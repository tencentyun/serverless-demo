// src/agent.ts
import {
  EventType,
  AbstractAgent
} from "@ag-ui/client";
import { Observable } from "rxjs";
import {
  Annotation,
  MessagesAnnotation,
  Command
} from "@langchain/langgraph";

// src/util.ts
import { DynamicStructuredTool } from "@langchain/core/tools";
import z from "zod/v4";
function convertActionsToDynamicStructuredTools(tools) {
  return tools.map(convertActionToDynamicStructuredTool);
}
function convertActionToDynamicStructuredTool(actionInput) {
  return new DynamicStructuredTool({
    name: actionInput.name,
    description: actionInput.description,
    schema: convertJsonSchemaToZodSchema(actionInput.parameters, true),
    func: async () => {
      return "";
    }
  });
}
function convertJsonSchemaToZodSchema(jsonSchema, required) {
  if (jsonSchema.type === "object") {
    const spec = {};
    if (!jsonSchema.properties || !Object.keys(jsonSchema.properties).length) {
      return !required ? z.object(spec).optional() : z.object(spec);
    }
    for (const [key, value] of Object.entries(jsonSchema.properties)) {
      spec[key] = convertJsonSchemaToZodSchema(
        value,
        jsonSchema.required ? jsonSchema.required.includes(key) : false
      );
    }
    let schema = z.object(spec).describe(jsonSchema.description);
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "string") {
    let schema = z.string().describe(jsonSchema.description);
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "number") {
    let schema = z.number().describe(jsonSchema.description);
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "boolean") {
    let schema = z.boolean().describe(jsonSchema.description);
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "array") {
    let itemSchema = convertJsonSchemaToZodSchema(jsonSchema.items, true);
    let schema = z.array(itemSchema).describe(jsonSchema.description);
    return required ? schema : schema.optional();
  }
  throw new Error("Invalid JSON schema");
}

// src/agent.ts
import { noopLogger, isErrorWithCode } from "@cloudbase/agent-shared";
var ClientPropertiesAnnotation = Annotation.Root({
  tools: Annotation
});
var ClientStateAnnotation = Annotation.Root({
  client: Annotation,
  ...MessagesAnnotation.spec
});
var LanggraphAgent = class extends AbstractAgent {
  constructor(agentConfig) {
    super(agentConfig);
    this.compiledWorkflow = agentConfig.compiledWorkflow;
    const baseLogger = agentConfig.logger ?? noopLogger;
    this.logger = baseLogger.child?.({ component: "langgraph-agent" }) ?? baseLogger;
  }
  run(input) {
    return new Observable((subscriber) => {
      this._run(subscriber, input);
    });
  }
  async _run(subscriber, input) {
    const { messages, runId, threadId } = input;
    const logger = this.logger.child?.({ runId, threadId }) ?? this.logger;
    logger.info?.("Run started");
    const runStartedEvent = {
      type: EventType.RUN_STARTED,
      threadId,
      runId
    };
    logger.trace?.({ aguiEvent: runStartedEvent }, "Emitting AGUI event");
    subscriber.next(runStartedEvent);
    const isResume = !!input.forwardedProps?.resume;
    const lastUserMessage = messages.filter((m) => m.role === "user").pop();
    logger.debug?.(
      {
        isResume,
        messageCount: messages.length,
        toolCount: input.tools?.length ?? 0,
        tools: input.tools?.map((t) => t.name),
        lastUserMessage: typeof lastUserMessage?.content === "string" ? lastUserMessage.content.slice(0, 200) : void 0
      },
      "Preparing stream input"
    );
    logger.trace?.({ messages, tools: input.tools }, "Full input messages");
    const langChainMessages = isResume ? void 0 : aguiMessagesToLangChain(messages);
    if (langChainMessages) {
      logger.trace?.(
        {
          langChainMessages,
          messageCount: langChainMessages.length,
          messageTypes: langChainMessages.map((m) => ({
            type: m.type,
            id: m.id,
            hasToolCalls: "tool_calls" in m && Array.isArray(m.tool_calls) && m.tool_calls.length > 0,
            toolCallId: "tool_call_id" in m ? m.tool_call_id : void 0
          }))
        },
        "Converted LangGraph messages"
      );
    }
    const streamEventInput = isResume ? new Command({
      resume: JSON.stringify(input.forwardedProps?.resume?.payload)
    }) : {
      messages: langChainMessages,
      client: {
        tools: convertActionsToDynamicStructuredTools(
          input.tools.map((x) => ({
            ...x,
            parameters: typeof x.parameters === "string" ? JSON.parse(x.parameters) : x.parameters
          }))
        )
      }
    };
    const stream = this.compiledWorkflow.streamEvents(streamEventInput, {
      version: "v2",
      runId,
      configurable: {
        thread_id: threadId
      }
    });
    logger.debug?.("Stream created, starting event processing");
    const chatModelRuns = [];
    const handledToolCallIds = /* @__PURE__ */ new Set();
    for (const msg of messages) {
      if (msg.role === "tool" && msg.toolCallId) {
        handledToolCallIds.add(msg.toolCallId);
      }
    }
    if (handledToolCallIds.size > 0) {
      logger.debug?.(
        { count: handledToolCallIds.size },
        "Pre-populated handled tool call IDs from input messages"
      );
    }
    let interrupt;
    let currentToolCall = null;
    let eventCount = 0;
    let toolCallCount = 0;
    let textChunkCount = 0;
    try {
      for await (const event of stream) {
        eventCount++;
        logger.trace?.(
          { eventType: event.event, eventCount, langGraphEvent: event },
          "Processing stream event"
        );
        if (event.event.startsWith("ChannelWrite<")) {
          continue;
        }
        if (event.event === "on_chat_model_start") {
          logger.debug?.(
            { chatModelRunId: event.run_id },
            "Chat model started"
          );
          chatModelRuns.push({ runId: event.run_id });
          continue;
        }
        if (event.event === "on_chat_model_stream") {
          const chatModelRun = chatModelRuns.find(
            (run) => run.runId === event.run_id
          );
          if (!chatModelRun) {
            logger.warn?.(
              { chatModelRunId: event.run_id },
              "Received message from unknown chat model run"
            );
            subscriber.next({
              type: EventType.RUN_ERROR,
              code: "INTERNAL_ERROR",
              message: `Received a message from an unknown chat model run. Run Id: ${event.run_id}`
            });
            continue;
          }
          const chunkId = event.data.chunk.id;
          if (!chatModelRun.messageId) {
            chatModelRun.messageId = chunkId;
            const textStartEvent = {
              messageId: chunkId,
              type: EventType.TEXT_MESSAGE_START,
              role: "assistant"
            };
            logger.debug?.({ messageId: chunkId }, "Text message started");
            logger.trace?.(
              { aguiEvent: textStartEvent },
              "Emitting AGUI event"
            );
            subscriber.next(textStartEvent);
          } else if (chatModelRun.messageId !== chunkId) {
            logger.warn?.(
              {
                expectedMessageId: chatModelRun.messageId,
                receivedMessageId: chunkId,
                chatModelRunId: event.run_id
              },
              "Received message with unexpected ID"
            );
            subscriber.next({
              type: EventType.RUN_ERROR,
              code: "INTERNAL_ERROR",
              message: `Received a message of unknown message id from current run. Run Id: ${event.run_id} Message Id from current run: ${chatModelRun.messageId} Message Id from received message: ${chunkId}`
            });
            continue;
          }
          if (Array.isArray(event.data.chunk?.tool_call_chunks) && event.data.chunk?.tool_call_chunks?.length > 0) {
            const parentMessageId = chatModelRun.messageId;
            event.data.chunk.tool_call_chunks.map((x) => ({
              ...x,
              args: typeof x.args === "string" ? x.args : x.args ? JSON.stringify(x.args) : ""
            })).forEach((toolCall) => {
              if (currentToolCall) {
                if (toolCall.id && currentToolCall.id !== toolCall.id) {
                  const toolEndEvent = {
                    toolCallId: currentToolCall.id,
                    type: EventType.TOOL_CALL_END
                  };
                  logger.debug?.(
                    {
                      toolCallId: currentToolCall.id,
                      toolCallName: currentToolCall.name
                    },
                    "Tool call ended"
                  );
                  logger.trace?.(
                    { aguiEvent: toolEndEvent },
                    "Emitting AGUI event"
                  );
                  subscriber.next(toolEndEvent);
                  if (toolCall.name && toolCall.id) {
                    currentToolCall = toolCall;
                    toolCallCount++;
                    const toolStartEvent = {
                      toolCallId: currentToolCall.id,
                      toolCallName: currentToolCall.name,
                      parentMessageId,
                      type: EventType.TOOL_CALL_START
                    };
                    logger.debug?.(
                      {
                        toolCallId: toolCall.id,
                        toolCallName: toolCall.name
                      },
                      "Tool call started"
                    );
                    logger.trace?.(
                      { aguiEvent: toolStartEvent },
                      "Emitting AGUI event"
                    );
                    subscriber.next(toolStartEvent);
                    if (currentToolCall.args) {
                      const toolArgsEvent = {
                        toolCallId: currentToolCall.id,
                        delta: currentToolCall.args,
                        type: EventType.TOOL_CALL_ARGS
                      };
                      logger.trace?.(
                        { aguiEvent: toolArgsEvent },
                        "Emitting AGUI event"
                      );
                      subscriber.next(toolArgsEvent);
                      if (isValidJson(currentToolCall.args)) {
                        const toolEndEvent2 = {
                          toolCallId: currentToolCall.id,
                          type: EventType.TOOL_CALL_END
                        };
                        logger.debug?.(
                          { toolCallId: currentToolCall.id },
                          "Tool call ended (args complete)"
                        );
                        logger.trace?.(
                          { aguiEvent: toolEndEvent2 },
                          "Emitting AGUI event"
                        );
                        subscriber.next(toolEndEvent2);
                        currentToolCall = null;
                      }
                    }
                  }
                } else {
                  if (toolCall.args) {
                    currentToolCall.args += toolCall.args;
                    const toolArgsEvent = {
                      toolCallId: currentToolCall.id,
                      delta: toolCall.args,
                      type: EventType.TOOL_CALL_ARGS
                    };
                    logger.trace?.(
                      { aguiEvent: toolArgsEvent },
                      "Emitting AGUI event"
                    );
                    subscriber.next(toolArgsEvent);
                    if (isValidJson(currentToolCall.args)) {
                      const toolEndEvent = {
                        toolCallId: currentToolCall.id,
                        type: EventType.TOOL_CALL_END
                      };
                      logger.debug?.(
                        { toolCallId: currentToolCall.id },
                        "Tool call ended (args complete)"
                      );
                      logger.trace?.(
                        { aguiEvent: toolEndEvent },
                        "Emitting AGUI event"
                      );
                      subscriber.next(toolEndEvent);
                      currentToolCall = null;
                    }
                  }
                }
              } else {
                if (toolCall.name && toolCall.id) {
                  currentToolCall = toolCall;
                  toolCallCount++;
                  const toolStartEvent = {
                    toolCallId: toolCall.id,
                    toolCallName: toolCall.name,
                    parentMessageId,
                    type: EventType.TOOL_CALL_START
                  };
                  logger.debug?.(
                    { toolCallId: toolCall.id, toolCallName: toolCall.name },
                    "Tool call started"
                  );
                  logger.trace?.(
                    { aguiEvent: toolStartEvent },
                    "Emitting AGUI event"
                  );
                  subscriber.next(toolStartEvent);
                  if (toolCall.args) {
                    const toolArgsEvent = {
                      toolCallId: toolCall.id,
                      delta: toolCall.args,
                      type: EventType.TOOL_CALL_ARGS
                    };
                    logger.trace?.(
                      { aguiEvent: toolArgsEvent },
                      "Emitting AGUI event"
                    );
                    subscriber.next(toolArgsEvent);
                    if (isValidJson(toolCall.args)) {
                      const toolEndEvent = {
                        toolCallId: toolCall.id,
                        type: EventType.TOOL_CALL_END
                      };
                      logger.debug?.(
                        { toolCallId: toolCall.id },
                        "Tool call ended (args complete)"
                      );
                      logger.trace?.(
                        { aguiEvent: toolEndEvent },
                        "Emitting AGUI event"
                      );
                      subscriber.next(toolEndEvent);
                      currentToolCall = null;
                    }
                  }
                }
              }
            });
          }
          const delta = event.data.chunk.content;
          if (typeof delta === "string" && delta) {
            textChunkCount++;
            const textContentEvent = {
              messageId: chatModelRun.messageId,
              type: EventType.TEXT_MESSAGE_CONTENT,
              delta
            };
            logger.trace?.(
              { aguiEvent: textContentEvent },
              "Emitting AGUI event"
            );
            subscriber.next(textContentEvent);
          }
          continue;
        }
        if (event.event === "on_chat_model_end") {
          const chatModelRun = chatModelRuns.find(
            (run) => run.runId === event.run_id
          );
          if (!chatModelRun) {
            logger.warn?.(
              { chatModelRunId: event.run_id },
              "Received on_chat_model_end from unknown run"
            );
            subscriber.next({
              type: EventType.RUN_ERROR,
              code: "INTERNAL_ERROR",
              message: `Received a on_chat_model_end event from an unknown chat model run. Run Id: ${event.run_id}`
            });
            continue;
          }
          const textEndEvent = {
            type: EventType.TEXT_MESSAGE_END,
            messageId: chatModelRun.messageId
          };
          logger.debug?.(
            { messageId: chatModelRun.messageId },
            "Text message ended"
          );
          logger.trace?.({ aguiEvent: textEndEvent }, "Emitting AGUI event");
          subscriber.next(textEndEvent);
          continue;
        }
        if (event.event === "on_tool_end") {
          const toolMessage = event.data.output;
          if (toolMessage && toolMessage.tool_call_id) {
            if (!handledToolCallIds.has(toolMessage.tool_call_id)) {
              if (!toolMessage.id) {
                toolMessage.id = crypto.randomUUID();
                if (toolMessage.lc_kwargs) {
                  toolMessage.lc_kwargs.id = toolMessage.id;
                }
              }
              const toolResultEvent = {
                toolCallId: toolMessage.tool_call_id,
                type: EventType.TOOL_CALL_RESULT,
                content: typeof toolMessage.content === "string" ? toolMessage.content : JSON.stringify(toolMessage.content),
                messageId: toolMessage.id
              };
              logger.debug?.(
                {
                  toolCallId: toolMessage.tool_call_id,
                  messageId: toolMessage.id
                },
                "Tool call result received"
              );
              logger.trace?.(
                { aguiEvent: toolResultEvent },
                "Emitting AGUI event"
              );
              subscriber.next(toolResultEvent);
              handledToolCallIds.add(toolMessage.tool_call_id);
            } else {
              logger.trace?.(
                { toolCallId: toolMessage.tool_call_id },
                "Skipping duplicate tool call result"
              );
            }
          }
          continue;
        }
        if (event.event === "on_chain_stream") {
          const chunk = event.data.chunk;
          if (chunk?.messages && Array.isArray(chunk.messages)) {
            logger.trace?.(
              {
                nodeName: event.name,
                stateMessages: chunk.messages.map((m) => ({
                  type: m.type,
                  id: m.id,
                  contentPreview: typeof m.content === "string" ? m.content.slice(0, 100) : "[non-string content]",
                  hasToolCalls: "tool_calls" in m && Array.isArray(m.tool_calls) && m.tool_calls.length > 0,
                  toolCallId: "tool_call_id" in m ? m.tool_call_id : void 0
                })),
                messageCount: chunk.messages.length
              },
              "State update with messages"
            );
          }
          if (chunk?.__interrupt__ && Array.isArray(chunk.__interrupt__) && chunk.__interrupt__.length > 0) {
            const rawInterrupt = chunk.__interrupt__[0];
            logger.debug?.(
              { interruptId: rawInterrupt.id },
              "Interrupt received"
            );
            interrupt = {
              id: rawInterrupt.id,
              // TODO: replace with actual reason
              reason: "agent requested interrupt",
              payload: rawInterrupt.value
            };
          }
        }
      }
      const stats = { eventCount, toolCallCount, textChunkCount };
      if (interrupt) {
        const runFinishedEvent = {
          type: EventType.RUN_FINISHED,
          threadId,
          runId,
          outcome: "interrupt",
          interrupt
        };
        logger.info?.(
          { outcome: "interrupt", interruptId: interrupt.id, ...stats },
          "Run finished with interrupt"
        );
        logger.trace?.({ aguiEvent: runFinishedEvent }, "Emitting AGUI event");
        subscriber.next(runFinishedEvent);
      } else {
        const runFinishedEvent = {
          type: EventType.RUN_FINISHED,
          threadId,
          runId
        };
        logger.info?.({ outcome: "complete", ...stats }, "Run finished");
        logger.trace?.({ aguiEvent: runFinishedEvent }, "Emitting AGUI event");
        subscriber.next(runFinishedEvent);
      }
    } catch (error) {
      logger.error?.(
        { err: error, eventCount, toolCallCount, textChunkCount },
        "Error during stream processing"
      );
      const errorCode = isErrorWithCode(error) ? error.code : "INTERNAL_ERROR";
      const errorMessage = error instanceof Error ? error.message : String(error);
      subscriber.next({
        type: EventType.RUN_ERROR,
        code: errorCode,
        message: errorMessage
      });
    }
    subscriber.complete();
  }
  clone() {
    const workflow = this.compiledWorkflow;
    const logger = this.logger;
    this.compiledWorkflow = void 0;
    const cloned = super.clone();
    this.compiledWorkflow = workflow;
    cloned.compiledWorkflow = workflow;
    cloned.logger = logger;
    return cloned;
  }
};
function aguiMessagesToLangChain(messages) {
  return messages.map((message, index) => {
    switch (message.role) {
      case "user":
        if (typeof message.content === "string") {
          return {
            id: message.id,
            role: message.role,
            content: message.content,
            type: "human"
          };
        } else {
          return {
            id: message.id,
            role: message.role,
            content: message.content.filter((m) => m.type === "text"),
            type: "human"
          };
        }
      case "assistant":
        return {
          id: message.id,
          type: "ai",
          role: message.role,
          content: message.content ?? "",
          tool_calls: (message.toolCalls ?? []).map((tc) => ({
            id: tc.id,
            name: tc.function.name,
            args: JSON.parse(tc.function.arguments),
            type: "tool_call"
          }))
        };
      case "system":
        return {
          id: message.id,
          role: message.role,
          content: message.content,
          type: "system"
        };
      case "tool":
        return {
          content: message.content,
          role: message.role,
          type: message.role,
          tool_call_id: message.toolCallId,
          id: message.id
        };
      default:
        throw new Error(`Message role ${message.role} is not supported.`);
    }
  });
}
function isValidJson(json) {
  try {
    JSON.parse(json);
    return true;
  } catch (e) {
    return false;
  }
}

// src/checkpoint.ts
import {
  BaseCheckpointSaver
} from "@langchain/langgraph";
import {
  MemoryClient,
  Order
} from "@cloudbase/agent-agents";
var TDAISaver = class extends BaseCheckpointSaver {
  constructor(config) {
    super();
    const {
      checkpointType = "checkpoints",
      checkpointWritesType = "checkpoint_writes",
      ...clientConfig
    } = config;
    this.memoryClient = new MemoryClient(clientConfig);
    this.checkpointType = checkpointType;
    this.checkpointWritesType = checkpointWritesType;
  }
  /**
   * Retrieves a checkpoint from TDAI Memory based on the provided config.
   * If the config contains a "checkpoint_id" key, the checkpoint with the matching
   * thread ID and checkpoint ID is retrieved. Otherwise, the latest checkpoint
   * for the given thread ID is retrieved.
   */
  async getTuple(config) {
    try {
      const {
        thread_id,
        checkpoint_ns = "",
        checkpoint_id
      } = config.configurable ?? {};
      if (!thread_id) {
        return void 0;
      }
      const query = {
        collection: this.checkpointType,
        checkpoint_ns
      };
      if (checkpoint_id) {
        query.checkpoint_id = checkpoint_id;
      }
      const { events = [] } = await this.memoryClient.queryEvents({
        sessionId: thread_id,
        where: query,
        orderBy: { checkpoint_id: Order.DESCENDING },
        limit: 1
      });
      if (events.length === 0) {
        return void 0;
      }
      const doc = events[0];
      const configurableValues = {
        checkpoint_ns,
        checkpoint_id: doc.checkpoint_id
      };
      const checkpoint = doc.checkpoint;
      const { events: serializedWrites = [] } = await this.memoryClient.queryEvents({
        sessionId: thread_id,
        where: {
          collection: this.checkpointWritesType,
          ...configurableValues
        }
      });
      const pendingWrites = serializedWrites.map(
        (serializedWrite) => {
          return [
            serializedWrite.task_id,
            serializedWrite.channel,
            serializedWrite.value
          ];
        }
      );
      const metadata = doc.metadata || {};
      return {
        config: { configurable: configurableValues },
        checkpoint,
        pendingWrites,
        metadata,
        parentConfig: doc.parent_checkpoint_id != null ? {
          configurable: {
            thread_id,
            checkpoint_ns,
            checkpoint_id: doc.parent_checkpoint_id
          }
        } : void 0
      };
    } catch (error) {
      console.error("Error getting checkpoint:", error);
      return void 0;
    }
  }
  /**
   * Retrieve a list of checkpoint tuples from TDAI Memory based on the provided config.
   * The checkpoints are ordered by checkpoint ID in descending order (newest first).
   */
  async *list(config, options) {
    const { limit, before, filter } = options ?? {};
    if (!config?.configurable?.thread_id) {
      throw new Error("Thread ID is required");
    }
    const query = {
      collection: this.checkpointType
    };
    if (config?.configurable?.checkpoint_ns !== void 0 && config?.configurable?.checkpoint_ns !== null) {
      query.checkpoint_ns = config.configurable.checkpoint_ns;
    }
    if (filter) {
      Object.entries(filter).forEach(([key, value]) => {
        query[`metadata.${key}`] = value;
      });
    }
    if (before) {
      query.checkpoint_id = { $lt: before.configurable?.checkpoint_id };
    }
    const { events = [] } = await this.memoryClient.queryEvents({
      sessionId: config?.configurable?.thread_id || "default",
      where: query,
      orderBy: { checkpoint_id: Order.DESCENDING },
      limit
    });
    for (const doc of events) {
      const checkpoint = doc.checkpoint;
      const metadata = doc.metadata || {};
      yield {
        config: {
          configurable: {
            thread_id: doc.thread_id,
            checkpoint_ns: doc.checkpoint_ns,
            checkpoint_id: doc.checkpoint_id
          }
        },
        checkpoint,
        metadata,
        parentConfig: doc.parent_checkpoint_id ? {
          configurable: {
            thread_id: doc.thread_id,
            checkpoint_ns: doc.checkpoint_ns,
            checkpoint_id: doc.parent_checkpoint_id
          }
        } : void 0
      };
    }
  }
  /**
   * Saves a checkpoint to TDAI Memory. The checkpoint is associated with the
   * provided config and its parent config (if any).
   */
  async put(config, checkpoint, metadata) {
    try {
      const thread_id = config.configurable?.thread_id;
      const checkpoint_ns = config.configurable?.checkpoint_ns ?? "";
      const checkpoint_id = checkpoint.id;
      if (thread_id === void 0) {
        throw new Error(
          `The provided config must contain a configurable field with a "thread_id" field.`
        );
      }
      const doc = {
        collection: this.checkpointType,
        checkpoint_ns,
        checkpoint_id,
        parent_checkpoint_id: config.configurable?.checkpoint_id,
        checkpoint,
        metadata
      };
      const { events = [] } = await this.memoryClient.queryEvents({
        sessionId: thread_id,
        where: {
          collection: this.checkpointType,
          checkpoint_ns,
          checkpoint_id
        }
      });
      if (events[0]) {
        this.memoryClient.deleteEvent({
          sessionId: thread_id,
          eventId: events[0].id
          //   messages: doc,
        });
      } else {
        await this.memoryClient.appendEvent({
          sessionId: thread_id,
          messages: doc
        });
      }
      return {
        configurable: {
          thread_id,
          checkpoint_ns,
          checkpoint_id
        }
      };
    } catch (error) {
      console.error("Error saving checkpoint:", error);
      throw error;
    }
  }
  /**
   * Saves intermediate writes associated with a checkpoint to TDAI Memory.
   */
  async putWrites(config, writes, taskId) {
    try {
      const thread_id = config.configurable?.thread_id;
      const checkpoint_ns = config.configurable?.checkpoint_ns;
      const checkpoint_id = config.configurable?.checkpoint_id;
      if (thread_id === void 0 || checkpoint_ns === void 0 || checkpoint_id === void 0) {
        throw new Error(
          `The provided config must contain a configurable field with "thread_id", "checkpoint_ns" and "checkpoint_id" fields.`
        );
      }
      const writePromises = writes.map(async ([channel, value], idx) => {
        const writeDoc = {
          collection: this.checkpointWritesType,
          checkpoint_ns,
          checkpoint_id,
          task_id: taskId,
          idx,
          channel,
          value
          // Store directly as JSON
        };
        return this.memoryClient.appendEvent({
          sessionId: thread_id,
          messages: writeDoc
        });
      });
      await Promise.all(writePromises);
    } catch (error) {
      console.error("Error storing writes:", error);
      throw error;
    }
  }
  /**
   * Delete all checkpoints and writes for a thread from TDAI Memory.
   */
  async deleteThread(threadId) {
    try {
      await this.memoryClient.deleteSession({
        sessionId: threadId
      });
    } catch (error) {
      console.error("Error deleting thread:", error);
      throw error;
    }
  }
  /**
   * Close the memory client connection
   */
  close() {
    this.memoryClient.close();
  }
};

// src/store/tdai-store.ts
import {
  BaseStore
} from "@langchain/langgraph";
var TDAIStore = class extends BaseStore {
  constructor(config) {
    super();
    this.isSetup = false;
    this.isClosed = false;
    this.client = config.memoryClient;
    this.namespacePrefix = config.namespacePrefix || [];
    this.ttlConfig = config.ttl;
    this.ensureTables = config.ensureTables ?? true;
    this.sessionId = config.sessionId || "default_session";
    this.defaultStrategy = config.defaultStrategy || "store";
  }
  /**
   * Create a storage key from namespace and key
   */
  createStorageKey(namespace, key) {
    const fullNamespace = [...this.namespacePrefix, ...namespace];
    return `${fullNamespace.join(":")}:${key}`;
  }
  /**
   * Parse a storage key back to namespace and key
   */
  parseStorageKey(storageKey) {
    const parts = storageKey.split(":");
    const prefixLength = this.namespacePrefix.length;
    const namespace = parts.slice(prefixLength, -1);
    const key = parts[parts.length - 1];
    return { namespace, key };
  }
  /**
   * Put an item with optional TTL.
   */
  async put(namespace, key, value, index, options) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const storageKey = this.createStorageKey(namespace, key);
    const content = JSON.stringify({
      storageKey,
      namespace,
      key,
      value,
      index,
      ttl: options?.ttl || this.ttlConfig?.defaultTtlSeconds
    });
    await this.client.appendRecord({
      sessionId: this.sessionId,
      content,
      strategy: this.defaultStrategy
    });
  }
  /**
   * Get an item by namespace and key.
   */
  async get(namespace, key) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const storageKey = this.createStorageKey(namespace, key);
    try {
      const { records = [] } = await this.client.searchRecords({
        content: storageKey,
        sessionId: this.sessionId,
        limit: 1
      });
      if (!records.length) {
        return null;
      }
      const record = records[0];
      const data = JSON.parse(record.record_content);
      if (data.ttl && record.created_at) {
        const createdTime = new Date(record.created_at).getTime();
        const now = Date.now();
        if (now > createdTime + data.ttl * 1e3) {
          await this.delete(namespace, key);
          return null;
        }
      }
      return {
        namespace,
        key,
        value: data.value,
        createdAt: new Date(record.created_at || Date.now()),
        updatedAt: new Date(record.updated_at || Date.now())
      };
    } catch (error) {
      return null;
    }
  }
  /**
   * Delete an item by namespace and key.
   */
  async delete(namespace, key) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const storageKey = this.createStorageKey(namespace, key);
    try {
      const { records = [] } = await this.client.searchRecords({
        content: storageKey,
        sessionId: this.sessionId,
        limit: 1
      });
      const record = records[0];
      if (record) {
        await this.client.deleteRecord({
          sessionId: this.sessionId,
          recordId: record.record_id
        });
      }
    } catch (error) {
    }
  }
  /**
   * List namespaces with optional filtering.
   */
  async listNamespaces(options = {}) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const { prefix, suffix, maxDepth, limit = 100, offset = 0 } = options;
    try {
      const { records = [] } = await this.client.queryRecords({
        limit: 1e3
        // Large limit to get all records
      });
      const namespaceSet = /* @__PURE__ */ new Set();
      for (const record of records) {
        try {
          const data = JSON.parse(record.record_content);
          if (data.namespace) {
            const namespace = data.namespace;
            if (prefix && prefix.length > 0) {
              const hasPrefix = prefix.every((p, i) => namespace[i] === p);
              if (!hasPrefix) continue;
            }
            if (suffix && suffix.length > 0) {
              const namespaceSuffix = namespace.slice(-suffix.length);
              if (JSON.stringify(namespaceSuffix) !== JSON.stringify(suffix)) {
                continue;
              }
            }
            if (maxDepth !== void 0 && namespace.length > maxDepth) {
              continue;
            }
            namespaceSet.add(JSON.stringify(namespace));
          }
        } catch (error) {
        }
      }
      const namespaces = Array.from(namespaceSet).map((ns) => JSON.parse(ns)).sort().slice(offset, offset + limit);
      return namespaces;
    } catch (error) {
      return [];
    }
  }
  /**
   * Execute multiple operations in a single batch.
   */
  async batch(operations) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const results = [];
    for (const operation of operations) {
      if ("namespacePrefix" in operation) {
        results.push(await this.executeSearch(operation));
      } else if ("key" in operation && !("value" in operation)) {
        const getOp = operation;
        results.push(await this.get(getOp.namespace, getOp.key));
      } else if ("value" in operation) {
        const putOp = operation;
        if (putOp.value !== null) {
          await this.put(
            putOp.namespace,
            putOp.key,
            putOp.value,
            putOp.index,
            putOp.options
          );
        }
        results.push(void 0);
      } else if ("matchConditions" in operation) {
        const listOp = operation;
        results.push(await this.executeListNamespaces(listOp));
      } else {
        throw new Error(
          `Unsupported operation type: ${JSON.stringify(operation)}`
        );
      }
    }
    return results;
  }
  /**
   * Execute search operation
   */
  async executeSearch(operation) {
    const { namespacePrefix, ...searchOptions } = operation;
    return this.search(namespacePrefix, searchOptions);
  }
  /**
   * Execute list namespaces operation
   */
  async executeListNamespaces(operation) {
    const { matchConditions, maxDepth, limit = 100, offset = 0 } = operation;
    let prefix;
    let suffix;
    if (matchConditions && matchConditions.length > 0) {
      for (const condition of matchConditions) {
        if (condition.matchType === "prefix") {
          prefix = condition.path;
        } else if (condition.matchType === "suffix") {
          suffix = condition.path;
        }
      }
    }
    return this.listNamespaces({
      prefix,
      suffix,
      maxDepth,
      limit,
      offset
    });
  }
  /**
   * Initialize the store.
   */
  async setup() {
    if (this.isSetup) return;
    if (this.ttlConfig?.sweepIntervalMinutes) {
      const intervalMs = this.ttlConfig.sweepIntervalMinutes * 60 * 1e3;
      this.sweepInterval = setInterval(async () => {
        try {
          await this.sweepExpiredItems();
        } catch (error) {
          console.error("Error during TTL sweep:", error);
        }
      }, intervalMs);
    }
    this.isSetup = true;
  }
  /**
   * Start the store.
   */
  async start() {
    if (this.ensureTables && !this.isSetup) {
      await this.setup();
    }
  }
  /**
   * Stop the store and close all connections.
   */
  async stop() {
    if (this.isClosed) return;
    if (this.sweepInterval) {
      clearInterval(this.sweepInterval);
      this.sweepInterval = void 0;
    }
    this.client.close();
    this.isClosed = true;
  }
  /**
   * Manually sweep expired items from the store.
   */
  async sweepExpiredItems() {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    try {
      const { records = [] } = await this.client.queryRecords({
        limit: 1e3
      });
      let cleanedCount = 0;
      const now = Date.now();
      for (const record of records) {
        try {
          const data = JSON.parse(record.record_content);
          if (data.ttl && data.createdAt) {
            const createdTime = new Date(data.createdAt).getTime();
            if (now > createdTime + data.ttl * 1e3) {
              await this.client.deleteRecord({
                sessionId: this.sessionId,
                recordId: record.record_id
              });
              cleanedCount++;
            }
          }
        } catch (error) {
        }
      }
      return cleanedCount;
    } catch (error) {
      return 0;
    }
  }
  /**
   * Get statistics about the store.
   */
  async getStats() {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    try {
      const { records = [] } = await this.client.queryRecords({
        limit: 1e3
      });
      let totalItems = 0;
      let expiredItems = 0;
      const namespaces = /* @__PURE__ */ new Set();
      const dates = [];
      const now = Date.now();
      for (const record of records) {
        try {
          const data = JSON.parse(record.record_content);
          totalItems++;
          if (data.namespace) {
            namespaces.add(data.namespace.join(":"));
          }
          if (data.createdAt) {
            dates.push(new Date(data.createdAt));
          }
          if (data.ttl && data.createdAt) {
            const createdTime = new Date(data.createdAt).getTime();
            if (now > createdTime + data.ttl * 1e3) {
              expiredItems++;
            }
          }
        } catch (error) {
        }
      }
      const oldestItem = dates.length > 0 ? new Date(Math.min(...dates.map((d) => d.getTime()))) : null;
      const newestItem = dates.length > 0 ? new Date(Math.max(...dates.map((d) => d.getTime()))) : null;
      return {
        totalItems,
        expiredItems,
        namespaceCount: namespaces.size,
        oldestItem,
        newestItem
      };
    } catch (error) {
      return {
        totalItems: 0,
        expiredItems: 0,
        namespaceCount: 0,
        oldestItem: null,
        newestItem: null
      };
    }
  }
  /**
   * Search for items in the store with support for text search and filtering.
   */
  async search(namespacePrefix, options = {}) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const { filter, query, limit = 10, offset = 0, refreshTtl } = options;
    try {
      const namespaceKey = [...this.namespacePrefix, ...namespacePrefix].join(
        ":"
      );
      let searchResult;
      if (query) {
        searchResult = await this.client.searchRecords({
          content: query,
          limit: limit + offset
        });
      } else {
        searchResult = await this.client.queryRecords({
          limit: limit + offset
        });
      }
      const items = [];
      const now = Date.now();
      if (searchResult.records) {
        for (const record of searchResult.records.slice(
          offset,
          offset + limit
        )) {
          try {
            const data = JSON.parse(record.record_content);
            if (namespaceKey && !data.storageKey?.startsWith(namespaceKey)) {
              continue;
            }
            if (data.ttl && data.createdAt) {
              const createdTime = new Date(data.createdAt).getTime();
              if (now > createdTime + data.ttl * 1e3) {
                continue;
              }
            }
            if (filter) {
              let matches = true;
              for (const [key, value] of Object.entries(filter)) {
                if (data.value[key] !== value) {
                  matches = false;
                  break;
                }
              }
              if (!matches) continue;
            }
            const item = {
              namespace: data.namespace,
              key: data.key,
              value: data.value,
              createdAt: new Date(record.created_at || Date.now()),
              updatedAt: new Date(record.updated_at || Date.now())
            };
            items.push(item);
            if (refreshTtl && this.ttlConfig?.defaultTtlSeconds) {
              await this.put(data.namespace, data.key, data.value, void 0, {
                ttl: this.ttlConfig.defaultTtlSeconds
              });
            }
          } catch (error) {
          }
        }
      }
      return items;
    } catch (error) {
      return [];
    }
  }
};

// src/index.ts
import { noopLogger as noopLogger2, createConsoleLogger } from "@cloudbase/agent-shared";
export {
  ClientPropertiesAnnotation,
  ClientStateAnnotation,
  LanggraphAgent,
  TDAISaver,
  TDAIStore,
  createConsoleLogger,
  noopLogger2 as noopLogger
};
//# sourceMappingURL=index.mjs.map