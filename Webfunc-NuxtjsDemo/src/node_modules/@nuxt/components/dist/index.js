'use strict';

const fs2 = require('fs');
const path = require('upath');
const chokidar2 = require('chokidar');
const chalk2 = require('chalk');
const semver2 = require('semver');
const globby2 = require('globby');
const lodash = require('lodash');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

const fs2__default = /*#__PURE__*/_interopDefaultLegacy(fs2);
const path__default = /*#__PURE__*/_interopDefaultLegacy(path);
const chokidar2__default = /*#__PURE__*/_interopDefaultLegacy(chokidar2);
const chalk2__default = /*#__PURE__*/_interopDefaultLegacy(chalk2);
const semver2__default = /*#__PURE__*/_interopDefaultLegacy(semver2);
const globby2__default = /*#__PURE__*/_interopDefaultLegacy(globby2);

function requireNuxtVersion(currentVersion, requiredVersion) {
  const pkgName = require("../package.json").name;
  if (!currentVersion || !requireNuxtVersion) {
    return;
  }
  const _currentVersion = semver2__default['default'].coerce(currentVersion);
  const _requiredVersion = semver2__default['default'].coerce(requiredVersion);
  if (semver2__default['default'].lt(_currentVersion, _requiredVersion)) {
    throw new Error(`

      ${chalk2__default['default'].cyan(pkgName)} is not compatible with your current Nuxt version : ${chalk2__default['default'].yellow("v" + currentVersion)}

      Required: ${chalk2__default['default'].green("v" + requiredVersion)} or ${chalk2__default['default'].cyan("higher")}
    `);
  }
}

const LAZY_PREFIX = "lazy";
const pascalCase = (str) => {
  const isFirstCharUppercase = str[0] === str[0].toUpperCase();
  const containsHyphens = str.includes("-");
  const shouldTransformToPascal = !isFirstCharUppercase || containsHyphens;
  return shouldTransformToPascal ? lodash.upperFirst(lodash.camelCase(str)) : str;
};
function sortDirsByPathLength({path: pathA}, {path: pathB}) {
  return pathB.split(/[\\/]/).filter(Boolean).length - pathA.split(/[\\/]/).filter(Boolean).length;
}
function prefixComponent(prefix = "", {pascalName, kebabName, ...rest}) {
  return {
    pascalName: pascalName.startsWith(prefix) ? pascalName : pascalCase(prefix) + pascalName,
    kebabName: kebabName.startsWith(prefix) ? kebabName : `${lodash.kebabCase(prefix)}-${kebabName}`,
    ...rest
  };
}
async function scanComponents(dirs, srcDir) {
  const components = [];
  const filePaths = new Set();
  const scannedPaths = [];
  for (const {path: path$1, pattern, ignore = [], prefix, extendComponent, global, level} of dirs.sort(sortDirsByPathLength)) {
    const resolvedNames = new Map();
    for (const _file of await globby2__default['default'](pattern, {cwd: path$1, ignore})) {
      const filePath = path.join(path$1, _file);
      if (scannedPaths.find((d) => filePath.startsWith(d))) {
        continue;
      }
      if (filePaths.has(filePath)) {
        continue;
      }
      filePaths.add(filePath);
      let fileName = path.basename(filePath, path.extname(filePath));
      if (fileName === "index") {
        fileName = path.basename(path.dirname(filePath), path.extname(filePath));
      }
      if (resolvedNames.has(fileName)) {
        console.warn(`Two component files resolving to the same name \`${fileName}\`:

 - ${filePath}
 - ${resolvedNames.get(fileName)}`);
        continue;
      }
      resolvedNames.set(fileName, filePath);
      const pascalName = pascalCase(fileName);
      const kebabName = lodash.kebabCase(fileName);
      const shortPath = filePath.replace(srcDir, "");
      const chunkName = "components/" + kebabName.replace(/-/g, "/");
      let _c = prefixComponent(prefix, {
        filePath,
        pascalName,
        kebabName,
        chunkName,
        shortPath,
        import: "",
        asyncImport: "",
        export: "default",
        global: Boolean(global),
        level: Number(level)
      });
      if (typeof extendComponent === "function") {
        _c = await extendComponent(_c) || _c;
      }
      const _import = _c.import || `require('${_c.filePath}').${_c.export}`;
      const _asyncImport = _c.asyncImport || `function () { return import('${_c.filePath}' /* webpackChunkName: "${_c.chunkName}" */).then(function(m) { return m['${_c.export}'] || m }) }`;
      const component = {
        ..._c,
        import: _import
      };
      const lazyComponent = prefixComponent(LAZY_PREFIX, {
        ..._c,
        async: true,
        import: _asyncImport
      });
      const definedComponent = components.find((c) => c.pascalName === component.pascalName);
      if (definedComponent && component.level < definedComponent.level) {
        Object.assign(definedComponent, component);
        const definedLazyComponent = components.find((c) => c.pascalName === lazyComponent.pascalName);
        definedLazyComponent && Object.assign(definedLazyComponent, lazyComponent);
      } else if (!definedComponent) {
        components.push(component);
        components.push(lazyComponent);
      }
    }
    scannedPaths.push(path$1);
  }
  return components;
}

const isPureObjectOrString = (val) => !Array.isArray(val) && typeof val === "object" || typeof val === "string";
const getDir = (p) => fs2__default['default'].statSync(p).isDirectory() ? p : path__default['default'].dirname(p);
const componentsModule = function() {
  var _a;
  const {nuxt} = this;
  const {components} = nuxt.options;
  if (!components) {
    return;
  }
  requireNuxtVersion((_a = nuxt == null ? void 0 : nuxt.constructor) == null ? void 0 : _a.version, "2.10");
  const options = {
    dirs: ["~/components"],
    ...Array.isArray(components) ? {dirs: components} : components
  };
  nuxt.hook("build:before", async (builder) => {
    const nuxtIgnorePatterns = builder.ignore.ignore ? builder.ignore.ignore._rules.map((rule) => rule.pattern) : [];
    await nuxt.callHook("components:dirs", options.dirs);
    const resolvePath = (dir) => nuxt.resolver.resolvePath(dir);
    try {
      const globalDir = getDir(resolvePath("~/components/global"));
      if (!options.dirs.find((dir) => resolvePath(dir) === globalDir)) {
        options.dirs.push({
          path: globalDir,
          global: true
        });
      }
    } catch (err) {
      nuxt.options.watch.push(path__default['default'].resolve(nuxt.options.srcDir, "components", "global"));
    }
    const componentDirs = options.dirs.filter(isPureObjectOrString).map((dir) => {
      const dirOptions = typeof dir === "object" ? dir : {path: dir};
      let dirPath = dirOptions.path;
      try {
        dirPath = getDir(nuxt.resolver.resolvePath(dirOptions.path));
      } catch (err) {
      }
      const transpile = typeof dirOptions.transpile === "boolean" ? dirOptions.transpile : "auto";
      if (dirOptions.global === "dev") {
        dirOptions.global = nuxt.options.dev;
      }
      dirOptions.level = Number(dirOptions.level || 0);
      const enabled = fs2__default['default'].existsSync(dirPath);
      if (!enabled && dirOptions.path !== "~/components") {
        console.warn("Components directory not found: `" + dirPath + "`");
      }
      const extensions = dirOptions.extensions || builder.supportedExtensions;
      return {
        ...dirOptions,
        enabled,
        path: dirPath,
        extensions,
        pattern: dirOptions.pattern || `**/*.{${extensions.join(",")},}`,
        ignore: [
          "**/*.stories.js",
          ...nuxtIgnorePatterns,
          ...dirOptions.ignore || []
        ],
        transpile: transpile === "auto" ? dirPath.includes("node_modules") : transpile
      };
    }).filter((d) => d.enabled);
    nuxt.options.build.transpile.push(...componentDirs.filter((dir) => dir.transpile).map((dir) => dir.path));
    let components2 = await scanComponents(componentDirs, nuxt.options.srcDir);
    await nuxt.callHook("components:extend", components2);
    if (componentDirs.some((dir) => !dir.global)) {
      this.extendBuild((config) => {
        var _a2;
        const vueRule = (_a2 = config.module) == null ? void 0 : _a2.rules.find((rule) => {
          var _a3;
          return (_a3 = rule.test) == null ? void 0 : _a3.toString().includes(".vue");
        });
        if (!vueRule) {
          throw new Error("Cannot find vue loader");
        }
        if (!vueRule.use) {
          vueRule.use = [{
            loader: vueRule.loader.toString(),
            options: vueRule.options
          }];
          delete vueRule.loader;
          delete vueRule.options;
        }
        if (!Array.isArray(vueRule.use)) {
          vueRule.use = [vueRule.use];
        }
        vueRule.use.unshift({
          loader: require.resolve("./loader"),
          options: {
            dependencies: nuxt.options.dev ? componentDirs.filter((dir) => !dir.global).map((dir) => dir.path) : [],
            getComponents: () => components2
          }
        });
      });
      nuxt.hook("webpack:config", (configs) => {
        for (const config of configs.filter((c) => ["client", "modern", "server"].includes(c.name))) {
          config.entry.app.unshift(path__default['default'].resolve(__dirname, "../lib/installComponents.js"));
        }
      });
    }
    if (nuxt.options.dev && componentDirs.some((dir) => dir.watch !== false)) {
      const watcher = chokidar2__default['default'].watch(componentDirs.filter((dir) => dir.watch !== false).map((dir) => dir.path), nuxt.options.watchers.chokidar);
      watcher.on("all", async (eventName) => {
        if (!["add", "unlink"].includes(eventName)) {
          return;
        }
        components2 = await scanComponents(componentDirs, nuxt.options.srcDir);
        await nuxt.callHook("components:extend", components2);
        await builder.generateRoutesAndFiles();
      });
      nuxt.hook("close", () => {
        watcher.close();
      });
    }
    const getComponents = () => components2;
    const templates = [
      "components/index.js",
      "components/plugin.js",
      "vetur/tags.json"
    ];
    for (const t of templates) {
      this[t.includes("plugin") ? "addPlugin" : "addTemplate"]({
        src: path__default['default'].resolve(__dirname, "../templates", t),
        fileName: t,
        options: {getComponents}
      });
    }
  });
};
componentsModule.meta = {name: "@nuxt/components"};

module.exports = componentsModule;
