import { TextMessageStartEvent, TextMessageContentEvent, TextMessageEndEvent, ThinkingTextMessageStartEvent, ThinkingTextMessageContentEvent, ThinkingTextMessageEndEvent, ToolCallStartEvent, ToolCallArgsEvent, ToolCallEndEvent, ToolCallResultEvent, ThinkingStartEvent, ThinkingEndEvent, StateSnapshotEvent, StateDeltaEvent, MessagesSnapshotEvent, RawEvent, CustomEvent, RunStartedEvent, RunFinishedEvent, RunErrorEvent, StepStartedEvent, StepFinishedEvent, AgentConfig, AbstractAgent, RunAgentInput as RunAgentInput$1, HttpAgent } from '@ag-ui/client';
import * as _langchain_langgraph_sdk_dist_types_stream from '@langchain/langgraph-sdk/dist/types.stream';
import * as _langchain_langgraph_sdk from '@langchain/langgraph-sdk';
import { Message, AssistantGraph, Client, Config, Assistant, StreamMode, ThreadState, Thread } from '@langchain/langgraph-sdk';
import { Subscriber, Observable } from 'rxjs';
import { MessageType } from '@langchain/core/messages';
import { RunAgentInput } from '@ag-ui/core';
import { RunsStreamPayload } from '@langchain/langgraph-sdk/dist/types';

declare enum LangGraphEventTypes {
    OnChainStart = "on_chain_start",
    OnChainStream = "on_chain_stream",
    OnChainEnd = "on_chain_end",
    OnChatModelStart = "on_chat_model_start",
    OnChatModelStream = "on_chat_model_stream",
    OnChatModelEnd = "on_chat_model_end",
    OnToolStart = "on_tool_start",
    OnToolEnd = "on_tool_end",
    OnCustomEvent = "on_custom_event",
    OnInterrupt = "on_interrupt"
}
type LangGraphToolWithName = {
    type: "function";
    name?: string;
    function: {
        name: string;
        description: string;
        parameters: any;
    };
};
type State<TDefinedState = Record<string, any>> = {
    [k in keyof TDefinedState]: TDefinedState[k] | null;
} & Record<string, any>;
interface StateEnrichment {
    messages: Message[];
    tools: LangGraphToolWithName[];
    'ag-ui': {
        tools: LangGraphToolWithName[];
        context: RunAgentInput['context'];
    };
}
type SchemaKeys = {
    input: string[] | null;
    output: string[] | null;
    context: string[] | null;
    config: string[] | null;
} | null;
type MessageInProgress = {
    id: string;
    toolCallId?: string | null;
    toolCallName?: string | null;
};
type ThinkingInProgress = {
    index: number;
    type?: LangGraphReasoning['type'];
};
interface RunMetadata {
    id: string;
    schemaKeys?: SchemaKeys;
    nodeName?: string;
    prevNodeName?: string | null;
    exitingNode?: boolean;
    manuallyEmittedState?: State | null;
    threadId?: string;
    graphInfo?: AssistantGraph;
    hasFunctionStreaming?: boolean;
    serverRunIdKnown?: boolean;
}
type MessagesInProgressRecord = Record<string, MessageInProgress | null>;
interface ToolCall {
    id: string;
    name: string;
    args: Record<string, unknown>;
}
type BaseLangGraphPlatformMessage = Omit<Message, "isResultMessage" | "isTextMessage" | "isImageMessage" | "isActionExecutionMessage" | "isAgentStateMessage" | "type" | "createdAt"> & {
    content: string;
    role: string;
    additional_kwargs?: Record<string, unknown>;
    type: MessageType;
};
interface LangGraphPlatformResultMessage extends BaseLangGraphPlatformMessage {
    tool_call_id: string;
    name: string;
}
interface LangGraphPlatformActionExecutionMessage extends BaseLangGraphPlatformMessage {
    tool_calls: ToolCall[];
}
type LangGraphPlatformMessage = LangGraphPlatformActionExecutionMessage | LangGraphPlatformResultMessage | BaseLangGraphPlatformMessage;
declare enum CustomEventNames {
    ManuallyEmitMessage = "manually_emit_message",
    ManuallyEmitToolCall = "manually_emit_tool_call",
    ManuallyEmitState = "manually_emit_state",
    Exit = "exit"
}
interface PredictStateTool {
    tool: string;
    state_key: string;
    tool_argument: string;
}
interface LangGraphReasoning {
    type: 'text';
    text: string;
    index: number;
}

type ProcessedEvents = TextMessageStartEvent | TextMessageContentEvent | TextMessageEndEvent | ThinkingTextMessageStartEvent | ThinkingTextMessageContentEvent | ThinkingTextMessageEndEvent | ToolCallStartEvent | ToolCallArgsEvent | ToolCallEndEvent | ToolCallResultEvent | ThinkingStartEvent | ThinkingEndEvent | StateSnapshotEvent | StateDeltaEvent | MessagesSnapshotEvent | RawEvent | CustomEvent | RunStartedEvent | RunFinishedEvent | RunErrorEvent | StepStartedEvent | StepFinishedEvent;
type RunAgentExtendedInput<TStreamMode extends StreamMode | StreamMode[] = StreamMode, TSubgraphs extends boolean = false> = Omit<RunAgentInput$1, "forwardedProps"> & {
    forwardedProps?: Omit<RunsStreamPayload<TStreamMode, TSubgraphs>, "input"> & {
        nodeName?: string;
        threadMetadata?: Record<string, any>;
    };
};
interface RegenerateInput extends RunAgentExtendedInput {
    messageCheckpoint: Message;
}
interface LangGraphAgentConfig extends AgentConfig {
    client?: Client;
    deploymentUrl: string;
    langsmithApiKey?: string;
    propertyHeaders?: Record<string, string>;
    assistantConfig?: Config;
    agentName?: string;
    graphId: string;
}
declare class LangGraphAgent extends AbstractAgent {
    client: Client;
    assistantConfig?: Config;
    agentName?: string;
    graphId: string;
    assistant?: Assistant;
    messagesInProcess: MessagesInProgressRecord;
    thinkingProcess: null | ThinkingInProgress;
    activeRun?: RunMetadata;
    private cancelRequested;
    private cancelSent;
    subscriber: Subscriber<ProcessedEvents>;
    constantSchemaKeys: string[];
    config: LangGraphAgentConfig;
    constructor(config: LangGraphAgentConfig);
    clone(): LangGraphAgent;
    dispatchEvent(event: ProcessedEvents): boolean;
    run(input: RunAgentInput$1): Observable<ProcessedEvents>;
    runAgentStream(input: RunAgentExtendedInput, subscriber: Subscriber<ProcessedEvents>): Promise<void>;
    prepareRegenerateStream(input: RegenerateInput, streamMode: StreamMode | StreamMode[]): Promise<void | {
        streamResponse: _langchain_langgraph_sdk_dist_types_stream.TypedAsyncGenerator<"messages" | "values" | "updates" | "events" | "debug" | "tasks" | "checkpoints" | "custom" | "messages-tuple" | StreamMode[], false, _langchain_langgraph_sdk.DefaultValues, _langchain_langgraph_sdk.DefaultValues, unknown>;
        state: ThreadState<State>;
        streamMode: StreamMode | StreamMode[];
    }>;
    prepareStream(input: RunAgentExtendedInput, streamMode: StreamMode | StreamMode[]): Promise<void | {
        streamResponse: _langchain_langgraph_sdk_dist_types_stream.TypedAsyncGenerator<"messages" | "values" | "updates" | "events" | "debug" | "tasks" | "checkpoints" | "custom" | "messages-tuple" | StreamMode[], false, _langchain_langgraph_sdk.DefaultValues, _langchain_langgraph_sdk.DefaultValues, unknown>;
        state: ThreadState<State>;
        streamMode: StreamMode | StreamMode[];
    } | {
        streamResponse: _langchain_langgraph_sdk_dist_types_stream.TypedAsyncGenerator<"messages" | "values" | "updates" | "events" | "debug" | "tasks" | "checkpoints" | "custom" | "messages-tuple" | StreamMode[], false, _langchain_langgraph_sdk.DefaultValues, _langchain_langgraph_sdk.DefaultValues, unknown>;
        state: ThreadState<State>;
    }>;
    handleStreamEvents(stream: Awaited<ReturnType<typeof this.prepareStream> | ReturnType<typeof this.prepareRegenerateStream>>, threadId: string, subscriber: Subscriber<ProcessedEvents>, input: RunAgentExtendedInput, streamModes: StreamMode | StreamMode[]): Promise<void>;
    handleSingleEvent(event: any): void;
    abortRun(): void;
    handleThinkingEvent(reasoningData: LangGraphReasoning): void;
    getStateSnapshot(threadState: ThreadState<State>): State;
    getOrCreateThread(threadId: string, threadMetadata?: Record<string, any>): Promise<Thread>;
    getThread(threadId: string): Promise<Thread<_langchain_langgraph_sdk.DefaultValues>>;
    createThread(payload?: Parameters<typeof this$1.client.threads.create>[0]): Promise<Thread<_langchain_langgraph_sdk.DefaultValues>>;
    mergeConfigs({ configs, assistant, schemaKeys, }: {
        configs: Config[];
        assistant: Assistant;
        schemaKeys: SchemaKeys;
    }): Promise<Config>;
    getMessageInProgress(runId: string): MessageInProgress | null;
    setMessageInProgress(runId: string, data: MessageInProgress): void;
    getAssistant(): Promise<Assistant>;
    getSchemaKeys(): Promise<SchemaKeys>;
    langGraphDefaultMergeState(state: State, messages: Message[], input: RunAgentExtendedInput): State<StateEnrichment>;
    handleNodeChange(nodeName: string | undefined): void;
    startStep(nodeName: string): void;
    endStep(): void;
    getCheckpointByMessage(messageId: string, threadId: string, checkpoint?: null | {
        checkpoint_id?: null | string;
        checkpoint_ns: string;
    }): Promise<ThreadState>;
}

declare class LangGraphHttpAgent extends HttpAgent {
}

export { CustomEventNames, LangGraphAgent, type LangGraphAgentConfig, LangGraphEventTypes, LangGraphHttpAgent, type LangGraphPlatformMessage, type LangGraphReasoning, type LangGraphToolWithName, type MessageInProgress, type MessagesInProgressRecord, type PredictStateTool, type ProcessedEvents, type RunMetadata, type SchemaKeys, type State, type StateEnrichment, type ThinkingInProgress, type ToolCall };
