{"version":3,"file":"schema.d.ts","names":["JSONSchema","RunnableLike","BaseChannel","SerializableSchema","ReducedValue","UntrackedValue","STATE_SCHEMA_SYMBOL","StateSchemaFieldToChannel","F","V","I","O","StateSchemaFieldsToStateDefinition","StateSchemaFields","TFields","K","StateSchemaField","Input","Output","InferStateSchemaValue","TOutput","InferStateSchemaUpdate","TInput","StateSchema","Record","T","Promise","AnyStateSchema"],"sources":["../../src/state/schema.d.ts"],"sourcesContent":["import type { JSONSchema } from \"@langchain/core/utils/json_schema\";\nimport type { RunnableLike } from \"../pregel/runnable_types.js\";\nimport { BaseChannel } from \"../channels/index.js\";\nimport type { SerializableSchema } from \"./types.js\";\nimport { ReducedValue } from \"./values/reduced.js\";\nimport { UntrackedValue } from \"./values/untracked.js\";\ndeclare const STATE_SCHEMA_SYMBOL: unique symbol;\n/**\n * Maps a single StateSchema field definition to its corresponding Channel type.\n *\n * This utility type inspects the type of the field and returns an appropriate\n * `BaseChannel` type, parameterized with the state \"value\" and \"input\" types according to the field's shape.\n *\n * Rules:\n * - If the field (`F`) is a `ReducedValue<V, I>`, the channel will store values of type `V`\n *   and accept input of type `I`.\n * - If the field is a `UntrackedValue<V>`, the channel will store and accept values of type `V`.\n * - If the field is a `SerializableSchema<I, O>`, the channel will store values of type `O`\n *   (the schema's output/validated value) and accept input of type `I`.\n * - For all other types, a generic `BaseChannel<unknown, unknown>` is used as fallback.\n *\n * @template F - The StateSchema field type to map to a Channel type.\n *\n * @example\n * ```typescript\n * type MyField = ReducedValue<number, string>;\n * type ChannelType = StateSchemaFieldToChannel<MyField>;\n * // ChannelType is BaseChannel<number, string>\n * ```\n */\nexport type StateSchemaFieldToChannel<F> = F extends ReducedValue<infer V, infer I> ? BaseChannel<V, I> : F extends UntrackedValue<infer V> ? BaseChannel<V, V> : F extends SerializableSchema<infer I, infer O> ? BaseChannel<O, I> : BaseChannel<unknown, unknown>;\n/**\n * Converts StateSchema fields into a strongly-typed\n * State Definition object, where each field is mapped to its channel type.\n *\n * This utility type is used internally to create the shape of the state channels for a given schema,\n * substituting each field with the result of `StateSchemaFieldToChannel`.\n *\n * If you define a state schema as:\n * ```typescript\n * const fields = {\n *   a: ReducedValue<number, string>(),\n *   b: UntrackedValue<boolean>(),\n *   c: SomeSerializableSchemaType, // SerializableSchema<in, out>\n * }\n * ```\n * then `StateSchemaFieldsToStateDefinition<typeof fields>` yields:\n * ```typescript\n * {\n *   a: BaseChannel<number, string>;\n *   b: BaseChannel<boolean, boolean>;\n *   c: BaseChannel<typeof schema's output type, typeof schema's input type>;\n * }\n * ```\n *\n * @template TFields - The mapping of field names to StateSchema field types.\n * @returns An object type mapping field names to channel types.\n *\n * @see StateSchemaFieldToChannel\n */\nexport type StateSchemaFieldsToStateDefinition<TFields extends StateSchemaFields> = {\n    [K in keyof TFields]: StateSchemaFieldToChannel<TFields[K]>;\n};\n/**\n * Valid field types for StateSchema.\n * Either a LangGraph state value type or a raw schema (e.g., Zod schema).\n */\nexport type StateSchemaField<Input = unknown, Output = Input> = ReducedValue<Input, Output> | UntrackedValue<Output> | SerializableSchema<Input, Output>;\n/**\n * Init object for StateSchema constructor.\n * Uses `any` to allow variance in generic types (e.g., ReducedValue<string, string[]>).\n */\nexport type StateSchemaFields = {\n    [key: string]: StateSchemaField<any, any>;\n};\n/**\n * Infer the State type from a StateSchemaFields.\n * This is the type of the full state object.\n *\n * - ReducedValue<Value, Input> → Value (the stored type)\n * - UntrackedValue<Value> → Value\n * - SerializableSchema<Input, Output> → Output (the validated type)\n */\nexport type InferStateSchemaValue<TFields extends StateSchemaFields> = {\n    [K in keyof TFields]: TFields[K] extends ReducedValue<any, any> ? TFields[K][\"ValueType\"] : TFields[K] extends UntrackedValue<any> ? TFields[K][\"ValueType\"] : TFields[K] extends SerializableSchema<any, infer TOutput> ? TOutput : never;\n};\n/**\n * Infer the Update type from a StateSchemaFields.\n * This is the type for partial updates to state.\n *\n * - ReducedValue<Value, Input> → Input (the reducer input type)\n * - UntrackedValue<Value> → Value\n * - SerializableSchema<Input, Output> → Input (what you provide)\n */\nexport type InferStateSchemaUpdate<TFields extends StateSchemaFields> = {\n    [K in keyof TFields]?: TFields[K] extends ReducedValue<any, any> ? TFields[K][\"InputType\"] : TFields[K] extends UntrackedValue<any> ? TFields[K][\"ValueType\"] : TFields[K] extends SerializableSchema<infer TInput, any> ? TInput : never;\n};\n/**\n * StateSchema provides a unified API for defining LangGraph state schemas.\n *\n * @example\n * ```ts\n * import { z } from \"zod\";\n * import { StateSchema, ReducedValue, MessagesValue } from \"@langchain/langgraph\";\n *\n * const AgentState = new StateSchema({\n *   // Prebuilt messages value\n *   messages: MessagesValue,\n *   // Basic LastValue channel from any standard schema\n *   currentStep: z.string(),\n *   // LastValue with native default\n *   count: z.number().default(0),\n *   // ReducedValue for fields needing reducers\n *   history: new ReducedValue(\n *     z.array(z.string()).default(() => []),\n *     {\n *       inputSchema: z.string(),\n *       reducer: (current, next) => [...current, next],\n *     }\n *   ),\n * });\n *\n * // Extract types\n * type State = typeof AgentState.State;\n * type Update = typeof AgentState.Update;\n *\n * // Use in StateGraph\n * const graph = new StateGraph(AgentState);\n * ```\n */\nexport declare class StateSchema<TFields extends StateSchemaFields> {\n    readonly fields: TFields;\n    /**\n     * Symbol for runtime identification.\n     * @internal Used by isInstance for runtime type checking\n     */\n    private readonly [STATE_SCHEMA_SYMBOL];\n    /**\n     * Type declaration for the full state type.\n     * Use: `typeof myState.State`\n     */\n    State: InferStateSchemaValue<TFields>;\n    /**\n     * Type declaration for the update type.\n     * Use: `typeof myState.Update`\n     */\n    Update: InferStateSchemaUpdate<TFields>;\n    /**\n     * Type declaration for node functions.\n     * Use: `typeof myState.Node` to type node functions outside the graph builder.\n     *\n     * @example\n     * ```typescript\n     * const AgentState = new StateSchema({\n     *   count: z.number().default(0),\n     * });\n     *\n     * const myNode: typeof AgentState.Node = (state) => {\n     *   return { count: state.count + 1 };\n     * };\n     * ```\n     */\n    Node: RunnableLike<InferStateSchemaValue<TFields>, InferStateSchemaUpdate<TFields>>;\n    constructor(fields: TFields);\n    /**\n     * Get the channel definitions for use with StateGraph.\n     * This converts the StateSchema fields into BaseChannel instances.\n     */\n    getChannels(): Record<string, BaseChannel>;\n    /**\n     * Get the JSON schema for the full state type.\n     * Used by Studio and API for schema introspection.\n     */\n    getJsonSchema(): JSONSchema;\n    /**\n     * Get the JSON schema for the update/input type.\n     * All fields are optional in updates.\n     */\n    getInputJsonSchema(): JSONSchema;\n    /**\n     * Get the list of channel keys (excluding managed values).\n     */\n    getChannelKeys(): string[];\n    /**\n     * Get all keys (channels + managed values).\n     */\n    getAllKeys(): string[];\n    /**\n     * Validate input data against the schema.\n     * This validates each field using its corresponding schema.\n     *\n     * @param data - The input data to validate\n     * @returns The validated data with coerced types\n     */\n    validateInput<T>(data: T): Promise<T>;\n    /**\n     * Type guard to check if a value is a StateSchema instance.\n     *\n     * @param value - The value to check.\n     * @returns True if the value is a StateSchema instance with the correct runtime tag.\n     */\n    static isInstance<TFields extends StateSchemaFields>(value: StateSchema<TFields>): value is StateSchema<TFields>;\n    static isInstance(value: unknown): value is StateSchema<any>;\n}\nexport type AnyStateSchema = StateSchema<any>;\nexport {};\n"],"mappings":"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"}