"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.createLsTool = createLsTool;
const v4_1 = require("zod/v4");
const path = __importStar(require("path"));
const utils_1 = require("./utils");
const utils_2 = require("../utils");
const lsParametersSchema = v4_1.z.object({
    path: v4_1.z
        .string()
        .optional()
        .describe("The absolute path to the directory to list (must be absolute, not relative)"),
    ignore: v4_1.z
        .array(v4_1.z.string())
        .optional()
        .describe('List of glob patterns to ignore (e.g., ["*.log", "temp*"])'),
    // show_hidden: z
    //   .boolean()
    //   .optional()
    //   .describe('Whether to show hidden files and directories (starting with .)'),
    // detailed: z
    //   .boolean()
    //   .optional()
    //   .describe('Whether to show detailed file information (size, modified time)'),
});
// Path validation is now handled by validateWorkspacePath in tool-utils
/**
 * Check if a filename should be ignored based on patterns
 */
function shouldIgnore(filename, patterns) {
    if (!patterns || patterns.length === 0) {
        return false;
    }
    for (const pattern of patterns) {
        // Convert glob pattern to RegExp (simplified version)
        const regexPattern = pattern
            .replace(/[.+^${}()|[\]\\]/g, "\\$&") // Escape special regex chars
            .replace(/\*/g, ".*") // * becomes .*
            .replace(/\?/g, "."); // ? becomes .
        const regex = new RegExp(`^${regexPattern}$`);
        if (regex.test(filename)) {
            return true;
        }
    }
    return false;
}
/**
 * Format file size in human-readable format
 */
function formatFileSize(bytes) {
    if (bytes === 0) {
        return "0 B";
    }
    const units = ["B", "KB", "MB", "GB", "TB"];
    const k = 1024;
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return `${parseFloat((bytes / Math.pow(k, i)).toFixed(1))} ${units[i]}`;
}
/**
 * Format modified time in relative format
 */
function formatModifiedTime(date) {
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMinutes = Math.floor(diffMs / 60000);
    const diffHours = Math.floor(diffMs / 3600000);
    const diffDays = Math.floor(diffMs / 86400000);
    if (diffMinutes < 1) {
        return "just now";
    }
    if (diffMinutes < 60) {
        return `${diffMinutes}m ago`;
    }
    if (diffHours < 24) {
        return `${diffHours}h ago`;
    }
    if (diffDays < 7) {
        return `${diffDays}d ago`;
    }
    return date.toLocaleDateString();
}
function createLsTool(context) {
    return (0, utils_2.tool)(async (params) => {
        try {
            const { path: targetPath = ".", show_hidden = false, ignore, detailed = false, } = params;
            // Validate workspace path (handles both absolute and relative paths)
            const pathError = (0, utils_1.validateWorkspacePath)(targetPath, context);
            if (pathError) {
                return pathError;
            }
            // Resolve target directory
            const absolutePath = (0, utils_1.resolveWorkspacePath)(targetPath, context);
            // console.log(`Listing directory: ${targetPath}`);
            // Check if path exists and is a directory
            const dirError = await (0, utils_1.validateDirectoryExists)(context, absolutePath, targetPath);
            if (dirError) {
                return dirError;
            }
            // Read directory contents
            const files = await context.fsOperator.readdir(absolutePath, {
                withFileTypes: true,
            });
            if (files.length === 0) {
                return (0, utils_1.createSuccessResponse)({
                    path: targetPath,
                    absolute_path: absolutePath,
                    entries: [],
                    total_count: 0,
                });
            }
            const entries = [];
            let hiddenCount = 0;
            let ignoredCount = 0;
            // Process each file/directory
            for (const file of files) {
                // Skip hidden files unless requested
                if (!show_hidden && file.name.toString().startsWith(".")) {
                    hiddenCount++;
                    continue;
                }
                // Check ignore patterns
                if (shouldIgnore(file.name.toString(), ignore)) {
                    ignoredCount++;
                    continue;
                }
                const fullPath = path.join(absolutePath, file.name.toString());
                try {
                    const fileStats = await context.fsOperator.stat(fullPath);
                    const isDir = fileStats.isDirectory();
                    const entry = {
                        name: file.name.toString(),
                        isDirectory: isDir,
                        size: isDir ? 0 : fileStats.size,
                        modifiedTime: fileStats.mtime,
                        extension: isDir
                            ? undefined
                            : path.extname(file.name.toString()).slice(1),
                    };
                    entries.push(entry);
                }
                catch (error) {
                    // Log error but continue with other files
                    console.log(`Error accessing ${file}: ${error instanceof Error ? error.message : String(error)}`);
                }
            }
            // Sort entries (directories first, then alphabetically)
            entries.sort((a, b) => {
                if (a.isDirectory && !b.isDirectory) {
                    return -1;
                }
                if (!a.isDirectory && b.isDirectory) {
                    return 1;
                }
                return a.name.localeCompare(b.name);
            });
            // Create formatted output
            let summary = `Listed ${entries.length} item(s) in ${targetPath}`;
            if (hiddenCount > 0) {
                summary += ` (${hiddenCount} hidden)`;
            }
            if (ignoredCount > 0) {
                summary += ` (${ignoredCount} ignored)`;
            }
            // Create detailed listing if requested
            let detailedListing = "";
            if (detailed && entries.length > 0) {
                detailedListing = "\n\nDetailed listing:\n";
                detailedListing += entries
                    .map((entry) => {
                    const type = entry.isDirectory ? "[DIR]" : "[FILE]";
                    const size = entry.isDirectory
                        ? ""
                        : ` ${formatFileSize(entry.size)}`;
                    const modified = ` ${formatModifiedTime(entry.modifiedTime)}`;
                    const ext = entry.extension ? ` .${entry.extension}` : "";
                    return `${type} ${entry.name}${size}${modified}${ext}`;
                })
                    .join("\n");
            }
            return (0, utils_1.createSuccessResponse)({
                path: targetPath,
                absolute_path: absolutePath,
                entries,
                total_count: entries.length,
                hidden_count: hiddenCount,
                ignored_count: ignoredCount,
                directories: entries.filter((e) => e.isDirectory).length,
                files: entries.filter((e) => !e.isDirectory).length,
                summary,
                detailed_listing: detailed ? detailedListing : undefined,
            });
        }
        catch (error) {
            return (0, utils_2.handleToolError)(error, "Ls tool execution", "execution");
        }
    }, {
        name: "LS",
        description: "Lists files and directories in a given path. The path parameter must be an absolute path, not a relative path. You can optionally provide an array of glob patterns to ignore with the ignore parameter. You should generally prefer the Glob and Grep tools, if you know which directories to search.",
        schema: lsParametersSchema,
    });
}
//# sourceMappingURL=ls-tool.js.map