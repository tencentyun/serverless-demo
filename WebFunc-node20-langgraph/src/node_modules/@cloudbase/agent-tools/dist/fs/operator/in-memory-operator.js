"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.InMemoryFileOperator = void 0;
const base_operator_1 = require("./base-operator");
const path = __importStar(require("path"));
class InMemoryFileOperator extends base_operator_1.BaseFileOperator {
    constructor(fs, workspaceRoot) {
        super();
        this.fileSystem = fs;
        this.workspaceRoot = workspaceRoot || "/";
    }
    /**
     * Set workspace root for path resolution
     */
    setWorkspaceRoot(workspaceRoot) {
        this.workspaceRoot = workspaceRoot;
    }
    /**
     * Get current workspace root
     */
    getWorkspaceRoot() {
        return this.workspaceRoot;
    }
    /**
     * Resolve path relative to workspace root instead of process.cwd()
     * For memory file system, we ensure all paths are absolute to avoid cwd issues
     */
    resolvePath(filePath) {
        const pathStr = filePath.toString();
        if (path.posix.isAbsolute(pathStr)) {
            return path.posix.normalize(pathStr);
        }
        // For memory file system, use path.posix.join to avoid cwd calls
        return path.posix.join(this.workspaceRoot, pathStr);
    }
    async access(path) {
        const resolvedPath = this.resolvePath(path);
        return this.fileSystem.promises.access(resolvedPath);
    }
    async readFile(path, encoding) {
        const resolvedPath = this.resolvePath(path);
        if (encoding) {
            return this.fileSystem.promises.readFile(resolvedPath, encoding);
        }
        return this.fileSystem.promises.readFile(resolvedPath);
    }
    async mkdir(path, options) {
        const resolvedPath = this.resolvePath(path);
        return this.fileSystem.promises.mkdir(resolvedPath, options);
    }
    async writeFile(path, data, options) {
        const resolvedPath = this.resolvePath(path);
        return this.fileSystem.promises.writeFile(resolvedPath, data, options);
    }
    async readdir(path, options) {
        const resolvedPath = this.resolvePath(path);
        return this.fileSystem.promises.readdir(resolvedPath, options);
    }
    async stat(path) {
        const resolvedPath = this.resolvePath(path);
        return this.fileSystem.promises.stat(resolvedPath);
    }
    async exists(path) {
        const resolvedPath = this.resolvePath(path);
        return this.fileSystem.existsSync(resolvedPath);
    }
    async unlink(path) {
        const resolvedPath = this.resolvePath(path);
        return this.fileSystem.promises.unlink(resolvedPath);
    }
    async rmdir(path) {
        const resolvedPath = this.resolvePath(path);
        return this.fileSystem.promises.rmdir(resolvedPath);
    }
    async rename(oldPath, newPath) {
        const resolvedOldPath = this.resolvePath(oldPath);
        const resolvedNewPath = this.resolvePath(newPath);
        return this.fileSystem.promises.rename(resolvedOldPath, resolvedNewPath);
    }
}
exports.InMemoryFileOperator = InMemoryFileOperator;
//# sourceMappingURL=in-memory-operator.js.map