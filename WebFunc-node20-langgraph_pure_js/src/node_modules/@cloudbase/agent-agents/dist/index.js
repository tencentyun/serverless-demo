"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};

// src/core/events.ts
var import_events, EventType, EventSystem;
var init_events = __esm({
  "src/core/events.ts"() {
    "use strict";
    import_events = require("events");
    EventType = /* @__PURE__ */ ((EventType3) => {
      EventType3["TEXT_MESSAGE_START"] = "TEXT_MESSAGE_START";
      EventType3["TEXT_MESSAGE_CONTENT"] = "TEXT_MESSAGE_CONTENT";
      EventType3["TEXT_MESSAGE_END"] = "TEXT_MESSAGE_END";
      EventType3["TOOL_CALL_START"] = "TOOL_CALL_START";
      EventType3["TOOL_CALL_ARGS"] = "TOOL_CALL_ARGS";
      EventType3["TOOL_CALL_END"] = "TOOL_CALL_END";
      EventType3["STATE_SNAPSHOT"] = "STATE_SNAPSHOT";
      EventType3["STATE_DELTA"] = "STATE_DELTA";
      EventType3["MESSAGES_SNAPSHOT"] = "MESSAGES_SNAPSHOT";
      EventType3["RAW"] = "RAW";
      EventType3["CUSTOM"] = "CUSTOM";
      EventType3["RUN_STARTED"] = "RUN_STARTED";
      EventType3["RUN_FINISHED"] = "RUN_FINISHED";
      EventType3["RUN_ERROR"] = "RUN_ERROR";
      EventType3["STEP_STARTED"] = "STEP_STARTED";
      EventType3["STEP_FINISHED"] = "STEP_FINISHED";
      EventType3["TEXT_MESSAGE_CHUNK"] = "TEXT_MESSAGE_CHUNK";
      EventType3["TOOL_CALL_CHUNK"] = "TOOL_CALL_CHUNK";
      EventType3["TOOL_CALL_RESULT"] = "TOOL_CALL_RESULT";
      EventType3["TOOL_REGISTERED"] = "TOOL_REGISTERED";
      EventType3["TOOL_UNREGISTERED"] = "TOOL_UNREGISTERED";
      EventType3["TOOL_VALIDATION_FAILED"] = "TOOL_VALIDATION_FAILED";
      EventType3["STATE_UPDATE"] = "STATE_UPDATE";
      EventType3["APPROVAL_REQUIRED"] = "APPROVAL_REQUIRED";
      EventType3["APPROVAL_RECEIVED"] = "APPROVAL_RECEIVED";
      EventType3["CONVERSATION_CREATED"] = "CONVERSATION_CREATED";
      EventType3["CONVERSATION_UPDATED"] = "CONVERSATION_UPDATED";
      EventType3["CONVERSATION_DELETED"] = "CONVERSATION_DELETED";
      EventType3["CONTROL_FLOW_DECISION"] = "CONTROL_FLOW_DECISION";
      EventType3["EXECUTION_PAUSED"] = "EXECUTION_PAUSED";
      EventType3["EXECUTION_RESUMED"] = "EXECUTION_RESUMED";
      return EventType3;
    })(EventType || {});
    EventSystem = class extends import_events.EventEmitter {
      constructor() {
        super();
        this.setMaxListeners(100);
      }
      // Type-safe event emission
      emit(event, data) {
        return super.emit(event, { ...data, timestamp: Date.now() });
      }
      // Type-safe event listening
      on(event, handler) {
        return super.on(event, handler);
      }
      // Type-safe event listening (once)
      once(event, handler) {
        return super.once(event, handler);
      }
      // Type-safe event removal
      off(event, handler) {
        return super.off(event, handler);
      }
      // Remove all listeners for a specific event
      removeAllListeners(event) {
        return super.removeAllListeners(event);
      }
      // Get listener count for an event
      listenerCount(event) {
        return super.listenerCount(event);
      }
      // Get all event names that have listeners
      getEventNames() {
        return super.eventNames();
      }
      // Check if an event has listeners
      hasListeners(event) {
        return this.listenerCount(event) > 0;
      }
      // Emit event with error handling
      safeEmit(event, data) {
        try {
          return this.emit(event, data);
        } catch (error) {
          console.error(`Error emitting event ${event}:`, error);
          return false;
        }
      }
      // Create a promise that resolves when an event is emitted
      waitFor(event, timeout) {
        return new Promise((resolve, reject) => {
          const timeoutId = timeout ? setTimeout(() => {
            reject(new Error(`Timeout waiting for event ${event}`));
          }, timeout) : void 0;
          this.once(event, (data) => {
            if (timeoutId) {
              clearTimeout(timeoutId);
            }
            resolve(data);
          });
        });
      }
      // Create a promise that resolves when any of the specified events are emitted
      waitForAny(events, timeout) {
        return new Promise((resolve, reject) => {
          const timeoutId = timeout ? setTimeout(() => {
            reject(new Error(`Timeout waiting for any of events: ${events.join(", ")}`));
          }, timeout) : void 0;
          const handlers = /* @__PURE__ */ new Map();
          events.forEach((event) => {
            const handler = (data) => {
              events.forEach((e) => {
                if (handlers.has(e)) {
                  this.off(e, handlers.get(e));
                }
              });
              if (timeoutId) {
                clearTimeout(timeoutId);
              }
              resolve({ event, data });
            };
            handlers.set(event, handler);
            this.once(event, handler);
          });
        });
      }
    };
  }
});

// src/core/storage/memory/in-memory/in-memory-query-builder.ts
var in_memory_query_builder_exports = {};
__export(in_memory_query_builder_exports, {
  InMemoryQueryBuilder: () => InMemoryQueryBuilder,
  InMemoryUpdateBuilder: () => InMemoryUpdateBuilder
});
var InMemoryQueryBuilder, InMemoryUpdateBuilder;
var init_in_memory_query_builder = __esm({
  "src/core/storage/memory/in-memory/in-memory-query-builder.ts"() {
    "use strict";
    InMemoryQueryBuilder = class _InMemoryQueryBuilder {
      constructor() {
        this.conditions = [];
      }
      where(field, operator, value) {
        const condition = this.buildCondition(field, operator, value);
        this.conditions.push(condition);
        return this;
      }
      and(field, operator, value) {
        return this.where(field, operator, value);
      }
      or(conditions) {
        const orCondition = (doc) => {
          return conditions.some((builder) => {
            const builtQuery = builder.build();
            return builtQuery(doc);
          });
        };
        this.conditions.push(orCondition);
        return this;
      }
      in(field, values) {
        const condition = (doc) => {
          const fieldValue = this.getFieldValue(doc, field);
          return values.includes(fieldValue);
        };
        this.conditions.push(condition);
        return this;
      }
      nin(field, values) {
        const condition = (doc) => {
          const fieldValue = this.getFieldValue(doc, field);
          return !values.includes(fieldValue);
        };
        this.conditions.push(condition);
        return this;
      }
      regex(field, pattern, flags) {
        const regex = typeof pattern === "string" ? new RegExp(pattern, flags) : pattern;
        const condition = (doc) => {
          const fieldValue = this.getFieldValue(doc, field);
          return typeof fieldValue === "string" && regex.test(fieldValue);
        };
        this.conditions.push(condition);
        return this;
      }
      clone() {
        const cloned = new _InMemoryQueryBuilder();
        cloned.conditions = [...this.conditions];
        return cloned;
      }
      build() {
        if (this.conditions.length === 0) {
          return () => true;
        }
        return (doc) => {
          return this.conditions.every((condition) => condition(doc));
        };
      }
      buildCondition(field, operator, value) {
        return (doc) => {
          const fieldValue = this.getFieldValue(doc, field);
          switch (operator) {
            case "eq":
              return fieldValue === value;
            case "ne":
              return fieldValue !== value;
            case "gt":
              return fieldValue > value;
            case "gte":
              return fieldValue >= value;
            case "lt":
              return fieldValue < value;
            case "lte":
              return fieldValue <= value;
            default:
              throw new Error(`Unsupported operator: ${operator}`);
          }
        };
      }
      getFieldValue(doc, field) {
        return field.split(".").reduce((obj, key) => obj?.[key], doc);
      }
    };
    InMemoryUpdateBuilder = class _InMemoryUpdateBuilder {
      constructor() {
        this.updates = {};
      }
      set(field, value) {
        this.updates[field] = value;
        return this;
      }
      unset(field) {
        this.updates[field] = void 0;
        return this;
      }
      inc(field, value) {
        this.updates[field] = { $inc: value };
        return this;
      }
      push(field, value) {
        this.updates[field] = { $push: value };
        return this;
      }
      pull(field, value) {
        this.updates[field] = { $pull: value };
        return this;
      }
      clone() {
        const cloned = new _InMemoryUpdateBuilder();
        cloned.updates = { ...this.updates };
        return cloned;
      }
      build() {
        return { ...this.updates };
      }
    };
  }
});

// src/core/storage/memory/in-memory/in-memory-adapter.ts
var in_memory_adapter_exports = {};
__export(in_memory_adapter_exports, {
  InMemoryAdapter: () => InMemoryAdapter
});
var InMemoryAdapter;
var init_in_memory_adapter = __esm({
  "src/core/storage/memory/in-memory/in-memory-adapter.ts"() {
    "use strict";
    InMemoryAdapter = class {
      createQueryBuilder() {
        const { InMemoryQueryBuilder: InMemoryQueryBuilder2 } = (init_in_memory_query_builder(), __toCommonJS(in_memory_query_builder_exports));
        return new InMemoryQueryBuilder2();
      }
      createUpdateBuilder() {
        const { InMemoryUpdateBuilder: InMemoryUpdateBuilder2 } = (init_in_memory_query_builder(), __toCommonJS(in_memory_query_builder_exports));
        return new InMemoryUpdateBuilder2();
      }
      async find(collection, query, options) {
        let results;
        if (typeof query === "function") {
          results = collection.filter(query);
        } else {
          results = collection.filter((doc) => this.matchesQuery(doc, query));
        }
        if (options?.sort) {
          results = this.applySorting(results, options.sort);
        }
        if (options?.skip) {
          results = results.slice(options.skip);
        }
        if (options?.limit) {
          results = results.slice(0, options.limit);
        }
        return results;
      }
      async findOne(collection, query) {
        const results = await this.find(collection, query, { limit: 1 });
        return results.length > 0 ? results[0] : null;
      }
      async insertOne(collection, document) {
        const newDoc = {
          _id: this.generateId(),
          ...document
        };
        collection.push(newDoc);
        return newDoc;
      }
      async insertMany(collection, documents) {
        let insertedCount = 0;
        for (const doc of documents) {
          await this.insertOne(collection, doc);
          insertedCount++;
        }
        return { insertedCount };
      }
      async updateOne(collection, filter, update) {
        const doc = await this.findOne(collection, filter);
        if (!doc) {
          return { modifiedCount: 0 };
        }
        this.applyUpdate(doc, update);
        return { modifiedCount: 1 };
      }
      async deleteOne(collection, filter) {
        const index = collection.findIndex(
          (doc) => typeof filter === "function" ? filter(doc) : this.matchesQuery(doc, filter)
        );
        if (index === -1) {
          return { deletedCount: 0 };
        }
        collection.splice(index, 1);
        return { deletedCount: 1 };
      }
      async deleteMany(collection, filter) {
        let deletedCount = 0;
        for (let i = collection.length - 1; i >= 0; i--) {
          const doc = collection[i];
          const matches = typeof filter === "function" ? filter(doc) : this.matchesQuery(doc, filter);
          if (matches) {
            collection.splice(i, 1);
            deletedCount++;
          }
        }
        return { deletedCount };
      }
      async count(collection, query) {
        const results = await this.find(collection, query);
        return results.length;
      }
      matchesQuery(doc, query) {
        if (!query || typeof query !== "object") {
          return true;
        }
        return Object.entries(query).every(([field, value]) => {
          const docValue = this.getFieldValue(doc, field);
          if (value && typeof value === "object" && !Array.isArray(value) && !(value instanceof Date)) {
            return Object.entries(value).every(([operator, operatorValue]) => {
              switch (operator) {
                case "$gt":
                  return docValue > operatorValue;
                case "$gte":
                  return docValue >= operatorValue;
                case "$lt":
                  return docValue < operatorValue;
                case "$lte":
                  return docValue <= operatorValue;
                case "$ne":
                case "$neq":
                  return docValue !== operatorValue;
                case "$in":
                  return Array.isArray(operatorValue) && operatorValue.includes(docValue);
                case "$nin":
                  return Array.isArray(operatorValue) && !operatorValue.includes(docValue);
                case "$regex":
                  const regex = new RegExp(operatorValue);
                  return typeof docValue === "string" && regex.test(docValue);
                default:
                  return docValue === operatorValue;
              }
            });
          }
          return docValue === value;
        });
      }
      getFieldValue(doc, field) {
        return field.split(".").reduce((obj, key) => obj?.[key], doc);
      }
      applySorting(results, sort) {
        return results.sort((a, b) => {
          for (const [field, direction] of Object.entries(sort)) {
            const aValue = this.getFieldValue(a, field);
            const bValue = this.getFieldValue(b, field);
            let comparison = 0;
            if (aValue < bValue) comparison = -1;
            else if (aValue > bValue) comparison = 1;
            if (comparison !== 0) {
              return direction === 1 ? comparison : -comparison;
            }
          }
          return 0;
        });
      }
      applyUpdate(doc, update) {
        Object.entries(update).forEach(([field, value]) => {
          if (value && typeof value === "object" && !Array.isArray(value) && !(value instanceof Date)) {
            if (value.$inc !== void 0) {
              const currentValue = this.getFieldValue(doc, field) || 0;
              this.setFieldValue(doc, field, currentValue + value.$inc);
            } else if (value.$push !== void 0) {
              const currentArray = this.getFieldValue(doc, field) || [];
              currentArray.push(value.$push);
            } else if (value.$pull !== void 0) {
              const currentArray = this.getFieldValue(doc, field) || [];
              const index = currentArray.indexOf(value.$pull);
              if (index > -1) {
                currentArray.splice(index, 1);
              }
            } else {
              this.setFieldValue(doc, field, value);
            }
          } else if (value === void 0) {
            this.unsetFieldValue(doc, field);
          } else {
            this.setFieldValue(doc, field, value);
          }
        });
      }
      setFieldValue(doc, field, value) {
        const keys = field.split(".");
        let current = doc;
        for (let i = 0; i < keys.length - 1; i++) {
          const key = keys[i];
          if (!(key in current) || typeof current[key] !== "object") {
            current[key] = {};
          }
          current = current[key];
        }
        current[keys[keys.length - 1]] = value;
      }
      unsetFieldValue(doc, field) {
        const keys = field.split(".");
        let current = doc;
        for (let i = 0; i < keys.length - 1; i++) {
          const key = keys[i];
          if (!(key in current)) {
            return;
          }
          current = current[key];
        }
        delete current[keys[keys.length - 1]];
      }
      generateId() {
        return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      }
    };
  }
});

// src/agkit/agent.ts
function convertMessages(aguiMessages) {
  return aguiMessages.map((msg) => {
    let role;
    if (msg.role === "developer") {
      role = "system";
    } else if (msg.role === "user" || msg.role === "assistant" || msg.role === "system" || msg.role === "tool") {
      role = msg.role;
    } else {
      role = "user";
    }
    return {
      id: msg.id,
      role,
      content: msg.content || "",
      toolCalls: msg.toolCalls,
      toolCallId: msg.toolCallId,
      timestamp: msg.timestamp ? new Date(msg.timestamp) : /* @__PURE__ */ new Date(),
      metadata: msg.metadata
    };
  });
}
var import_client, import_rxjs, AGKitAgent;
var init_agent = __esm({
  "src/agkit/agent.ts"() {
    "use strict";
    import_client = require("@ag-ui/client");
    import_rxjs = require("rxjs");
    init_events();
    AGKitAgent = class extends import_client.AbstractAgent {
      constructor(agent, config) {
        super({
          agentId: config?.agentId || agent.name,
          description: config?.description || agent.description || "",
          threadId: config?.threadId || "",
          ...config
        });
        this.agent = agent;
      }
      run(input) {
        return new import_rxjs.Observable((subscriber) => {
          this._run(subscriber, input);
        });
      }
      async _run(subscriber, input) {
        const { messages, runId, threadId, tools, forwardedProps } = input;
        try {
          subscriber.next({ type: import_client.EventType.RUN_STARTED, threadId, runId });
          const convertedTools = tools?.map((tool2) => {
            let schema;
            if (tool2.parameters) {
              try {
                const jsonSchema = typeof tool2.parameters === "string" ? JSON.parse(tool2.parameters) : tool2.parameters;
                schema = jsonSchema;
              } catch (error) {
                console.warn("Failed to convert parameters to schema:", error);
                schema = void 0;
              }
            }
            return {
              name: tool2.name,
              description: tool2.description,
              schema,
              // No handler for client-side tools
              handler: void 0
            };
          });
          const convertedMessages = convertMessages(messages);
          await this.agent.run(convertedMessages, void 0, {
            conversationId: threadId,
            runId,
            tools: convertedTools,
            ...forwardedProps,
            // Bridge AG-Kit events to AG-UI events for this specific run
            onEvent: (event) => {
              this.bridgeEvent(subscriber, threadId, runId, event);
            }
          });
          subscriber.complete();
        } catch (error) {
          subscriber.next({
            type: import_client.EventType.RUN_ERROR,
            threadId,
            runId,
            message: error instanceof Error ? error.message : String(error),
            code: error instanceof Error ? error.name : "UNKNOWN_ERROR"
          });
          subscriber.error(error);
        }
      }
      /**
       * Bridge a single AG-Kit event to AG-UI event format
       * This is called per-event for a specific run (no global listeners)
       */
      bridgeEvent(subscriber, threadId, runId, event) {
        switch (event.type) {
          case "TEXT_MESSAGE_START" /* TEXT_MESSAGE_START */:
            subscriber.next({
              type: import_client.EventType.TEXT_MESSAGE_START,
              threadId,
              runId,
              messageId: event.messageId,
              role: event.role
            });
            break;
          case "TEXT_MESSAGE_CONTENT" /* TEXT_MESSAGE_CONTENT */:
            subscriber.next({
              type: import_client.EventType.TEXT_MESSAGE_CONTENT,
              threadId,
              runId,
              messageId: event.messageId,
              delta: event.delta
            });
            break;
          case "TEXT_MESSAGE_END" /* TEXT_MESSAGE_END */:
            subscriber.next({
              type: import_client.EventType.TEXT_MESSAGE_END,
              threadId,
              runId,
              messageId: event.messageId
            });
            break;
          case "TOOL_CALL_START" /* TOOL_CALL_START */:
            subscriber.next({
              type: import_client.EventType.TOOL_CALL_START,
              threadId,
              runId,
              toolCallId: event.toolCallId,
              toolCallName: event.toolCallName
            });
            break;
          case "TOOL_CALL_ARGS" /* TOOL_CALL_ARGS */:
            subscriber.next({
              type: import_client.EventType.TOOL_CALL_ARGS,
              threadId,
              runId,
              toolCallId: event.toolCallId,
              delta: event.delta
            });
            break;
          case "TOOL_CALL_END" /* TOOL_CALL_END */:
            subscriber.next({
              type: import_client.EventType.TOOL_CALL_END,
              threadId,
              runId,
              toolCallId: event.toolCallId
            });
            break;
          case "TOOL_CALL_RESULT" /* TOOL_CALL_RESULT */:
            subscriber.next({
              type: import_client.EventType.TOOL_CALL_RESULT,
              threadId,
              runId,
              toolCallId: event.toolCallId,
              content: event.content
            });
            break;
          case "RUN_FINISHED" /* RUN_FINISHED */:
            if (event.outcome === "interrupt") {
              subscriber.next({
                type: import_client.EventType.RUN_FINISHED,
                threadId,
                runId,
                outcome: "interrupt",
                interrupt: event.interrupt
              });
            } else {
              subscriber.next({
                type: import_client.EventType.RUN_FINISHED,
                threadId,
                runId,
                result: event.result
              });
            }
            break;
          // Ignore other event types (they're not part of AG-UI protocol)
          default:
            break;
        }
      }
      destroy() {
        this.agent.destroy();
      }
    };
  }
});

// src/agkit/converter.ts
var converter_exports = {};
__export(converter_exports, {
  toAGUIAgent: () => toAGUIAgent
});
function toAGUIAgent(agent, config) {
  if (agent instanceof import_client2.AbstractAgent) {
    return agent;
  }
  return new AGKitAgent(agent, config);
}
var import_client2;
var init_converter = __esm({
  "src/agkit/converter.ts"() {
    "use strict";
    import_client2 = require("@ag-ui/client");
    init_agent();
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AGKitAgent: () => AGKitAgent,
  AGKitError: () => AGKitError,
  Agent: () => Agent,
  AgentConfigSchema: () => AgentConfigSchema,
  AnthropicProvider: () => AnthropicProvider,
  BaseLongTermMemory: () => BaseLongTermMemory,
  BaseMemory: () => BaseMemory,
  BaseModelProvider: () => BaseModelProvider,
  CloudBaseMemory: () => CloudBaseMemory,
  ConfigValidator: () => ConfigValidator,
  ConfigurationError: () => ConfigurationError,
  ControlFlowConfigSchema: () => ControlFlowConfigSchema,
  ControlFlowError: () => ControlFlowError,
  ConversationManager: () => ConversationManager,
  ErrorCategory: () => ErrorCategory,
  ErrorContextBuilder: () => ErrorContextBuilder,
  EventSystem: () => EventSystem,
  EventType: () => EventType,
  ExecutionError: () => ExecutionError,
  FallbackModelStrategy: () => FallbackModelStrategy,
  HumanApprovalRequiredError: () => HumanApprovalRequiredError,
  HumanInTheLoopConfigSchema: () => HumanInTheLoopConfigSchema,
  InMemoryMemory: () => InMemoryMemory,
  InvalidModelProviderError: () => InvalidModelProviderError,
  InvalidModelResponseError: () => InvalidModelResponseError,
  LoggingErrorHandler: () => LoggingErrorHandler,
  Mem0LongTermMemory: () => Mem0LongTermMemory,
  MemoryClient: () => MemoryClient,
  MemoryError: () => MemoryError,
  MemoryLimitError: () => MemoryLimitError,
  MissingRequiredConfigError: () => MissingRequiredConfigError,
  ModelError: () => ModelError,
  ModelProviderError: () => ModelProviderError,
  ModelProviderRegistry: () => ModelProviderRegistry,
  ModelSettingsSchema: () => ModelSettingsSchema,
  MongoDBMemory: () => MongoDBMemory,
  MySQLMemory: () => MySQLMemory,
  NetworkError: () => NetworkError,
  OpenAIProvider: () => OpenAIProvider,
  OptimizedEventSystem: () => OptimizedEventSystem,
  Order: () => Order,
  OutputConstraintSchema: () => OutputConstraintSchema,
  OutputTypeSchema: () => OutputTypeSchema,
  ParamError: () => ParamError,
  ProviderFactory: () => ProviderFactory,
  ProviderPresets: () => ProviderPresets,
  RateLimitError: () => RateLimitError,
  RetryErrorHandler: () => RetryErrorHandler,
  RunOptionsSchema: () => RunOptionsSchema,
  RuntimeError: () => RuntimeError,
  SchemaValidationError: () => SchemaValidationError,
  StateConstraintSchema: () => StateConstraintSchema,
  StateError: () => StateError,
  TDAIException: () => TDAIException,
  TDAILongTermMemory: () => TDAILongTermMemory,
  TDAIMemory: () => TDAIMemory,
  TiktokenTokenizer: () => TiktokenTokenizer,
  TimeoutError: () => TimeoutError,
  TokenLimitError: () => TokenLimitError,
  TokenTrimmer: () => TokenTrimmer,
  ToolDefinitionSchema: () => ToolDefinitionSchema,
  ToolError: () => ToolError,
  ToolExecutionError: () => ToolExecutionError,
  ToolNotFoundError: () => ToolNotFoundError,
  ToolProxy: () => ToolProxy,
  ToolValidationError: () => ToolValidationError,
  TypeChecker: () => TypeChecker,
  TypeORMAdapter: () => TypeORMAdapter,
  TypeORMMemory: () => TypeORMMemory,
  TypeORMQueryBuilder: () => TypeORMQueryBuilder,
  TypeORMUpdateBuilder: () => TypeORMUpdateBuilder,
  ValidationError: () => ValidationError,
  configValidator: () => configValidator,
  createAnthropicProvider: () => createAnthropicProvider,
  createAnthropicProviderFromEnv: () => createAnthropicProviderFromEnv,
  createCompositeTool: () => createCompositeTool,
  createDefaultAnthropicProvider: () => createDefaultAnthropicProvider,
  createDefaultOpenAIProvider: () => createDefaultOpenAIProvider,
  createErrorContext: () => createErrorContext,
  createLoggedTool: () => createLoggedTool,
  createOpenAIProvider: () => createOpenAIProvider,
  createOpenAIProviderFromEnv: () => createOpenAIProviderFromEnv,
  createOptimizedEventSystem: () => createOptimizedEventSystem,
  createProviderFromApiKey: () => createProviderFromApiKey,
  createProviderFromConfig: () => createProviderFromConfig,
  createRetryTool: () => createRetryTool,
  createTimeoutTool: () => createTimeoutTool,
  createTypeSafeOutput: () => createTypeSafeOutput,
  createTypeSafeState: () => createTypeSafeState,
  createTypedTool: () => createTypedTool,
  isConfigurationError: () => isConfigurationError,
  isOutputConstraint: () => isOutputConstraint,
  isRetryableError: () => isRetryableError,
  isStateConstraint: () => isStateConstraint,
  isToolError: () => isToolError,
  modelProviderRegistry: () => modelProviderRegistry,
  optimizedEventSystem: () => optimizedEventSystem,
  providerFactory: () => providerFactory,
  toAGUIAgent: () => toAGUIAgent,
  typeChecker: () => typeChecker,
  validateAgentName: () => validateAgentName,
  validateConfig: () => validateConfig,
  validateInstructions: () => validateInstructions,
  validateModelProvider: () => validateModelProvider,
  validateOutput: () => validateOutput,
  validateState: () => validateState,
  validateTypes: () => validateTypes
});
module.exports = __toCommonJS(index_exports);

// src/core/agent.ts
var import_node_crypto4 = require("crypto");
init_events();

// src/core/errors.ts
var AGKitError = class extends Error {
  constructor(message, context, cause) {
    super(message);
    this.name = this.constructor.name;
    this.timestamp = /* @__PURE__ */ new Date();
    this.context = context;
    this.cause = cause;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    }
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      category: this.category,
      message: this.message,
      timestamp: this.timestamp.toISOString(),
      context: this.context,
      stack: this.stack
    };
  }
};
var ErrorCategory = /* @__PURE__ */ ((ErrorCategory2) => {
  ErrorCategory2["CONFIGURATION"] = "CONFIGURATION";
  ErrorCategory2["NETWORK"] = "NETWORK";
  ErrorCategory2["MODEL"] = "MODEL";
  ErrorCategory2["TOOL"] = "TOOL";
  ErrorCategory2["VALIDATION"] = "VALIDATION";
  ErrorCategory2["RUNTIME"] = "RUNTIME";
  ErrorCategory2["MEMORY"] = "MEMORY";
  ErrorCategory2["CONTROL_FLOW"] = "CONTROL_FLOW";
  return ErrorCategory2;
})(ErrorCategory || {});
var ConfigurationError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "CONFIG_ERROR";
    this.category = "CONFIGURATION" /* CONFIGURATION */;
  }
};
var InvalidModelProviderError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "INVALID_MODEL_PROVIDER";
    this.category = "CONFIGURATION" /* CONFIGURATION */;
  }
};
var MissingRequiredConfigError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "MISSING_REQUIRED_CONFIG";
    this.category = "CONFIGURATION" /* CONFIGURATION */;
  }
};
var NetworkError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "NETWORK_ERROR";
    this.category = "NETWORK" /* NETWORK */;
  }
};
var TimeoutError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "TIMEOUT_ERROR";
    this.category = "NETWORK" /* NETWORK */;
  }
};
var RateLimitError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "RATE_LIMIT_ERROR";
    this.category = "NETWORK" /* NETWORK */;
  }
};
var ModelError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "MODEL_ERROR";
    this.category = "MODEL" /* MODEL */;
  }
};
var ModelProviderError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "MODEL_PROVIDER_ERROR";
    this.category = "MODEL" /* MODEL */;
  }
};
var TokenLimitError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "TOKEN_LIMIT_ERROR";
    this.category = "MODEL" /* MODEL */;
  }
};
var InvalidModelResponseError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "INVALID_MODEL_RESPONSE";
    this.category = "MODEL" /* MODEL */;
  }
};
var ToolError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "TOOL_ERROR";
    this.category = "TOOL" /* TOOL */;
  }
};
var ToolExecutionError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "TOOL_EXECUTION_ERROR";
    this.category = "TOOL" /* TOOL */;
  }
};
var ToolNotFoundError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "TOOL_NOT_FOUND";
    this.category = "TOOL" /* TOOL */;
  }
};
var ToolValidationError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "TOOL_VALIDATION_ERROR";
    this.category = "TOOL" /* TOOL */;
  }
};
var ValidationError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "VALIDATION_ERROR";
    this.category = "VALIDATION" /* VALIDATION */;
  }
};
var SchemaValidationError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "SCHEMA_VALIDATION_ERROR";
    this.category = "VALIDATION" /* VALIDATION */;
  }
};
var RuntimeError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "RUNTIME_ERROR";
    this.category = "RUNTIME" /* RUNTIME */;
  }
};
var StateError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "STATE_ERROR";
    this.category = "RUNTIME" /* RUNTIME */;
  }
};
var ExecutionError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "EXECUTION_ERROR";
    this.category = "RUNTIME" /* RUNTIME */;
  }
};
var MemoryError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "MEMORY_ERROR";
    this.category = "MEMORY" /* MEMORY */;
  }
};
var MemoryLimitError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "MEMORY_LIMIT_ERROR";
    this.category = "MEMORY" /* MEMORY */;
  }
};
var ControlFlowError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "CONTROL_FLOW_ERROR";
    this.category = "CONTROL_FLOW" /* CONTROL_FLOW */;
  }
};
var HumanApprovalRequiredError = class extends AGKitError {
  constructor() {
    super(...arguments);
    this.code = "HUMAN_APPROVAL_REQUIRED";
    this.category = "CONTROL_FLOW" /* CONTROL_FLOW */;
  }
};
var LoggingErrorHandler = class {
  canHandle(error) {
    return true;
  }
  handle(error) {
    console.error(`[${error.category}] ${error.code}: ${error.message}`, {
      context: error.context,
      stack: error.stack
    });
  }
};
var RetryErrorHandler = class {
  constructor(maxRetries = 3, retryableCategories = [
    "NETWORK" /* NETWORK */,
    "MODEL" /* MODEL */
  ]) {
    this.maxRetries = maxRetries;
    this.retryableCategories = new Set(retryableCategories);
  }
  canHandle(error) {
    return this.retryableCategories.has(error.category);
  }
  async handle(error) {
    console.warn(`Retrying operation after ${error.code} error`);
  }
};
var FallbackModelStrategy = class {
  canRecover(error) {
    return error instanceof ModelError || error instanceof NetworkError;
  }
  async recover(error) {
    console.log("Attempting recovery with fallback model provider");
    return null;
  }
};
var ErrorContextBuilder = class {
  constructor() {
    this.context = {};
  }
  withAgentId(agentId) {
    this.context.agentId = agentId;
    return this;
  }
  withRunId(runId) {
    this.context.runId = runId;
    return this;
  }
  withToolName(toolName) {
    this.context.toolName = toolName;
    return this;
  }
  withModelName(modelName) {
    this.context.modelName = modelName;
    return this;
  }
  withRetryCount(count) {
    this.context.retryCount = count;
    return this;
  }
  withCustom(key, value) {
    this.context[key] = value;
    return this;
  }
  build() {
    return { ...this.context };
  }
};
function isRetryableError(error) {
  const retryableCategories = [
    "NETWORK" /* NETWORK */,
    "MODEL" /* MODEL */
  ];
  return retryableCategories.includes(error.category);
}
function isConfigurationError(error) {
  return error.category === "CONFIGURATION" /* CONFIGURATION */;
}
function isToolError(error) {
  return error.category === "TOOL" /* TOOL */;
}
function createErrorContext() {
  return new ErrorContextBuilder();
}

// src/core/config-validation.ts
var import_v4 = require("zod/v4");
function zFunction() {
  return import_v4.z.custom((value) => typeof value === "function");
}
var ModelSettingsSchema = import_v4.z.object({
  temperature: import_v4.z.number().min(0).max(2).optional(),
  maxTokens: import_v4.z.number().positive().optional(),
  topP: import_v4.z.number().min(0).max(1).optional(),
  frequencyPenalty: import_v4.z.number().min(-2).max(2).optional(),
  presencePenalty: import_v4.z.number().min(-2).max(2).optional(),
  stop: import_v4.z.array(import_v4.z.string()).optional()
});
var HumanInTheLoopConfigSchema = import_v4.z.object({
  enabled: import_v4.z.boolean(),
  requireApproval: import_v4.z.array(import_v4.z.string()).optional(),
  highRiskTools: import_v4.z.array(import_v4.z.string()).optional(),
  timeout: import_v4.z.number().positive().optional(),
  defaultAction: import_v4.z.enum(["approve", "reject", "pause"]).optional()
});
var ControlFlowConfigSchema = import_v4.z.object({
  maxSteps: import_v4.z.number().positive().optional(),
  errorRetryLimit: import_v4.z.number().nonnegative().optional(),
  pauseOnHumanInput: import_v4.z.boolean().optional(),
  customHandler: import_v4.z.object({
    handleNextStep: zFunction(),
    handleToolCall: zFunction(),
    handleError: zFunction()
  }).optional()
});
var ToolDefinitionSchema = import_v4.z.object({
  name: import_v4.z.string().min(1),
  description: import_v4.z.string().optional(),
  schema: import_v4.z.any().optional(),
  invoke: zFunction().optional(),
  requiresApproval: import_v4.z.boolean().optional()
});
var OutputTypeSchema = import_v4.z.union([
  import_v4.z.literal("string"),
  import_v4.z.literal("structured"),
  import_v4.z.object({
    schema: import_v4.z.any()
  })
]);
var AgentConfigSchema = import_v4.z.object({
  name: import_v4.z.string().min(1, "Agent name is required"),
  description: import_v4.z.string().optional(),
  model: import_v4.z.union([import_v4.z.string(), import_v4.z.any()]),
  instructions: import_v4.z.union([import_v4.z.string(), zFunction()]).optional(),
  // Use any to avoid Zod wrapping constructors; we call with `new` downstream
  stateType: import_v4.z.any().optional(),
  outputType: OutputTypeSchema.optional(),
  modelSettings: ModelSettingsSchema.optional(),
  tools: import_v4.z.array(ToolDefinitionSchema).optional(),
  memory: import_v4.z.any().optional(),
  // BaseMemory instance, not config object
  humanInTheLoop: HumanInTheLoopConfigSchema.optional(),
  controlFlow: ControlFlowConfigSchema.optional()
});
var RunOptionsSchema = import_v4.z.object({
  state: import_v4.z.record(import_v4.z.string(), import_v4.z.unknown()).optional(),
  conversationId: import_v4.z.string().optional(),
  runId: import_v4.z.string().optional(),
  userId: import_v4.z.string().optional(),
  model: import_v4.z.string().optional(),
  // Runtime model override
  temperature: import_v4.z.number().min(0).max(2).optional(),
  maxTokens: import_v4.z.number().positive().optional(),
  stream: import_v4.z.boolean().optional(),
  tools: import_v4.z.array(ToolDefinitionSchema).optional(),
  // memory removed - should not be configurable at runtime
  humanInTheLoop: HumanInTheLoopConfigSchema.optional(),
  controlFlow: ControlFlowConfigSchema.optional()
});
var ConfigValidator = class _ConfigValidator {
  static getInstance() {
    if (!_ConfigValidator.instance) {
      _ConfigValidator.instance = new _ConfigValidator();
    }
    return _ConfigValidator.instance;
  }
  // Validate agent configuration
  validateAgentConfig(config, context) {
    try {
      AgentConfigSchema.parse(config);
      return config;
    } catch (error) {
      if (error instanceof import_v4.z.ZodError) {
        const contextData = createErrorContext().withCustom("validationErrors", error.errors).withCustom("config", config).withCustom("context", context).build();
        throw new ConfigurationError(
          `Agent configuration validation failed: ${this.formatZodErrors(error.errors)}`,
          contextData,
          error
        );
      }
      throw error;
    }
  }
  // Validate run options
  validateRunOptions(options, context) {
    try {
      RunOptionsSchema.parse(options);
      return options;
    } catch (error) {
      if (error instanceof import_v4.z.ZodError) {
        const contextData = createErrorContext().withCustom("validationErrors", error.errors).withCustom("options", options).withCustom("context", context).build();
        throw new ConfigurationError(
          `Run options validation failed: ${this.formatZodErrors(error.errors)}`,
          contextData,
          error
        );
      }
      throw error;
    }
  }
  // Validate model settings
  validateModelSettings(settings) {
    try {
      ModelSettingsSchema.parse(settings);
      return settings;
    } catch (error) {
      if (error instanceof import_v4.z.ZodError) {
        const contextData = createErrorContext().withCustom("validationErrors", error.errors).withCustom("settings", settings).build();
        throw new ConfigurationError(
          `Model settings validation failed: ${this.formatZodErrors(error.errors)}`,
          contextData,
          error
        );
      }
      throw error;
    }
  }
  // Validate tool definitions
  validateToolDefinitions(tools) {
    try {
      import_v4.z.array(ToolDefinitionSchema).parse(tools);
      return tools;
    } catch (error) {
      if (error instanceof import_v4.z.ZodError) {
        const contextData = createErrorContext().withCustom("validationErrors", error.errors).withCustom("tools", tools).build();
        throw new ConfigurationError(
          `Tool definitions validation failed: ${this.formatZodErrors(error.errors)}`,
          contextData,
          error
        );
      }
      throw error;
    }
  }
  // Memory validation removed - memory should be BaseMemory instance, not config object
  // Validate human-in-the-loop configuration
  validateHumanInTheLoopConfig(config) {
    try {
      HumanInTheLoopConfigSchema.parse(config);
      return config;
    } catch (error) {
      if (error instanceof import_v4.z.ZodError) {
        const contextData = createErrorContext().withCustom("validationErrors", error.errors).withCustom("config", config).build();
        throw new ConfigurationError(
          `Human-in-the-loop configuration validation failed: ${this.formatZodErrors(error.errors)}`,
          contextData,
          error
        );
      }
      throw error;
    }
  }
  // Validate control flow configuration
  validateControlFlowConfig(config) {
    try {
      ControlFlowConfigSchema.parse(config);
      return config;
    } catch (error) {
      if (error instanceof import_v4.z.ZodError) {
        const contextData = createErrorContext().withCustom("validationErrors", error.errors).withCustom("config", config).build();
        throw new ConfigurationError(
          `Control flow configuration validation failed: ${this.formatZodErrors(error.errors)}`,
          contextData,
          error
        );
      }
      throw error;
    }
  }
  // Check for required configuration fields
  checkRequiredFields(config, requiredFields) {
    const missingFields = requiredFields.filter((field) => !(field in config));
    if (missingFields.length > 0) {
      const contextData = createErrorContext().withCustom("missingFields", missingFields).withCustom("config", config).build();
      throw new MissingRequiredConfigError(
        `Missing required configuration fields: ${missingFields.join(", ")}`,
        contextData
      );
    }
  }
  // Format Zod errors for better readability
  formatZodErrors(errors) {
    if (!errors || errors.length === 0) {
      return "Unknown validation error";
    }
    return errors.map((error) => {
      const path = error.path.length > 0 ? error.path.join(".") : "root";
      return `${path}: ${error.message}`;
    }).join("; ");
  }
  // Validate configuration with custom schema
  validateWithCustomSchema(data, schema, errorMessage) {
    try {
      schema.parse(data);
      return data;
    } catch (error) {
      if (error instanceof import_v4.z.ZodError) {
        const contextData = createErrorContext().withCustom("validationErrors", error.errors).withCustom("data", data).build();
        throw new ConfigurationError(
          `${errorMessage}: ${this.formatZodErrors(error.errors)}`,
          contextData,
          error
        );
      }
      throw error;
    }
  }
};
function validateConfig(schema) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = function(...args) {
      if (args.length > 0) {
        const configArg = args[0];
        if (configArg !== void 0 && configArg !== null) {
          try {
            schema.parse(configArg);
          } catch (error) {
            if (error instanceof import_v4.z.ZodError) {
              const contextData = createErrorContext().withCustom("validationErrors", error.errors).withCustom("config", configArg).build();
              throw new ConfigurationError(
                `Configuration validation failed: ${error.errors.map((e) => e.message).join("; ")}`,
                contextData,
                error
              );
            }
            throw error;
          }
        }
      }
      return originalMethod.apply(this, args);
    };
    return descriptor;
  };
}
var configValidator = ConfigValidator.getInstance();
function validateAgentName(name) {
  if (typeof name !== "string" || name.trim().length === 0) {
    throw new ConfigurationError("Agent name must be a non-empty string");
  }
  return name.trim();
}
function validateModelProvider(provider) {
  if (typeof provider !== "string" && typeof provider !== "object") {
    throw new ConfigurationError("Model provider must be a string or object");
  }
  return provider;
}
function validateInstructions(instructions) {
  if (typeof instructions !== "string" && typeof instructions !== "function") {
    throw new ConfigurationError("Instructions must be a string or function");
  }
  return instructions;
}

// src/core/tool-proxy.ts
init_events();
var ToolProxy = class {
  constructor(eventSystem, context) {
    this.tools = /* @__PURE__ */ new Map();
    this.eventSystem = eventSystem;
    this.executionContext = {
      timestamp: /* @__PURE__ */ new Date(),
      ...context
    };
  }
  /**
   * Register a tool with the proxy
   */
  registerTool(tool2) {
    if (this.tools.has(tool2.name)) {
      throw new Error(`Tool '${tool2.name}' is already registered`);
    }
    this.validateToolDefinition(tool2);
    this.tools.set(tool2.name, tool2);
    this.eventSystem.emit("TOOL_REGISTERED" /* TOOL_REGISTERED */, {
      type: "TOOL_REGISTERED" /* TOOL_REGISTERED */,
      toolName: tool2.name,
      timestamp: Date.now()
    });
  }
  /**
   * Remove a tool from the proxy
   */
  unregisterTool(toolName) {
    const removed = this.tools.delete(toolName);
    if (removed) {
      this.eventSystem.emit("TOOL_UNREGISTERED" /* TOOL_UNREGISTERED */, {
        type: "TOOL_UNREGISTERED" /* TOOL_UNREGISTERED */,
        toolName,
        timestamp: Date.now()
      });
    }
    return removed;
  }
  /**
   * Get a tool by name
   */
  getTool(toolName) {
    return this.tools.get(toolName);
  }
  /**
   * Get all registered tools
   */
  getAllTools() {
    return Array.from(this.tools.values());
  }
  /**
   * Get the number of registered tools
   */
  getToolCount() {
    return this.tools.size;
  }
  /**
   * Get tool names
   */
  getToolNames() {
    return Array.from(this.tools.keys());
  }
  /**
   * Check if a tool is registered
   */
  hasTool(toolName) {
    return this.tools.has(toolName);
  }
  /**
   * Execute a tool with the given input
   */
  async executeTool(toolName, input, context, state) {
    const tool2 = this.getTool(toolName);
    if (!tool2) {
      throw new ToolExecutionError(`Tool '${toolName}' not found`, {
        toolName,
        input,
        context: this.executionContext
      });
    }
    const mergedContext = {
      ...this.executionContext,
      ...context,
      timestamp: /* @__PURE__ */ new Date(),
      state
    };
    try {
      if (!tool2.invoke) {
        throw new ToolExecutionError(
          `Tool '${toolName}' has no handler (client-side tool)`,
          {
            toolName,
            input,
            context: mergedContext
          }
        );
      }
      const result = await tool2.invoke(input, mergedContext);
      return result;
    } catch (error) {
      this.eventSystem.emit("RUN_ERROR" /* RUN_ERROR */, {
        type: "RUN_ERROR" /* RUN_ERROR */,
        threadId: mergedContext.conversationId || "unknown",
        runId: mergedContext.runId || "unknown",
        message: error instanceof Error ? error.message : String(error),
        code: error instanceof Error ? error.name : "TOOL_EXECUTION_ERROR"
      });
      throw new ToolExecutionError(
        `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`,
        {
          toolName,
          input,
          context: mergedContext,
          originalError: error
        }
      );
    }
  }
  /**
   * Execute multiple tools in parallel
   */
  async executeToolsParallel(executions, state) {
    const promises = executions.map(async (execution) => {
      try {
        const result = await this.executeTool(
          execution.toolName,
          execution.input,
          execution.context,
          state
        );
        return { toolName: execution.toolName, result };
      } catch (error) {
        return {
          toolName: execution.toolName,
          result: null,
          error: error instanceof Error ? error : new Error(String(error))
        };
      }
    });
    return Promise.all(promises);
  }
  /**
   * Execute multiple tools sequentially
   */
  async executeToolsSequential(executions, state) {
    const results = [];
    for (const execution of executions) {
      try {
        const result = await this.executeTool(
          execution.toolName,
          execution.input,
          execution.context,
          state
        );
        results.push({ toolName: execution.toolName, result });
      } catch (error) {
        results.push({
          toolName: execution.toolName,
          result: null,
          error: error instanceof Error ? error : new Error(String(error))
        });
      }
    }
    return results;
  }
  /**
   * Validate tool input against schema if available
   */
  validateToolInput(toolName, input) {
    const tool2 = this.getTool(toolName);
    if (!tool2) {
      return false;
    }
    if (!tool2.schema) {
      return true;
    }
    try {
      tool2.schema.parse(input);
      return true;
    } catch (error) {
      return false;
    }
  }
  /**
   * Get tool metadata
   */
  getToolMetadata(toolName) {
    const tool2 = this.getTool(toolName);
    if (!tool2) {
      return null;
    }
    return {
      name: tool2.name,
      description: tool2.description,
      hasSchema: !!tool2.schema,
      requiresApproval: !!tool2.requiresApproval
    };
  }
  /**
   * Update execution context
   */
  updateExecutionContext(context) {
    this.executionContext = {
      ...this.executionContext,
      ...context,
      timestamp: /* @__PURE__ */ new Date()
    };
  }
  /**
   * Get current execution context
   */
  getExecutionContext() {
    return { ...this.executionContext };
  }
  /**
   * Clear all tools
   */
  clearTools() {
    const toolNames = this.getToolNames();
    for (const toolName of toolNames) {
      this.unregisterTool(toolName);
    }
  }
  /**
   * Get tools that require approval
   */
  getToolsRequiringApproval() {
    return this.getAllTools().filter((tool2) => tool2.requiresApproval);
  }
  /**
   * Validate tool definition
   */
  validateToolDefinition(tool2) {
    if (!tool2.name || typeof tool2.name !== "string") {
      throw new Error("Tool name must be a non-empty string");
    }
    if (tool2.schema && typeof tool2.schema.parse !== "function") {
      throw new Error("Tool schema must be a valid Zod schema");
    }
  }
};

// src/core/tool-execution-handler.ts
var import_node_crypto = require("crypto");
init_events();
var ToolExecutionHandler = class {
  constructor(toolProxy, maxRetries = 0, customHandler) {
    this.toolProxy = toolProxy;
    this.maxRetries = maxRetries;
    this.customHandler = customHandler;
  }
  /**
   * Execute a tool call with retry logic
   * Returns result object with success status and optional message to save
   */
  async executeWithRetry(eventEmitter, toolCall, assistantMessage, conversationMessages, allMessages, context, state) {
    let retryCount = 0;
    while (retryCount <= this.maxRetries) {
      try {
        const toolName = toolCall.function.name;
        const toolInput = toolCall.function.arguments ? JSON.parse(toolCall.function.arguments) : {};
        if (!toolName) {
          throw new Error(
            `Tool call missing function name. Tool call data: ${JSON.stringify(toolCall)}`
          );
        }
        if (this.customHandler) {
          try {
            const toolDecision = await this.customHandler.handleToolCall(
              toolCall,
              context,
              state
            );
            switch (toolDecision.action) {
              case "execute":
                break;
              case "request_approval":
                this.emitEvent(eventEmitter, {
                  type: "APPROVAL_REQUIRED" /* APPROVAL_REQUIRED */,
                  toolName,
                  toolInput,
                  approver: toolDecision.approver,
                  conversationId: context.conversationId,
                  runId: context.runId
                });
                throw new Error(
                  `Tool execution requires approval from ${toolDecision.approver}`
                );
              case "reject":
                throw new Error(
                  `Tool execution rejected: ${toolDecision.reason}`
                );
              case "modify":
                Object.assign(toolInput, toolDecision.newParams);
                break;
            }
          } catch (error) {
            console.error("Custom tool control flow handler error:", error);
          }
        }
        const tool2 = this.toolProxy.getTool(toolName);
        if (!tool2?.invoke) {
          const toolCallMessage = {
            role: "tool",
            tool_call_id: toolCall.id,
            content: `Tool '${toolName}' executed successfully by client. Result: ${JSON.stringify(toolInput)}`
          };
          conversationMessages.push(toolCallMessage);
          allMessages.push({
            id: (0, import_node_crypto.randomUUID)(),
            role: "tool",
            content: `Tool '${toolName}' executed successfully by client. Result: ${JSON.stringify(toolInput)}`,
            toolCallId: toolCall.id,
            timestamp: /* @__PURE__ */ new Date()
          });
          return { success: false };
        }
        const toolResult = await this.toolProxy.executeTool(
          toolName,
          toolInput,
          {
            conversationId: context.conversationId,
            runId: context.runId,
            timestamp: /* @__PURE__ */ new Date(),
            state
            // Pass state directly for direct modification
          },
          state
        );
        const cleanResult = toolResult;
        this.emitEvent(eventEmitter, {
          type: "TOOL_CALL_RESULT" /* TOOL_CALL_RESULT */,
          toolCallId: toolCall.id,
          content: JSON.stringify(cleanResult)
        });
        const toolResultMessage = {
          role: "tool",
          tool_call_id: toolCall.id,
          content: JSON.stringify(cleanResult)
        };
        conversationMessages.push(toolResultMessage);
        const toolMessage = {
          id: (0, import_node_crypto.randomUUID)(),
          role: "tool",
          content: JSON.stringify(cleanResult),
          timestamp: /* @__PURE__ */ new Date(),
          toolCallId: toolCall.id,
          metadata: {
            state: this.deepClone(state),
            conversationId: context.conversationId,
            runId: context.runId,
            userId: context.userId
          }
        };
        allMessages.push(toolMessage);
        return { success: true, messageToSave: toolMessage };
      } catch (error) {
        retryCount++;
        if (this.customHandler) {
          try {
            const errorDecision = await this.customHandler.handleError(
              error,
              context,
              state
            );
            switch (errorDecision.action) {
              case "retry":
                if (retryCount <= errorDecision.maxAttempts) {
                  console.warn(
                    `Tool execution failed for ${toolCall.function.name}, retrying (${retryCount}/${errorDecision.maxAttempts}):`,
                    error
                  );
                  await new Promise(
                    (resolve) => setTimeout(resolve, 1e3 * retryCount)
                  );
                  continue;
                }
                break;
              case "recover":
                break;
              case "escalate":
                this.emitEvent(eventEmitter, {
                  type: "APPROVAL_REQUIRED" /* APPROVAL_REQUIRED */,
                  toolName: toolCall.function.name,
                  error: error instanceof Error ? error.message : String(error),
                  target: errorDecision.target,
                  conversationId: context.conversationId,
                  runId: context.runId
                });
                throw new Error(
                  `Tool execution escalated to ${errorDecision.target}: ${error instanceof Error ? error.message : String(error)}`
                );
              case "abort":
                throw new Error(
                  `Tool execution aborted: ${errorDecision.reason}`
                );
            }
          } catch (handlerError) {
            console.error(
              "Custom error control flow handler error:",
              handlerError
            );
          }
        }
        if (retryCount > this.maxRetries) {
          console.error(
            `Tool execution failed for ${toolCall.function.name} after ${this.maxRetries} retries:`,
            error
          );
          const errorContent = `Error: ${error instanceof Error ? error.message : String(error)}`;
          conversationMessages.push({
            role: "tool",
            tool_call_id: toolCall.id,
            content: errorContent
          });
          allMessages.push({
            id: (0, import_node_crypto.randomUUID)(),
            role: "tool",
            content: errorContent,
            timestamp: /* @__PURE__ */ new Date(),
            toolCallId: toolCall.id
          });
        } else {
          console.warn(
            `Tool execution failed for ${toolCall.function.name}, retrying (${retryCount}/${this.maxRetries}):`,
            error
          );
          await new Promise(
            (resolve) => setTimeout(resolve, 1e3 * retryCount)
          );
        }
      }
    }
    return { success: false };
  }
  /**
   * Helper method to emit events
   */
  emitEvent(eventEmitter, event) {
    if (eventEmitter.next) {
      eventEmitter.next(event);
    } else if (eventEmitter.emit) {
      eventEmitter.emit(event.type, event);
    }
  }
  /**
   * Deep clone an object to prevent reference sharing
   */
  deepClone(obj) {
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => this.deepClone(item));
    }
    if (typeof obj === "object") {
      const cloned = {};
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          cloned[key] = this.deepClone(obj[key]);
        }
      }
      return cloned;
    }
    return obj;
  }
};

// src/core/message-builder.ts
var import_node_crypto2 = require("crypto");
var MessageBuilder = class {
  /**
   * Create a message with state metadata for memory storage
   */
  createMessageWithState(role, content, conversationId, state, options) {
    return {
      id: (0, import_node_crypto2.randomUUID)(),
      role,
      content,
      timestamp: /* @__PURE__ */ new Date(),
      toolCalls: options?.toolCalls,
      toolCallId: options?.toolCallId,
      metadata: {
        state: this.deepClone(state),
        conversationId,
        runId: options?.runId,
        userId: options?.userId
      }
    };
  }
  /**
   * Build initial messages for agent execution
   */
  buildInitialMessages(systemInstruction, conversationMessages) {
    const messages = [
      { role: "system", content: systemInstruction }
    ];
    for (const message of conversationMessages) {
      if (message.role === "user") {
        messages.push({
          role: "user",
          content: message.content
        });
      } else if (message.role === "assistant") {
        const assistantMessage = {
          role: "assistant",
          content: message.content
        };
        if (message.toolCalls && message.toolCalls.length > 0) {
          assistantMessage.tool_calls = message.toolCalls;
        }
        messages.push(assistantMessage);
      } else if (message.role === "tool") {
        messages.push({
          role: "tool",
          tool_call_id: message.toolCallId,
          content: message.content
        });
      }
    }
    return messages;
  }
  /**
   * Extract current state from messages
   */
  extractStateFromMessages(messages) {
    const lastMessage = messages[messages.length - 1];
    if (lastMessage?.metadata?.state) {
      return lastMessage.metadata.state;
    }
    return {};
  }
  /**
   * Deep clone an object to prevent reference sharing
   */
  deepClone(obj) {
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => this.deepClone(item));
    }
    if (typeof obj === "object") {
      const cloned = {};
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          cloned[key] = this.deepClone(obj[key]);
        }
      }
      return cloned;
    }
    return obj;
  }
};

// src/core/agent-executor.ts
var import_node_crypto3 = require("crypto");
init_events();
var import_v42 = require("zod/v4");
var AgentExecutor = class {
  constructor(config, modelProvider, toolExecutionHandler, messageBuilder, getBusinessState, addMessages, syncState) {
    this.config = config;
    this.modelProvider = modelProvider;
    this.toolExecutionHandler = toolExecutionHandler;
    this.messageBuilder = messageBuilder;
    this.getBusinessState = getBusinessState;
    this.addMessages = addMessages;
    this.syncState = syncState;
  }
  /**
   * Execute the agent core loop
   * @param eventEmitter - Event emitter (EventSystem or Observable subscriber)
   * @param context - Run context containing conversation state
   * @param options - Runtime options
   * @param returnResult - Whether to return result or just emit events
   * @returns AgentResult if returnResult is true, void otherwise
   */
  async execute(eventEmitter, context, options, returnResult = true) {
    const startTime = Date.now();
    const maxIterations = this.config.controlFlow?.maxSteps;
    let iteration = 0;
    try {
      this.emitEvent(eventEmitter, {
        type: "STEP_STARTED" /* STEP_STARTED */,
        stepName: "build_initial_messages"
      });
      const systemInstruction = await this.getSystemInstruction(context);
      let conversationMessages = this.messageBuilder.buildInitialMessages(
        systemInstruction,
        context.messages
      );
      this.emitEvent(eventEmitter, {
        type: "STEP_FINISHED" /* STEP_FINISHED */,
        stepName: "build_initial_messages"
      });
      const loopResult = await this.executeAgentLoop(
        eventEmitter,
        context,
        conversationMessages,
        options,
        maxIterations,
        iteration,
        startTime
      );
      if (loopResult.earlyReturn) {
        return returnResult ? loopResult.result : void 0;
      }
      const outputData = await this.transformOutput(loopResult.finalResponse);
      const executionTime = Date.now() - startTime;
      const result = this.buildResult(
        outputData,
        loopResult.allMessages,
        context,
        executionTime,
        loopResult.totalTokenUsage
      );
      if (!returnResult) {
        this.emitEvent(eventEmitter, {
          type: "RUN_FINISHED" /* RUN_FINISHED */,
          threadId: context.conversationId,
          runId: context.runId,
          result,
          executionTime
        });
      }
      return returnResult ? result : void 0;
    } catch (error) {
      const executionTime = Date.now() - startTime;
      this.emitErrorEvent(eventEmitter, context, error, executionTime);
      throw error;
    }
  }
  /**
   * Execute the main agent loop
   */
  async executeAgentLoop(eventEmitter, context, conversationMessages, options, maxIterations, iteration, startTime) {
    let finalResponse = "";
    let allMessages = [];
    let totalTokenUsage = null;
    const customHandler = this.config.controlFlow?.customHandler;
    while (maxIterations === void 0 || iteration < maxIterations) {
      iteration++;
      if (options?.signal?.aborted) {
        throw new Error(
          `Run aborted: ${options.signal.reason || "AbortSignal was aborted"}`
        );
      }
      const controlResult = await this.checkControlFlow(
        customHandler,
        context,
        eventEmitter,
        startTime,
        allMessages,
        totalTokenUsage
      );
      if (controlResult) {
        return {
          finalResponse,
          allMessages,
          totalTokenUsage,
          earlyReturn: true,
          result: controlResult
        };
      }
      this.emitEvent(eventEmitter, {
        type: "STEP_STARTED" /* STEP_STARTED */,
        stepName: `agent_loop_iteration_${iteration}`
      });
      const iterationResult = await this.executeSingleIteration(
        eventEmitter,
        context,
        conversationMessages,
        options,
        allMessages
      );
      totalTokenUsage = this.accumulateTokenUsage(
        totalTokenUsage,
        iterationResult.tokenUsage
      );
      this.emitEvent(eventEmitter, {
        type: "STEP_FINISHED" /* STEP_FINISHED */,
        stepName: `agent_loop_iteration_${iteration}`
      });
      if (iterationResult.isDone) {
        finalResponse = iterationResult.content;
        break;
      }
      if (!iterationResult.allToolsHandled) {
        break;
      }
    }
    if (maxIterations !== void 0 && iteration >= maxIterations) {
      console.warn(
        `\u26A0\uFE0F  Agent loop reached maximum iterations (${maxIterations})`
      );
      finalResponse = finalResponse || "Maximum iterations reached. The agent was unable to complete the task.";
    }
    return { finalResponse, allMessages, totalTokenUsage };
  }
  /**
   * Execute a single iteration of the agent loop
   */
  async executeSingleIteration(eventEmitter, context, conversationMessages, options, allMessages) {
    const llmResponse = await this.callLLM(
      conversationMessages,
      context,
      options,
      true
    );
    const streamResult = await this.processStreamingResponse(
      llmResponse,
      eventEmitter,
      options
    );
    const assistantMessage = await this.saveAssistantMessage(
      streamResult.content,
      streamResult.toolCalls,
      context,
      allMessages,
      conversationMessages
    );
    if (streamResult.toolCalls.length === 0) {
      return {
        content: streamResult.content,
        isDone: true,
        allToolsHandled: true,
        tokenUsage: streamResult.tokenUsage
      };
    }
    const allToolsHandled = await this.executeToolCalls(
      streamResult.toolCalls,
      eventEmitter,
      context,
      conversationMessages,
      allMessages,
      assistantMessage
    );
    return {
      content: streamResult.content,
      isDone: false,
      allToolsHandled,
      tokenUsage: streamResult.tokenUsage
    };
  }
  /**
   * Process streaming response from LLM
   */
  async processStreamingResponse(llmResponse, eventEmitter) {
    let messageId;
    let content = "";
    let toolCalls = [];
    let tokenUsage = null;
    for await (const chunk of llmResponse) {
      const choice = chunk.choices?.[0];
      if (!choice) continue;
      if (choice.delta?.role && !messageId) {
        messageId = (0, import_node_crypto3.randomUUID)();
        this.emitEvent(eventEmitter, {
          type: "TEXT_MESSAGE_START" /* TEXT_MESSAGE_START */,
          messageId,
          role: "assistant"
        });
      }
      if (choice.delta?.content) {
        content += choice.delta.content;
        this.emitEvent(eventEmitter, {
          type: "TEXT_MESSAGE_CONTENT" /* TEXT_MESSAGE_CONTENT */,
          messageId,
          delta: choice.delta.content
        });
      }
      if (choice.delta?.tool_calls) {
        this.processToolCallDeltas(
          choice.delta.tool_calls,
          toolCalls,
          eventEmitter
        );
      }
      if (chunk.usage) {
        tokenUsage = this.accumulateTokenUsage(tokenUsage, chunk.usage);
      }
    }
    if (messageId) {
      this.emitEvent(eventEmitter, {
        type: "TEXT_MESSAGE_END" /* TEXT_MESSAGE_END */,
        messageId
      });
    }
    if (toolCalls.length > 0) {
      for (const toolCall of toolCalls) {
        this.emitEvent(eventEmitter, {
          type: "TOOL_CALL_END" /* TOOL_CALL_END */,
          toolCallId: toolCall.id
        });
      }
    }
    return { content, toolCalls, tokenUsage };
  }
  /**
   * Process tool call deltas from streaming response
   */
  processToolCallDeltas(toolCallDeltas, toolCalls, eventEmitter) {
    for (const toolCallDelta of toolCallDeltas) {
      let toolCallIndex = toolCallDelta.index;
      if (toolCallIndex === void 0 || toolCallIndex < 0) {
        toolCallIndex = toolCalls.length;
      }
      if (!toolCalls[toolCallIndex]) {
        toolCalls[toolCallIndex] = {
          id: toolCallDelta.id || (0, import_node_crypto3.randomUUID)(),
          type: toolCallDelta.type || "function",
          function: {
            name: "",
            arguments: ""
          }
        };
        this.emitEvent(eventEmitter, {
          type: "TOOL_CALL_START" /* TOOL_CALL_START */,
          toolCallId: toolCalls[toolCallIndex].id,
          toolCallName: toolCallDelta.function?.name || ""
        });
      } else {
        if (toolCallDelta.id && toolCalls[toolCallIndex].id !== toolCallDelta.id) {
          toolCalls[toolCallIndex].id = toolCallDelta.id;
        }
      }
      if (toolCallDelta.function?.name) {
        toolCalls[toolCallIndex].function.name = toolCallDelta.function.name;
      }
      if (toolCallDelta.function?.arguments) {
        toolCalls[toolCallIndex].function.arguments += toolCallDelta.function.arguments;
        this.emitEvent(eventEmitter, {
          type: "TOOL_CALL_ARGS" /* TOOL_CALL_ARGS */,
          toolCallId: toolCalls[toolCallIndex].id,
          delta: toolCallDelta.function.arguments
        });
      }
    }
  }
  /**
   * Save assistant message to conversation
   */
  async saveAssistantMessage(content, toolCalls, context, allMessages, conversationMessages) {
    const assistantMessage = this.messageBuilder.createMessageWithState(
      "assistant",
      content,
      context.conversationId,
      this.getBusinessState(),
      {
        runId: context.runId,
        userId: context.userId
      }
    );
    if (toolCalls.length > 0) {
      assistantMessage.toolCalls = toolCalls.map((tc) => ({
        id: tc.id,
        type: tc.type,
        function: {
          name: tc.function.name,
          arguments: tc.function.arguments
        }
      }));
    }
    allMessages.push(assistantMessage);
    await this.addMessages(
      context.conversationId,
      [assistantMessage],
      this.getBusinessState()
    );
    const assistantConversationMessage = {
      role: "assistant",
      content: content || null
    };
    if (toolCalls.length > 0) {
      assistantConversationMessage.tool_calls = toolCalls;
    }
    conversationMessages.push(assistantConversationMessage);
    return assistantMessage;
  }
  /**
   * Execute all tool calls
   */
  async executeToolCalls(toolCalls, eventEmitter, context, conversationMessages, allMessages, assistantMessage) {
    let allToolsHandled = true;
    for (const toolCall of toolCalls) {
      const result = await this.toolExecutionHandler.executeWithRetry(
        eventEmitter,
        toolCall,
        assistantMessage,
        conversationMessages,
        allMessages,
        context,
        this.getBusinessState()
      );
      if (result.messageToSave) {
        await this.addMessages(
          context.conversationId,
          [result.messageToSave],
          this.getBusinessState()
        );
        if (this.syncState && result.messageToSave.metadata?.state) {
          const updatedState = result.messageToSave.metadata.state;
          this.syncState(updatedState);
        }
      }
      if (!result.success) {
        allToolsHandled = false;
      }
    }
    return allToolsHandled;
  }
  /**
   * Check custom control flow handler
   */
  async checkControlFlow(customHandler, context, eventEmitter, startTime, allMessages, totalTokenUsage) {
    if (!customHandler) return null;
    try {
      const latestUserMessage = allMessages.filter((m) => m.role === "user").pop()?.content || "";
      const state = this.getBusinessState();
      const userMessage = state?.userResponse || latestUserMessage;
      const controlDecision = await customHandler.handleNextStep(
        context,
        state,
        userMessage
      );
      if (this.syncState) {
        this.syncState(state);
      }
      switch (controlDecision.action) {
        case "continue":
          return null;
        case "pause":
          this.emitEvent(eventEmitter, {
            type: "EXECUTION_PAUSED" /* EXECUTION_PAUSED */,
            reason: controlDecision.reason,
            conversationId: context.conversationId,
            runId: context.runId
          });
          throw new Error(`Execution paused: ${controlDecision.reason}`);
        case "complete":
          return this.buildResult(
            controlDecision.result,
            allMessages,
            context,
            Date.now() - startTime,
            totalTokenUsage
          );
        case "interrupt":
          this.emitEvent(eventEmitter, {
            type: "RUN_FINISHED" /* RUN_FINISHED */,
            threadId: context.conversationId,
            runId: context.runId,
            outcome: "interrupt",
            interrupt: {
              id: (0, import_node_crypto3.randomUUID)(),
              reason: controlDecision.reason,
              payload: controlDecision.payload
            }
          });
          return {
            success: true,
            data: "",
            messages: allMessages,
            metadata: {
              conversationId: context.conversationId,
              runId: context.runId,
              executionTime: Date.now() - startTime,
              tokenUsage: this.buildTokenUsage(totalTokenUsage),
              outcome: "interrupt",
              interrupt: {
                reason: controlDecision.reason,
                payload: controlDecision.payload
              }
            }
          };
        case "escalate":
          this.emitEvent(eventEmitter, {
            type: "APPROVAL_REQUIRED" /* APPROVAL_REQUIRED */,
            target: controlDecision.target,
            context: controlDecision.context,
            conversationId: context.conversationId,
            runId: context.runId
          });
          throw new Error(
            `Execution escalated to ${controlDecision.target}`
          );
      }
    } catch (error) {
      console.error("Custom control flow handler error:", error);
    }
    return null;
  }
  /**
   * Get system instruction
   */
  async getSystemInstruction(context) {
    if (typeof this.config.instructions === "function") {
      return await this.config.instructions(this.getBusinessState(), context);
    }
    return `${this.config.instructions} You are an Agent named "${this.config.name || "unnamed"}" ${this.config.description ? `with description: "${this.config.description}".` : ""}.` || "You are a helpful AI assistant. Do not assume or guess parameter values for function calls. If the user's description is unclear, ask the user to provide necessary information.";
  }
  /**
   * Transform output using configured output type
   */
  async transformOutput(finalResponse) {
    if (this.config.outputType && typeof this.config.outputType === "object" && "schema" in this.config.outputType) {
      const zodSchema = this.config.outputType.schema;
      if (zodSchema) {
        try {
          const parsedOutput = JSON.parse(finalResponse);
          const validatedOutput = zodSchema.parse(parsedOutput);
          return validatedOutput;
        } catch (error) {
          console.error("Output validation failed:", error);
          return finalResponse;
        }
      }
    }
    return finalResponse;
  }
  /**
   * Build final result object
   */
  buildResult(outputData, allMessages, context, executionTime, totalTokenUsage) {
    return {
      success: true,
      data: outputData,
      messages: allMessages,
      metadata: {
        conversationId: context.conversationId,
        runId: context.runId,
        executionTime,
        tokenUsage: this.buildTokenUsage(totalTokenUsage)
      }
    };
  }
  /**
   * Build token usage object
   */
  buildTokenUsage(totalTokenUsage) {
    return totalTokenUsage ? {
      promptTokens: totalTokenUsage.prompt_tokens || 0,
      completionTokens: totalTokenUsage.completion_tokens || 0,
      totalTokens: totalTokenUsage.total_tokens || 0
    } : {
      promptTokens: 0,
      completionTokens: 0,
      totalTokens: 0
    };
  }
  /**
   * Accumulate token usage
   */
  accumulateTokenUsage(currentUsage, newUsage) {
    if (!newUsage) return currentUsage;
    if (!currentUsage) {
      return { ...newUsage };
    }
    return {
      prompt_tokens: (currentUsage.prompt_tokens || 0) + (newUsage.prompt_tokens || 0),
      completion_tokens: (currentUsage.completion_tokens || 0) + (newUsage.completion_tokens || 0),
      total_tokens: (currentUsage.total_tokens || 0) + (newUsage.total_tokens || 0)
    };
  }
  /**
   * Call LLM with streaming
   */
  async callLLM(messages, context, options, stream = false) {
    if (!this.modelProvider?.chat) {
      throw new Error("No model provider configured or chat interface not available");
    }
    const modelName = this.getModelName(options);
    const toolDefinitions = this.prepareToolDefinitions(options);
    const requestParams = {
      model: modelName,
      messages,
      temperature: options?.temperature ?? this.config.modelSettings?.temperature ?? 0.7,
      max_tokens: options?.maxTokens ?? this.config.modelSettings?.maxTokens ?? 1e3,
      stream
    };
    if (toolDefinitions && toolDefinitions.length > 0) {
      requestParams.tools = toolDefinitions;
      requestParams.tool_choice = "auto";
    }
    if (options?.signal) {
      requestParams.signal = options.signal;
    }
    return this.modelProvider.chat.completions.stream(requestParams);
  }
  /**
   * Get model name from options or config
   */
  getModelName(options) {
    if (options?.model) {
      return options.model;
    }
    if (typeof this.config.model === "string") {
      return this.config.model;
    }
    return this.modelProvider.getDefaultModel();
  }
  /**
   * Prepare tool definitions for LLM
   */
  prepareToolDefinitions(options) {
    const configTools = this.config.tools ?? [];
    const runtimeTools = options?.tools ?? [];
    if (!configTools.length && !runtimeTools.length) return void 0;
    const byName = /* @__PURE__ */ new Map();
    for (const t of configTools) byName.set(t.name, t);
    for (const t of runtimeTools) byName.set(t.name, t);
    const mergedTools = Array.from(byName.values());
    return mergedTools.map((tool2) => {
      const isZodSchema = !!tool2.schema && typeof tool2.schema.safeParse === "function";
      let parameters;
      if (isZodSchema) {
        try {
          parameters = import_v42.z.toJSONSchema(tool2.schema);
        } catch (error) {
          parameters = tool2.schema;
        }
      } else {
        parameters = tool2.schema;
      }
      return {
        type: "function",
        function: {
          name: tool2.name,
          description: tool2.description,
          parameters
        }
      };
    });
  }
  /**
   * Emit event to either EventSystem or Observable subscriber
   */
  emitEvent(eventEmitter, event) {
    if (eventEmitter.next) {
      eventEmitter.next(event);
    } else {
      eventEmitter.emit(event.type, event);
    }
  }
  /**
   * Emit error event
   */
  emitErrorEvent(eventEmitter, context, error, executionTime) {
    this.emitEvent(eventEmitter, {
      type: "RUN_ERROR" /* RUN_ERROR */,
      threadId: context.conversationId,
      runId: context.runId,
      message: error instanceof Error ? error.message : String(error),
      code: error instanceof Error ? error.name : "UNKNOWN_ERROR",
      details: error
    });
  }
};

// src/core/storage/utils/token-utils.ts
var import_tiktoken = require("tiktoken");
var TiktokenTokenizer = class {
  /**
   * Creates a new TiktokenTokenizer instance
   * @param encodingName - Tiktoken encoding name, defaults to 'o200k_base'
   */
  constructor(encodingName = "o200k_base") {
    this.encoding = (0, import_tiktoken.get_encoding)(encodingName);
  }
  /**
   * Encode text into token array
   * @param text - Text to encode
   * @returns Array of token IDs
   */
  encode(text) {
    return this.encoding.encode(text);
  }
  /**
   * Decode tokens back to text
   * @param tokens - Token array to decode
   * @returns Decoded text string
   */
  decode(tokens) {
    const decoded = this.encoding.decode(tokens);
    return typeof decoded === "string" ? decoded : new TextDecoder().decode(decoded);
  }
  /**
   * Count the number of tokens in text
   * @param text - Text to count tokens for
   * @returns Number of tokens
   */
  countTokens(text) {
    return this.encoding.encode(text).length;
  }
  /**
   * Free the encoding resources
   */
  free() {
    this.encoding.free();
  }
};
var TokenTrimmer = class {
  /**
   * Creates a new TokenTrimmer instance
   * @param tokenizer - Optional tokenizer, defaults to TiktokenTokenizer
   */
  constructor(tokenizer) {
    this.tokenizer = tokenizer || new TiktokenTokenizer();
  }
  /**
   * Calculate the token count for a message including role and content
   * @param message - Message object with role and content
   * @returns Total token count including formatting overhead
   */
  countMessageTokens(message) {
    const roleTokens = this.tokenizer.countTokens(message.role);
    const contentTokens = this.tokenizer.countTokens(message.content);
    return roleTokens + contentTokens + 4;
  }
  /**
   * Trim message list to fit within token limits
   * Preserves messages starting from newest or oldest based on strategy
   * @param events - Array of events with message objects
   * @param maxTokens - Maximum token limit
   * @param strategy - Trimming strategy: 'newest_first' or 'oldest_first'
   * @returns Trimmed array of events within token limit
   */
  trimMessages(events, maxTokens, strategy = "newest_first") {
    if (maxTokens <= 0) {
      return [];
    }
    const eventsToProcess = strategy === "newest_first" ? [...events].reverse() : [...events];
    const result = [];
    let totalTokens = 0;
    for (const event of eventsToProcess) {
      const messageTokens = this.countMessageTokens(event.message);
      if (totalTokens + messageTokens <= maxTokens) {
        result.push(event);
        totalTokens += messageTokens;
      } else {
        if (result.length === 0 && messageTokens > maxTokens) {
          const truncatedEvent = this.truncateMessage(event, maxTokens);
          if (truncatedEvent) {
            result.push(truncatedEvent);
          }
        }
        break;
      }
    }
    return strategy === "newest_first" ? result.reverse() : result;
  }
  /**
   * Truncate a single message to fit within token limits
   * @param event - Event to truncate
   * @param maxTokens - Maximum token limit
   * @returns Truncated event or null if cannot fit
   */
  truncateMessage(event, maxTokens) {
    const roleTokens = this.tokenizer.countTokens(event.message.role);
    const availableTokens = maxTokens - roleTokens - 4;
    if (availableTokens <= 0) {
      return null;
    }
    let left = 0;
    let right = event.message.content.length;
    let bestLength = 0;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const truncatedContent = event.message.content.substring(0, mid);
      const contentTokens = this.tokenizer.countTokens(truncatedContent);
      if (contentTokens <= availableTokens) {
        bestLength = mid;
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    if (bestLength === 0) {
      return null;
    }
    return {
      ...event,
      message: {
        ...event.message,
        content: event.message.content.substring(0, bestLength) + "..."
      }
    };
  }
  /**
   * Free tokenizer resources
   */
  free() {
    if (this.tokenizer instanceof TiktokenTokenizer) {
      this.tokenizer.free();
    }
  }
};

// src/core/storage/memory/memory-base.ts
var BaseMemory = class {
  constructor(config) {
    // Metrics
    this.compactionCount = 0;
    this.summarizationCount = 0;
    this.lastCompactionGain = 0;
    this.tokenTrimmer = new TokenTrimmer(
      config?.tokenizer || new TiktokenTokenizer()
    );
    if (config?.thresholds) {
      this.thresholds = {
        preRotThreshold: config.thresholds.preRotThreshold || 15e4,
        compactionTrigger: config.thresholds.compactionTrigger || 0.8,
        summarizationTrigger: config.thresholds.summarizationTrigger || 0.95,
        recentToKeep: config.thresholds.recentToKeep || 5
      };
    }
    if (config?.summarizer) {
      this.summarizer = config.summarizer;
    }
  }
  /**
   * Add multiple memory events efficiently
   *
   * Implementations should override this method to handle bulk addition
   * efficiently and avoid unnecessary round-trips to the underlying store.
   *
   * @param list - Array of memory events to store
   * @returns Promise that resolves when all events are stored
   */
  async addList(list, options) {
    for (const event of list) {
      await this.add(event, options);
    }
  }
  /**
   * Remove all events from storage
   * @returns Promise that resolves when all events are cleared
   * @throws Error if not implemented by subclass
   */
  clear() {
    throw new Error("Clear method not implemented.");
  }
  // ==================== Session Branching (Optional) ====================
  /**
   * Create a new branch from current session state
   * @param branchName - Name for the new branch
   * @param fromEventId - Optional event ID to branch from
   * @returns Promise resolving to branch ID
   * @throws Error if not implemented by subclass
   */
  branch(branchName, fromEventId) {
    throw new Error("Branch method not implemented.");
  }
  /**
   * Switch to a different branch or checkout to a specific event
   * @param target - Branch name or event ID to checkout
   * @param options - Optional configuration
   * @param options.type - Type of checkout: 'branch' or 'event' (default: auto-detect)
   * @param options.sessionId - Session ID when checking out to an event
   * @returns Promise that resolves when checkout is complete
   * @throws Error if not implemented by subclass
   *
   * @example
   * // Checkout to a branch
   * await memory.checkout('experiment-1');
   *
   * // Checkout to a specific event (deletes all events after it)
   * await memory.checkout('event-123', { type: 'event', sessionId: 'session-1' });
   */
  checkout(target, options) {
    throw new Error("Checkout method not implemented.");
  }
  /**
   * List all available branches
   * @returns Promise resolving to array of branch information
   * @throws Error if not implemented by subclass
   */
  listBranches() {
    throw new Error("ListBranches method not implemented.");
  }
  /**
   * Delete a branch
   * @param branchName - Name of the branch to delete
   * @returns Promise that resolves when deletion is complete
   * @throws Error if not implemented by subclass or trying to delete active branch
   */
  deleteBranch(branchName) {
    throw new Error("DeleteBranch method not implemented.");
  }
  /**
   * Clean up all inactive branches, keeping only the main branch
   * This is useful for maintaining a single trunk after experimentation
   * @param keepBranches - Optional list of branch names to keep (in addition to active branch)
   * @returns Promise that resolves when cleanup is complete
   * @throws Error if not implemented by subclass
   */
  cleanupBranches(keepBranches) {
    throw new Error("CleanupBranches method not implemented.");
  }
  // ==================== Context Engineering (Optional) ====================
  /**
   * Check if an event is compacted
   * @param event - Event to check
   * @returns True if event has compaction metadata
   */
  isCompacted(event) {
    return event.state?.__compaction__ !== void 0;
  }
  /**
   * Decompress a compacted event
   * @param event - Event to decompress
   * @returns Decompressed event with original content and state
   */
  decompressEvent(event) {
    if (!this.isCompacted(event)) {
      return event;
    }
    const { __compaction__, ...metadata } = event.state;
    return {
      message: {
        ...event.message,
        content: __compaction__.originalContent
      },
      state: metadata
    };
  }
  /**
   * Decompress multiple events
   * @param events - Events to decompress
   * @returns Array of decompressed events
   */
  decompressEvents(events) {
    return events.map((e) => this.decompressEvent(e));
  }
  // ==================== Context Engineering Core Methods ====================
  /**
   * Manage context automatically when adding events
   * Subclasses should call this method after adding events if context management is enabled
   */
  async manageContext({
    sessionId,
    events
  }) {
    if (!this.thresholds) {
      return { events };
    }
    const currentTokens = await this.getCurrentTokenCount(events);
    const compactionThreshold = this.thresholds.preRotThreshold * this.thresholds.compactionTrigger;
    const summarizationThreshold = this.thresholds.preRotThreshold * this.thresholds.summarizationTrigger;
    if (this.thresholds?.recentToKeep && events.length > this.thresholds?.recentToKeep) {
      if (currentTokens >= summarizationThreshold) {
        const { events: processedEvents } = await this.performSummarization({ sessionId, events });
        return { events: processedEvents };
      }
      if (currentTokens >= compactionThreshold) {
        const { events: compactedEvents, gain: gainFromCompaction } = await this.performCompaction({
          sessionId,
          events
        });
        if (gainFromCompaction > this.thresholds.preRotThreshold * 0.05) {
          return { events: compactedEvents };
        }
        const { events: processedEvents } = await this.performSummarization({ sessionId, events });
        return { events: processedEvents };
      }
    }
    return { events };
  }
  /**
   * Perform compaction (reversible externalization to event.state)
   * Subclasses should override this method to implement compaction logic
   * @returns Token gain from compaction
   */
  async performCompaction({
    sessionId,
    events
  }) {
    const tokensBefore = await this.getCurrentTokenCount(events);
    const totalEvents = events.length;
    const recentToKeep = this.thresholds.recentToKeep;
    const delta = totalEvents - recentToKeep;
    if (delta <= 0) {
      return { events, gain: 0 };
    }
    const processedEvents = await Promise.all(events.map(async (event, i) => {
      if (i < delta) {
        if (!this.isCompacted(event)) {
          return this.compactEvent({ sessionId, event });
        }
      }
      return event;
    }));
    const tokensAfter = await this.getCurrentTokenCount(processedEvents);
    const gain = tokensBefore - tokensAfter;
    this.compactionCount++;
    this.lastCompactionGain = gain;
    return { events: processedEvents, gain };
  }
  /**
   * Compact a single event - store full content in state
   */
  async compactEvent({
    sessionId,
    event
  }) {
    if (!this.tokenTrimmer) {
      return event;
    }
    const originalTokens = await this.tokenTrimmer.countMessageTokens(
      event.message
    );
    const compactionMetadata = {
      originalContent: event.message.content,
      originalTokens,
      compactedTokens: 0
    };
    const compactContent = `[Compacted: ${event.message.role} message, ${originalTokens} tokens]`;
    event.message.content = compactContent;
    event.state = {
      ...event.state,
      __compaction__: compactionMetadata
    };
    compactionMetadata.compactedTokens = await this.tokenTrimmer.countMessageTokens(event.message);
    await this.update({ sessionId, event });
    return event;
  }
  /**
   * Perform summarization (irreversible refinement)
   * @param sessionId - Optional session identifier (implementation-specific)
   */
  async performSummarization({
    sessionId,
    events
  }) {
    const recentToKeep = this.thresholds.recentToKeep;
    if (events.length <= recentToKeep) {
      return { events };
    }
    const eventsToSummarize = events.slice(0, -recentToKeep);
    const decompressedEvents = this.decompressEvents(eventsToSummarize);
    const summary = await this.summarizer(decompressedEvents);
    await this.storeSummary({ sessionId, summary });
    await this.clearSummarizedEvents({ sessionId, recentToKeep });
    this.summarizationCount++;
    return { events: events.slice(-recentToKeep), summary };
  }
  /**
   * Store summary (to be implemented by subclasses)
   * @param summary - The structured summary to store
   */
  async storeSummary(params) {
  }
  /**
   * Clear summarized events (to be implemented by subclasses)
   * @param sessionId - Optional session identifier (implementation-specific)
   * @param recentToKeep - Number of recent events to keep
   */
  async clearSummarizedEvents(params) {
  }
  /**
   * Get current token count for a session
   */
  async getCurrentTokenCount(events) {
    if (!this.tokenTrimmer) {
      return 0;
    }
    let total = 0;
    for (const event of events) {
      if (this.isCompacted(event)) {
        const __compaction__ = event.state.__compaction__;
        total += __compaction__.compactedTokens;
      } else {
        total += await this.tokenTrimmer.countMessageTokens(event.message);
      }
    }
    return total;
  }
  /**
   * Create default structured summary
   */
  async summarizer(events) {
    return {
      content: "",
      count: events.length,
      timeRange: {
        start: events[0]?.message.timestamp,
        end: events[events.length - 1]?.message.timestamp
      },
      timestamp: /* @__PURE__ */ new Date()
    };
  }
};

// src/core/storage/memory/in-memory/utils.ts
var CollectionManager = class {
  constructor() {
    const { InMemoryAdapter: InMemoryAdapter2 } = (init_in_memory_adapter(), __toCommonJS(in_memory_adapter_exports));
    this.adapter = new InMemoryAdapter2();
    this.eventsCollection = [];
    this.summaryCollection = [];
    this.stateCollection = [];
  }
  /**
   * Get the main events collection
   */
  getCollection() {
    return this.eventsCollection;
  }
  /**
   * Get the summary collection
   */
  getSummaryCollection() {
    return this.summaryCollection;
  }
  /**
   * Get the state collection
   */
  getStateCollection() {
    return this.stateCollection;
  }
  /**
   * Get database adapter
   */
  getAdapter() {
    return this.adapter;
  }
  /**
   * Get database instance (not applicable for in-memory, returns null)
   */
  getDatabase() {
    return null;
  }
  /**
   * Clear all collections (useful for testing)
   */
  clearAll() {
    this.eventsCollection.length = 0;
    this.summaryCollection.length = 0;
    this.stateCollection.length = 0;
  }
};
var DocumentConverter = class {
  /**
   * Convert IMemoryEvent to in-memory document
   */
  toDocument(event, sessionId, branchPath) {
    return {
      sessionId,
      messageId: event.message.id,
      branchPath,
      role: event.message.role,
      content: event.message.content,
      toolCalls: event.message.toolCalls,
      toolCallId: event.message.toolCallId,
      state: event.state || {},
      createdAt: event.message.timestamp || /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    };
  }
  /**
   * Convert in-memory document to IMemoryEvent
   */
  fromDocument(doc) {
    return {
      message: {
        id: doc.messageId,
        role: doc.role,
        content: doc.content,
        toolCalls: doc.toolCalls,
        toolCallId: doc.toolCallId,
        timestamp: doc.createdAt
      },
      state: doc.state
    };
  }
};

// src/core/storage/memory/common/state-manager.ts
var StateManager = class {
  constructor(collectionManager) {
    this.collectionManager = collectionManager;
    this.stateCache = /* @__PURE__ */ new Map();
    this.branchesCache = null;
  }
  /**
   * Get state document for a session
   */
  async getStateDocument(sessionId) {
    if (this.stateCache.has(sessionId)) {
      return this.stateCache.get(sessionId);
    }
    try {
      const collection = this.collectionManager.getStateCollection();
      const adapter = this.collectionManager.getAdapter();
      const state = await adapter.findOne(collection, { sessionId });
      if (state) {
        this.stateCache.set(sessionId, state);
        return state;
      }
      return null;
    } catch (error) {
      console.error("Error getting state document:", error);
      return null;
    }
  }
  /**
   * Update state document
   */
  async updateStateDocument(sessionId, updates) {
    try {
      const collection = this.collectionManager.getStateCollection();
      const adapter = this.collectionManager.getAdapter();
      const existingState = await this.getStateDocument(sessionId);
      if (existingState && existingState._id) {
        await adapter.updateOne(
          collection,
          { _id: existingState._id },
          {
            ...updates,
            updatedAt: /* @__PURE__ */ new Date()
          }
        );
        const updatedState = await adapter.findOne(collection, { sessionId });
        if (updatedState) {
          this.stateCache.set(sessionId, updatedState);
        }
      } else {
        const newState = {
          sessionId,
          currentBranch: "main",
          branches: {},
          createdAt: /* @__PURE__ */ new Date(),
          updatedAt: /* @__PURE__ */ new Date(),
          ...updates
        };
        const result = await adapter.insertOne(collection, newState);
        this.stateCache.set(sessionId, result);
      }
      this.branchesCache = null;
    } catch (error) {
      console.error("Error updating state document:", error);
      throw error;
    }
  }
  /**
   * Get current branch name
   */
  async getCurrentBranch(sessionId) {
    const state = await this.getStateDocument(sessionId);
    return state?.currentBranch || "main";
  }
  /**
   * Save current branch
   */
  async saveCurrentBranch(sessionId, branchName) {
    await this.updateStateDocument(sessionId, { currentBranch: branchName });
  }
  /**
   * Get branches metadata
   */
  async getBranches(sessionId) {
    if (this.branchesCache) {
      return this.branchesCache;
    }
    const state = await this.getStateDocument(sessionId);
    if (!state) {
      const mainBranch = {
        name: "main",
        branchPath: "main",
        createdAt: /* @__PURE__ */ new Date(0),
        // Epoch time for main branch
        snapshotTime: /* @__PURE__ */ new Date()
      };
      const branches = { main: mainBranch };
      await this.updateStateDocument(sessionId, { branches });
      this.branchesCache = branches;
      return branches;
    }
    this.branchesCache = state.branches;
    return state.branches;
  }
  /**
   * Save branches metadata
   */
  async saveBranches(sessionId, branches) {
    await this.updateStateDocument(sessionId, { branches });
    this.branchesCache = branches;
  }
  /**
   * Update branches cache without database update
   * Used when branches are updated as part of a batch operation
   */
  updateBranchesCache(branches) {
    this.branchesCache = branches;
  }
  /**
   * Clear cache
   */
  clearCache() {
    this.stateCache.clear();
    this.branchesCache = null;
  }
};

// src/core/storage/memory/common/cursor-manager.ts
var CursorManager = class {
  constructor(collectionManager, stateManager) {
    this.collectionManager = collectionManager;
    this.stateManager = stateManager;
  }
  /**
   * Get start cursor (timestamp) for soft delete
   */
  async getStartCursor(sessionId) {
    const state = await this.stateManager.getStateDocument(sessionId);
    return state?.startCursor;
  }
  /**
   * Set start cursor (timestamp) for soft delete
   */
  async setStartCursor(sessionId, cursor) {
    await this.stateManager.updateStateDocument(sessionId, {
      startCursor: cursor
    });
  }
  /**
   * Get event document by message ID
   * Used for getting event timestamp when needed
   */
  async getEventByMessageId(sessionId, messageId) {
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const doc = await adapter.findOne(collection, { sessionId, messageId });
      return doc;
    } catch (error) {
      console.error("Error getting event by message ID:", error);
      return null;
    }
  }
};

// src/core/storage/memory/common/summary-manager.ts
var SummaryManager = class {
  constructor(sessionId, collectionManager, cursorManager) {
    this.sessionId = sessionId;
    this.collectionManager = collectionManager;
    this.cursorManager = cursorManager;
  }
  /**
   * Add a summary
   */
  async addSummary(summaryId, content, metadata, sessionId) {
    try {
      const collection = this.collectionManager.getSummaryCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = sessionId || this.sessionId;
      const summary = {
        sessionId: sid,
        summaryId,
        content,
        metadata,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      };
      await adapter.insertOne(collection, summary);
    } catch (error) {
      console.error("Error adding summary to database:", error);
      throw error;
    }
  }
  /**
   * Get all summaries for a session
   */
  async getSummaries(sessionId) {
    try {
      const collection = this.collectionManager.getSummaryCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = sessionId || this.sessionId;
      const summaries = await adapter.find(
        collection,
        { sessionId: sid },
        { sort: { createdAt: 1 } }
      );
      return summaries;
    } catch (error) {
      console.error("Error getting summaries from database:", error);
      throw error;
    }
  }
  /**
   * Clear old events by setting soft delete cursor
   */
  async clearSummarizedEvents(params) {
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = params.sessionId || this.sessionId;
      const currentCursor = await this.cursorManager.getStartCursor(sid);
      let whereCondition = { sessionId: sid };
      if (currentCursor) {
        const queryBuilder = adapter.createQueryBuilder();
        const cursorCondition = queryBuilder.where("createdAt", "gt", currentCursor).build();
        whereCondition = { ...whereCondition, ...cursorCondition };
      }
      const result = await adapter.find(
        collection,
        whereCondition,
        { sort: { createdAt: 1 } }
      );
      const totalEvents = result.length;
      const eventsToDelete = totalEvents - params.recentToKeep;
      if (eventsToDelete > 0) {
        const lastDeletedEvent = result[eventsToDelete - 1];
        await this.cursorManager.setStartCursor(
          sid,
          lastDeletedEvent.createdAt
        );
      }
    } catch (error) {
      console.error("Error clearing summarized events from database:", error);
      throw error;
    }
  }
};

// src/core/storage/memory/common/branch-manager.ts
var BranchManager = class {
  constructor(collectionManager, stateManager, cursorManager) {
    this.collectionManager = collectionManager;
    this.stateManager = stateManager;
    this.cursorManager = cursorManager;
  }
  /**
   * Get current branch path
   */
  async getCurrentBranchPath(sessionId) {
    const currentBranch = await this.stateManager.getCurrentBranch(sessionId);
    const branches = await this.stateManager.getBranches(sessionId);
    return branches[currentBranch]?.branchPath || "main";
  }
  /**
   * Build branch query conditions
   */
  async buildBranchConditions(sessionId, currentBranchPath) {
    const adapter = this.collectionManager.getAdapter();
    const branches = await this.stateManager.getBranches(sessionId);
    const conditions = [];
    const pathParts = currentBranchPath.split("/");
    for (let i = 1; i <= pathParts.length; i++) {
      const ancestorPath = pathParts.slice(0, i).join("/");
      const branch = Object.values(branches).find(
        (b) => b.branchPath === ancestorPath
      );
      if (branch) {
        const queryBuilder = adapter.createQueryBuilder().where("sessionId", "eq", sessionId).and("branchPath", "eq", ancestorPath);
        if (i < pathParts.length) {
          const childBranch = Object.values(branches).find(
            (b) => b.branchPath === pathParts.slice(0, i + 1).join("/")
          );
          if (childBranch) {
            queryBuilder.and("createdAt", "lte", childBranch.snapshotTime);
          }
        }
        conditions.push(queryBuilder.build());
      }
    }
    return conditions.length > 0 ? conditions : [
      adapter.createQueryBuilder().where("sessionId", "eq", sessionId).and("branchPath", "eq", "main").build()
    ];
  }
  /**
   * Apply cursor condition to branch conditions
   */
  applyCursorCondition(conditions, cursorTime) {
    const adapter = this.collectionManager.getAdapter();
    return conditions.map((cond) => {
      const builder = adapter.createQueryBuilder();
      if (cond && cond.__typeorm_query__) {
        const existingWhere = cond.where;
        const existingParams = cond.parameters;
        const cursorParamName = `cursor_param_${Date.now()}`;
        const combinedWhere = `(${existingWhere}) AND entity.createdAt > :${cursorParamName}`;
        const combinedParams = { ...existingParams, [cursorParamName]: cursorTime };
        return {
          __typeorm_query__: true,
          where: combinedWhere,
          parameters: combinedParams
        };
      } else {
        Object.entries(cond).forEach(([field, value]) => {
          if (field !== "_id") {
            builder.where(field, "eq", value);
          }
        });
        builder.and("createdAt", "gt", cursorTime);
        return builder.build();
      }
    });
  }
  /**
   * Create a new branch
   */
  async createBranch(sessionId, branchName, fromEventId, listEvents) {
    const branches = await this.stateManager.getBranches(sessionId);
    if (branches[branchName]) {
      throw new Error(`Branch '${branchName}' already exists`);
    }
    const currentBranchName = await this.stateManager.getCurrentBranch(sessionId);
    const currentBranchPath = await this.getCurrentBranchPath(sessionId);
    const newBranchPath = `${currentBranchPath}/${branchName}`;
    let snapshotTime;
    if (fromEventId) {
      const fromEvent = await this.cursorManager.getEventByMessageId(
        sessionId,
        fromEventId
      );
      if (!fromEvent) {
        throw new Error(`Event '${fromEventId}' not found`);
      }
      snapshotTime = fromEvent.createdAt;
    } else {
      if (listEvents) {
        const events = await listEvents();
        if (events.length > 0) {
          const lastEvent = events[events.length - 1];
          const lastDoc = await this.cursorManager.getEventByMessageId(
            sessionId,
            lastEvent.message.id
          );
          snapshotTime = lastDoc ? lastDoc.createdAt : /* @__PURE__ */ new Date();
        } else {
          snapshotTime = /* @__PURE__ */ new Date();
        }
      } else {
        snapshotTime = /* @__PURE__ */ new Date();
      }
    }
    const currentCursor = await this.cursorManager.getStartCursor(sessionId);
    branches[branchName] = {
      name: branchName,
      parentBranch: currentBranchName,
      branchPath: newBranchPath,
      createdAt: /* @__PURE__ */ new Date(),
      fromEventId,
      snapshotTime,
      startCursor: currentCursor
    };
    await this.stateManager.saveBranches(sessionId, branches);
    return branchName;
  }
  /**
   * Switch to a different branch
   */
  async checkoutBranch(sessionId, branchName) {
    const branches = await this.stateManager.getBranches(sessionId);
    const branch = branches[branchName];
    if (!branch) {
      throw new Error(`Branch '${branchName}' does not exist`);
    }
    const currentBranchName = await this.stateManager.getCurrentBranch(sessionId);
    const currentCursor = await this.cursorManager.getStartCursor(sessionId);
    if (branches[currentBranchName]) {
      branches[currentBranchName].startCursor = currentCursor;
    }
    const updates = {
      branches,
      currentBranch: branchName
    };
    if (branch.startCursor !== void 0) {
      updates.startCursor = branch.startCursor;
    } else {
      updates.startCursor = void 0;
    }
    await this.stateManager.updateStateDocument(sessionId, updates);
    this.stateManager.updateBranchesCache(branches);
  }
  /**
   * Checkout to a specific event, deleting all events after it
   */
  async checkoutToEvent(sessionId, eventId) {
    const collection = this.collectionManager.getCollection();
    const event = await this.cursorManager.getEventByMessageId(sessionId, eventId);
    const adapter = this.collectionManager.getAdapter();
    if (!event) {
      throw new Error(`Event '${eventId}' not found in session '${sessionId}'`);
    }
    const currentBranchPath = await this.getCurrentBranchPath(sessionId);
    let conditions = await this.buildBranchConditions(
      sessionId,
      currentBranchPath
    );
    conditions = this.applyCursorCondition(
      conditions,
      event.createdAt
    );
    let whereCondition;
    if (conditions.length > 1) {
      const orBuilder = adapter.createQueryBuilder();
      const conditionBuilders = conditions.map((cond) => {
        const builder = adapter.createQueryBuilder();
        Object.entries(cond).forEach(([field, value]) => {
          builder.where(field, "eq", value);
        });
        return builder;
      });
      whereCondition = orBuilder.or(conditionBuilders).build();
    } else {
      whereCondition = conditions[0];
    }
    await adapter.deleteMany(collection, whereCondition);
  }
  /**
   * Detect whether target is a branch name or event ID
   */
  async detectCheckoutType(sessionId, target) {
    const branches = await this.stateManager.getBranches(sessionId);
    return branches[target] ? "branch" : "event";
  }
  /**
   * Delete a branch
   */
  async deleteBranch(sessionId, branchName) {
    if (branchName === "main") {
      throw new Error("Cannot delete main branch");
    }
    const currentBranch = await this.stateManager.getCurrentBranch(sessionId);
    if (currentBranch === branchName) {
      throw new Error(
        "Cannot delete current branch. Switch to another branch first."
      );
    }
    const branches = await this.stateManager.getBranches(sessionId);
    if (!branches[branchName]) {
      throw new Error(`Branch '${branchName}' does not exist`);
    }
    delete branches[branchName];
    await this.stateManager.saveBranches(sessionId, branches);
  }
  /**
   * List all branches
   */
  async listBranches(sessionId) {
    const branches = await this.stateManager.getBranches(sessionId);
    const currentBranch = await this.stateManager.getCurrentBranch(sessionId);
    return Object.values(branches).map((branch) => ({
      ...branch,
      isActive: branch.name === currentBranch
    }));
  }
  /**
   * Get current branch name
   */
  async getCurrentBranch(sessionId) {
    return this.stateManager.getCurrentBranch(sessionId);
  }
  /**
   * Clean up branches, keeping only specified branches and the current active branch
   * @param sessionId - Session identifier
   * @param keepBranches - Optional list of branch names to keep (in addition to active branch)
   */
  async cleanupBranches(sessionId, keepBranches = []) {
    const branches = await this.stateManager.getBranches(sessionId);
    const currentBranch = await this.stateManager.getCurrentBranch(sessionId);
    const branchesToKeep = /* @__PURE__ */ new Set([
      "main",
      currentBranch,
      ...keepBranches
    ]);
    const branchesToDelete = Object.keys(branches).filter(
      (branchName) => !branchesToKeep.has(branchName)
    );
    for (const branchName of branchesToDelete) {
      delete branches[branchName];
    }
    await this.stateManager.saveBranches(sessionId, branches);
  }
};

// src/core/storage/memory/in-memory/in-memory-memory.ts
var InMemoryMemory = class extends BaseMemory {
  /**
   * Creates a new InMemoryMemory instance
   * @param options - Configuration options
   * @param options.sessionId - Unique session identifier (default: 'default')
   * @param options.enableContextManagement - Whether to automatically manage context (default: true if thresholds provided)
   */
  constructor(options = {}) {
    super(options);
    this.sessionId = options.sessionId || "default";
    this.enableContextManagement = options.enableContextManagement ?? (options.thresholds ? true : false);
    this.collectionManager = new CollectionManager();
    this.documentConverter = new DocumentConverter();
    this.stateManager = new StateManager(this.collectionManager);
    this.cursorManager = new CursorManager(
      this.collectionManager,
      this.stateManager
    );
    this.branchManager = new BranchManager(
      this.collectionManager,
      this.stateManager,
      this.cursorManager
    );
    this.summaryManager = new SummaryManager(
      this.sessionId,
      this.collectionManager,
      this.cursorManager
    );
  }
  // ==================== CRUD Operations ====================
  /**
   * Returns events from in-memory storage with filtering, pagination, and token limiting
   * Respects branch isolation using branch path and snapshot time
   * @param options - Optional filtering and pagination options
   * @returns Promise resolving to filtered array of memory events
   */
  async list(options) {
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      const currentBranchPath = await this.branchManager.getCurrentBranchPath(sid);
      const branchConditions = await this.branchManager.buildBranchConditions(
        sid,
        currentBranchPath
      );
      const startCursor = await this.cursorManager.getStartCursor(sid);
      let conditions = branchConditions;
      if (startCursor) {
        conditions = this.branchManager.applyCursorCondition(
          conditions,
          startCursor
        );
      }
      let whereCondition;
      if (conditions.length > 1) {
        whereCondition = (doc) => {
          return conditions.some((cond) => {
            if (typeof cond === "function") {
              return cond(doc);
            }
            return Object.entries(cond).every(([field, value]) => {
              const docValue = field.split(".").reduce((obj, key) => obj?.[key], doc);
              if (value && typeof value === "object" && !Array.isArray(value) && !(value instanceof Date)) {
                return Object.entries(value).every(([op, opValue]) => {
                  switch (op) {
                    case "$gt":
                      return docValue > opValue;
                    case "$gte":
                      return docValue >= opValue;
                    case "$lt":
                      return docValue < opValue;
                    case "$lte":
                      return docValue <= opValue;
                    case "$ne":
                    case "$neq":
                      return docValue !== opValue;
                    default:
                      return docValue === opValue;
                  }
                });
              }
              return docValue === value;
            });
          });
        };
      } else {
        const cond = conditions[0];
        if (typeof cond === "function") {
          whereCondition = cond;
        } else {
          whereCondition = (doc) => {
            return Object.entries(cond).every(([field, value]) => {
              const docValue = field.split(".").reduce((obj, key) => obj?.[key], doc);
              if (value && typeof value === "object" && !Array.isArray(value) && !(value instanceof Date)) {
                return Object.entries(value).every(([op, opValue]) => {
                  switch (op) {
                    case "$gt":
                      return docValue > opValue;
                    case "$gte":
                      return docValue >= opValue;
                    case "$lt":
                      return docValue < opValue;
                    case "$lte":
                      return docValue <= opValue;
                    case "$ne":
                    case "$neq":
                      return docValue !== opValue;
                    default:
                      return docValue === opValue;
                  }
                });
              }
              return docValue === value;
            });
          };
        }
      }
      const order = options?.order || "asc";
      const queryOptions = {
        sort: { createdAt: order === "asc" ? 1 : -1 }
      };
      if (options?.offset) {
        queryOptions.skip = options.offset;
      }
      if (options?.limit) {
        queryOptions.limit = options.limit;
      }
      const result = await adapter.find(
        collection,
        whereCondition,
        queryOptions
      );
      return (order === "desc" ? result.reverse() : result).map(
        (doc) => this.documentConverter.fromDocument(doc)
      );
    } catch (error) {
      console.error("Error listing events from in-memory storage:", error);
      throw error;
    }
  }
  /**
   * Adds a new event to in-memory storage
   * @param event - The memory event to add
   * @param options - Optional session and branch options
   */
  async add(event, options) {
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      const currentBranchPath = await this.branchManager.getCurrentBranchPath(sid);
      const document = this.documentConverter.toDocument(
        event,
        sid,
        currentBranchPath
      );
      await adapter.insertOne(collection, document);
      if (this.enableContextManagement && this.thresholds) {
        const events = await this.list({ sessionId: sid });
        await this.manageContext({ sessionId: sid, events });
      }
    } catch (error) {
      console.error("Error adding event to in-memory storage:", error);
      throw error;
    }
  }
  /**
   * Adds multiple events to in-memory storage
   * @param list - Array of memory events to add
   * @param options - Optional session and branch options
   */
  async addList(list, options) {
    try {
      for (const event of list) {
        await this.add(event, options);
      }
    } finally {
    }
  }
  /**
   * Update an existing event in memory storage
   * @param params - Update parameters including session ID and event
   */
  async update(params) {
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const updateBuilder = adapter.createUpdateBuilder();
      ["role", "content", "toolCalls", "toolCallId", "state"].forEach((key) => {
        if (params.event.message[key]) {
          updateBuilder.set(key, params.event.message[key]);
        }
      });
      if (params.event.state) {
        updateBuilder.set("state", params.event.state);
      }
      updateBuilder.set("updatedAt", /* @__PURE__ */ new Date());
      const query = adapter.createQueryBuilder().where("sessionId", "eq", params.sessionId).and("messageId", "eq", params.event.message.id).build();
      await adapter.updateOne(collection, query, updateBuilder.build());
    } catch (error) {
      console.error("Error updating event in in-memory storage:", error);
      throw error;
    }
  }
  /**
   * Deletes an event from in-memory storage by message ID or event object
   * @param params - Delete parameters including event reference or message ID
   */
  async delete(params, options) {
    if (typeof params === "string" || typeof params === "number") {
      return this.deleteByIdOrIndex(params, options);
    }
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = params.sessionId || this.sessionId;
      const query = adapter.createQueryBuilder().where("sessionId", "eq", sid).and("messageId", "eq", params.event.message.id).build();
      await adapter.deleteOne(collection, query);
    } catch (error) {
      console.error("Error deleting event from in-memory storage:", error);
      throw error;
    }
  }
  /**
   * Deletes an event by ID or index
   * @param idOrIndex - Event message ID or array index
   * @param options - Optional session options
   */
  async deleteByIdOrIndex(idOrIndex, options) {
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      if (typeof idOrIndex === "string") {
        const query = adapter.createQueryBuilder().where("sessionId", "eq", sid).and("messageId", "eq", idOrIndex).build();
        await adapter.deleteOne(collection, query);
      } else {
        const events = await this.list({ sessionId: sid });
        if (idOrIndex >= 0 && idOrIndex < events.length) {
          const eventToDelete = events[idOrIndex];
          await this.delete({ event: eventToDelete, sessionId: sid });
        }
      }
    } catch (error) {
      console.error(
        "Error deleting event by ID/index from in-memory storage:",
        error
      );
      throw error;
    }
  }
  /**
   * Clears events from in-memory storage
   * @param options - Optional session-specific clearing
   */
  async clear(options) {
    try {
      const collection = this.collectionManager.getCollection();
      const stateCollection = this.collectionManager.getStateCollection();
      const summaryCollection = this.collectionManager.getSummaryCollection();
      const adapter = this.collectionManager.getAdapter();
      if (options?.sessionId) {
        const sid = options.sessionId;
        const result = await adapter.find(
          collection,
          { sessionId: sid },
          { sort: { createdAt: -1 }, limit: 1 }
        );
        if (result.length > 0) {
          const lastEvent = result[0];
          await this.cursorManager.setStartCursor(sid, lastEvent.createdAt);
        }
        await adapter.deleteMany(summaryCollection, { sessionId: sid });
      } else {
        await adapter.deleteMany(collection, {});
        await adapter.deleteMany(stateCollection, {});
        await adapter.deleteMany(summaryCollection, {});
      }
      this.stateManager.clearCache();
    } catch (error) {
      console.error("Error clearing events from in-memory storage:", error);
      throw error;
    }
  }
  /**
   * Gets the count of events in in-memory storage
   * @param options - Optional session filtering
   * @returns Promise resolving to the count of events
   */
  async getCount(options) {
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      const currentBranchPath = await this.branchManager.getCurrentBranchPath(sid);
      const branchConditions = await this.branchManager.buildBranchConditions(
        sid,
        currentBranchPath
      );
      const startCursor = await this.cursorManager.getStartCursor(sid);
      let conditions = branchConditions;
      if (startCursor) {
        conditions = this.branchManager.applyCursorCondition(
          conditions,
          startCursor
        );
      }
      let whereCondition;
      if (conditions.length > 1) {
        whereCondition = (doc) => {
          return conditions.some((cond) => {
            if (typeof cond === "function") {
              return cond(doc);
            }
            return Object.entries(cond).every(([field, value]) => {
              const docValue = field.split(".").reduce((obj, key) => obj?.[key], doc);
              return docValue === value;
            });
          });
        };
      } else {
        const cond = conditions[0];
        if (typeof cond === "function") {
          whereCondition = cond;
        } else {
          whereCondition = (doc) => {
            return Object.entries(cond).every(([field, value]) => {
              const docValue = field.split(".").reduce((obj, key) => obj?.[key], doc);
              return docValue === value;
            });
          };
        }
      }
      const count = await adapter.count(collection, whereCondition);
      return count;
    } catch (error) {
      console.error("Error getting count from in-memory storage:", error);
      return 0;
    }
  }
  // ==================== Search Operations ====================
  /**
   * Retrieve events using content-based search
   * @param query - Search query text to match against message content
   * @param options - Optional search and session options
   * @returns Promise resolving to array of matching memory events
   */
  async retrieve(query, options) {
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      const currentBranchPath = await this.branchManager.getCurrentBranchPath(sid);
      const branchConditions = await this.branchManager.buildBranchConditions(
        sid,
        currentBranchPath
      );
      const startCursor = await this.cursorManager.getStartCursor(sid);
      let conditions = branchConditions;
      if (startCursor) {
        conditions = this.branchManager.applyCursorCondition(
          conditions,
          startCursor
        );
      }
      const searchCondition = (doc) => {
        const matchesBranch = conditions.some((cond) => {
          if (typeof cond === "function") {
            return cond(doc);
          }
          return Object.entries(cond).every(([field, value]) => {
            const docValue = field.split(".").reduce((obj, key) => obj?.[key], doc);
            return docValue === value;
          });
        });
        if (!matchesBranch) return false;
        const content = doc.content || "";
        return content.toLowerCase().includes(query.toLowerCase());
      };
      const result = await adapter.find(
        collection,
        searchCondition
      );
      return result.map(
        (doc) => this.documentConverter.fromDocument(doc)
      );
    } catch (error) {
      console.error("Error retrieving events from in-memory storage:", error);
      throw error;
    }
  }
  // ==================== Summary Operations ====================
  /**
   * Get summaries for a session
   * @param sessionId - Optional session identifier
   * @returns Array of structured summaries
   */
  async getSummaries(sessionId) {
    const summaries = await this.summaryManager.getSummaries(sessionId);
    return summaries.map((doc) => ({
      content: doc.content,
      count: 1,
      // Default count since BaseSummaryDocument doesn't have count
      timeRange: {
        start: doc.metadata?.timeRangeStart,
        end: doc.metadata?.timeRangeEnd
      },
      timestamp: doc.createdAt
    }));
  }
  /**
   * Store summary implementation
   * @param params - Summary storage parameters
   */
  async storeSummary(params) {
    const summaryId = `summary_${Date.now()}`;
    const metadata = {
      count: params.summary.count,
      timeRangeStart: params.summary.timeRange.start,
      timeRangeEnd: params.summary.timeRange.end
    };
    return this.summaryManager.addSummary(
      summaryId,
      params.summary.content,
      metadata,
      params.sessionId
    );
  }
  /**
   * Clear summarized events implementation using soft delete
   * Sets cursor to hide old events without actually deleting them
   * @param params - Clear parameters
   */
  async clearSummarizedEvents(params) {
    return this.summaryManager.clearSummarizedEvents({
      sessionId: params.sessionId,
      recentToKeep: params.recentToKeep
    });
  }
  // ==================== Branch Operations ====================
  /**
   * Create a new branch from the current state
   * @param branchName - Name of the new branch
   * @param fromEventId - Optional event ID to branch from
   * @returns Promise resolving to the branch name
   */
  async branch(branchName, fromEventId) {
    return this.branchManager.createBranch(
      this.sessionId,
      branchName,
      fromEventId,
      () => this.list({ sessionId: this.sessionId })
    );
  }
  /**
   * Switch to a different branch or checkout to a specific event
   * @param target - Branch name or event ID
   * @param options - Optional checkout options
   */
  async checkout(target, options) {
    const checkoutType = options?.type || await this.branchManager.detectCheckoutType(
      options?.sessionId || this.sessionId,
      target
    );
    const sessionId = options?.sessionId || this.sessionId;
    if (checkoutType === "event") {
      const collection = this.collectionManager.getCollection();
      const event = await this.cursorManager.getEventByMessageId(
        sessionId,
        target
      );
      const adapter = this.collectionManager.getAdapter();
      if (!event) {
        throw new Error(`Event '${target}' not found`);
      }
      const currentBranchPath = await this.branchManager.getCurrentBranchPath(sessionId);
      let conditions = await this.branchManager.buildBranchConditions(
        sessionId,
        currentBranchPath
      );
      conditions = this.branchManager.applyCursorCondition(
        conditions,
        event.createdAt
      );
      const whereCondition = (doc) => {
        return conditions.some((cond) => {
          if (typeof cond === "function") {
            return cond(doc);
          }
          return Object.entries(cond).every(([field, value]) => {
            const docValue = field.split(".").reduce((obj, key) => obj?.[key], doc);
            return docValue === value;
          });
        });
      };
      await adapter.deleteMany(collection, whereCondition);
    } else {
      await this.branchManager.checkoutBranch(sessionId, target);
    }
  }
  /**
   * Delete a branch
   * @param branchName - Name of the branch to delete
   */
  async deleteBranch(branchName) {
    return this.branchManager.deleteBranch(this.sessionId, branchName);
  }
  /**
   * List all branches for the current session
   * @returns Promise resolving to array of branch information
   */
  async listBranches() {
    const branches = await this.branchManager.listBranches(this.sessionId);
    const branchInfos = [];
    for (const branch of branches) {
      branchInfos.push({
        name: branch.name,
        isActive: branch.isActive,
        createdAt: branch.createdAt,
        fromEventId: branch.fromEventId
      });
    }
    return branchInfos;
  }
  /**
   * Get current branch name
   * @returns Promise resolving to current branch name
   */
  async getCurrentBranch() {
    return this.branchManager.getCurrentBranch(this.sessionId);
  }
  /**
   * Clean up branches, keeping only specified branches and the current active branch
   * @param keepBranches - Optional list of branch names to keep (in addition to active branch)
   */
  async cleanupBranches(keepBranches) {
    return this.branchManager.cleanupBranches(this.sessionId, keepBranches);
  }
  // ==================== Utility Methods ====================
  /**
   * Clear all collections (useful for testing)
   */
  clearAll() {
    this.collectionManager.clearAll();
    this.stateManager.clearCache();
  }
  /**
   * Check if the memory storage is empty
   * @param options - Optional session options
   * @returns Promise resolving to true if no events are stored
   */
  async isEmpty(options) {
    const count = await this.getCount(options);
    return count === 0;
  }
  /**
   * Get all session IDs currently stored in memory
   * @returns Array of session identifiers
   */
  getSessionIds() {
    const collection = this.collectionManager.getCollection();
    const sessionIds = /* @__PURE__ */ new Set();
    for (const doc of collection) {
      sessionIds.add(doc.sessionId);
    }
    return Array.from(sessionIds);
  }
  /**
   * Check if a specific session exists
   * @param sessionId - The session identifier to check
   * @returns True if the session exists
   */
  hasSession(sessionId) {
    return this.getSessionIds().includes(sessionId);
  }
  /**
   * Get raw session events (for testing purposes)
   * @param sessionId - The session identifier
   * @returns Array of raw events without decompression
   */
  getSessionEvents(sessionId) {
    const collection = this.collectionManager.getCollection();
    const rawEvents = collection.filter((doc) => doc.sessionId === sessionId).map((doc) => this.documentConverter.fromDocument(doc)).sort((a, b) => {
      const aTime = a.message.timestamp?.getTime() || 0;
      const bTime = b.message.timestamp?.getTime() || 0;
      return bTime - aTime;
    });
    return rawEvents;
  }
};

// src/core/agent.ts
var globalMemory = null;
function getGlobalMemory() {
  if (!globalMemory) {
    globalMemory = new InMemoryMemory();
  }
  return globalMemory;
}
var Agent = class {
  constructor(config) {
    this.isRunning = false;
    this.isPaused = false;
    this.config = configValidator.validateAgentConfig(config, {
      agentName: config.name
    });
    this.eventSystem = new EventSystem();
    this.toolProxy = new ToolProxy(this.eventSystem);
    this.toolExecutionHandler = new ToolExecutionHandler(
      this.toolProxy,
      this.config.controlFlow?.errorRetryLimit || 0,
      this.config.controlFlow?.customHandler
    );
    this.messageBuilder = new MessageBuilder();
    this.state = this.initializeState();
    this.memory = config.memory || getGlobalMemory();
    this.modelProvider = this.initializeModelProvider();
    this.initializeTools();
    this.initializeEventListeners();
    this.agentExecutor = new AgentExecutor(
      this.config,
      this.modelProvider,
      this.toolExecutionHandler,
      this.messageBuilder,
      () => this.state.businessState,
      (conversationId, messages, state) => this.addMessages(conversationId, messages, state),
      // State sync callback: merge updated state into businessState
      (updatedState) => {
        if (this.state.businessState && typeof this.state.businessState === "object" && typeof updatedState === "object") {
          Object.assign(this.state.businessState, updatedState);
        } else {
          this.state.businessState = updatedState;
        }
      }
    );
  }
  /**
   * Create a message with state metadata for memory storage
   */
  createMessageWithState(role, content, conversationId, state, options) {
    return this.messageBuilder.createMessageWithState(
      role,
      content,
      conversationId,
      state,
      options
    );
  }
  /**
   * Get conversation messages from memory
   */
  async getConversationMessages(conversationId) {
    const events = await this.memory.list({
      limit: 1e3,
      sessionId: conversationId
      // Use conversationId as sessionId
    });
    return events.map((event) => event.message).sort((a, b) => (a.timestamp?.getTime() || 0) - (b.timestamp?.getTime() || 0));
  }
  /**
   * Add messages to memory
   */
  async addMessages(conversationId, messages, state) {
    const events = messages.map((message) => ({
      message,
      state
    }));
    await this.memory.addList(events, { sessionId: conversationId });
  }
  /**
   * Extract current state from messages
   */
  extractStateFromMessages(messages) {
    return this.messageBuilder.extractStateFromMessages(messages);
  }
  // Core run method
  async run(input, state, options) {
    const validatedOptions = options ? configValidator.validateRunOptions(options, {
      agentName: this.config.name,
      inputType: typeof input
    }) : void 0;
    const runId = validatedOptions?.runId || (0, import_node_crypto4.randomUUID)();
    const conversationId = options?.conversationId || (0, import_node_crypto4.randomUUID)();
    const eventEmitter = {
      emit: (type, event) => {
        this.eventSystem.emit(type, event);
        if (validatedOptions?.onEvent) {
          validatedOptions.onEvent(event);
        }
      },
      next: (event) => {
        this.eventSystem.emit(event.type, event);
        if (validatedOptions?.onEvent) {
          validatedOptions.onEvent(event);
        }
      }
    };
    if (options?.signal?.aborted) {
      throw new ExecutionError(
        "Run aborted before start",
        { reason: options.signal.reason || "AbortSignal was already aborted" }
      );
    }
    const abortHandler = () => {
      this.isRunning = false;
      this.state.status = "idle";
    };
    options?.signal?.addEventListener("abort", abortHandler);
    eventEmitter.emit("RUN_STARTED" /* RUN_STARTED */, {
      type: "RUN_STARTED" /* RUN_STARTED */,
      threadId: conversationId,
      // AG-UI compatibility
      runId,
      input,
      options: options || {}
    });
    try {
      this.isRunning = true;
      this.state.status = "running";
      this.state.runId = runId;
      this.state.conversationId = conversationId;
      if (options?.signal?.aborted) {
        throw new ExecutionError(
          "Run aborted",
          { reason: options.signal.reason || "AbortSignal was aborted" }
        );
      }
      if (options?.resume) {
        try {
          const resumePayload = JSON.parse(options.resume.payload);
          if (this.state.businessState) {
            Object.assign(this.state.businessState, {
              userResponse: resumePayload
            });
          }
        } catch (error) {
          console.error("Failed to parse resume payload:", error);
        }
      }
      eventEmitter.emit("STATE_UPDATE" /* STATE_UPDATE */, {
        type: "STATE_UPDATE" /* STATE_UPDATE */,
        conversationId,
        runId,
        state: this.state
      });
      const context = await this.createRunContext(input, state, options);
      if (options?.signal?.aborted) {
        throw new ExecutionError(
          "Run aborted",
          { reason: options.signal.reason || "AbortSignal was aborted" }
        );
      }
      const result = await this.executeAgentCore(
        eventEmitter,
        context,
        validatedOptions,
        true
      );
      if (options?.signal?.aborted) {
        throw new ExecutionError(
          "Run aborted",
          { reason: options.signal.reason || "AbortSignal was aborted" }
        );
      }
      if (result && result.metadata && result.metadata.outcome !== "interrupt") {
        eventEmitter.emit("RUN_FINISHED" /* RUN_FINISHED */, {
          type: "RUN_FINISHED" /* RUN_FINISHED */,
          threadId: conversationId,
          // AG-UI compatibility
          runId,
          result,
          executionTime: Date.now() - (this.state.lastActivity?.getTime() || Date.now())
        });
      }
      this.isRunning = false;
      this.state.status = "idle";
      return result;
    } catch (error) {
      const agentError = this.createAgentError(error);
      eventEmitter.emit("RUN_ERROR" /* RUN_ERROR */, {
        type: "RUN_ERROR" /* RUN_ERROR */,
        threadId: conversationId,
        // AG-UI compatibility
        runId,
        code: agentError.code,
        message: agentError.message,
        details: agentError?.details,
        executionTime: Date.now() - (this.state.lastActivity?.getTime() || Date.now())
      });
      this.isRunning = false;
      this.state.status = "error";
      throw agentError;
    } finally {
      if (options?.signal) {
        options.signal.removeEventListener("abort", abortHandler);
      }
    }
  }
  // Streaming run method - Returns AsyncIterator (no RxJS dependency)
  async *stream(input, state, options) {
    const runId = options?.runId || (0, import_node_crypto4.randomUUID)();
    const conversationId = options?.conversationId || (0, import_node_crypto4.randomUUID)();
    const eventQueue = [];
    let isDone = false;
    let error = null;
    const eventCollector = (event) => {
      eventQueue.push(event);
    };
    const executePromise = (async () => {
      try {
        eventCollector({
          type: "RUN_STARTED" /* RUN_STARTED */,
          threadId: conversationId,
          runId
        });
        const context = await this.createRunContext(input, state, options);
        const streamEmitter = {
          emit: (type, event) => eventCollector(event),
          next: (event) => eventCollector(event)
        };
        await this.executeAgentCore(streamEmitter, context, options, false);
        isDone = true;
      } catch (err) {
        error = err instanceof Error ? err : new Error(String(err));
        isDone = true;
        eventCollector({
          type: "RUN_ERROR" /* RUN_ERROR */,
          threadId: conversationId,
          runId,
          message: error.message,
          code: error.name,
          executionTime: 0
        });
      }
    })();
    while (!isDone || eventQueue.length > 0) {
      if (eventQueue.length > 0) {
        yield eventQueue.shift();
      } else {
        await new Promise((resolve) => setTimeout(resolve, 10));
      }
    }
    if (error) {
      throw error;
    }
    await executePromise;
  }
  // Tool management
  addTool(tool2) {
    this.toolProxy.registerTool(tool2);
  }
  removeTool(toolName) {
    return this.toolProxy.unregisterTool(toolName);
  }
  getTool(toolName) {
    return this.toolProxy.getTool(toolName);
  }
  getTools() {
    return this.toolProxy.getAllTools();
  }
  getToolCount() {
    return this.toolProxy.getToolCount();
  }
  // Enhanced tool management methods
  hasTool(toolName) {
    return this.toolProxy.hasTool(toolName);
  }
  getToolNames() {
    return this.toolProxy.getToolNames();
  }
  getToolsRequiringApproval() {
    return this.toolProxy.getToolsRequiringApproval();
  }
  async executeTool(toolName, input, context) {
    return this.toolProxy.executeTool(
      toolName,
      input,
      context,
      this.state.businessState
    );
  }
  validateToolInput(toolName, input) {
    return this.toolProxy.validateToolInput(toolName, input);
  }
  getToolMetadata(toolName) {
    return this.toolProxy.getToolMetadata(toolName);
  }
  // Conversation management (placeholder - will be implemented in Phase 3)
  async createConversation(userId, config) {
    throw new Error("Conversation management not yet implemented");
  }
  async getConversation(conversationId) {
    throw new Error("Conversation management not yet implemented");
  }
  async deleteConversation(conversationId) {
    throw new Error("Conversation management not yet implemented");
  }
  // State management
  getState() {
    return { ...this.state };
  }
  setState(state) {
    this.state = { ...this.state, ...state };
    this.state.lastActivity = /* @__PURE__ */ new Date();
    this.eventSystem.emit("STATE_UPDATE" /* STATE_UPDATE */, {
      type: "STATE_UPDATE" /* STATE_UPDATE */,
      state: this.state,
      conversationId: this.state.conversationId || "",
      runId: this.state.runId || ""
    });
  }
  // Lifecycle control
  async start() {
    if (this.isRunning) {
      throw new Error("Agent is already running");
    }
    this.isRunning = true;
    this.state.status = "running";
  }
  async pause() {
    if (!this.isRunning) {
      throw new Error("Agent is not running");
    }
    this.isPaused = true;
    this.state.status = "paused";
    this.eventSystem.emit("EXECUTION_PAUSED" /* EXECUTION_PAUSED */, {
      type: "EXECUTION_PAUSED" /* EXECUTION_PAUSED */,
      reason: "Manual pause",
      conversationId: this.state.conversationId || "",
      runId: this.state.runId || ""
    });
  }
  async resume(resumeData) {
    if (!this.isPaused) {
      throw new Error("Agent is not paused");
    }
    this.isPaused = false;
    this.state.status = "running";
    this.eventSystem.emit("EXECUTION_RESUMED" /* EXECUTION_RESUMED */, {
      type: "EXECUTION_RESUMED" /* EXECUTION_RESUMED */,
      resumeData,
      conversationId: this.state.conversationId || "",
      runId: this.state.runId || ""
    });
  }
  async stop() {
    this.isRunning = false;
    this.isPaused = false;
    this.state.status = "idle";
  }
  // Event system
  on(event, handler) {
    this.eventSystem.on(event, handler);
  }
  off(event, handler) {
    this.eventSystem.off(event, handler);
  }
  // Private methods
  initializeState() {
    return {
      businessState: this.config.stateType ? new this.config.stateType() : {},
      context: {},
      status: "idle",
      lastActivity: /* @__PURE__ */ new Date()
    };
  }
  initializeModelProvider() {
    if (typeof this.config.model === "string") {
      throw new Error("String-based model provider not yet implemented");
    }
    return this.config.model;
  }
  initializeTools() {
    if (this.config.tools) {
      for (const tool2 of this.config.tools) {
        this.toolProxy.registerTool(tool2);
      }
    }
  }
  initializeEventListeners() {
    this.eventSystem.on("RUN_ERROR" /* RUN_ERROR */, (event) => {
      console.error("Agent error:", event.message);
    });
  }
  async createRunContext(input, state, options) {
    const runId = options?.runId || (0, import_node_crypto4.randomUUID)();
    const conversationId = options?.conversationId || (0, import_node_crypto4.randomUUID)();
    let messages = await this.getConversationMessages(conversationId);
    const currentMessages = typeof input === "string" ? [
      this.createMessageWithState(
        "user",
        input,
        conversationId,
        this.state.businessState,
        { runId, userId: options?.userId }
      )
    ] : input;
    await this.addMessages(conversationId, currentMessages, this.state.businessState);
    messages = await this.getConversationMessages(conversationId);
    if (options?.resume) {
      try {
        const resumePayload = JSON.parse(options.resume.payload);
        const resumeMessage = this.createMessageWithState(
          "user",
          `Resume: ${JSON.stringify(resumePayload)}`,
          conversationId,
          this.state.businessState,
          { runId, userId: options?.userId }
        );
        await this.addMessages(conversationId, [resumeMessage], this.state.businessState);
        messages = await this.getConversationMessages(conversationId);
      } catch (error) {
        console.error("Failed to parse resume payload:", error);
      }
    }
    const currentState = this.extractStateFromMessages(messages);
    if (currentState && typeof currentState === "object") {
      if (this.state.businessState) {
        Object.assign(this.state.businessState, currentState);
      } else {
        this.state.businessState = currentState;
      }
    }
    return {
      conversationId,
      runId,
      userId: options?.userId,
      requestId: (0, import_node_crypto4.randomUUID)(),
      messages,
      state: currentState,
      metadata: options?.metadata
    };
  }
  // Helper method to emit events to either eventSystem or Observable subscriber
  emitEvent(eventEmitter, event) {
    if (eventEmitter.next) {
      eventEmitter.next(event);
    } else {
      eventEmitter.emit(event.type, event);
    }
  }
  // Unified streaming execution method - delegates to AgentExecutor
  async executeAgentCore(eventEmitter, context, options, returnResult = true) {
    try {
      return await this.agentExecutor.execute(
        eventEmitter,
        context,
        options,
        returnResult
      );
    } catch (error) {
      throw this.createAgentError(error);
    }
  }
  createAgentError(error) {
    return new ExecutionError(
      error instanceof Error ? error.message : String(error),
      { originalError: error },
      error instanceof Error ? error : void 0
    );
  }
  // Getters for configuration and state
  get name() {
    return this.config.name;
  }
  get description() {
    return this.config.description;
  }
  get isActive() {
    return this.isRunning;
  }
  get isPausedState() {
    return this.isPaused;
  }
  // Memory management methods removed - handled by memory module automatically
  // AG-UI integration
  toAGUIAgent() {
    const { toAGUIAgent: toAGUIAgent2 } = (init_converter(), __toCommonJS(converter_exports));
    return toAGUIAgent2(this);
  }
  // Cleanup on destruction
  destroy() {
    this.eventSystem.removeAllListeners();
  }
};

// src/core/type-validation.ts
var import_v43 = require("zod/v4");
function isStateConstraint(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function isOutputConstraint(value) {
  return typeof value === "string" || typeof value === "object" && value !== null || Array.isArray(value);
}
var StateConstraintSchema = import_v43.z.record(import_v43.z.string(), import_v43.z.unknown());
var OutputConstraintSchema = import_v43.z.union([
  import_v43.z.string(),
  import_v43.z.record(import_v43.z.string(), import_v43.z.unknown()),
  import_v43.z.array(import_v43.z.unknown())
]);
function validateState(value, schema) {
  if (!isStateConstraint(value)) {
    throw new Error("Value is not a valid state constraint");
  }
  if (schema) {
    return schema.parse(value);
  }
  return value;
}
function validateOutput(value, schema) {
  if (!isOutputConstraint(value)) {
    throw new Error("Value is not a valid output constraint");
  }
  if (schema) {
    return schema.parse(value);
  }
  return value;
}
var TypeChecker = class _TypeChecker {
  static getInstance() {
    if (!_TypeChecker.instance) {
      _TypeChecker.instance = new _TypeChecker();
    }
    return _TypeChecker.instance;
  }
  // Check if a value matches a specific type at runtime
  checkType(value, typeName) {
    switch (typeName) {
      case "string":
        return typeof value === "string";
      case "number":
        return typeof value === "number";
      case "boolean":
        return typeof value === "boolean";
      case "object":
        return typeof value === "object" && value !== null;
      case "array":
        return Array.isArray(value);
      case "function":
        return typeof value === "function";
      default:
        return false;
    }
  }
  // Validate object structure
  validateObjectStructure(obj, requiredKeys, optionalKeys = []) {
    if (!isStateConstraint(obj)) {
      return false;
    }
    const keys = Object.keys(obj);
    for (const key of requiredKeys) {
      if (!keys.includes(key)) {
        return false;
      }
    }
    for (const key of keys) {
      if (!requiredKeys.includes(key) && !optionalKeys.includes(key)) {
        return false;
      }
    }
    return true;
  }
  // Deep type validation
  validateDeepType(value, expectedType) {
    try {
      switch (expectedType) {
        case "StateConstraint":
          return isStateConstraint(value);
        case "OutputConstraint":
          return isOutputConstraint(value);
        default:
          return this.checkType(value, expectedType);
      }
    } catch {
      return false;
    }
  }
};
function createTypeSafeState(initialState) {
  if (!isStateConstraint(initialState)) {
    throw new Error("Initial state must be a valid state constraint");
  }
  return initialState;
}
function createTypeSafeOutput(output) {
  if (!isOutputConstraint(output)) {
    throw new Error("Output must be a valid output constraint");
  }
  return output;
}
function validateTypes(stateSchema, outputSchema) {
  return function(target, propertyKey, descriptor) {
    const originalMethod = descriptor.value;
    descriptor.value = function(...args) {
      if (stateSchema && args.length > 0) {
        const stateArg = args[0];
        if (stateArg !== void 0 && stateArg !== null) {
          validateState(stateArg, stateSchema);
        }
      }
      const result = originalMethod.apply(this, args);
      if (outputSchema && result instanceof Promise) {
        return result.then((output) => {
          if (output !== void 0 && output !== null) {
            return validateOutput(output, outputSchema);
          }
          return output;
        });
      } else if (outputSchema && result !== void 0 && result !== null) {
        return validateOutput(result, outputSchema);
      }
      return result;
    };
    return descriptor;
  };
}
var typeChecker = TypeChecker.getInstance();

// src/core/index.ts
init_events();

// src/core/optimized-events.ts
var import_events7 = require("events");
var OptimizedEventSystem = class extends import_events7.EventEmitter {
  constructor(options = {}) {
    super();
    this.eventQueue = [];
    this.processingHandlers = /* @__PURE__ */ new Set();
    this.isProcessing = false;
    this.setMaxListeners(1e3);
    this.options = {
      batchSize: 10,
      batchTimeout: 16,
      // ~60fps
      maxConcurrentHandlers: 5,
      enableBatching: true,
      enableAsyncProcessing: true,
      ...options
    };
  }
  // High-performance event emission with batching
  emit(event, data) {
    const timestamp = Date.now();
    const priority = this.getEventPriority(event);
    const batchedEvent = {
      type: event,
      data: { ...data, timestamp },
      timestamp,
      priority
    };
    if (this.options.enableBatching) {
      this.addToBatch(batchedEvent);
      return true;
    } else {
      return this.processEventImmediately(batchedEvent);
    }
  }
  addToBatch(event) {
    const insertIndex = this.eventQueue.findIndex((e) => e.priority < event.priority);
    if (insertIndex === -1) {
      this.eventQueue.push(event);
    } else {
      this.eventQueue.splice(insertIndex, 0, event);
    }
    if (this.eventQueue.length >= this.options.batchSize) {
      this.processBatch();
    } else if (!this.batchTimer) {
      this.batchTimer = setTimeout(() => {
        this.processBatch();
      }, this.options.batchTimeout);
    }
  }
  async processBatch() {
    if (this.batchTimer) {
      clearTimeout(this.batchTimer);
      this.batchTimer = void 0;
    }
    if (this.eventQueue.length === 0) return;
    const batch = this.eventQueue.splice(0, this.options.batchSize);
    if (this.options.enableAsyncProcessing) {
      this.processBatchAsync(batch);
    } else {
      this.processBatchSync(batch);
    }
  }
  async processBatchAsync(batch) {
    if (this.processingHandlers.size >= this.options.maxConcurrentHandlers) {
      this.eventQueue.unshift(...batch);
      return;
    }
    const processingPromise = this.processBatchSync(batch);
    this.processingHandlers.add(processingPromise);
    try {
      await processingPromise;
    } finally {
      this.processingHandlers.delete(processingPromise);
    }
  }
  async processBatchSync(batch) {
    const eventsByType = /* @__PURE__ */ new Map();
    for (const event of batch) {
      if (!eventsByType.has(event.type)) {
        eventsByType.set(event.type, []);
      }
      eventsByType.get(event.type).push(event);
    }
    const promises = [];
    for (const [eventType, events] of eventsByType) {
      const handlers = this.listeners(eventType);
      for (const handler of handlers) {
        for (const event of events) {
          try {
            const result = handler(event.data);
            if (result instanceof Promise) {
              promises.push(result);
            }
          } catch (error) {
            console.error(`Error in event handler for ${eventType}:`, error);
          }
        }
      }
    }
    if (promises.length > 0) {
      await Promise.allSettled(promises);
    }
  }
  processEventImmediately(event) {
    try {
      return super.emit(event.type, event.data);
    } catch (error) {
      console.error(`Error emitting event ${event.type}:`, error);
      return false;
    }
  }
  getEventPriority(eventType) {
    const priorities = {
      ["error" /* ERROR */]: 100,
      ["run_failed" /* RUN_FAILED */]: 90,
      ["approval_required" /* APPROVAL_REQUIRED */]: 80,
      ["execution_paused" /* EXECUTION_PAUSED */]: 70,
      ["execution_resumed" /* EXECUTION_RESUMED */]: 70,
      ["run_started" /* RUN_STARTED */]: 60,
      ["run_finished" /* RUN_FINISHED */]: 60,
      ["tool_call_start" /* TOOL_CALL_START */]: 50,
      ["tool_call_end" /* TOOL_CALL_END */]: 50,
      ["tool_call_result" /* TOOL_CALL_RESULT */]: 50,
      ["state_update" /* STATE_UPDATE */]: 40,
      ["text_message_start" /* TEXT_MESSAGE_START */]: 30,
      ["text_message_end" /* TEXT_MESSAGE_END */]: 30,
      ["text_message_content" /* TEXT_MESSAGE_CONTENT */]: 20,
      ["messages_snapshot" /* MESSAGES_SNAPSHOT */]: 10,
      ["conversation_created" /* CONVERSATION_CREATED */]: 10,
      ["conversation_updated" /* CONVERSATION_UPDATED */]: 10,
      ["conversation_deleted" /* CONVERSATION_DELETED */]: 10,
      ["control_flow_decision" /* CONTROL_FLOW_DECISION */]: 10,
      ["tool_call_args" /* TOOL_CALL_ARGS */]: 10,
      ["approval_received" /* APPROVAL_RECEIVED */]: 10
    };
    return priorities[eventType] || 0;
  }
  // Type-safe event listening
  on(event, handler) {
    return super.on(event, handler);
  }
  // Type-safe event listening (once)
  once(event, handler) {
    return super.once(event, handler);
  }
  // Performance monitoring
  getPerformanceMetrics() {
    return {
      queueSize: this.eventQueue.length,
      processingHandlers: this.processingHandlers.size,
      isProcessing: this.isProcessing
    };
  }
  // Flush all pending events
  async flush() {
    if (this.batchTimer) {
      clearTimeout(this.batchTimer);
      this.batchTimer = void 0;
    }
    while (this.eventQueue.length > 0) {
      await this.processBatch();
    }
    await Promise.allSettled(Array.from(this.processingHandlers));
  }
  // Cleanup
  destroy() {
    if (this.batchTimer) {
      clearTimeout(this.batchTimer);
    }
    this.eventQueue = [];
    this.processingHandlers.clear();
    this.removeAllListeners();
  }
};
function createOptimizedEventSystem(options) {
  return new OptimizedEventSystem(options);
}
var optimizedEventSystem = new OptimizedEventSystem();

// src/core/providers/model-provider.ts
var BaseModelProvider = class {
  constructor(config) {
    this.config = config;
    this.defaultModel = config.defaultModel || this.getDefaultModel();
  }
  // Common implementations
  supportsTools() {
    return true;
  }
  supportsStreaming() {
    return true;
  }
  validateConfig(config) {
    return !!(config.apiKey && config.apiKey.trim().length > 0);
  }
  // Utility methods
  createError(message, type, details) {
    const error = new Error(message);
    error.type = type;
    if (details) {
      if (details.message && details.name && details.stack) {
        error.details = details;
      } else {
        error.details = {
          message: details.message || "Unknown error",
          name: details.name || "Error",
          stack: details.stack || "No stack trace available"
        };
      }
    }
    return error;
  }
  async withRetry(operation, maxRetries = this.config.maxRetries || 3, delay = this.config.retryDelay || 1e3) {
    let lastError;
    for (let attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        return await operation();
      } catch (error) {
        lastError = error;
        if (error instanceof Error && this.isNonRetryableError(error)) {
          const cleanError2 = new Error(error.message);
          cleanError2.name = error.name;
          cleanError2.stack = error.stack;
          throw cleanError2;
        }
        if (attempt === maxRetries) {
          break;
        }
        await new Promise((resolve) => setTimeout(resolve, delay * Math.pow(2, attempt)));
      }
    }
    const cleanError = new Error(lastError.message);
    cleanError.name = lastError.name;
    cleanError.stack = lastError.stack;
    throw cleanError;
  }
  isNonRetryableError(error) {
    const nonRetryableTypes = ["authentication", "invalid_request"];
    return nonRetryableTypes.includes(error.type);
  }
  formatMessages(messages) {
    return messages.map((msg) => {
      const formatted = {
        role: msg.role,
        content: msg.content
      };
      if (msg.toolCalls && msg.toolCalls.length > 0) {
        formatted.tool_calls = msg.toolCalls;
      }
      if (msg.role === "tool" && msg.toolCallId) {
        formatted.tool_call_id = msg.toolCallId;
      }
      return formatted;
    });
  }
  parseMessages(response) {
    const messages = [];
    if (response.choices && response.choices.length > 0) {
      const choice = response.choices[0];
      if (choice.message) {
        messages.push({
          id: response.id || `msg_${Date.now()}`,
          role: choice.message.role,
          content: choice.message.content || "",
          toolCalls: choice.message.tool_calls,
          timestamp: /* @__PURE__ */ new Date()
        });
      }
    }
    return messages;
  }
};
var ModelProviderRegistry = class {
  constructor() {
    this.providers = /* @__PURE__ */ new Map();
  }
  // Register a provider
  register(name, provider) {
    this.providers.set(name, provider);
    return this;
  }
  // Unregister a provider
  unregister(name) {
    return this.providers.delete(name);
  }
  // Get a provider by name
  get(name) {
    return this.providers.get(name);
  }
  // Get all registered providers
  getAll() {
    return new Map(this.providers);
  }
  // Set default provider
  setDefault(name) {
    if (!this.providers.has(name)) {
      throw new Error(`Provider '${name}' is not registered`);
    }
    this.defaultProvider = name;
    return this;
  }
  // Get default provider
  getDefault() {
    if (this.defaultProvider) {
      return this.providers.get(this.defaultProvider);
    }
    return void 0;
  }
  // List all provider names
  listNames() {
    return Array.from(this.providers.keys());
  }
  // Check if a provider is registered
  has(name) {
    return this.providers.has(name);
  }
  // Clear all providers
  clear() {
    this.providers.clear();
    this.defaultProvider = void 0;
  }
};
var modelProviderRegistry = new ModelProviderRegistry();

// src/core/providers/openai-provider.ts
var import_openai = __toESM(require("openai"));
var OpenAIProvider = class extends BaseModelProvider {
  constructor(config) {
    super(config);
    this.config = config;
    if (!this.validateConfig(config)) {
      throw this.createError("Invalid OpenAI configuration", "invalid_request", config);
    }
    this.client = new import_openai.default({
      apiKey: config.apiKey,
      baseURL: config.baseURL,
      organization: config.organization,
      project: config.project,
      timeout: config.timeout || 3e4,
      fetchOptions: config.fetchOptions
    });
  }
  get chat() {
    return {
      completions: {
        create: this.createCompletion.bind(this),
        stream: this.createStream.bind(this)
      }
    };
  }
  getProviderName() {
    return "openai";
  }
  getDefaultModel() {
    return this.config.defaultModel || "gpt-4";
  }
  validateConfig(config) {
    return super.validateConfig(config) && typeof config.apiKey === "string" && config.apiKey.length > 0;
  }
  formatTools(tools) {
    return tools;
  }
  parseToolCalls(response) {
    const toolCalls = [];
    if (response.choices && response.choices.length > 0) {
      const choice = response.choices[0];
      if (choice.message.tool_calls) {
        for (const toolCall of choice.message.tool_calls) {
          toolCalls.push({
            id: toolCall.id,
            function: {
              name: toolCall.function.name,
              arguments: toolCall.function.arguments
            }
          });
        }
      }
    }
    return toolCalls;
  }
  // Enhanced chat completion with error handling and retries
  async createCompletion(params) {
    try {
      const openaiParams = this.convertToOpenAIParams(params);
      const requestOptions = {};
      if (params.signal) {
        requestOptions.signal = params.signal;
      }
      const response = await this.withRetry(async () => {
        return await this.client.chat.completions.create(openaiParams, requestOptions);
      });
      return this.convertFromOpenAIResponse(response);
    } catch (error) {
      const cleanError = new Error(error.message);
      cleanError.name = error.name;
      cleanError.stack = error.stack;
      throw this.handleOpenAIError(cleanError);
    }
  }
  // Enhanced streaming with error handling
  async *createStream(params) {
    try {
      const openaiParams = this.convertToOpenAIParams(params);
      const requestOptions = {};
      if (params.signal) {
        requestOptions.signal = params.signal;
      }
      const stream = await this.client.chat.completions.create({
        ...openaiParams,
        stream: true
      }, requestOptions);
      if (Symbol.asyncIterator in stream) {
        for await (const chunk of stream) {
          yield this.convertFromOpenAIChunk(chunk);
        }
      } else {
        throw new Error("Streaming not supported by this OpenAI client version");
      }
    } catch (error) {
      throw this.handleOpenAIError(error);
    }
  }
  // Convert our params to OpenAI format
  convertToOpenAIParams(params) {
    const openaiParams = {
      model: params.model,
      messages: params.messages,
      // Use messages directly without formatting
      temperature: params.temperature,
      max_tokens: params.max_tokens,
      top_p: params.top_p,
      frequency_penalty: params.frequency_penalty,
      presence_penalty: params.presence_penalty,
      stop: params.stop
    };
    if (params.tools && params.tools.length > 0) {
      openaiParams.tools = this.formatTools(params.tools);
      openaiParams.tool_choice = params.tool_choice || "auto";
    }
    return openaiParams;
  }
  // Convert OpenAI response to our format
  convertFromOpenAIResponse(response) {
    return {
      id: response.id,
      object: response.object,
      created: response.created,
      model: response.model,
      choices: response.choices.map((choice) => ({
        index: choice.index,
        message: {
          role: choice.message.role,
          content: choice.message.content,
          tool_calls: choice.message.tool_calls
        },
        finish_reason: choice.finish_reason
      })),
      usage: response.usage
    };
  }
  // Convert OpenAI chunk to our format
  convertFromOpenAIChunk(chunk) {
    return {
      id: chunk.id,
      object: chunk.object,
      created: chunk.created,
      model: chunk.model,
      choices: chunk.choices.map((choice) => ({
        index: choice.index,
        delta: choice.delta,
        finish_reason: choice.finish_reason
      }))
    };
  }
  // Handle OpenAI-specific errors
  handleOpenAIError(error) {
    if (error instanceof Error) {
      if (error.name === "AbortError" || error.message.includes("abort")) {
        return this.createError("Request aborted", "aborted", error);
      }
      if (error.message.includes("401") || error.message.includes("Unauthorized")) {
        return this.createError("Invalid API key", "authentication", error);
      }
      if (error.message.includes("429") || error.message.includes("rate limit")) {
        return this.createError("Rate limit exceeded", "rate_limit", error);
      }
      if (error.message.includes("quota") || error.message.includes("billing")) {
        return this.createError("Quota exceeded", "quota_exceeded", error);
      }
      if (error.message.includes("400") || error.message.includes("Bad Request")) {
        return this.createError("Invalid request", "invalid_request", error);
      }
      if (error.message.includes("500") || error.message.includes("Internal Server Error")) {
        return this.createError("Server error", "server_error", error);
      }
      if (error.message.includes("timeout")) {
        return this.createError("Request timeout", "timeout", error);
      }
    }
    return this.createError(
      error.message || "Unknown OpenAI error",
      "unknown",
      {
        message: error.message,
        name: error.name,
        stack: error.stack
      }
    );
  }
  // Get available models (if supported by the API)
  async getAvailableModels() {
    try {
      const response = await this.client.models.list();
      return response.data.filter((model) => model.id.includes("gpt")).map((model) => model.id);
    } catch (error) {
      console.warn("Failed to fetch available models:", error);
      return ["gpt-4", "gpt-4-turbo", "gpt-3.5-turbo"];
    }
  }
  // Check if a model is available
  async isModelAvailable(model) {
    try {
      const models = await this.getAvailableModels();
      return models.includes(model);
    } catch (error) {
      console.warn("Failed to check model availability:", error);
      return true;
    }
  }
  // Get model information
  async getModelInfo(model) {
    try {
      const response = await this.client.models.retrieve(model);
      return {
        id: response.id,
        object: response.object,
        created: response.created,
        owned_by: response.owned_by,
        permission: response.permission,
        root: response.root,
        parent: response.parent
      };
    } catch (error) {
      throw this.handleOpenAIError(error);
    }
  }
  // Estimate token usage for a request
  async estimateTokens(params) {
    const text = params.messages.map((msg) => msg.content).join(" ");
    return Math.ceil(text.length / 4);
  }
  // Get usage statistics
  async getUsage(startDate, endDate) {
    try {
      const params = {};
      if (startDate) params.start_date = startDate.toISOString().split("T")[0];
      if (endDate) params.end_date = endDate.toISOString().split("T")[0];
      throw new Error("Usage statistics not available in current OpenAI SDK");
    } catch (error) {
      throw this.handleOpenAIError(error);
    }
  }
};
function createOpenAIProvider(config) {
  return new OpenAIProvider(config);
}
function createDefaultOpenAIProvider(apiKey, options) {
  return new OpenAIProvider({
    apiKey,
    defaultModel: "gpt-4",
    timeout: 3e4,
    maxRetries: 3,
    retryDelay: 1e3,
    ...options
  });
}

// src/core/providers/anthropic-provider.ts
var import_sdk = __toESM(require("@anthropic-ai/sdk"));
var AnthropicProvider = class extends BaseModelProvider {
  constructor(config) {
    super(config);
    this.config = config;
    if (!this.validateConfig(config)) {
      throw this.createError("Invalid Anthropic configuration", "invalid_request", config);
    }
    this.client = new import_sdk.default({
      apiKey: config.apiKey,
      baseURL: config.baseURL,
      timeout: config.timeout || 3e4
    });
  }
  get chat() {
    return {
      completions: {
        create: this.createCompletion.bind(this),
        stream: this.createStream.bind(this)
      }
    };
  }
  getProviderName() {
    return "anthropic";
  }
  getDefaultModel() {
    return this.config.defaultModel || "claude-3-sonnet-20240229";
  }
  validateConfig(config) {
    return super.validateConfig(config) && typeof config.apiKey === "string" && config.apiKey.length > 0;
  }
  formatTools(tools) {
    return tools.map((tool2) => ({
      type: "function",
      function: {
        name: tool2.name,
        description: tool2.description,
        parameters: tool2.schema || {}
      }
    }));
  }
  parseToolCalls(response) {
    const toolCalls = [];
    if (response.choices && response.choices.length > 0) {
      const choice = response.choices[0];
      if (choice.message.tool_calls) {
        for (const toolCall of choice.message.tool_calls) {
          toolCalls.push({
            id: toolCall.id,
            function: {
              name: toolCall.function.name,
              arguments: toolCall.function.arguments
            }
          });
        }
      }
    }
    return toolCalls;
  }
  // Create completion using Anthropic API
  async createCompletion(params) {
    try {
      const anthropicParams = this.convertToAnthropicParams(params);
      const requestOptions = {};
      if (params.signal) {
        requestOptions.signal = params.signal;
      }
      const response = await this.withRetry(async () => {
        return await this.client.messages.create(anthropicParams, requestOptions);
      });
      return this.convertFromAnthropicResponse(response, params.model);
    } catch (error) {
      const cleanError = new Error(error.message);
      cleanError.name = error.name;
      cleanError.stack = error.stack;
      throw this.handleAnthropicError(cleanError);
    }
  }
  // Create streaming completion
  async *createStream(params) {
    try {
      const anthropicParams = this.convertToAnthropicParams(params);
      anthropicParams.stream = true;
      const requestOptions = {};
      if (params.signal) {
        requestOptions.signal = params.signal;
      }
      const stream = await this.client.messages.create(anthropicParams, requestOptions);
      if (Symbol.asyncIterator in stream) {
        for await (const chunk of stream) {
          yield this.convertFromAnthropicChunk(chunk, params.model);
        }
      } else {
        throw new Error("Streaming not supported by this Anthropic client version");
      }
    } catch (error) {
      throw this.handleAnthropicError(error);
    }
  }
  // Convert our params to Anthropic format
  convertToAnthropicParams(params) {
    const anthropicParams = {
      model: params.model,
      max_tokens: params.max_tokens || 1024,
      temperature: params.temperature,
      top_p: params.top_p,
      stop_sequences: params.stop
    };
    const systemMessages = [];
    const messages = [];
    for (const message of params.messages) {
      if (message.role === "system") {
        systemMessages.push(message.content);
      } else {
        messages.push({
          role: message.role === "assistant" ? "assistant" : "user",
          content: message.content
        });
      }
    }
    if (systemMessages.length > 0) {
      anthropicParams.system = systemMessages.join("\n");
    }
    anthropicParams.messages = messages;
    if (params.tools && params.tools.length > 0) {
      anthropicParams.tools = this.formatTools(params.tools);
    }
    return anthropicParams;
  }
  // Convert Anthropic response to our format
  convertFromAnthropicResponse(response, model) {
    const choice = {
      index: 0,
      message: {
        role: "assistant",
        content: response.content[0]?.text || "",
        tool_calls: response.content.filter((item) => item.type === "tool_use").map((item) => ({
          id: item.id,
          function: {
            name: item.name,
            arguments: JSON.stringify(item.input)
          }
        }))
      },
      finish_reason: this.mapFinishReason(response.stop_reason)
    };
    return {
      id: response.id,
      object: "chat.completion",
      created: Date.now(),
      model,
      choices: [choice],
      usage: {
        prompt_tokens: response.usage?.input_tokens || 0,
        completion_tokens: response.usage?.output_tokens || 0,
        total_tokens: (response.usage?.input_tokens || 0) + (response.usage?.output_tokens || 0)
      }
    };
  }
  // Convert Anthropic chunk to our format
  convertFromAnthropicChunk(chunk, model) {
    const choice = {
      index: 0,
      delta: {
        content: chunk.delta?.text || "",
        role: "assistant"
      },
      finish_reason: chunk.type === "message_stop" ? "stop" : void 0
    };
    return {
      id: chunk.id || `chunk_${Date.now()}`,
      object: "chat.completion.chunk",
      created: Date.now(),
      model,
      choices: [choice]
    };
  }
  // Map Anthropic stop reasons to OpenAI format
  mapFinishReason(stopReason) {
    switch (stopReason) {
      case "end_turn":
        return "stop";
      case "max_tokens":
        return "length";
      case "stop_sequence":
        return "stop";
      default:
        return "stop";
    }
  }
  // Handle Anthropic-specific errors
  handleAnthropicError(error) {
    if (error instanceof Error) {
      if (error.name === "AbortError" || error.message.includes("abort")) {
        return this.createError("Request aborted", "aborted", error);
      }
      if (error.message.includes("401") || error.message.includes("Unauthorized")) {
        return this.createError("Invalid API key", "authentication", error);
      }
      if (error.message.includes("429") || error.message.includes("rate limit")) {
        return this.createError("Rate limit exceeded", "rate_limit", error);
      }
      if (error.message.includes("quota") || error.message.includes("billing")) {
        return this.createError("Quota exceeded", "quota_exceeded", error);
      }
      if (error.message.includes("400") || error.message.includes("Bad Request")) {
        return this.createError("Invalid request", "invalid_request", error);
      }
      if (error.message.includes("500") || error.message.includes("Internal Server Error")) {
        return this.createError("Server error", "server_error", error);
      }
      if (error.message.includes("timeout")) {
        return this.createError("Request timeout", "timeout", error);
      }
    }
    return this.createError(
      error.message || "Unknown Anthropic error",
      "unknown",
      {
        message: error.message,
        name: error.name,
        stack: error.stack
      }
    );
  }
  // Get available models
  async getAvailableModels() {
    return [
      "claude-3-opus-20240229",
      "claude-3-sonnet-20240229",
      "claude-3-haiku-20240307",
      "claude-2.1",
      "claude-2.0",
      "claude-instant-1.2"
    ];
  }
  // Check if a model is available
  async isModelAvailable(model) {
    const models = await this.getAvailableModels();
    return models.includes(model);
  }
  // Get model information
  async getModelInfo(model) {
    return {
      id: model,
      object: "model",
      created: Date.now(),
      owned_by: "anthropic"
    };
  }
  // Estimate token usage for a request
  async estimateTokens(params) {
    const text = params.messages.map((msg) => msg.content).join(" ");
    return Math.ceil(text.length / 4);
  }
  // Get usage statistics (Anthropic doesn't provide usage API)
  async getUsage(startDate, endDate) {
    throw this.createError("Usage statistics not available for Anthropic", "invalid_request");
  }
};
function createAnthropicProvider(config) {
  return new AnthropicProvider(config);
}
function createDefaultAnthropicProvider(apiKey, options) {
  return new AnthropicProvider({
    apiKey,
    defaultModel: "claude-3-sonnet-20240229",
    timeout: 3e4,
    maxRetries: 3,
    retryDelay: 1e3,
    ...options
  });
}

// src/core/providers/factory.ts
var ProviderFactory = class {
  constructor(registry = modelProviderRegistry) {
    this.registry = registry;
  }
  // Create OpenAI provider
  createOpenAI(config) {
    const openaiConfig = {
      ...config,
      // Ensure OpenAI-specific defaults
      defaultModel: config.defaultModel || "gpt-4",
      timeout: config.timeout || 3e4,
      maxRetries: config.maxRetries || 3,
      retryDelay: config.retryDelay || 1e3
    };
    const provider = createOpenAIProvider(openaiConfig);
    this.registry.register("openai", provider);
    return provider;
  }
  // Create Anthropic provider
  createAnthropic(config) {
    const anthropicConfig = {
      ...config,
      // Ensure Anthropic-specific defaults
      defaultModel: config.defaultModel || "claude-3-sonnet-20240229",
      timeout: config.timeout || 3e4,
      maxRetries: config.maxRetries || 3,
      retryDelay: config.retryDelay || 1e3
    };
    const provider = createAnthropicProvider(anthropicConfig);
    this.registry.register("anthropic", provider);
    return provider;
  }
  // Create custom provider (for future extensibility)
  createCustom(config) {
    const { providerType, ...baseConfig } = config;
    switch (providerType.toLowerCase()) {
      case "openai":
        return this.createOpenAI(baseConfig);
      case "anthropic":
        return this.createAnthropic(baseConfig);
      default:
        throw new Error(`Unsupported provider type: ${providerType}`);
    }
  }
  // Create provider from environment variables
  createFromEnv(providerType = "openai") {
    const config = {
      apiKey: this.getApiKeyFromEnv(providerType),
      baseURL: this.getBaseURLFromEnv(providerType),
      defaultModel: this.getDefaultModelFromEnv(providerType),
      timeout: this.getTimeoutFromEnv(),
      maxRetries: this.getMaxRetriesFromEnv(),
      retryDelay: this.getRetryDelayFromEnv()
    };
    return this.createCustom({ ...config, providerType });
  }
  // Get API key from environment variables
  getApiKeyFromEnv(providerType) {
    const envKey = providerType.toUpperCase() + "_API_KEY";
    const apiKey = process.env[envKey];
    if (!apiKey) {
      throw new Error(`API key not found in environment variable: ${envKey}`);
    }
    return apiKey;
  }
  // Get base URL from environment variables
  getBaseURLFromEnv(providerType) {
    const envKey = providerType.toUpperCase() + "_BASE_URL";
    return process.env[envKey];
  }
  // Get default model from environment variables
  getDefaultModelFromEnv(providerType) {
    const envKey = providerType.toUpperCase() + "_DEFAULT_MODEL";
    return process.env[envKey];
  }
  // Get timeout from environment variables
  getTimeoutFromEnv() {
    const timeout = process.env.MODEL_PROVIDER_TIMEOUT;
    return timeout ? parseInt(timeout, 10) : void 0;
  }
  // Get max retries from environment variables
  getMaxRetriesFromEnv() {
    const maxRetries = process.env.MODEL_PROVIDER_MAX_RETRIES;
    return maxRetries ? parseInt(maxRetries, 10) : void 0;
  }
  // Get retry delay from environment variables
  getRetryDelayFromEnv() {
    const retryDelay = process.env.MODEL_PROVIDER_RETRY_DELAY;
    return retryDelay ? parseInt(retryDelay, 10) : void 0;
  }
  // Create provider with validation
  createWithValidation(config) {
    this.validateConfig(config);
    return this.createCustom(config);
  }
  // Validate provider configuration
  validateConfig(config) {
    if (!config.apiKey) {
      throw new Error("API key is required");
    }
    if (!config.providerType) {
      throw new Error("Provider type is required");
    }
    const supportedProviders = ["openai", "anthropic"];
    if (!supportedProviders.includes(config.providerType.toLowerCase())) {
      throw new Error(`Unsupported provider type: ${config.providerType}. Supported types: ${supportedProviders.join(", ")}`);
    }
    switch (config.providerType.toLowerCase()) {
      case "openai":
        if (!config.apiKey.startsWith("sk-")) {
          throw new Error("Invalid OpenAI API key format");
        }
        break;
      case "anthropic":
        if (!config.apiKey.startsWith("sk-ant-")) {
          throw new Error("Invalid Anthropic API key format");
        }
        break;
    }
  }
  // Get registry
  getRegistry() {
    return this.registry;
  }
};
function createOpenAIProviderFromEnv() {
  const factory = new ProviderFactory();
  return factory.createFromEnv("openai");
}
function createAnthropicProviderFromEnv() {
  const factory = new ProviderFactory();
  return factory.createFromEnv("anthropic");
}
function createProviderFromConfig(config) {
  const factory = new ProviderFactory();
  return factory.createCustom({
    providerType: config.type,
    apiKey: config.apiKey,
    baseURL: config.baseURL,
    defaultModel: config.defaultModel,
    timeout: config.timeout,
    maxRetries: config.maxRetries,
    retryDelay: config.retryDelay
  });
}
function createProviderFromApiKey(apiKey, options) {
  const factory = new ProviderFactory();
  if (apiKey.startsWith("sk-") && !apiKey.startsWith("sk-ant-")) {
    return factory.createOpenAI({
      apiKey,
      ...options
    });
  } else if (apiKey.startsWith("sk-ant-")) {
    return factory.createAnthropic({
      apiKey,
      ...options
    });
  } else {
    throw new Error("Unable to detect provider type from API key format");
  }
}
var ProviderPresets = {
  // OpenAI presets
  openai: {
    gpt4: (apiKey) => createProviderFromConfig({
      type: "openai",
      apiKey,
      defaultModel: "gpt-4"
    }),
    gpt4Turbo: (apiKey) => createProviderFromConfig({
      type: "openai",
      apiKey,
      defaultModel: "gpt-4-turbo"
    }),
    gpt35Turbo: (apiKey) => createProviderFromConfig({
      type: "openai",
      apiKey,
      defaultModel: "gpt-3.5-turbo"
    })
  },
  // Anthropic presets
  anthropic: {
    claude3Opus: (apiKey) => createProviderFromConfig({
      type: "anthropic",
      apiKey,
      defaultModel: "claude-3-opus-20240229"
    }),
    claude3Sonnet: (apiKey) => createProviderFromConfig({
      type: "anthropic",
      apiKey,
      defaultModel: "claude-3-sonnet-20240229"
    }),
    claude3Haiku: (apiKey) => createProviderFromConfig({
      type: "anthropic",
      apiKey,
      defaultModel: "claude-3-haiku-20240307"
    })
  }
};
var providerFactory = new ProviderFactory();

// src/core/tool-helpers.ts
var import_v44 = require("zod/v4");
var import_agent_tools = require("@cloudbase/agent-tools");
function createTool(name, description, handler, options) {
  if (!name || typeof name !== "string") {
    throw new ToolValidationError("Tool name must be a non-empty string");
  }
  if (!description || typeof description !== "string") {
    throw new ToolValidationError(
      "Tool description must be a non-empty string"
    );
  }
  if (!handler || typeof handler !== "function") {
    throw new ToolValidationError("Tool handler must be a function");
  }
  return (0, import_agent_tools.tool)(handler, {
    name,
    description,
    schema: options?.schema || import_v44.z.object({}),
    requiresApproval: options?.requiresApproval || false
  });
}
function createTypedTool(name, description, schema, handler, options) {
  return createTool(
    name,
    description,
    async (input, context) => {
      const validatedInput = schema.parse(input);
      return handler(validatedInput, context);
    },
    {
      schema,
      requiresApproval: options?.requiresApproval
    }
  );
}
function createLoggedTool(name, description, handler, options) {
  const logLevel = options?.logLevel || "info";
  return createTool(
    name,
    description,
    async (input, context) => {
      const startTime = Date.now();
      try {
        if (logLevel === "debug" || logLevel === "info") {
          console.log(`[${name}] Input:`, input);
        }
        const result = await handler(input, context);
        const executionTime = Date.now() - startTime;
        if (logLevel === "debug" || logLevel === "info") {
          console.log(`[${name}] Output:`, result);
          console.log(`[${name}] Execution time: ${executionTime}ms`);
        }
        return result;
      } catch (error) {
        const executionTime = Date.now() - startTime;
        if (logLevel === "error" || logLevel === "warn") {
          console.error(`[${name}] Error after ${executionTime}ms:`, error);
        }
        throw error;
      }
    },
    options
  );
}
function createRetryTool(name, description, handler, options) {
  const maxRetries = options?.maxRetries || 3;
  const retryDelay = options?.retryDelay || 1e3;
  const retryCondition = options?.retryCondition || (() => true);
  return createTool(
    name,
    description,
    async (input, context) => {
      let lastError;
      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          return await handler(input, context);
        } catch (error) {
          lastError = error instanceof Error ? error : new Error(String(error));
          if (attempt === maxRetries || !retryCondition(lastError)) {
            throw lastError;
          }
          await new Promise(
            (resolve) => setTimeout(resolve, retryDelay * (attempt + 1))
          );
        }
      }
      throw lastError;
    },
    options
  );
}
function createTimeoutTool(name, description, handler, options) {
  const timeout = options?.timeout || 3e4;
  return createTool(
    name,
    description,
    async (input, context) => {
      return Promise.race([
        handler(input, context),
        new Promise((_, reject) => {
          setTimeout(() => {
            reject(new Error(`Tool '${name}' timed out after ${timeout}ms`));
          }, timeout);
        })
      ]);
    },
    options
  );
}
function createCompositeTool(name, description, tools, options) {
  const executionMode = options?.executionMode || "sequential";
  return createTool(
    name,
    description,
    async (input, context) => {
      if (!Array.isArray(input)) {
        throw new Error(
          "Composite tool input must be an array of tool executions"
        );
      }
      const results = [];
      if (executionMode === "parallel") {
        const promises = input.map(async (toolInput) => {
          const toolName = toolInput.toolName;
          const tool2 = tools.find((t) => t.name === toolName);
          if (!tool2) {
            throw new Error(`Tool '${toolName}' not found in composite tool`);
          }
          if (!tool2.invoke) {
            throw new Error(
              `Tool '${toolName}' has no invoke (client-side tool)`
            );
          }
          return tool2.invoke(toolInput.input, context);
        });
        const parallelResults = await Promise.all(promises);
        results.push(...parallelResults);
      } else {
        for (const toolInput of input) {
          const toolName = toolInput.toolName;
          const tool2 = tools.find((t) => t.name === toolName);
          if (!tool2) {
            throw new Error(`Tool '${toolName}' not found in composite tool`);
          }
          if (!tool2.invoke) {
            throw new Error(
              `Tool '${toolName}' has no invoke (client-side tool)`
            );
          }
          const result = await tool2.invoke(toolInput.input, context);
          results.push(result);
        }
      }
      return results;
    },
    {
      requiresApproval: options?.requiresApproval || tools.some((t) => t.requiresApproval)
    }
  );
}

// src/core/conversation-manager.ts
var import_node_crypto5 = require("crypto");
var ConversationManager = class {
  constructor() {
    this.conversations = /* @__PURE__ */ new Map();
    this.currentState = /* @__PURE__ */ new Map();
  }
  /**
   * Create a message with state metadata
   */
  createMessageWithState(role, content, conversationId, options) {
    const currentState = this.currentState.get(conversationId) || {};
    return {
      id: (0, import_node_crypto5.randomUUID)(),
      role,
      content,
      timestamp: /* @__PURE__ */ new Date(),
      toolCalls: options?.toolCalls,
      toolCallId: options?.toolCallId,
      metadata: {
        state: this.deepClone(currentState),
        conversationId,
        runId: options?.runId,
        userId: options?.userId
      }
    };
  }
  /**
   * Extract current state from messages
   */
  extractStateFromMessages(messages) {
    const lastMessage = messages[messages.length - 1];
    if (lastMessage?.metadata?.state) {
      return lastMessage.metadata.state;
    }
    return {};
  }
  /**
   * Get conversation messages
   */
  getConversationMessages(conversationId) {
    return this.conversations.get(conversationId) || [];
  }
  /**
   * Add messages to conversation
   */
  addMessages(conversationId, messages) {
    const existing = this.conversations.get(conversationId) || [];
    this.conversations.set(conversationId, [...existing, ...messages]);
  }
  /**
   * Get current state for conversation
   */
  getCurrentState(conversationId) {
    return this.currentState.get(conversationId) || {};
  }
  /**
   * Update state for conversation
   */
  updateState(conversationId, stateChanges) {
    const current = this.currentState.get(conversationId) || {};
    this.currentState.set(conversationId, { ...current, ...stateChanges });
  }
  /**
   * Clear conversation data
   */
  clearConversation(conversationId) {
    this.conversations.delete(conversationId);
    this.currentState.delete(conversationId);
  }
  /**
   * Deep clone an object to prevent reference sharing
   */
  deepClone(obj) {
    if (obj === null || typeof obj !== "object") {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (Array.isArray(obj)) {
      return obj.map((item) => this.deepClone(item));
    }
    if (typeof obj === "object") {
      const cloned = {};
      for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
          cloned[key] = this.deepClone(obj[key]);
        }
      }
      return cloned;
    }
    return obj;
  }
};

// src/agkit/index.ts
init_agent();
init_converter();

// src/core/storage/tdaimemory/errors.ts
var ParamError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "ParamError";
  }
};
var TDAIException = class extends Error {
  constructor(data, requestId) {
    super(data.message);
    this.name = "TDAIException";
    this.code = data.code;
    this.message = data.message || "";
    this.requestId = requestId || data.req_id;
  }
  toString() {
    if (this.requestId) {
      return `<${this.constructor.name}: (code=${this.code}, message=${this.message}, request_id=${this.requestId})>`;
    } else {
      return `<${this.constructor.name}: (code=${this.code}, message=${this.message})>`;
    }
  }
};

// src/core/storage/tdaimemory/stub.ts
var Stub = class {
};
var HttpStub = class extends Stub {
  constructor(options) {
    super();
    this.endpoint = options.endpoint;
    this.timeout = options.timeout || 1e4;
    this.headers = {
      "x-tdai-service-id": options.serviceId,
      "Authorization": `Bearer ${options.apiKey}`,
      "Content-Type": "application/json"
    };
  }
  /**
   * Send a POST request to the specified path
   */
  async post(path, body, timeout) {
    const requestTimeout = timeout ? timeout * 1e3 : this.timeout;
    const url = `${this.endpoint}${path}`;
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), requestTimeout);
      const response = await fetch(url, {
        method: "POST",
        headers: this.headers,
        body: JSON.stringify(body),
        signal: controller.signal
      });
      clearTimeout(timeoutId);
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const responseText = await response.text();
      const data = JSON.parse(responseText);
      if (data.code !== 0) {
        const requestId = response.headers.get("x-qcloud-transaction-id");
        throw new TDAIException(data, requestId || void 0);
      }
      return data.data;
    } catch (error) {
      if (error instanceof TDAIException) {
        throw error;
      }
      throw new Error(`Request failed: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Close the HTTP client connection
   * Note: fetch API doesn't require explicit cleanup, but this method is provided for interface compatibility
   */
  close() {
  }
};

// src/core/storage/tdaimemory/client.ts
var MemoryClient = class {
  constructor(options) {
    this.defaultMemoryId = options.memoryId;
    this.defaultActorId = options.defaultActorId;
    if (options.stub) {
      this.stub = options.stub;
    } else {
      this.stub = new HttpStub({
        endpoint: options.endpoint || "https://memory.tdai.tencentyun.com",
        apiKey: options.apiKey,
        serviceId: options.memoryId,
        timeout: options.timeout
      });
    }
  }
  /**
   * Close the client connection
   */
  close() {
    this.stub.close();
  }
  getMemoryId(memoryId) {
    return memoryId || this.defaultMemoryId;
  }
  getActorId(actorId) {
    if (actorId) {
      return actorId;
    }
    if (this.defaultActorId) {
      return this.defaultActorId;
    }
    throw new ParamError("actor_id is required");
  }
  /**
   * Create a new session
   */
  async createSession(options = {}) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId)
    };
    if (options.name !== void 0) {
      requestBody.name = options.name;
    }
    return this.stub.post("/memory/v1/session/create", requestBody);
  }
  /**
   * Query sessions based on conditions
   */
  async querySessions(options = {}) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId)
    };
    if (options.orderBy !== void 0) {
      requestBody.order_by = options.orderBy;
    }
    if (options.limit !== void 0) {
      requestBody.limit = options.limit;
    }
    if (options.offset !== void 0) {
      requestBody.offset = options.offset;
    }
    return this.stub.post("/memory/v1/session/query", requestBody);
  }
  /**
   * Update an existing session
   */
  async updateSession(options) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId),
      session_id: options.sessionId,
      name: options.name
    };
    return this.stub.post("/memory/v1/session/update", requestBody);
  }
  /**
   * Delete an existing session
   */
  async deleteSession(options) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId),
      session_id: options.sessionId
    };
    return this.stub.post("/memory/v1/session/delete", requestBody);
  }
  /**
   * Search sessions based on conditions and keywords
   */
  async searchSessions(options) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId),
      content: options.content
    };
    if (options.orderBy !== void 0) {
      requestBody.order_by = options.orderBy;
    }
    if (options.limit !== void 0) {
      requestBody.limit = options.limit;
    }
    return this.stub.post("/memory/v1/session/search", requestBody);
  }
  /**
   * Append events to a session
   */
  async appendEvent(options) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId),
      session_id: options.sessionId,
      messages: options.messages
    };
    return this.stub.post("/memory/v1/event/append", requestBody);
  }
  /**
   * Query events based on conditions
   */
  async queryEvents(options = {}) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId)
    };
    if (options.sessionId !== void 0) {
      requestBody.session_id = options.sessionId;
    }
    if (options.where !== void 0) {
      requestBody.where = options.where;
    }
    if (options.orderBy !== void 0) {
      requestBody.order_by = options.orderBy;
    }
    if (options.limit !== void 0) {
      requestBody.limit = options.limit;
    }
    if (options.offset !== void 0) {
      requestBody.offset = options.offset;
    }
    return this.stub.post("/memory/v1/event/query", requestBody);
  }
  /**
   * Delete an event from a session
   */
  async deleteEvent(options) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId),
      session_id: options.sessionId,
      event_id: options.eventId
    };
    return this.stub.post("/memory/v1/event/delete", requestBody);
  }
  /**
   * Set state for a session
   */
  async setState(options) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId),
      session_id: options.sessionId,
      state: options.state
    };
    return this.stub.post("/memory/v1/state/set", requestBody);
  }
  /**
   * Get state for a session
   */
  async getStates(options) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId),
      session_id: options.sessionId,
      keys: options.keys
    };
    return this.stub.post("/memory/v1/state/get", requestBody);
  }
  /**
   * Get all states for an actor in a memory
   */
  async getAllStates(options) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId),
      session_id: options.sessionId
    };
    return this.stub.post("/memory/v1/state/get_all", requestBody);
  }
  /**
   * Delete specified state keys for a session
   */
  async deleteStates(options) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId),
      session_id: options.sessionId,
      keys: options.keys
    };
    return this.stub.post("/memory/v1/state/delete", requestBody);
  }
  /**
   * Flush all states for a session
   */
  async flushStates(options) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId),
      session_id: options.sessionId
    };
    return this.stub.post("/memory/v1/state/flush", requestBody);
  }
  /**
   * Append records to a session
   */
  async appendRecord(options) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId),
      session_id: options.sessionId,
      content: options.content,
      strategy: options.strategy
    };
    return this.stub.post("/memory/v1/record/append", requestBody);
  }
  /**
   * Query records based on conditions
   */
  async queryRecords(options = {}) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId)
    };
    if (options.sessionId !== void 0) {
      requestBody.session_id = options.sessionId;
    }
    if (options.strategies !== void 0) {
      requestBody.strategies = options.strategies;
    }
    if (options.where !== void 0) {
      requestBody.where = options.where;
    }
    if (options.orderBy !== void 0) {
      requestBody.order_by = options.orderBy;
    }
    if (options.limit !== void 0) {
      requestBody.limit = options.limit;
    }
    if (options.offset !== void 0) {
      requestBody.offset = options.offset;
    }
    return this.stub.post("/memory/v1/record/query", requestBody);
  }
  /**
   * Update an existing record
   */
  async updateRecord(options) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId),
      session_id: options.sessionId,
      record_id: options.recordId,
      content: options.content
    };
    return this.stub.post("/memory/v1/record/update", requestBody);
  }
  /**
   * Delete an existing record
   */
  async deleteRecord(options) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId),
      session_id: options.sessionId,
      record_id: options.recordId
    };
    return this.stub.post("/memory/v1/record/delete", requestBody);
  }
  /**
   * Search records based on conditions and keywords
   */
  async searchRecords(options) {
    const requestBody = {
      memory_id: this.getMemoryId(options.memoryId),
      actor_id: this.getActorId(options.actorId),
      content: options.content
    };
    if (options.sessionId !== void 0) {
      requestBody.session_id = options.sessionId;
    }
    if (options.strategies !== void 0) {
      requestBody.strategies = options.strategies;
    }
    if (options.where !== void 0) {
      requestBody.where = options.where;
    }
    if (options.orderBy !== void 0) {
      requestBody.order_by = options.orderBy;
    }
    if (options.limit !== void 0) {
      requestBody.limit = options.limit;
    }
    return this.stub.post("/memory/v1/record/search", requestBody);
  }
};

// src/core/storage/tdaimemory/params.ts
var Order = class {
};
/** Ascending sort order */
Order.ASCENDING = 1;
/** Descending sort order */
Order.DESCENDING = -1;

// src/core/storage/memory/tdai-memory.ts
var TDAIMemory = class extends BaseMemory {
  /**
   * Creates a new TDAIMemory instance
   * @param options - Configuration options
   * @param options.sessionId - Unique session identifier
   * @param options.client - Optional pre-configured TDAI client
   * @param options.clientOptions - TDAI client configuration if client not provided
   * @param options.useCache - Enable local caching for better performance
   * @param options.enableContextManagement - Whether to automatically manage context after adding events (default: true)
   */
  constructor(options) {
    super(options);
    if (!options.client && !options.clientOptions) {
      throw new Error("Either client or clientOptions must be provided");
    }
    this.client = options.client || new MemoryClient(options.clientOptions);
    this.sessionId = options.sessionId;
    this.cachedMap = /* @__PURE__ */ new Map();
    this.useCache = options.useCache ?? false;
    this.enableContextManagement = options.enableContextManagement ?? options.thresholds ? true : false;
  }
  /**
   * Returns events from TDAI service with filtering, pagination, and token limiting
   * @param options - Optional filtering and pagination options
   * @returns Promise resolving to filtered array of memory events
   */
  async list(options) {
    try {
      const queryParams = {
        sessionId: this.sessionId
      };
      if (options?.limit) {
        queryParams.limit = options.limit;
      }
      if (options?.offset) {
        queryParams.offset = options.offset;
      }
      if (options?.order) {
        queryParams.orderBy = {
          created_at: options.order === "desc" ? Order.DESCENDING : Order.ASCENDING
        };
      }
      const { events = [], total_count } = await this.client.queryEvents(queryParams);
      let memoryEvents = this.convertTDAIEventsToMemoryEvents(events);
      if (this.enableContextManagement) {
        await this.manageContext({
          sessionId: this.sessionId,
          events: memoryEvents
        });
      }
      if (options?.maxTokens) {
        memoryEvents = this.tokenTrimmer.trimMessages(
          memoryEvents,
          options.maxTokens
        );
      }
      if (this.useCache) {
        this.cachedMap.set("events", events);
        this.cachedMap.set("total_count", total_count);
      }
      return options?.order === "desc" ? memoryEvents.reverse() : memoryEvents;
    } catch (error) {
      console.error("Error listing events:", error);
      return [];
    }
  }
  /**
   * Add a single event to TDAI cloud storage
   * @param event - The memory event to store
   * @param options - Optional session options
   */
  async add(event, options) {
    try {
      await this.client.appendEvent({
        sessionId: this.sessionId,
        messages: {
          role: event.message.role,
          content: event.message.content,
          metadata: {
            ...event.state,
            messageId: event.message.id,
            timestamp: event.message.timestamp?.toISOString(),
            toolCalls: event.message.toolCalls,
            toolCallId: event.message.toolCallId
          }
        }
      });
      this.cachedMap.clear();
    } catch (error) {
      console.error("Error adding event:", error);
      throw error;
    }
  }
  /**
   * Add multiple events efficiently with sequential processing
   * @param list - Array of memory events to store
   */
  async addList(list, options) {
    const originalContextManagement = this.enableContextManagement;
    this.enableContextManagement = false;
    try {
      for (const event of list) {
        await this.add(event, options);
      }
    } finally {
      this.enableContextManagement = originalContextManagement;
    }
  }
  // TODO: impl update event in tdaiclient
  async update({ sessionId, event }) {
  }
  /**
   * Delete an event from TDAI cloud storage
   * @param idOrIndex - Event ID (string) or array index (number, not yet implemented)
   */
  async delete(idOrIndex) {
    if (typeof idOrIndex === "string") {
      await this.client.deleteEvent({
        sessionId: this.sessionId,
        eventId: idOrIndex
      });
      this.cachedMap.clear();
    } else {
      console.warn("Deleting by index is not yet implemented", idOrIndex);
      throw new Error("Deleting by index is not yet implemented");
      this.cachedMap.clear();
    }
  }
  /**
   * Retrieve events using TDAI's search capabilities
   * @param query - Optional search query for content matching
   * @returns Promise resolving to array of matching events
   */
  async retrieve(query) {
    if (!query) {
      return this.list();
    }
    const { events = [] } = await this.client.queryEvents({
      sessionId: this.sessionId,
      where: {
        content: {
          // TODO: Replace with semantic similarity search
          $eq: query
        }
      }
    });
    return this.convertTDAIEventsToMemoryEvents(events);
  }
  /**
   * Clear all events.
   */
  // public async clear(): Promise<void> {
  //   return this.delete();
  // }
  /**
   * Check if the session contains any events
   * @returns Promise resolving to true if no events are stored
   */
  async isEmpty() {
    return await this.getCount() === 0;
  }
  /**
   * Get the current number of events stored in the session
   * @returns Promise resolving to the count of stored events
   */
  async getCount() {
    if (this.useCache && this.cachedMap.get("total_count") !== void 0) {
      return this.cachedMap.get("total_count");
    } else {
      const { total_count } = await this.client.queryEvents({
        sessionId: this.sessionId
      });
      return total_count;
    }
  }
  /**
   * Convert TDAI events to IMemoryEvent format for compatibility
   * @param events - Array of TDAI events to convert
   * @returns Array of converted memory events
   */
  convertTDAIEventsToMemoryEvents(events) {
    return events.map((event) => ({
      message: {
        id: event.metadata?.messageId || Math.random().toString(36).substr(2, 9),
        role: event.role || "user",
        content: event.content || "",
        timestamp: event.metadata?.timestamp ? new Date(event.metadata.timestamp) : /* @__PURE__ */ new Date(),
        toolCalls: event.metadata?.toolCalls,
        toolCallId: event.metadata?.toolCallId
      },
      state: {
        ...this.extractStateFromMetadata(event.metadata || {}),
        ...event.score !== void 0 && { score: event.score }
      }
    }));
  }
  /**
   * Extract state from metadata, excluding message-specific fields
   * @param metadata - Event metadata object
   * @returns Cleaned state object without message fields
   */
  extractStateFromMetadata(metadata) {
    const { messageId, timestamp, toolCalls, toolCallId, ...state } = metadata;
    return state;
  }
  /**
   * Clean up branches - not supported by TDAI Memory
   * @param keepBranches - Ignored parameter
   * @throws Error indicating branch operations are not supported
   */
  async cleanupBranches(keepBranches) {
    throw new Error("Branch operations are not supported by TDAI Memory");
  }
};

// src/core/storage/memory/cloudbase/cloudbase-query-builder.ts
var CloudBaseQueryBuilder = class _CloudBaseQueryBuilder {
  constructor(db) {
    this.conditions = {};
    this.orConditions = [];
    this.db = db;
  }
  where(field, operator, value) {
    this.conditions[field] = this.buildOperator(operator, value);
    return this;
  }
  and(field, operator, value) {
    return this.where(field, operator, value);
  }
  or(conditions) {
    this.orConditions = conditions.map((builder) => builder.build());
    return this;
  }
  in(field, values) {
    const _ = this.db.command;
    this.conditions[field] = _.in(values);
    return this;
  }
  regex(field, pattern, options) {
    this.conditions[field] = this.db.RegExp({
      regexp: pattern,
      options: options || "i"
    });
    return this;
  }
  build() {
    if (this.orConditions.length > 0) {
      const _ = this.db.command;
      return _.or(this.orConditions);
    }
    return this.conditions;
  }
  clone() {
    const cloned = new _CloudBaseQueryBuilder(this.db);
    cloned.conditions = { ...this.conditions };
    cloned.orConditions = [...this.orConditions];
    return cloned;
  }
  /**
   * Build CloudBase operator from generic operator
   */
  buildOperator(operator, value) {
    const _ = this.db.command;
    const operatorMap = {
      eq: (v) => _.eq(v),
      ne: (v) => _.neq(v),
      gt: (v) => _.gt(v),
      gte: (v) => _.gte(v),
      lt: (v) => _.lt(v),
      lte: (v) => _.lte(v),
      in: (v) => _.in(v),
      nin: (v) => _.nin(v)
    };
    if (operator === "eq") {
      return value;
    }
    const buildFn = operatorMap[operator];
    return buildFn ? buildFn(value) : value;
  }
};
var CloudBaseUpdateBuilder = class {
  constructor() {
    this.updates = {};
    this.removes = [];
    this.increments = {};
  }
  set(field, value) {
    this.updates[field] = value;
    return this;
  }
  setMultiple(updates) {
    Object.assign(this.updates, updates);
    return this;
  }
  unset(field) {
    this.removes.push(field);
    return this;
  }
  increment(field, value) {
    this.increments[field] = value;
    return this;
  }
  build() {
    const result = { ...this.updates };
    Object.entries(this.increments).forEach(([field, value]) => {
      result[`__inc_${field}`] = value;
    });
    this.removes.forEach((field) => {
      result[field] = null;
    });
    return result;
  }
};

// src/core/storage/memory/cloudbase/cloudbase-adapter.ts
var CloudBaseAdapter = class {
  constructor(db) {
    this.db = db;
  }
  getCollection(name) {
    return this.db.collection(name);
  }
  async find(collection, query, options) {
    let queryBuilder = collection.where(query);
    if (options?.sort) {
      const sortField = Object.keys(options.sort)[0];
      const sortOrder = options.sort[sortField] === 1 ? "asc" : "desc";
      queryBuilder = queryBuilder.orderBy(sortField, sortOrder);
    }
    if (options?.skip) {
      queryBuilder = queryBuilder.skip(options.skip);
    }
    if (options?.limit) {
      queryBuilder = queryBuilder.limit(options.limit);
    }
    const result = await queryBuilder.get();
    return result.data;
  }
  async findOne(collection, query) {
    const result = await collection.where(query).limit(1).get();
    return result.data.length > 0 ? result.data[0] : null;
  }
  async insertOne(collection, document) {
    const result = await collection.add(document);
    return { _id: result.id, ...document };
  }
  async insertMany(collection, documents) {
    let insertedCount = 0;
    for (const doc of documents) {
      await collection.add(doc);
      insertedCount++;
    }
    return { insertedCount };
  }
  async updateOne(collection, filter, update) {
    const result = await collection.where(filter).limit(1).get();
    if (result.data.length === 0) {
      return { modifiedCount: 0 };
    }
    const docId = result.data[0]._id;
    const updateData = { ...update };
    const incrementFields = {};
    Object.keys(updateData).forEach((key) => {
      if (key.startsWith("__inc_")) {
        const field = key.substring(6);
        incrementFields[field] = updateData[key];
        delete updateData[key];
      }
    });
    if (Object.keys(incrementFields).length > 0) {
      const currentDoc = result.data[0];
      Object.entries(incrementFields).forEach(([field, value]) => {
        updateData[field] = (currentDoc[field] || 0) + value;
      });
    }
    await collection.doc(docId).update(updateData);
    return { modifiedCount: 1 };
  }
  async deleteOne(collection, filter) {
    const result = await collection.where(filter).limit(1).get();
    if (result.data.length === 0) {
      return { deletedCount: 0 };
    }
    const docId = result.data[0]._id;
    await collection.doc(docId).remove();
    return { deletedCount: 1 };
  }
  async deleteMany(collection, filter) {
    const result = await collection.where(filter).remove();
    return { deletedCount: result.deleted || 0 };
  }
  async count(collection, query) {
    const result = await collection.where(query).count();
    return result.total;
  }
  // Query builder factory methods
  createQueryBuilder() {
    return new CloudBaseQueryBuilder(this.db);
  }
  createUpdateBuilder() {
    return new CloudBaseUpdateBuilder();
  }
};

// src/core/storage/memory/cloudbase/utils.ts
var CollectionManager2 = class {
  constructor(app, collectionName, summaryCollectionName, stateCollectionName) {
    this.app = app;
    this.collectionName = collectionName;
    this.summaryCollectionName = summaryCollectionName;
    this.stateCollectionName = stateCollectionName;
    this.adapter = new CloudBaseAdapter(this.app.database());
  }
  /**
   * Get the main events collection
   */
  getCollection() {
    return this.app.database().collection(this.collectionName);
  }
  /**
   * Get the summary collection
   */
  getSummaryCollection() {
    return this.app.database().collection(this.summaryCollectionName);
  }
  /**
   * Get the state collection
   */
  getStateCollection() {
    return this.app.database().collection(this.stateCollectionName);
  }
  /**
   * Get database instance
   */
  getDatabase() {
    return this.app.database();
  }
  /**
   * Get database adapter
   */
  getAdapter() {
    return this.adapter;
  }
};
var DocumentConverter2 = class {
  /**
   * Convert IMemoryEvent to CloudBase document
   */
  toDocument(event, sessionId, branchPath) {
    return {
      sessionId,
      messageId: event.message.id,
      branchPath,
      role: event.message.role,
      content: event.message.content,
      toolCalls: event.message.toolCalls,
      toolCallId: event.message.toolCallId,
      state: event.state || {},
      createdAt: event.message.timestamp || /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    };
  }
  /**
   * Convert CloudBase document to IMemoryEvent
   */
  fromDocument(doc) {
    return {
      message: {
        id: doc.messageId,
        role: doc.role,
        content: doc.content,
        toolCalls: doc.toolCalls,
        toolCallId: doc.toolCallId,
        timestamp: doc.createdAt
      },
      state: doc.state
    };
  }
  /**
   * Convert summary to CloudBase summary document
   */
  toSummaryDocument(summary, sessionId) {
    return {
      sessionId,
      summaryId: summary.id,
      content: summary.content,
      metadata: summary.metadata,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    };
  }
  /**
   * Convert CloudBase summary document to summary
   */
  fromSummaryDocument(doc) {
    return {
      id: doc.summaryId,
      content: doc.content,
      metadata: doc.metadata
    };
  }
};

// src/core/storage/memory/cloudbase/cloudbase-memory.ts
var CloudBaseMemory = class extends BaseMemory {
  /**
   * Creates a new CloudBaseMemory instance
   * @param options - Configuration options
   * @param options.app - CloudBase app instance from @cloudbase/node-sdk
   * @param options.collectionName - Collection name for storing events (default: 'memory_events')
   * @param options.summaryCollectionName - Collection name for storing summaries (default: 'memory_summaries')
   * @param options.stateCollectionName - Collection name for storing session state (default: 'memory_state')
   * @param options.sessionId - Unique session identifier (default: 'default')
   * @param options.enableContextManagement - Whether to automatically manage context (default: true if thresholds provided)
   */
  constructor(options) {
    super(options);
    if (!options.app) {
      throw new Error("CloudBase app instance is required");
    }
    this.sessionId = options.sessionId || "default";
    this.enableContextManagement = options.enableContextManagement ?? (options.thresholds ? true : false);
    this.collectionManager = new CollectionManager2(
      options.app,
      options.collectionName || "memory_events",
      options.summaryCollectionName || "memory_summaries",
      options.stateCollectionName || "memory_state"
    );
    this.documentConverter = new DocumentConverter2();
    this.stateManager = new StateManager(this.collectionManager);
    this.cursorManager = new CursorManager(
      this.collectionManager,
      this.stateManager
    );
    this.branchManager = new BranchManager(
      this.collectionManager,
      this.stateManager,
      this.cursorManager
    );
    this.summaryManager = new SummaryManager(
      this.sessionId,
      this.collectionManager,
      this.cursorManager
    );
  }
  // ==================== CRUD Operations ====================
  /**
   * Returns events from CloudBase database with filtering, pagination, and token limiting
   * Respects branch isolation using branch path and snapshot time
   * @param options - Optional filtering and pagination options
   * @returns Promise resolving to filtered array of memory events
   */
  async list(options) {
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const db = this.collectionManager.getDatabase();
      const _ = db.command;
      const sid = options?.sessionId || this.sessionId;
      const currentBranchPath = await this.branchManager.getCurrentBranchPath(sid);
      const branchConditions = await this.branchManager.buildBranchConditions(
        sid,
        currentBranchPath
      );
      const startCursor = await this.cursorManager.getStartCursor(sid);
      let conditions = branchConditions;
      if (startCursor) {
        conditions = this.branchManager.applyCursorCondition(
          conditions,
          startCursor
        );
      }
      let whereCondition;
      if (conditions.length > 1) {
        whereCondition = _.or(conditions);
      } else {
        whereCondition = conditions[0];
      }
      const order = options?.order || "desc";
      const queryOptions = {
        sort: { createdAt: order === "asc" ? 1 : -1 }
      };
      if (options?.offset) {
        queryOptions.skip = options.offset;
      }
      if (options?.limit) {
        queryOptions.limit = options.limit;
      }
      const result = await adapter.find(
        collection,
        whereCondition,
        queryOptions
      );
      let events = (order === "desc" ? result.reverse() : result).map(
        (doc) => this.documentConverter.fromDocument(doc)
      );
      if (this.enableContextManagement && events.length > 0) {
        const res = await this.manageContext({ sessionId: sid, events });
        events = res.events;
      }
      if (options?.maxTokens) {
        events = this.tokenTrimmer.trimMessages(events, options.maxTokens);
      }
      return events;
    } catch (error) {
      console.error("Error listing events from CloudBase:", error);
      throw error;
    }
  }
  /**
   * Add a single event to CloudBase database
   * @param event - The memory event to store
   * @param options - Optional session options
   */
  async add(event, options) {
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      if (!event.message.timestamp) {
        event.message.timestamp = /* @__PURE__ */ new Date();
      }
      const branchPath = await this.branchManager.getCurrentBranchPath(sid);
      const doc = this.documentConverter.toDocument(event, sid, branchPath);
      await adapter.insertOne(collection, doc);
    } catch (error) {
      console.error("Error adding event to CloudBase:", error);
      throw error;
    }
  }
  /**
   * Add multiple events efficiently
   * @param list - Array of memory events to store
   * @param options - Optional session options
   */
  async addList(list, options) {
    for (const event of list) {
      await this.add(event, options);
    }
  }
  /**
   * Update an event in CloudBase database
   * @param params - Update parameters
   */
  async update(params) {
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = params.sessionId || this.sessionId;
      const query = adapter.createQueryBuilder().where("sessionId", "eq", sid).and("messageId", "eq", params.event.message.id).build();
      const doc = await adapter.findOne(
        collection,
        query
      );
      if (!doc) {
        throw new Error(
          `Event with messageId '${params.event.message.id}' not found in session '${sid}'`
        );
      }
      const branchPath = await this.branchManager.getCurrentBranchPath(sid);
      const updateDoc = this.documentConverter.toDocument(
        params.event,
        sid,
        branchPath
      );
      const update = adapter.createUpdateBuilder().setMultiple({
        ...updateDoc,
        updatedAt: /* @__PURE__ */ new Date()
      }).build();
      await adapter.updateOne(collection, query, update);
    } catch (error) {
      console.error("Error updating event in CloudBase:", error);
      throw error;
    }
  }
  /**
   * Delete an event from CloudBase database
   * @param idOrIndex - Message ID (string) to delete
   * @param options - Optional session options
   */
  async delete(idOrIndex, options) {
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      if (typeof idOrIndex === "string") {
        const query = adapter.createQueryBuilder().where("sessionId", "eq", sid).and("messageId", "eq", idOrIndex).build();
        await adapter.deleteMany(collection, query);
      } else {
        console.warn(
          "Deleting by index is not efficient in CloudBase. Consider using message ID instead."
        );
        const events = await this.list({ sessionId: sid });
        if (idOrIndex >= 0 && idOrIndex < events.length) {
          const eventToDelete = events[idOrIndex];
          await this.delete(eventToDelete.message.id, options);
        }
      }
    } catch (error) {
      console.error("Error deleting event from CloudBase:", error);
      throw error;
    }
  }
  /**
   * Clear all events from CloudBase database
   * @param options - Optional session options. If sessionId provided, clears only that session using soft delete.
   */
  async clear(options) {
    try {
      const collection = this.collectionManager.getCollection();
      const stateCollection = this.collectionManager.getStateCollection();
      const summaryCollection = this.collectionManager.getSummaryCollection();
      if (options?.sessionId) {
        const sid = options.sessionId;
        const adapter = this.collectionManager.getAdapter();
        const result = await adapter.find(
          collection,
          { sessionId: sid },
          { sort: { createdAt: -1 }, limit: 1 }
        );
        if (result.length > 0) {
          const lastEvent = result[0];
          await this.cursorManager.setStartCursor(sid, lastEvent.createdAt);
        }
        await adapter.deleteMany(summaryCollection, { sessionId: sid });
      } else {
        const adapter = this.collectionManager.getAdapter();
        await adapter.deleteMany(collection, {});
        await adapter.deleteMany(stateCollection, {});
        await adapter.deleteMany(summaryCollection, {});
      }
      this.stateManager.clearCache();
    } catch (error) {
      console.error("Error clearing events from CloudBase:", error);
      throw error;
    }
  }
  /**
   * Check if the session contains any events (respecting soft delete)
   * @param options - Optional session options
   * @returns Promise resolving to true if no events are stored
   */
  async isEmpty(options) {
    return await this.getCount(options) === 0;
  }
  /**
   * Get the current number of events stored in the session (respecting soft delete)
   * @param options - Optional session options
   * @returns Promise resolving to the count of stored events
   */
  async getCount(options) {
    try {
      const collection = this.collectionManager.getCollection();
      const db = this.collectionManager.getDatabase();
      const _ = db.command;
      const sid = options?.sessionId || this.sessionId;
      const currentBranchPath = await this.branchManager.getCurrentBranchPath(sid);
      const branchConditions = await this.branchManager.buildBranchConditions(
        sid,
        currentBranchPath
      );
      const startCursor = await this.cursorManager.getStartCursor(sid);
      let conditions = branchConditions;
      if (startCursor) {
        conditions = this.branchManager.applyCursorCondition(
          conditions,
          startCursor
        );
      }
      const adapter = this.collectionManager.getAdapter();
      let whereCondition;
      if (conditions.length > 1) {
        whereCondition = _.or(conditions);
      } else {
        whereCondition = conditions[0];
      }
      const count = await adapter.count(collection, whereCondition);
      return count;
    } catch (error) {
      console.error("Error getting count from CloudBase:", error);
      throw error;
    }
  }
  // ==================== Search Operations ====================
  /**
   * Retrieve events using content-based search
   * @param query - Search query text to match against message content
   * @param options - Optional session options
   * @returns Promise resolving to array of matching events
   */
  async retrieve(query, options) {
    try {
      const collection = this.collectionManager.getCollection();
      const db = this.collectionManager.getDatabase();
      const _ = db.command;
      const sid = options?.sessionId || this.sessionId;
      const startCursor = await this.cursorManager.getStartCursor(sid);
      let whereCondition = {
        sessionId: sid,
        content: db.RegExp({
          regexp: query,
          options: "i"
          // case-insensitive
        })
      };
      const adapter = this.collectionManager.getAdapter();
      if (startCursor) {
        const queryBuilder = adapter.createQueryBuilder();
        const cursorCondition = queryBuilder.where("createdAt", "gt", startCursor).build();
        whereCondition = { ...whereCondition, ...cursorCondition };
      }
      const result = await adapter.find(
        collection,
        whereCondition
      );
      return result.map(
        (doc) => this.documentConverter.fromDocument(doc)
      );
    } catch (error) {
      console.error("Error retrieving events from CloudBase:", error);
      throw error;
    }
  }
  // ==================== Summary Operations ====================
  /**
   * Get summaries for a session
   * @param sessionId - Optional session identifier
   * @returns Array of structured summaries
   */
  async getSummaries(sessionId) {
    const summaries = await this.summaryManager.getSummaries(sessionId);
    return summaries.map((doc) => ({
      content: doc.content,
      count: 1,
      // Default count since BaseSummaryDocument doesn't have count
      timeRange: {
        start: doc.metadata?.timeRangeStart,
        end: doc.metadata?.timeRangeEnd
      },
      timestamp: doc.createdAt
    }));
  }
  /**
   * Store summary implementation
   * @param params - Summary storage parameters
   */
  async storeSummary(params) {
    const summaryId = `summary_${Date.now()}`;
    const metadata = {
      count: params.summary.count,
      timeRangeStart: params.summary.timeRange.start,
      timeRangeEnd: params.summary.timeRange.end
    };
    return this.summaryManager.addSummary(
      summaryId,
      params.summary.content,
      metadata,
      params.sessionId
    );
  }
  /**
   * Clear summarized events implementation using soft delete
   * Sets cursor to hide old events without actually deleting them
   * @param params - Clear parameters
   */
  async clearSummarizedEvents(params) {
    return this.summaryManager.clearSummarizedEvents(params);
  }
  // ==================== Branch Management ====================
  /**
   * Create a new branch from current session state
   * @param branchName - Name for the new branch
   * @param fromEventId - Optional event ID to branch from
   * @returns Promise resolving to branch ID
   */
  async branch(branchName, fromEventId) {
    return this.branchManager.createBranch(
      this.sessionId,
      branchName,
      fromEventId,
      () => this.list({ sessionId: this.sessionId })
    );
  }
  /**
   * Switch to a different branch or checkout to a specific event
   * @param target - Branch name or event ID to checkout
   * @param options - Optional configuration
   */
  async checkout(target, options) {
    const sid = options?.sessionId || this.sessionId;
    const checkoutType = options?.type || await this.branchManager.detectCheckoutType(sid, target);
    if (checkoutType === "event") {
      await this.branchManager.checkoutToEvent(sid, target);
    } else {
      await this.branchManager.checkoutBranch(sid, target);
    }
  }
  /**
   * Delete a branch
   * @param branchName - Name of the branch to delete
   */
  async deleteBranch(branchName) {
    return this.branchManager.deleteBranch(this.sessionId, branchName);
  }
  /**
   * List all branches
   * @returns Promise resolving to array of branch information
   */
  async listBranches() {
    const branches = await this.branchManager.listBranches(this.sessionId);
    const currentBranch = await this.getCurrentBranch();
    return branches.map((branch) => ({
      id: branch.name,
      name: branch.name,
      createdAt: branch.createdAt,
      fromEventId: branch.fromEventId,
      isActive: branch.name === currentBranch
    }));
  }
  /**
   * Get current branch name
   * @returns Promise resolving to current branch name
   */
  async getCurrentBranch() {
    return this.branchManager.getCurrentBranch(this.sessionId);
  }
  /**
   * Clean up branches, keeping only specified branches and the current active branch
   * @param keepBranches - Optional list of branch names to keep (in addition to active branch)
   */
  async cleanupBranches(keepBranches) {
    return this.branchManager.cleanupBranches(this.sessionId, keepBranches);
  }
};

// src/core/storage/memory/mongodb/mongodb-memory.ts
var import_mongodb = require("mongodb");

// src/core/storage/memory/mongodb/mongodb-query-builder.ts
var MongoDBQueryBuilder = class _MongoDBQueryBuilder {
  constructor() {
    this.query = {};
    this.orConditions = [];
  }
  where(field, operator, value) {
    this.query[field] = this.buildOperator(operator, value);
    return this;
  }
  and(field, operator, value) {
    return this.where(field, operator, value);
  }
  or(conditions) {
    this.orConditions = conditions.map((builder) => builder.build());
    return this;
  }
  in(field, values) {
    this.query[field] = { $in: values };
    return this;
  }
  regex(field, pattern, options) {
    this.query[field] = new RegExp(pattern, options || "i");
    return this;
  }
  build() {
    if (this.orConditions.length > 0) {
      return { $or: this.orConditions };
    }
    return this.query;
  }
  clone() {
    const cloned = new _MongoDBQueryBuilder();
    cloned.query = { ...this.query };
    cloned.orConditions = [...this.orConditions];
    return cloned;
  }
  /**
   * Build MongoDB operator from generic operator
   */
  buildOperator(operator, value) {
    const operatorMap = {
      eq: "$eq",
      ne: "$ne",
      gt: "$gt",
      gte: "$gte",
      lt: "$lt",
      lte: "$lte",
      in: "$in",
      nin: "$nin"
    };
    if (operator === "eq") {
      return value;
    }
    const mongoOp = operatorMap[operator];
    return { [mongoOp]: value };
  }
};
var MongoDBUpdateBuilder = class {
  constructor() {
    this.updates = {};
    this.unsets = {};
    this.increments = {};
  }
  set(field, value) {
    this.updates[field] = value;
    return this;
  }
  setMultiple(updates) {
    Object.assign(this.updates, updates);
    return this;
  }
  unset(field) {
    this.unsets[field] = "";
    return this;
  }
  increment(field, value) {
    this.increments[field] = value;
    return this;
  }
  build() {
    const result = {};
    if (Object.keys(this.updates).length > 0) {
      result.$set = this.updates;
    }
    if (Object.keys(this.unsets).length > 0) {
      result.$unset = this.unsets;
    }
    if (Object.keys(this.increments).length > 0) {
      result.$inc = this.increments;
    }
    return result;
  }
};

// src/core/storage/memory/mongodb/mongodb-adapter.ts
var MongoDBAdapter = class {
  constructor(db) {
    this.db = db;
  }
  getCollection(name) {
    return this.db.collection(name);
  }
  async find(collection, query, options) {
    let cursor = collection.find(query);
    if (options?.sort) {
      cursor = cursor.sort(options.sort);
    }
    if (options?.skip) {
      cursor = cursor.skip(options.skip);
    }
    if (options?.limit) {
      cursor = cursor.limit(options.limit);
    }
    return cursor.toArray();
  }
  async findOne(collection, query) {
    return collection.findOne(query);
  }
  async insertOne(collection, document) {
    const result = await collection.insertOne(document);
    return { _id: result.insertedId, ...document };
  }
  async insertMany(collection, documents) {
    const result = await collection.insertMany(documents);
    return { insertedCount: result.insertedCount };
  }
  async updateOne(collection, filter, update) {
    const hasOperators = Object.keys(update).some((key) => key.startsWith("$"));
    const updateDoc = hasOperators ? update : { $set: update };
    const result = await collection.updateOne(filter, updateDoc);
    return { modifiedCount: result.modifiedCount };
  }
  async deleteOne(collection, filter) {
    const result = await collection.deleteOne(filter);
    return { deletedCount: result.deletedCount };
  }
  async deleteMany(collection, filter) {
    const result = await collection.deleteMany(filter);
    return { deletedCount: result.deletedCount };
  }
  async count(collection, query) {
    return collection.countDocuments(query);
  }
  // Query builder factory methods
  createQueryBuilder() {
    return new MongoDBQueryBuilder();
  }
  createUpdateBuilder() {
    return new MongoDBUpdateBuilder();
  }
};

// src/core/storage/memory/mongodb/collection-manager.ts
var MongoDBCollectionManager = class {
  constructor(db, collectionName, stateCollectionName, summaryCollectionName) {
    this.db = db;
    this.collectionName = collectionName;
    this.stateCollectionName = stateCollectionName;
    this.summaryCollectionName = summaryCollectionName;
    this.adapter = new MongoDBAdapter(db);
    this.eventsCollection = db.collection(collectionName);
    this.stateCollection = db.collection(stateCollectionName);
    this.summaryCollection = db.collection(summaryCollectionName);
  }
  getCollection() {
    return this.eventsCollection;
  }
  getStateCollection() {
    return this.stateCollection;
  }
  getSummaryCollection() {
    return this.summaryCollection;
  }
  getDatabase() {
    return this.db;
  }
  getAdapter() {
    return this.adapter;
  }
};

// src/core/storage/memory/common/document-converter.ts
var DocumentConverter3 = class {
  /**
   * Convert memory event to database document
   */
  toDocument(event, sessionId, branchPath) {
    return {
      sessionId,
      messageId: event.message.id,
      branchPath,
      role: event.message.role,
      content: event.message.content,
      toolCalls: event.message.toolCalls,
      toolCallId: event.message.toolCallId,
      state: event.state,
      createdAt: event.message.timestamp || /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date()
    };
  }
  /**
   * Convert database document to memory event
   */
  fromDocument(doc) {
    return {
      message: {
        id: doc.messageId,
        role: doc.role,
        content: doc.content,
        toolCalls: doc.toolCalls,
        toolCallId: doc.toolCallId,
        timestamp: doc.createdAt
      },
      state: doc.state
    };
  }
};

// src/core/storage/memory/mongodb/mongodb-memory.ts
var MongoDBMemory = class extends BaseMemory {
  /**
   * Creates a new MongoDBMemory instance
   * @param config - Configuration options
   * @param config.db - MongoDB database instance
   * @param config.connectionString - MongoDB connection string for auto-initialization
   * @param config.databaseName - Database name (default: 'ag_kit_memory')
   * @param config.collectionName - Collection name for storing events (default: 'memory_events')
   * @param config.summaryCollectionName - Collection name for storing summaries (default: 'memory_summaries')
   * @param config.stateCollectionName - Collection name for storing session state (default: 'memory_state')
   * @param config.sessionId - Unique session identifier (default: 'default')
   * @param config.enableContextManagement - Whether to automatically manage context (default: true if thresholds provided)
   */
  constructor(config) {
    super(config);
    // Core database components
    this.db = null;
    if (!config.db && !config.connectionString) {
      throw new Error(
        "Either 'db' instance or 'connectionString' must be provided"
      );
    }
    this.sessionId = config.sessionId || "default";
    this.enableContextManagement = config.enableContextManagement ?? (config.thresholds ? true : false);
    if (config.db) {
      this.db = config.db;
      this._initializeManagers(config);
    }
  }
  /**
   * Initialize MongoDB connection and managers
   */
  async initialize(config) {
    if (this.db) {
      return;
    }
    if (!config.connectionString) {
      throw new Error("Connection string is required for initialization");
    }
    try {
      this.client = new import_mongodb.MongoClient(config.connectionString, {
        ...config.clientOptions
      });
      await this.client.connect();
      const databaseName = config.databaseName || "ag_kit_memory";
      this.db = this.client.db(databaseName);
      this._initializeManagers(config);
    } catch (error) {
      throw error;
    }
  }
  /**
   * Initialize all manager instances
   */
  _initializeManagers(config) {
    if (!this.db) {
      throw new Error("Database instance is required for initialization");
    }
    this.collectionManager = new MongoDBCollectionManager(
      this.db,
      config.collectionName || "memory_events",
      config.stateCollectionName || "memory_state",
      config.summaryCollectionName || "memory_summaries"
    );
    this.documentConverter = new DocumentConverter3();
    this.stateManager = new StateManager(this.collectionManager);
    this.cursorManager = new CursorManager(
      this.collectionManager,
      this.stateManager
    );
    this.branchManager = new BranchManager(
      this.collectionManager,
      this.stateManager,
      this.cursorManager
    );
    this.summaryManager = new SummaryManager(
      this.sessionId,
      this.collectionManager,
      this.cursorManager
    );
  }
  // ==================== CRUD Operations ====================
  /**
   * Add a single event to MongoDB database
   * @param event - The memory event to store
   * @param options - Optional session options
   */
  async add(event, options) {
    this.ensureInitialized();
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      if (!event.message.timestamp) {
        event.message.timestamp = /* @__PURE__ */ new Date();
      }
      const branchPath = await this.branchManager.getCurrentBranchPath(sid);
      const doc = this.documentConverter.toDocument(event, sid, branchPath);
      await adapter.insertOne(collection, doc);
    } catch (error) {
      console.error("Error adding event to MongoDB:", error);
      throw error;
    }
  }
  /**
   * Add multiple events efficiently
   * @param list - Array of memory events to store
   * @param options - Optional session options
   */
  async addList(list, options) {
    if (list.length === 0) return;
    for (const event of list) {
      await this.add(event, options);
    }
  }
  /**
   * Returns events from MongoDB database with filtering, pagination, and token limiting
   * Respects branch isolation using branch path and snapshot time
   * @param options - Optional filtering and pagination options
   * @returns Promise resolving to filtered array of memory events
   */
  async list(options) {
    this.ensureInitialized();
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      const currentBranchPath = await this.branchManager.getCurrentBranchPath(sid);
      const branchConditions = await this.branchManager.buildBranchConditions(
        sid,
        currentBranchPath
      );
      const startCursor = await this.cursorManager.getStartCursor(sid);
      let conditions = branchConditions;
      if (startCursor) {
        conditions = this.branchManager.applyCursorCondition(
          conditions,
          startCursor
        );
      }
      let whereCondition;
      if (conditions.length > 1) {
        const orBuilder = adapter.createQueryBuilder();
        const conditionBuilders = conditions.map((cond) => {
          const builder = adapter.createQueryBuilder();
          Object.entries(cond).forEach(([field, value]) => {
            builder.where(field, "eq", value);
          });
          return builder;
        });
        whereCondition = orBuilder.or(conditionBuilders).build();
      } else {
        whereCondition = conditions[0];
      }
      const order = options?.order || "asc";
      const queryOptions = {
        sort: { createdAt: order === "asc" ? 1 : -1 }
      };
      if (options?.offset) {
        queryOptions.skip = options.offset;
      }
      if (options?.limit) {
        queryOptions.limit = options.limit;
      }
      const result = await adapter.find(
        collection,
        whereCondition,
        queryOptions
      );
      let events = (order === "desc" ? result.reverse() : result).map(
        (doc) => this.documentConverter.fromDocument(doc)
      );
      if (this.enableContextManagement && events.length > 0) {
        const res = await this.manageContext({ sessionId: sid, events });
        events = res.events;
      }
      if (options?.maxTokens) {
        events = this.tokenTrimmer.trimMessages(events, options.maxTokens);
      }
      return events;
    } catch (error) {
      console.error("Error listing events from MongoDB:", error);
      throw error;
    }
  }
  /**
   * Update an event in MongoDB database
   * @param params - Update parameters
   */
  async update(params) {
    this.ensureInitialized();
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = params.sessionId || this.sessionId;
      const { event } = params;
      const currentBranchPath = await this.branchManager.getCurrentBranchPath(sid);
      const document = this.documentConverter.toDocument(
        event,
        sid,
        currentBranchPath
      );
      await adapter.updateOne(
        collection,
        { sessionId: sid, messageId: event.message.id },
        document
      );
    } catch (error) {
      console.error("Error updating event in MongoDB:", error);
      throw error;
    }
  }
  /**
   * Delete an event from MongoDB database
   * @param messageId - Message ID (string) to delete
   * @param options - Optional session options
   */
  async delete(messageId) {
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = this.sessionId;
      await adapter.deleteOne(collection, {
        sessionId: sid,
        messageId
      });
    } catch (error) {
      console.error("Error deleting event from MongoDB:", error);
      throw error;
    }
  }
  /**
   * Clear all events from MongoDB database
   * @param options - Optional session options. If sessionId provided, clears only that session using soft delete.
   */
  async clear(options) {
    this.ensureInitialized();
    try {
      const collection = this.collectionManager.getCollection();
      const stateCollection = this.collectionManager.getStateCollection();
      const summaryCollection = this.collectionManager.getSummaryCollection();
      if (options?.sessionId) {
        const sid = options.sessionId;
        const adapter = this.collectionManager.getAdapter();
        const result = await adapter.find(
          collection,
          { sessionId: sid },
          { sort: { createdAt: -1 }, limit: 1 }
        );
        if (result.length > 0) {
          const lastEvent = result[0];
          await this.cursorManager.setStartCursor(sid, lastEvent.createdAt);
        }
        await adapter.deleteMany(summaryCollection, { sessionId: sid });
      } else {
        const adapter = this.collectionManager.getAdapter();
        await adapter.deleteMany(collection, {});
        await adapter.deleteMany(stateCollection, {});
        await adapter.deleteMany(summaryCollection, {});
      }
      this.stateManager.clearCache();
    } catch (error) {
      console.error("Error clearing events from MongoDB:", error);
      throw error;
    }
  }
  /**
   * Check if the session contains any events (respecting soft delete)
   * @param options - Optional session options
   * @returns Promise resolving to true if no events are stored
   */
  async isEmpty(options) {
    return await this.getCount(options) === 0;
  }
  /**
   * Get the current number of events stored in the session (respecting soft delete)
   * @param options - Optional session options
   * @returns Promise resolving to the count of stored events
   */
  async getCount(options) {
    this.ensureInitialized();
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      const currentBranchPath = await this.branchManager.getCurrentBranchPath(sid);
      const branchConditions = await this.branchManager.buildBranchConditions(
        sid,
        currentBranchPath
      );
      const startCursor = await this.cursorManager.getStartCursor(sid);
      let conditions = branchConditions;
      if (startCursor) {
        conditions = this.branchManager.applyCursorCondition(
          conditions,
          startCursor
        );
      }
      let whereCondition;
      if (conditions.length > 1) {
        const orBuilder = adapter.createQueryBuilder();
        const conditionBuilders = conditions.map((cond) => {
          const builder = adapter.createQueryBuilder();
          Object.entries(cond).forEach(([field, value]) => {
            builder.where(field, "eq", value);
          });
          return builder;
        });
        whereCondition = orBuilder.or(conditionBuilders).build();
      } else {
        whereCondition = conditions[0];
      }
      const count = await adapter.count(collection, whereCondition);
      return count;
    } catch (error) {
      console.error("Error getting count from MongoDB:", error);
      throw error;
    }
  }
  // ==================== Search Operations ====================
  /**
   * Retrieve events using content-based search
   * @param query - Search query text to match against message content
   * @param options - Optional session options
   * @returns Promise resolving to array of matching events
   */
  async retrieve(query, options) {
    this.ensureInitialized();
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      const startCursor = await this.cursorManager.getStartCursor(sid);
      const queryBuilder = adapter.createQueryBuilder().where("sessionId", "eq", sid).regex("content", query, "i");
      if (startCursor) {
        queryBuilder.and("createdAt", "gt", startCursor);
      }
      const whereCondition = queryBuilder.build();
      const result = await adapter.find(
        collection,
        whereCondition
      );
      return result.map(
        (doc) => this.documentConverter.fromDocument(doc)
      );
    } catch (error) {
      console.error("Error retrieving events from MongoDB:", error);
      throw error;
    }
  }
  // ==================== Summary Operations ====================
  /**
   * Get summaries for a session
   * @param sessionId - Optional session identifier
   * @returns Array of structured summaries
   */
  async getSummaries(sessionId) {
    const summaries = await this.summaryManager.getSummaries(sessionId);
    return summaries.map((doc) => ({
      content: doc.content,
      count: 1,
      // Default count since BaseSummaryDocument doesn't have count
      timeRange: {
        start: doc.metadata?.timeRangeStart,
        end: doc.metadata?.timeRangeEnd
      },
      timestamp: doc.createdAt
    }));
  }
  /**
   * Store summary implementation
   * @param params - Summary storage parameters
   */
  async storeSummary(params) {
    const summaryId = `summary_${Date.now()}`;
    const metadata = {
      count: params.summary.count,
      timeRangeStart: params.summary.timeRange.start,
      timeRangeEnd: params.summary.timeRange.end
    };
    return this.summaryManager.addSummary(
      summaryId,
      params.summary.content,
      metadata,
      params.sessionId
    );
  }
  /**
   * Clear summarized events implementation using soft delete
   * Sets cursor to hide old events without actually deleting them
   * @param params - Clear parameters
   */
  async clearSummarizedEvents(params) {
    return this.summaryManager.clearSummarizedEvents(params);
  }
  // ==================== Branch Management ====================
  /**
   * Create a new branch from current session state
   * @param branchName - Name for the new branch
   * @param fromEventId - Optional event ID to branch from
   * @returns Promise resolving to branch ID
   */
  async branch(branchName, fromEventId) {
    return this.branchManager.createBranch(
      this.sessionId,
      branchName,
      fromEventId,
      () => this.list({ sessionId: this.sessionId })
    );
  }
  /**
   * Switch to a different branch or checkout to a specific event
   * @param target - Branch name or event ID to checkout
   * @param options - Optional configuration
   */
  async checkout(target, options) {
    const sid = options?.sessionId || this.sessionId;
    const checkoutType = options?.type || await this.branchManager.detectCheckoutType(sid, target);
    if (checkoutType === "event") {
      await this.branchManager.checkoutToEvent(sid, target);
    } else {
      await this.branchManager.checkoutBranch(sid, target);
    }
  }
  /**
   * Delete a branch
   * @param branchName - Name of the branch to delete
   */
  async deleteBranch(branchName) {
    return this.branchManager.deleteBranch(this.sessionId, branchName);
  }
  /**
   * List all branches
   * @returns Promise resolving to array of branch information
   */
  async listBranches() {
    const branches = await this.branchManager.listBranches(this.sessionId);
    const currentBranch = await this.getCurrentBranch();
    return branches.map((branch) => ({
      id: branch.name,
      name: branch.name,
      createdAt: branch.createdAt,
      fromEventId: branch.fromEventId,
      eventCount: 0,
      // TODO: Implement event count
      isActive: branch.name === currentBranch
    }));
  }
  /**
   * Get current branch name
   * @returns Promise resolving to current branch name
   */
  async getCurrentBranch() {
    return this.branchManager.getCurrentBranch(this.sessionId);
  }
  /**
   * Clean up branches, keeping only specified branches and the current active branch
   * @param keepBranches - Optional list of branch names to keep (in addition to active branch)
   */
  async cleanupBranches(keepBranches) {
    return this.branchManager.cleanupBranches(this.sessionId, keepBranches);
  }
  // ==================== Utility Methods ====================
  /**
   * Close MongoDB connection (if managed by this instance)
   */
  async close() {
    if (this.client) {
      try {
        await this.client.close();
      } catch (error) {
        console.error("Error closing MongoDB connection:", error);
        throw error;
      }
    }
  }
  /**
   * Check if MongoDB connection is ready
   */
  isReady() {
    return !!this.db;
  }
  /**
   * Get database instance (for advanced usage)
   */
  getDatabase() {
    if (!this.db) {
      throw new Error("MongoDB not initialized. Call initialize() first.");
    }
    return this.db;
  }
  /**
   * Ensure MongoDB is initialized before operations
   */
  ensureInitialized() {
    if (!this.db) {
      throw new Error(
        "MongoDB not initialized. Call initialize() first or provide db in constructor."
      );
    }
  }
};

// src/core/storage/memory/mysql/mysql-memory.ts
var import_typeorm5 = require("typeorm");

// src/core/storage/memory/typeorm/typeorm-memory.ts
var import_typeorm4 = require("typeorm");

// src/core/storage/memory/typeorm/typeorm-query-builder.ts
var TypeORMQueryBuilder = class _TypeORMQueryBuilder {
  constructor() {
    this.conditions = [];
    this.parameters = {};
    this.paramCounter = 0;
    this.orConditions = [];
  }
  where(field, operator, value) {
    return this.addCondition(field, operator, value);
  }
  and(field, operator, value) {
    return this.addCondition(field, operator, value);
  }
  or(conditions) {
    this.orConditions = conditions.map((builder) => {
      const built = builder.build();
      if (built.__typeorm_query__) {
        return {
          where: built.where,
          parameters: built.parameters
        };
      }
      return built;
    });
    return this;
  }
  in(field, values) {
    const paramName = `param_${this.paramCounter++}`;
    this.conditions.push(`entity.${field} IN (:...${paramName})`);
    this.parameters[paramName] = values;
    return this;
  }
  regex(field, pattern, options) {
    const paramName = `param_${this.paramCounter++}`;
    const likePattern = pattern.replace(/\.\*/g, "%").replace(/\./g, "_").replace(/^\^/, "").replace(/\$$/, "");
    this.conditions.push(`entity.${field} LIKE :${paramName}`);
    this.parameters[paramName] = likePattern;
    return this;
  }
  clone() {
    const cloned = new _TypeORMQueryBuilder();
    cloned.conditions = [...this.conditions];
    cloned.parameters = { ...this.parameters };
    cloned.paramCounter = this.paramCounter;
    cloned.orConditions = [...this.orConditions];
    return cloned;
  }
  build() {
    if (this.orConditions.length > 0) {
      const allParameters = { ...this.parameters };
      let globalParamCounter = this.paramCounter;
      const orClauses = [];
      for (const orCondition of this.orConditions) {
        if (orCondition.where && orCondition.parameters) {
          let whereClause = orCondition.where;
          for (const [oldParam, value] of Object.entries(
            orCondition.parameters
          )) {
            const newParam = `param_${globalParamCounter++}`;
            whereClause = whereClause.replace(
              new RegExp(`:${oldParam}\\b`, "g"),
              `:${newParam}`
            );
            allParameters[newParam] = value;
          }
          orClauses.push(`(${whereClause})`);
        }
      }
      let finalWhere = "";
      if (this.conditions.length > 0) {
        finalWhere = this.conditions.join(" AND ");
        if (orClauses.length > 0) {
          finalWhere += ` AND (${orClauses.join(" OR ")})`;
        }
      } else if (orClauses.length > 0) {
        finalWhere = orClauses.join(" OR ");
      }
      return {
        __typeorm_query__: true,
        where: finalWhere,
        parameters: allParameters
      };
    }
    if (this.conditions.length === 0) {
      return {};
    }
    return {
      __typeorm_query__: true,
      where: this.conditions.join(" AND "),
      parameters: this.parameters
    };
  }
  // Helper method to add conditions based on operator
  addCondition(field, operator, value) {
    const paramName = `param_${this.paramCounter++}`;
    switch (operator) {
      case "eq":
        this.conditions.push(`entity.${field} = :${paramName}`);
        break;
      case "ne":
        this.conditions.push(`entity.${field} != :${paramName}`);
        break;
      case "gt":
        this.conditions.push(`entity.${field} > :${paramName}`);
        break;
      case "gte":
        this.conditions.push(`entity.${field} >= :${paramName}`);
        break;
      case "lt":
        this.conditions.push(`entity.${field} < :${paramName}`);
        break;
      case "lte":
        this.conditions.push(`entity.${field} <= :${paramName}`);
        break;
      case "in":
        this.conditions.push(`entity.${field} IN (:...${paramName})`);
        break;
      case "nin":
        this.conditions.push(`entity.${field} NOT IN (:...${paramName})`);
        break;
      case "LIKE":
      case "like":
        this.conditions.push(`entity.${field} LIKE :${paramName}`);
        break;
      case "ILIKE":
      case "ilike":
        this.conditions.push(`LOWER(entity.${field}) LIKE LOWER(:${paramName})`);
        break;
      default:
        this.conditions.push(`entity.${field} = :${paramName}`);
    }
    this.parameters[paramName] = value;
    return this;
  }
};
var TypeORMUpdateBuilder = class {
  constructor() {
    this.updates = {};
  }
  set(field, value) {
    this.updates[field] = value;
    return this;
  }
  setMultiple(updates) {
    Object.assign(this.updates, updates);
    return this;
  }
  unset(field) {
    this.updates[field] = null;
    return this;
  }
  increment(field, value) {
    console.warn("Increment operations require special handling in TypeORM");
    this.updates[field] = value;
    return this;
  }
  build() {
    return { $set: this.updates };
  }
};

// src/core/storage/memory/typeorm/typeorm-adapter.ts
var TypeORMAdapter = class {
  /**
   * Get collection (for TypeORM, this is handled by CollectionManager)
   * This method is required by IDatabaseAdapter but not used directly
   */
  getCollection(name) {
    throw new Error("getCollection should not be called directly on TypeORMAdapter. Use TypeORMCollectionManager instead.");
  }
  /**
   * Find documents using TypeORM repository
   */
  async find(repository, query, options) {
    if (this.isComplexQuery(query)) {
      return this.handleComplexQuery(repository, query, options);
    } else if (Array.isArray(query)) {
      return this.handleArrayQuery(repository, query, options);
    } else {
      return this.handleSimpleQuery(repository, query, options);
    }
  }
  /**
   * Check if query is a complex query from our query builder
   */
  isComplexQuery(query) {
    return query && query.__typeorm_query__;
  }
  /**
   * Handle complex queries with custom where clauses
   */
  async handleComplexQuery(repository, query, options) {
    let queryBuilder = repository.createQueryBuilder("entity");
    queryBuilder = queryBuilder.where(query.where, query.parameters);
    this.applyQueryOptions(queryBuilder, options);
    return await queryBuilder.getMany();
  }
  /**
   * Handle array queries (OR conditions)
   */
  async handleArrayQuery(repository, query, options) {
    const hasComplexQuery = query.some((q) => this.isComplexQuery(q));
    if (hasComplexQuery) {
      return this.handleComplexArrayQuery(repository, query, options);
    } else {
      return this.handleSimpleArrayQuery(repository, query, options);
    }
  }
  /**
   * Handle array queries containing complex queries
   */
  async handleComplexArrayQuery(repository, query, options) {
    let queryBuilder = repository.createQueryBuilder("entity");
    const { whereClause, parameters } = this.buildOrConditions(query);
    if (whereClause) {
      queryBuilder = queryBuilder.where(whereClause, parameters);
    }
    this.applyQueryOptions(queryBuilder, options);
    return await queryBuilder.getMany();
  }
  /**
   * Build OR conditions from mixed query array
   */
  buildOrConditions(queries) {
    const orConditions = [];
    const allParameters = {};
    let paramCounter = 0;
    for (const q of queries) {
      if (this.isComplexQuery(q)) {
        const { clause, params } = this.processComplexCondition(q, paramCounter);
        orConditions.push(`(${clause})`);
        Object.assign(allParameters, params);
        paramCounter += Object.keys(params).length;
      } else {
        const { clause, params } = this.processSimpleCondition(q, paramCounter);
        if (clause) {
          orConditions.push(`(${clause})`);
          Object.assign(allParameters, params);
          paramCounter += Object.keys(params).length;
        }
      }
    }
    return {
      whereClause: orConditions.join(" OR "),
      parameters: allParameters
    };
  }
  /**
   * Process complex query condition
   */
  processComplexCondition(query, startParamCounter) {
    let whereClause = query.where;
    const params = {};
    let paramCounter = startParamCounter;
    if (query.parameters) {
      for (const [oldParam, value] of Object.entries(query.parameters)) {
        const newParam = `param_${paramCounter++}`;
        whereClause = whereClause.replace(
          new RegExp(`:${oldParam}\\b`, "g"),
          `:${newParam}`
        );
        params[newParam] = value;
      }
    }
    return { clause: whereClause, params };
  }
  /**
   * Process simple query condition
   */
  processSimpleCondition(query, startParamCounter) {
    const conditions = [];
    const params = {};
    let paramCounter = startParamCounter;
    for (const [field, value] of Object.entries(query)) {
      const paramName = `param_${paramCounter++}`;
      conditions.push(`entity.${field} = :${paramName}`);
      params[paramName] = value;
    }
    return {
      clause: conditions.join(" AND "),
      params
    };
  }
  /**
   * Handle simple array queries using TypeORM's built-in OR handling
   */
  async handleSimpleArrayQuery(repository, query, options) {
    const findOptions = { where: query };
    this.applyFindOptions(findOptions, options);
    return await repository.find(findOptions);
  }
  /**
   * Handle simple single queries
   */
  async handleSimpleQuery(repository, query, options) {
    const findOptions = { where: query };
    this.applyFindOptions(findOptions, options);
    return await repository.find(findOptions);
  }
  /**
   * Apply query options to QueryBuilder
   */
  applyQueryOptions(queryBuilder, options) {
    if (options?.sort) {
      Object.entries(options.sort).forEach(([field, direction]) => {
        queryBuilder.addOrderBy(`entity.${field}`, direction === 1 ? "ASC" : "DESC");
      });
    }
    if (options?.skip) {
      queryBuilder.skip(options.skip);
    }
    if (options?.limit) {
      queryBuilder.take(options.limit);
    }
  }
  /**
   * Apply query options to FindManyOptions
   */
  applyFindOptions(findOptions, options) {
    if (options?.sort) {
      findOptions.order = {};
      Object.entries(options.sort).forEach(([field, direction]) => {
        findOptions.order[field] = direction === 1 ? "ASC" : "DESC";
      });
    }
    if (options?.skip) {
      findOptions.skip = options.skip;
    }
    if (options?.limit) {
      findOptions.take = options.limit;
    }
  }
  /**
   * Find one document
   */
  async findOne(repository, query) {
    if (query && query.__typeorm_query__) {
      return await repository.createQueryBuilder("entity").where(query.where, query.parameters).getOne();
    } else {
      const findOptions = {
        where: query
      };
      return await repository.findOne(findOptions);
    }
  }
  /**
   * Insert one document
   */
  async insertOne(repository, document) {
    const entity = repository.create(document);
    return await repository.save(entity);
  }
  /**
   * Insert many documents
   */
  async insertMany(repository, documents) {
    const entities = repository.create(documents);
    const result = await repository.save(entities);
    return { insertedCount: Array.isArray(result) ? result.length : 1 };
  }
  /**
   * Update one document
   */
  async updateOne(repository, filter, update) {
    const updateData = update.$set || update;
    if (filter && filter.__typeorm_query__) {
      const whereClause = filter.where.replace(/entity\./g, "");
      const result = await repository.createQueryBuilder().update().set(updateData).where(whereClause, filter.parameters).execute();
      return { modifiedCount: result.affected || 0 };
    } else {
      const result = await repository.update(filter, updateData);
      return { modifiedCount: result.affected || 0 };
    }
  }
  /**
   * Delete one document
   */
  async deleteOne(repository, filter) {
    const result = await this.executeDelete(repository, filter);
    return { deletedCount: result.affected || 0 };
  }
  /**
   * Delete many documents
   */
  async deleteMany(repository, filter) {
    const result = await this.executeDelete(repository, filter);
    return { deletedCount: result.affected || 0 };
  }
  /**
   * Execute delete operation with proper query handling
   */
  async executeDelete(repository, filter) {
    if (!filter || Object.keys(filter).length === 0) {
      return await repository.createQueryBuilder().delete().execute();
    }
    if (Array.isArray(filter)) {
      const hasComplexQuery = filter.some((q) => this.isComplexQuery(q));
      if (hasComplexQuery) {
        const { whereClause, parameters } = this.buildOrConditions(filter);
        const deleteWhereClause = whereClause.replace(/entity\./g, "");
        return await repository.createQueryBuilder().delete().where(deleteWhereClause, parameters).execute();
      } else {
        let totalAffected = 0;
        for (const condition of filter) {
          const result = await repository.delete(condition);
          totalAffected += result.affected || 0;
        }
        return { affected: totalAffected };
      }
    }
    if (filter && filter.__typeorm_query__) {
      const whereClause = filter.where.replace(/entity\./g, "");
      return await repository.createQueryBuilder().delete().where(whereClause, filter.parameters).execute();
    } else {
      return await repository.delete(filter);
    }
  }
  /**
   * Count documents
   */
  async count(repository, query) {
    if (query && query.__typeorm_query__) {
      return await repository.createQueryBuilder("entity").where(query.where, query.parameters).getCount();
    } else {
      return await repository.count({ where: query });
    }
  }
  /**
   * Create query builder
   */
  createQueryBuilder() {
    return new TypeORMQueryBuilder();
  }
  /**
   * Create update builder
   */
  createUpdateBuilder() {
    return new TypeORMUpdateBuilder();
  }
};

// src/core/storage/memory/typeorm/typeorm-collection-manager.ts
var TypeORMCollectionManager = class {
  constructor(dataSource, eventTableName = "memory_events", stateTableName = "memory_state", summaryTableName = "memory_summaries") {
    this.dataSource = dataSource;
    this.eventTableName = eventTableName;
    this.stateTableName = stateTableName;
    this.summaryTableName = summaryTableName;
    this.adapter = new TypeORMAdapter();
    this.eventRepository = dataSource.getRepository(eventTableName);
    this.stateRepository = dataSource.getRepository(stateTableName);
    this.summaryRepository = dataSource.getRepository(summaryTableName);
  }
  /**
   * Get main events collection/repository
   */
  getCollection() {
    return this.eventRepository;
  }
  /**
   * Get state collection/repository
   */
  getStateCollection() {
    return this.stateRepository;
  }
  /**
   * Get summary collection/repository
   */
  getSummaryCollection() {
    return this.summaryRepository;
  }
  /**
   * Get database instance
   */
  getDatabase() {
    return this.dataSource;
  }
  /**
   * Get database adapter
   */
  getAdapter() {
    return this.adapter;
  }
};

// src/core/storage/memory/typeorm/entities/memory-event.entity.ts
var import_reflect_metadata = require("reflect-metadata");
var import_typeorm = require("typeorm");
var MemoryEvent = class {
};
__decorateClass([
  (0, import_typeorm.PrimaryGeneratedColumn)("uuid")
], MemoryEvent.prototype, "_id", 2);
__decorateClass([
  (0, import_typeorm.Column)({ type: "varchar", length: 255 })
], MemoryEvent.prototype, "sessionId", 2);
__decorateClass([
  (0, import_typeorm.Column)({ type: "varchar", length: 255 })
], MemoryEvent.prototype, "messageId", 2);
__decorateClass([
  (0, import_typeorm.Column)({ type: "varchar", length: 500 })
], MemoryEvent.prototype, "branchPath", 2);
__decorateClass([
  (0, import_typeorm.Column)({ type: "varchar", length: 50 })
], MemoryEvent.prototype, "role", 2);
__decorateClass([
  (0, import_typeorm.Column)({ type: "text" })
], MemoryEvent.prototype, "content", 2);
__decorateClass([
  (0, import_typeorm.Column)({ type: "json", nullable: true })
], MemoryEvent.prototype, "toolCalls", 2);
__decorateClass([
  (0, import_typeorm.Column)({ type: "varchar", length: 255, nullable: true })
], MemoryEvent.prototype, "toolCallId", 2);
__decorateClass([
  (0, import_typeorm.Column)({ type: "json" })
], MemoryEvent.prototype, "state", 2);
__decorateClass([
  (0, import_typeorm.CreateDateColumn)()
], MemoryEvent.prototype, "createdAt", 2);
__decorateClass([
  (0, import_typeorm.UpdateDateColumn)()
], MemoryEvent.prototype, "updatedAt", 2);
MemoryEvent = __decorateClass([
  (0, import_typeorm.Entity)("memory_events"),
  (0, import_typeorm.Index)("IDX_SESSION_BRANCH", ["sessionId", "branchPath"]),
  (0, import_typeorm.Index)("IDX_SESSION_CREATED", ["sessionId", "createdAt"]),
  (0, import_typeorm.Index)("IDX_SESSION_MESSAGE", ["sessionId", "messageId"])
], MemoryEvent);
function createMemoryEventEntity(tableName = "memory_events") {
  let CustomMemoryEvent = class extends MemoryEvent {
  };
  CustomMemoryEvent = __decorateClass([
    (0, import_typeorm.Entity)(tableName),
    (0, import_typeorm.Index)("IDX_SESSION_BRANCH", ["sessionId", "branchPath"]),
    (0, import_typeorm.Index)("IDX_SESSION_CREATED", ["sessionId", "createdAt"]),
    (0, import_typeorm.Index)("IDX_SESSION_MESSAGE", ["sessionId", "messageId"])
  ], CustomMemoryEvent);
  return CustomMemoryEvent;
}

// src/core/storage/memory/typeorm/entities/memory-state.entity.ts
var import_reflect_metadata2 = require("reflect-metadata");
var import_typeorm2 = require("typeorm");
var MemoryState = class {
};
__decorateClass([
  (0, import_typeorm2.PrimaryGeneratedColumn)("uuid")
], MemoryState.prototype, "_id", 2);
__decorateClass([
  (0, import_typeorm2.Column)({ type: "varchar", length: 255, unique: true })
], MemoryState.prototype, "sessionId", 2);
__decorateClass([
  (0, import_typeorm2.Column)({ type: "varchar", length: 500, default: "main" })
], MemoryState.prototype, "currentBranch", 2);
__decorateClass([
  (0, import_typeorm2.Column)({ type: "datetime", nullable: true })
], MemoryState.prototype, "startCursor", 2);
__decorateClass([
  (0, import_typeorm2.Column)({ type: "json" })
], MemoryState.prototype, "branches", 2);
__decorateClass([
  (0, import_typeorm2.CreateDateColumn)()
], MemoryState.prototype, "createdAt", 2);
__decorateClass([
  (0, import_typeorm2.UpdateDateColumn)()
], MemoryState.prototype, "updatedAt", 2);
MemoryState = __decorateClass([
  (0, import_typeorm2.Entity)("memory_state"),
  (0, import_typeorm2.Index)("IDX_STATE_SESSION", ["sessionId"])
], MemoryState);
function createMemoryStateEntity(tableName = "memory_state") {
  let CustomMemoryState = class extends MemoryState {
  };
  CustomMemoryState = __decorateClass([
    (0, import_typeorm2.Entity)(tableName),
    (0, import_typeorm2.Index)("IDX_STATE_SESSION", ["sessionId"])
  ], CustomMemoryState);
  return CustomMemoryState;
}

// src/core/storage/memory/typeorm/entities/memory-summary.entity.ts
var import_reflect_metadata3 = require("reflect-metadata");
var import_typeorm3 = require("typeorm");
var MemorySummary = class {
};
__decorateClass([
  (0, import_typeorm3.PrimaryGeneratedColumn)("uuid")
], MemorySummary.prototype, "_id", 2);
__decorateClass([
  (0, import_typeorm3.Column)({ type: "varchar", length: 255 })
], MemorySummary.prototype, "sessionId", 2);
__decorateClass([
  (0, import_typeorm3.Column)({ type: "varchar", length: 255 })
], MemorySummary.prototype, "summaryId", 2);
__decorateClass([
  (0, import_typeorm3.Column)({ type: "text" })
], MemorySummary.prototype, "content", 2);
__decorateClass([
  (0, import_typeorm3.Column)({ type: "json", nullable: true })
], MemorySummary.prototype, "metadata", 2);
__decorateClass([
  (0, import_typeorm3.CreateDateColumn)()
], MemorySummary.prototype, "createdAt", 2);
__decorateClass([
  (0, import_typeorm3.UpdateDateColumn)()
], MemorySummary.prototype, "updatedAt", 2);
MemorySummary = __decorateClass([
  (0, import_typeorm3.Entity)("memory_summaries"),
  (0, import_typeorm3.Index)("IDX_SUMMARY_SESSION", ["sessionId"]),
  (0, import_typeorm3.Index)("IDX_SUMMARY_ID", ["sessionId", "summaryId"])
], MemorySummary);
function createMemorySummaryEntity(tableName = "memory_summaries") {
  let CustomMemorySummary = class extends MemorySummary {
  };
  CustomMemorySummary = __decorateClass([
    (0, import_typeorm3.Entity)(tableName),
    (0, import_typeorm3.Index)("IDX_SUMMARY_SESSION", ["sessionId"]),
    (0, import_typeorm3.Index)("IDX_SUMMARY_ID", ["sessionId", "summaryId"])
  ], CustomMemorySummary);
  return CustomMemorySummary;
}

// src/core/storage/memory/typeorm/typeorm-memory.ts
var TypeORMMemory = class extends BaseMemory {
  /**
   * Creates a new TypeORMMemory instance
   * @param config - Configuration options
   * @param config.dataSource - TypeORM DataSource instance
   * @param config.eventTableName - Table name for storing events (default: 'memory_events')
   * @param config.summaryTableName - Table name for storing summaries (default: 'memory_summaries')
   * @param config.stateTableName - Table name for storing session state (default: 'memory_state')
   * @param config.sessionId - Unique session identifier (default: 'default')
   * @param config.enableContextManagement - Whether to automatically manage context (default: true if thresholds provided)
   */
  constructor(config) {
    super(config);
    if (!config.dataSource) {
      throw new Error("DataSource instance must be provided");
    }
    this.dataSource = config.dataSource;
    this.sessionId = config.sessionId || "default";
    this.enableContextManagement = config.enableContextManagement ?? (config.thresholds ? true : false);
    this._initializationPromise = this._initialize(config);
  }
  /**
   * Initialize entities and managers asynchronously
   */
  async _initialize(config) {
    await this._initializeEntities(config);
    this._initializeManagers(config);
  }
  /**
   * Initialize entities based on table names and ensure DataSource uses them
   * This approach ensures that the same entity classes are used for both
   * DataSource registration and repository creation
   */
  async _initializeEntities(config) {
    const existingEntities = this.dataSource.options.entities || [];
    this.dataSource.setOptions({
      ...this.dataSource.options,
      entities: existingEntities?.length ? existingEntities : [
        createMemoryEventEntity(config.eventTableName),
        createMemoryStateEntity(config.stateTableName),
        createMemorySummaryEntity(config.summaryTableName)
      ]
    });
    if (this.dataSource.isInitialized) {
      this.dataSource.buildMetadatas();
      if (this.dataSource.options.synchronize) {
        try {
          await this.dataSource.synchronize();
        } catch (error) {
          console.warn("Failed to synchronize database schema:", error);
        }
      }
    }
  }
  /**
   * Initialize all manager instances
   */
  _initializeManagers(config) {
    if (!this.dataSource) {
      throw new Error("DataSource instance is required for initialization");
    }
    this.collectionManager = new TypeORMCollectionManager(
      this.dataSource,
      config.eventTableName || "memory_events",
      config.stateTableName || "memory_state",
      config.summaryTableName || "memory_summaries"
    );
    this.documentConverter = config.documentConverter || new DocumentConverter3();
    this.stateManager = new StateManager(this.collectionManager);
    this.cursorManager = new CursorManager(
      this.collectionManager,
      this.stateManager
    );
    this.branchManager = new BranchManager(
      this.collectionManager,
      this.stateManager,
      this.cursorManager
    );
    this.summaryManager = new SummaryManager(
      this.sessionId,
      this.collectionManager,
      this.cursorManager
    );
  }
  // ==================== CRUD Operations ====================
  /**
   * Add a single event to TypeORM database
   * @param event - The memory event to store
   * @param options - Optional session options
   */
  async add(event, options) {
    await this.ensureInitialized();
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      if (!event.message.timestamp) {
        event.message.timestamp = /* @__PURE__ */ new Date();
      }
      const branchPath = await this.branchManager.getCurrentBranchPath(sid);
      const doc = this.documentConverter.toDocument(event, sid, branchPath);
      await adapter.insertOne(collection, doc);
    } catch (error) {
      console.error("Error adding event to TypeORM:", error);
      throw error;
    }
  }
  /**
   * Add multiple events efficiently
   * @param list - Array of memory events to store
   * @param options - Optional session options
   */
  async addList(list, options) {
    if (list.length === 0) return;
    for (const event of list) {
      await this.add(event, options);
    }
  }
  /**
   * Returns events from TypeORM database with filtering, pagination, and token limiting
   * Respects branch isolation using branch path and snapshot time
   * @param options - Optional filtering and pagination options
   * @returns Promise resolving to filtered array of memory events
   */
  async list(options) {
    await this.ensureInitialized();
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      const currentBranchPath = await this.branchManager.getCurrentBranchPath(sid);
      const branchConditions = await this.branchManager.buildBranchConditions(
        sid,
        currentBranchPath
      );
      const startCursor = await this.cursorManager.getStartCursor(sid);
      let conditions = branchConditions;
      if (startCursor) {
        conditions = this.branchManager.applyCursorCondition(
          conditions,
          startCursor
        );
      }
      let whereCondition;
      if (conditions.length > 1) {
        whereCondition = conditions;
      } else {
        whereCondition = conditions[0];
      }
      const order = options?.order || "asc";
      const queryOptions = {
        sort: { createdAt: order === "asc" ? 1 : -1 }
      };
      if (options?.offset) {
        queryOptions.skip = options.offset;
      }
      if (options?.limit) {
        queryOptions.limit = options.limit;
      }
      const result = await adapter.find(
        collection,
        whereCondition,
        queryOptions
      );
      let events = (order === "desc" ? result.reverse() : result).map(
        (doc) => this.documentConverter.fromDocument(doc)
      );
      if (this.enableContextManagement && events.length > 0) {
        const res = await this.manageContext({ sessionId: sid, events });
        events = res.events;
      }
      if (options?.maxTokens) {
        events = this.tokenTrimmer.trimMessages(events, options.maxTokens);
      }
      return events;
    } catch (error) {
      console.error("Error listing events from TypeORM:", error);
      throw error;
    }
  }
  /**
   * Update an event in TypeORM database
   * @param params - Update parameters
   */
  async update(params) {
    await this.ensureInitialized();
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = params.sessionId || this.sessionId;
      const query = adapter.createQueryBuilder().where("sessionId", "eq", sid).and("messageId", "eq", params.event.message.id).build();
      const doc = await adapter.findOne(collection, query);
      if (!doc) {
        throw new Error(
          `Event with messageId '${params.event.message.id}' not found in session '${sid}'`
        );
      }
      const branchPath = await this.branchManager.getCurrentBranchPath(sid);
      const updateDoc = this.documentConverter.toDocument(
        params.event,
        sid,
        branchPath
      );
      const update = adapter.createUpdateBuilder().setMultiple({
        ...updateDoc,
        updatedAt: /* @__PURE__ */ new Date()
      }).build();
      await adapter.updateOne(collection, query, update);
    } catch (error) {
      console.error("Error updating event in TypeORM:", error);
      throw error;
    }
  }
  /**
   * Delete an event from TypeORM database
   * @param idOrIndex - Message ID (string) to delete
   * @param options - Optional session options
   */
  async delete(idOrIndex, options) {
    await this.ensureInitialized();
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      if (typeof idOrIndex === "string") {
        const query = adapter.createQueryBuilder().where("sessionId", "eq", sid).and("messageId", "eq", idOrIndex).build();
        await adapter.deleteMany(collection, query);
      } else {
        console.warn(
          "Deleting by index is not efficient in TypeORM. Consider using message ID instead."
        );
        const events = await this.list({ sessionId: sid });
        if (idOrIndex >= 0 && idOrIndex < events.length) {
          const eventToDelete = events[idOrIndex];
          await this.delete(eventToDelete.message.id, options);
        }
      }
    } catch (error) {
      console.error("Error deleting event from TypeORM:", error);
      throw error;
    }
  }
  /**
   * Clear all events from TypeORM database
   * @param options - Optional session options. If sessionId provided, clears only that session using soft delete.
   */
  async clear(options) {
    await this.ensureInitialized();
    try {
      const collection = this.collectionManager.getCollection();
      const stateCollection = this.collectionManager.getStateCollection();
      const summaryCollection = this.collectionManager.getSummaryCollection();
      if (options?.sessionId) {
        const sid = options.sessionId;
        const adapter = this.collectionManager.getAdapter();
        const result = await adapter.find(
          collection,
          { sessionId: sid },
          { sort: { createdAt: -1 }, limit: 1 }
        );
        if (result.length > 0) {
          const lastEvent = result[0];
          await this.cursorManager.setStartCursor(sid, lastEvent.createdAt);
        }
        await adapter.deleteMany(summaryCollection, { sessionId: sid });
      } else {
        const adapter = this.collectionManager.getAdapter();
        await adapter.deleteMany(collection, {});
        await adapter.deleteMany(stateCollection, {});
        await adapter.deleteMany(summaryCollection, {});
      }
      this.stateManager.clearCache();
    } catch (error) {
      console.error("Error clearing events from TypeORM:", error);
      throw error;
    }
  }
  /**
   * Check if the session contains any events (respecting soft delete)
   * @param options - Optional session options
   * @returns Promise resolving to true if no events are stored
   */
  async isEmpty(options) {
    return await this.getCount(options) === 0;
  }
  /**
   * Get the current number of events stored in the session (respecting soft delete)
   * @param options - Optional session options
   * @returns Promise resolving to the count of stored events
   */
  async getCount(options) {
    await this.ensureInitialized();
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      const currentBranchPath = await this.branchManager.getCurrentBranchPath(sid);
      const branchConditions = await this.branchManager.buildBranchConditions(
        sid,
        currentBranchPath
      );
      const startCursor = await this.cursorManager.getStartCursor(sid);
      let conditions = branchConditions;
      if (startCursor) {
        conditions = this.branchManager.applyCursorCondition(
          conditions,
          startCursor
        );
      }
      let whereCondition;
      if (conditions.length > 1) {
        whereCondition = conditions;
      } else {
        whereCondition = conditions[0];
      }
      const count = await adapter.count(collection, whereCondition);
      return count;
    } catch (error) {
      console.error("Error getting count from TypeORM:", error);
      return 0;
    }
  }
  // ==================== Search Operations ====================
  /**
   * Retrieve events using content-based search
   * @param query - Search query text to match against message content
   * @param options - Optional session options
   * @returns Promise resolving to array of matching events
   */
  async retrieve(query, options) {
    await this.ensureInitialized();
    try {
      const collection = this.collectionManager.getCollection();
      const adapter = this.collectionManager.getAdapter();
      const sid = options?.sessionId || this.sessionId;
      const startCursor = await this.cursorManager.getStartCursor(sid);
      const queryBuilder = new TypeORMQueryBuilder();
      queryBuilder.where("sessionId", "=", sid).and("content", "ILIKE", `%${query}%`);
      if (startCursor) {
        queryBuilder.and("createdAt", ">", startCursor);
      }
      const result = await adapter.find(
        collection,
        queryBuilder.build()
      );
      return result.map(
        (doc) => this.documentConverter.fromDocument(doc)
      );
    } catch (error) {
      console.error("Error retrieving events from TypeORM:", error);
      throw error;
    }
  }
  // ==================== Summary Operations ====================
  /**
   * Get summaries for a session
   * @param sessionId - Optional session identifier
   * @returns Array of structured summaries
   */
  async getSummaries(sessionId) {
    const summaries = await this.summaryManager.getSummaries(sessionId);
    return summaries.map((doc) => ({
      content: doc.content,
      count: 1,
      // Default count since BaseSummaryDocument doesn't have count
      timeRange: {
        start: doc.metadata?.timeRangeStart,
        end: doc.metadata?.timeRangeEnd
      },
      timestamp: doc.createdAt
    }));
  }
  /**
   * Store summary implementation
   * @param params - Summary storage parameters
   */
  async storeSummary(params) {
    const summaryId = `summary_${Date.now()}`;
    const metadata = {
      count: params.summary.count,
      timeRangeStart: params.summary.timeRange.start,
      timeRangeEnd: params.summary.timeRange.end
    };
    return this.summaryManager.addSummary(
      summaryId,
      params.summary.content,
      metadata,
      params.sessionId
    );
  }
  /**
   * Clear summarized events implementation using soft delete
   * Sets cursor to hide old events without actually deleting them
   * @param params - Clear parameters
   */
  async clearSummarizedEvents(params) {
    return this.summaryManager.clearSummarizedEvents(params);
  }
  // ==================== Branch Management ====================
  /**
   * Create a new branch from current session state
   * @param branchName - Name for the new branch
   * @param fromEventId - Optional event ID to branch from
   * @returns Promise resolving to branch ID
   */
  async branch(branchName, fromEventId) {
    await this.ensureInitialized();
    return this.branchManager.createBranch(
      this.sessionId,
      branchName,
      fromEventId,
      () => this.list({ sessionId: this.sessionId })
    );
  }
  /**
   * Switch to a different branch or checkout to a specific event
   * @param target - Branch name or event ID to checkout
   * @param options - Optional configuration
   */
  async checkout(target, options) {
    await this.ensureInitialized();
    const sid = options?.sessionId || this.sessionId;
    const checkoutType = options?.type || await this.branchManager.detectCheckoutType(sid, target);
    if (checkoutType === "event") {
      const collection = this.collectionManager.getCollection();
      const event = await this.cursorManager.getEventByMessageId(sid, target);
      const adapter = this.collectionManager.getAdapter();
      if (!event) {
        throw new Error(`Event '${target}' not found in session '${sid}'`);
      }
      const currentBranchPath = await this.branchManager.getCurrentBranchPath(sid);
      let conditions = await this.branchManager.buildBranchConditions(
        sid,
        currentBranchPath
      );
      conditions = this.branchManager.applyCursorCondition(
        conditions,
        event.createdAt
      );
      let whereCondition;
      if (conditions.length > 1) {
        whereCondition = conditions;
      } else {
        whereCondition = conditions[0];
      }
      await adapter.deleteMany(collection, whereCondition);
    } else {
      await this.branchManager.checkoutBranch(sid, target);
    }
  }
  /**
   * Delete a branch
   * @param branchName - Name of the branch to delete
   */
  async deleteBranch(branchName) {
    await this.ensureInitialized();
    return this.branchManager.deleteBranch(this.sessionId, branchName);
  }
  /**
   * List all branches
   * @returns Promise resolving to array of branch information
   */
  async listBranches() {
    await this.ensureInitialized();
    const branches = await this.branchManager.listBranches(this.sessionId);
    const currentBranch = await this.getCurrentBranch();
    return branches.map((branch) => ({
      id: branch.name,
      name: branch.name,
      createdAt: branch.createdAt,
      fromEventId: branch.fromEventId,
      eventCount: 0,
      // TODO: Implement event count
      isActive: branch.name === currentBranch
    }));
  }
  /**
   * Get current branch name
   * @returns Promise resolving to current branch name
   */
  async getCurrentBranch() {
    await this.ensureInitialized();
    return this.branchManager.getCurrentBranch(this.sessionId);
  }
  /**
   * Clean up branches, keeping only specified branches and the current active branch
   * @param keepBranches - Optional list of branch names to keep (in addition to active branch)
   */
  async cleanupBranches(keepBranches) {
    await this.ensureInitialized();
    return this.branchManager.cleanupBranches(this.sessionId, keepBranches);
  }
  // ==================== Utility Methods ====================
  /**
   * Check if TypeORM connection is ready
   */
  isReady() {
    return !!this.dataSource && this.dataSource.isInitialized;
  }
  /**
   * Close TypeORM DataSource connection and clean up resources
   * This method should be called when the memory instance is no longer needed
   * to properly release database connections and prevent connection leaks
   * 
   * @throws Error if there's an issue closing the connection
   * 
   * @example
   * ```typescript
   * const memory = new TypeORMMemory({ dataSource, sessionId: 'test' });
   * // ... use memory
   * await memory.close(); // Clean up when done
   * ```
   */
  async close() {
    if (this.dataSource && this.dataSource.isInitialized) {
      try {
        await this.dataSource.destroy();
      } catch (error) {
        console.error("Error closing TypeORM DataSource connection:", error);
        throw error;
      }
    }
  }
  /**
   * Get DataSource instance (for advanced usage)
   */
  getDataSource() {
    if (!this.dataSource) {
      throw new Error("TypeORM DataSource not initialized.");
    }
    return this.dataSource;
  }
  /**
   * Ensure TypeORM is initialized before operations
   */
  async ensureInitialized() {
    await this._initializationPromise;
    if (!this.dataSource) {
      throw new Error("DataSource instance is required");
    }
    if (!this.dataSource.isInitialized) {
      try {
        await this.dataSource.initialize();
      } catch (error) {
        console.error("Failed to initialize DataSource:", error);
        throw error;
      }
    }
    if (!this.collectionManager) {
      throw new Error("TypeORMMemory not properly initialized");
    }
  }
  /**
   * Create a TypeORM DataSource configuration
   */
  static createDataSource(config) {
    const baseConfig = {
      type: config.type,
      synchronize: config.synchronize ?? false,
      logging: config.logging ?? false,
      entities: [],
      migrations: [],
      subscribers: []
    };
    if (config.type === "sqlite") {
      baseConfig.database = config.filename || ":memory:";
    } else {
      baseConfig.host = config.host;
      baseConfig.port = config.port;
      baseConfig.username = config.username;
      baseConfig.password = config.password;
      baseConfig.database = config.database;
    }
    return new import_typeorm4.DataSource(baseConfig);
  }
};

// src/core/storage/memory/mysql/mysql-memory.ts
var MySQLMemory = class _MySQLMemory extends TypeORMMemory {
  /**
   * Creates a new MySQLMemory instance
   * @param config - MySQL-specific configuration options
   */
  constructor(config) {
    const dataSource = _MySQLMemory.createMySQLDataSource(config);
    super({ ...config, dataSource });
  }
  /**
   * Create a MySQL DataSource configuration with optimizations
   */
  static createMySQLDataSource(config) {
    const options = {
      // Use TypeORM's MysqlConnectionOptions as base
      ...config.connection,
      // Override required fields
      type: "mysql",
      // Use dynamic entity creation for table name customization
      entities: [
        createMemoryEventEntity(config.eventTableName || "memory_events"),
        createMemoryStateEntity(config.stateTableName || "memory_state"),
        createMemorySummaryEntity(
          config.summaryTableName || "memory_summaries"
        )
      ],
      synchronize: config.autoInitialize !== false,
      logging: config.enableLogging || false,
      // MySQL-specific optimizations with defaults
      charset: config.connection.charset || "utf8mb4",
      timezone: config.connection.timezone || "+00:00",
      // Enhanced extra options
      extra: {
        // Default MySQL optimizations
        supportBigNumbers: true,
        // 
        bigNumberStrings: true,
        multipleStatements: false,
        // Security: prevent SQL injection
        dateStrings: false,
        // Use proper Date objects
        // Merge with user-provided extra options
        ...config.connection.extra
      }
    };
    return new import_typeorm5.DataSource(options);
  }
  /**
   * Create a MySQL Memory instance with connection string
   *
   * @param connectionString - MySQL connection string (mysql://username:password@host:port/database)
   * @param sessionId - Session identifier for memory isolation
   * @param options - Additional configuration options
   * @returns MySQLMemory instance
   * 'custom_state',
   *   summaryTableName: 'custom_summaries',
   *   thresholds: {
   * @example
   * ```typescript
   * const memory = MySQLMemory.fromConnectionString(
   *   'mysql://user:pass@localhost:3306/mydb',
   *   'session-123',
   *   {
   *     thresholds: { maxTokens: 10000 },
   *     enableContextManagement: true
   *   }
   * );
   * ```
   */
  static fromConnectionString(connectionString, sessionId, options) {
    const url = new URL(connectionString);
    if (url.protocol !== "mysql:") {
      throw new Error(
        "Invalid MySQL connection string. Must start with 'mysql://'"
      );
    }
    const connection = {
      host: url.hostname,
      port: url.port ? parseInt(url.port) : 3306,
      username: url.username,
      password: url.password,
      database: url.pathname.slice(1)
      // Remove leading slash
    };
    return new _MySQLMemory({
      connection,
      sessionId,
      ...options
    });
  }
  /**
   * Create a MySQL Memory instance with simple configuration
   *
   * @param config - Simple configuration object
   * @returns MySQLMemory instance
   *
   * @example
   * ```typescript
   * const memory = MySQLMemory.create({
   *   host: 'localhost',
   *   port: 3306,
   *   username: 'root',
   *   password: 'password',
   *   database: 'myapp',
   *   sessionId: 'user-session-123'
   * });
   * ```
   */
  static create(config) {
    return new _MySQLMemory({
      connection: config.connection,
      sessionId: config.sessionId,
      eventTableName: config.eventTableName,
      stateTableName: config.stateTableName,
      summaryTableName: config.summaryTableName,
      autoInitialize: config.autoInitialize,
      enableContextManagement: config.enableContextManagement,
      thresholds: config.thresholds,
      tokenizer: config.tokenizer,
      summarizer: config.summarizer
    });
  }
  /**
   * Get MySQL-specific connection information
   * @returns Connection information object
   */
  getConnectionInfo() {
    const options = this.dataSource.options;
    return {
      host: options.host,
      port: options.port,
      database: options.database,
      username: options.username
    };
  }
};

// src/core/storage/memory/mysql/index.ts
var import_typeorm6 = require("typeorm");

// src/core/storage/memory/typeorm/index.ts
var import_typeorm7 = require("typeorm");

// src/core/storage/long-term-memory/long-term-memory-base.ts
var BaseLongTermMemory = class {
  /**
   * Creates a new BaseLongTermMemory instance
   * @param config - Configuration object for the memory implementation
   */
  constructor(config = {}) {
    this.config = {
      ...config
    };
  }
  // ==================== Helper Methods ====================
  /**
   * Generate a unique memory ID
   * Implementers can override this method to customize ID generation strategy
   * @returns Unique memory identifier string
   */
  generateMemoryId() {
    return `memory_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
};

// src/core/storage/long-term-memory/tdai-long-term-memory.ts
var TDAILongTermMemory = class extends BaseLongTermMemory {
  constructor(config) {
    super();
    this.client = config.client;
    this.sessionId = config.sessionId || "default";
  }
  /**
   * 
   */
  async record(memory) {
    try {
      await this.client.appendRecord({
        sessionId: this.sessionId,
        content: memory.content,
        strategy: memory.strategy
        // metadata: memory.metadata
      });
    } catch (error) {
      console.error("Error recording memory:", error);
      throw error;
    }
  }
  /**
   * 
   */
  async recordBatch(memories) {
    const promises = memories.map((memory) => this.record(memory));
    await Promise.all(promises);
  }
  /**
   * 
   */
  async retrieve(query) {
    try {
      const result = await this.client.queryRecords({
        sessionId: this.sessionId,
        limit: query.limit,
        offset: query.offset,
        orderBy: query.orderBy,
        where: query.where
      });
      return result.records.map((record) => ({
        id: record.record_id,
        strategy: record.strategy_name,
        content: record.record_content,
        createdAt: new Date(record.created_at),
        updatedAt: record.updated_at ? new Date(record.updated_at) : void 0,
        metadata: {
          // ...record.metadata,
          eventIds: record.event_ids
        }
      }));
    } catch (error) {
      console.error("Error retrieving memories:", error);
      return [];
    }
  }
  /**
   * 
   */
  async delete(recordId) {
    try {
      if (typeof recordId === "string") {
        await this.client.deleteRecord({
          sessionId: this.sessionId,
          recordId
        });
      } else {
        const memories = await this.retrieve(recordId);
        for (const memory of memories) {
          await this.client.deleteRecord({
            sessionId: this.sessionId,
            recordId: memory.id
          });
        }
      }
    } catch (error) {
      console.error("Error deleting memory:", error);
      throw error;
    }
  }
  /**
   * 
   */
  async update(memoryId, updates) {
    try {
      if (updates.content) {
        await this.client.updateRecord({
          sessionId: this.sessionId,
          recordId: memoryId,
          content: updates.content
        });
      }
      if (updates.strategy || updates.metadata) {
        const existing = await this.retrieve({
          where: { record_id: memoryId },
          limit: 1
        });
        if (existing.length > 0) {
          await this.delete(memoryId);
          const newMemory = {
            id: memoryId,
            strategy: updates.strategy || existing[0].strategy,
            content: updates.content || existing[0].content,
            createdAt: existing[0].createdAt,
            updatedAt: /* @__PURE__ */ new Date(),
            metadata: { ...existing[0].metadata, ...updates.metadata }
          };
          await this.record(newMemory);
        }
      }
    } catch (error) {
      console.error("Error updating memory:", error);
      throw error;
    }
  }
  /**
   * 
   */
  async semanticSearch(query, options) {
    try {
      const result = await this.client.searchRecords({
        content: query,
        sessionId: this.sessionId,
        strategies: options?.strategies,
        limit: options?.limit,
        orderBy: options?.orderBy,
        where: options?.where
      });
      return result.records.map((record) => ({
        id: record.record_id,
        strategy: record.strategy_name,
        content: record.record_content,
        createdAt: new Date(record.created_at),
        updatedAt: record.updated_at ? new Date(record.updated_at) : void 0,
        metadata: {
          eventIds: record.event_ids,
          score: record.score
        }
      }));
    } catch (error) {
      console.error("Error in semantic search:", error);
      return [];
    }
  }
  /**
   * 
   */
  async clear(strategy) {
    try {
      const query = strategy ? { strategies: [strategy] } : {};
      await this.delete(query);
    } catch (error) {
      console.error("Error clearing memories:", error);
      throw error;
    }
  }
  /**
   * 
   * TODO:  LLM 
   */
  async extractAndRecord(messages, context) {
    const extractedMemories = [];
    throw new Error("Memory extraction not implemented");
  }
  /**
   * 
   */
  async getRelatedMemories(memoryId, depth = 1) {
    try {
      const memory = await this.retrieve({
        where: { record_id: memoryId },
        limit: 1
      });
      if (memory.length === 0) {
        return [];
      }
      const targetMemory = memory[0];
      const relatedQuery = {
        content: targetMemory.content,
        limit: 10
      };
      const related = await this.retrieve(relatedQuery);
      return related.filter((m) => m.id !== memoryId);
    } catch (error) {
      console.error("Error getting related memories:", error);
      return [];
    }
  }
  /**
   * TODO: imply 
   * 
   * 
   * 
   */
  async consolidate() {
    throw new Error("Memory consolidation not implemented");
  }
};

// src/core/storage/long-term-memory/mem0-long-term-memory.ts
var import_mem0ai = require("mem0ai");
var Mem0LongTermMemory = class extends BaseLongTermMemory {
  constructor(config) {
    super(config);
    const { userId, agentId, appId, ...clientOptions } = config;
    this.client = new import_mem0ai.MemoryClient(clientOptions);
    this.defaultOptions = {
      user_id: config.userId,
      agent_id: config.agentId,
      app_id: config.appId
    };
  }
  /**
   * Record a new memory entity
   */
  async record(memory) {
    try {
      const messages = [
        {
          role: memory.role || "assistant",
          content: memory.content
        }
      ];
      const options = {
        ...this.defaultOptions,
        metadata: {
          ...memory.metadata,
          strategy: memory.strategy,
          id: memory.id
        }
      };
      const result = await this.client.add(messages, options);
      console.log(`Memory recorded successfully. Mem0 ID: ${result[0]?.id}`);
    } catch (error) {
      console.error("Error recording memory:", error);
      throw error;
    }
  }
  /**
   * Record multiple memories in batch
   */
  async recordBatch(memories) {
    try {
      for (const memory of memories) {
        await this.record(memory);
      }
      console.log(`Batch recorded ${memories.length} memories successfully`);
    } catch (error) {
      console.error("Error recording batch memories:", error);
      throw error;
    }
  }
  /**
   * Retrieve memories based on query
   */
  async retrieve(query) {
    try {
      const options = {
        ...this.defaultOptions,
        limit: query.limit,
        page: query.offset ? Math.floor(query.offset / (query.limit || 10)) + 1 : 1,
        page_size: query.limit,
        metadata: query.strategy ? { strategy: query.strategy } : void 0,
        filters: query.filters || {}
      };
      let memories;
      if (query.query) {
        memories = await this.client.search(query.query, options);
      } else {
        memories = await this.client.getAll(options);
      }
      return this.convertToMemoryEntities(memories);
    } catch (error) {
      console.error("Error retrieving memories:", error);
      throw error;
    }
  }
  /**
   * Delete memory by ID or query
   */
  async delete(memoryId) {
    try {
      if (typeof memoryId === "string") {
        await this.client.delete(memoryId);
        console.log(`Memory ${memoryId} deleted successfully`);
      } else {
        const memories = await this.retrieve(memoryId);
        for (const memory of memories) {
          await this.client.delete(memory.id);
        }
        console.log(`Deleted ${memories.length} memories matching query`);
      }
    } catch (error) {
      console.error("Error deleting memory:", error);
      throw error;
    }
  }
  /**
   * Update memory content or metadata
   */
  async update(memoryId, updates) {
    try {
      const updateData = {};
      if (updates.content) {
        updateData.text = updates.content;
      }
      if (updates.metadata || updates.strategy) {
        updateData.metadata = {
          ...updates.metadata,
          ...updates.strategy && { strategy: updates.strategy }
        };
      }
      await this.client.update(memoryId, updateData);
      console.log(`Memory ${memoryId} updated successfully`);
    } catch (error) {
      console.error("Error updating memory:", error);
      throw error;
    }
  }
  /**
   * Clear memories by strategy
   */
  async clear(strategy) {
    try {
      if (strategy) {
        const options = {
          ...this.defaultOptions,
          filters: { strategy }
        };
        await this.client.deleteAll(options);
        console.log(`Cleared memories with strategy: ${strategy}`);
      } else {
        await this.client.deleteAll(this.defaultOptions);
        console.log("Cleared all memories");
      }
    } catch (error) {
      console.error("Error clearing memories:", error);
      throw error;
    }
  }
  /**
   * Extract and record memories from conversation messages
   */
  async extractAndRecord(messages, context) {
    try {
      const mem0Messages = messages.map((msg) => ({
        role: msg.role || "user",
        content: typeof msg.content === "string" ? msg.content : JSON.stringify(msg.content)
      }));
      const options = {
        ...this.defaultOptions,
        user_id: context.userId || this.defaultOptions.user_id,
        agent_id: context.agentId || this.defaultOptions.agent_id,
        app_id: context.appId || this.defaultOptions.app_id,
        run_id: context.runId,
        metadata: context.metadata || {}
      };
      const extractedMemories = await this.client.add(mem0Messages, options);
      const memoryEntities = extractedMemories.map(
        (memory) => this.convertMem0ToMemoryEntity(memory)
      );
      return memoryEntities;
    } catch (error) {
      console.error("Error extracting memories:", error);
      throw error;
    }
  }
  /**
   * Semantic search using Mem0's intelligent search
   */
  async semanticSearch(query, options) {
    try {
      const searchOptions = {
        ...this.defaultOptions,
        limit: options?.limit || 10,
        threshold: options?.threshold || 0.7,
        rerank: true,
        enable_graph: true,
        filters: options?.filters || {},
        ...options?.strategy && {
          filters: {
            ...options.filters,
            strategy: options.strategy
          }
        }
      };
      const memories = await this.client.search(query, searchOptions);
      return this.convertToMemoryEntities(memories);
    } catch (error) {
      console.error("Error in semantic search:", error);
      throw error;
    }
  }
  /**
   * Get related memories using Mem0's graph-based relationships
   */
  async getRelatedMemories(memoryId, depth) {
    try {
      const originalMemory = await this.client.get(memoryId);
      if (!originalMemory.memory) {
        return [];
      }
      const searchOptions = {
        ...this.defaultOptions,
        limit: depth || 5,
        enable_graph: true,
        rerank: true,
        threshold: 0.6
      };
      const relatedMemories = await this.client.search(
        originalMemory.memory,
        searchOptions
      );
      const filteredMemories = relatedMemories.filter(
        (memory) => memory.id !== memoryId
      );
      return this.convertToMemoryEntities(filteredMemories);
    } catch (error) {
      console.error("Error getting related memories:", error);
      throw error;
    }
  }
  /**
   * Consolidate memories - Mem0 handles this automatically, but we can trigger it
   */
  async consolidate() {
    try {
      const allMemories = await this.client.getAll({
        ...this.defaultOptions,
        limit: 1e3
        // Get a large batch for consolidation
      });
      console.log(
        `Consolidation check completed for ${allMemories.length} memories`
      );
    } catch (error) {
      console.error("Error in consolidation:", error);
      throw error;
    }
  }
  /**
   * Get memory history for a specific memory
   */
  async getMemoryHistory(memoryId) {
    try {
      const history = await this.client.history(memoryId);
      return history;
    } catch (error) {
      console.error("Error getting memory history:", error);
      throw error;
    }
  }
  /**
   * Get all users (if available)
   */
  async getUsers() {
    try {
      return await this.client.users();
    } catch (error) {
      console.error("Error getting users:", error);
      throw error;
    }
  }
  /**
   * Provide feedback on a memory
   */
  async provideFeedback(memoryId, feedback, reason) {
    try {
      await this.client.feedback({
        memory_id: memoryId,
        feedback,
        feedback_reason: reason
      });
      console.log(`Feedback provided for memory ${memoryId}: ${feedback}`);
    } catch (error) {
      console.error("Error providing feedback:", error);
      throw error;
    }
  }
  /**
   * Test connection to Mem0
   */
  async ping() {
    try {
      await this.client.ping();
      console.log("Mem0 connection successful");
    } catch (error) {
      console.error("Error pinging Mem0:", error);
      throw error;
    }
  }
  // Private helper methods
  /**
   * Convert Mem0 Memory objects to MemoryEntity
   */
  convertToMemoryEntities(mem0Memories) {
    if (!mem0Memories || !Array.isArray(mem0Memories)) {
      return [];
    }
    return mem0Memories.map((memory) => this.convertMem0ToMemoryEntity(memory));
  }
  /**
   * Convert single Mem0 Memory to MemoryEntity
   */
  convertMem0ToMemoryEntity(memory) {
    return {
      id: memory.id,
      content: memory.memory || memory.data?.memory || "",
      strategy: memory.metadata?.strategy || "general",
      metadata: {
        ...memory.metadata,
        mem0_id: memory.id,
        categories: memory.categories,
        score: memory.score,
        hash: memory.hash,
        memory_type: memory.memory_type,
        owner: memory.owner,
        agent_id: memory.agent_id,
        app_id: memory.app_id,
        run_id: memory.run_id
      },
      createdAt: memory.created_at || /* @__PURE__ */ new Date(),
      updatedAt: memory.updated_at || /* @__PURE__ */ new Date()
    };
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AGKitAgent,
  AGKitError,
  Agent,
  AgentConfigSchema,
  AnthropicProvider,
  BaseLongTermMemory,
  BaseMemory,
  BaseModelProvider,
  CloudBaseMemory,
  ConfigValidator,
  ConfigurationError,
  ControlFlowConfigSchema,
  ControlFlowError,
  ConversationManager,
  ErrorCategory,
  ErrorContextBuilder,
  EventSystem,
  EventType,
  ExecutionError,
  FallbackModelStrategy,
  HumanApprovalRequiredError,
  HumanInTheLoopConfigSchema,
  InMemoryMemory,
  InvalidModelProviderError,
  InvalidModelResponseError,
  LoggingErrorHandler,
  Mem0LongTermMemory,
  MemoryClient,
  MemoryError,
  MemoryLimitError,
  MissingRequiredConfigError,
  ModelError,
  ModelProviderError,
  ModelProviderRegistry,
  ModelSettingsSchema,
  MongoDBMemory,
  MySQLMemory,
  NetworkError,
  OpenAIProvider,
  OptimizedEventSystem,
  Order,
  OutputConstraintSchema,
  OutputTypeSchema,
  ParamError,
  ProviderFactory,
  ProviderPresets,
  RateLimitError,
  RetryErrorHandler,
  RunOptionsSchema,
  RuntimeError,
  SchemaValidationError,
  StateConstraintSchema,
  StateError,
  TDAIException,
  TDAILongTermMemory,
  TDAIMemory,
  TiktokenTokenizer,
  TimeoutError,
  TokenLimitError,
  TokenTrimmer,
  ToolDefinitionSchema,
  ToolError,
  ToolExecutionError,
  ToolNotFoundError,
  ToolProxy,
  ToolValidationError,
  TypeChecker,
  TypeORMAdapter,
  TypeORMMemory,
  TypeORMQueryBuilder,
  TypeORMUpdateBuilder,
  ValidationError,
  configValidator,
  createAnthropicProvider,
  createAnthropicProviderFromEnv,
  createCompositeTool,
  createDefaultAnthropicProvider,
  createDefaultOpenAIProvider,
  createErrorContext,
  createLoggedTool,
  createOpenAIProvider,
  createOpenAIProviderFromEnv,
  createOptimizedEventSystem,
  createProviderFromApiKey,
  createProviderFromConfig,
  createRetryTool,
  createTimeoutTool,
  createTypeSafeOutput,
  createTypeSafeState,
  createTypedTool,
  isConfigurationError,
  isOutputConstraint,
  isRetryableError,
  isStateConstraint,
  isToolError,
  modelProviderRegistry,
  optimizedEventSystem,
  providerFactory,
  toAGUIAgent,
  typeChecker,
  validateAgentName,
  validateConfig,
  validateInstructions,
  validateModelProvider,
  validateOutput,
  validateState,
  validateTypes
});
//# sourceMappingURL=index.js.map