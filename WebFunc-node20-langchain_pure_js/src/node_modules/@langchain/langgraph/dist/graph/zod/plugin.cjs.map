{"version":3,"file":"plugin.cjs","names":["withLangGraph","z3","zd"],"sources":["../../../src/graph/zod/plugin.ts"],"sourcesContent":["import { z as zd } from \"zod\";\nimport { z as z3 } from \"zod/v3\";\nimport {\n  getInteropZodDefaultGetter,\n  InteropZodType,\n} from \"@langchain/core/utils/types\";\nimport { SchemaMeta, withLangGraph } from \"./meta.js\";\n\nconst metaSymbol = Symbol.for(\"langgraph-zod\");\n\ninterface ZodLangGraphTypes<T, Output> {\n  // Overload 1: with explicit reducer schema - captures input type from the schema\n  reducer<TReducerSchema extends { _output: unknown }>(\n    transform: (a: Output, arg: TReducerSchema[\"_output\"]) => Output,\n    options: TReducerSchema\n  ): T & { lg_reducer_schema: TReducerSchema };\n\n  // Overload 2: without reducer schema - uses Output as input type\n  reducer(\n    transform: (a: Output, arg: Output) => Output\n  ): T & { lg_reducer_schema: T };\n\n  metadata(payload: {\n    langgraph_nodes?: string[];\n    langgraph_type?: \"prompt\";\n\n    [key: string]: unknown;\n  }): T;\n}\n\ndeclare module \"zod\" {\n  interface ZodType<Output> {\n    /**\n     * @deprecated Using the langgraph zod plugin is deprecated and will be removed in future versions\n     * Consider upgrading to zod 4 and using the exported langgraph meta registry. {@link langgraphRegistry}\n     */\n    langgraph: ZodLangGraphTypes<this, Output>;\n  }\n}\n\ndeclare module \"zod/v3\" {\n  interface ZodType<Output> {\n    /**\n     * @deprecated Using the langgraph zod plugin is deprecated and will be removed in future versions\n     * Consider upgrading to zod 4 and using the exported langgraph meta registry. {@link langgraphRegistry}\n     */\n    langgraph: ZodLangGraphTypes<this, Output>;\n  }\n}\n\ninterface PluginGlobalType {\n  [metaSymbol]?: WeakSet<object>;\n}\n\nif (!(metaSymbol in globalThis)) {\n  (globalThis as PluginGlobalType)[metaSymbol] = new WeakSet();\n}\n\nfunction applyPluginPrototype(prototype: object) {\n  const cache = (globalThis as PluginGlobalType)[metaSymbol]!;\n  if (cache.has(prototype)) {\n    return; // Already applied\n  }\n\n  Object.defineProperty(prototype, \"langgraph\", {\n    get(this: InteropZodType) {\n      // Actual return type is provided by module augmentation\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      const zodThis = this;\n\n      return {\n        metadata(jsonSchemaExtra: SchemaMeta[\"jsonSchemaExtra\"]) {\n          return withLangGraph(zodThis, { jsonSchemaExtra });\n        },\n        reducer(\n          fn: (a: unknown, arg: unknown) => unknown,\n          schema?: InteropZodType\n        ) {\n          const defaultFn = getInteropZodDefaultGetter(zodThis);\n          return withLangGraph(zodThis, {\n            default: defaultFn,\n            reducer: { schema, fn },\n          });\n        },\n      };\n    },\n  });\n  cache.add(prototype);\n}\n\ntry {\n  applyPluginPrototype(z3.ZodType.prototype);\n  applyPluginPrototype(zd.ZodType.prototype);\n} catch (error) {\n  throw new Error(\n    \"Failed to extend Zod with LangGraph-related methods. This is most likely a bug, consider opening an issue and/or using `withLangGraph` to augment your Zod schema.\",\n    { cause: error }\n  );\n}\n"],"mappings":";;;;;;AAQA,MAAM,aAAa,OAAO,IAAI,gBAAgB;AA8C9C,IAAI,EAAE,cAAc,YAClB,CAAC,WAAgC,8BAAc,IAAI,SAAS;AAG9D,SAAS,qBAAqB,WAAmB;CAC/C,MAAM,QAAS,WAAgC;AAC/C,KAAI,MAAM,IAAI,UAAU,CACtB;AAGF,QAAO,eAAe,WAAW,aAAa,EAC5C,MAA0B;EAGxB,MAAM,UAAU;AAEhB,SAAO;GACL,SAAS,iBAAgD;AACvD,WAAOA,2BAAc,SAAS,EAAE,iBAAiB,CAAC;;GAEpD,QACE,IACA,QACA;AAEA,WAAOA,2BAAc,SAAS;KAC5B,qEAF2C,QAAQ;KAGnD,SAAS;MAAE;MAAQ;MAAI;KACxB,CAAC;;GAEL;IAEJ,CAAC;AACF,OAAM,IAAI,UAAU;;AAGtB,IAAI;AACF,sBAAqBC,SAAG,QAAQ,UAAU;AAC1C,sBAAqBC,MAAG,QAAQ,UAAU;SACnC,OAAO;AACd,OAAM,IAAI,MACR,sKACA,EAAE,OAAO,OAAO,CACjB"}