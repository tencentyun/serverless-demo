{"version":3,"file":"annotation.js","names":[],"sources":["../../src/graph/annotation.ts"],"sourcesContent":["import { RunnableLike } from \"../pregel/runnable_types.js\";\nimport { BaseChannel } from \"../channels/base.js\";\nimport { BinaryOperator, BinaryOperatorAggregate } from \"../channels/binop.js\";\nimport { LastValue } from \"../channels/last_value.js\";\n\nexport type SingleReducer<ValueType, UpdateType = ValueType> =\n  | {\n      reducer: BinaryOperator<ValueType, UpdateType>;\n      default?: () => ValueType;\n    }\n  | {\n      /**\n       * @deprecated Use `reducer` instead\n       */\n      value: BinaryOperator<ValueType, UpdateType>;\n      default?: () => ValueType;\n    }\n  | null;\n\nexport interface StateDefinition {\n  [key: string]: BaseChannel | (() => BaseChannel);\n}\n\ntype ExtractValueType<C> = C extends BaseChannel\n  ? C[\"ValueType\"]\n  : C extends () => BaseChannel\n  ? ReturnType<C>[\"ValueType\"]\n  : never;\n\ntype ExtractUpdateType<C> = C extends BaseChannel\n  ? C[\"UpdateType\"]\n  : C extends () => BaseChannel\n  ? ReturnType<C>[\"UpdateType\"]\n  : never;\n\nexport type StateType<SD extends StateDefinition> = {\n  [key in keyof SD]: ExtractValueType<SD[key]>;\n};\n\nexport type UpdateType<SD extends StateDefinition> = {\n  [key in keyof SD]?: ExtractUpdateType<SD[key]>;\n};\n\nexport type NodeType<SD extends StateDefinition> = RunnableLike<\n  StateType<SD>,\n  UpdateType<SD> | Partial<StateType<SD>>\n>;\n\n/** @ignore */\nexport interface AnnotationFunction {\n  <ValueType>(): LastValue<ValueType>;\n  <ValueType, UpdateType = ValueType>(\n    annotation: SingleReducer<ValueType, UpdateType>\n  ): BinaryOperatorAggregate<ValueType, UpdateType>;\n  Root: <S extends StateDefinition>(sd: S) => AnnotationRoot<S>;\n}\n\n/**\n * Should not be instantiated directly. See {@link Annotation}.\n */\nexport class AnnotationRoot<SD extends StateDefinition> {\n  lc_graph_name = \"AnnotationRoot\";\n\n  declare State: StateType<SD>;\n\n  declare Update: UpdateType<SD>;\n\n  declare Node: NodeType<SD>;\n\n  spec: SD;\n\n  constructor(s: SD) {\n    this.spec = s;\n  }\n}\n\n/**\n * Helper that instantiates channels within a StateGraph state.\n *\n * Can be used as a field in an {@link Annotation.Root} wrapper in one of two ways:\n * 1. **Directly**: Creates a channel that stores the most recent value returned from a node.\n * 2. **With a reducer**: Creates a channel that applies the reducer on a node's return value.\n *\n * @example\n * ```ts\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single string key named \"currentOutput\"\n * const SimpleAnnotation = Annotation.Root({\n *   currentOutput: Annotation<string>,\n * });\n *\n * const graphBuilder = new StateGraph(SimpleAnnotation);\n *\n * // A node in the graph that returns an object with a \"currentOutput\" key\n * // replaces the value in the state. You can get the state type as shown below:\n * const myNode = (state: typeof SimpleAnnotation.State) => {\n *   return {\n *     currentOutput: \"some_new_value\",\n *   };\n * }\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   ...\n *   .compile();\n * ```\n *\n * @example\n * ```ts\n * import { type BaseMessage, AIMessage } from \"@langchain/core/messages\";\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single key named \"messages\" that will\n * // combine a returned BaseMessage or arrays of BaseMessages\n * const AnnotationWithReducer = Annotation.Root({\n *   messages: Annotation<BaseMessage[]>({\n *     // Different types are allowed for updates\n *     reducer: (left: BaseMessage[], right: BaseMessage | BaseMessage[]) => {\n *       if (Array.isArray(right)) {\n *         return left.concat(right);\n *       }\n *       return left.concat([right]);\n *     },\n *     default: () => [],\n *   }),\n * });\n *\n * const graphBuilder = new StateGraph(AnnotationWithReducer);\n *\n * // A node in the graph that returns an object with a \"messages\" key\n * // will update the state by combining the existing value with the returned one.\n * const myNode = (state: typeof AnnotationWithReducer.State) => {\n *   return {\n *     messages: [new AIMessage(\"Some new response\")],\n *   };\n * };\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   ...\n *   .compile();\n * ```\n * @namespace\n * @property Root\n * Helper function that instantiates a StateGraph state. See {@link Annotation} for usage.\n */\nexport const Annotation: AnnotationFunction = function <\n  ValueType,\n  UpdateType = ValueType\n>(\n  annotation?: SingleReducer<ValueType, UpdateType>\n): BaseChannel<ValueType, UpdateType> {\n  if (annotation) {\n    return getChannel<ValueType, UpdateType>(annotation);\n  } else {\n    // @ts-expect-error - Annotation without reducer\n    return new LastValue<ValueType>();\n  }\n} as AnnotationFunction;\n\nAnnotation.Root = <S extends StateDefinition>(sd: S) => new AnnotationRoot(sd);\n\nexport function getChannel<V, U = V>(\n  reducer: SingleReducer<V, U>\n): BaseChannel<V, U> {\n  if (\n    typeof reducer === \"object\" &&\n    reducer &&\n    \"reducer\" in reducer &&\n    reducer.reducer\n  ) {\n    return new BinaryOperatorAggregate(reducer.reducer, reducer.default);\n  }\n  if (\n    typeof reducer === \"object\" &&\n    reducer &&\n    \"value\" in reducer &&\n    reducer.value\n  ) {\n    return new BinaryOperatorAggregate(reducer.value, reducer.default);\n  }\n  // @ts-expect-error - Annotation without reducer\n  return new LastValue<V>();\n}\n"],"mappings":";;;;;;;AA4DA,IAAa,iBAAb,MAAwD;CACtD,gBAAgB;CAQhB;CAEA,YAAY,GAAO;AACjB,OAAK,OAAO;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2EhB,MAAa,aAAiC,SAI5C,YACoC;AACpC,KAAI,WACF,QAAO,WAAkC,WAAW;KAGpD,QAAO,IAAI,WAAsB;;AAIrC,WAAW,QAAmC,OAAU,IAAI,eAAe,GAAG;AAE9E,SAAgB,WACd,SACmB;AACnB,KACE,OAAO,YAAY,YACnB,WACA,aAAa,WACb,QAAQ,QAER,QAAO,IAAI,wBAAwB,QAAQ,SAAS,QAAQ,QAAQ;AAEtE,KACE,OAAO,YAAY,YACnB,WACA,WAAW,WACX,QAAQ,MAER,QAAO,IAAI,wBAAwB,QAAQ,OAAO,QAAQ,QAAQ;AAGpE,QAAO,IAAI,WAAc"}