"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/core/constants.ts
var import_openinference_semantic_conventions, OtelSpanAttributes;
var init_constants = __esm({
  "src/core/constants.ts"() {
    "use strict";
    import_openinference_semantic_conventions = require("@arizeai/openinference-semantic-conventions");
    OtelSpanAttributes = {
      // OpenInference - re-export all standard conventions
      ...import_openinference_semantic_conventions.SemanticConventions,
      // AG-Kit Trace attributes (non-standard)
      TRACE_NAME: "trace.name",
      TRACE_TAGS: "trace.tags",
      TRACE_PUBLIC: "trace.public",
      TRACE_METADATA: "trace.metadata",
      TRACE_INPUT: "trace.input",
      TRACE_OUTPUT: "trace.output",
      // AG-Kit Observation attributes (non-standard)
      OBSERVATION_TYPE: "observation.type",
      OBSERVATION_LEVEL: "observation.level",
      OBSERVATION_STATUS_MESSAGE: "observation.status_message",
      OBSERVATION_INPUT: "observation.input",
      OBSERVATION_OUTPUT: "observation.output",
      OBSERVATION_METADATA: "observation.metadata",
      // AG-Kit LLM-specific (non-standard)
      LLM_COMPLETION_START_TIME: "llm.completion_start_time",
      LLM_MODEL_PARAMETERS: "llm.model_parameters",
      LLM_USAGE_DETAILS: "llm.usage_details",
      LLM_COST_DETAILS: "llm.cost_details",
      // AG-Kit Retriever-specific (non-standard)
      RETRIEVER_NAME: "retriever.name",
      RETRIEVER_QUERY: "retriever.query",
      RETRIEVER_INDEX_ID: "retriever.index_id",
      RETRIEVER_TOP_K: "retriever.top_k",
      // AG-Kit General (non-standard)
      ENVIRONMENT: "environment",
      RELEASE: "release",
      VERSION: "version"
    };
  }
});

// src/core/attributes.ts
function createTraceAttributes({
  name,
  userId,
  sessionId,
  version,
  release,
  input,
  output,
  metadata,
  tags,
  environment,
  public: isPublic
} = {}) {
  const attributes = {
    [OtelSpanAttributes.TRACE_NAME]: name,
    // Use OpenInference standard attributes for user and session
    [OtelSpanAttributes.USER_ID]: userId,
    [OtelSpanAttributes.SESSION_ID]: sessionId,
    [OtelSpanAttributes.VERSION]: version,
    [OtelSpanAttributes.RELEASE]: release,
    [OtelSpanAttributes.TRACE_INPUT]: _serialize(input),
    [OtelSpanAttributes.TRACE_OUTPUT]: _serialize(output),
    [OtelSpanAttributes.TRACE_TAGS]: tags,
    [OtelSpanAttributes.ENVIRONMENT]: environment,
    [OtelSpanAttributes.TRACE_PUBLIC]: isPublic,
    ..._flattenAndSerializeMetadata(metadata, OtelSpanAttributes.TRACE_METADATA)
  };
  return Object.fromEntries(
    Object.entries(attributes).filter(([_, v]) => v != null)
  );
}
function createObservationAttributes(type, attributes) {
  const {
    metadata,
    input,
    output,
    level,
    statusMessage,
    version,
    completionStartTime,
    model,
    modelParameters,
    usageDetails
  } = attributes;
  const otelAttributes = {
    [import_openinference_semantic_conventions2.SemanticConventions.OPENINFERENCE_SPAN_KIND]: type.toUpperCase(),
    [OtelSpanAttributes.OBSERVATION_TYPE]: type,
    [OtelSpanAttributes.OBSERVATION_LEVEL]: level,
    [OtelSpanAttributes.OBSERVATION_STATUS_MESSAGE]: statusMessage,
    [OtelSpanAttributes.VERSION]: version,
    // Use OpenInference input.value convention
    [import_openinference_semantic_conventions2.SemanticConventions.INPUT_VALUE]: _serialize(input),
    // Also set legacy agkit.observation.input for compatibility
    [OtelSpanAttributes.OBSERVATION_INPUT]: _serialize(input),
    // Use OpenInference output.value convention
    [import_openinference_semantic_conventions2.SemanticConventions.OUTPUT_VALUE]: _serialize(output),
    // Also set legacy agkit.observation.output for compatibility
    [OtelSpanAttributes.OBSERVATION_OUTPUT]: _serialize(output)
  };
  if (type === "llm") {
    if (model) {
      otelAttributes[import_openinference_semantic_conventions2.SemanticConventions.LLM_MODEL_NAME] = model;
    }
    if (modelParameters) {
      otelAttributes[import_openinference_semantic_conventions2.SemanticConventions.LLM_INVOCATION_PARAMETERS] = _serialize(modelParameters);
      otelAttributes[OtelSpanAttributes.LLM_MODEL_PARAMETERS] = _serialize(modelParameters);
    }
    if (usageDetails) {
      if (typeof usageDetails === "object") {
        const usage = usageDetails;
        if (usage.promptTokens !== void 0) {
          otelAttributes[import_openinference_semantic_conventions2.SemanticConventions.LLM_TOKEN_COUNT_PROMPT] = usage.promptTokens;
        }
        if (usage.completionTokens !== void 0) {
          otelAttributes[import_openinference_semantic_conventions2.SemanticConventions.LLM_TOKEN_COUNT_COMPLETION] = usage.completionTokens;
        }
        if (usage.totalTokens !== void 0) {
          otelAttributes[import_openinference_semantic_conventions2.SemanticConventions.LLM_TOKEN_COUNT_TOTAL] = usage.totalTokens;
        }
      }
      otelAttributes[OtelSpanAttributes.LLM_USAGE_DETAILS] = _serialize(usageDetails);
    }
    if (completionStartTime) {
      otelAttributes[OtelSpanAttributes.LLM_COMPLETION_START_TIME] = _serialize(completionStartTime);
    }
  }
  if (type === "embedding") {
    if (model) {
      otelAttributes[import_openinference_semantic_conventions2.SemanticConventions.EMBEDDING_MODEL_NAME] = model;
    }
    if (modelParameters) {
      otelAttributes[import_openinference_semantic_conventions2.SemanticConventions.LLM_INVOCATION_PARAMETERS] = _serialize(modelParameters);
    }
  }
  const metadataAttrs = _flattenAndSerializeMetadata(
    metadata,
    import_openinference_semantic_conventions2.SemanticConventions.METADATA
  );
  Object.assign(otelAttributes, metadataAttrs);
  const obsetvabilityMetadataAttrs = _flattenAndSerializeMetadata(
    metadata,
    OtelSpanAttributes.OBSERVATION_METADATA
  );
  Object.assign(otelAttributes, obsetvabilityMetadataAttrs);
  return Object.fromEntries(
    Object.entries(otelAttributes).filter(([_, v]) => v != null)
  );
}
function _serialize(obj) {
  try {
    if (typeof obj === "string") return obj;
    if (obj instanceof Date) return obj.toISOString();
    return obj != null ? JSON.stringify(obj) : void 0;
  } catch {
    return "<failed to serialize>";
  }
}
function _flattenAndSerializeMetadata(metadata, prefix) {
  const metadataAttributes = {};
  if (metadata === void 0 || metadata === null) {
    return metadataAttributes;
  }
  if (typeof metadata !== "object" || Array.isArray(metadata)) {
    const serialized = _serialize(metadata);
    if (serialized) {
      metadataAttributes[prefix] = serialized;
    }
  } else {
    for (const [key, value] of Object.entries(metadata)) {
      const serialized = typeof value === "string" ? value : _serialize(value);
      if (serialized) {
        metadataAttributes[`${prefix}.${key}`] = serialized;
      }
    }
  }
  return metadataAttributes;
}
var import_openinference_semantic_conventions2;
var init_attributes = __esm({
  "src/core/attributes.ts"() {
    "use strict";
    init_constants();
    import_openinference_semantic_conventions2 = require("@arizeai/openinference-semantic-conventions");
  }
});

// src/core/tracerProvider.ts
function createState() {
  return {
    isolatedTracerProvider: null
  };
}
function getObservabilityGlobalState() {
  const initialState = createState();
  try {
    const g = globalThis;
    if (typeof g !== "object" || g === null) {
      console.warn(
        "[Observability] globalThis is not available, using fallback state"
      );
      return initialState;
    }
    if (!g[OBSERVABILITY_GLOBAL_SYMBOL]) {
      Object.defineProperty(g, OBSERVABILITY_GLOBAL_SYMBOL, {
        value: initialState,
        writable: false,
        configurable: false,
        enumerable: false
      });
    }
    return g[OBSERVABILITY_GLOBAL_SYMBOL];
  } catch (err) {
    console.error(
      `[Observability] Failed to access global state: ${err instanceof Error ? err.message : String(err)}`
    );
    return initialState;
  }
}
function setTracerProvider(provider) {
  getObservabilityGlobalState().isolatedTracerProvider = provider;
}
function getTracerProvider() {
  const { isolatedTracerProvider } = getObservabilityGlobalState();
  if (isolatedTracerProvider) return isolatedTracerProvider;
  return import_api.trace.getTracerProvider();
}
function getTracer() {
  return getTracerProvider().getTracer(
    OBSERVABILITY_SDK_NAME,
    OBSERVABILITY_SDK_VERSION
  );
}
var import_api, OBSERVABILITY_GLOBAL_SYMBOL, OBSERVABILITY_SDK_NAME, OBSERVABILITY_SDK_VERSION;
var init_tracerProvider = __esm({
  "src/core/tracerProvider.ts"() {
    "use strict";
    import_api = require("@opentelemetry/api");
    OBSERVABILITY_GLOBAL_SYMBOL = /* @__PURE__ */ Symbol.for("observability");
    OBSERVABILITY_SDK_NAME = "ag-kit-observability";
    OBSERVABILITY_SDK_VERSION = "0.1.0";
  }
});

// src/core/spanWrapper.ts
var BaseObservation, ObservationSpan, ObservationLLM, ObservationEmbedding, ObservationAgent, ObservationTool, ObservationChain, ObservationRetriever, ObservationReranker, ObservationEvaluator, ObservationGuardrail;
var init_spanWrapper = __esm({
  "src/core/spanWrapper.ts"() {
    "use strict";
    init_attributes();
    init_tracerProvider();
    BaseObservation = class {
      /** The underlying OpenTelemetry span */
      otelSpan;
      /** The observation type */
      type;
      /** The span ID from the OpenTelemetry span context */
      id;
      /** The trace ID from the OpenTelemetry span context */
      traceId;
      constructor(params) {
        this.otelSpan = params.otelSpan;
        this.id = params.otelSpan.spanContext().spanId;
        this.traceId = params.otelSpan.spanContext().traceId;
        this.type = params.type;
        if (params.attributes) {
          this.otelSpan.setAttributes(
            createObservationAttributes(params.type, params.attributes)
          );
        }
      }
      /** Gets the AG-Kit OpenTelemetry tracer instance */
      get tracer() {
        return getTracer();
      }
      /**
       * Ends the observation, marking it as complete.
       *
       * @param endTime - Optional end time, defaults to current time
       */
      end(endTime) {
        this.otelSpan.end(endTime);
      }
      /**
       * Updates the OTEL span attributes.
       *
       * @param attributes - Attributes to update
       * @internal
       */
      updateOtelSpanAttributes(attributes) {
        this.otelSpan.setAttributes(
          createObservationAttributes(this.type, attributes)
        );
      }
      /**
       * Updates the parent trace with new attributes.
       *
       * @param attributes - Trace attributes to set
       * @returns This observation for method chaining
       */
      updateTrace(attributes) {
        this.otelSpan.setAttributes(createTraceAttributes(attributes));
        return this;
      }
      startObservation(name, attributes, options) {
        const { startObservation: startObs } = (init_src(), __toCommonJS(src_exports));
        const { asType = "span" } = options || {};
        return startObs(name, attributes, {
          asType,
          parentSpanContext: this.otelSpan.spanContext()
        });
      }
    };
    ObservationSpan = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "span" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationLLM = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "llm" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationEmbedding = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "embedding" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationAgent = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "agent" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationTool = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "tool" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationChain = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "chain" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationRetriever = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "retriever" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationReranker = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "reranker" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationEvaluator = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "evaluator" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationGuardrail = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "guardrail" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  ObservationAgent: () => ObservationAgent,
  ObservationChain: () => ObservationChain,
  ObservationEmbedding: () => ObservationEmbedding,
  ObservationEvaluator: () => ObservationEvaluator,
  ObservationGuardrail: () => ObservationGuardrail,
  ObservationLLM: () => ObservationLLM,
  ObservationReranker: () => ObservationReranker,
  ObservationRetriever: () => ObservationRetriever,
  ObservationSpan: () => ObservationSpan,
  ObservationTool: () => ObservationTool,
  createObservationAttributes: () => createObservationAttributes,
  createTraceAttributes: () => createTraceAttributes,
  getActiveSpanId: () => getActiveSpanId,
  getActiveTraceId: () => getActiveTraceId,
  getTracer: () => getTracer,
  getTracerProvider: () => getTracerProvider,
  observe: () => observe,
  setTracerProvider: () => setTracerProvider,
  startActiveObservation: () => startActiveObservation,
  startObservation: () => startObservation,
  updateActiveObservation: () => updateActiveObservation,
  updateActiveTrace: () => updateActiveTrace
});
function createOtelSpan(params) {
  return getTracer().startSpan(
    params.name,
    { startTime: params.startTime },
    createParentContext(params.parentSpanContext)
  );
}
function createParentContext(parentSpanContext) {
  if (!parentSpanContext) return;
  return import_api2.trace.setSpanContext(import_api2.context.active(), parentSpanContext);
}
function startObservation(name, attributes, options) {
  const { asType = "span", ...observationOptions } = options || {};
  const otelSpan = createOtelSpan({
    name,
    ...observationOptions
  });
  switch (asType) {
    case "llm":
      return new ObservationLLM({
        otelSpan,
        attributes
      });
    case "embedding":
      return new ObservationEmbedding({
        otelSpan,
        attributes
      });
    case "agent":
      return new ObservationAgent({
        otelSpan,
        attributes
      });
    case "tool":
      return new ObservationTool({
        otelSpan,
        attributes
      });
    case "chain":
      return new ObservationChain({
        otelSpan,
        attributes
      });
    case "retriever":
      return new ObservationRetriever({
        otelSpan,
        attributes
      });
    case "reranker":
      return new ObservationReranker({
        otelSpan,
        attributes
      });
    case "evaluator":
      return new ObservationEvaluator({
        otelSpan,
        attributes
      });
    case "guardrail":
      return new ObservationGuardrail({
        otelSpan,
        attributes
      });
    case "span":
    default:
      return new ObservationSpan({
        otelSpan,
        attributes
      });
  }
}
function updateActiveTrace(attributes) {
  const span = import_api2.trace.getActiveSpan();
  if (!span) {
    console.warn(
      "[Observability] No active OTEL span in context. Skipping trace update."
    );
    return;
  }
  span.setAttributes(createTraceAttributes(attributes));
}
function getActiveTraceId() {
  return import_api2.trace.getActiveSpan()?.spanContext().traceId;
}
function getActiveSpanId() {
  return import_api2.trace.getActiveSpan()?.spanContext().spanId;
}
function wrapPromise(promise, span, endOnExit) {
  return promise.then(
    (value) => {
      if (endOnExit !== false) {
        span.end();
      }
      return value;
    },
    (err) => {
      span.setStatus({
        code: import_api2.SpanStatusCode.ERROR,
        message: err instanceof Error ? err.message : "Unknown error"
      });
      if (endOnExit !== false) {
        span.end();
      }
      throw err;
    }
  );
}
function startActiveObservation(name, fn, options) {
  const { asType = "span", endOnExit, ...observationOptions } = options || {};
  return getTracer().startActiveSpan(
    name,
    { startTime: observationOptions?.startTime },
    createParentContext(observationOptions?.parentSpanContext) ?? import_api2.context.active(),
    (span) => {
      try {
        let observation;
        switch (asType) {
          case "llm":
            observation = new ObservationLLM({ otelSpan: span });
            break;
          case "embedding":
            observation = new ObservationEmbedding({ otelSpan: span });
            break;
          case "agent":
            observation = new ObservationAgent({ otelSpan: span });
            break;
          case "tool":
            observation = new ObservationTool({ otelSpan: span });
            break;
          case "chain":
            observation = new ObservationChain({ otelSpan: span });
            break;
          case "retriever":
            observation = new ObservationRetriever({ otelSpan: span });
            break;
          case "reranker":
            observation = new ObservationReranker({ otelSpan: span });
            break;
          case "evaluator":
            observation = new ObservationEvaluator({ otelSpan: span });
            break;
          case "guardrail":
            observation = new ObservationGuardrail({ otelSpan: span });
            break;
          case "span":
          default:
            observation = new ObservationSpan({ otelSpan: span });
        }
        const result = fn(observation);
        if (result instanceof Promise) {
          return wrapPromise(
            result,
            span,
            endOnExit
          );
        } else {
          if (endOnExit !== false) {
            span.end();
          }
          return result;
        }
      } catch (err) {
        span.setStatus({
          code: import_api2.SpanStatusCode.ERROR,
          message: err instanceof Error ? err.message : "Unknown error"
        });
        if (endOnExit !== false) {
          span.end();
        }
        throw err;
      }
    }
  );
}
function updateActiveObservation(attributes) {
  const span = import_api2.trace.getActiveSpan();
  if (!span) {
    console.warn(
      "[Observability] No active OTEL span in context. Skipping observation update."
    );
    return;
  }
  span.setAttributes(createObservationAttributes("span", attributes));
}
function _captureArguments(args) {
  if (args.length === 0) return {};
  if (args.length === 1) return { arg: args[0] };
  return { args };
}
function observe(fn, options = {}) {
  const {
    asType = "span",
    captureInput = true,
    captureOutput = true,
    ...observationOptions
  } = options;
  const wrappedFunction = function(...args) {
    const name = fn.name || "anonymous-function";
    const inputData = captureInput ? _captureArguments(args) : void 0;
    const observation = startObservation(
      name,
      inputData ? { input: inputData } : {},
      {
        ...observationOptions,
        asType
      }
    );
    const activeContext = import_api2.trace.setSpan(import_api2.context.active(), observation.otelSpan);
    const result = import_api2.context.with(activeContext, () => fn.apply(this, args));
    if (result instanceof Promise) {
      return result.then(
        (value) => {
          if (captureOutput) {
            observation.update({ output: value });
          }
          observation.end();
          return value;
        },
        (err) => {
          observation.update({
            level: "ERROR",
            statusMessage: err instanceof Error ? err.message : "Unknown error"
          });
          observation.end();
          throw err;
        }
      );
    }
    if (captureOutput) {
      observation.update({ output: result });
    }
    observation.end();
    return result;
  };
  Object.defineProperty(wrappedFunction, "name", { value: fn.name });
  Object.defineProperty(wrappedFunction, "length", { value: fn.length });
  return wrappedFunction;
}
var import_api2;
var init_src = __esm({
  "src/index.ts"() {
    "use strict";
    import_api2 = require("@opentelemetry/api");
    init_attributes();
    init_spanWrapper();
    init_tracerProvider();
    init_attributes();
    init_tracerProvider();
  }
});

// src/langchain/CallbackHandler.ts
var CallbackHandler_exports = {};
__export(CallbackHandler_exports, {
  CallbackHandler: () => CallbackHandler
});
module.exports = __toCommonJS(CallbackHandler_exports);
var import_base = require("@langchain/core/callbacks/base");
var import_messages = require("@langchain/core/messages");
init_src();
var import_agent_shared = require("@cloudbase/agent-shared");
var CallbackHandler = class extends import_base.BaseCallbackHandler {
  name = "ObservabilityCallbackHandler";
  userId;
  version;
  sessionId;
  tags;
  traceMetadata;
  completionStartTimes = {};
  promptToParentRunMap;
  runMap = /* @__PURE__ */ new Map();
  last_trace_id = null;
  // External parent context from AG-UI.Server span
  externalParentSpanContext;
  // Adapter name for ROOT span prefix
  adapterName;
  // Logger for debug output (defaults to noopLogger for silent operation)
  logger;
  constructor(params) {
    super();
    this.sessionId = params?.sessionId;
    this.userId = params?.userId;
    this.tags = params?.tags ?? [];
    this.traceMetadata = params?.traceMetadata;
    this.version = params?.version;
    this.adapterName = params?.adapterName;
    this.logger = params?.logger ?? import_agent_shared.noopLogger;
    this.promptToParentRunMap = /* @__PURE__ */ new Map();
  }
  /**
   * Set external parent SpanContext from AG-UI.Server span.
   * This allows the CallbackHandler to link LangChain/LangGraph spans
   * to the server-level span, creating a unified trace hierarchy.
   *
   * @param spanContext - SpanContext from the AG-UI.Server span
   * @public
   */
  setExternalParentContext(spanContext) {
    this.externalParentSpanContext = spanContext;
  }
  async handleLLMNewToken(token, _idx, runId, _parentRunId, _tags, _fields) {
    if (runId && !(runId in this.completionStartTimes)) {
      this.logger.debug?.(`LLM first streaming token: ${runId}`);
      this.completionStartTimes[runId] = /* @__PURE__ */ new Date();
    }
  }
  async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
    try {
      this.logger.debug?.(`Chain start with Id: ${runId}`);
      const runName = name ?? chain.id.at(-1)?.toString() ?? "Langchain Run";
      this.registerPromptInfo(parentRunId, metadata);
      let finalInput = inputs;
      if (typeof inputs === "object" && "input" in inputs && Array.isArray(inputs["input"]) && inputs["input"].every((m) => m instanceof import_messages.BaseMessage)) {
        finalInput = inputs["input"].map(
          (m) => this.extractChatMessageContent(m)
        );
      } else if (typeof inputs === "object" && "messages" in inputs && Array.isArray(inputs["messages"]) && inputs["messages"].every((m) => m instanceof import_messages.BaseMessage)) {
        finalInput = inputs["messages"].map(
          (m) => this.extractChatMessageContent(m)
        );
      } else if (typeof inputs === "object" && "content" in inputs && typeof inputs["content"] === "string") {
        finalInput = inputs["content"];
      }
      const observation = this.startAndRegisterObservation({
        runName,
        parentRunId,
        runId,
        tags,
        metadata,
        attributes: {
          input: finalInput
        },
        asType: "span"
      });
      const traceTags = [.../* @__PURE__ */ new Set([...tags ?? [], ...this.tags])];
      if (!parentRunId) {
        observation.updateTrace({
          tags: traceTags,
          userId: metadata && "userId" in metadata && typeof metadata["userId"] === "string" ? metadata["userId"] : this.userId,
          sessionId: metadata && "sessionId" in metadata && typeof metadata["sessionId"] === "string" ? metadata["sessionId"] : this.sessionId,
          metadata: this.traceMetadata,
          version: this.version
        });
      }
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleAgentAction(action, runId, parentRunId) {
    try {
      this.logger.debug?.(`Agent action ${action.tool} with ID: ${runId}`);
      this.startAndRegisterObservation({
        runId,
        parentRunId,
        runName: action.tool,
        attributes: {
          input: action
        },
        asType: "tool"
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleAgentEnd(action, runId, _parentRunId) {
    try {
      this.logger.debug?.(`Agent finish with ID: ${runId}`);
      this.handleObservationEnd({
        runId,
        attributes: { output: action }
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleChainError(err, runId, _parentRunId) {
    try {
      this.logger.debug?.(`Chain error: ${err} with ID: ${runId}`);
      this.handleObservationEnd({
        runId,
        attributes: {
          level: "ERROR",
          statusMessage: err.toString()
        }
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleGenerationStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
    this.logger.debug?.(
      `Generation start with ID: ${runId} and parentRunId ${parentRunId}`
    );
    const runName = name ?? llm.id.at(-1)?.toString() ?? "Langchain Generation";
    const modelParameters = {};
    const invocationParams = extraParams?.["invocation_params"];
    for (const [key, value] of Object.entries({
      temperature: invocationParams?.temperature,
      max_tokens: invocationParams?.max_tokens,
      top_p: invocationParams?.top_p,
      frequency_penalty: invocationParams?.frequency_penalty,
      presence_penalty: invocationParams?.presence_penalty,
      request_timeout: invocationParams?.request_timeout
    })) {
      if (value !== void 0 && value !== null) {
        modelParameters[key] = value;
      }
    }
    let extractedModelName;
    if (extraParams) {
      const invocationParamsModelName = extraParams.invocation_params.model;
      const metadataModelName = metadata && "ls_model_name" in metadata ? metadata["ls_model_name"] : void 0;
      extractedModelName = invocationParamsModelName ?? metadataModelName;
    }
    const registeredPrompt = this.promptToParentRunMap.get(
      parentRunId ?? "root"
    );
    if (registeredPrompt && parentRunId) {
      this.deregisterPromptInfo(parentRunId);
    }
    this.startAndRegisterObservation({
      runId,
      parentRunId,
      metadata,
      tags,
      runName,
      attributes: {
        input: messages,
        model: extractedModelName,
        modelParameters
      },
      asType: "llm"
    });
  }
  async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
    try {
      this.logger.debug?.(`Chat model start with ID: ${runId}`);
      const prompts = messages.flatMap(
        (message) => message.map((m) => this.extractChatMessageContent(m))
      );
      this.handleGenerationStart(
        llm,
        prompts,
        runId,
        parentRunId,
        extraParams,
        tags,
        metadata,
        name
      );
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleChainEnd(outputs, runId, _parentRunId) {
    try {
      this.logger.debug?.(`Chain end with ID: ${runId}`);
      let finalOutput = outputs;
      if (typeof outputs === "object" && "output" in outputs && typeof outputs["output"] === "string") {
        finalOutput = outputs["output"];
      } else if (typeof outputs === "object" && "messages" in outputs && Array.isArray(outputs["messages"]) && outputs["messages"].every((m) => m instanceof import_messages.BaseMessage)) {
        finalOutput = {
          messages: outputs.messages.map(
            (message) => this.extractChatMessageContent(message)
          )
        };
      }
      this.handleObservationEnd({
        runId,
        attributes: {
          output: finalOutput
        }
      });
      this.deregisterPromptInfo(runId);
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
    try {
      this.logger.debug?.(`LLM start with ID: ${runId}`);
      this.handleGenerationStart(
        llm,
        prompts,
        runId,
        parentRunId,
        extraParams,
        tags,
        metadata,
        name
      );
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
    try {
      this.logger.debug?.(`Tool start with ID: ${runId}`);
      this.startAndRegisterObservation({
        runId,
        parentRunId,
        runName: name ?? tool.id.at(-1)?.toString() ?? "Tool execution",
        attributes: {
          input
        },
        metadata,
        tags,
        asType: "tool"
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
    try {
      this.logger.debug?.(`Retriever start with ID: ${runId}`);
      this.startAndRegisterObservation({
        runId,
        parentRunId,
        runName: name ?? retriever.id.at(-1)?.toString() ?? "Retriever",
        attributes: {
          input: query
        },
        tags,
        metadata,
        asType: "span"
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleRetrieverEnd(documents, runId, _parentRunId) {
    try {
      this.logger.debug?.(`Retriever end with ID: ${runId}`);
      this.handleObservationEnd({
        runId,
        attributes: {
          output: documents
        }
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleRetrieverError(err, runId, _parentRunId) {
    try {
      this.logger.debug?.(`Retriever error: ${err} with ID: ${runId}`);
      this.handleObservationEnd({
        runId,
        attributes: {
          level: "ERROR",
          statusMessage: err.toString()
        }
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleToolEnd(output, runId, _parentRunId) {
    try {
      this.logger.debug?.(`Tool end with ID: ${runId}`);
      this.handleObservationEnd({
        runId,
        attributes: { output }
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleToolError(err, runId, _parentRunId) {
    try {
      this.logger.debug?.(`Tool error ${err} with ID: ${runId}`);
      this.handleObservationEnd({
        runId,
        attributes: {
          level: "ERROR",
          statusMessage: err.toString()
        }
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleLLMEnd(output, runId, _parentRunId) {
    try {
      this.logger.debug?.(`LLM end with ID: ${runId}`);
      const lastResponse = output.generations[output.generations.length - 1][output.generations[output.generations.length - 1].length - 1];
      const llmUsage = this.extractUsageMetadata(lastResponse) ?? output.llmOutput?.["tokenUsage"];
      const modelName = this.extractModelNameFromMetadata(lastResponse);
      const usageDetails = {
        input: llmUsage?.input_tokens ?? ("promptTokens" in llmUsage ? llmUsage?.promptTokens : void 0),
        output: llmUsage?.output_tokens ?? ("completionTokens" in llmUsage ? llmUsage?.completionTokens : void 0),
        total: llmUsage?.total_tokens ?? ("totalTokens" in llmUsage ? llmUsage?.totalTokens : void 0)
      };
      if (llmUsage && "input_token_details" in llmUsage) {
        for (const [key, val] of Object.entries(
          llmUsage["input_token_details"] ?? {}
        )) {
          usageDetails[`input_${key}`] = val;
          if ("input" in usageDetails && typeof val === "number") {
            usageDetails["input"] = Math.max(0, usageDetails["input"] - val);
          }
        }
      }
      if (llmUsage && "output_token_details" in llmUsage) {
        for (const [key, val] of Object.entries(
          llmUsage["output_token_details"] ?? {}
        )) {
          usageDetails[`output_${key}`] = val;
          if ("output" in usageDetails && typeof val === "number") {
            usageDetails["output"] = Math.max(0, usageDetails["output"] - val);
          }
        }
      }
      const extractedOutput = "message" in lastResponse ? this.extractChatMessageContent(
        lastResponse["message"]
      ) : lastResponse.text;
      this.handleObservationEnd({
        runId,
        attributes: {
          model: modelName,
          output: extractedOutput,
          completionStartTime: runId in this.completionStartTimes ? this.completionStartTimes[runId] : void 0,
          usageDetails
        }
      });
      if (runId in this.completionStartTimes) {
        delete this.completionStartTimes[runId];
      }
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleLLMError(err, runId, _parentRunId) {
    try {
      this.logger.debug?.(`LLM error ${err} with ID: ${runId}`);
      this.handleObservationEnd({
        runId,
        attributes: {
          level: "ERROR",
          statusMessage: err.toString()
        }
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  registerPromptInfo(parentRunId, metadata) {
    if (metadata && "promptInfo" in metadata && parentRunId) {
      this.promptToParentRunMap.set(
        parentRunId,
        metadata.promptInfo
      );
    }
  }
  deregisterPromptInfo(runId) {
    this.promptToParentRunMap.delete(runId);
  }
  startAndRegisterObservation(params) {
    const { runName, runId, parentRunId, attributes, metadata, tags, asType } = params;
    let parentSpanContext;
    if (parentRunId) {
      parentSpanContext = this.runMap.get(parentRunId)?.otelSpan.spanContext();
    } else if (this.externalParentSpanContext) {
      parentSpanContext = this.externalParentSpanContext;
    }
    let finalRunName = runName;
    if (!parentRunId && this.adapterName) {
      finalRunName = `Adapter.${this.adapterName}`;
    }
    const observation = startObservation(
      finalRunName,
      {
        version: this.version,
        metadata: this.joinTagsAndMetaData(tags, metadata),
        ...attributes
      },
      {
        asType: asType ?? "span",
        parentSpanContext
      }
    );
    this.runMap.set(runId, observation);
    return observation;
  }
  handleObservationEnd(params) {
    const { runId, attributes = {} } = params;
    const observation = this.runMap.get(runId);
    if (!observation) {
      this.logger.warn?.("Observation not found in runMap. Skipping operation.");
      return;
    }
    observation.update(attributes).end();
    this.last_trace_id = observation.traceId;
    this.runMap.delete(runId);
  }
  joinTagsAndMetaData(tags, metadata1, metadata2) {
    const finalDict = {};
    if (tags && tags.length > 0) {
      finalDict.tags = tags;
    }
    if (metadata1) {
      Object.assign(finalDict, metadata1);
    }
    if (metadata2) {
      Object.assign(finalDict, metadata2);
    }
    return this.stripObservabilityKeysFromMetadata(finalDict);
  }
  stripObservabilityKeysFromMetadata(metadata) {
    if (!metadata) {
      return;
    }
    const reservedKeys = ["promptInfo", "userId", "sessionId"];
    return Object.fromEntries(
      Object.entries(metadata).filter(([key, _]) => !reservedKeys.includes(key))
    );
  }
  extractUsageMetadata(generation) {
    try {
      const usageMetadata = "message" in generation && (import_messages.AIMessage.isInstance(generation["message"]) || import_messages.AIMessageChunk.isInstance(generation["message"])) ? generation["message"].usage_metadata : void 0;
      return usageMetadata;
    } catch (err) {
      this.logger.debug?.(`Error extracting usage metadata: ${err}`);
      return;
    }
  }
  extractModelNameFromMetadata(generation) {
    try {
      return "message" in generation && (import_messages.AIMessage.isInstance(generation["message"]) || import_messages.AIMessageChunk.isInstance(generation["message"])) ? generation["message"].response_metadata.model_name : void 0;
    } catch {
    }
  }
  extractChatMessageContent(message) {
    let response = void 0;
    if (message.getType() === "human") {
      response = { content: message.content, role: "user" };
    } else if (message.getType() === "generic") {
      response = {
        content: message.content,
        role: "human"
      };
    } else if (message.getType() === "ai") {
      response = { content: message.content, role: "assistant" };
      if ("tool_calls" in message && Array.isArray(message.tool_calls) && (message.tool_calls?.length ?? 0) > 0) {
        response["tool_calls"] = message["tool_calls"];
      }
      if ("additional_kwargs" in message && "tool_calls" in message["additional_kwargs"]) {
        response["tool_calls"] = message["additional_kwargs"]["tool_calls"];
      }
    } else if (message.getType() === "system") {
      response = { content: message.content, role: "system" };
    } else if (message.getType() === "function") {
      response = {
        content: message.content,
        additional_kwargs: message.additional_kwargs,
        role: message.name
      };
    } else if (message.getType() === "tool") {
      response = {
        content: message.content,
        additional_kwargs: message.additional_kwargs,
        role: message.name
      };
    } else if (!message.name) {
      response = { content: message.content };
    } else {
      response = {
        role: message.name,
        content: message.content
      };
    }
    if ((message.additional_kwargs.function_call || message.additional_kwargs.tool_calls) && response["tool_calls"] === void 0) {
      return { ...response, additional_kwargs: message.additional_kwargs };
    }
    return response;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  CallbackHandler
});
//# sourceMappingURL=langchain.js.map