var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { AI } from './AI';
import { Bot } from './bot';
import * as models from './models';
import * as utils from './utils';
var COMPONENT_NAME = 'ai';
var MODELS = models.MODELS, restModels = __rest(models, ["MODELS"]);
var createRequestInstanceWithAccessTokenHeader = function (_a) {
    var getAccessToken = _a.getAccessToken, req = _a.req;
    var fetch = function (options) { return __awaiter(void 0, void 0, void 0, function () {
        var token, _a, headers, restOptions, accessToken;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    if (typeof req.fetch !== 'function') {
                        throw new Error('req.fetch is not a function');
                    }
                    token = options.token, _a = options.headers, headers = _a === void 0 ? {} : _a, restOptions = __rest(options, ["token", "headers"]);
                    if (!(token != null)) return [3, 1];
                    accessToken = token;
                    return [3, 3];
                case 1: return [4, getAccessToken()];
                case 2:
                    accessToken = (_b.sent()).accessToken;
                    _b.label = 3;
                case 3: return [2, req.fetch(__assign({ headers: __assign({ Authorization: "Bearer ".concat(accessToken) }, headers) }, restOptions))];
            }
        });
    }); };
    return {
        download: req.download,
        post: req.post,
        upload: req.upload,
        fetch: fetch,
    };
};
function createAI(_a) {
    var env = _a.env, baseUrl = _a.baseUrl, req = _a.req, getAccessToken = _a.getAccessToken, handleReqInstance = _a.handleReqInstance, i18n = _a.i18n;
    var getBaseUrl = function () {
        if (baseUrl != null) {
            return baseUrl;
        }
        if (env == null) {
            throw new Error('`env` is required when `baseUrl` is not provided!');
        }
        return "https://".concat(env, ".api.tcloudbasegateway.com/v1");
    };
    var getReq = function () {
        if (handleReqInstance == null) {
            if (getAccessToken == null) {
                throw new Error('`getAccessToken` is required when `handleReqInstance` is not provided!');
            }
            return createRequestInstanceWithAccessTokenHeader({ req: req, getAccessToken: getAccessToken });
        }
        return handleReqInstance({ req: req });
    };
    return new AI(getReq(), getBaseUrl(), i18n);
}
var createAi = createAI;
function ai(options) {
    var _this = this;
    var _a;
    var req = this.request;
    if (req.fetch == null) {
        throw new Error('cloudbase.request.fetch() unimplemented!');
    }
    var getUrlFromCloud = function () {
        var _a = _this.getEndPointWithKey('GATEWAY'), BASE_URL = _a.BASE_URL, PROTOCOL = _a.PROTOCOL;
        return "".concat(PROTOCOL).concat(BASE_URL);
    };
    var baseUrl = (_a = options === null || options === void 0 ? void 0 : options.baseUrl) !== null && _a !== void 0 ? _a : getUrlFromCloud();
    return createAI({ req: req, baseUrl: baseUrl, handleReqInstance: function (_a) {
            var req = _a.req;
            return req;
        }, i18n: this.config.i18n });
}
var component = {
    name: COMPONENT_NAME,
    entity: { ai: ai },
};
function registerAi(app) {
    try {
        app.registerComponent(component);
    }
    catch (e) {
        console.warn(e);
    }
}
export { AI, Bot, createAi, createAI, restModels as models, registerAi, utils };
export * from './type';
try {
    window.registerAi = registerAi;
}
catch (e) { }
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUlBLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUE7QUFDekIsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLE9BQU8sQ0FBQTtBQUMzQixPQUFPLEtBQUssTUFBTSxNQUFNLFVBQVUsQ0FBQTtBQUNsQyxPQUFPLEtBQUssS0FBSyxNQUFNLFNBQVMsQ0FBQTtBQUVoQyxJQUFNLGNBQWMsR0FBRyxJQUFJLENBQUE7QUFFbkIsSUFBQSxNQUFNLEdBQW9CLE1BQU0sT0FBMUIsRUFBSyxVQUFVLFVBQUssTUFBTSxFQUFsQyxVQUF5QixDQUFGLENBQVc7QUFReEMsSUFBTSwwQ0FBMEMsR0FBRyxVQUFDLEVBR2tDO1FBRnBGLGNBQWMsb0JBQUEsRUFDZCxHQUFHLFNBQUE7SUFFSCxJQUFNLEtBQUssR0FBcUIsVUFBTyxPQUEyQzs7Ozs7b0JBQ2hGLElBQUksT0FBTyxHQUFHLENBQUMsS0FBSyxLQUFLLFVBQVUsRUFBRTt3QkFDbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsQ0FBQyxDQUFBO3FCQUMvQztvQkFFTyxLQUFLLEdBQW1DLE9BQU8sTUFBMUMsRUFBRSxLQUFpQyxPQUFPLFFBQTVCLEVBQVosT0FBTyxtQkFBRyxFQUFFLEtBQUEsRUFBSyxXQUFXLFVBQUssT0FBTyxFQUFqRCxvQkFBdUMsQ0FBRixDQUFZO3lCQUVuRCxDQUFBLEtBQUssSUFBSSxJQUFJLENBQUEsRUFBYixjQUFhO29CQUNmLFdBQVcsR0FBRyxLQUFLLENBQUE7O3dCQUVKLFdBQU0sY0FBYyxFQUFFLEVBQUE7O29CQUFyQyxXQUFXLEdBQUcsQ0FBQyxTQUFzQixDQUFDLENBQUMsV0FBVyxDQUFBOzt3QkFHcEQsV0FBTyxHQUFH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QUVELE9BQU8sRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsVUFBVSxJQUFJLE1BQU0sRUFBRSxVQUFVLEVBQUUsS0FBSyxFQUFFLENBQUE7QUFDL0UsY0FBYyxRQUFRLENBQUE7QUFFdEIsSUFBSTtJQUNELE1BQWMsQ0FBQyxVQUFVLEdBQUcsVUFBVSxDQUFBO0NBQ3hDO0FBQUMsT0FBTyxDQUFDLEVBQUUsR0FBRSIsInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuaW1wb3J0IHR5cGUgeyBJRmV0Y2hPcHRpb25zLCBTREtSZXF1ZXN0SW50ZXJmYWNlIH0gZnJvbSAnQGNsb3VkYmFzZS9hZGFwdGVyLWludGVyZmFjZSdcbmltcG9ydCB0eXBlIHsgSUNsb3VkYmFzZSwgSUNsb3VkYmFzZUNvbmZpZyB9IGZyb20gJ0BjbG91ZGJhc2UvdHlwZXMnXG5pbXBvcnQgdHlwZSB7IElDbG91ZGJhc2VDb21wb25lbnQgfSBmcm9tICdAY2xvdWRiYXNlL3R5cGVzL2NvbXBvbmVudCdcbmltcG9ydCB7IEFJIH0gZnJvbSAnLi9BSSdcbmltcG9ydCB7IEJvdCB9IGZyb20gJy4vYm90J1xuaW1wb3J0ICogYXMgbW9kZWxzIGZyb20gJy4vbW9kZWxzJ1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscydcblxuY29uc3QgQ09NUE9ORU5UX05BTUUgPSAnYWknXG5cbmNvbnN0IHsgTU9ERUxTLCAuLi5yZXN0TW9kZWxzIH0gPSBtb2RlbHNcblxuaW50ZXJmYWNlIElIYW5kbGVSZXF1ZXN0SW5zdGFuY2Uge1xuICByZXE6IFNES1JlcXVlc3RJbnRlcmZhY2Vcbn1cblxudHlwZSBIYW5kbGVSZXF1ZXN0SW5zdGFuY2VGdW5jID0gKG9wdGlvbnM6IElIYW5kbGVSZXF1ZXN0SW5zdGFuY2UpID0+IFNES1JlcXVlc3RJbnRlcmZhY2VcblxuY29uc3QgY3JlYXRlUmVxdWVzdEluc3RhbmNlV2l0aEFjY2Vzc1Rva2VuSGVhZGVyID0gKHtcbiAgZ2V0QWNjZXNzVG9rZW4sXG4gIHJlcSxcbn06IElIYW5kbGVSZXF1ZXN0SW5zdGFuY2UgJiB7IGdldEFjY2Vzc1Rva2VuOiAoKSA9PiBQcm9taXNlPHsgYWNjZXNzVG9rZW46IHN0cmluZyB9PiB9KSA9PiB7XG4gIGNvbnN0IGZldGNoOiB0eXBlb2YgcmVxLmZldGNoID0gYXN5bmMgKG9wdGlvbnM6IElGZXRjaE9wdGlvbnMgJiB7IHRva2VuPzogc3RyaW5nIH0pID0+IHtcbiAgICBpZiAodHlwZW9mIHJlcS5mZXRjaCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZXEuZmV0Y2ggaXMgbm90IGEgZnVuY3Rpb24nKVxuICAgIH1cblxuICAgIGNvbnN0IHsgdG9rZW4sIGhlYWRlcnMgPSB7fSwgLi4ucmVzdE9wdGlvbnMgfSA9IG9wdGlvbnNcbiAgICBsZXQgYWNjZXNzVG9rZW46IHN0cmluZ1xuICAgIGlmICh0b2tlbiAhPSBudWxsKSB7XG4gICAgICBhY2Nlc3NUb2tlbiA9IHRva2VuXG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY2Vzc1Rva2VuID0gKGF3YWl0IGdldEFjY2Vzc1Rva2VuKCkpLmFjY2Vzc1Rva2VuXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcS5mZXRjaCh7XG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gLFxuICAgICAgICAuLi5oZWFkZXJzLFxuICAgICAgfSxcbiAgICAgIC4uLnJlc3RPcHRpb25zLFxuICAgIH0pXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGRvd25sb2FkOiByZXEuZG93bmxvYWQsXG4gICAgcG9zdDogcmVxLnBvc3QsXG4gICAgdXBsb2FkOiByZXEudXBsb2FkLFxuICAgIGZldGNoLFxuICB9XG59XG5cbmludGVyZmFjZSBBSUluaXRPcHRpb24ge1xuICBiYXNlVXJsPzogc3RyaW5nXG59XG5cbmludGVyZmFjZSBJQ3JlYXRlQUkge1xuICByZXE6IFNES1JlcXVlc3RJbnRlcmZhY2VcbiAgYmFzZVVybD86IHN0cmluZ1xuICBlbnY/OiBzdHJpbmdcbiAgZ2V0QWNjZXNzVG9rZW4/OiAoKSA9PiBQcm9taXNlPHsgYWNjZXNzVG9rZW46IHN0cmluZyB9PlxuICBoYW5kbGVSZXFJbnN0YW5jZT86IEhhbmRsZVJlcXVlc3RJbnN0YW5jZUZ1bmNcbiAgaTE4bj86IElDbG91ZGJhc2VDb25maWdbJ2kxOG4nXVxufVxuXG4vKipcbiAqIOacgOeugOWcsOWIm+W7uuS4gOS4quaOpeS6keW8gOWPkee9keWFs+acjeWKoeeahCBgQUlgIOWunuS+i++8jOivt+axguaXtuS8muiHquWKqOW4puS4iumJtOadg+ivt+axguWktOOAglxuICog5Y+q6ZyA6KaB5Lyg5YWl77yaXG4gKlxuICogLSBgZ2V0QWNjZXNzVG9rZW5gOiDojrflj5YgYWNjZXNzVG9rZW4g55qE5Ye95pWwXG4gKiAtIGByZXFgOiDor7fmsYLlh73mlbDvvIzkuIDoiKzku44gYWRhcHRlciDkuIrmi79cbiAqIC0gYGVudmA6IOS6keW8gOWPkeeOr+WigyBJRFxuICpcbiAqIOWFtuS7luWPguaVsOWPr+aMiemcgOS8oOWFpeimhuebluWHveaVsOmAu+i+keOAglxuICovXG5mdW5jdGlvbiBjcmVhdGVBSSh7IGVudiwgYmFzZVVybCwgcmVxLCBnZXRBY2Nlc3NUb2tlbiwgaGFuZGxlUmVxSW5zdGFuY2UsIGkxOG4gfTogSUNyZWF0ZUFJKSB7XG4gIGNvbnN0IGdldEJhc2VVcmwgPSAoKSA9PiB7XG4gICAgaWYgKGJhc2VVcmwgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGJhc2VVcmxcbiAgICB9XG4gICAgaWYgKGVudiA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2BlbnZgIGlzIHJlcXVpcmVkIHdoZW4gYGJhc2VVcmxgIGlzIG5vdCBwcm92aWRlZCEnKVxuICAgIH1cbiAgICByZXR1cm4gYGh0dHBzOi8vJHtlbnZ9LmFwaS50Y2xvdWRiYXNlZ2F0ZXdheS5jb20vdjFgXG4gIH1cblxuICBjb25zdCBnZXRSZXEgPSAoKSA9PiB7XG4gICAgaWYgKGhhbmRsZVJlcUluc3RhbmNlID09IG51bGwpIHtcbiAgICAgIGlmIChnZXRBY2Nlc3NUb2tlbiA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYGdldEFjY2Vzc1Rva2VuYCBpcyByZXF1aXJlZCB3aGVuIGBoYW5kbGVSZXFJbnN0YW5jZWAgaXMgbm90IHByb3ZpZGVkIScpXG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlUmVxdWVzdEluc3RhbmNlV2l0aEFjY2Vzc1Rva2VuSGVhZGVyKHsgcmVxLCBnZXRBY2Nlc3NUb2tlbiB9KVxuICAgIH1cbiAgICByZXR1cm4gaGFuZGxlUmVxSW5zdGFuY2UoeyByZXEgfSlcbiAgfVxuXG4gIHJldHVybiBuZXcgQUkoZ2V0UmVxKCksIGdldEJhc2VVcmwoKSwgaTE4bilcbn1cblxuLy8g5YW85a65XG4vKipcbiAqIEBkZXByZWNhdGVkIHVzZSBgY3JlYXRlQUlgXG4gKi9cbmNvbnN0IGNyZWF0ZUFpID0gY3JlYXRlQUlcblxuLyoqXG4gKiDliJvlu7ogYEFJYCDlrp7kvovjgIJcbiAqIOivpeWHveaVsOaMgui9veWcqCBqcyBzZGsg55qEIENsb3VkYmFzZSDlrp7kvovkuIrjgIJcbiAqIOivpeWHveaVsOiwg+eUqOS6huacrOaooeWdl+aatOmcsueahCBgY3JlYXRlQUlgIOWHveaVsO+8jOS9huiwg+eUqOaXtumAmui/h+S8oOWFpeWPguaVsOWBmuS6humAu+i+keimhueblu+8mlxuICpcbiAqIC0g5Lyg5YWl5LuOIENsb3VkYmFzZSDlrp7kvovkuIrnmoTkuK3lv4PnmoQgYHJlcWBcbiAqIC0g5Lyg5YWl5LuOIENsb3VkYmFzZSDlrp7kvovkuIrmi7/liLDnmoQgYGJhc2VVcmxgXG4gKiAtIOS8oOWFpeS4gOS4quS4jeWkhOeQhiBgcmVxYCDnmoQgYGhhbmRsZVJlcUluc3RhbmNlYO+8jOeUseS6jiBgcmVxYCDmmK/ku44gQ2xvdWRiYXNlIOWunuS+i+S4iuaLv+WIsOeahO+8jOi/meS4quS4reW/g+eahCBgcmVxYCDlt7Lnu4/lj6/nlKjkuoZcbiAqIC0g5LiN55So5Lyg5YWlIGBlbnZgIOS6hu+8jOWboOS4uuW3sue7j+S8oOS6hiBgYmFzZVVybGBcbiAqIC0g5LiN55So5Lyg5YWlIGBnZXRBY2Nlc3NUb2tlbmAg5LqG77yM5Zug5Li65Lyg5LqGIGBoYW5kbGVSZXFJbnN0YW5jZWBcbiAqL1xuZnVuY3Rpb24gYWkoXG4gIHRoaXM6IElDbG91ZGJhc2UgJiB7IGdldEVuZFBvaW50V2l0aEtleTogKGtleTogJ0dBVEVXQVknKSA9PiB7IEJBU0VfVVJMOiBzdHJpbmc7IFBST1RPQ09MOiBzdHJpbmcgfSB9LFxuICBvcHRpb25zPzogQUlJbml0T3B0aW9uLFxuKSB7XG4gIGNvbnN0IHJlcSA9IHRoaXMucmVxdWVzdFxuXG4gIGlmIChyZXEuZmV0Y2ggPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xvdWRiYXNlLnJlcXVlc3QuZmV0Y2goKSB1bmltcGxlbWVudGVkIScpXG4gIH1cblxuICBjb25zdCBnZXRVcmxGcm9tQ2xvdWQgPSAoKSA9PiB7XG4gICAgY29uc3QgeyBCQVNFX1VSTCwgUFJPVE9DT0wgfSA9IHRoaXMuZ2V0RW5kUG9pbnRXaXRoS2V5KCdHQVRFV0FZJylcbiAgICByZXR1cm4gYCR7UFJPVE9DT0x9JHtCQVNFX1VSTH1gXG4gIH1cblxuICBjb25zdCBiYXNlVXJsID0gb3B0aW9ucz8uYmFzZVVybCA/PyBnZXRVcmxGcm9tQ2xvdWQoKVxuXG4gIHJldHVybiBjcmVhdGVBSSh7IHJlcSwgYmFzZVVybCwgaGFuZGxlUmVxSW5zdGFuY2U6ICh7IHJlcSB9KSA9PiByZXEsIGkxOG46IHRoaXMuY29uZmlnLmkxOG4gfSlcbn1cblxuY29uc3QgY29tcG9uZW50OiBJQ2xvdWRiYXNlQ29tcG9uZW50ID0ge1xuICBuYW1lOiBDT01QT05FTlRfTkFNRSxcbiAgZW50aXR5OiB7IGFpIH0sXG59XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyQWkoYXBwOiBJQ2xvdWRiYXNlKSB7XG4gIHRyeSB7XG4gICAgYXBwLnJlZ2lzdGVyQ29tcG9uZW50KGNvbXBvbmVudClcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUud2FybihlKVxuICB9XG59XG5cbmV4cG9ydCB7IEFJLCBCb3QsIGNyZWF0ZUFpLCBjcmVhdGVBSSwgcmVzdE1vZGVscyBhcyBtb2RlbHMsIHJlZ2lzdGVyQWksIHV0aWxzIH1cbmV4cG9ydCAqIGZyb20gJy4vdHlwZSdcblxudHJ5IHtcbiAgKHdpbmRvdyBhcyBhbnkpLnJlZ2lzdGVyQWkgPSByZWdpc3RlckFpXG59IGNhdGNoIChlKSB7fVxuIl19