{"version":3,"sources":["../src/index.ts","../src/utils.ts","../src/logger.ts","../src/constants.ts","../src/finalize-events.ts","../src/transcription-errors.ts"],"sourcesContent":["export {\n  type MaybePromise,\n  type NonEmptyRecord,\n  type AgentDescription,\n  type RuntimeInfo,\n} from \"./types\";\n\nexport * from \"./utils\";\n\nexport { logger } from \"./logger\";\nexport { DEFAULT_AGENT_ID } from \"./constants\";\nexport { finalizeRunEvents } from \"./finalize-events\";\n\nexport {\n  TranscriptionErrorCode,\n  TranscriptionErrors,\n  type TranscriptionErrorResponse,\n} from \"./transcription-errors\";\n","import { v4 as uuidv4 } from \"uuid\";\nimport * as PartialJSON from \"partial-json\";\n\nexport function randomUUID() {\n  return uuidv4();\n}\n\nexport function partialJSONParse(json: string) {\n  try {\n    return PartialJSON.parse(json);\n  } catch (error) {\n    return {};\n  }\n}\n","export const logger = console;\n","export const DEFAULT_AGENT_ID = \"default\";\n","import {\n  BaseEvent,\n  EventType,\n  RunErrorEvent,\n} from \"@ag-ui/client\";\nimport { randomUUID } from \"./utils\";\n\ninterface FinalizeRunOptions {\n  stopRequested?: boolean;\n  interruptionMessage?: string;\n}\n\nconst defaultStopMessage = \"Run stopped by user\";\nconst defaultAbruptEndMessage = \"Run ended without emitting a terminal event\";\n\nexport function finalizeRunEvents(\n  events: BaseEvent[],\n  options: FinalizeRunOptions = {},\n): BaseEvent[] {\n  const { stopRequested = false, interruptionMessage } = options;\n\n  const resolvedStopMessage = interruptionMessage ?? defaultStopMessage;\n  const resolvedAbruptMessage =\n    interruptionMessage && interruptionMessage !== defaultStopMessage\n      ? interruptionMessage\n      : defaultAbruptEndMessage;\n\n  const appended: BaseEvent[] = [];\n\n  const openMessageIds = new Set<string>();\n  const openToolCalls = new Map<\n    string,\n    {\n      hasEnd: boolean;\n      hasResult: boolean;\n    }\n  >();\n\n  for (const event of events) {\n    switch (event.type) {\n      case EventType.TEXT_MESSAGE_START: {\n        const messageId = (event as { messageId?: string }).messageId;\n        if (typeof messageId === \"string\") {\n          openMessageIds.add(messageId);\n        }\n        break;\n      }\n      case EventType.TEXT_MESSAGE_END: {\n        const messageId = (event as { messageId?: string }).messageId;\n        if (typeof messageId === \"string\") {\n          openMessageIds.delete(messageId);\n        }\n        break;\n      }\n      case EventType.TOOL_CALL_START: {\n        const toolCallId = (event as { toolCallId?: string }).toolCallId;\n        if (typeof toolCallId === \"string\") {\n          openToolCalls.set(toolCallId, {\n            hasEnd: false,\n            hasResult: false,\n          });\n        }\n        break;\n      }\n      case EventType.TOOL_CALL_END: {\n        const toolCallId = (event as { toolCallId?: string }).toolCallId;\n        const info = toolCallId ? openToolCalls.get(toolCallId) : undefined;\n        if (info) {\n          info.hasEnd = true;\n        }\n        break;\n      }\n      case EventType.TOOL_CALL_RESULT: {\n        const toolCallId = (event as { toolCallId?: string }).toolCallId;\n        const info = toolCallId ? openToolCalls.get(toolCallId) : undefined;\n        if (info) {\n          info.hasResult = true;\n        }\n        break;\n      }\n      default:\n        break;\n    }\n  }\n\n  const hasRunFinished = events.some((event) => event.type === EventType.RUN_FINISHED);\n  const hasRunError = events.some((event) => event.type === EventType.RUN_ERROR);\n  const hasTerminalEvent = hasRunFinished || hasRunError;\n  const terminalEventMissing = !hasTerminalEvent;\n\n  for (const messageId of openMessageIds) {\n    const endEvent = {\n      type: EventType.TEXT_MESSAGE_END,\n      messageId,\n    } as BaseEvent;\n    events.push(endEvent);\n    appended.push(endEvent);\n  }\n\n  for (const [toolCallId, info] of openToolCalls) {\n    if (!info.hasEnd) {\n      const endEvent = {\n        type: EventType.TOOL_CALL_END,\n        toolCallId,\n      } as BaseEvent;\n      events.push(endEvent);\n      appended.push(endEvent);\n    }\n\n    if (terminalEventMissing && !info.hasResult) {\n      const resultEvent = {\n        type: EventType.TOOL_CALL_RESULT,\n        toolCallId,\n        messageId: `${toolCallId ?? randomUUID()}-result`,\n        role: \"tool\",\n        content: JSON.stringify(\n          stopRequested\n            ? {\n                status: \"stopped\",\n                reason: \"stop_requested\",\n                message: resolvedStopMessage,\n              }\n            : {\n                status: \"error\",\n                reason: \"missing_terminal_event\",\n                message: resolvedAbruptMessage,\n              },\n        ),\n      } as BaseEvent;\n      events.push(resultEvent);\n      appended.push(resultEvent);\n    }\n  }\n\n  if (terminalEventMissing) {\n    if (stopRequested) {\n      const finishedEvent = {\n        type: EventType.RUN_FINISHED,\n      } as BaseEvent;\n      events.push(finishedEvent);\n      appended.push(finishedEvent);\n    } else {\n      const errorEvent: RunErrorEvent = {\n        type: EventType.RUN_ERROR,\n        message: resolvedAbruptMessage,\n        code: \"INCOMPLETE_STREAM\",\n      };\n      events.push(errorEvent);\n      appended.push(errorEvent);\n    }\n  }\n\n  return appended;\n}\n","/**\n * Error codes for transcription HTTP responses.\n * Uses snake_case to align with existing CopilotKitCoreErrorCode pattern.\n * These codes are returned by the runtime and parsed by the client.\n */\nexport enum TranscriptionErrorCode {\n  /** Transcription service not configured in runtime */\n  SERVICE_NOT_CONFIGURED = \"service_not_configured\",\n  /** Audio format not supported */\n  INVALID_AUDIO_FORMAT = \"invalid_audio_format\",\n  /** Audio file is too long */\n  AUDIO_TOO_LONG = \"audio_too_long\",\n  /** Audio file is empty or too short */\n  AUDIO_TOO_SHORT = \"audio_too_short\",\n  /** Rate limited by transcription provider */\n  RATE_LIMITED = \"rate_limited\",\n  /** Authentication failed with transcription provider */\n  AUTH_FAILED = \"auth_failed\",\n  /** Transcription provider returned an error */\n  PROVIDER_ERROR = \"provider_error\",\n  /** Network error during transcription */\n  NETWORK_ERROR = \"network_error\",\n  /** Invalid request format */\n  INVALID_REQUEST = \"invalid_request\",\n}\n\n/**\n * Error response format returned by the transcription endpoint.\n */\nexport interface TranscriptionErrorResponse {\n  error: TranscriptionErrorCode;\n  message: string;\n  retryable?: boolean;\n}\n\n/**\n * Helper functions to create transcription error responses.\n * Used by the runtime to return consistent error responses.\n */\nexport const TranscriptionErrors = {\n  serviceNotConfigured: (): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.SERVICE_NOT_CONFIGURED,\n    message: \"Transcription service is not configured\",\n    retryable: false,\n  }),\n\n  invalidAudioFormat: (format: string, supported: string[]): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.INVALID_AUDIO_FORMAT,\n    message: `Unsupported audio format: ${format}. Supported: ${supported.join(\", \")}`,\n    retryable: false,\n  }),\n\n  invalidRequest: (details: string): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.INVALID_REQUEST,\n    message: details,\n    retryable: false,\n  }),\n\n  rateLimited: (): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.RATE_LIMITED,\n    message: \"Rate limited. Please try again later.\",\n    retryable: true,\n  }),\n\n  authFailed: (): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.AUTH_FAILED,\n    message: \"Authentication failed with transcription provider\",\n    retryable: false,\n  }),\n\n  providerError: (message: string): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.PROVIDER_ERROR,\n    message,\n    retryable: true,\n  }),\n\n  networkError: (message: string = \"Network error during transcription\"): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.NETWORK_ERROR,\n    message,\n    retryable: true,\n  }),\n\n  audioTooLong: (): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.AUDIO_TOO_LONG,\n    message: \"Audio file is too long\",\n    retryable: false,\n  }),\n\n  audioTooShort: (): TranscriptionErrorResponse => ({\n    error: TranscriptionErrorCode.AUDIO_TOO_SHORT,\n    message: \"Audio is too short to transcribe\",\n    retryable: false,\n  }),\n};\n"],"mappings":"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","names":["uuidv4","TranscriptionErrorCode"]}