{"version":3,"sources":["../src/index.ts","../src/agent.ts","../src/types.ts","../src/utils.ts"],"sourcesContent":["import { HttpAgent } from \"@ag-ui/client\";\n\nexport * from './agent'\nexport class LangGraphHttpAgent extends HttpAgent {}","import { Observable, Subscriber } from \"rxjs\";\nimport {\n  Client as LangGraphClient,\n  EventsStreamEvent,\n  StreamMode,\n  Config as LangGraphConfig,\n  ThreadState,\n  Assistant,\n  Message as LangGraphMessage,\n  Config,\n  Interrupt,\n  Thread,\n} from \"@langchain/langgraph-sdk\";\nimport { randomUUID } from \"@ag-ui/client\";\nimport {\n  LangGraphPlatformMessage,\n  CustomEventNames,\n  LangGraphEventTypes,\n  State,\n  MessagesInProgressRecord,\n  ThinkingInProgress,\n  SchemaKeys,\n  MessageInProgress,\n  RunMetadata,\n  PredictStateTool,\n  LangGraphReasoning,\n  StateEnrichment,\n  LangGraphToolWithName,\n} from \"./types\";\nimport {\n  AbstractAgent,\n  AgentConfig,\n  CustomEvent,\n  EventType,\n  MessagesSnapshotEvent,\n  RawEvent,\n  RunAgentInput,\n  RunErrorEvent,\n  RunFinishedEvent,\n  RunStartedEvent,\n  StateDeltaEvent,\n  StateSnapshotEvent,\n  StepFinishedEvent,\n  StepStartedEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallStartEvent,\n  ToolCallResultEvent,\n  ThinkingTextMessageStartEvent,\n  ThinkingTextMessageContentEvent,\n  ThinkingTextMessageEndEvent,\n  ThinkingStartEvent,\n  ThinkingEndEvent,\n} from \"@ag-ui/client\";\nimport { RunsStreamPayload } from \"@langchain/langgraph-sdk/dist/types\";\nimport {\n  aguiMessagesToLangChain,\n  DEFAULT_SCHEMA_KEYS,\n  filterObjectBySchemaKeys,\n  getStreamPayloadInput,\n  langchainMessagesToAgui,\n  resolveMessageContent,\n  resolveReasoningContent,\n} from \"@/utils\";\nimport { ToolMessage } from \"@langchain/core/messages\";\nimport { ToolMessageFieldsWithToolCallId } from \"@langchain/core/dist/messages/tool\";\n\nexport type ProcessedEvents =\n  | TextMessageStartEvent\n  | TextMessageContentEvent\n  | TextMessageEndEvent\n  | ThinkingTextMessageStartEvent\n  | ThinkingTextMessageContentEvent\n  | ThinkingTextMessageEndEvent\n  | ToolCallStartEvent\n  | ToolCallArgsEvent\n  | ToolCallEndEvent\n  | ToolCallResultEvent\n  | ThinkingStartEvent\n  | ThinkingEndEvent\n  | StateSnapshotEvent\n  | StateDeltaEvent\n  | MessagesSnapshotEvent\n  | RawEvent\n  | CustomEvent\n  | RunStartedEvent\n  | RunFinishedEvent\n  | RunErrorEvent\n  | StepStartedEvent\n  | StepFinishedEvent;\n\ntype RunAgentExtendedInput<\n  TStreamMode extends StreamMode | StreamMode[] = StreamMode,\n  TSubgraphs extends boolean = false,\n> = Omit<RunAgentInput, \"forwardedProps\"> & {\n  forwardedProps?: Omit<RunsStreamPayload<TStreamMode, TSubgraphs>, \"input\"> & {\n    nodeName?: string;\n    threadMetadata?: Record<string, any>;\n  };\n};\n\ninterface RegenerateInput extends RunAgentExtendedInput {\n  messageCheckpoint: LangGraphMessage;\n}\n\nexport interface LangGraphAgentConfig extends AgentConfig {\n  client?: LangGraphClient;\n  deploymentUrl: string;\n  langsmithApiKey?: string;\n  propertyHeaders?: Record<string, string>;\n  assistantConfig?: LangGraphConfig;\n  agentName?: string;\n  graphId: string;\n}\n\nexport class LangGraphAgent extends AbstractAgent {\n  client: LangGraphClient;\n  assistantConfig?: LangGraphConfig;\n  agentName?: string;\n  graphId: string;\n  assistant?: Assistant;\n  messagesInProcess: MessagesInProgressRecord;\n  thinkingProcess: null | ThinkingInProgress;\n  activeRun?: RunMetadata;\n  // Stop control flags\n  private cancelRequested: boolean = false;\n  private cancelSent: boolean = false;\n  // @ts-expect-error no need to initialize subscriber right now\n  subscriber: Subscriber<ProcessedEvents>;\n  constantSchemaKeys: string[] = DEFAULT_SCHEMA_KEYS;\n  config: LangGraphAgentConfig;\n\n  constructor(config: LangGraphAgentConfig) {\n    super(config);\n    this.config = config;\n    this.messagesInProcess = {};\n    this.agentName = config.agentName;\n    this.graphId = config.graphId;\n    this.assistantConfig = config.assistantConfig;\n    this.thinkingProcess = null;\n    this.client =\n      config?.client ??\n      new LangGraphClient({\n        apiUrl: config.deploymentUrl,\n        apiKey: config.langsmithApiKey,\n        defaultHeaders: { ...(config.propertyHeaders ?? {}) },\n      });\n  }\n\n  public clone() {\n    return new LangGraphAgent(this.config);\n  }\n\n  dispatchEvent(event: ProcessedEvents) {\n    this.subscriber.next(event);\n    return true;\n  }\n\n  run(input: RunAgentInput) {\n    return new Observable<ProcessedEvents>((subscriber) => {\n      this.runAgentStream(input, subscriber);\n      return () => {};\n    });\n  }\n\n  async runAgentStream(input: RunAgentExtendedInput, subscriber: Subscriber<ProcessedEvents>) {\n    this.activeRun = {\n      id: input.runId,\n      threadId: input.threadId,\n      hasFunctionStreaming: false,\n    };\n    // Reset cancel flags for this run\n    this.cancelRequested = false;\n    this.cancelSent = false;\n    this.subscriber = subscriber;\n    if (!this.assistant) {\n      this.assistant = await this.getAssistant();\n    }\n    const threadId = input.threadId ?? randomUUID();\n    const streamMode =\n      input.forwardedProps?.streamMode ?? ([\"events\", \"values\", \"updates\"] satisfies StreamMode[]);\n    const preparedStream = await this.prepareStream({ ...input, threadId }, streamMode);\n\n    if (!preparedStream) {\n      return subscriber.error(\"No stream to regenerate\");\n    }\n\n    await this.handleStreamEvents(preparedStream, threadId, subscriber, input, Array.isArray(streamMode) ? streamMode : [streamMode]);\n  }\n\n  async prepareRegenerateStream(input: RegenerateInput, streamMode: StreamMode | StreamMode[]) {\n    const { threadId, messageCheckpoint } = input;\n\n    const timeTravelCheckpoint = await this.getCheckpointByMessage(\n      messageCheckpoint!.id!,\n      threadId,\n    );\n    if (!this.assistant) {\n      this.assistant = await this.getAssistant();\n    }\n\n    if (!timeTravelCheckpoint) {\n      return this.subscriber.error(\"No checkpoint found for message\");\n    }\n\n    const fork = await this.client.threads.updateState(threadId, {\n      values: this.langGraphDefaultMergeState(timeTravelCheckpoint.values, [], input),\n      checkpointId: timeTravelCheckpoint.checkpoint.checkpoint_id!,\n      asNode: timeTravelCheckpoint.next?.[0] ?? \"__start__\",\n    });\n\n    const payload = {\n      ...(input.forwardedProps ?? {}),\n      input: this.langGraphDefaultMergeState(\n        timeTravelCheckpoint.values,\n        [messageCheckpoint],\n        input,\n      ),\n      // @ts-ignore\n      checkpointId: fork.checkpoint.checkpoint_id!,\n      streamMode,\n    };\n    return {\n      streamResponse: this.client.runs.stream(threadId, this.assistant.assistant_id, payload),\n      state: timeTravelCheckpoint as ThreadState<State>,\n      streamMode,\n    };\n  }\n\n  async prepareStream(input: RunAgentExtendedInput, streamMode: StreamMode | StreamMode[]) {\n    let {\n      threadId: inputThreadId,\n      state: inputState,\n      messages,\n      tools,\n      context,\n      forwardedProps,\n    } = input;\n    // If a manual emittance happens, it is the ultimate source of truth of state, unless a node has exited.\n    // Therefore, this value should either hold null, or the only edition of state that should be used.\n    this.activeRun!.manuallyEmittedState = null;\n\n    const nodeNameInput = forwardedProps?.nodeName;\n    const threadId = inputThreadId ?? randomUUID();\n\n    if (!this.assistant) {\n      this.assistant = await this.getAssistant();\n    }\n\n    const thread = await this.getOrCreateThread(threadId, forwardedProps?.threadMetadata);\n    this.activeRun!.threadId = thread.thread_id;\n\n    const agentState: ThreadState<State> =\n      (await this.client.threads.getState(thread.thread_id)) ??\n      ({ values: {} } as ThreadState<State>);\n    const agentStateMessages = agentState.values.messages ?? [];\n    const inputMessagesToLangchain = aguiMessagesToLangChain(messages);\n    const stateValuesDiff = this.langGraphDefaultMergeState(\n      { ...inputState, messages: agentStateMessages },\n      inputMessagesToLangchain,\n      input,\n    );\n    // Messages are a combination of existing messages in state + everything that was newly sent\n    let threadState = {\n      ...agentState,\n      values: {\n        ...stateValuesDiff,\n        messages: [...agentStateMessages, ...(stateValuesDiff.messages ?? [])],\n      },\n    };\n    let stateValues = threadState.values;\n    this.activeRun!.schemaKeys = await this.getSchemaKeys();\n\n    if (\n      (agentState.values.messages ?? []).length > messages.filter((m) => m.role !== \"system\").length\n    ) {\n      let lastUserMessage: LangGraphMessage | null = null;\n      // Find the first user message by working backwards from the last message\n      for (let i = messages.length - 1; i >= 0; i--) {\n        if (messages[i].role === \"user\") {\n          lastUserMessage = aguiMessagesToLangChain([messages[i]])[0];\n          break;\n        }\n      }\n\n      if (!lastUserMessage) {\n        return this.subscriber.error(\"No user message found in messages to regenerate\");\n      }\n\n      return this.prepareRegenerateStream(\n        { ...input, messageCheckpoint: lastUserMessage },\n        streamMode,\n      );\n    }\n    this.activeRun!.graphInfo = await this.client.assistants.getGraph(this.assistant.assistant_id);\n\n    const mode =\n      !forwardedProps?.command?.resume &&\n      threadId &&\n      this.activeRun!.nodeName != \"__end__\" &&\n      this.activeRun!.nodeName\n        ? \"continue\"\n        : \"start\";\n\n    if (mode === \"continue\") {\n      const nodeBefore = this.activeRun!.graphInfo.edges.find(\n        (e) => e.target === this.activeRun!.nodeName,\n      );\n      await this.client.threads.updateState(threadId, {\n        values: inputState,\n        asNode: nodeBefore?.source,\n      });\n    }\n\n    const payloadInput = getStreamPayloadInput({\n      mode,\n      state: stateValues,\n      schemaKeys: this.activeRun!.schemaKeys,\n    });\n\n    let payloadConfig: LangGraphConfig | undefined;\n    const configsToMerge = [this.assistantConfig, forwardedProps?.config].filter(\n      Boolean,\n    ) as LangGraphConfig[];\n    if (configsToMerge.length) {\n      payloadConfig = await this.mergeConfigs({\n        configs: configsToMerge,\n        assistant: this.assistant,\n        schemaKeys: this.activeRun!.schemaKeys,\n      });\n    }\n    // @ts-ignore\n    const { command, ...restProps } = forwardedProps\n    if (command?.resume && typeof command.resume === 'string') {\n      try {\n        command.resume = JSON.parse(command.resume);\n      } catch {\n        // Keep as string if not valid JSON\n      }\n    }\n    const payload = {\n      ...restProps,\n      command,\n      streamMode,\n      input: payloadInput,\n      config: payloadConfig,\n      context: {\n        ...context,\n        ...(payloadConfig?.configurable ?? {}),\n      }\n    };\n\n    // If there are still outstanding unresolved interrupts, we must force resolution of them before moving forward\n    const interrupts = (agentState.tasks?.[0]?.interrupts ?? []) as Interrupt[];\n    if (interrupts?.length && !forwardedProps?.command?.resume) {\n      this.dispatchEvent({\n        type: EventType.RUN_STARTED,\n        threadId,\n        runId: input.runId,\n      });\n      this.handleNodeChange(nodeNameInput)\n\n      interrupts.forEach((interrupt) => {\n        this.dispatchEvent({\n          type: EventType.CUSTOM,\n          name: LangGraphEventTypes.OnInterrupt,\n          value:\n            typeof interrupt.value === \"string\" ? interrupt.value : JSON.stringify(interrupt.value),\n          rawEvent: interrupt,\n        });\n      });\n\n      this.dispatchEvent({\n        type: EventType.RUN_FINISHED,\n        threadId,\n        runId: input.runId,\n      });\n      return this.subscriber.complete();\n    }\n\n    return {\n      // @ts-ignore\n      streamResponse: this.client.runs.stream(threadId, this.assistant.assistant_id, payload),\n      state: threadState as ThreadState<State>,\n    };\n  }\n\n  async handleStreamEvents(\n    stream: Awaited<\n      ReturnType<typeof this.prepareStream> | ReturnType<typeof this.prepareRegenerateStream>\n    >,\n    threadId: string,\n    subscriber: Subscriber<ProcessedEvents>,\n    input: RunAgentExtendedInput,\n    streamModes: StreamMode | StreamMode[],\n  ) {\n    const { forwardedProps } = input;\n    const nodeNameInput = forwardedProps?.nodeName;\n    this.subscriber = subscriber;\n    let shouldExit = false;\n    if (!stream) return;\n\n    let { streamResponse, state } = stream;\n\n    this.activeRun!.prevNodeName = null;\n    let latestStateValues = {} as ThreadState<State>[\"values\"];\n    let updatedState = state;\n\n    try {\n      this.dispatchEvent({\n        type: EventType.RUN_STARTED,\n        threadId,\n        runId: this.activeRun!.id,\n      });\n      this.handleNodeChange(nodeNameInput)\n\n      for await (let streamResponseChunk of streamResponse) {\n        // If a cancel was requested and we haven't sent it yet, try now.\n        if (\n          this.cancelRequested &&\n          !this.cancelSent &&\n          this.activeRun?.threadId &&\n          this.activeRun?.id\n        ) {\n          try {\n            await this.client.runs.cancel(this.activeRun.threadId, this.activeRun.id);\n          } catch (_) {\n            // Ignore cancellation errors\n          } finally {\n            this.cancelSent = true;\n          }\n          // Best-effort: ask iterator to close early\n          try {\n            // Many async iterables used for streaming implement return()\n            await (streamResponse as any)?.return?.();\n          } catch (_) {}\n          break;\n        }\n\n        const subgraphsStreamEnabled = input.forwardedProps?.streamSubgraphs;\n        const isSubgraphStream =\n          subgraphsStreamEnabled &&\n          (streamResponseChunk.event.startsWith(\"events\") ||\n            streamResponseChunk.event.startsWith(\"values\"));\n\n        // @ts-ignore\n        if (!streamModes.includes(streamResponseChunk.event as StreamMode) && !isSubgraphStream && streamResponseChunk.event !== 'error') {\n          continue;\n        }\n\n        // Force event type, as data is not properly defined on the LG side.\n        type EventsChunkData = {\n          __interrupt__?: any;\n          metadata: Record<string, any>;\n          event: string;\n          data: any;\n          [key: string]: unknown;\n        };\n        const chunk = streamResponseChunk as EventsStreamEvent & { data: EventsChunkData };\n\n        if (streamResponseChunk.event === \"error\") {\n          this.dispatchEvent({\n            type: EventType.RUN_ERROR,\n            message: streamResponseChunk.data.message,\n            rawEvent: streamResponseChunk,\n          });\n          break;\n        }\n\n        if (streamResponseChunk.event === \"updates\") {\n          continue;\n        }\n\n        if (streamResponseChunk.event === \"values\") {\n          latestStateValues = chunk.data;\n          continue;\n        } else if (subgraphsStreamEnabled && chunk.event.startsWith(\"values|\")) {\n          latestStateValues = {\n            ...latestStateValues,\n            ...chunk.data,\n          };\n          continue;\n        }\n\n        const chunkData = chunk.data;\n        const metadata = chunkData.metadata ?? {};\n        const currentNodeName = metadata.langgraph_node;\n        const eventType = chunkData.event;\n\n        // Set server-assigned run id as soon as available\n        if (metadata.run_id) {\n          this.activeRun!.id = metadata.run_id;\n          this.activeRun!.serverRunIdKnown = true;\n          // If cancel was requested earlier (before server id was known), send it now.\n          if (this.cancelRequested && !this.cancelSent && this.activeRun?.threadId) {\n            try {\n              await this.client.runs.cancel(this.activeRun.threadId!, this.activeRun.id);\n            } catch (_) {\n              // Ignore cancellation errors\n            } finally {\n              this.cancelSent = true;\n            }\n          }\n        }\n\n        if (currentNodeName && currentNodeName !== this.activeRun!.nodeName) {\n          this.handleNodeChange(currentNodeName)\n        }\n\n        shouldExit =\n          shouldExit ||\n          (eventType === LangGraphEventTypes.OnCustomEvent &&\n            chunkData.name === CustomEventNames.Exit);\n\n        if (eventType === LangGraphEventTypes.OnChainEnd && this.activeRun!.nodeName === currentNodeName) {\n          this.activeRun!.exitingNode = true;\n        }\n        if (this.activeRun!.exitingNode) {\n          this.activeRun!.manuallyEmittedState = null;\n        }\n\n        // we only want to update the node name under certain conditions\n        // since we don't need any internal node names to be sent to the frontend\n        if (this.activeRun!.graphInfo?.[\"nodes\"].some((node) => node.id === currentNodeName)) {\n          this.handleNodeChange(currentNodeName)\n        }\n\n        updatedState.values = this.activeRun!.manuallyEmittedState ?? latestStateValues;\n\n        if (!this.activeRun!.nodeName) {\n          continue;\n        }\n\n        const hasStateDiff = JSON.stringify(updatedState) !== JSON.stringify(state);\n        // We should not update snapshot while a message is in progress.\n        if (\n          (hasStateDiff ||\n            this.activeRun!.prevNodeName != this.activeRun!.nodeName ||\n            this.activeRun!.exitingNode) &&\n          !Boolean(this.getMessageInProgress(this.activeRun!.id))\n        ) {\n          state = updatedState;\n          this.activeRun!.prevNodeName = this.activeRun!.nodeName;\n\n          this.dispatchEvent({\n            type: EventType.STATE_SNAPSHOT,\n            snapshot: this.getStateSnapshot(state),\n            rawEvent: chunk,\n          });\n        }\n\n        this.dispatchEvent({\n          type: EventType.RAW,\n          event: chunkData,\n        });\n\n        this.handleSingleEvent(chunkData);\n      }\n\n      state = await this.client.threads.getState(threadId);\n      const tasks = state.tasks;\n      const interrupts = (tasks?.[0]?.interrupts ?? []) as Interrupt[];\n      const isEndNode = state.next.length === 0;\n      const writes = state.metadata?.writes ?? {};\n\n      // Initialize a new node name to use in the next if block\n      let newNodeName = this.activeRun!.nodeName!;\n\n      if (!interrupts?.length) {\n        newNodeName = isEndNode ? \"__end__\" : (state.next[0] ?? Object.keys(writes)[0]);\n      }\n\n      interrupts.forEach((interrupt) => {\n        this.dispatchEvent({\n          type: EventType.CUSTOM,\n          name: LangGraphEventTypes.OnInterrupt,\n          value:\n            typeof interrupt.value === \"string\" ? interrupt.value : JSON.stringify(interrupt.value),\n          rawEvent: interrupt,\n        });\n      });\n\n      this.handleNodeChange(newNodeName);\n      // Immediately turn off new step\n      this.handleNodeChange(undefined);\n\n      this.dispatchEvent({\n        type: EventType.STATE_SNAPSHOT,\n        snapshot: this.getStateSnapshot(state),\n      });\n      this.dispatchEvent({\n        type: EventType.MESSAGES_SNAPSHOT,\n        messages: langchainMessagesToAgui((state.values as { messages: any[] }).messages ?? []),\n      });\n\n      this.dispatchEvent({\n        type: EventType.RUN_FINISHED,\n        threadId,\n        runId: this.activeRun!.id,\n      });\n      // Reset cancel flags when run completes\n      this.cancelRequested = false;\n      this.cancelSent = false;\n      this.activeRun = undefined;\n      return subscriber.complete();\n    } catch (e) {\n      return subscriber.error(e);\n    }\n  }\n\n  handleSingleEvent(event: any): void {\n    switch (event.event) {\n      case LangGraphEventTypes.OnChatModelStream:\n        let shouldEmitMessages = event.metadata[\"emit-messages\"] ?? true;\n        let shouldEmitToolCalls = event.metadata[\"emit-tool-calls\"] ?? true;\n\n        if (event.data.chunk.response_metadata.finish_reason) return;\n        let currentStream = this.getMessageInProgress(this.activeRun!.id);\n        const hasCurrentStream = Boolean(currentStream?.id);\n        const toolCallData = event.data.chunk.tool_call_chunks?.[0];\n        const toolCallUsedToPredictState = event.metadata[\"predict_state\"]?.some(\n          (predictStateTool: PredictStateTool) => predictStateTool.tool === toolCallData?.name,\n        );\n\n        const isToolCallStartEvent = !hasCurrentStream && toolCallData?.name;\n        const isToolCallArgsEvent =\n          hasCurrentStream && currentStream?.toolCallId && toolCallData?.args;\n        const isToolCallEndEvent = hasCurrentStream && currentStream?.toolCallId && !toolCallData;\n\n        if (isToolCallEndEvent || isToolCallArgsEvent || isToolCallStartEvent) {\n          this.activeRun!.hasFunctionStreaming = true;\n        }\n\n        const reasoningData = resolveReasoningContent(event.data);\n        const messageContent = resolveMessageContent(event.data.chunk.content);\n        const isMessageContentEvent = Boolean(!toolCallData && messageContent);\n\n        const isMessageEndEvent =\n          hasCurrentStream && !currentStream?.toolCallId && !isMessageContentEvent;\n\n        if (reasoningData) {\n          this.handleThinkingEvent(reasoningData);\n          break;\n        }\n\n        if (!reasoningData && this.thinkingProcess) {\n          this.dispatchEvent({\n            type: EventType.THINKING_TEXT_MESSAGE_END,\n          });\n          this.dispatchEvent({\n            type: EventType.THINKING_END,\n          });\n          this.thinkingProcess = null;\n        }\n\n        if (toolCallUsedToPredictState) {\n          this.dispatchEvent({\n            type: EventType.CUSTOM,\n            name: \"PredictState\",\n            value: event.metadata[\"predict_state\"],\n          });\n        }\n\n        if (isToolCallEndEvent) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TOOL_CALL_END,\n            toolCallId: currentStream?.toolCallId!,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.messagesInProcess[this.activeRun!.id] = null;\n          }\n          break;\n        }\n\n        if (isMessageEndEvent) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_END,\n            messageId: currentStream!.id,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.messagesInProcess[this.activeRun!.id] = null;\n          }\n          break;\n        }\n\n        if (isToolCallStartEvent && shouldEmitToolCalls) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TOOL_CALL_START,\n            toolCallId: toolCallData.id,\n            toolCallName: toolCallData.name,\n            parentMessageId: event.data.chunk.id,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.setMessageInProgress(this.activeRun!.id, {\n              id: event.data.chunk.id,\n              toolCallId: toolCallData.id,\n              toolCallName: toolCallData.name,\n            });\n          }\n          break;\n        }\n\n        // Tool call args: emit ActionExecutionArgs\n        if (isToolCallArgsEvent && shouldEmitToolCalls) {\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_ARGS,\n            toolCallId: currentStream?.toolCallId!,\n            delta: toolCallData.args,\n            rawEvent: event,\n          });\n          break;\n        }\n\n        // Message content: emit TextMessageContent\n        if (isMessageContentEvent && shouldEmitMessages) {\n          // No existing message yet, also init the message\n          if (!currentStream) {\n            this.dispatchEvent({\n              type: EventType.TEXT_MESSAGE_START,\n              role: \"assistant\",\n              messageId: event.data.chunk.id,\n              rawEvent: event,\n            });\n            this.setMessageInProgress(this.activeRun!.id, {\n              id: event.data.chunk.id,\n              toolCallId: null,\n              toolCallName: null,\n            });\n            currentStream = this.getMessageInProgress(this.activeRun!.id);\n          }\n\n          this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_CONTENT,\n            messageId: currentStream!.id,\n            delta: messageContent!,\n            rawEvent: event,\n          });\n          break;\n        }\n\n        break;\n      case LangGraphEventTypes.OnChatModelEnd:\n        if (this.getMessageInProgress(this.activeRun!.id)?.toolCallId) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TOOL_CALL_END,\n            toolCallId: this.getMessageInProgress(this.activeRun!.id)!.toolCallId!,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.messagesInProcess[this.activeRun!.id] = null;\n          }\n          break;\n        }\n        if (this.getMessageInProgress(this.activeRun!.id)?.id) {\n          const resolved = this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_END,\n            messageId: this.getMessageInProgress(this.activeRun!.id)!.id,\n            rawEvent: event,\n          });\n          if (resolved) {\n            this.messagesInProcess[this.activeRun!.id] = null;\n          }\n          break;\n        }\n        break;\n      case LangGraphEventTypes.OnCustomEvent:\n        if (event.name === CustomEventNames.ManuallyEmitMessage) {\n          this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_START,\n            role: \"assistant\",\n            messageId: event.data.message_id,\n            rawEvent: event,\n          });\n          this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_CONTENT,\n            messageId: event.data.message_id,\n            delta: event.data.message,\n            rawEvent: event,\n          });\n          this.dispatchEvent({\n            type: EventType.TEXT_MESSAGE_END,\n            messageId: event.data.message_id,\n            rawEvent: event,\n          });\n          break;\n        }\n\n        if (event.name === CustomEventNames.ManuallyEmitToolCall) {\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_START,\n            toolCallId: event.data.id,\n            toolCallName: event.data.name,\n            parentMessageId: event.data.id,\n            rawEvent: event,\n          });\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_ARGS,\n            toolCallId: event.data.id,\n            delta: event.data.args,\n            rawEvent: event,\n          });\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_END,\n            toolCallId: event.data.id,\n            rawEvent: event,\n          });\n          break;\n        }\n\n        if (event.name === CustomEventNames.ManuallyEmitState) {\n          this.activeRun!.manuallyEmittedState = event.data;\n          this.dispatchEvent({\n            type: EventType.STATE_SNAPSHOT,\n            snapshot: this.getStateSnapshot({\n              values: this.activeRun!.manuallyEmittedState!,\n            } as ThreadState<State>),\n            rawEvent: event,\n          });\n        }\n\n        this.dispatchEvent({\n          type: EventType.CUSTOM,\n          name: event.name,\n          value: event.data,\n          rawEvent: event,\n        });\n        break;\n      case LangGraphEventTypes.OnToolEnd:\n        let toolCallOutput = event.data?.output\n\n        // Command from within a tool. We need to grab result from the tool result message\n        if (toolCallOutput && !toolCallOutput.tool_call_id && toolCallOutput.update?.messages?.find((message: { type: string }) => message.type === 'tool')) {\n          toolCallOutput = toolCallOutput.update?.messages?.find((message: { type: string }) => message.type === 'tool')\n        }\n\n        if (toolCallOutput && toolCallOutput.update?.messages?.length) {\n          type MessageFields = ToolMessageFieldsWithToolCallId & { type: string }\n          toolCallOutput.update?.messages.filter((message: MessageFields) => message.type === 'tool').forEach((message: MessageFields) => {\n            if (!this.activeRun!.hasFunctionStreaming) {\n              this.dispatchEvent({\n                type: EventType.TOOL_CALL_START,\n                toolCallId: message.tool_call_id,\n                toolCallName: message.name ?? '',\n                parentMessageId: message.id,\n                rawEvent: event,\n              })\n              this.dispatchEvent({\n                type: EventType.TOOL_CALL_ARGS,\n                toolCallId: message.tool_call_id,\n                delta: JSON.stringify(event.data.input),\n                rawEvent: event,\n              });\n            }\n\n            this.dispatchEvent({\n              type: EventType.TOOL_CALL_RESULT,\n              toolCallId: message.tool_call_id,\n              content: typeof message?.content === 'string' ? message?.content : JSON.stringify(message?.content),\n              messageId: randomUUID(),\n              rawEvent: event,\n              role: \"tool\",\n            })\n          })\n\n          break;\n        }\n\n        if (!this.activeRun!.hasFunctionStreaming) {\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_START,\n            toolCallId: toolCallOutput.tool_call_id,\n            toolCallName: toolCallOutput.name,\n            parentMessageId: toolCallOutput.id,\n            rawEvent: event,\n          })\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_ARGS,\n            toolCallId: toolCallOutput.tool_call_id,\n            delta: JSON.stringify(event.data.input),\n            rawEvent: event,\n          });\n          this.dispatchEvent({\n            type: EventType.TOOL_CALL_END,\n            toolCallId: toolCallOutput.tool_call_id,\n            rawEvent: event,\n          });\n        }\n\n        const content: string = Array.isArray(toolCallOutput.content)\n          ? toolCallOutput.content\n              .map((block: any) => {\n                if (typeof block === \"string\") return block;\n                if (block.type === \"text\") return block.text;\n                return JSON.stringify(block);\n              })\n              .join(\"\")\n          : toolCallOutput.content;\n\n        this.dispatchEvent({\n          type: EventType.TOOL_CALL_RESULT,\n          toolCallId: toolCallOutput.tool_call_id,\n          content,\n          messageId: randomUUID(),\n          role: \"tool\",\n          rawEvent: event,\n        })\n        break;\n    }\n  }\n\n  // Request cancellation of the current run via LangGraph Platform SDK\n  public abortRun() {\n    this.cancelRequested = true;\n    const threadId = this.activeRun?.threadId;\n    const runId = this.activeRun?.id;\n    if (threadId && runId && !this.cancelSent) {\n      void this.client.runs\n        .cancel(threadId, runId)\n        .then(() => {\n          this.cancelSent = true;\n        })\n        .catch(() => {\n          // Ignore cancellation errors; streaming loop will also check cancelRequested\n        });\n    }\n    super.abortRun();\n  }\n\n  handleThinkingEvent(reasoningData: LangGraphReasoning) {\n    if (!reasoningData || !reasoningData.type || !reasoningData.text) {\n      return;\n    }\n\n    const thinkingStepIndex = reasoningData.index;\n\n    if (this.thinkingProcess?.index && this.thinkingProcess.index !== thinkingStepIndex) {\n      if (this.thinkingProcess.type) {\n        this.dispatchEvent({\n          type: EventType.THINKING_TEXT_MESSAGE_END,\n        });\n      }\n      this.dispatchEvent({\n        type: EventType.THINKING_END,\n      });\n      this.thinkingProcess = null;\n    }\n\n    if (!this.thinkingProcess) {\n      // No thinking step yet. Start a new one\n      this.dispatchEvent({\n        type: EventType.THINKING_START,\n      });\n      this.thinkingProcess = {\n        index: thinkingStepIndex,\n      };\n    }\n\n    if (this.thinkingProcess.type !== reasoningData.type) {\n      this.dispatchEvent({\n        type: EventType.THINKING_TEXT_MESSAGE_START,\n      });\n      this.thinkingProcess.type = reasoningData.type;\n    }\n\n    if (this.thinkingProcess.type) {\n      this.dispatchEvent({\n        type: EventType.THINKING_TEXT_MESSAGE_CONTENT,\n        delta: reasoningData.text,\n      });\n    }\n  }\n\n  getStateSnapshot(threadState: ThreadState<State>) {\n    let state = threadState.values;\n    const schemaKeys = this.activeRun!.schemaKeys!;\n    // Do not emit state keys that are not part of the output schema\n    if (schemaKeys?.output) {\n      state = filterObjectBySchemaKeys(state, [...this.constantSchemaKeys, ...schemaKeys.output]);\n    }\n    // return state\n    return state;\n  }\n\n  async getOrCreateThread(threadId: string, threadMetadata?: Record<string, any>): Promise<Thread> {\n    let thread: Thread;\n    try {\n      try {\n        thread = await this.getThread(threadId);\n      } catch (error) {\n        thread = await this.createThread({\n          threadId,\n          metadata: threadMetadata,\n        });\n      }\n    } catch (error: unknown) {\n      throw new Error(`Failed to create thread: ${(error as Error).message}`);\n    }\n\n    return thread;\n  }\n\n  async getThread(threadId: string) {\n    return this.client.threads.get(threadId);\n  }\n\n  async createThread(payload?: Parameters<typeof this.client.threads.create>[0]) {\n    return this.client.threads.create(payload);\n  }\n\n  async mergeConfigs({\n    configs,\n    assistant,\n    schemaKeys,\n  }: {\n    configs: Config[];\n    assistant: Assistant;\n    schemaKeys: SchemaKeys;\n  }) {\n    return configs.reduce((acc, cfg) => {\n      let filteredConfigurable = acc.configurable;\n\n      if (cfg.configurable) {\n        filteredConfigurable = schemaKeys?.config\n          ? filterObjectBySchemaKeys(cfg?.configurable, [\n              ...this.constantSchemaKeys,\n              ...(schemaKeys?.config ?? []),\n            ])\n          : cfg?.configurable;\n      }\n\n      const newConfig = {\n        ...acc,\n        ...cfg,\n        configurable: filteredConfigurable,\n      };\n\n      // LG does not return recursion limit if it's the default, therefore we check: if no recursion limit is currently set, and the user asked for 25, there is no change.\n      const isRecursionLimitSetToDefault =\n        acc.recursion_limit == null && cfg.recursion_limit === 25;\n      // Deep compare configs to avoid unnecessary update calls\n      const configsAreDifferent = JSON.stringify(newConfig) !== JSON.stringify(acc);\n\n      // Check if the only difference is the recursion_limit being set to default\n      const isOnlyRecursionLimitDifferent =\n        isRecursionLimitSetToDefault &&\n        JSON.stringify({ ...newConfig, recursion_limit: null }) ===\n          JSON.stringify({ ...acc, recursion_limit: null });\n\n      if (configsAreDifferent && !isOnlyRecursionLimitDifferent) {\n        return {\n          ...acc,\n          ...newConfig,\n        };\n      }\n\n      return acc;\n    }, assistant.config);\n  }\n\n  getMessageInProgress(runId: string) {\n    return this.messagesInProcess[runId];\n  }\n\n  setMessageInProgress(runId: string, data: MessageInProgress) {\n    this.messagesInProcess = {\n      ...this.messagesInProcess,\n      [runId]: {\n        ...(this.messagesInProcess[runId] as MessageInProgress),\n        ...data,\n      },\n    };\n  }\n\n  async getAssistant(): Promise<Assistant> {\n    try {\n      const assistants = await this.client.assistants.search();\n      const retrievedAssistant = assistants.find(\n        (searchResult) => searchResult.graph_id === this.graphId,\n      );\n      if (!retrievedAssistant) {\n        const notFoundMessage = `\n      No agent found with graph ID ${this.graphId} found..\\n\n\n      These are the available agents: [${assistants.map((a) => `${a.graph_id} (ID: ${a.assistant_id})`).join(\", \")}]\n      `\n        console.error(notFoundMessage);\n        throw new Error(notFoundMessage);\n      }\n\n      return retrievedAssistant;\n    } catch (error) {\n      const redefinedError = new Error(`Failed to retrieve assistant: ${(error as Error).message}`)\n      this.dispatchEvent({\n        type: EventType.RUN_ERROR,\n        message: redefinedError.message,\n      });\n      this.subscriber.error()\n      throw redefinedError;\n    }\n  }\n\n  async getSchemaKeys(): Promise<SchemaKeys> {\n    try {\n      const graphSchema = await this.client.assistants.getSchemas(this.assistant!.assistant_id);\n      let configSchema = null;\n      let contextSchema: string[] = []\n      if ('context_schema' in graphSchema && graphSchema.context_schema?.properties) {\n        contextSchema = Object.keys(graphSchema.context_schema.properties);\n      }\n      if (graphSchema.config_schema?.properties) {\n        configSchema = Object.keys(graphSchema.config_schema.properties);\n      }\n      if (!graphSchema.input_schema?.properties || !graphSchema.output_schema?.properties) {\n        return { config: [], input: null, output: null, context: contextSchema };\n      }\n      const inputSchema = Object.keys(graphSchema.input_schema.properties);\n      const outputSchema = Object.keys(graphSchema.output_schema.properties);\n\n      return {\n        input:\n          inputSchema && inputSchema.length ? [...inputSchema, ...this.constantSchemaKeys] : null,\n        output:\n          outputSchema && outputSchema.length\n            ? [...outputSchema, ...this.constantSchemaKeys]\n            : null,\n        context: contextSchema,\n        config: configSchema,\n      };\n    } catch (e) {\n      return { config: [], input: this.constantSchemaKeys, output: this.constantSchemaKeys, context: [] };\n    }\n  }\n\n  langGraphDefaultMergeState(state: State, messages: LangGraphMessage[], input: RunAgentExtendedInput): State<StateEnrichment> {\n    if (messages.length > 0 && \"role\" in messages[0] && messages[0].role === \"system\") {\n      // remove system message\n      messages = messages.slice(1);\n    }\n\n    // merge with existing messages\n    const existingMessages: LangGraphPlatformMessage[] = state.messages || [];\n    const existingMessageIds = new Set(existingMessages.map((message) => message.id));\n\n    const newMessages = messages.filter((message) => !existingMessageIds.has(message.id));\n\n    const langGraphTools: LangGraphToolWithName[] = [...(state.tools ?? []), ...(input.tools ?? [])].reduce((acc, tool) => {\n      let mappedTool = tool;\n      if (!tool.type) {\n        mappedTool = {\n            type: \"function\",\n            name: tool.name,\n            function: {\n                name: tool.name,\n                description: tool.description,\n                parameters: tool.parameters,\n            },\n        }\n      }\n\n      // Verify no duplicated\n      if (acc.find((t: LangGraphToolWithName) => (t.name === mappedTool.name) || t.function.name === mappedTool.function.name)) return acc;\n\n      return [...acc, mappedTool];\n    }, []);\n\n    return {\n      ...state,\n      messages: newMessages,\n      tools: langGraphTools,\n      'ag-ui': {\n        tools: langGraphTools,\n        context: input.context,\n      }\n    };\n  }\n\n  handleNodeChange(nodeName: string | undefined) {\n    if (nodeName === \"__end__\") {\n      nodeName = undefined;\n    }\n    if (nodeName !== this.activeRun?.nodeName) {\n      // End current step\n      if (this.activeRun?.nodeName) {\n        this.endStep();\n      }\n      // If we actually got a node name, start a new step\n      if (nodeName) {\n        this.startStep(nodeName);\n      }\n    }\n    this.activeRun!.nodeName = nodeName;\n  }\n\n  startStep(nodeName: string) {\n    this.dispatchEvent({\n      type: EventType.STEP_STARTED,\n      stepName: nodeName,\n    });\n  }\n\n  endStep() {\n    this.dispatchEvent({\n      type: EventType.STEP_FINISHED,\n      stepName: this.activeRun!.nodeName!,\n    });\n  }\n\n  async getCheckpointByMessage(\n    messageId: string,\n    threadId: string,\n    checkpoint?: null | {\n      checkpoint_id?: null | string;\n      checkpoint_ns: string;\n    },\n  ): Promise<ThreadState> {\n    const options = checkpoint?.checkpoint_id\n      ? {\n          checkpoint: { checkpoint_id: checkpoint.checkpoint_id },\n        }\n      : undefined;\n    const history = await this.client.threads.getHistory(threadId, options);\n    const reversed = [...history].reverse(); // oldest â†’ newest\n\n    let targetState = reversed.find((state) =>\n      (state.values as State).messages?.some((m: LangGraphPlatformMessage) => m.id === messageId),\n    );\n\n    if (!targetState) throw new Error(\"Message not found\");\n\n    const targetStateMessages = (targetState.values as State).messages ?? [];\n    const messageIndex = targetStateMessages.findIndex(\n      (m: LangGraphPlatformMessage) => m.id === messageId,\n    );\n    const messagesAfter = targetStateMessages.slice(messageIndex + 1);\n    if (messagesAfter.length) {\n      return this.getCheckpointByMessage(messageId, threadId, targetState.parent_checkpoint);\n    }\n\n    const targetStateIndex = reversed.indexOf(targetState);\n\n    const { messages, ...targetStateValuesWithoutMessages } = targetState.values as State;\n    const selectedCheckpoint = reversed[targetStateIndex - 1] ?? { ...targetState, values: {} };\n    return {\n      ...selectedCheckpoint,\n      values: { ...selectedCheckpoint.values, ...targetStateValuesWithoutMessages },\n    };\n  }\n}\n\nexport * from \"./types\";\n","import { AssistantGraph, Message as LangGraphMessage } from \"@langchain/langgraph-sdk\";\nimport { MessageType } from \"@langchain/core/messages\";\nimport { RunAgentInput } from \"@ag-ui/core\";\n\nexport enum LangGraphEventTypes {\n  OnChainStart = \"on_chain_start\",\n  OnChainStream = \"on_chain_stream\",\n  OnChainEnd = \"on_chain_end\",\n  OnChatModelStart = \"on_chat_model_start\",\n  OnChatModelStream = \"on_chat_model_stream\",\n  OnChatModelEnd = \"on_chat_model_end\",\n  OnToolStart = \"on_tool_start\",\n  OnToolEnd = \"on_tool_end\",\n  OnCustomEvent = \"on_custom_event\",\n  OnInterrupt = \"on_interrupt\",\n}\n\nexport type LangGraphToolWithName = {\n  type: \"function\";\n  name?: string;\n  function: {\n    name: string;\n    description: string;\n    parameters: any;\n  },\n}\n\nexport type State<TDefinedState = Record<string, any>> = {\n  [k in keyof TDefinedState]: TDefinedState[k] | null;\n} & Record<string, any>;\nexport interface StateEnrichment {\n  messages: LangGraphMessage[];\n  tools: LangGraphToolWithName[];\n  'ag-ui': {\n    tools: LangGraphToolWithName[];\n    context: RunAgentInput['context']\n  }\n}\n\nexport type SchemaKeys = {\n  input: string[] | null;\n  output: string[] | null;\n  context: string[] | null;\n  config: string[] | null;\n} | null;\n\nexport type MessageInProgress = {\n  id: string;\n  toolCallId?: string | null;\n  toolCallName?: string | null;\n};\n\nexport type ThinkingInProgress = {\n  index: number;\n  type?: LangGraphReasoning['type'];\n}\n\nexport interface RunMetadata {\n  id: string;\n  schemaKeys?: SchemaKeys;\n  nodeName?: string;\n  prevNodeName?: string | null;\n  exitingNode?: boolean;\n  manuallyEmittedState?: State | null;\n  threadId?: string;\n  graphInfo?: AssistantGraph\n  hasFunctionStreaming?: boolean;\n  // True once the platform-assigned run id is known (set from stream metadata)\n  serverRunIdKnown?: boolean;\n}\n\nexport type MessagesInProgressRecord = Record<string, MessageInProgress | null>;\n\n// The following types are our own definition to the messages accepted by LangGraph Platform, enhanced with some of our extra data.\nexport interface ToolCall {\n  id: string;\n  name: string;\n  args: Record<string, unknown>;\n}\n\ntype BaseLangGraphPlatformMessage = Omit<\n  LangGraphMessage,\n  | \"isResultMessage\"\n  | \"isTextMessage\"\n  | \"isImageMessage\"\n  | \"isActionExecutionMessage\"\n  | \"isAgentStateMessage\"\n  | \"type\"\n  | \"createdAt\"\n> & {\n  content: string;\n  role: string;\n  additional_kwargs?: Record<string, unknown>;\n  type: MessageType;\n};\n\ninterface LangGraphPlatformResultMessage extends BaseLangGraphPlatformMessage {\n  tool_call_id: string;\n  name: string;\n}\n\ninterface LangGraphPlatformActionExecutionMessage extends BaseLangGraphPlatformMessage {\n  tool_calls: ToolCall[];\n}\n\nexport type LangGraphPlatformMessage =\n  | LangGraphPlatformActionExecutionMessage\n  | LangGraphPlatformResultMessage\n  | BaseLangGraphPlatformMessage;\n\nexport enum CustomEventNames {\n  ManuallyEmitMessage = \"manually_emit_message\",\n  ManuallyEmitToolCall = \"manually_emit_tool_call\",\n  ManuallyEmitState = \"manually_emit_state\",\n  Exit = \"exit\",\n}\n\nexport interface PredictStateTool {\n  tool: string;\n  state_key: string;\n  tool_argument: string;\n}\n\nexport interface LangGraphReasoning {\n  type: 'text';\n  text: string;\n  index: number\n}\n","import { Message as LangGraphMessage } from \"@langchain/langgraph-sdk\";\nimport { State, SchemaKeys, LangGraphReasoning } from \"./types\";\nimport { Message, ToolCall, TextInputContent, BinaryInputContent, InputContent , UserMessage} from \"@ag-ui/client\";\n\nexport const DEFAULT_SCHEMA_KEYS = [\"messages\", \"tools\"];\n\nexport function filterObjectBySchemaKeys(obj: Record<string, any>, schemaKeys: string[]) {\n  return Object.fromEntries(Object.entries(obj).filter(([key]) => schemaKeys.includes(key)));\n}\n\nexport function getStreamPayloadInput({\n  mode,\n  state,\n  schemaKeys,\n}: {\n  mode: \"start\" | \"continue\";\n  state: State;\n  schemaKeys: SchemaKeys;\n}) {\n  let input = mode === \"start\" ? state : null;\n  // Do not input keys that are not part of the input schema\n  if (input && schemaKeys?.input) {\n    input = filterObjectBySchemaKeys(input, [...DEFAULT_SCHEMA_KEYS, ...schemaKeys.input]);\n  }\n\n  return input;\n}\n\n/**\n * Convert LangChain's multimodal content to AG-UI format\n */\nfunction convertLangchainMultimodalToAgui(\n  content: Array<{ type: string; text?: string; image_url?: any }>\n): InputContent[] {\n  const aguiContent: InputContent[] = [];\n\n  for (const item of content) {\n    if (item.type === \"text\" && item.text) {\n      aguiContent.push({\n        type: \"text\",\n        text: item.text,\n      });\n    } else if (item.type === \"image_url\") {\n      const imageUrl = typeof item.image_url === \"string\"\n        ? item.image_url\n        : item.image_url?.url;\n\n      if (!imageUrl) continue;\n\n      // Parse data URLs to extract base64 data\n      if (imageUrl.startsWith(\"data:\")) {\n        // Format: data:mime_type;base64,data\n        const [header, data] = imageUrl.split(\",\", 2);\n        const mimeType = header.includes(\":\")\n          ? header.split(\":\")[1].split(\";\")[0]\n          : \"image/png\";\n\n        aguiContent.push({\n          type: \"binary\",\n          mimeType,\n          data: data || \"\",\n        });\n      } else {\n        // Regular URL or ID\n        aguiContent.push({\n          type: \"binary\",\n          mimeType: \"image/png\", // Default MIME type\n          url: imageUrl,\n        });\n      }\n    }\n  }\n\n  return aguiContent;\n}\n\n/**\n * Convert AG-UI multimodal content to LangChain's format\n */\nfunction convertAguiMultimodalToLangchain(\n  content: InputContent[]\n): Array<{ type: string; text?: string; image_url?: { url: string } }> {\n  const langchainContent: Array<{ type: string; text?: string; image_url?: { url: string } }> = [];\n\n  for (const item of content) {\n    if (item.type === \"text\") {\n      langchainContent.push({\n        type: \"text\",\n        text: item.text,\n      });\n    } else if (item.type === \"binary\") {\n      // LangChain uses image_url format (OpenAI-style)\n      let url: string;\n\n      // Prioritize url, then data, then id\n      if (item.url) {\n        url = item.url;\n      } else if (item.data) {\n        // Construct data URL from base64 data\n        url = `data:${item.mimeType};base64,${item.data}`;\n      } else if (item.id) {\n        // Use id as a reference\n        url = item.id;\n      } else {\n        continue; // Skip if no source is provided\n      }\n\n      langchainContent.push({\n        type: \"image_url\",\n        image_url: { url },\n      });\n    }\n  }\n\n  return langchainContent;\n}\n\nexport function langchainMessagesToAgui(messages: LangGraphMessage[]): Message[] {\n  return messages.map((message) => {\n    switch (message.type) {\n      case \"human\":\n        // Handle multimodal content\n        let userContent: string | InputContent[];\n        if (Array.isArray(message.content)) {\n          userContent = convertLangchainMultimodalToAgui(message.content as any);\n        } else {\n          userContent = stringifyIfNeeded(resolveMessageContent(message.content));\n        }\n\n        return {\n          id: message.id!,\n          role: \"user\",\n          content: userContent,\n        };\n      case \"ai\":\n        const aiContent = resolveMessageContent(message.content)\n        return {\n          id: message.id!,\n          role: \"assistant\",\n          content: aiContent ? stringifyIfNeeded(aiContent) : '',\n          toolCalls: message.tool_calls?.map((tc) => ({\n            id: tc.id!,\n            type: \"function\",\n            function: {\n              name: tc.name,\n              arguments: JSON.stringify(tc.args),\n            },\n          })),\n        };\n      case \"system\":\n        return {\n          id: message.id!,\n          role: \"system\",\n          content: stringifyIfNeeded(resolveMessageContent(message.content)),\n        };\n      case \"tool\":\n        return {\n          id: message.id!,\n          role: \"tool\",\n          content: stringifyIfNeeded(resolveMessageContent(message.content)),\n          toolCallId: message.tool_call_id,\n        };\n      default:\n        throw new Error(\"message type returned from LangGraph is not supported.\");\n    }\n  });\n}\n\nexport function aguiMessagesToLangChain(messages: Message[]): LangGraphMessage[] {\n  return messages.map((message, index) => {\n    switch (message.role) {\n      case \"user\":\n        // Handle multimodal content\n        let content: UserMessage['content'];\n        if (typeof message.content === \"string\") {\n          content = message.content;\n        } else if (Array.isArray(message.content)) {\n          content = convertAguiMultimodalToLangchain(message.content) as any;\n        } else {\n          content = String(message.content);\n        }\n\n        return {\n          id: message.id,\n          role: message.role,\n          content,\n          type: \"human\",\n        } as LangGraphMessage;\n      case \"assistant\":\n        return {\n          id: message.id,\n          type: \"ai\",\n          role: message.role,\n          content: message.content ?? \"\",\n          tool_calls: (message.toolCalls ?? []).map((tc: ToolCall) => ({\n            id: tc.id,\n            name: tc.function.name,\n            args: JSON.parse(tc.function.arguments),\n            type: \"tool_call\",\n          })),\n        };\n      case \"system\":\n        return {\n          id: message.id,\n          role: message.role,\n          content: message.content,\n          type: \"system\",\n        };\n      case \"tool\":\n        return {\n          content: message.content,\n          role: message.role,\n          type: message.role,\n          tool_call_id: message.toolCallId,\n          id: message.id,\n        };\n      default:\n        console.error(`Message role ${message.role} is not implemented`);\n        throw new Error(\"message role is not supported.\");\n    }\n  });\n}\n\nfunction stringifyIfNeeded(item: any) {\n  if (typeof item === \"string\") return item;\n  return JSON.stringify(item);\n}\n\n/**\n * Flatten multimodal content into plain text.\n * Used for backwards compatibility or when multimodal is not supported.\n */\nfunction flattenUserContent(content: Message[\"content\"]): string {\n  if (typeof content === \"string\") {\n    return content;\n  }\n\n  if (!Array.isArray(content)) {\n    return \"\";\n  }\n\n  const parts: string[] = [];\n\n  for (const item of content) {\n    if (item.type === \"text\" && \"text\" in item) {\n      if (item.text) {\n        parts.push(item.text);\n      }\n    } else if (item.type === \"binary\" && \"mimeType\" in item) {\n      // Add descriptive placeholder for binary content\n      const binaryItem = item as BinaryInputContent;\n      if (binaryItem.filename) {\n        parts.push(`[Binary content: ${binaryItem.filename}]`);\n      } else if (binaryItem.url) {\n        parts.push(`[Binary content: ${binaryItem.url}]`);\n      } else {\n        parts.push(`[Binary content: ${binaryItem.mimeType}]`);\n      }\n    }\n  }\n\n  return parts.join(\"\\n\");\n}\n\nexport function resolveReasoningContent(eventData: any): LangGraphReasoning | null {\n  const content = eventData.chunk?.content\n\n  // Anthropic reasoning response\n  if (content && Array.isArray(content) && content.length && content[0]) {\n    if (!content[0].thinking) return null\n    return {\n      text: content[0].thinking,\n      type: 'text',\n      index: content[0].index,\n    }\n  }\n\n  /// OpenAI reasoning response\n  if (eventData.chunk.additional_kwargs?.reasoning?.summary?.[0]) {\n    const data = eventData.chunk.additional_kwargs?.reasoning.summary[0]\n    if (!data || !data.text) return null\n    return {\n      type: 'text',\n      text: data.text,\n      index: data.index,\n    }\n  }\n\n  return null\n}\n\nexport function resolveMessageContent(content?: LangGraphMessage['content']): string | null {\n  if (!content) return null;\n\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (Array.isArray(content) && content.length) {\n    const contentText = content.find(c => c.type === 'text')?.text\n    return contentText ?? null;\n  }\n\n  return null\n}\n"],"mappings":"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","names":["HttpAgent","Observable","LangGraphClient","randomUUID","LangGraphEventTypes","CustomEventNames","AbstractAgent","EventType","DEFAULT_SCHEMA_KEYS","filterObjectBySchemaKeys","obj","schemaKeys","key","getStreamPayloadInput","mode","state","input","convertLangchainMultimodalToAgui","content","_a","aguiContent","item","imageUrl","header","data","mimeType","convertAguiMultimodalToLangchain","langchainContent","url","langchainMessagesToAgui","messages","message","userContent","stringifyIfNeeded","resolveMessageContent","aiContent","tc","aguiMessagesToLangChain","index","_b","resolveReasoningContent","eventData","_a","_b","_c","_d","_e","content","data","resolveMessageContent","contentText","c","LangGraphAgent","_LangGraphAgent","AbstractAgent","config","_a","_b","DEFAULT_SCHEMA_KEYS","LangGraphClient","__spreadValues","event","input","Observable","subscriber","_c","threadId","randomUUID","streamMode","preparedStream","__spreadProps","messageCheckpoint","timeTravelCheckpoint","fork","payload","_d","_e","_g","_h","_i","_j","_k","inputThreadId","inputState","messages","tools","context","forwardedProps","nodeNameInput","thread","agentState","agentStateMessages","inputMessagesToLangchain","aguiMessagesToLangChain","stateValuesDiff","threadState","stateValues","m","lastUserMessage","i","mode","nodeBefore","e","payloadInput","getStreamPayloadInput","payloadConfig","configsToMerge","_f","command","restProps","__objRest","interrupts","EventType","interrupt","stream","streamModes","_l","_m","_n","shouldExit","streamResponse","state","latestStateValues","updatedState","iter","__forAwait","more","temp","error","streamResponseChunk","_","subgraphsStreamEnabled","isSubgraphStream","chunk","chunkData","metadata","currentNodeName","eventType","node","tasks","isEndNode","writes","newNodeName","langchainMessagesToAgui","shouldEmitMessages","shouldEmitToolCalls","currentStream","hasCurrentStream","toolCallData","toolCallUsedToPredictState","predictStateTool","isToolCallStartEvent","isToolCallArgsEvent","isToolCallEndEvent","reasoningData","resolveReasoningContent","messageContent","resolveMessageContent","isMessageContentEvent","isMessageEndEvent","toolCallOutput","message","content","block","runId","thinkingStepIndex","schemaKeys","filterObjectBySchemaKeys","threadMetadata","configs","assistant","acc","cfg","filteredConfigurable","newConfig","isRecursionLimitSetToDefault","configsAreDifferent","isOnlyRecursionLimitDifferent","data","assistants","retrievedAssistant","searchResult","notFoundMessage","a","redefinedError","graphSchema","configSchema","contextSchema","inputSchema","outputSchema","existingMessages","existingMessageIds","newMessages","langGraphTools","tool","mappedTool","t","nodeName","messageId","checkpoint","options","reversed","targetState","targetStateMessages","messageIndex","targetStateIndex","targetStateValuesWithoutMessages","selectedCheckpoint","LangGraphHttpAgent","HttpAgent"]}