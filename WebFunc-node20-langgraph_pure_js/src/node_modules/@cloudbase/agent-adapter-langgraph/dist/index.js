"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../../observability/dist/chunk-NFEGQTCC.mjs
var __defProp2, __getOwnPropDesc2, __getOwnPropNames2, __hasOwnProp2, __esm2, __export2, __copyProps2, __toCommonJS2;
var init_chunk_NFEGQTCC = __esm({
  "../../observability/dist/chunk-NFEGQTCC.mjs"() {
    "use strict";
    __defProp2 = Object.defineProperty;
    __getOwnPropDesc2 = Object.getOwnPropertyDescriptor;
    __getOwnPropNames2 = Object.getOwnPropertyNames;
    __hasOwnProp2 = Object.prototype.hasOwnProperty;
    __esm2 = (fn, res) => function __init() {
      return fn && (res = (0, fn[__getOwnPropNames2(fn)[0]])(fn = 0)), res;
    };
    __export2 = (target, all) => {
      for (var name in all)
        __defProp2(target, name, { get: all[name], enumerable: true });
    };
    __copyProps2 = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames2(from))
          if (!__hasOwnProp2.call(to, key) && key !== except)
            __defProp2(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc2(from, key)) || desc.enumerable });
      }
      return to;
    };
    __toCommonJS2 = (mod) => __copyProps2(__defProp2({}, "__esModule", { value: true }), mod);
  }
});

// ../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/dist/esm/trace/SemanticConventions.js
var SemanticAttributePrefixes, LLMAttributePostfixes, RetrievalAttributePostfixes, RerankerAttributePostfixes, EmbeddingAttributePostfixes, ToolAttributePostfixes, MessageAttributePostfixes, MessageContentsAttributePostfixes, ImageAttributesPostfixes, ToolCallAttributePostfixes, DocumentAttributePostfixes, TagAttributePostfixes, SessionAttributePostfixes, UserAttributePostfixes, AudioAttributesPostfixes, PromptAttributePostfixes, AgentPostfixes, GraphPostfixes, INPUT_VALUE, INPUT_MIME_TYPE, OUTPUT_VALUE, OUTPUT_MIME_TYPE, LLM_INPUT_MESSAGES, LLM_PROMPTS, LLM_INVOCATION_PARAMETERS, LLM_OUTPUT_MESSAGES, LLM_MODEL_NAME, LLM_PROVIDER, LLM_SYSTEM, LLM_TOKEN_COUNT_COMPLETION, LLM_TOKEN_COUNT_COMPLETION_DETAILS_REASONING, LLM_TOKEN_COUNT_COMPLETION_DETAILS_AUDIO, LLM_TOKEN_COUNT_PROMPT, LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_WRITE, LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_READ, LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_INPUT, LLM_TOKEN_COUNT_PROMPT_DETAILS_AUDIO, LLM_TOKEN_COUNT_TOTAL, LLM_TOKEN_COUNT_PROMPT_DETAILS, LLM_TOKEN_COUNT_COMPLETION_DETAILS, LLM_COST, LLM_COST_PROMPT, LLM_COST_COMPLETION, LLM_COST_TOTAL, LLM_COST_INPUT, LLM_COST_OUTPUT, LLM_COST_COMPLETION_DETAILS_REASONING, LLM_COST_COMPLETION_DETAILS_AUDIO, LLM_COST_PROMPT_DETAILS_CACHE_WRITE, LLM_COST_PROMPT_DETAILS_CACHE_READ, LLM_COST_PROMPT_DETAILS_CACHE_INPUT, LLM_COST_PROMPT_DETAILS_AUDIO, MESSAGE_ROLE, MESSAGE_NAME, MESSAGE_TOOL_CALLS, MESSAGE_TOOL_CALL_ID, TOOL_CALL_FUNCTION_NAME, TOOL_CALL_FUNCTION_ARGUMENTS_JSON, TOOL_CALL_ID, MESSAGE_FUNCTION_CALL_NAME, MESSAGE_FUNCTION_CALL_ARGUMENTS_JSON, MESSAGE_CONTENT, MESSAGE_CONTENTS, MESSAGE_CONTENT_TYPE, MESSAGE_CONTENT_TEXT, MESSAGE_CONTENT_IMAGE, IMAGE_URL, DOCUMENT_ID, DOCUMENT_CONTENT, DOCUMENT_SCORE, DOCUMENT_METADATA, EMBEDDING_TEXT, EMBEDDING_MODEL_NAME, EMBEDDING_VECTOR, EMBEDDING_EMBEDDINGS, RETRIEVAL_DOCUMENTS, PROMPT_TEMPLATE_PREFIX, PROMPT_TEMPLATE_VARIABLES, PROMPT_TEMPLATE_TEMPLATE, LLM_FUNCTION_CALL, LLM_TOOLS, TOOL_NAME, TOOL_DESCRIPTION, TOOL_PARAMETERS, TOOL_JSON_SCHEMA, SESSION_ID, USER_ID, RERANKER_INPUT_DOCUMENTS, RERANKER_OUTPUT_DOCUMENTS, RERANKER_QUERY, RERANKER_MODEL_NAME, RERANKER_TOP_K, METADATA, PROMPT_TEMPLATE_VERSION, TAG_TAGS, AUDIO_URL, AUDIO_MIME_TYPE, AUDIO_TRANSCRIPT, PROMPT_VENDOR, PROMPT_ID, PROMPT_URL, AGENT_NAME, GRAPH_NODE_ID, GRAPH_NODE_NAME, GRAPH_NODE_PARENT_ID, SemanticConventions, OpenInferenceSpanKind, MimeType, LLMSystem, LLMProvider;
var init_SemanticConventions = __esm({
  "../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/dist/esm/trace/SemanticConventions.js"() {
    "use strict";
    SemanticAttributePrefixes = {
      input: "input",
      output: "output",
      llm: "llm",
      retrieval: "retrieval",
      reranker: "reranker",
      messages: "messages",
      message: "message",
      document: "document",
      embedding: "embedding",
      tool: "tool",
      tool_call: "tool_call",
      metadata: "metadata",
      tag: "tag",
      session: "session",
      user: "user",
      openinference: "openinference",
      message_content: "message_content",
      image: "image",
      audio: "audio",
      prompt: "prompt",
      agent: "agent",
      graph: "graph"
    };
    LLMAttributePostfixes = {
      provider: "provider",
      system: "system",
      model_name: "model_name",
      token_count: "token_count",
      input_messages: "input_messages",
      output_messages: "output_messages",
      invocation_parameters: "invocation_parameters",
      prompts: "prompts",
      prompt_template: "prompt_template",
      function_call: "function_call",
      tools: "tools",
      cost: "cost"
    };
    RetrievalAttributePostfixes = {
      documents: "documents"
    };
    RerankerAttributePostfixes = {
      input_documents: "input_documents",
      output_documents: "output_documents",
      query: "query",
      model_name: "model_name",
      top_k: "top_k"
    };
    EmbeddingAttributePostfixes = {
      embeddings: "embeddings",
      text: "text",
      model_name: "model_name",
      vector: "vector"
    };
    ToolAttributePostfixes = {
      name: "name",
      description: "description",
      parameters: "parameters",
      json_schema: "json_schema"
    };
    MessageAttributePostfixes = {
      role: "role",
      content: "content",
      contents: "contents",
      name: "name",
      function_call_name: "function_call_name",
      function_call_arguments_json: "function_call_arguments_json",
      tool_calls: "tool_calls",
      tool_call_id: "tool_call_id"
    };
    MessageContentsAttributePostfixes = {
      type: "type",
      text: "text",
      image: "image"
    };
    ImageAttributesPostfixes = {
      url: "url"
    };
    ToolCallAttributePostfixes = {
      function_name: "function.name",
      function_arguments_json: "function.arguments",
      id: "id"
    };
    DocumentAttributePostfixes = {
      id: "id",
      content: "content",
      score: "score",
      metadata: "metadata"
    };
    TagAttributePostfixes = {
      tags: "tags"
    };
    SessionAttributePostfixes = {
      id: "id"
    };
    UserAttributePostfixes = {
      id: "id"
    };
    AudioAttributesPostfixes = {
      url: "url",
      mime_type: "mime_type",
      transcript: "transcript"
    };
    PromptAttributePostfixes = {
      vendor: "vendor",
      id: "id",
      url: "url"
    };
    AgentPostfixes = {
      name: "name"
    };
    GraphPostfixes = {
      node_id: "node.id",
      node_name: "node.name",
      node_parent_id: "node.parent_id"
    };
    INPUT_VALUE = `${SemanticAttributePrefixes.input}.value`;
    INPUT_MIME_TYPE = `${SemanticAttributePrefixes.input}.mime_type`;
    OUTPUT_VALUE = `${SemanticAttributePrefixes.output}.value`;
    OUTPUT_MIME_TYPE = `${SemanticAttributePrefixes.output}.mime_type`;
    LLM_INPUT_MESSAGES = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.input_messages}`;
    LLM_PROMPTS = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.prompts}`;
    LLM_INVOCATION_PARAMETERS = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.invocation_parameters}`;
    LLM_OUTPUT_MESSAGES = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.output_messages}`;
    LLM_MODEL_NAME = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.model_name}`;
    LLM_PROVIDER = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.provider}`;
    LLM_SYSTEM = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.system}`;
    LLM_TOKEN_COUNT_COMPLETION = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion`;
    LLM_TOKEN_COUNT_COMPLETION_DETAILS_REASONING = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion_details.reasoning`;
    LLM_TOKEN_COUNT_COMPLETION_DETAILS_AUDIO = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion_details.audio`;
    LLM_TOKEN_COUNT_PROMPT = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt`;
    LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_WRITE = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.cache_write`;
    LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_READ = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.cache_read`;
    LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_INPUT = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.cache_input`;
    LLM_TOKEN_COUNT_PROMPT_DETAILS_AUDIO = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.audio`;
    LLM_TOKEN_COUNT_TOTAL = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.total`;
    LLM_TOKEN_COUNT_PROMPT_DETAILS = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details`;
    LLM_TOKEN_COUNT_COMPLETION_DETAILS = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion_details`;
    LLM_COST = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}`;
    LLM_COST_PROMPT = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt`;
    LLM_COST_COMPLETION = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion`;
    LLM_COST_TOTAL = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.total`;
    LLM_COST_INPUT = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.input`;
    LLM_COST_OUTPUT = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion_details.output`;
    LLM_COST_COMPLETION_DETAILS_REASONING = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion_details.reasoning`;
    LLM_COST_COMPLETION_DETAILS_AUDIO = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion_details.audio`;
    LLM_COST_PROMPT_DETAILS_CACHE_WRITE = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.cache_write`;
    LLM_COST_PROMPT_DETAILS_CACHE_READ = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.cache_read`;
    LLM_COST_PROMPT_DETAILS_CACHE_INPUT = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.cache_input`;
    LLM_COST_PROMPT_DETAILS_AUDIO = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.audio`;
    MESSAGE_ROLE = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.role}`;
    MESSAGE_NAME = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.name}`;
    MESSAGE_TOOL_CALLS = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.tool_calls}`;
    MESSAGE_TOOL_CALL_ID = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.tool_call_id}`;
    TOOL_CALL_FUNCTION_NAME = `${SemanticAttributePrefixes.tool_call}.${ToolCallAttributePostfixes.function_name}`;
    TOOL_CALL_FUNCTION_ARGUMENTS_JSON = `${SemanticAttributePrefixes.tool_call}.${ToolCallAttributePostfixes.function_arguments_json}`;
    TOOL_CALL_ID = `${SemanticAttributePrefixes.tool_call}.${ToolCallAttributePostfixes.id}`;
    MESSAGE_FUNCTION_CALL_NAME = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.function_call_name}`;
    MESSAGE_FUNCTION_CALL_ARGUMENTS_JSON = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.function_call_arguments_json}`;
    MESSAGE_CONTENT = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.content}`;
    MESSAGE_CONTENTS = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.contents}`;
    MESSAGE_CONTENT_TYPE = `${SemanticAttributePrefixes.message_content}.${MessageContentsAttributePostfixes.type}`;
    MESSAGE_CONTENT_TEXT = `${SemanticAttributePrefixes.message_content}.${MessageContentsAttributePostfixes.text}`;
    MESSAGE_CONTENT_IMAGE = `${SemanticAttributePrefixes.message_content}.${MessageContentsAttributePostfixes.image}`;
    IMAGE_URL = `${SemanticAttributePrefixes.image}.${ImageAttributesPostfixes.url}`;
    DOCUMENT_ID = `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.id}`;
    DOCUMENT_CONTENT = `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.content}`;
    DOCUMENT_SCORE = `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.score}`;
    DOCUMENT_METADATA = `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.metadata}`;
    EMBEDDING_TEXT = `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.text}`;
    EMBEDDING_MODEL_NAME = `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.model_name}`;
    EMBEDDING_VECTOR = `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.vector}`;
    EMBEDDING_EMBEDDINGS = `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.embeddings}`;
    RETRIEVAL_DOCUMENTS = `${SemanticAttributePrefixes.retrieval}.${RetrievalAttributePostfixes.documents}`;
    PROMPT_TEMPLATE_PREFIX = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.prompt_template}`;
    PROMPT_TEMPLATE_VARIABLES = `${PROMPT_TEMPLATE_PREFIX}.variables`;
    PROMPT_TEMPLATE_TEMPLATE = `${PROMPT_TEMPLATE_PREFIX}.template`;
    LLM_FUNCTION_CALL = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.function_call}`;
    LLM_TOOLS = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.tools}`;
    TOOL_NAME = `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.name}`;
    TOOL_DESCRIPTION = `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.description}`;
    TOOL_PARAMETERS = `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.parameters}`;
    TOOL_JSON_SCHEMA = `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.json_schema}`;
    SESSION_ID = `${SemanticAttributePrefixes.session}.${SessionAttributePostfixes.id}`;
    USER_ID = `${SemanticAttributePrefixes.user}.${UserAttributePostfixes.id}`;
    RERANKER_INPUT_DOCUMENTS = `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.input_documents}`;
    RERANKER_OUTPUT_DOCUMENTS = `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.output_documents}`;
    RERANKER_QUERY = `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.query}`;
    RERANKER_MODEL_NAME = `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.model_name}`;
    RERANKER_TOP_K = `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.top_k}`;
    METADATA = "metadata";
    PROMPT_TEMPLATE_VERSION = `${PROMPT_TEMPLATE_PREFIX}.version`;
    TAG_TAGS = `${SemanticAttributePrefixes.tag}.${TagAttributePostfixes.tags}`;
    AUDIO_URL = `${SemanticAttributePrefixes.audio}.${AudioAttributesPostfixes.url}`;
    AUDIO_MIME_TYPE = `${SemanticAttributePrefixes.audio}.${AudioAttributesPostfixes.mime_type}`;
    AUDIO_TRANSCRIPT = `${SemanticAttributePrefixes.audio}.${AudioAttributesPostfixes.transcript}`;
    PROMPT_VENDOR = `${SemanticAttributePrefixes.prompt}.${PromptAttributePostfixes.vendor}`;
    PROMPT_ID = `${SemanticAttributePrefixes.prompt}.${PromptAttributePostfixes.id}`;
    PROMPT_URL = `${SemanticAttributePrefixes.prompt}.${PromptAttributePostfixes.url}`;
    AGENT_NAME = `${SemanticAttributePrefixes.agent}.${AgentPostfixes.name}`;
    GRAPH_NODE_ID = `${SemanticAttributePrefixes.graph}.${GraphPostfixes.node_id}`;
    GRAPH_NODE_NAME = `${SemanticAttributePrefixes.graph}.${GraphPostfixes.node_name}`;
    GRAPH_NODE_PARENT_ID = `${SemanticAttributePrefixes.graph}.${GraphPostfixes.node_parent_id}`;
    SemanticConventions = {
      IMAGE_URL,
      INPUT_VALUE,
      INPUT_MIME_TYPE,
      OUTPUT_VALUE,
      OUTPUT_MIME_TYPE,
      LLM_INPUT_MESSAGES,
      LLM_OUTPUT_MESSAGES,
      LLM_MODEL_NAME,
      LLM_PROMPTS,
      LLM_INVOCATION_PARAMETERS,
      LLM_TOKEN_COUNT_COMPLETION,
      LLM_TOKEN_COUNT_COMPLETION_DETAILS,
      LLM_TOKEN_COUNT_COMPLETION_DETAILS_REASONING,
      LLM_TOKEN_COUNT_COMPLETION_DETAILS_AUDIO,
      LLM_TOKEN_COUNT_PROMPT,
      LLM_TOKEN_COUNT_PROMPT_DETAILS,
      LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_WRITE,
      LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_READ,
      LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_INPUT,
      LLM_TOKEN_COUNT_PROMPT_DETAILS_AUDIO,
      LLM_TOKEN_COUNT_TOTAL,
      LLM_SYSTEM,
      LLM_PROVIDER,
      LLM_TOOLS,
      LLM_COST,
      LLM_COST_PROMPT,
      LLM_COST_COMPLETION,
      LLM_COST_TOTAL,
      LLM_COST_INPUT,
      LLM_COST_OUTPUT,
      LLM_COST_COMPLETION_DETAILS_REASONING,
      LLM_COST_COMPLETION_DETAILS_AUDIO,
      LLM_COST_PROMPT_DETAILS_CACHE_WRITE,
      LLM_COST_PROMPT_DETAILS_CACHE_READ,
      LLM_COST_PROMPT_DETAILS_CACHE_INPUT,
      LLM_COST_PROMPT_DETAILS_AUDIO,
      MESSAGE_ROLE,
      MESSAGE_NAME,
      MESSAGE_TOOL_CALLS,
      MESSAGE_TOOL_CALL_ID,
      TOOL_CALL_ID,
      TOOL_CALL_FUNCTION_NAME,
      TOOL_CALL_FUNCTION_ARGUMENTS_JSON,
      MESSAGE_FUNCTION_CALL_NAME,
      MESSAGE_FUNCTION_CALL_ARGUMENTS_JSON,
      MESSAGE_CONTENT,
      MESSAGE_CONTENTS,
      MESSAGE_CONTENT_IMAGE,
      MESSAGE_CONTENT_TEXT,
      MESSAGE_CONTENT_TYPE,
      DOCUMENT_ID,
      DOCUMENT_CONTENT,
      DOCUMENT_SCORE,
      DOCUMENT_METADATA,
      EMBEDDING_EMBEDDINGS,
      EMBEDDING_TEXT,
      EMBEDDING_MODEL_NAME,
      EMBEDDING_VECTOR,
      TOOL_DESCRIPTION,
      TOOL_NAME,
      TOOL_PARAMETERS,
      TOOL_JSON_SCHEMA,
      PROMPT_TEMPLATE_VARIABLES,
      PROMPT_TEMPLATE_TEMPLATE,
      PROMPT_TEMPLATE_VERSION,
      RERANKER_INPUT_DOCUMENTS,
      RERANKER_OUTPUT_DOCUMENTS,
      RERANKER_QUERY,
      RERANKER_MODEL_NAME,
      RERANKER_TOP_K,
      LLM_FUNCTION_CALL,
      RETRIEVAL_DOCUMENTS,
      SESSION_ID,
      USER_ID,
      METADATA,
      TAG_TAGS,
      OPENINFERENCE_SPAN_KIND: `${SemanticAttributePrefixes.openinference}.span.kind`,
      PROMPT_VENDOR,
      PROMPT_ID,
      PROMPT_URL,
      AGENT_NAME,
      GRAPH_NODE_ID,
      GRAPH_NODE_NAME,
      GRAPH_NODE_PARENT_ID
    };
    (function(OpenInferenceSpanKind2) {
      OpenInferenceSpanKind2["LLM"] = "LLM";
      OpenInferenceSpanKind2["CHAIN"] = "CHAIN";
      OpenInferenceSpanKind2["TOOL"] = "TOOL";
      OpenInferenceSpanKind2["RETRIEVER"] = "RETRIEVER";
      OpenInferenceSpanKind2["RERANKER"] = "RERANKER";
      OpenInferenceSpanKind2["EMBEDDING"] = "EMBEDDING";
      OpenInferenceSpanKind2["AGENT"] = "AGENT";
      OpenInferenceSpanKind2["GUARDRAIL"] = "GUARDRAIL";
      OpenInferenceSpanKind2["EVALUATOR"] = "EVALUATOR";
    })(OpenInferenceSpanKind || (OpenInferenceSpanKind = {}));
    (function(MimeType2) {
      MimeType2["TEXT"] = "text/plain";
      MimeType2["JSON"] = "application/json";
      MimeType2["AUDIO_WAV"] = "audio/wav";
    })(MimeType || (MimeType = {}));
    (function(LLMSystem2) {
      LLMSystem2["OPENAI"] = "openai";
      LLMSystem2["ANTHROPIC"] = "anthropic";
      LLMSystem2["MISTRALAI"] = "mistralai";
      LLMSystem2["COHERE"] = "cohere";
      LLMSystem2["VERTEXAI"] = "vertexai";
      LLMSystem2["AI21"] = "ai21";
      LLMSystem2["META"] = "meta";
      LLMSystem2["AMAZON"] = "amazon";
    })(LLMSystem || (LLMSystem = {}));
    (function(LLMProvider2) {
      LLMProvider2["OPENAI"] = "openai";
      LLMProvider2["ANTHROPIC"] = "anthropic";
      LLMProvider2["MISTRALAI"] = "mistralai";
      LLMProvider2["COHERE"] = "cohere";
      LLMProvider2["GOOGLE"] = "google";
      LLMProvider2["AWS"] = "aws";
      LLMProvider2["AZURE"] = "azure";
      LLMProvider2["XAI"] = "xai";
      LLMProvider2["DEEPSEEK"] = "deepseek";
    })(LLMProvider || (LLMProvider = {}));
  }
});

// ../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/dist/esm/trace/index.js
var init_trace = __esm({
  "../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/dist/esm/trace/index.js"() {
    "use strict";
    init_SemanticConventions();
  }
});

// ../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/dist/esm/resource/SemanticResourceAttributes.js
var init_SemanticResourceAttributes = __esm({
  "../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/dist/esm/resource/SemanticResourceAttributes.js"() {
    "use strict";
  }
});

// ../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/dist/esm/resource/index.js
var init_resource = __esm({
  "../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/dist/esm/resource/index.js"() {
    "use strict";
    init_SemanticResourceAttributes();
  }
});

// ../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/dist/esm/index.js
var init_esm = __esm({
  "../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/dist/esm/index.js"() {
    "use strict";
    init_trace();
    init_resource();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js
var _globalThis;
var init_globalThis = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js"() {
    "use strict";
    _globalThis = typeof globalThis === "object" ? globalThis : global;
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/platform/node/index.js
var init_node = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/platform/node/index.js"() {
    "use strict";
    init_globalThis();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/platform/index.js
var init_platform = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/platform/index.js"() {
    "use strict";
    init_node();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/version.js
var VERSION;
var init_version = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/version.js"() {
    "use strict";
    VERSION = "1.9.0";
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/internal/semver.js
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var re, isCompatible;
var init_semver = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/internal/semver.js"() {
    "use strict";
    init_version();
    re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
    isCompatible = _makeCompatibilityCheck(VERSION);
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
function registerGlobal(type, instance, diag, allowOverride) {
  var _a;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a, _b;
  var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}
var major, GLOBAL_OPENTELEMETRY_API_KEY, _global;
var init_global_utils = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/internal/global-utils.js"() {
    "use strict";
    init_platform();
    init_version();
    init_semver();
    major = VERSION.split(".")[0];
    GLOBAL_OPENTELEMETRY_API_KEY = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major);
    _global = _globalThis;
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
function logProxy(funcName, namespace, args) {
  var logger = getGlobal("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
}
var __read, __spreadArray, DiagComponentLogger;
var init_ComponentLogger = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js"() {
    "use strict";
    init_global_utils();
    __read = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    DiagComponentLogger = /** @class */
    (function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      DiagComponentLogger2.prototype.debug = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("debug", this._namespace, args);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("error", this._namespace, args);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("info", this._namespace, args);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("warn", this._namespace, args);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return logProxy("verbose", this._namespace, args);
      };
      return DiagComponentLogger2;
    })();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
var init_types = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/types.js"() {
    "use strict";
    (function(DiagLogLevel2) {
      DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
      DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
      DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
      DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
      DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
      DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
      DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
    })(DiagLogLevel || (DiagLogLevel = {}));
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}
var init_logLevelLogger = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js"() {
    "use strict";
    init_types();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2, __spreadArray2, API_NAME, DiagAPI;
var init_diag = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/diag.js"() {
    "use strict";
    init_ComponentLogger();
    init_logLevelLogger();
    init_types();
    init_global_utils();
    __read2 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray2 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME = "diag";
    DiagAPI = /** @class */
    (function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
              args[_i] = arguments[_i];
            }
            var logger = getGlobal("diag");
            if (!logger)
              return;
            return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));
          };
        }
        var self = this;
        var setLogger = function(logger, optionsOrLogLevel) {
          var _a, _b, _c;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger === self) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self, true);
        };
        self.setLogger = setLogger;
        self.disable = function() {
          unregisterGlobal(API_NAME, self);
        };
        self.createComponentLogger = function(options) {
          return new DiagComponentLogger(options);
        };
        self.verbose = _logProxy("verbose");
        self.debug = _logProxy("debug");
        self.info = _logProxy("info");
        self.warn = _logProxy("warn");
        self.error = _logProxy("error");
      }
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    })();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext, ROOT_CONTEXT;
var init_context = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context/context.js"() {
    "use strict";
    BaseContext = /** @class */
    /* @__PURE__ */ (function() {
      function BaseContext2(parentContext) {
        var self = this;
        self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self.getValue = function(key) {
          return self._currentContext.get(key);
        };
        self.setValue = function(key, value) {
          var context2 = new BaseContext2(self._currentContext);
          context2._currentContext.set(key, value);
          return context2;
        };
        self.deleteValue = function(key) {
          var context2 = new BaseContext2(self._currentContext);
          context2._currentContext.delete(key);
          return context2;
        };
      }
      return BaseContext2;
    })();
    ROOT_CONTEXT = new BaseContext();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read3, __spreadArray3, NoopContextManager;
var init_NoopContextManager = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js"() {
    "use strict";
    init_context();
    __read3 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray3 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    NoopContextManager = /** @class */
    (function() {
      function NoopContextManager2() {
      }
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return fn.call.apply(fn, __spreadArray3([thisArg], __read3(args), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    })();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/context.js
var __read4, __spreadArray4, API_NAME2, NOOP_CONTEXT_MANAGER, ContextAPI;
var init_context2 = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/context.js"() {
    "use strict";
    init_NoopContextManager();
    init_global_utils();
    init_diag();
    __read4 = function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m) return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"])) m.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar;
    };
    __spreadArray4 = function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    API_NAME2 = "context";
    NOOP_CONTEXT_MANAGER = new NoopContextManager();
    ContextAPI = /** @class */
    (function() {
      function ContextAPI2() {
      }
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context2, fn, thisArg) {
        var _a;
        var args = [];
        for (var _i = 3; _i < arguments.length; _i++) {
          args[_i - 3] = arguments[_i];
        }
        return (_a = this._getContextManager()).with.apply(_a, __spreadArray4([context2, fn, thisArg], __read4(args), false));
      };
      ContextAPI2.prototype.bind = function(context2, target) {
        return this._getContextManager().bind(context2, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME2, DiagAPI.instance());
      };
      return ContextAPI2;
    })();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
var init_trace_flags = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js"() {
    "use strict";
    (function(TraceFlags2) {
      TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
      TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
    })(TraceFlags || (TraceFlags = {}));
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID, INVALID_TRACEID, INVALID_SPAN_CONTEXT;
var init_invalid_span_constants = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js"() {
    "use strict";
    init_trace_flags();
    INVALID_SPANID = "0000000000000000";
    INVALID_TRACEID = "00000000000000000000000000000000";
    INVALID_SPAN_CONTEXT = {
      traceId: INVALID_TRACEID,
      spanId: INVALID_SPANID,
      traceFlags: TraceFlags.NONE
    };
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan;
var init_NonRecordingSpan = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js"() {
    "use strict";
    init_invalid_span_constants();
    NonRecordingSpan = /** @class */
    (function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addLink = function(_link) {
        return this;
      };
      NonRecordingSpan2.prototype.addLinks = function(_links) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    })();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
function getSpan(context2) {
  return context2.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context2, span) {
  return context2.setValue(SPAN_KEY, span);
}
function deleteSpan(context2) {
  return context2.deleteValue(SPAN_KEY);
}
function setSpanContext(context2, spanContext) {
  return setSpan(context2, new NonRecordingSpan(spanContext));
}
function getSpanContext(context2) {
  var _a;
  return (_a = getSpan(context2)) === null || _a === void 0 ? void 0 : _a.spanContext();
}
var SPAN_KEY;
var init_context_utils = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/context-utils.js"() {
    "use strict";
    init_context();
    init_NonRecordingSpan();
    init_context2();
    SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}
var VALID_TRACEID_REGEX, VALID_SPANID_REGEX;
var init_spancontext_utils = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js"() {
    "use strict";
    init_invalid_span_constants();
    init_NonRecordingSpan();
    VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
    VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}
var contextApi, NoopTracer;
var init_NoopTracer = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js"() {
    "use strict";
    init_context2();
    init_context_utils();
    init_NonRecordingSpan();
    init_spancontext_utils();
    contextApi = ContextAPI.getInstance();
    NoopTracer = /** @class */
    (function() {
      function NoopTracer2() {
      }
      NoopTracer2.prototype.startSpan = function(name, options, context2) {
        if (context2 === void 0) {
          context2 = contextApi.active();
        }
        var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context2 && getSpanContext(context2);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span);
        return contextApi.with(contextWithSpanSet, fn, void 0, span);
      };
      return NoopTracer2;
    })();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER, ProxyTracer;
var init_ProxyTracer = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js"() {
    "use strict";
    init_NoopTracer();
    NOOP_TRACER = new NoopTracer();
    ProxyTracer = /** @class */
    (function() {
      function ProxyTracer2(_provider, name, version, options) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options;
      }
      ProxyTracer2.prototype.startSpan = function(name, options, context2) {
        return this._getTracer().startSpan(name, options, context2);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer = this._getTracer();
        return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer) {
          return NOOP_TRACER;
        }
        this._delegate = tracer;
        return this._delegate;
      };
      return ProxyTracer2;
    })();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider;
var init_NoopTracerProvider = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js"() {
    "use strict";
    init_NoopTracer();
    NoopTracerProvider = /** @class */
    (function() {
      function NoopTracerProvider2() {
      }
      NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    })();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER, ProxyTracerProvider;
var init_ProxyTracerProvider = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js"() {
    "use strict";
    init_ProxyTracer();
    init_NoopTracerProvider();
    NOOP_TRACER_PROVIDER = new NoopTracerProvider();
    ProxyTracerProvider = /** @class */
    (function() {
      function ProxyTracerProvider2() {
      }
      ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
        var _a;
        return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a;
        return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
        var _a;
        return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
      };
      return ProxyTracerProvider2;
    })();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
var init_status = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/status.js"() {
    "use strict";
    (function(SpanStatusCode2) {
      SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
      SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
      SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
    })(SpanStatusCode || (SpanStatusCode = {}));
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context-api.js
var context;
var init_context_api = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context-api.js"() {
    "use strict";
    init_context2();
    context = ContextAPI.getInstance();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME3, TraceAPI;
var init_trace2 = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/trace.js"() {
    "use strict";
    init_global_utils();
    init_ProxyTracerProvider();
    init_spancontext_utils();
    init_context_utils();
    init_diag();
    API_NAME3 = "trace";
    TraceAPI = /** @class */
    (function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME3, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME3) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME3, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    })();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace;
var init_trace_api = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace-api.js"() {
    "use strict";
    init_trace2();
    trace = TraceAPI.getInstance();
  }
});

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js
var init_esm2 = __esm({
  "../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/index.js"() {
    "use strict";
    init_status();
    init_context_api();
    init_trace_api();
  }
});

// ../../observability/dist/chunk-ZGEMAYS4.mjs
function createTraceAttributes({
  name,
  userId,
  sessionId,
  version,
  release,
  input,
  output,
  metadata,
  tags,
  environment,
  public: isPublic
} = {}) {
  const attributes = {
    [OtelSpanAttributes.TRACE_NAME]: name,
    // Use OpenInference standard attributes for user and session
    [OtelSpanAttributes.USER_ID]: userId,
    [OtelSpanAttributes.SESSION_ID]: sessionId,
    [OtelSpanAttributes.VERSION]: version,
    [OtelSpanAttributes.RELEASE]: release,
    [OtelSpanAttributes.TRACE_INPUT]: _serialize(input),
    [OtelSpanAttributes.TRACE_OUTPUT]: _serialize(output),
    [OtelSpanAttributes.TRACE_TAGS]: tags,
    [OtelSpanAttributes.ENVIRONMENT]: environment,
    [OtelSpanAttributes.TRACE_PUBLIC]: isPublic,
    ..._flattenAndSerializeMetadata(metadata, OtelSpanAttributes.TRACE_METADATA)
  };
  return Object.fromEntries(
    Object.entries(attributes).filter(([_, v]) => v != null)
  );
}
function createObservationAttributes(type, attributes) {
  const {
    metadata,
    input,
    output,
    level,
    statusMessage,
    version,
    completionStartTime,
    model,
    modelParameters,
    usageDetails
  } = attributes;
  const otelAttributes = {
    [SemanticConventions.OPENINFERENCE_SPAN_KIND]: type.toUpperCase(),
    [OtelSpanAttributes.OBSERVATION_TYPE]: type,
    [OtelSpanAttributes.OBSERVATION_LEVEL]: level,
    [OtelSpanAttributes.OBSERVATION_STATUS_MESSAGE]: statusMessage,
    [OtelSpanAttributes.VERSION]: version,
    // Use OpenInference input.value convention
    [SemanticConventions.INPUT_VALUE]: _serialize(input),
    // Also set legacy agkit.observation.input for compatibility
    [OtelSpanAttributes.OBSERVATION_INPUT]: _serialize(input),
    // Use OpenInference output.value convention
    [SemanticConventions.OUTPUT_VALUE]: _serialize(output),
    // Also set legacy agkit.observation.output for compatibility
    [OtelSpanAttributes.OBSERVATION_OUTPUT]: _serialize(output)
  };
  if (type === "llm") {
    if (model) {
      otelAttributes[SemanticConventions.LLM_MODEL_NAME] = model;
    }
    if (modelParameters) {
      otelAttributes[SemanticConventions.LLM_INVOCATION_PARAMETERS] = _serialize(modelParameters);
      otelAttributes[OtelSpanAttributes.LLM_MODEL_PARAMETERS] = _serialize(modelParameters);
    }
    if (usageDetails) {
      if (typeof usageDetails === "object") {
        const usage = usageDetails;
        if (usage.promptTokens !== void 0) {
          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_PROMPT] = usage.promptTokens;
        }
        if (usage.completionTokens !== void 0) {
          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_COMPLETION] = usage.completionTokens;
        }
        if (usage.totalTokens !== void 0) {
          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_TOTAL] = usage.totalTokens;
        }
      }
      otelAttributes[OtelSpanAttributes.LLM_USAGE_DETAILS] = _serialize(usageDetails);
    }
    if (completionStartTime) {
      otelAttributes[OtelSpanAttributes.LLM_COMPLETION_START_TIME] = _serialize(completionStartTime);
    }
  }
  if (type === "embedding") {
    if (model) {
      otelAttributes[SemanticConventions.EMBEDDING_MODEL_NAME] = model;
    }
    if (modelParameters) {
      otelAttributes[SemanticConventions.LLM_INVOCATION_PARAMETERS] = _serialize(modelParameters);
    }
  }
  const metadataAttrs = _flattenAndSerializeMetadata(
    metadata,
    SemanticConventions.METADATA
  );
  Object.assign(otelAttributes, metadataAttrs);
  const obsetvabilityMetadataAttrs = _flattenAndSerializeMetadata(
    metadata,
    OtelSpanAttributes.OBSERVATION_METADATA
  );
  Object.assign(otelAttributes, obsetvabilityMetadataAttrs);
  return Object.fromEntries(
    Object.entries(otelAttributes).filter(([_, v]) => v != null)
  );
}
function _serialize(obj) {
  try {
    if (typeof obj === "string") return obj;
    if (obj instanceof Date) return obj.toISOString();
    return obj != null ? JSON.stringify(obj) : void 0;
  } catch {
    return "<failed to serialize>";
  }
}
function _flattenAndSerializeMetadata(metadata, prefix) {
  const metadataAttributes = {};
  if (metadata === void 0 || metadata === null) {
    return metadataAttributes;
  }
  if (typeof metadata !== "object" || Array.isArray(metadata)) {
    const serialized = _serialize(metadata);
    if (serialized) {
      metadataAttributes[prefix] = serialized;
    }
  } else {
    for (const [key, value] of Object.entries(metadata)) {
      const serialized = typeof value === "string" ? value : _serialize(value);
      if (serialized) {
        metadataAttributes[`${prefix}.${key}`] = serialized;
      }
    }
  }
  return metadataAttributes;
}
function createState() {
  return {
    isolatedTracerProvider: null
  };
}
function getObservabilityGlobalState() {
  const initialState = createState();
  try {
    const g = globalThis;
    if (typeof g !== "object" || g === null) {
      console.warn(
        "[Observability] globalThis is not available, using fallback state"
      );
      return initialState;
    }
    if (!g[OBSERVABILITY_GLOBAL_SYMBOL]) {
      Object.defineProperty(g, OBSERVABILITY_GLOBAL_SYMBOL, {
        value: initialState,
        writable: false,
        configurable: false,
        enumerable: false
      });
    }
    return g[OBSERVABILITY_GLOBAL_SYMBOL];
  } catch (err) {
    console.error(
      `[Observability] Failed to access global state: ${err instanceof Error ? err.message : String(err)}`
    );
    return initialState;
  }
}
function setTracerProvider(provider) {
  getObservabilityGlobalState().isolatedTracerProvider = provider;
}
function getTracerProvider() {
  const { isolatedTracerProvider } = getObservabilityGlobalState();
  if (isolatedTracerProvider) return isolatedTracerProvider;
  return trace.getTracerProvider();
}
function getTracer() {
  return getTracerProvider().getTracer(
    OBSERVABILITY_SDK_NAME,
    OBSERVABILITY_SDK_VERSION
  );
}
function createOtelSpan(params) {
  return getTracer().startSpan(
    params.name,
    { startTime: params.startTime },
    createParentContext(params.parentSpanContext)
  );
}
function createParentContext(parentSpanContext) {
  if (!parentSpanContext) return;
  return trace.setSpanContext(context.active(), parentSpanContext);
}
function startObservation(name, attributes, options) {
  const { asType = "span", ...observationOptions } = options || {};
  const otelSpan = createOtelSpan({
    name,
    ...observationOptions
  });
  switch (asType) {
    case "llm":
      return new ObservationLLM({
        otelSpan,
        attributes
      });
    case "embedding":
      return new ObservationEmbedding({
        otelSpan,
        attributes
      });
    case "agent":
      return new ObservationAgent({
        otelSpan,
        attributes
      });
    case "tool":
      return new ObservationTool({
        otelSpan,
        attributes
      });
    case "chain":
      return new ObservationChain({
        otelSpan,
        attributes
      });
    case "retriever":
      return new ObservationRetriever({
        otelSpan,
        attributes
      });
    case "reranker":
      return new ObservationReranker({
        otelSpan,
        attributes
      });
    case "evaluator":
      return new ObservationEvaluator({
        otelSpan,
        attributes
      });
    case "guardrail":
      return new ObservationGuardrail({
        otelSpan,
        attributes
      });
    case "span":
    default:
      return new ObservationSpan({
        otelSpan,
        attributes
      });
  }
}
function updateActiveTrace(attributes) {
  const span = trace.getActiveSpan();
  if (!span) {
    console.warn(
      "[Observability] No active OTEL span in context. Skipping trace update."
    );
    return;
  }
  span.setAttributes(createTraceAttributes(attributes));
}
function getActiveTraceId() {
  return trace.getActiveSpan()?.spanContext().traceId;
}
function getActiveSpanId() {
  return trace.getActiveSpan()?.spanContext().spanId;
}
function wrapPromise(promise, span, endOnExit) {
  return promise.then(
    (value) => {
      if (endOnExit !== false) {
        span.end();
      }
      return value;
    },
    (err) => {
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: err instanceof Error ? err.message : "Unknown error"
      });
      if (endOnExit !== false) {
        span.end();
      }
      throw err;
    }
  );
}
function startActiveObservation(name, fn, options) {
  const { asType = "span", endOnExit, ...observationOptions } = options || {};
  return getTracer().startActiveSpan(
    name,
    { startTime: observationOptions?.startTime },
    createParentContext(observationOptions?.parentSpanContext) ?? context.active(),
    (span) => {
      try {
        let observation;
        switch (asType) {
          case "llm":
            observation = new ObservationLLM({ otelSpan: span });
            break;
          case "embedding":
            observation = new ObservationEmbedding({ otelSpan: span });
            break;
          case "agent":
            observation = new ObservationAgent({ otelSpan: span });
            break;
          case "tool":
            observation = new ObservationTool({ otelSpan: span });
            break;
          case "chain":
            observation = new ObservationChain({ otelSpan: span });
            break;
          case "retriever":
            observation = new ObservationRetriever({ otelSpan: span });
            break;
          case "reranker":
            observation = new ObservationReranker({ otelSpan: span });
            break;
          case "evaluator":
            observation = new ObservationEvaluator({ otelSpan: span });
            break;
          case "guardrail":
            observation = new ObservationGuardrail({ otelSpan: span });
            break;
          case "span":
          default:
            observation = new ObservationSpan({ otelSpan: span });
        }
        const result = fn(observation);
        if (result instanceof Promise) {
          return wrapPromise(
            result,
            span,
            endOnExit
          );
        } else {
          if (endOnExit !== false) {
            span.end();
          }
          return result;
        }
      } catch (err) {
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: err instanceof Error ? err.message : "Unknown error"
        });
        if (endOnExit !== false) {
          span.end();
        }
        throw err;
      }
    }
  );
}
function updateActiveObservation(attributes) {
  const span = trace.getActiveSpan();
  if (!span) {
    console.warn(
      "[Observability] No active OTEL span in context. Skipping observation update."
    );
    return;
  }
  span.setAttributes(createObservationAttributes("span", attributes));
}
function _captureArguments(args) {
  if (args.length === 0) return {};
  if (args.length === 1) return { arg: args[0] };
  return { args };
}
function observe(fn, options = {}) {
  const {
    asType = "span",
    captureInput = true,
    captureOutput = true,
    ...observationOptions
  } = options;
  const wrappedFunction = function(...args) {
    const name = fn.name || "anonymous-function";
    const inputData = captureInput ? _captureArguments(args) : void 0;
    const observation = startObservation(
      name,
      inputData ? { input: inputData } : {},
      {
        ...observationOptions,
        asType
      }
    );
    const activeContext = trace.setSpan(context.active(), observation.otelSpan);
    const result = context.with(activeContext, () => fn.apply(this, args));
    if (result instanceof Promise) {
      return result.then(
        (value) => {
          if (captureOutput) {
            observation.update({ output: value });
          }
          observation.end();
          return value;
        },
        (err) => {
          observation.update({
            level: "ERROR",
            statusMessage: err instanceof Error ? err.message : "Unknown error"
          });
          observation.end();
          throw err;
        }
      );
    }
    if (captureOutput) {
      observation.update({ output: result });
    }
    observation.end();
    return result;
  };
  Object.defineProperty(wrappedFunction, "name", { value: fn.name });
  Object.defineProperty(wrappedFunction, "length", { value: fn.length });
  return wrappedFunction;
}
var OtelSpanAttributes, init_constants, init_attributes, OBSERVABILITY_GLOBAL_SYMBOL, OBSERVABILITY_SDK_NAME, OBSERVABILITY_SDK_VERSION, init_tracerProvider, BaseObservation, ObservationSpan, ObservationLLM, ObservationEmbedding, ObservationAgent, ObservationTool, ObservationChain, ObservationRetriever, ObservationReranker, ObservationEvaluator, ObservationGuardrail, init_spanWrapper, src_exports, init_src;
var init_chunk_ZGEMAYS4 = __esm({
  "../../observability/dist/chunk-ZGEMAYS4.mjs"() {
    "use strict";
    init_chunk_NFEGQTCC();
    init_esm();
    init_esm();
    init_esm2();
    init_esm2();
    init_constants = __esm2({
      "src/core/constants.ts"() {
        "use strict";
        OtelSpanAttributes = {
          // OpenInference - re-export all standard conventions
          ...SemanticConventions,
          // AG-Kit Trace attributes (non-standard)
          TRACE_NAME: "trace.name",
          TRACE_TAGS: "trace.tags",
          TRACE_PUBLIC: "trace.public",
          TRACE_METADATA: "trace.metadata",
          TRACE_INPUT: "trace.input",
          TRACE_OUTPUT: "trace.output",
          // AG-Kit Observation attributes (non-standard)
          OBSERVATION_TYPE: "observation.type",
          OBSERVATION_LEVEL: "observation.level",
          OBSERVATION_STATUS_MESSAGE: "observation.status_message",
          OBSERVATION_INPUT: "observation.input",
          OBSERVATION_OUTPUT: "observation.output",
          OBSERVATION_METADATA: "observation.metadata",
          // AG-Kit LLM-specific (non-standard)
          LLM_COMPLETION_START_TIME: "llm.completion_start_time",
          LLM_MODEL_PARAMETERS: "llm.model_parameters",
          LLM_USAGE_DETAILS: "llm.usage_details",
          LLM_COST_DETAILS: "llm.cost_details",
          // AG-Kit Retriever-specific (non-standard)
          RETRIEVER_NAME: "retriever.name",
          RETRIEVER_QUERY: "retriever.query",
          RETRIEVER_INDEX_ID: "retriever.index_id",
          RETRIEVER_TOP_K: "retriever.top_k",
          // AG-Kit General (non-standard)
          ENVIRONMENT: "environment",
          RELEASE: "release",
          VERSION: "version"
        };
      }
    });
    init_attributes = __esm2({
      "src/core/attributes.ts"() {
        "use strict";
        init_constants();
      }
    });
    init_tracerProvider = __esm2({
      "src/core/tracerProvider.ts"() {
        "use strict";
        OBSERVABILITY_GLOBAL_SYMBOL = /* @__PURE__ */ Symbol.for("observability");
        OBSERVABILITY_SDK_NAME = "ag-kit-observability";
        OBSERVABILITY_SDK_VERSION = "0.1.0";
      }
    });
    init_spanWrapper = __esm2({
      "src/core/spanWrapper.ts"() {
        "use strict";
        init_attributes();
        init_tracerProvider();
        BaseObservation = class {
          constructor(params) {
            /** The underlying OpenTelemetry span */
            __publicField(this, "otelSpan");
            /** The observation type */
            __publicField(this, "type");
            /** The span ID from the OpenTelemetry span context */
            __publicField(this, "id");
            /** The trace ID from the OpenTelemetry span context */
            __publicField(this, "traceId");
            this.otelSpan = params.otelSpan;
            this.id = params.otelSpan.spanContext().spanId;
            this.traceId = params.otelSpan.spanContext().traceId;
            this.type = params.type;
            if (params.attributes) {
              this.otelSpan.setAttributes(
                createObservationAttributes(params.type, params.attributes)
              );
            }
          }
          /** Gets the AG-Kit OpenTelemetry tracer instance */
          get tracer() {
            return getTracer();
          }
          /**
           * Ends the observation, marking it as complete.
           *
           * @param endTime - Optional end time, defaults to current time
           */
          end(endTime) {
            this.otelSpan.end(endTime);
          }
          /**
           * Updates the OTEL span attributes.
           *
           * @param attributes - Attributes to update
           * @internal
           */
          updateOtelSpanAttributes(attributes) {
            this.otelSpan.setAttributes(
              createObservationAttributes(this.type, attributes)
            );
          }
          /**
           * Updates the parent trace with new attributes.
           *
           * @param attributes - Trace attributes to set
           * @returns This observation for method chaining
           */
          updateTrace(attributes) {
            this.otelSpan.setAttributes(createTraceAttributes(attributes));
            return this;
          }
          startObservation(name, attributes, options) {
            const { startObservation: startObs } = (init_src(), __toCommonJS2(src_exports));
            const { asType = "span" } = options || {};
            return startObs(name, attributes, {
              asType,
              parentSpanContext: this.otelSpan.spanContext()
            });
          }
        };
        ObservationSpan = class extends BaseObservation {
          constructor(params) {
            super({ ...params, type: "span" });
          }
          update(attributes) {
            super.updateOtelSpanAttributes(attributes);
            return this;
          }
        };
        ObservationLLM = class extends BaseObservation {
          constructor(params) {
            super({ ...params, type: "llm" });
          }
          update(attributes) {
            super.updateOtelSpanAttributes(attributes);
            return this;
          }
        };
        ObservationEmbedding = class extends BaseObservation {
          constructor(params) {
            super({ ...params, type: "embedding" });
          }
          update(attributes) {
            super.updateOtelSpanAttributes(attributes);
            return this;
          }
        };
        ObservationAgent = class extends BaseObservation {
          constructor(params) {
            super({ ...params, type: "agent" });
          }
          update(attributes) {
            super.updateOtelSpanAttributes(attributes);
            return this;
          }
        };
        ObservationTool = class extends BaseObservation {
          constructor(params) {
            super({ ...params, type: "tool" });
          }
          update(attributes) {
            super.updateOtelSpanAttributes(attributes);
            return this;
          }
        };
        ObservationChain = class extends BaseObservation {
          constructor(params) {
            super({ ...params, type: "chain" });
          }
          update(attributes) {
            super.updateOtelSpanAttributes(attributes);
            return this;
          }
        };
        ObservationRetriever = class extends BaseObservation {
          constructor(params) {
            super({ ...params, type: "retriever" });
          }
          update(attributes) {
            super.updateOtelSpanAttributes(attributes);
            return this;
          }
        };
        ObservationReranker = class extends BaseObservation {
          constructor(params) {
            super({ ...params, type: "reranker" });
          }
          update(attributes) {
            super.updateOtelSpanAttributes(attributes);
            return this;
          }
        };
        ObservationEvaluator = class extends BaseObservation {
          constructor(params) {
            super({ ...params, type: "evaluator" });
          }
          update(attributes) {
            super.updateOtelSpanAttributes(attributes);
            return this;
          }
        };
        ObservationGuardrail = class extends BaseObservation {
          constructor(params) {
            super({ ...params, type: "guardrail" });
          }
          update(attributes) {
            super.updateOtelSpanAttributes(attributes);
            return this;
          }
        };
      }
    });
    src_exports = {};
    __export2(src_exports, {
      ObservationAgent: () => ObservationAgent,
      ObservationChain: () => ObservationChain,
      ObservationEmbedding: () => ObservationEmbedding,
      ObservationEvaluator: () => ObservationEvaluator,
      ObservationGuardrail: () => ObservationGuardrail,
      ObservationLLM: () => ObservationLLM,
      ObservationReranker: () => ObservationReranker,
      ObservationRetriever: () => ObservationRetriever,
      ObservationSpan: () => ObservationSpan,
      ObservationTool: () => ObservationTool,
      createObservationAttributes: () => createObservationAttributes,
      createTraceAttributes: () => createTraceAttributes,
      getActiveSpanId: () => getActiveSpanId,
      getActiveTraceId: () => getActiveTraceId,
      getTracer: () => getTracer,
      getTracerProvider: () => getTracerProvider,
      observe: () => observe,
      setTracerProvider: () => setTracerProvider,
      startActiveObservation: () => startActiveObservation,
      startObservation: () => startObservation,
      updateActiveObservation: () => updateActiveObservation,
      updateActiveTrace: () => updateActiveTrace
    });
    init_src = __esm2({
      "src/index.ts"() {
        init_attributes();
        init_spanWrapper();
        init_tracerProvider();
        init_attributes();
        init_tracerProvider();
      }
    });
  }
});

// ../../observability/dist/langchain.mjs
var langchain_exports = {};
__export(langchain_exports, {
  CallbackHandler: () => CallbackHandler
});
var import_base, import_messages, import_agent_shared, CallbackHandler;
var init_langchain = __esm({
  "../../observability/dist/langchain.mjs"() {
    "use strict";
    init_chunk_ZGEMAYS4();
    init_chunk_NFEGQTCC();
    import_base = require("@langchain/core/callbacks/base");
    import_messages = require("@langchain/core/messages");
    import_agent_shared = require("@cloudbase/agent-shared");
    init_src();
    CallbackHandler = class extends import_base.BaseCallbackHandler {
      constructor(params) {
        super();
        __publicField(this, "name", "ObservabilityCallbackHandler");
        __publicField(this, "userId");
        __publicField(this, "version");
        __publicField(this, "sessionId");
        __publicField(this, "tags");
        __publicField(this, "traceMetadata");
        __publicField(this, "completionStartTimes", {});
        __publicField(this, "promptToParentRunMap");
        __publicField(this, "runMap", /* @__PURE__ */ new Map());
        __publicField(this, "last_trace_id", null);
        // External parent context from AG-UI.Server span
        __publicField(this, "externalParentSpanContext");
        // Adapter name for ROOT span prefix
        __publicField(this, "adapterName");
        // Logger for debug output (defaults to noopLogger for silent operation)
        __publicField(this, "logger");
        this.sessionId = params?.sessionId;
        this.userId = params?.userId;
        this.tags = params?.tags ?? [];
        this.traceMetadata = params?.traceMetadata;
        this.version = params?.version;
        this.adapterName = params?.adapterName;
        this.logger = params?.logger ?? import_agent_shared.noopLogger;
        this.promptToParentRunMap = /* @__PURE__ */ new Map();
      }
      /**
       * Set external parent SpanContext from AG-UI.Server span.
       * This allows the CallbackHandler to link LangChain/LangGraph spans
       * to the server-level span, creating a unified trace hierarchy.
       *
       * @param spanContext - SpanContext from the AG-UI.Server span
       * @public
       */
      setExternalParentContext(spanContext) {
        this.externalParentSpanContext = spanContext;
      }
      async handleLLMNewToken(token, _idx, runId, _parentRunId, _tags, _fields) {
        if (runId && !(runId in this.completionStartTimes)) {
          this.logger.debug?.(`LLM first streaming token: ${runId}`);
          this.completionStartTimes[runId] = /* @__PURE__ */ new Date();
        }
      }
      async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
        try {
          this.logger.debug?.(`Chain start with Id: ${runId}`);
          const runName = name ?? chain.id.at(-1)?.toString() ?? "Langchain Run";
          this.registerPromptInfo(parentRunId, metadata);
          let finalInput = inputs;
          if (typeof inputs === "object" && "input" in inputs && Array.isArray(inputs["input"]) && inputs["input"].every((m) => m instanceof import_messages.BaseMessage)) {
            finalInput = inputs["input"].map(
              (m) => this.extractChatMessageContent(m)
            );
          } else if (typeof inputs === "object" && "messages" in inputs && Array.isArray(inputs["messages"]) && inputs["messages"].every((m) => m instanceof import_messages.BaseMessage)) {
            finalInput = inputs["messages"].map(
              (m) => this.extractChatMessageContent(m)
            );
          } else if (typeof inputs === "object" && "content" in inputs && typeof inputs["content"] === "string") {
            finalInput = inputs["content"];
          }
          const observation = this.startAndRegisterObservation({
            runName,
            parentRunId,
            runId,
            tags,
            metadata,
            attributes: {
              input: finalInput
            },
            asType: "span"
          });
          const traceTags = [.../* @__PURE__ */ new Set([...tags ?? [], ...this.tags])];
          if (!parentRunId) {
            observation.updateTrace({
              tags: traceTags,
              userId: metadata && "userId" in metadata && typeof metadata["userId"] === "string" ? metadata["userId"] : this.userId,
              sessionId: metadata && "sessionId" in metadata && typeof metadata["sessionId"] === "string" ? metadata["sessionId"] : this.sessionId,
              metadata: this.traceMetadata,
              version: this.version
            });
          }
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      async handleAgentAction(action, runId, parentRunId) {
        try {
          this.logger.debug?.(`Agent action ${action.tool} with ID: ${runId}`);
          this.startAndRegisterObservation({
            runId,
            parentRunId,
            runName: action.tool,
            attributes: {
              input: action
            },
            asType: "tool"
          });
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      async handleAgentEnd(action, runId, _parentRunId) {
        try {
          this.logger.debug?.(`Agent finish with ID: ${runId}`);
          this.handleObservationEnd({
            runId,
            attributes: { output: action }
          });
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      async handleChainError(err, runId, _parentRunId) {
        try {
          this.logger.debug?.(`Chain error: ${err} with ID: ${runId}`);
          this.handleObservationEnd({
            runId,
            attributes: {
              level: "ERROR",
              statusMessage: err.toString()
            }
          });
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      async handleGenerationStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
        this.logger.debug?.(
          `Generation start with ID: ${runId} and parentRunId ${parentRunId}`
        );
        const runName = name ?? llm.id.at(-1)?.toString() ?? "Langchain Generation";
        const modelParameters = {};
        const invocationParams = extraParams?.["invocation_params"];
        for (const [key, value] of Object.entries({
          temperature: invocationParams?.temperature,
          max_tokens: invocationParams?.max_tokens,
          top_p: invocationParams?.top_p,
          frequency_penalty: invocationParams?.frequency_penalty,
          presence_penalty: invocationParams?.presence_penalty,
          request_timeout: invocationParams?.request_timeout
        })) {
          if (value !== void 0 && value !== null) {
            modelParameters[key] = value;
          }
        }
        let extractedModelName;
        if (extraParams) {
          const invocationParamsModelName = extraParams.invocation_params.model;
          const metadataModelName = metadata && "ls_model_name" in metadata ? metadata["ls_model_name"] : void 0;
          extractedModelName = invocationParamsModelName ?? metadataModelName;
        }
        const registeredPrompt = this.promptToParentRunMap.get(
          parentRunId ?? "root"
        );
        if (registeredPrompt && parentRunId) {
          this.deregisterPromptInfo(parentRunId);
        }
        this.startAndRegisterObservation({
          runId,
          parentRunId,
          metadata,
          tags,
          runName,
          attributes: {
            input: messages,
            model: extractedModelName,
            modelParameters
          },
          asType: "llm"
        });
      }
      async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
        try {
          this.logger.debug?.(`Chat model start with ID: ${runId}`);
          const prompts = messages.flatMap(
            (message) => message.map((m) => this.extractChatMessageContent(m))
          );
          this.handleGenerationStart(
            llm,
            prompts,
            runId,
            parentRunId,
            extraParams,
            tags,
            metadata,
            name
          );
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      async handleChainEnd(outputs, runId, _parentRunId) {
        try {
          this.logger.debug?.(`Chain end with ID: ${runId}`);
          let finalOutput = outputs;
          if (typeof outputs === "object" && "output" in outputs && typeof outputs["output"] === "string") {
            finalOutput = outputs["output"];
          } else if (typeof outputs === "object" && "messages" in outputs && Array.isArray(outputs["messages"]) && outputs["messages"].every((m) => m instanceof import_messages.BaseMessage)) {
            finalOutput = {
              messages: outputs.messages.map(
                (message) => this.extractChatMessageContent(message)
              )
            };
          }
          this.handleObservationEnd({
            runId,
            attributes: {
              output: finalOutput
            }
          });
          this.deregisterPromptInfo(runId);
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
        try {
          this.logger.debug?.(`LLM start with ID: ${runId}`);
          this.handleGenerationStart(
            llm,
            prompts,
            runId,
            parentRunId,
            extraParams,
            tags,
            metadata,
            name
          );
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
        try {
          this.logger.debug?.(`Tool start with ID: ${runId}`);
          this.startAndRegisterObservation({
            runId,
            parentRunId,
            runName: name ?? tool.id.at(-1)?.toString() ?? "Tool execution",
            attributes: {
              input
            },
            metadata,
            tags,
            asType: "tool"
          });
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
        try {
          this.logger.debug?.(`Retriever start with ID: ${runId}`);
          this.startAndRegisterObservation({
            runId,
            parentRunId,
            runName: name ?? retriever.id.at(-1)?.toString() ?? "Retriever",
            attributes: {
              input: query
            },
            tags,
            metadata,
            asType: "span"
          });
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      async handleRetrieverEnd(documents, runId, _parentRunId) {
        try {
          this.logger.debug?.(`Retriever end with ID: ${runId}`);
          this.handleObservationEnd({
            runId,
            attributes: {
              output: documents
            }
          });
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      async handleRetrieverError(err, runId, _parentRunId) {
        try {
          this.logger.debug?.(`Retriever error: ${err} with ID: ${runId}`);
          this.handleObservationEnd({
            runId,
            attributes: {
              level: "ERROR",
              statusMessage: err.toString()
            }
          });
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      async handleToolEnd(output, runId, _parentRunId) {
        try {
          this.logger.debug?.(`Tool end with ID: ${runId}`);
          this.handleObservationEnd({
            runId,
            attributes: { output }
          });
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      async handleToolError(err, runId, _parentRunId) {
        try {
          this.logger.debug?.(`Tool error ${err} with ID: ${runId}`);
          this.handleObservationEnd({
            runId,
            attributes: {
              level: "ERROR",
              statusMessage: err.toString()
            }
          });
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      async handleLLMEnd(output, runId, _parentRunId) {
        try {
          this.logger.debug?.(`LLM end with ID: ${runId}`);
          const lastResponse = output.generations[output.generations.length - 1][output.generations[output.generations.length - 1].length - 1];
          const llmUsage = this.extractUsageMetadata(lastResponse) ?? output.llmOutput?.["tokenUsage"];
          const modelName = this.extractModelNameFromMetadata(lastResponse);
          const usageDetails = {
            input: llmUsage?.input_tokens ?? ("promptTokens" in llmUsage ? llmUsage?.promptTokens : void 0),
            output: llmUsage?.output_tokens ?? ("completionTokens" in llmUsage ? llmUsage?.completionTokens : void 0),
            total: llmUsage?.total_tokens ?? ("totalTokens" in llmUsage ? llmUsage?.totalTokens : void 0)
          };
          if (llmUsage && "input_token_details" in llmUsage) {
            for (const [key, val] of Object.entries(
              llmUsage["input_token_details"] ?? {}
            )) {
              usageDetails[`input_${key}`] = val;
              if ("input" in usageDetails && typeof val === "number") {
                usageDetails["input"] = Math.max(0, usageDetails["input"] - val);
              }
            }
          }
          if (llmUsage && "output_token_details" in llmUsage) {
            for (const [key, val] of Object.entries(
              llmUsage["output_token_details"] ?? {}
            )) {
              usageDetails[`output_${key}`] = val;
              if ("output" in usageDetails && typeof val === "number") {
                usageDetails["output"] = Math.max(0, usageDetails["output"] - val);
              }
            }
          }
          const extractedOutput = "message" in lastResponse ? this.extractChatMessageContent(
            lastResponse["message"]
          ) : lastResponse.text;
          this.handleObservationEnd({
            runId,
            attributes: {
              model: modelName,
              output: extractedOutput,
              completionStartTime: runId in this.completionStartTimes ? this.completionStartTimes[runId] : void 0,
              usageDetails
            }
          });
          if (runId in this.completionStartTimes) {
            delete this.completionStartTimes[runId];
          }
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      async handleLLMError(err, runId, _parentRunId) {
        try {
          this.logger.debug?.(`LLM error ${err} with ID: ${runId}`);
          this.handleObservationEnd({
            runId,
            attributes: {
              level: "ERROR",
              statusMessage: err.toString()
            }
          });
        } catch (e) {
          this.logger.debug?.(e instanceof Error ? e.message : String(e));
        }
      }
      registerPromptInfo(parentRunId, metadata) {
        if (metadata && "promptInfo" in metadata && parentRunId) {
          this.promptToParentRunMap.set(
            parentRunId,
            metadata.promptInfo
          );
        }
      }
      deregisterPromptInfo(runId) {
        this.promptToParentRunMap.delete(runId);
      }
      startAndRegisterObservation(params) {
        const { runName, runId, parentRunId, attributes, metadata, tags, asType } = params;
        let parentSpanContext;
        if (parentRunId) {
          parentSpanContext = this.runMap.get(parentRunId)?.otelSpan.spanContext();
        } else if (this.externalParentSpanContext) {
          parentSpanContext = this.externalParentSpanContext;
        }
        let finalRunName = runName;
        if (!parentRunId && this.adapterName) {
          finalRunName = `Adapter.${this.adapterName}`;
        }
        const observation = startObservation(
          finalRunName,
          {
            version: this.version,
            metadata: this.joinTagsAndMetaData(tags, metadata),
            ...attributes
          },
          {
            asType: asType ?? "span",
            parentSpanContext
          }
        );
        this.runMap.set(runId, observation);
        return observation;
      }
      handleObservationEnd(params) {
        const { runId, attributes = {} } = params;
        const observation = this.runMap.get(runId);
        if (!observation) {
          this.logger.warn?.("Observation not found in runMap. Skipping operation.");
          return;
        }
        observation.update(attributes).end();
        this.last_trace_id = observation.traceId;
        this.runMap.delete(runId);
      }
      joinTagsAndMetaData(tags, metadata1, metadata2) {
        const finalDict = {};
        if (tags && tags.length > 0) {
          finalDict.tags = tags;
        }
        if (metadata1) {
          Object.assign(finalDict, metadata1);
        }
        if (metadata2) {
          Object.assign(finalDict, metadata2);
        }
        return this.stripObservabilityKeysFromMetadata(finalDict);
      }
      stripObservabilityKeysFromMetadata(metadata) {
        if (!metadata) {
          return;
        }
        const reservedKeys = ["promptInfo", "userId", "sessionId"];
        return Object.fromEntries(
          Object.entries(metadata).filter(([key, _]) => !reservedKeys.includes(key))
        );
      }
      extractUsageMetadata(generation) {
        try {
          const usageMetadata = "message" in generation && (import_messages.AIMessage.isInstance(generation["message"]) || import_messages.AIMessageChunk.isInstance(generation["message"])) ? generation["message"].usage_metadata : void 0;
          return usageMetadata;
        } catch (err) {
          this.logger.debug?.(`Error extracting usage metadata: ${err}`);
          return;
        }
      }
      extractModelNameFromMetadata(generation) {
        try {
          return "message" in generation && (import_messages.AIMessage.isInstance(generation["message"]) || import_messages.AIMessageChunk.isInstance(generation["message"])) ? generation["message"].response_metadata.model_name : void 0;
        } catch {
        }
      }
      extractChatMessageContent(message) {
        let response = void 0;
        if (message.getType() === "human") {
          response = { content: message.content, role: "user" };
        } else if (message.getType() === "generic") {
          response = {
            content: message.content,
            role: "human"
          };
        } else if (message.getType() === "ai") {
          response = { content: message.content, role: "assistant" };
          if ("tool_calls" in message && Array.isArray(message.tool_calls) && (message.tool_calls?.length ?? 0) > 0) {
            response["tool_calls"] = message["tool_calls"];
          }
          if ("additional_kwargs" in message && "tool_calls" in message["additional_kwargs"]) {
            response["tool_calls"] = message["additional_kwargs"]["tool_calls"];
          }
        } else if (message.getType() === "system") {
          response = { content: message.content, role: "system" };
        } else if (message.getType() === "function") {
          response = {
            content: message.content,
            additional_kwargs: message.additional_kwargs,
            role: message.name
          };
        } else if (message.getType() === "tool") {
          response = {
            content: message.content,
            additional_kwargs: message.additional_kwargs,
            role: message.name
          };
        } else if (!message.name) {
          response = { content: message.content };
        } else {
          response = {
            role: message.name,
            content: message.content
          };
        }
        if ((message.additional_kwargs.function_call || message.additional_kwargs.tool_calls) && response["tool_calls"] === void 0) {
          return { ...response, additional_kwargs: message.additional_kwargs };
        }
        return response;
      }
    };
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  ClientPropertiesAnnotation: () => ClientPropertiesAnnotation,
  ClientStateAnnotation: () => ClientStateAnnotation,
  LanggraphAgent: () => LanggraphAgent,
  TDAISaver: () => TDAISaver,
  TDAIStore: () => TDAIStore,
  createConsoleLogger: () => import_agent_shared3.createConsoleLogger,
  noopLogger: () => import_agent_shared3.noopLogger
});
module.exports = __toCommonJS(index_exports);

// src/agent.ts
var import_client = require("@ag-ui/client");
var import_rxjs = require("rxjs");
var import_langgraph = require("@langchain/langgraph");

// src/util.ts
var import_tools = require("@langchain/core/tools");
var import_v4 = __toESM(require("zod/v4"));
function convertActionsToDynamicStructuredTools(tools) {
  return tools.map(convertActionToDynamicStructuredTool);
}
function convertActionToDynamicStructuredTool(actionInput) {
  return new import_tools.DynamicStructuredTool({
    name: actionInput.name,
    description: actionInput.description,
    schema: convertJsonSchemaToZodSchema(actionInput.parameters, true),
    func: async () => {
      return "";
    }
  });
}
function convertJsonSchemaToZodSchema(jsonSchema, required) {
  if (jsonSchema.type === "object") {
    const spec = {};
    if (!jsonSchema.properties || !Object.keys(jsonSchema.properties).length) {
      return !required ? import_v4.default.object(spec).optional() : import_v4.default.object(spec);
    }
    for (const [key, value] of Object.entries(jsonSchema.properties)) {
      spec[key] = convertJsonSchemaToZodSchema(
        value,
        jsonSchema.required ? jsonSchema.required.includes(key) : false
      );
    }
    let schema = import_v4.default.object(spec).describe(jsonSchema.description);
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "string") {
    let schema = import_v4.default.string().describe(jsonSchema.description);
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "number") {
    let schema = import_v4.default.number().describe(jsonSchema.description);
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "boolean") {
    let schema = import_v4.default.boolean().describe(jsonSchema.description);
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "array") {
    let itemSchema = convertJsonSchemaToZodSchema(jsonSchema.items, true);
    let schema = import_v4.default.array(itemSchema).describe(jsonSchema.description);
    return required ? schema : schema.optional();
  }
  throw new Error("Invalid JSON schema");
}

// src/agent.ts
var import_agent_shared2 = require("@cloudbase/agent-shared");
var LangChainCallbackHandler;
var observabilityLoadAttempted = false;
var ClientPropertiesAnnotation = import_langgraph.Annotation.Root({
  tools: import_langgraph.Annotation
});
var ClientStateAnnotation = import_langgraph.Annotation.Root({
  client: import_langgraph.Annotation,
  ...import_langgraph.MessagesAnnotation.spec
});
var LanggraphAgent = class extends import_client.AbstractAgent {
  constructor(agentConfig) {
    super(agentConfig);
    this.compiledWorkflow = agentConfig.compiledWorkflow;
    this.adapterName = agentConfig.adapterName || "LangGraph";
    const baseLogger = agentConfig.logger ?? import_agent_shared2.noopLogger;
    this.logger = baseLogger.child?.({ component: "langgraph-agent" }) ?? baseLogger;
  }
  run(input) {
    return new import_rxjs.Observable((subscriber) => {
      this._run(subscriber, input);
    });
  }
  async _run(subscriber, input) {
    const { messages, runId, threadId } = input;
    const logger = this.logger.child?.({ runId, threadId }) ?? this.logger;
    logger.info?.("Run started");
    if (!observabilityLoadAttempted && !this.observabilityCallback) {
      observabilityLoadAttempted = true;
      try {
        logger.debug?.("Attempting to load observability...");
        const obsModule = await Promise.resolve().then(() => (init_langchain(), langchain_exports));
        LangChainCallbackHandler = obsModule.CallbackHandler;
        if (LangChainCallbackHandler) {
          this.observabilityCallback = new LangChainCallbackHandler({
            adapterName: this.adapterName,
            logger
            // Reuse the run-specific logger with context
          });
          logger.debug?.("\u2713 Observability callback created");
        }
      } catch (e) {
        logger.debug?.(
          "\u2717 Observability not available:",
          e instanceof Error ? e.message : String(e)
        );
      }
    }
    if (this.observabilityCallback && input.forwardedProps?.__agui_server_context) {
      try {
        const serverContextData = input.forwardedProps.__agui_server_context;
        const serverSpanContext = {
          traceId: serverContextData.traceId,
          spanId: serverContextData.spanId,
          traceFlags: serverContextData.traceFlags,
          isRemote: false
        };
        this.observabilityCallback.setExternalParentContext(serverSpanContext);
        logger.debug?.("\u2713 Server context restored:", {
          traceId: serverSpanContext.traceId,
          spanId: serverSpanContext.spanId
        });
      } catch (e) {
        logger.debug?.("Failed to restore server context:", e);
      }
    }
    const runStartedEvent = {
      type: import_client.EventType.RUN_STARTED,
      threadId,
      runId
    };
    logger.trace?.({ aguiEvent: runStartedEvent }, "Emitting AGUI event");
    subscriber.next(runStartedEvent);
    const isResume = !!input.forwardedProps?.resume;
    const lastUserMessage = messages.filter((m) => m.role === "user").pop();
    logger.debug?.(
      {
        isResume,
        messageCount: messages.length,
        toolCount: input.tools?.length ?? 0,
        tools: input.tools?.map((t) => t.name),
        lastUserMessage: typeof lastUserMessage?.content === "string" ? lastUserMessage.content.slice(0, 200) : void 0
      },
      "Preparing stream input"
    );
    logger.trace?.({ messages, tools: input.tools }, "Full input messages");
    const langChainMessages = isResume ? void 0 : aguiMessagesToLangChain(messages);
    if (langChainMessages) {
      logger.trace?.(
        {
          langChainMessages,
          messageCount: langChainMessages.length,
          messageTypes: langChainMessages.map((m) => ({
            type: m.type,
            id: m.id,
            hasToolCalls: "tool_calls" in m && Array.isArray(m.tool_calls) && m.tool_calls.length > 0,
            toolCallId: "tool_call_id" in m ? m.tool_call_id : void 0
          }))
        },
        "Converted LangGraph messages"
      );
    }
    const streamEventInput = isResume ? new import_langgraph.Command({
      resume: JSON.stringify(input.forwardedProps?.resume?.payload)
    }) : {
      messages: langChainMessages,
      client: {
        tools: convertActionsToDynamicStructuredTools(
          input.tools.map((x) => ({
            ...x,
            parameters: typeof x.parameters === "string" ? JSON.parse(x.parameters) : x.parameters
          }))
        )
      }
    };
    const stream = this.compiledWorkflow.streamEvents(streamEventInput, {
      version: "v2",
      ...this.observabilityCallback ? { callbacks: [this.observabilityCallback] } : {},
      runId,
      configurable: {
        thread_id: threadId
      }
    });
    logger.debug?.("Stream created, starting event processing");
    const chatModelRuns = [];
    const handledToolCallIds = /* @__PURE__ */ new Set();
    for (const msg of messages) {
      if (msg.role === "tool" && msg.toolCallId) {
        handledToolCallIds.add(msg.toolCallId);
      }
    }
    if (handledToolCallIds.size > 0) {
      logger.debug?.(
        { count: handledToolCallIds.size },
        "Pre-populated handled tool call IDs from input messages"
      );
    }
    let interrupt;
    let currentToolCall = null;
    let eventCount = 0;
    let toolCallCount = 0;
    let textChunkCount = 0;
    try {
      for await (const event of stream) {
        eventCount++;
        logger.trace?.(
          { eventType: event.event, eventCount, langGraphEvent: event },
          "Processing stream event"
        );
        if (event.event.startsWith("ChannelWrite<")) {
          continue;
        }
        if (event.event === "on_chat_model_start") {
          logger.debug?.(
            { chatModelRunId: event.run_id },
            "Chat model started"
          );
          chatModelRuns.push({ runId: event.run_id });
          continue;
        }
        if (event.event === "on_chat_model_stream") {
          const chatModelRun = chatModelRuns.find(
            (run) => run.runId === event.run_id
          );
          if (!chatModelRun) {
            logger.warn?.(
              { chatModelRunId: event.run_id },
              "Received message from unknown chat model run"
            );
            subscriber.next({
              type: import_client.EventType.RUN_ERROR,
              code: "INTERNAL_ERROR",
              message: `Received a message from an unknown chat model run. Run Id: ${event.run_id}`
            });
            continue;
          }
          const chunkId = event.data.chunk.id;
          if (!chatModelRun.messageId) {
            chatModelRun.messageId = chunkId;
            const textStartEvent = {
              messageId: chunkId,
              type: import_client.EventType.TEXT_MESSAGE_START,
              role: "assistant"
            };
            logger.debug?.({ messageId: chunkId }, "Text message started");
            logger.trace?.(
              { aguiEvent: textStartEvent },
              "Emitting AGUI event"
            );
            subscriber.next(textStartEvent);
          } else if (chatModelRun.messageId !== chunkId) {
            logger.warn?.(
              {
                expectedMessageId: chatModelRun.messageId,
                receivedMessageId: chunkId,
                chatModelRunId: event.run_id
              },
              "Received message with unexpected ID"
            );
            subscriber.next({
              type: import_client.EventType.RUN_ERROR,
              code: "INTERNAL_ERROR",
              message: `Received a message of unknown message id from current run. Run Id: ${event.run_id} Message Id from current run: ${chatModelRun.messageId} Message Id from received message: ${chunkId}`
            });
            continue;
          }
          if (Array.isArray(event.data.chunk?.tool_call_chunks) && event.data.chunk?.tool_call_chunks?.length > 0) {
            const parentMessageId = chatModelRun.messageId;
            event.data.chunk.tool_call_chunks.map((x) => ({
              ...x,
              args: typeof x.args === "string" ? x.args : x.args ? JSON.stringify(x.args) : ""
            })).forEach((toolCall) => {
              if (currentToolCall) {
                if (toolCall.id && currentToolCall.id !== toolCall.id) {
                  const toolEndEvent = {
                    toolCallId: currentToolCall.id,
                    type: import_client.EventType.TOOL_CALL_END
                  };
                  logger.debug?.(
                    {
                      toolCallId: currentToolCall.id,
                      toolCallName: currentToolCall.name
                    },
                    "Tool call ended"
                  );
                  logger.trace?.(
                    { aguiEvent: toolEndEvent },
                    "Emitting AGUI event"
                  );
                  subscriber.next(toolEndEvent);
                  if (toolCall.name && toolCall.id) {
                    currentToolCall = toolCall;
                    toolCallCount++;
                    const toolStartEvent = {
                      toolCallId: currentToolCall.id,
                      toolCallName: currentToolCall.name,
                      parentMessageId,
                      type: import_client.EventType.TOOL_CALL_START
                    };
                    logger.debug?.(
                      {
                        toolCallId: toolCall.id,
                        toolCallName: toolCall.name
                      },
                      "Tool call started"
                    );
                    logger.trace?.(
                      { aguiEvent: toolStartEvent },
                      "Emitting AGUI event"
                    );
                    subscriber.next(toolStartEvent);
                    if (currentToolCall.args) {
                      const toolArgsEvent = {
                        toolCallId: currentToolCall.id,
                        delta: currentToolCall.args,
                        type: import_client.EventType.TOOL_CALL_ARGS
                      };
                      logger.trace?.(
                        { aguiEvent: toolArgsEvent },
                        "Emitting AGUI event"
                      );
                      subscriber.next(toolArgsEvent);
                      if (isValidJson(currentToolCall.args)) {
                        const toolEndEvent2 = {
                          toolCallId: currentToolCall.id,
                          type: import_client.EventType.TOOL_CALL_END
                        };
                        logger.debug?.(
                          { toolCallId: currentToolCall.id },
                          "Tool call ended (args complete)"
                        );
                        logger.trace?.(
                          { aguiEvent: toolEndEvent2 },
                          "Emitting AGUI event"
                        );
                        subscriber.next(toolEndEvent2);
                        currentToolCall = null;
                      }
                    }
                  }
                } else {
                  if (toolCall.args) {
                    currentToolCall.args += toolCall.args;
                    const toolArgsEvent = {
                      toolCallId: currentToolCall.id,
                      delta: toolCall.args,
                      type: import_client.EventType.TOOL_CALL_ARGS
                    };
                    logger.trace?.(
                      { aguiEvent: toolArgsEvent },
                      "Emitting AGUI event"
                    );
                    subscriber.next(toolArgsEvent);
                    if (isValidJson(currentToolCall.args)) {
                      const toolEndEvent = {
                        toolCallId: currentToolCall.id,
                        type: import_client.EventType.TOOL_CALL_END
                      };
                      logger.debug?.(
                        { toolCallId: currentToolCall.id },
                        "Tool call ended (args complete)"
                      );
                      logger.trace?.(
                        { aguiEvent: toolEndEvent },
                        "Emitting AGUI event"
                      );
                      subscriber.next(toolEndEvent);
                      currentToolCall = null;
                    }
                  }
                }
              } else {
                if (toolCall.name && toolCall.id) {
                  currentToolCall = toolCall;
                  toolCallCount++;
                  const toolStartEvent = {
                    toolCallId: toolCall.id,
                    toolCallName: toolCall.name,
                    parentMessageId,
                    type: import_client.EventType.TOOL_CALL_START
                  };
                  logger.debug?.(
                    { toolCallId: toolCall.id, toolCallName: toolCall.name },
                    "Tool call started"
                  );
                  logger.trace?.(
                    { aguiEvent: toolStartEvent },
                    "Emitting AGUI event"
                  );
                  subscriber.next(toolStartEvent);
                  if (toolCall.args) {
                    const toolArgsEvent = {
                      toolCallId: toolCall.id,
                      delta: toolCall.args,
                      type: import_client.EventType.TOOL_CALL_ARGS
                    };
                    logger.trace?.(
                      { aguiEvent: toolArgsEvent },
                      "Emitting AGUI event"
                    );
                    subscriber.next(toolArgsEvent);
                    if (isValidJson(toolCall.args)) {
                      const toolEndEvent = {
                        toolCallId: toolCall.id,
                        type: import_client.EventType.TOOL_CALL_END
                      };
                      logger.debug?.(
                        { toolCallId: toolCall.id },
                        "Tool call ended (args complete)"
                      );
                      logger.trace?.(
                        { aguiEvent: toolEndEvent },
                        "Emitting AGUI event"
                      );
                      subscriber.next(toolEndEvent);
                      currentToolCall = null;
                    }
                  }
                }
              }
            });
          }
          const delta = event.data.chunk.content;
          if (typeof delta === "string" && delta) {
            textChunkCount++;
            const textContentEvent = {
              messageId: chatModelRun.messageId,
              type: import_client.EventType.TEXT_MESSAGE_CONTENT,
              delta
            };
            logger.trace?.(
              { aguiEvent: textContentEvent },
              "Emitting AGUI event"
            );
            subscriber.next(textContentEvent);
          }
          continue;
        }
        if (event.event === "on_chat_model_end") {
          const chatModelRun = chatModelRuns.find(
            (run) => run.runId === event.run_id
          );
          if (!chatModelRun) {
            logger.warn?.(
              { chatModelRunId: event.run_id },
              "Received on_chat_model_end from unknown run"
            );
            subscriber.next({
              type: import_client.EventType.RUN_ERROR,
              code: "INTERNAL_ERROR",
              message: `Received a on_chat_model_end event from an unknown chat model run. Run Id: ${event.run_id}`
            });
            continue;
          }
          const textEndEvent = {
            type: import_client.EventType.TEXT_MESSAGE_END,
            messageId: chatModelRun.messageId
          };
          logger.debug?.(
            { messageId: chatModelRun.messageId },
            "Text message ended"
          );
          logger.trace?.({ aguiEvent: textEndEvent }, "Emitting AGUI event");
          subscriber.next(textEndEvent);
          continue;
        }
        if (event.event === "on_tool_end") {
          const toolMessage = event.data.output;
          if (toolMessage && toolMessage.tool_call_id) {
            if (!handledToolCallIds.has(toolMessage.tool_call_id)) {
              if (!toolMessage.id) {
                toolMessage.id = crypto.randomUUID();
                if (toolMessage.lc_kwargs) {
                  toolMessage.lc_kwargs.id = toolMessage.id;
                }
              }
              const toolResultEvent = {
                toolCallId: toolMessage.tool_call_id,
                type: import_client.EventType.TOOL_CALL_RESULT,
                content: typeof toolMessage.content === "string" ? toolMessage.content : JSON.stringify(toolMessage.content),
                messageId: toolMessage.id
              };
              logger.debug?.(
                {
                  toolCallId: toolMessage.tool_call_id,
                  messageId: toolMessage.id
                },
                "Tool call result received"
              );
              logger.trace?.(
                { aguiEvent: toolResultEvent },
                "Emitting AGUI event"
              );
              subscriber.next(toolResultEvent);
              handledToolCallIds.add(toolMessage.tool_call_id);
            } else {
              logger.trace?.(
                { toolCallId: toolMessage.tool_call_id },
                "Skipping duplicate tool call result"
              );
            }
          }
          continue;
        }
        if (event.event === "on_chain_stream") {
          const chunk = event.data.chunk;
          if (chunk?.messages && Array.isArray(chunk.messages)) {
            logger.trace?.(
              {
                nodeName: event.name,
                stateMessages: chunk.messages.map((m) => ({
                  type: m.type,
                  id: m.id,
                  contentPreview: typeof m.content === "string" ? m.content.slice(0, 100) : "[non-string content]",
                  hasToolCalls: "tool_calls" in m && Array.isArray(m.tool_calls) && m.tool_calls.length > 0,
                  toolCallId: "tool_call_id" in m ? m.tool_call_id : void 0
                })),
                messageCount: chunk.messages.length
              },
              "State update with messages"
            );
          }
          if (chunk?.__interrupt__ && Array.isArray(chunk.__interrupt__) && chunk.__interrupt__.length > 0) {
            const rawInterrupt = chunk.__interrupt__[0];
            logger.debug?.(
              { interruptId: rawInterrupt.id },
              "Interrupt received"
            );
            interrupt = {
              id: rawInterrupt.id,
              // TODO: replace with actual reason
              reason: "agent requested interrupt",
              payload: rawInterrupt.value
            };
          }
        }
      }
      const stats = { eventCount, toolCallCount, textChunkCount };
      if (interrupt) {
        const runFinishedEvent = {
          type: import_client.EventType.RUN_FINISHED,
          threadId,
          runId,
          outcome: "interrupt",
          interrupt
        };
        logger.info?.(
          { outcome: "interrupt", interruptId: interrupt.id, ...stats },
          "Run finished with interrupt"
        );
        logger.trace?.({ aguiEvent: runFinishedEvent }, "Emitting AGUI event");
        subscriber.next(runFinishedEvent);
      } else {
        const runFinishedEvent = {
          type: import_client.EventType.RUN_FINISHED,
          threadId,
          runId
        };
        logger.info?.({ outcome: "complete", ...stats }, "Run finished");
        logger.trace?.({ aguiEvent: runFinishedEvent }, "Emitting AGUI event");
        subscriber.next(runFinishedEvent);
      }
    } catch (error) {
      logger.error?.(
        { err: error, eventCount, toolCallCount, textChunkCount },
        "Error during stream processing"
      );
      const errorCode = (0, import_agent_shared2.isErrorWithCode)(error) ? error.code : "INTERNAL_ERROR";
      const errorMessage = error instanceof Error ? error.message : String(error);
      subscriber.next({
        type: import_client.EventType.RUN_ERROR,
        code: errorCode,
        message: errorMessage
      });
    }
    subscriber.complete();
  }
  clone() {
    const workflow = this.compiledWorkflow;
    const logger = this.logger;
    this.compiledWorkflow = void 0;
    const cloned = super.clone();
    this.compiledWorkflow = workflow;
    cloned.compiledWorkflow = workflow;
    cloned.logger = logger;
    return cloned;
  }
};
function aguiMessagesToLangChain(messages) {
  return messages.map((message, index) => {
    switch (message.role) {
      case "user":
        if (typeof message.content === "string") {
          return {
            id: message.id,
            role: message.role,
            content: message.content,
            type: "human"
          };
        } else {
          return {
            id: message.id,
            role: message.role,
            content: message.content.filter((m) => m.type === "text"),
            type: "human"
          };
        }
      case "assistant":
        return {
          id: message.id,
          type: "ai",
          role: message.role,
          content: message.content ?? "",
          tool_calls: (message.toolCalls ?? []).map((tc) => ({
            id: tc.id,
            name: tc.function.name,
            args: JSON.parse(tc.function.arguments),
            type: "tool_call"
          }))
        };
      case "system":
        return {
          id: message.id,
          role: message.role,
          content: message.content,
          type: "system"
        };
      case "tool":
        return {
          content: message.content,
          role: message.role,
          type: message.role,
          tool_call_id: message.toolCallId,
          id: message.id
        };
      default:
        throw new Error(`Message role ${message.role} is not supported.`);
    }
  });
}
function isValidJson(json) {
  try {
    JSON.parse(json);
    return true;
  } catch (e) {
    return false;
  }
}

// src/checkpoint.ts
var import_langgraph2 = require("@langchain/langgraph");
var import_agent_agents = require("@cloudbase/agent-agents");
var TDAISaver = class extends import_langgraph2.BaseCheckpointSaver {
  constructor(config) {
    super();
    const {
      checkpointType = "checkpoints",
      checkpointWritesType = "checkpoint_writes",
      ...clientConfig
    } = config;
    this.memoryClient = new import_agent_agents.MemoryClient(clientConfig);
    this.checkpointType = checkpointType;
    this.checkpointWritesType = checkpointWritesType;
  }
  /**
   * Retrieves a checkpoint from TDAI Memory based on the provided config.
   * If the config contains a "checkpoint_id" key, the checkpoint with the matching
   * thread ID and checkpoint ID is retrieved. Otherwise, the latest checkpoint
   * for the given thread ID is retrieved.
   */
  async getTuple(config) {
    try {
      const {
        thread_id,
        checkpoint_ns = "",
        checkpoint_id
      } = config.configurable ?? {};
      if (!thread_id) {
        return void 0;
      }
      const query = {
        collection: this.checkpointType,
        checkpoint_ns
      };
      if (checkpoint_id) {
        query.checkpoint_id = checkpoint_id;
      }
      const { events = [] } = await this.memoryClient.queryEvents({
        sessionId: thread_id,
        where: query,
        orderBy: { checkpoint_id: import_agent_agents.Order.DESCENDING },
        limit: 1
      });
      if (events.length === 0) {
        return void 0;
      }
      const doc = events[0];
      const configurableValues = {
        checkpoint_ns,
        checkpoint_id: doc.checkpoint_id
      };
      const checkpoint = doc.checkpoint;
      const { events: serializedWrites = [] } = await this.memoryClient.queryEvents({
        sessionId: thread_id,
        where: {
          collection: this.checkpointWritesType,
          ...configurableValues
        }
      });
      const pendingWrites = serializedWrites.map(
        (serializedWrite) => {
          return [
            serializedWrite.task_id,
            serializedWrite.channel,
            serializedWrite.value
          ];
        }
      );
      const metadata = doc.metadata || {};
      return {
        config: { configurable: configurableValues },
        checkpoint,
        pendingWrites,
        metadata,
        parentConfig: doc.parent_checkpoint_id != null ? {
          configurable: {
            thread_id,
            checkpoint_ns,
            checkpoint_id: doc.parent_checkpoint_id
          }
        } : void 0
      };
    } catch (error) {
      console.error("Error getting checkpoint:", error);
      return void 0;
    }
  }
  /**
   * Retrieve a list of checkpoint tuples from TDAI Memory based on the provided config.
   * The checkpoints are ordered by checkpoint ID in descending order (newest first).
   */
  async *list(config, options) {
    const { limit, before, filter } = options ?? {};
    if (!config?.configurable?.thread_id) {
      throw new Error("Thread ID is required");
    }
    const query = {
      collection: this.checkpointType
    };
    if (config?.configurable?.checkpoint_ns !== void 0 && config?.configurable?.checkpoint_ns !== null) {
      query.checkpoint_ns = config.configurable.checkpoint_ns;
    }
    if (filter) {
      Object.entries(filter).forEach(([key, value]) => {
        query[`metadata.${key}`] = value;
      });
    }
    if (before) {
      query.checkpoint_id = { $lt: before.configurable?.checkpoint_id };
    }
    const { events = [] } = await this.memoryClient.queryEvents({
      sessionId: config?.configurable?.thread_id || "default",
      where: query,
      orderBy: { checkpoint_id: import_agent_agents.Order.DESCENDING },
      limit
    });
    for (const doc of events) {
      const checkpoint = doc.checkpoint;
      const metadata = doc.metadata || {};
      yield {
        config: {
          configurable: {
            thread_id: doc.thread_id,
            checkpoint_ns: doc.checkpoint_ns,
            checkpoint_id: doc.checkpoint_id
          }
        },
        checkpoint,
        metadata,
        parentConfig: doc.parent_checkpoint_id ? {
          configurable: {
            thread_id: doc.thread_id,
            checkpoint_ns: doc.checkpoint_ns,
            checkpoint_id: doc.parent_checkpoint_id
          }
        } : void 0
      };
    }
  }
  /**
   * Saves a checkpoint to TDAI Memory. The checkpoint is associated with the
   * provided config and its parent config (if any).
   */
  async put(config, checkpoint, metadata) {
    try {
      const thread_id = config.configurable?.thread_id;
      const checkpoint_ns = config.configurable?.checkpoint_ns ?? "";
      const checkpoint_id = checkpoint.id;
      if (thread_id === void 0) {
        throw new Error(
          `The provided config must contain a configurable field with a "thread_id" field.`
        );
      }
      const doc = {
        collection: this.checkpointType,
        checkpoint_ns,
        checkpoint_id,
        parent_checkpoint_id: config.configurable?.checkpoint_id,
        checkpoint,
        metadata
      };
      const { events = [] } = await this.memoryClient.queryEvents({
        sessionId: thread_id,
        where: {
          collection: this.checkpointType,
          checkpoint_ns,
          checkpoint_id
        }
      });
      if (events[0]) {
        this.memoryClient.deleteEvent({
          sessionId: thread_id,
          eventId: events[0].id
          //   messages: doc,
        });
      } else {
        await this.memoryClient.appendEvent({
          sessionId: thread_id,
          messages: doc
        });
      }
      return {
        configurable: {
          thread_id,
          checkpoint_ns,
          checkpoint_id
        }
      };
    } catch (error) {
      console.error("Error saving checkpoint:", error);
      throw error;
    }
  }
  /**
   * Saves intermediate writes associated with a checkpoint to TDAI Memory.
   */
  async putWrites(config, writes, taskId) {
    try {
      const thread_id = config.configurable?.thread_id;
      const checkpoint_ns = config.configurable?.checkpoint_ns;
      const checkpoint_id = config.configurable?.checkpoint_id;
      if (thread_id === void 0 || checkpoint_ns === void 0 || checkpoint_id === void 0) {
        throw new Error(
          `The provided config must contain a configurable field with "thread_id", "checkpoint_ns" and "checkpoint_id" fields.`
        );
      }
      const writePromises = writes.map(async ([channel, value], idx) => {
        const writeDoc = {
          collection: this.checkpointWritesType,
          checkpoint_ns,
          checkpoint_id,
          task_id: taskId,
          idx,
          channel,
          value
          // Store directly as JSON
        };
        return this.memoryClient.appendEvent({
          sessionId: thread_id,
          messages: writeDoc
        });
      });
      await Promise.all(writePromises);
    } catch (error) {
      console.error("Error storing writes:", error);
      throw error;
    }
  }
  /**
   * Delete all checkpoints and writes for a thread from TDAI Memory.
   */
  async deleteThread(threadId) {
    try {
      await this.memoryClient.deleteSession({
        sessionId: threadId
      });
    } catch (error) {
      console.error("Error deleting thread:", error);
      throw error;
    }
  }
  /**
   * Close the memory client connection
   */
  close() {
    this.memoryClient.close();
  }
};

// src/store/tdai-store.ts
var import_langgraph3 = require("@langchain/langgraph");
var TDAIStore = class extends import_langgraph3.BaseStore {
  constructor(config) {
    super();
    this.isSetup = false;
    this.isClosed = false;
    this.client = config.memoryClient;
    this.namespacePrefix = config.namespacePrefix || [];
    this.ttlConfig = config.ttl;
    this.ensureTables = config.ensureTables ?? true;
    this.sessionId = config.sessionId || "default_session";
    this.defaultStrategy = config.defaultStrategy || "store";
  }
  /**
   * Create a storage key from namespace and key
   */
  createStorageKey(namespace, key) {
    const fullNamespace = [...this.namespacePrefix, ...namespace];
    return `${fullNamespace.join(":")}:${key}`;
  }
  /**
   * Parse a storage key back to namespace and key
   */
  parseStorageKey(storageKey) {
    const parts = storageKey.split(":");
    const prefixLength = this.namespacePrefix.length;
    const namespace = parts.slice(prefixLength, -1);
    const key = parts[parts.length - 1];
    return { namespace, key };
  }
  /**
   * Put an item with optional TTL.
   */
  async put(namespace, key, value, index, options) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const storageKey = this.createStorageKey(namespace, key);
    const content = JSON.stringify({
      storageKey,
      namespace,
      key,
      value,
      index,
      ttl: options?.ttl || this.ttlConfig?.defaultTtlSeconds
    });
    await this.client.appendRecord({
      sessionId: this.sessionId,
      content,
      strategy: this.defaultStrategy
    });
  }
  /**
   * Get an item by namespace and key.
   */
  async get(namespace, key) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const storageKey = this.createStorageKey(namespace, key);
    try {
      const { records = [] } = await this.client.searchRecords({
        content: storageKey,
        sessionId: this.sessionId,
        limit: 1
      });
      if (!records.length) {
        return null;
      }
      const record = records[0];
      const data = JSON.parse(record.record_content);
      if (data.ttl && record.created_at) {
        const createdTime = new Date(record.created_at).getTime();
        const now = Date.now();
        if (now > createdTime + data.ttl * 1e3) {
          await this.delete(namespace, key);
          return null;
        }
      }
      return {
        namespace,
        key,
        value: data.value,
        createdAt: new Date(record.created_at || Date.now()),
        updatedAt: new Date(record.updated_at || Date.now())
      };
    } catch (error) {
      return null;
    }
  }
  /**
   * Delete an item by namespace and key.
   */
  async delete(namespace, key) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const storageKey = this.createStorageKey(namespace, key);
    try {
      const { records = [] } = await this.client.searchRecords({
        content: storageKey,
        sessionId: this.sessionId,
        limit: 1
      });
      const record = records[0];
      if (record) {
        await this.client.deleteRecord({
          sessionId: this.sessionId,
          recordId: record.record_id
        });
      }
    } catch (error) {
    }
  }
  /**
   * List namespaces with optional filtering.
   */
  async listNamespaces(options = {}) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const { prefix, suffix, maxDepth, limit = 100, offset = 0 } = options;
    try {
      const { records = [] } = await this.client.queryRecords({
        limit: 1e3
        // Large limit to get all records
      });
      const namespaceSet = /* @__PURE__ */ new Set();
      for (const record of records) {
        try {
          const data = JSON.parse(record.record_content);
          if (data.namespace) {
            const namespace = data.namespace;
            if (prefix && prefix.length > 0) {
              const hasPrefix = prefix.every((p, i) => namespace[i] === p);
              if (!hasPrefix) continue;
            }
            if (suffix && suffix.length > 0) {
              const namespaceSuffix = namespace.slice(-suffix.length);
              if (JSON.stringify(namespaceSuffix) !== JSON.stringify(suffix)) {
                continue;
              }
            }
            if (maxDepth !== void 0 && namespace.length > maxDepth) {
              continue;
            }
            namespaceSet.add(JSON.stringify(namespace));
          }
        } catch (error) {
        }
      }
      const namespaces = Array.from(namespaceSet).map((ns) => JSON.parse(ns)).sort().slice(offset, offset + limit);
      return namespaces;
    } catch (error) {
      return [];
    }
  }
  /**
   * Execute multiple operations in a single batch.
   */
  async batch(operations) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const results = [];
    for (const operation of operations) {
      if ("namespacePrefix" in operation) {
        results.push(await this.executeSearch(operation));
      } else if ("key" in operation && !("value" in operation)) {
        const getOp = operation;
        results.push(await this.get(getOp.namespace, getOp.key));
      } else if ("value" in operation) {
        const putOp = operation;
        if (putOp.value !== null) {
          await this.put(
            putOp.namespace,
            putOp.key,
            putOp.value,
            putOp.index,
            putOp.options
          );
        }
        results.push(void 0);
      } else if ("matchConditions" in operation) {
        const listOp = operation;
        results.push(await this.executeListNamespaces(listOp));
      } else {
        throw new Error(
          `Unsupported operation type: ${JSON.stringify(operation)}`
        );
      }
    }
    return results;
  }
  /**
   * Execute search operation
   */
  async executeSearch(operation) {
    const { namespacePrefix, ...searchOptions } = operation;
    return this.search(namespacePrefix, searchOptions);
  }
  /**
   * Execute list namespaces operation
   */
  async executeListNamespaces(operation) {
    const { matchConditions, maxDepth, limit = 100, offset = 0 } = operation;
    let prefix;
    let suffix;
    if (matchConditions && matchConditions.length > 0) {
      for (const condition of matchConditions) {
        if (condition.matchType === "prefix") {
          prefix = condition.path;
        } else if (condition.matchType === "suffix") {
          suffix = condition.path;
        }
      }
    }
    return this.listNamespaces({
      prefix,
      suffix,
      maxDepth,
      limit,
      offset
    });
  }
  /**
   * Initialize the store.
   */
  async setup() {
    if (this.isSetup) return;
    if (this.ttlConfig?.sweepIntervalMinutes) {
      const intervalMs = this.ttlConfig.sweepIntervalMinutes * 60 * 1e3;
      this.sweepInterval = setInterval(async () => {
        try {
          await this.sweepExpiredItems();
        } catch (error) {
          console.error("Error during TTL sweep:", error);
        }
      }, intervalMs);
    }
    this.isSetup = true;
  }
  /**
   * Start the store.
   */
  async start() {
    if (this.ensureTables && !this.isSetup) {
      await this.setup();
    }
  }
  /**
   * Stop the store and close all connections.
   */
  async stop() {
    if (this.isClosed) return;
    if (this.sweepInterval) {
      clearInterval(this.sweepInterval);
      this.sweepInterval = void 0;
    }
    this.client.close();
    this.isClosed = true;
  }
  /**
   * Manually sweep expired items from the store.
   */
  async sweepExpiredItems() {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    try {
      const { records = [] } = await this.client.queryRecords({
        limit: 1e3
      });
      let cleanedCount = 0;
      const now = Date.now();
      for (const record of records) {
        try {
          const data = JSON.parse(record.record_content);
          if (data.ttl && data.createdAt) {
            const createdTime = new Date(data.createdAt).getTime();
            if (now > createdTime + data.ttl * 1e3) {
              await this.client.deleteRecord({
                sessionId: this.sessionId,
                recordId: record.record_id
              });
              cleanedCount++;
            }
          }
        } catch (error) {
        }
      }
      return cleanedCount;
    } catch (error) {
      return 0;
    }
  }
  /**
   * Get statistics about the store.
   */
  async getStats() {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    try {
      const { records = [] } = await this.client.queryRecords({
        limit: 1e3
      });
      let totalItems = 0;
      let expiredItems = 0;
      const namespaces = /* @__PURE__ */ new Set();
      const dates = [];
      const now = Date.now();
      for (const record of records) {
        try {
          const data = JSON.parse(record.record_content);
          totalItems++;
          if (data.namespace) {
            namespaces.add(data.namespace.join(":"));
          }
          if (data.createdAt) {
            dates.push(new Date(data.createdAt));
          }
          if (data.ttl && data.createdAt) {
            const createdTime = new Date(data.createdAt).getTime();
            if (now > createdTime + data.ttl * 1e3) {
              expiredItems++;
            }
          }
        } catch (error) {
        }
      }
      const oldestItem = dates.length > 0 ? new Date(Math.min(...dates.map((d) => d.getTime()))) : null;
      const newestItem = dates.length > 0 ? new Date(Math.max(...dates.map((d) => d.getTime()))) : null;
      return {
        totalItems,
        expiredItems,
        namespaceCount: namespaces.size,
        oldestItem,
        newestItem
      };
    } catch (error) {
      return {
        totalItems: 0,
        expiredItems: 0,
        namespaceCount: 0,
        oldestItem: null,
        newestItem: null
      };
    }
  }
  /**
   * Search for items in the store with support for text search and filtering.
   */
  async search(namespacePrefix, options = {}) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const { filter, query, limit = 10, offset = 0, refreshTtl } = options;
    try {
      const namespaceKey = [...this.namespacePrefix, ...namespacePrefix].join(
        ":"
      );
      let searchResult;
      if (query) {
        searchResult = await this.client.searchRecords({
          content: query,
          limit: limit + offset
        });
      } else {
        searchResult = await this.client.queryRecords({
          limit: limit + offset
        });
      }
      const items = [];
      const now = Date.now();
      if (searchResult.records) {
        for (const record of searchResult.records.slice(
          offset,
          offset + limit
        )) {
          try {
            const data = JSON.parse(record.record_content);
            if (namespaceKey && !data.storageKey?.startsWith(namespaceKey)) {
              continue;
            }
            if (data.ttl && data.createdAt) {
              const createdTime = new Date(data.createdAt).getTime();
              if (now > createdTime + data.ttl * 1e3) {
                continue;
              }
            }
            if (filter) {
              let matches = true;
              for (const [key, value] of Object.entries(filter)) {
                if (data.value[key] !== value) {
                  matches = false;
                  break;
                }
              }
              if (!matches) continue;
            }
            const item = {
              namespace: data.namespace,
              key: data.key,
              value: data.value,
              createdAt: new Date(record.created_at || Date.now()),
              updatedAt: new Date(record.updated_at || Date.now())
            };
            items.push(item);
            if (refreshTtl && this.ttlConfig?.defaultTtlSeconds) {
              await this.put(data.namespace, data.key, data.value, void 0, {
                ttl: this.ttlConfig.defaultTtlSeconds
              });
            }
          } catch (error) {
          }
        }
      }
      return items;
    } catch (error) {
      return [];
    }
  }
};

// src/index.ts
var import_agent_shared3 = require("@cloudbase/agent-shared");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ClientPropertiesAnnotation,
  ClientStateAnnotation,
  LanggraphAgent,
  TDAISaver,
  TDAIStore,
  createConsoleLogger,
  noopLogger
});
//# sourceMappingURL=index.js.map