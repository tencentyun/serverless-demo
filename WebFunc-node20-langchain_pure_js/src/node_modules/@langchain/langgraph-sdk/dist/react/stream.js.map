{"version":3,"file":"stream.js","names":[],"sources":["../../src/react/stream.tsx"],"sourcesContent":["import { useState } from \"react\";\nimport { useStreamLGP } from \"./stream.lgp.js\";\nimport { useStreamCustom } from \"./stream.custom.js\";\nimport type { UseStreamOptions, InferAgentToolCalls } from \"../ui/types.js\";\nimport type { Message } from \"../types.messages.js\";\nimport type { BagTemplate } from \"../types.template.js\";\nimport type {\n  UseStream,\n  UseStreamCustom,\n  UseStreamCustomOptions,\n} from \"./types.js\";\n\nfunction isCustomOptions<\n  StateType extends Record<string, unknown> = Record<string, unknown>,\n  Bag extends BagTemplate = BagTemplate\n>(\n  options:\n    | UseStreamOptions<StateType, Bag>\n    | UseStreamCustomOptions<StateType, Bag>\n): options is UseStreamCustomOptions<StateType, Bag> {\n  return \"transport\" in options;\n}\n\n/**\n * Helper type that infers StateType based on whether T is an agent-like type, a CompiledGraph/Pregel instance, or a state type.\n * - If T has `~agentTypes`, returns a state with typed messages based on the agent's tools\n * - If T has `~RunOutput` (CompiledGraph/CompiledStateGraph), returns the state type\n * - If T has `~OutputType` (Pregel), returns the output type as state\n * - Otherwise, returns T (direct state type)\n */\ntype InferStateType<T> = T extends { \"~agentTypes\": unknown }\n  ? { messages: Message<InferAgentToolCalls<T>>[] }\n  : T extends { \"~RunOutput\": infer S }\n  ? S extends Record<string, unknown>\n    ? S\n    : Record<string, unknown>\n  : T extends { \"~OutputType\": infer O }\n  ? O extends Record<string, unknown>\n    ? O\n    : Record<string, unknown>\n  : T extends Record<string, unknown>\n  ? T\n  : Record<string, unknown>;\n\n/**\n * Helper type that infers Bag based on whether T is an agent-like type.\n * - If T has `~agentTypes`, extracts bag from the agent's tools\n * - Otherwise, returns the default BagTemplate\n */\ntype InferBag<T, B extends BagTemplate = BagTemplate> = T extends {\n  \"~agentTypes\": unknown;\n}\n  ? BagTemplate\n  : B;\n\n/**\n * A React hook that provides seamless integration with LangGraph streaming capabilities.\n *\n * The `useStream` hook handles all the complexities of streaming, state management, and branching logic,\n * letting you focus on building great chat experiences. It provides automatic state management for\n * messages, interrupts, loading states, and errors.\n *\n * ## Usage with ReactAgent (recommended for createAgent users)\n *\n * When using `createAgent` from `@langchain/langgraph`, you can pass `typeof agent` as the\n * type parameter to automatically infer tool call types:\n *\n * @example\n * ```typescript\n * // In your agent file (e.g., agent.ts)\n * import { createAgent, tool } from \"@langchain/langgraph\";\n * import { z } from \"zod\";\n *\n * const getWeather = tool(\n *   async ({ location }) => `Weather in ${location}`,\n *   { name: \"get_weather\", schema: z.object({ location: z.string() }) }\n * );\n *\n * export const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   tools: [getWeather],\n * });\n *\n * // In your React component\n * import { agent } from \"./agent\";\n *\n * function Chat() {\n *   // Tool calls are automatically typed from the agent's tools!\n *   const stream = useStream<typeof agent>({\n *     assistantId: \"agent\",\n *     apiUrl: \"http://localhost:2024\",\n *   });\n *\n *   // stream.toolCalls[0].call.name is typed as \"get_weather\"\n *   // stream.toolCalls[0].call.args is typed as { location: string }\n * }\n * ```\n *\n * ## Usage with StateGraph (for custom LangGraph applications)\n *\n * When building custom graphs with `StateGraph`, embed your tool call types directly\n * in your state's messages property using `Message<MyToolCalls>`:\n *\n * @example\n * ```typescript\n * import { Message } from \"@langchain/langgraph-sdk\";\n *\n * // Define your tool call types as a discriminated union\n * type MyToolCalls =\n *   | { name: \"search\"; args: { query: string }; id?: string }\n *   | { name: \"calculate\"; args: { expression: string }; id?: string };\n *\n * // Embed tool call types in your state's messages\n * interface MyGraphState {\n *   messages: Message<MyToolCalls>[];\n *   context?: string;\n * }\n *\n * function Chat() {\n *   const stream = useStream<MyGraphState>({\n *     assistantId: \"my-graph\",\n *     apiUrl: \"http://localhost:2024\",\n *   });\n *\n *   // stream.values is typed as MyGraphState\n *   // stream.toolCalls[0].call.name is typed as \"search\" | \"calculate\"\n * }\n * ```\n *\n * @example\n * ```typescript\n * // With additional type configuration (interrupts, configurable)\n * interface MyGraphState {\n *   messages: Message<MyToolCalls>[];\n * }\n *\n * function Chat() {\n *   const stream = useStream<MyGraphState, {\n *     InterruptType: { question: string };\n *     ConfigurableType: { userId: string };\n *   }>({\n *     assistantId: \"my-graph\",\n *     apiUrl: \"http://localhost:2024\",\n *   });\n *\n *   // stream.interrupt is typed as { question: string } | undefined\n * }\n * ```\n *\n * @template T Either a ReactAgent type (with `~agentTypes`) or a state type (`Record<string, unknown>`)\n * @template Bag Type configuration bag containing:\n *   - `ConfigurableType`: Type for the `config.configurable` property\n *   - `InterruptType`: Type for interrupt values\n *   - `CustomEventType`: Type for custom events\n *   - `UpdateType`: Type for the submit function updates\n *\n * @see {@link https://docs.langchain.com/langgraph-platform/use-stream-react | LangGraph React Integration Guide}\n */\nexport function useStream<\n  T = Record<string, unknown>,\n  Bag extends BagTemplate = BagTemplate\n>(\n  options: UseStreamOptions<InferStateType<T>, InferBag<T, Bag>>\n): UseStream<InferStateType<T>, InferBag<T, Bag>>;\n\n/**\n * A React hook that provides seamless integration with LangGraph streaming capabilities.\n *\n * The `useStream` hook handles all the complexities of streaming, state management, and branching logic,\n * letting you focus on building great chat experiences. It provides automatic state management for\n * messages, interrupts, loading states, and errors.\n *\n * @template T Either a ReactAgent type (with `~agentTypes`) or a state type (`Record<string, unknown>`)\n * @template Bag Type configuration bag containing:\n *   - `ConfigurableType`: Type for the `config.configurable` property\n *   - `InterruptType`: Type for interrupt values\n *   - `CustomEventType`: Type for custom events\n *   - `UpdateType`: Type for the submit function updates\n *\n * @see {@link https://docs.langchain.com/langgraph-platform/use-stream-react | LangGraph React Integration Guide}\n */\nexport function useStream<\n  T = Record<string, unknown>,\n  Bag extends BagTemplate = BagTemplate\n>(\n  options: UseStreamCustomOptions<InferStateType<T>, InferBag<T, Bag>>\n): UseStreamCustom<InferStateType<T>, InferBag<T, Bag>>;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function useStream(options: any): any {\n  // Store this in useState to make sure we're not changing the implementation in re-renders\n  const [isCustom] = useState(isCustomOptions(options));\n\n  if (isCustom) {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    return useStreamCustom(options);\n  }\n\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return useStreamLGP(options);\n}\n"],"mappings":";;;;;AAYA,SAAS,gBAIP,SAGmD;AACnD,QAAO,eAAe;;AAyKxB,SAAgB,UAAU,SAAmB;CAE3C,MAAM,CAAC,YAAY,SAAS,gBAAgB,QAAQ,CAAC;AAErD,KAAI,SAEF,QAAO,gBAAgB,QAAQ;AAIjC,QAAO,aAAa,QAAQ"}