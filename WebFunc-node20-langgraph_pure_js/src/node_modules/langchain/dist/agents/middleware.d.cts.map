{"version":3,"file":"middleware.d.cts","names":["InteropZodObject","InferInteropZodOutput","ClientTool","ServerTool","AgentMiddleware","WrapToolCallHook","WrapModelCallHook","BeforeAgentHook","BeforeModelHook","AfterModelHook","AfterAgentHook","createMiddleware","TSchema","TContextSchema","TTools","NormalizeContextSchema"],"sources":["../../src/agents/middleware.d.ts"],"sourcesContent":["import type { InteropZodObject, InferInteropZodOutput } from \"@langchain/core/utils/types\";\nimport type { ClientTool, ServerTool } from \"@langchain/core/tools\";\nimport { type AgentMiddleware, type WrapToolCallHook, type WrapModelCallHook, type BeforeAgentHook, type BeforeModelHook, type AfterModelHook, type AfterAgentHook } from \"./middleware/types.js\";\n/**\n * Creates a middleware instance with automatic schema inference.\n *\n * @param config - Middleware configuration\n * @param config.name - The name of the middleware\n * @param config.stateSchema - The schema of the middleware state\n * @param config.contextSchema - The schema of the middleware context\n * @param config.wrapModelCall - The function to wrap model invocation\n * @param config.wrapToolCall - The function to wrap tool invocation\n * @param config.beforeModel - The function to run before the model call\n * @param config.afterModel - The function to run after the model call\n * @param config.beforeAgent - The function to run before the agent execution starts\n * @param config.afterAgent - The function to run after the agent execution completes\n * @returns A middleware instance\n *\n * @example\n * ```ts\n * const authMiddleware = createMiddleware({\n *   name: \"AuthMiddleware\",\n *   stateSchema: z.object({\n *     isAuthenticated: z.boolean().default(false),\n *   }),\n *   contextSchema: z.object({\n *     userId: z.string(),\n *   }),\n *   beforeModel: async (state, runtime, controls) => {\n *     if (!state.isAuthenticated) {\n *       return controls.terminate(new Error(\"Not authenticated\"));\n *     }\n *   },\n * });\n * ```\n */\nexport declare function createMiddleware<TSchema extends InteropZodObject | undefined = undefined, TContextSchema extends InteropZodObject | undefined = undefined, const TTools extends readonly (ClientTool | ServerTool)[] = readonly (ClientTool | ServerTool)[]>(config: {\n    /**\n     * The name of the middleware\n     */\n    name: string;\n    /**\n     * The schema of the middleware state. Middleware state is persisted between multiple invocations. It can be either:\n     * - A Zod object\n     * - A Zod optional object\n     * - A Zod default object\n     * - Undefined\n     */\n    stateSchema?: TSchema;\n    /**\n     * The schema of the middleware context. Middleware context is read-only and not persisted between multiple invocations. It can be either:\n     * - A Zod object\n     * - A Zod optional object\n     * - A Zod default object\n     * - Undefined\n     */\n    contextSchema?: TContextSchema;\n    /**\n     * Additional tools registered by the middleware.\n     */\n    tools?: TTools;\n    /**\n     * Wraps tool execution with custom logic. This allows you to:\n     * - Modify tool call parameters before execution\n     * - Handle errors and retry with different parameters\n     * - Post-process tool results\n     * - Implement caching, logging, authentication, or other cross-cutting concerns\n     * - Return Command objects for advanced control flow\n     *\n     * The handler receives a ToolCallRequest containing the tool call, state, and runtime,\n     * along with a handler function to execute the actual tool.\n     *\n     * @param request - The tool call request containing toolCall, state, and runtime.\n     * @param handler - The function that executes the tool. Call this with a ToolCallRequest to get the result.\n     * @returns The tool result as a ToolMessage or a Command for advanced control flow.\n     *\n     * @example\n     * ```ts\n     * wrapToolCall: async (request, handler) => {\n     *   console.log(`Calling tool: ${request.tool.name}`);\n     *   console.log(`Tool description: ${request.tool.description}`);\n     *\n     *   try {\n     *     // Execute the tool\n     *     const result = await handler(request);\n     *     console.log(`Tool ${request.tool.name} succeeded`);\n     *     return result;\n     *   } catch (error) {\n     *     console.error(`Tool ${request.tool.name} failed:`, error);\n     *     // Could return a custom error message or retry\n     *     throw error;\n     *   }\n     * }\n     * ```\n     *\n     * @example Authentication\n     * ```ts\n     * wrapToolCall: async (request, handler) => {\n     *   // Check if user is authorized for this tool\n     *   if (!request.runtime.context.isAuthorized(request.tool.name)) {\n     *     return new ToolMessage({\n     *       content: \"Unauthorized to call this tool\",\n     *       tool_call_id: request.toolCall.id,\n     *     });\n     *   }\n     *   return handler(request);\n     * }\n     * ```\n     */\n    wrapToolCall?: WrapToolCallHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n    /**\n     * Wraps the model invocation with custom logic. This allows you to:\n     * - Modify the request before calling the model\n     * - Handle errors and retry with different parameters\n     * - Post-process the response\n     * - Implement custom caching, logging, or other cross-cutting concerns\n     *\n     * The request parameter contains: model, messages, systemPrompt, tools, state, and runtime.\n     *\n     * @param request - The model request containing all the parameters needed.\n     * @param handler - The function that invokes the model. Call this with a ModelRequest to get the response.\n     * @returns The response from the model (or a modified version).\n     *\n     * @example\n     * ```ts\n     * wrapModelCall: async (request, handler) => {\n     *   // Modify request before calling\n     *   const modifiedRequest = { ...request, systemPrompt: \"You are helpful\" };\n     *\n     *   try {\n     *     // Call the model\n     *     return await handler(modifiedRequest);\n     *   } catch (error) {\n     *     // Handle errors and retry with fallback\n     *     const fallbackRequest = { ...request, model: fallbackModel };\n     *     return await handler(fallbackRequest);\n     *   }\n     * }\n     * ```\n     */\n    wrapModelCall?: WrapModelCallHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n    /**\n     * The function to run before the agent execution starts. This function is called once at the start of the agent invocation.\n     * It allows to modify the state of the agent before any model calls or tool executions.\n     *\n     * @param state - The middleware state\n     * @param runtime - The middleware runtime\n     * @returns The modified middleware state or undefined to pass through\n     */\n    beforeAgent?: BeforeAgentHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n    /**\n     * The function to run before the model call. This function is called before the model is invoked and before the `wrapModelCall` hook.\n     * It allows to modify the state of the agent.\n     *\n     * @param state - The middleware state\n     * @param runtime - The middleware runtime\n     * @returns The modified middleware state or undefined to pass through\n     */\n    beforeModel?: BeforeModelHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n    /**\n     * The function to run after the model call. This function is called after the model is invoked and before any tools are called.\n     * It allows to modify the state of the agent after the model is invoked, e.g. to update tool call parameters.\n     *\n     * @param state - The middleware state\n     * @param runtime - The middleware runtime\n     * @returns The modified middleware state or undefined to pass through\n     */\n    afterModel?: AfterModelHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n    /**\n     * The function to run after the agent execution completes. This function is called once at the end of the agent invocation.\n     * It allows to modify the final state of the agent after all model calls and tool executions are complete.\n     *\n     * @param state - The middleware state\n     * @param runtime - The middleware runtime\n     * @returns The modified middleware state or undefined to pass through\n     */\n    afterAgent?: AfterAgentHook<TSchema, NormalizeContextSchema<TContextSchema>>;\n}): AgentMiddleware<TSchema, TContextSchema, NormalizeContextSchema<TContextSchema>, TTools>;\ntype NormalizeContextSchema<TContextSchema extends InteropZodObject | undefined = undefined> = TContextSchema extends InteropZodObject ? InferInteropZodOutput<TContextSchema> : unknown;\nexport {};\n//# sourceMappingURL=middleware.d.ts.map"],"mappings":";;;;;;;;AAoCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4IgEa,iBA5IxCF,gBA4IwCE,CAAAA,gBA5IPb,gBA4IOa,GAAAA,SAAAA,GAAAA,SAAAA,EAAAA,uBA5I0Db,gBA4I1Da,GAAAA,SAAAA,GAAAA,SAAAA,EAAAA,qBAAAA,SAAAA,CA5ImIX,UA4InIW,GA5IgJV,UA4IhJU,CAAAA,EAAAA,GAAAA,SAAAA,CA5I0KX,UA4I1KW,GA5IuLV,UA4IvLU,CAAAA,EAAAA,CAAAA,CAAAA,MAAAA,EAAAA;EAAvBE;;;EACZF,IAAAA,EAAAA,MAAAA;EAAuCA;;;;AAAjD;AAA0E;;EACEA,WAAAA,CAAAA,EAlI7ED,OAkI6EC;EAAuBb;;;AAAwC;;;;kBA1H1Ia;;;;UAIRC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBAiDOT,iBAAiBO,SAASG,uBAAuBF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBA+BhDP,kBAAkBM,SAASG,uBAAuBF;;;;;;;;;gBASpDN,gBAAgBK,SAASG,uBAAuBF;;;;;;;;;gBAShDL,gBAAgBI,SAASG,uBAAuBF;;;;;;;;;eASjDJ,eAAeG,SAASG,uBAAuBF;;;;;;;;;eAS/CH,eAAeE,SAASG,uBAAuBF;IAC5DT,gBAAgBQ,SAASC,gBAAgBE,uBAAuBF,iBAAiBC;KAChFC,8CAA8Cf,4CAA4Ca,uBAAuBb,mBAAmBC,sBAAsBY"}