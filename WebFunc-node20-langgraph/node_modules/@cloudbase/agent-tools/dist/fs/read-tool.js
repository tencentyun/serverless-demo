"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.readParametersSchema = void 0;
exports.read = read;
exports.createReadTool = createReadTool;
const path = __importStar(require("path"));
const mime = __importStar(require("mime-types"));
const v4_1 = require("zod/v4");
const utils_1 = require("./utils");
const utils_2 = require("../utils");
// Constants for file processing
const DEFAULT_MAX_LINES = 1000;
const MAX_LINE_LENGTH = 2000;
const MAX_FILE_SIZE_BYTES = 10 * 1024 * 1024; // 10MB
/**
 * Detect file type based on extension and content
 */
function detectFileType(context, filePath) {
    const ext = path.extname(filePath).toLowerCase();
    const mimeType = mime.lookup(filePath);
    // Check for images
    if (mimeType && mimeType.startsWith("image/")) {
        return "image";
    }
    // Check for PDF
    if (mimeType === "application/pdf") {
        return "pdf";
    }
    // Known binary extensions
    const binaryExtensions = [
        ".exe",
        ".dll",
        ".so",
        ".dylib",
        ".zip",
        ".tar",
        ".gz",
        ".7z",
        ".bin",
        ".dat",
        ".class",
        ".jar",
        ".war",
        ".pyc",
        ".pyo",
        ".doc",
        ".docx",
        ".xls",
        ".xlsx",
        ".ppt",
        ".pptx",
        ".odt",
        ".ods",
        ".odp",
        ".wasm",
        ".obj",
        ".o",
        ".a",
        ".lib",
    ];
    if (binaryExtensions.includes(ext)) {
        return "binary";
    }
    return "text";
}
/**
 * Process text file content with line range support
 */
async function processTextFile(context, filePath, startLine, lineCount, endLine, encoding = "utf-8") {
    const content = (await context.fsOperator.readFile(filePath, encoding)).toString();
    const lines = content.split("\n");
    const originalLineCount = lines.length;
    // Handle line range
    const actualStartLine = Math.max((startLine || 1) - 1, 0); // Convert to 0-based
    if (endLine === undefined) {
        const actualLineCount = lineCount || Math.min(DEFAULT_MAX_LINES, originalLineCount);
        endLine = Math.min(actualStartLine + actualLineCount, originalLineCount);
    }
    if (endLine < 0) {
        endLine += originalLineCount + 1;
    }
    const selectedLines = lines.slice(actualStartLine, endLine);
    // Truncate long lines
    let linesWereTruncated = false;
    const processedLines = selectedLines.map((line) => {
        if (line.length > MAX_LINE_LENGTH) {
            linesWereTruncated = true;
            return line.substring(0, MAX_LINE_LENGTH) + "... [line truncated]";
        }
        return line;
    });
    const contentWasTruncated = endLine < originalLineCount;
    const isTruncated = contentWasTruncated || linesWereTruncated;
    let processedContent = catWithLineNumbers(processedLines.join("\n"), actualStartLine);
    // Add truncation notice
    if (contentWasTruncated) {
        processedContent =
            `[Content truncated: showing lines ${actualStartLine + 1}-${endLine} of ${originalLineCount} total lines]\n\n` + processedContent;
    }
    else if (linesWereTruncated) {
        processedContent =
            `[Some lines truncated due to length (max ${MAX_LINE_LENGTH} chars)]\n\n` +
                processedContent;
    }
    return {
        content: processedContent,
        metadata: {
            lineCount: originalLineCount,
            isTruncated,
            linesShown: [actualStartLine + 1, endLine],
        },
    };
}
/**
 * Process image or PDF file
 */
async function processMediaFile(context, filePath, fileType) {
    const buffer = await context.fsOperator.readFile(filePath);
    const mimeType = mime.lookup(filePath) || "application/octet-stream";
    // For SuperDesign, we'll return a descriptive message rather than raw base64
    // The actual file handling would be done by the VS Code webview
    const fileName = path.basename(filePath);
    const fileSize = (buffer.length / 1024).toFixed(1);
    return {
        content: `[${fileType.toUpperCase()} FILE: ${fileName}]\nFile size: ${fileSize} KB\nMIME type: ${mimeType}\nBase64 data available for webview display.`,
        metadata: {
            mimeType,
        },
    };
}
async function read(context, params) {
    const { file_path, offset: startLine, endLine, limit: lineCount, encoding = "utf-8", } = params;
    const startTime = Date.now();
    try {
        // Validate workspace path (handles both absolute and relative paths)
        const pathError = (0, utils_1.validateWorkspacePath)(file_path, context);
        if (pathError) {
            return pathError;
        }
        // Resolve file path
        const absolutePath = (0, utils_1.resolveWorkspacePath)(file_path, context);
        // Check file existence
        const fileError = await (0, utils_1.validateFileExists)(context, absolutePath, file_path);
        if (fileError) {
            return fileError;
        }
        // Check if it's a directory
        const stats = await context.fsOperator.stat(absolutePath);
        if (stats.isDirectory()) {
            return (0, utils_2.handleToolError)(`Path is a directory, not a file: ${file_path}`, "Path validation", "validation");
        }
        // Check file size
        if (stats.size > MAX_FILE_SIZE_BYTES) {
            const sizeMB = (stats.size / 1024 / 1024).toFixed(1);
            return (0, utils_2.handleToolError)(`File too large (${sizeMB}MB). Maximum size: ${MAX_FILE_SIZE_BYTES / 1024 / 1024}MB`, "File size check", "validation");
        }
        // Detect file type
        const fileType = detectFileType(context, absolutePath);
        context.messageHandler?.currentText.append(`\n[read] Reading ${fileType} file: ${file_path} (${(stats.size / 1024).toFixed(1)} KB)`);
        let content;
        let metadata = {};
        // Process based on file type
        switch (fileType) {
            case "text": {
                const result = await processTextFile(context, absolutePath, startLine, lineCount, endLine, encoding);
                content = result.content;
                metadata = result.metadata;
                break;
            }
            case "image":
            case "pdf": {
                const result = await processMediaFile(context, absolutePath, fileType);
                content = result.content;
                metadata = result.metadata;
                break;
            }
            case "binary": {
                const fileName = path.basename(absolutePath);
                const fileSize = (stats.size / 1024).toFixed(1);
                content = `[BINARY FILE: ${fileName}]\nFile size: ${fileSize} KB\nCannot display binary content as text.`;
                break;
            }
            default:
                return (0, utils_2.handleToolError)(`Unsupported file type: ${fileType}`, "File type detection", "validation");
        }
        // Create result
        const fileReadResult = {
            content,
            filePath: file_path || "",
            fileType,
            mimeType: mime.lookup(absolutePath) || undefined,
            size: stats.size,
            ...metadata,
        };
        const duration = Date.now() - startTime;
        context.messageHandler?.currentText.append(`\n[read] File read completed in ${duration}ms\n`);
        return (0, utils_1.createSuccessResponse)(fileReadResult);
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        context.messageHandler?.currentText.append(`\n[read] Read failed: ${errorMessage}\n`);
        return (0, utils_2.handleToolError)(error, "Read tool execution", "execution");
    }
}
function catWithLineNumbers(content, offset = 0) {
    // Split by lines
    const lines = content.split("\n");
    // Add line numbers to each line, consistent with cat -n format
    const numberedLines = lines.map((line, index) => {
        const lineNumber = index + 1 + offset;
        // Right-align line numbers, 6-digit width, followed by tab
        return `${lineNumber.toString().padStart(6)}\t${line}`;
    });
    return numberedLines.join("\n");
}
exports.readParametersSchema = v4_1.z.object({
    file_path: v4_1.z.string().describe("The absolute path to the file to read"),
    offset: v4_1.z
        .number()
        .optional()
        .describe("Optional: The number of lines to read. Only provide if the file is too large to read at once. Default: 0"),
    limit: v4_1.z
        .number()
        .optional()
        .describe("Optional: The line number to start reading from. Only provide if the file is too large to read at once. Default: undefined, which means start from the beginning."),
});
/**
 * Create SuperDesign read tool with execution context
 */
function createReadTool(context) {
    return (0, utils_2.tool)((params) => read(context, params), {
        name: "Read",
        description: "Reads a file from the local filesystem. You can access any file directly by using this tool.\nAssume this tool is able to read all files on the machine. If the User provides a path to a file assume that path is valid. It is okay to read a file that does not exist; an error will be returned.\n\nUsage:\n- The file_path parameter must be an absolute path, not a relative path\n- By default, it reads up to 2000 lines starting from the beginning of the file\n- You can optionally specify a line offset and limit (especially handy for long files), but it's recommended to read the whole file by not providing these parameters\n- Any lines longer than 2000 characters will be truncated\n- Results are returned using cat -n format, with line numbers starting at 1\n- You have the capability to call multiple tools in a single response. It is always better to speculatively read multiple files as a batch that are potentially useful. \n- If you read a file that exists but has empty contents you will receive a system reminder warning in place of file contents.",
        schema: exports.readParametersSchema,
        getDisplay: ({ name, input }) => {
            return `> Using ${name} for tool call: ${input.file_path || ""}`;
        },
    });
}
//# sourceMappingURL=read-tool.js.map