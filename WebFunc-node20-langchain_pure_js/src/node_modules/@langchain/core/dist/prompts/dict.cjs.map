{"version":3,"file":"dict.cjs","names":["Runnable","fields: {\n    template: Record<string, unknown>;\n    templateFormat?: TemplateFormat;\n  }","values: TypedPromptInputValues<RunInput>","values: TypedPromptInputValues<InputValues>","template: Record<string, unknown>","templateFormat: TemplateFormat","inputVariables: Array<Extract<keyof InputValues, string>>","parseTemplate","inputs: TypedPromptInputValues<InputValues>","formatted: Record<string, unknown>","renderTemplate","formattedV: Array<unknown>"],"sources":["../../src/prompts/dict.ts"],"sourcesContent":["import { Runnable } from \"../runnables/base.js\";\nimport type { InputValues } from \"../utils/types/index.js\";\nimport { TypedPromptInputValues } from \"./base.js\";\nimport { parseTemplate, renderTemplate, TemplateFormat } from \"./template.js\";\n\nexport class DictPromptTemplate<\n  RunInput extends InputValues = InputValues,\n  RunOutput extends Record<string, unknown> = Record<string, unknown>,\n> extends Runnable<TypedPromptInputValues<RunInput>, RunOutput> {\n  lc_namespace = [\"langchain_core\", \"prompts\", \"dict\"];\n\n  lc_serializable = true;\n\n  template: Record<string, unknown>;\n\n  templateFormat: TemplateFormat;\n\n  inputVariables: Array<Extract<keyof RunInput, string>>;\n\n  static lc_name() {\n    return \"DictPromptTemplate\";\n  }\n\n  constructor(fields: {\n    template: Record<string, unknown>;\n    templateFormat?: TemplateFormat;\n  }) {\n    const templateFormat = fields.templateFormat ?? \"f-string\";\n    const inputVariables = _getInputVariables(\n      fields.template,\n      templateFormat\n    ) as Array<Extract<keyof RunInput, string>>;\n    super({ inputVariables, ...fields });\n    this.template = fields.template;\n    this.templateFormat = templateFormat;\n    this.inputVariables = inputVariables;\n  }\n\n  async format(values: TypedPromptInputValues<RunInput>): Promise<RunOutput> {\n    return _insertInputVariables(\n      this.template,\n      values,\n      this.templateFormat\n    ) as RunOutput;\n  }\n\n  async invoke(\n    values: TypedPromptInputValues<InputValues>\n  ): Promise<RunOutput> {\n    return await this._callWithConfig(this.format.bind(this), values, {\n      runType: \"prompt\",\n    });\n  }\n}\n\nfunction _getInputVariables(\n  template: Record<string, unknown>,\n  templateFormat: TemplateFormat\n): Array<Extract<keyof InputValues, string>> {\n  const inputVariables: Array<Extract<keyof InputValues, string>> = [];\n  for (const v of Object.values(template)) {\n    if (typeof v === \"string\") {\n      parseTemplate(v, templateFormat).forEach((t) => {\n        if (t.type === \"variable\") {\n          inputVariables.push(t.name);\n        }\n      });\n    } else if (Array.isArray(v)) {\n      for (const x of v) {\n        if (typeof x === \"string\") {\n          parseTemplate(x, templateFormat).forEach((t) => {\n            if (t.type === \"variable\") {\n              inputVariables.push(t.name);\n            }\n          });\n        } else if (typeof x === \"object\") {\n          inputVariables.push(..._getInputVariables(x, templateFormat));\n        }\n      }\n    } else if (typeof v === \"object\" && v !== null) {\n      inputVariables.push(\n        ..._getInputVariables(v as Record<string, unknown>, templateFormat)\n      );\n    }\n  }\n  return Array.from(new Set(inputVariables));\n}\n\nfunction _insertInputVariables(\n  template: Record<string, unknown>,\n  inputs: TypedPromptInputValues<InputValues>,\n  templateFormat: TemplateFormat\n): Record<string, unknown> {\n  const formatted: Record<string, unknown> = {};\n  for (const [k, v] of Object.entries(template)) {\n    if (typeof v === \"string\") {\n      formatted[k] = renderTemplate(v, templateFormat, inputs);\n    } else if (Array.isArray(v)) {\n      const formattedV: Array<unknown> = [];\n      for (const x of v) {\n        if (typeof x === \"string\") {\n          formattedV.push(renderTemplate(x, templateFormat, inputs));\n        } else if (typeof x === \"object\") {\n          formattedV.push(_insertInputVariables(x, inputs, templateFormat));\n        }\n      }\n      formatted[k] = formattedV;\n    } else if (typeof v === \"object\" && v !== null) {\n      formatted[k] = _insertInputVariables(\n        v as Record<string, unknown>,\n        inputs,\n        templateFormat\n      );\n    } else {\n      formatted[k] = v;\n    }\n  }\n  return formatted;\n}\n"],"mappings":";;;;AAKA,IAAa,qBAAb,cAGUA,sBAAsD;CAC9D,eAAe;EAAC;EAAkB;EAAW;CAAO;CAEpD,kBAAkB;CAElB;CAEA;CAEA;CAEA,OAAO,UAAU;AACf,SAAO;CACR;CAED,YAAYC,QAGT;EACD,MAAM,iBAAiB,OAAO,kBAAkB;EAChD,MAAM,iBAAiB,mBACrB,OAAO,UACP,eACD;EACD,MAAM;GAAE;GAAgB,GAAG;EAAQ,EAAC;EACpC,KAAK,WAAW,OAAO;EACvB,KAAK,iBAAiB;EACtB,KAAK,iBAAiB;CACvB;CAED,MAAM,OAAOC,QAA8D;AACzE,SAAO,sBACL,KAAK,UACL,QACA,KAAK,eACN;CACF;CAED,MAAM,OACJC,QACoB;AACpB,SAAO,MAAM,KAAK,gBAAgB,KAAK,OAAO,KAAK,KAAK,EAAE,QAAQ,EAChE,SAAS,SACV,EAAC;CACH;AACF;AAED,SAAS,mBACPC,UACAC,gBAC2C;CAC3C,MAAMC,iBAA4D,CAAE;AACpE,MAAK,MAAM,KAAK,OAAO,OAAO,SAAS,CACrC,KAAI,OAAO,MAAM,UACfC,+BAAc,GAAG,eAAe,CAAC,QAAQ,CAAC,MAAM;AAC9C,MAAI,EAAE,SAAS,YACb,eAAe,KAAK,EAAE,KAAK;CAE9B,EAAC;UACO,MAAM,QAAQ,EAAE,EACzB;OAAK,MAAM,KAAK,EACd,KAAI,OAAO,MAAM,UACfA,+BAAc,GAAG,eAAe,CAAC,QAAQ,CAAC,MAAM;AAC9C,OAAI,EAAE,SAAS,YACb,eAAe,KAAK,EAAE,KAAK;EAE9B,EAAC;WACO,OAAO,MAAM,UACtB,eAAe,KAAK,GAAG,mBAAmB,GAAG,eAAe,CAAC;CAEhE,WACQ,OAAO,MAAM,YAAY,MAAM,MACxC,eAAe,KACb,GAAG,mBAAmB,GAA8B,eAAe,CACpE;AAGL,QAAO,MAAM,KAAK,IAAI,IAAI,gBAAgB;AAC3C;AAED,SAAS,sBACPH,UACAI,QACAH,gBACyB;CACzB,MAAMI,YAAqC,CAAE;AAC7C,MAAK,MAAM,CAAC,GAAG,EAAE,IAAI,OAAO,QAAQ,SAAS,CAC3C,KAAI,OAAO,MAAM,UACf,UAAU,KAAKC,gCAAe,GAAG,gBAAgB,OAAO;UAC/C,MAAM,QAAQ,EAAE,EAAE;EAC3B,MAAMC,aAA6B,CAAE;AACrC,OAAK,MAAM,KAAK,EACd,KAAI,OAAO,MAAM,UACf,WAAW,KAAKD,gCAAe,GAAG,gBAAgB,OAAO,CAAC;WACjD,OAAO,MAAM,UACtB,WAAW,KAAK,sBAAsB,GAAG,QAAQ,eAAe,CAAC;EAGrE,UAAU,KAAK;CAChB,WAAU,OAAO,MAAM,YAAY,MAAM,MACxC,UAAU,KAAK,sBACb,GACA,QACA,eACD;MAED,UAAU,KAAK;AAGnB,QAAO;AACR"}