"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toolkitManager = exports.ToolkitManager = exports.BaseToolkit = exports.DynamicTool = exports.BaseTool = exports.ToolResult = void 0;
exports.handleToolError = handleToolError;
exports.tool = tool;
exports.stripAnsi = stripAnsi;
// Tool execution result interface
class ToolResult {
    constructor({ success, data, error, error_type, executionTime, }) {
        this.success = success;
        this.data = data;
        this.error = error;
        this.error_type = error_type;
        this.executionTime = executionTime;
    }
}
exports.ToolResult = ToolResult;
/**
 * Generic error handler that converts exceptions/errors to standardized error responses
 */
function handleToolError(error, context, errorType = "unknown", details) {
    let errorMessage;
    if (error instanceof Error) {
        errorMessage = error.message;
        details = {
            ...details,
            name: error.name,
            stack: error.stack?.split("\n").slice(0, 3), // Truncated stack trace
        };
    }
    else if (typeof error === "string") {
        errorMessage = error;
    }
    else {
        errorMessage = "An unknown error occurred";
        details = { ...details, originalError: error };
    }
    // Add context if provided
    if (context) {
        errorMessage = `${context}: ${errorMessage}`;
    }
    return new ToolResult({
        success: false,
        error: errorMessage,
        error_type: errorType,
        data: details,
    });
}
// Base tool class with generic support
class BaseTool {
    constructor(options) {
        this.name = options.name;
        this.description = options.description;
        this.schema = options.schema;
        this.requiresApproval = options.requiresApproval;
    }
    // Get tool display information
    getDisplay(params) {
        return `${this.name}: ${JSON.stringify(params.input)}`;
    }
    // Validate input parameters
    validateInput(input) {
        if (this.schema) {
            try {
                this.schema.parse(input);
                return { success: true };
            }
            catch (error) {
                return {
                    success: false,
                    error: `Input validation failed: ${error instanceof Error ? error.message : String(error)}`,
                };
            }
        }
        return new ToolResult({
            success: true,
        });
    }
    // Public invocation method with proper generic typing
    async invoke(input, context) {
        const startTime = Date.now();
        try {
            // Validate input
            const validationResult = this.validateInput(input);
            if (!validationResult.success) {
                return validationResult;
            }
            // Execute tool
            const result = await this._invoke(input, context);
            return result instanceof ToolResult
                ? result
                : new ToolResult({
                    success: true,
                    data: result,
                    executionTime: Date.now() - startTime,
                });
        }
        catch (error) {
            return new ToolResult({
                success: false,
                error: error instanceof Error ? error.message : String(error),
                data: error?.details,
                executionTime: Date.now() - startTime,
            });
        }
    }
    // Get tool metadata
    getMetadata() {
        return {
            name: this.name,
            description: this.description,
            schema: this.schema ? this.schema : null,
        };
    }
}
exports.BaseTool = BaseTool;
// Dynamic tool class with proper generic inheritance
class DynamicTool extends BaseTool {
    constructor(options) {
        super({
            name: options.name,
            description: options.description,
            requiresApproval: options.requiresApproval,
            schema: options.schema,
        });
        this.func = options.func;
    }
    async _invoke(input, context) {
        return this.func(input, context);
    }
}
exports.DynamicTool = DynamicTool;
// Base toolkit class
class BaseToolkit {
    constructor(options) {
        this.tools = new Map();
        this.eventListeners = new Set();
        this.initialized = false;
        this.name = options.name;
        this.description = options.description;
        this.context = options.context;
    }
    // Initialize toolkit
    async initialize() {
        if (this.initialized) {
            // throw new Error(`Toolkit '${this.name}' is already initialized`);
            return;
        }
        await this.onInitialize();
        this.initialized = true;
        this.emit({ type: "toolkit_initialized", toolkit: this });
    }
    // Destroy toolkit
    async destroy() {
        if (!this.initialized) {
            return;
        }
        await this.onDestroy();
        this.emit({ type: "toolkit_destroyed", toolkit: this });
        this.tools.clear();
        this.eventListeners.clear();
        this.initialized = false;
    }
    // Overridable initialization method for subclasses
    async onInitialize() {
        // Default implementation is empty
    }
    // Overridable destroy method for subclasses
    async onDestroy() {
        // Default implementation is empty
    }
    // Add tool
    addTool(tool) {
        if (this.tools.has(tool.name)) {
            throw new Error(`Tool '${tool.name}' already exists in toolkit '${this.name}'`);
        }
        this.tools.set(tool.name, tool);
        this.emit({ type: "tool_added", tool });
        return this;
    }
    // Add multiple tools
    addTools(tools) {
        tools.forEach((tool) => this.addTool(tool));
        return this;
    }
    // Remove tool
    removeTool(toolName) {
        const removed = this.tools.delete(toolName);
        if (removed) {
            this.emit({ type: "tool_removed", toolName });
        }
        return removed;
    }
    // Get tool
    getTool(name) {
        return this.tools.get(name);
    }
    // Get all tools
    getTools() {
        return Array.from(this.tools.values());
    }
    // Get tool names list
    getToolNames() {
        return Array.from(this.tools.keys());
    }
    // Check if tool exists
    hasTool(name) {
        return this.tools.has(name);
    }
    // Search tools
    searchTools(query) {
        const lowerQuery = query.toLowerCase();
        return this.getTools().filter((tool) => tool.name.toLowerCase().includes(lowerQuery) ||
            tool.description?.toLowerCase().includes(lowerQuery));
    }
    // Execute tool
    async invokeTool(toolName, input, context) {
        const tool = this.getTool(toolName);
        if (!tool) {
            return new ToolResult({
                success: false,
                error: `Tool '${toolName}' not found in toolkit '${this.name}'`,
            });
        }
        const mergedContext = { ...this.context, ...context };
        const result = await tool.invoke(input, mergedContext);
        this.emit({ type: "tool_executed", toolName, result });
        return result;
    }
    // Execute multiple tools
    async invokeTools(invocations) {
        const promises = invocations.map(({ toolName, input, context }) => this.invokeTool(toolName, input, context));
        return Promise.all(promises);
    }
    // Set execution context
    setContext(context) {
        this.context = { ...this.context, ...context };
        return this;
    }
    // Get execution context
    getContext() {
        return this.context;
    }
    // Add event listener
    addEventListener(listener) {
        this.eventListeners.add(listener);
        return this;
    }
    // Remove event listener
    removeEventListener(listener) {
        return this.eventListeners.delete(listener);
    }
    // Emit event
    emit(event) {
        this.eventListeners.forEach((listener) => {
            try {
                listener(event);
            }
            catch (error) {
                console.error("Error in toolkit event listener:", error);
            }
        });
    }
    // Get toolkit metadata
    getMetadata() {
        return {
            name: this.name,
            description: this.description,
            toolCount: this.tools.size,
            tools: this.getTools().map((tool) => tool.getMetadata()),
            initialized: this.initialized,
        };
    }
    // Validate toolkit integrity
    validate() {
        const errors = [];
        if (!this.initialized) {
            errors.push("Toolkit is not initialized");
        }
        if (this.tools.size === 0) {
            errors.push("Toolkit has no tools");
        }
        // Check for tool name conflicts
        const toolNames = this.getToolNames();
        const duplicates = toolNames.filter((name, index) => toolNames.indexOf(name) !== index);
        if (duplicates.length > 0) {
            errors.push(`Duplicate tool names: ${duplicates.join(", ")}`);
        }
        return {
            valid: errors.length === 0,
            errors,
        };
    }
    // Clone toolkit
    clone(newName) {
        const cloned = new BaseToolkit({
            name: newName || `${this.name}_clone`,
            description: this.description,
            context: this.context ? { ...this.context } : undefined,
        });
        // Copy all tools
        this.getTools().forEach((tool) => {
            cloned.addTool(tool);
        });
        return cloned;
    }
}
exports.BaseToolkit = BaseToolkit;
// Tool creation helper function
function tool(func, options) {
    const { getDisplay, ...rest } = options;
    const dynamicTool = new DynamicTool({
        ...rest,
        func: func,
    });
    if (getDisplay) {
        dynamicTool.getDisplay = getDisplay;
    }
    return dynamicTool;
}
// Toolkit manager
class ToolkitManager {
    constructor() {
        this.toolkits = new Map();
    }
    // Register toolkit
    register(toolkit) {
        if (this.toolkits.has(toolkit.name)) {
            throw new Error(`Toolkit '${toolkit.name}' is already registered`);
        }
        this.toolkits.set(toolkit.name, toolkit);
        return this;
    }
    // Unregister toolkit
    unregister(toolkitName) {
        const toolkit = this.toolkits.get(toolkitName);
        if (toolkit) {
            toolkit.destroy();
            return this.toolkits.delete(toolkitName);
        }
        return false;
    }
    // Get toolkit
    getToolkit(name) {
        return this.toolkits.get(name);
    }
    // Get all toolkits
    getToolkits() {
        return Array.from(this.toolkits.values());
    }
    // Get all tools
    getAllTools() {
        const allTools = [];
        this.toolkits.forEach((toolkit, toolkitName) => {
            toolkit.getTools().forEach((tool) => {
                allTools.push({ toolkit: toolkitName, tool });
            });
        });
        return allTools;
    }
    // Find tools by name
    findTool(toolName) {
        return this.getAllTools().filter(({ tool }) => tool.name === toolName);
    }
    // Initialize all toolkits
    async initializeAll() {
        const promises = Array.from(this.toolkits.values()).map((toolkit) => toolkit.initialize());
        await Promise.all(promises);
    }
    // Destroy all toolkits
    async destroyAll() {
        const promises = Array.from(this.toolkits.values()).map((toolkit) => toolkit.destroy());
        await Promise.all(promises);
        this.toolkits.clear();
    }
}
exports.ToolkitManager = ToolkitManager;
// Export singleton manager
exports.toolkitManager = new ToolkitManager();
function ansiRegex({ onlyFirst = false } = {}) {
    // Valid string terminator sequences are BEL, ESC\, and 0x9c
    const ST = "(?:\\u0007|\\u001B\\u005C|\\u009C)";
    // OSC sequences only: ESC ] ... ST (non-greedy until the first ST)
    const osc = `(?:\\u001B\\][\\s\\S]*?${ST})`;
    // CSI and related: ESC/C1, optional intermediates, optional params (supports ; and :) then final byte
    const csi = "[\\u001B\\u009B][[\\]()#;?]*(?:\\d{1,4}(?:[;:]\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]";
    const pattern = `${osc}|${csi}`;
    return new RegExp(pattern, onlyFirst ? undefined : "g");
}
const regex = ansiRegex();
function stripAnsi(string) {
    if (typeof string !== "string") {
        throw new TypeError(`Expected a \`string\`, got \`${typeof string}\``);
    }
    // Even though the regex is global, we don't need to reset the `.lastIndex`
    // because unlike `.exec()` and `.test()`, `.replace()` does it automatically
    // and doing it manually has a performance penalty.
    return string.replace(regex, "");
}
//# sourceMappingURL=utils.js.map