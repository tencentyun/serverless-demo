{"version":3,"file":"middleware.cjs","names":["RunnableCallable","fields: RunnableCallableArgs<TStateSchema, NodeOutput<TStateSchema>>","options: MiddlewareNodeOptions","#options","invokeState: TStateSchema","config?: LangGraphRunnableConfig","relevantContext: Record<string, unknown>","state: TStateSchema","runtime: Runtime<TContextSchema>","jumpToConstraint: JumpToTarget[] | undefined","constraint: string | undefined","getHookConstraint","derivePrivateState"],"sources":["../../../src/agents/nodes/middleware.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { z } from \"zod/v3\";\nimport { LangGraphRunnableConfig, Command } from \"@langchain/langgraph\";\nimport { interopParse } from \"@langchain/core/utils/types\";\n\nimport { RunnableCallable, RunnableCallableArgs } from \"../RunnableCallable.js\";\nimport type { JumpToTarget } from \"../constants.js\";\nimport type { Runtime } from \"../runtime.js\";\nimport type { AgentMiddleware, MiddlewareResult } from \"../middleware/types.js\";\nimport { derivePrivateState } from \"./utils.js\";\nimport { getHookConstraint } from \"../middleware/utils.js\";\n\n/**\n * Named class for context objects to provide better error messages\n */\nclass AgentContext {}\nclass AgentRuntime {}\n\ntype NodeOutput<TStateSchema extends Record<string, any>> =\n  | TStateSchema\n  | Command<any, TStateSchema, string>;\n\nexport interface MiddlewareNodeOptions {\n  getState: () => Record<string, unknown>;\n}\n\nexport abstract class MiddlewareNode<\n  TStateSchema extends Record<string, any>,\n  TContextSchema extends Record<string, any>,\n> extends RunnableCallable<TStateSchema, NodeOutput<TStateSchema>> {\n  #options: MiddlewareNodeOptions;\n\n  abstract middleware: AgentMiddleware<\n    z.ZodObject<z.ZodRawShape>,\n    z.ZodObject<z.ZodRawShape>\n  >;\n\n  constructor(\n    fields: RunnableCallableArgs<TStateSchema, NodeOutput<TStateSchema>>,\n    options: MiddlewareNodeOptions\n  ) {\n    super(fields);\n    this.#options = options;\n  }\n\n  abstract runHook(\n    state: TStateSchema,\n    config?: Runtime<TContextSchema>\n  ): Promise<MiddlewareResult<TStateSchema>> | MiddlewareResult<TStateSchema>;\n\n  async invokeMiddleware(\n    invokeState: TStateSchema,\n    config?: LangGraphRunnableConfig\n  ): Promise<NodeOutput<TStateSchema>> {\n    /**\n     * Filter context based on middleware's contextSchema\n     */\n    let filteredContext = {} as TContextSchema;\n    /**\n     * Parse context using middleware's contextSchema to apply defaults and validation\n     */\n    if (this.middleware.contextSchema) {\n      /**\n       * Extract only the fields relevant to this middleware's schema\n       */\n      const schemaShape = this.middleware.contextSchema?.shape;\n      if (schemaShape) {\n        const relevantContext: Record<string, unknown> = {};\n        const invokeContext = config?.context || {};\n        for (const key of Object.keys(schemaShape)) {\n          if (key in invokeContext) {\n            relevantContext[key] = invokeContext[key];\n          }\n        }\n        /**\n         * Parse to apply defaults and validation, even if relevantContext is empty\n         * This will throw if required fields are missing and no defaults exist\n         */\n        filteredContext = interopParse(\n          this.middleware.contextSchema,\n          relevantContext\n        ) as TContextSchema;\n      }\n    }\n\n    const state: TStateSchema = {\n      ...this.#options.getState(),\n      ...invokeState,\n      /**\n       * don't overwrite possible outdated messages from other middleware nodes\n       */\n      messages: invokeState.messages,\n    };\n\n    /**\n     * ToDo: implement later\n     */\n    const runtime: Runtime<TContextSchema> = {\n      context: filteredContext,\n      writer: config?.writer,\n      interrupt: config?.interrupt,\n      signal: config?.signal,\n    };\n\n    const result = await this.runHook(\n      state,\n      /**\n       * assign runtime and context values into empty named class\n       * instances to create a better error message.\n       */\n      Object.freeze(\n        Object.assign(new AgentRuntime(), {\n          ...runtime,\n          context: Object.freeze(\n            Object.assign(new AgentContext(), filteredContext)\n          ),\n        })\n      )\n    );\n\n    /**\n     * If result is undefined, return current state\n     */\n    if (!result) {\n      return { ...state, jumpTo: undefined };\n    }\n\n    /**\n     * Verify that the jump target is allowed for the middleware\n     */\n    let jumpToConstraint: JumpToTarget[] | undefined;\n    let constraint: string | undefined;\n\n    if (this.name?.startsWith(\"BeforeAgentNode_\")) {\n      jumpToConstraint = getHookConstraint(this.middleware.beforeAgent);\n      constraint = \"beforeAgent.canJumpTo\";\n    } else if (this.name?.startsWith(\"BeforeModelNode_\")) {\n      jumpToConstraint = getHookConstraint(this.middleware.beforeModel);\n      constraint = \"beforeModel.canJumpTo\";\n    } else if (this.name?.startsWith(\"AfterAgentNode_\")) {\n      jumpToConstraint = getHookConstraint(this.middleware.afterAgent);\n      constraint = \"afterAgent.canJumpTo\";\n    } else if (this.name?.startsWith(\"AfterModelNode_\")) {\n      jumpToConstraint = getHookConstraint(this.middleware.afterModel);\n      constraint = \"afterModel.canJumpTo\";\n    }\n\n    if (\n      typeof result.jumpTo === \"string\" &&\n      !jumpToConstraint?.includes(result.jumpTo as JumpToTarget)\n    ) {\n      const suggestion =\n        jumpToConstraint && jumpToConstraint.length > 0\n          ? `must be one of: ${jumpToConstraint?.join(\", \")}.`\n          : constraint\n            ? `no ${constraint} defined in middleware ${this.middleware.name}`\n            : \"\";\n      throw new Error(`Invalid jump target: ${result.jumpTo}, ${suggestion}.`);\n    }\n\n    /**\n     * If result is a control action, handle it\n     */\n    if (typeof result === \"object\" && \"type\" in result) {\n      // Handle control actions\n      if (result.type === \"terminate\") {\n        if (result.error) {\n          throw result.error;\n        }\n        return {\n          ...state,\n          ...(result.result || {}),\n          jumpTo: result.jumpTo,\n        };\n      }\n\n      throw new Error(`Invalid control action: ${JSON.stringify(result)}`);\n    }\n\n    /**\n     * If result is a state update, merge it with current state\n     */\n    return { ...state, ...result, jumpTo: result.jumpTo };\n  }\n\n  get nodeOptions(): {\n    input: z.ZodObject<TStateSchema>;\n  } {\n    return {\n      input: derivePrivateState(\n        this.middleware.stateSchema\n      ) as z.ZodObject<TStateSchema>,\n    };\n  }\n}\n"],"mappings":";;;;;;;;;;AAeA,IAAM,eAAN,MAAmB,CAAE;AACrB,IAAM,eAAN,MAAmB,CAAE;AAUrB,IAAsB,iBAAtB,cAGUA,0CAAyD;CACjE;CAOA,YACEC,QACAC,SACA;EACA,MAAM,OAAO;EACb,KAAKC,WAAW;CACjB;CAOD,MAAM,iBACJC,aACAC,QACmC;;;;EAInC,IAAI,kBAAkB,CAAE;;;;AAIxB,MAAI,KAAK,WAAW,eAAe;;;;GAIjC,MAAM,cAAc,KAAK,WAAW,eAAe;AACnD,OAAI,aAAa;IACf,MAAMC,kBAA2C,CAAE;IACnD,MAAM,gBAAgB,QAAQ,WAAW,CAAE;AAC3C,SAAK,MAAM,OAAO,OAAO,KAAK,YAAY,CACxC,KAAI,OAAO,eACT,gBAAgB,OAAO,cAAc;;;;;IAOzC,iEACE,KAAK,WAAW,eAChB,gBACD;GACF;EACF;EAED,MAAMC,QAAsB;GAC1B,GAAG,KAAKJ,SAAS,UAAU;GAC3B,GAAG;GAIH,UAAU,YAAY;EACvB;;;;EAKD,MAAMK,UAAmC;GACvC,SAAS;GACT,QAAQ,QAAQ;GAChB,WAAW,QAAQ;GACnB,QAAQ,QAAQ;EACjB;EAED,MAAM,SAAS,MAAM,KAAK;GACxB;;;;;GAKA,OAAO,OACL,OAAO,OAAO,IAAI,gBAAgB;IAChC,GAAG;IACH,SAAS,OAAO,OACd,OAAO,OAAO,IAAI,gBAAgB,gBAAgB,CACnD;GACF,EAAC,CACH;GACF;;;;AAKD,MAAI,CAAC,OACH,QAAO;GAAE,GAAG;GAAO,QAAQ;EAAW;;;;EAMxC,IAAIC;EACJ,IAAIC;AAEJ,MAAI,KAAK,MAAM,WAAW,mBAAmB,EAAE;GAC7C,mBAAmBC,kCAAkB,KAAK,WAAW,YAAY;GACjE,aAAa;EACd,WAAU,KAAK,MAAM,WAAW,mBAAmB,EAAE;GACpD,mBAAmBA,kCAAkB,KAAK,WAAW,YAAY;GACjE,aAAa;EACd,WAAU,KAAK,MAAM,WAAW,kBAAkB,EAAE;GACnD,mBAAmBA,kCAAkB,KAAK,WAAW,WAAW;GAChE,aAAa;EACd,WAAU,KAAK,MAAM,WAAW,kBAAkB,EAAE;GACnD,mBAAmBA,kCAAkB,KAAK,WAAW,WAAW;GAChE,aAAa;EACd;AAED,MACE,OAAO,OAAO,WAAW,YACzB,CAAC,kBAAkB,SAAS,OAAO,OAAuB,EAC1D;GACA,MAAM,aACJ,oBAAoB,iBAAiB,SAAS,IAC1C,CAAC,gBAAgB,EAAE,kBAAkB,KAAK,KAAK,CAAC,CAAC,CAAC,GAClD,aACE,CAAC,GAAG,EAAE,WAAW,uBAAuB,EAAE,KAAK,WAAW,MAAM,GAChE;AACR,SAAM,IAAI,MAAM,CAAC,qBAAqB,EAAE,OAAO,OAAO,EAAE,EAAE,WAAW,CAAC,CAAC;EACxE;;;;AAKD,MAAI,OAAO,WAAW,YAAY,UAAU,QAAQ;AAElD,OAAI,OAAO,SAAS,aAAa;AAC/B,QAAI,OAAO,MACT,OAAM,OAAO;AAEf,WAAO;KACL,GAAG;KACH,GAAI,OAAO,UAAU,CAAE;KACvB,QAAQ,OAAO;IAChB;GACF;AAED,SAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,KAAK,UAAU,OAAO,EAAE;EACpE;;;;AAKD,SAAO;GAAE,GAAG;GAAO,GAAG;GAAQ,QAAQ,OAAO;EAAQ;CACtD;CAED,IAAI,cAEF;AACA,SAAO,EACL,OAAOC,iCACL,KAAK,WAAW,YACjB,CACF;CACF;AACF"}