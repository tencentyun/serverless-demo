import { type ParsedEvent } from '../eventsource_parser'
import { BotReq, ReqOptions } from '../type'
import {
  IBotCreateConversation,
  IBotDeleteConversation,
  IBotGetConversation,
  IBotGetTextToSpeechResult,
  IBotPreview,
  IBotSendMessage,
  IBotSpeechToText,
  IBotTextToSpeech,
  IBotUploadFiles,
  ICreateBot,
  IDeleteBot,
  IGenerateBot,
  IGenerateImage,
  IGetBot,
  IGetBotChatRecords,
  IGetBotFeedback,
  IGetBotList,
  IGetBotRecommendQuestions,
  ISendBotFeedback,
  IUpdateBot,
} from './types'
import {
  createAsyncIterable,
  toPolyfillReadable,
  createEventSourceParserTransformStream,
  TextDecoderStream,
  TransformStream,
} from '../utils'

export class Bot {
  req: BotReq

  constructor(req: BotReq, public baseUrl: string) {
    // eslint-disable-next-line prefer-rest-params
    const token = arguments[2]
    if (typeof token === 'string') {
      this.req = ({ headers = {}, ...rest }) => req({ ...rest, headers: { ...headers, Authorization: `Bearer ${token}` } })
    } else {
      this.req = req
    }
  }

  list(props: IGetBotList, options?: ReqOptions) {
    return this.req({
      method: 'get',
      url: this.join('bots'),
      data: props,
      timeout: options?.timeout,
    })
  }

  create({ botInfo }: ICreateBot, options?: ReqOptions) {
    return this.req({
      method: 'post',
      url: this.join('bots'),
      data: botInfo,
      timeout: options?.timeout,
    })
  }

  get({ botId }: IGetBot, options?: ReqOptions) {
    return this.req({
      method: 'get',
      url: this.join(`bots/${botId}`),
      timeout: options?.timeout,
    })
  }

  update({ botId, botInfo }: IUpdateBot, options?: ReqOptions) {
    return this.req({
      method: 'PATCH',
      url: this.join(`bots/${botId}`),
      data: botInfo,
      timeout: options?.timeout,
    })
  }

  delete({ botId }: IDeleteBot, options?: ReqOptions) {
    return this.req({ method: 'delete', url: this.join(`bots/${botId}`), timeout: options?.timeout })
  }

  getChatRecords(props: IGetBotChatRecords, options?: ReqOptions) {
    return this.req({
      method: 'get',
      url: this.join(`bots/${props.botId}/records`),
      data: props,
      timeout: options?.timeout,
    })
  }

  sendFeedback({ userFeedback }: ISendBotFeedback, options?: ReqOptions) {
    return this.req({
      method: 'post',
      url: this.join(`bots/${userFeedback.botId}/feedback`),
      data: userFeedback,
      timeout: options?.timeout,
    })
  }

  getFeedback(props: IGetBotFeedback, options?: ReqOptions) {
    return this.req({
      method: 'get',
      url: this.join(`bots/${props.botId}/feedback`),
      data: props,
      timeout: options?.timeout,
    })
  }

  async uploadFiles(props: IBotUploadFiles, options?: ReqOptions) {
    return this.req({
      method: 'post',
      url: this.join(`bots/${props.botId}/files`),
      data: props,
      timeout: options?.timeout,
    })
  }

  async createConversation({ botId, ...rest }: IBotCreateConversation, options?: ReqOptions) {
    return this.req({
      method: 'post',
      url: this.join(`bots/${botId}/conversation`),
      data: rest,
      timeout: options?.timeout,
    })
  }

  async getConversation({ pageSize = 10, pageNumber = 1, botId, ...rest }: IBotGetConversation, options?: ReqOptions) {
    if (pageNumber < 1) throw new Error('pageNumber must be greater than 0')
    const offset = pageSize * (pageNumber - 1)
    const limit = pageSize
    return this.req({
      method: 'get',
      url: this.join(`bots/${botId}/conversation`),
      data: { ...rest, offset, limit },
      timeout: options?.timeout,
    })
  }

  async deleteConversation({ botId, conversationId, ...rest }: IBotDeleteConversation, options?: ReqOptions) {
    return this.req({
      method: 'delete',
      url: this.join(`bots/${botId}/conversation/${conversationId}`),
      data: rest,
      timeout: options?.timeout,
    })
  }

  async speechToText(props: IBotSpeechToText, options?: ReqOptions) {
    return this.req({
      method: 'post',
      url: this.join(`bots/${props.botId}/speech-to-text`),
      data: props,
      timeout: options?.timeout,
    })
  }

  async textToSpeech(props: IBotTextToSpeech, options?: ReqOptions) {
    return this.req({
      method: 'post',
      url: this.join(`bots/${props.botId}/text-to-speech`),
      data: props,
      timeout: options?.timeout,
    })
  }

  async getTextToSpeechResult(props: IBotGetTextToSpeechResult, options?: ReqOptions) {
    return this.req({
      method: 'get',
      url: this.join(`bots/${props.botId}/text-to-speech`),
      data: props,
      timeout: options?.timeout,
    })
  }

  async getRecommendQuestions(props: IGetBotRecommendQuestions, options?: ReqOptions) {
    const res = await this.req({
      method: 'post',
      url: this.join(`bots/${props.botId}/recommend-questions`),
      data: props,
      stream: true,
      timeout: options?.timeout,
    })
    return new StreamResult(res)
  }

  async generateBot(props: IGenerateBot, options?: ReqOptions) {
    const res = await this.req({
      method: 'post',
      url: this.join('generate-bot'),
      data: props,
      stream: true,
      timeout: options?.timeout,
    })
    return new StreamResult(res)
  }

  async getPreview(props: IBotPreview, options?: ReqOptions) {
    const res = await this.req({
      method: 'post',
      url: this.join('preview'),
      data: props,
      stream: true,
      timeout: options?.timeout,
    })
    return new StreamResult(res)
  }

  generateImage(props: IGenerateImage, options?: ReqOptions) {
    return this.req({ method: 'post', url: this.join('generate-image'), data: props, timeout: options?.timeout })
  }

  async sendMessage(props: IBotSendMessage, options?: ReqOptions) {
    const res = await this.req({
      method: 'post',
      url: this.join(`bots/${props.botId}/send-message`),
      data: props,
      stream: true,
      timeout: options?.timeout,
    })
    return new StreamResult(res)
  }

  private join(url: string) {
    return `${this.baseUrl}/${url}`
  }
}

type BotEventStreamData = { content: string }

class StreamResult {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  private _eventSourceStream: ReadableStream<ParsedEvent>

  constructor(_stream: ReadableStream<Uint8Array>) {
    const stream = toPolyfillReadable(_stream) as typeof _stream
    this._eventSourceStream = stream
      .pipeThrough(new TextDecoderStream())
      .pipeThrough(createEventSourceParserTransformStream())
  }

  private get teeedStream() {
    const [s1, s2] = this._eventSourceStream.tee()
    this._eventSourceStream = s2
    return s1
  }

  get eventSourceStream() {
    return createAsyncIterable(this.teeedStream)
  }

  get dataStream() {
    return createAsyncIterable(this.eventSourceStream.pipeThrough(new TransformStream<ParsedEvent, BotEventStreamData>({
      transform(chunk, controller) {
        try {
          const data = JSON.parse(chunk.data)
          controller.enqueue(data)
        } catch (e) {
          if (chunk.data !== '[DONE]') {
            console.warn('Error when transforming event source data to json', e, chunk)
          } else {
            controller.terminate()
          }
        }
      },
    }),),)
  }

  get textStream() {
    return createAsyncIterable(this.dataStream.pipeThrough(new TransformStream<BotEventStreamData, string>({
      transform(chunk, controller) {
        controller.enqueue(chunk?.content ?? '')
      },
    }),),)
  }
}
