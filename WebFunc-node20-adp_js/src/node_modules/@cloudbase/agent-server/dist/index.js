var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  ErrorCode: () => ErrorCode,
  agui: () => agui_exports,
  createConsoleLogger: () => import_agent_shared2.createConsoleLogger,
  createExpressRoutes: () => createExpressRoutes,
  createExpressServer: () => createExpressServer,
  extractRequestId: () => extractRequestId,
  generateRequestId: () => generateRequestId,
  getOrGenerateRequestId: () => getOrGenerateRequestId,
  isErrorWithCode: () => import_agent_shared3.isErrorWithCode,
  noopLogger: () => import_agent_shared2.noopLogger,
  run: () => run
});
module.exports = __toCommonJS(index_exports);

// src/agui/index.ts
var agui_exports = {};
__export(agui_exports, {
  healthz: () => healthz_exports,
  openai: () => openai_exports,
  sendMessage: () => sendMessage_exports,
  sendMessageAGUI: () => sendMessageAGUI_exports
});

// src/agui/sendMessage/index.ts
var sendMessage_exports = {};
__export(sendMessage_exports, {
  createServerAdapter: () => createServerAdapter,
  handler: () => handler
});

// src/agui/sendMessage/handler.ts
var import_client = require("@ag-ui/client");
var import_uuid = require("uuid");
var import_repeater = require("@repeaterjs/repeater");
function handler(input, agent) {
  agent.threadId = input.conversationId;
  if (input.messages) {
    const aguiMessages = input.messages.map(messageToAGUIMessage);
    agent.setMessages(aguiMessages);
  }
  return new import_repeater.Repeater(async (push, stop) => {
    agent.runAgent(
      {
        tools: input.tools,
        forwardedProps: {
          resume: input.resume
        }
      },
      {
        onTextMessageContentEvent: ({ event }) => {
          push({
            type: "text",
            content: event.delta,
            rawEvent: event.rawEvent
          });
        },
        onRunFinishedEvent: () => {
          stop();
        },
        onRunErrorEvent: ({ event }) => {
          push({
            type: "error",
            error: event.message,
            code: event.code
          });
        },
        onToolCallStartEvent: ({ event }) => {
          push({
            type: "tool-call-start",
            toolCallId: event.toolCallId,
            toolCallName: event.toolCallName
          });
        },
        onToolCallArgsEvent: ({ event }) => {
          push({
            type: "tool-call-args",
            toolCallId: event.toolCallId,
            delta: event.delta
          });
        },
        onToolCallEndEvent: ({ event }) => {
          push({
            type: "tool-call-end",
            toolCallId: event.toolCallId
          });
        },
        onToolCallResultEvent: ({ event }) => {
          push({
            type: "tool-result",
            result: event.content,
            toolCallId: event.toolCallId
          });
        },
        onEvent: ({ event }) => {
          if (event.type !== import_client.EventType.RUN_FINISHED) {
            return;
          }
          if (event["outcome"] !== "interrupt") {
            return;
          }
          const interrupt = event["interrupt"];
          push({
            type: "interrupt",
            id: interrupt.id,
            reason: interrupt.reason,
            payload: interrupt.payload
          });
        }
      }
    );
  });
}
function messageToAGUIMessage(message) {
  if (message.role === "system" || message.role === "user") {
    return {
      id: (0, import_uuid.v4)(),
      role: message.role,
      content: message.content
    };
  }
  if (message.role === "tool") {
    return {
      role: "tool",
      toolCallId: message.toolCallId,
      content: message.content,
      id: (0, import_uuid.v4)()
    };
  }
  if (message.role === "assistant") {
    return {
      role: "assistant",
      content: message.content,
      id: (0, import_uuid.v4)(),
      toolCalls: message.toolCalls
    };
  }
}

// src/agui/sendMessage/server.ts
var import_server = require("@whatwg-node/server");
var import_agent_shared = require("@cloudbase/agent-shared");
function createServerAdapter(createAgent) {
  return (0, import_server.createServerAdapter)(async (request) => {
    const input = import_agent_shared.sendMessageInputSchema.parse(await request.json());
    const { agent: unknownAgent, cleanup } = await Promise.resolve(
      createAgent({ request })
    );
    const agent = "toAGUIAgent" in unknownAgent ? unknownAgent.toAGUIAgent() : unknownAgent;
    const events = handler(input, agent);
    let heartbeat;
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder();
        heartbeat = setInterval(() => {
          controller.enqueue(encoder.encode(":ping\n\n"));
        }, 15 * 1e3);
        try {
          for await (const event of events) {
            const sseChunk = `data: ${JSON.stringify(event)}

`;
            controller.enqueue(encoder.encode(sseChunk));
          }
          controller.enqueue(encoder.encode("data: [DONE]\n\n"));
        } finally {
          if (heartbeat) clearInterval(heartbeat);
          controller.close();
          cleanup == null ? void 0 : cleanup();
        }
      },
      cancel() {
        if (heartbeat) clearInterval(heartbeat);
      }
    });
    const headers = new Headers({
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive"
    });
    return new Response(stream, { status: 200, headers });
  });
}

// src/agui/sendMessageAGUI/index.ts
var sendMessageAGUI_exports = {};
__export(sendMessageAGUI_exports, {
  createServerAdapter: () => createServerAdapter2,
  handler: () => handler2
});

// src/agui/sendMessageAGUI/handler.ts
var import_repeater2 = require("@repeaterjs/repeater");
function handler2(input, agent) {
  return new import_repeater2.Repeater(async (push, stop) => {
    agent.setMessages(input.messages);
    agent.setState(input.state);
    agent.threadId = input.threadId;
    await agent.runAgent(input, {
      onEvent: ({ event }) => {
        push(event);
      }
    });
    stop();
  });
}

// src/agui/sendMessageAGUI/server.ts
var import_server3 = require("@whatwg-node/server");
var import_client2 = require("@ag-ui/client");
var import_uuid3 = require("uuid");

// src/logger/index.ts
var import_agent_shared2 = require("@cloudbase/agent-shared");

// src/logger/request-id.ts
var import_uuid2 = require("uuid");
function generateRequestId(prefix = "req") {
  return `${prefix}-${(0, import_uuid2.v4)()}`;
}
function extractRequestId(headers) {
  const headerNames = ["x-request-id", "x-correlation-id", "x-trace-id"];
  for (const name of headerNames) {
    let value;
    if (headers instanceof Headers) {
      value = headers.get(name) || void 0;
    } else {
      const raw = headers[name];
      value = Array.isArray(raw) ? raw[0] : raw;
    }
    if (value) {
      return value;
    }
  }
  return void 0;
}
function getOrGenerateRequestId(headers, prefix = "req") {
  return extractRequestId(headers) || generateRequestId(prefix);
}

// src/agui/sendMessageAGUI/schemas.ts
var import_v4 = require("zod/v4");
var FunctionCallSchema = import_v4.z.object({
  name: import_v4.z.string(),
  arguments: import_v4.z.string()
});
var ToolCallSchema = import_v4.z.object({
  id: import_v4.z.string(),
  type: import_v4.z.literal("function"),
  function: FunctionCallSchema
});
var ToolSchema = import_v4.z.object({
  name: import_v4.z.string(),
  description: import_v4.z.string(),
  parameters: import_v4.z.any()
});
var TextInputContentSchema = import_v4.z.object({
  type: import_v4.z.literal("text"),
  text: import_v4.z.string()
});
var BinaryInputContentObjectSchema = import_v4.z.object({
  type: import_v4.z.literal("binary"),
  mimeType: import_v4.z.string(),
  id: import_v4.z.string().optional(),
  url: import_v4.z.string().optional(),
  data: import_v4.z.string().optional(),
  filename: import_v4.z.string().optional()
});
var ensureBinaryPayload = (value, ctx) => {
  if (!value.id && !value.url && !value.data) {
    ctx.addIssue({
      code: import_v4.z.ZodIssueCode.custom,
      message: "BinaryInputContent requires at least one of id, url, or data.",
      path: ["id"]
    });
  }
};
var BinaryInputContentSchema = BinaryInputContentObjectSchema.superRefine((value, ctx) => {
  ensureBinaryPayload(value, ctx);
});
var InputContentBaseSchema = import_v4.z.discriminatedUnion("type", [
  TextInputContentSchema,
  BinaryInputContentObjectSchema
]);
var InputContentSchema = InputContentBaseSchema.superRefine(
  (value, ctx) => {
    if (value.type === "binary") {
      ensureBinaryPayload(value, ctx);
    }
  }
);
var BaseMessageSchema = import_v4.z.object({
  id: import_v4.z.string(),
  role: import_v4.z.string(),
  content: import_v4.z.string().optional(),
  name: import_v4.z.string().optional()
});
var DeveloperMessageSchema = BaseMessageSchema.extend({
  role: import_v4.z.literal("developer"),
  content: import_v4.z.string()
});
var SystemMessageSchema = BaseMessageSchema.extend({
  role: import_v4.z.literal("system"),
  content: import_v4.z.string()
});
var AssistantMessageSchema = BaseMessageSchema.extend({
  role: import_v4.z.literal("assistant"),
  content: import_v4.z.string().optional(),
  toolCalls: import_v4.z.array(ToolCallSchema).optional()
});
var UserMessageSchema = BaseMessageSchema.extend({
  role: import_v4.z.literal("user"),
  content: import_v4.z.union([import_v4.z.string(), import_v4.z.array(InputContentSchema)])
});
var ToolMessageSchema = import_v4.z.object({
  id: import_v4.z.string(),
  content: import_v4.z.string(),
  role: import_v4.z.literal("tool"),
  toolCallId: import_v4.z.string(),
  error: import_v4.z.string().optional()
});
var ActivityMessageSchema = import_v4.z.object({
  id: import_v4.z.string(),
  role: import_v4.z.literal("activity"),
  activityType: import_v4.z.string(),
  content: import_v4.z.record(import_v4.z.string(), import_v4.z.any())
});
var MessageSchema = import_v4.z.discriminatedUnion("role", [
  DeveloperMessageSchema,
  SystemMessageSchema,
  AssistantMessageSchema,
  UserMessageSchema,
  ToolMessageSchema,
  ActivityMessageSchema
]);
var ContextSchema = import_v4.z.object({
  description: import_v4.z.string(),
  value: import_v4.z.string()
});
var ServerRunAgentInputSchema = import_v4.z.object({
  threadId: import_v4.z.string().optional(),
  // Modified: optional instead of required
  runId: import_v4.z.string(),
  parentRunId: import_v4.z.string().optional(),
  state: import_v4.z.any(),
  messages: import_v4.z.array(MessageSchema),
  tools: import_v4.z.array(ToolSchema),
  context: import_v4.z.array(ContextSchema),
  forwardedProps: import_v4.z.any()
});

// src/errors/index.ts
var import_agent_shared3 = require("@cloudbase/agent-shared");
var ErrorCode = {
  /** Invalid request format or parameters (400) */
  INVALID_REQUEST: "INVALID_REQUEST",
  /** Internal server error (500) */
  INTERNAL_ERROR: "INTERNAL_ERROR"
};

// src/agui/sendMessageAGUI/server.ts
var startObservation;
var setupObservability;
var observabilityLoadAttempted = false;
async function loadObservability() {
  if (!observabilityLoadAttempted) {
    observabilityLoadAttempted = true;
    try {
      const obs = await import("@cloudbase/agent-observability");
      const obsServer = await import("@cloudbase/agent-observability/server");
      startObservation = obs.startObservation;
      setupObservability = obsServer.setupObservability;
      return true;
    } catch (e) {
      return false;
    }
  }
  return !!startObservation;
}
async function ensureObservabilityReady() {
  if (!setupObservability) return false;
  try {
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => reject(new Error("Observability setup timeout")), 2e3);
    });
    await Promise.race([
      setupObservability(),
      timeoutPromise
    ]);
    return true;
  } catch (e) {
    return false;
  }
}
function createServerAdapter2(createAgent, options) {
  var _a;
  const { logger: parentLogger = import_agent_shared2.noopLogger } = options ?? {};
  const adapterLogger = ((_a = parentLogger.child) == null ? void 0 : _a.call(parentLogger, { component: "sendMessageAGUI" })) ?? parentLogger;
  return (0, import_server3.createServerAdapter)(async (request) => {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    const requestId = getOrGenerateRequestId(request.headers, "agui");
    const logger = ((_a2 = adapterLogger.child) == null ? void 0 : _a2.call(adapterLogger, { requestId })) ?? adapterLogger;
    (_b = logger.info) == null ? void 0 : _b.call(logger, "Request received");
    const inputRes = await safeAsync(async () => {
      const rawInput = await request.json();
      const inputWithDefaults = {
        tools: [],
        context: [],
        state: {},
        forwardedProps: {},
        ...rawInput,
        runId: typeof rawInput.runId === "string" && rawInput.runId ? rawInput.runId : (0, import_uuid3.v4)()
      };
      return ServerRunAgentInputSchema.parse(inputWithDefaults);
    });
    if ("error" in inputRes) {
      const { error } = inputRes;
      (_c = logger.warn) == null ? void 0 : _c.call(
        logger,
        { err: error instanceof Error ? error.message : String(error) },
        "Input validation failed"
      );
      return new Response(
        JSON.stringify({
          error: {
            code: ErrorCode.INVALID_REQUEST,
            message: error instanceof Error ? error.message : String(error)
          },
          requestId
        }),
        {
          status: 400,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    const input = inputRes.result;
    const lastUserMessage = input.messages.filter((m) => m.role === "user").pop();
    (_f = logger.debug) == null ? void 0 : _f.call(
      logger,
      {
        runId: input.runId,
        threadId: input.threadId,
        messageCount: input.messages.length,
        toolCount: ((_d = input.tools) == null ? void 0 : _d.length) ?? 0,
        tools: (_e = input.tools) == null ? void 0 : _e.map((t) => t.name),
        lastUserMessage: typeof (lastUserMessage == null ? void 0 : lastUserMessage.content) === "string" ? lastUserMessage.content.slice(0, 200) : void 0
      },
      "Input validated"
    );
    (_g = logger.trace) == null ? void 0 : _g.call(logger, { input }, "Full request input");
    const createAgentRes = await safeAsync(async () => {
      const res = await Promise.resolve(
        createAgent({ request, logger, requestId })
      );
      return {
        cleanup: res.cleanup,
        agent: "toAGUIAgent" in res.agent ? res.agent.toAGUIAgent() : res.agent
      };
    });
    if ("error" in createAgentRes) {
      const { error } = createAgentRes;
      (_h = logger.error) == null ? void 0 : _h.call(logger, { err: error }, "Agent creation failed");
      const errorCode = (0, import_agent_shared3.isErrorWithCode)(error) ? error.code : ErrorCode.INTERNAL_ERROR;
      const errorMessage = error instanceof Error ? error.message : String(error);
      return new Response(
        JSON.stringify({
          error: {
            code: errorCode,
            message: errorMessage
          },
          requestId
        }),
        {
          status: 500,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    const hasObservability = await loadObservability();
    let serverSpan = null;
    let serverContextData = null;
    if (hasObservability && startObservation) {
      try {
        const isReady = await ensureObservabilityReady();
        if (isReady) {
          serverSpan = startObservation(
            "AG-UI.Server",
            {
              "http.method": request.method,
              "http.url": request.url,
              "http.host": request.headers.get("host") || "unknown",
              "http.user_agent": request.headers.get("user-agent") || "unknown",
              "agui.thread_id": inputRes.result.threadId,
              "agui.run_id": inputRes.result.runId
            },
            { asType: "span" }
          );
          const spanContext = serverSpan.otelSpan.spanContext();
          serverContextData = {
            traceId: spanContext.traceId,
            spanId: spanContext.spanId,
            traceFlags: spanContext.traceFlags
          };
          inputRes.result.forwardedProps = {
            ...inputRes.result.forwardedProps,
            __agui_server_context: serverContextData
          };
          (_i = logger.debug) == null ? void 0 : _i.call(logger, "\u2713 Server span created:", {
            traceId: serverContextData.traceId,
            spanId: serverContextData.spanId
          });
        } else {
          (_j = logger.debug) == null ? void 0 : _j.call(logger, "Observability not ready, skipping span creation");
        }
      } catch (e) {
        (_k = logger.debug) == null ? void 0 : _k.call(logger, "Failed to create server span:", e);
      }
    }
    let cleanupCalled = false;
    const safeCleanup = () => {
      var _a3, _b2, _c2;
      if (!cleanupCalled) {
        cleanupCalled = true;
        try {
          (_b2 = (_a3 = createAgentRes.result).cleanup) == null ? void 0 : _b2.call(_a3);
        } catch (e) {
          (_c2 = logger.error) == null ? void 0 : _c2.call(logger, { err: e }, "Cleanup error");
        }
      }
    };
    const eventsResult = safe(
      () => handler2(
        inputRes.result,
        createAgentRes.result.agent
      )
    );
    if ("error" in eventsResult) {
      const { error } = eventsResult;
      (_l = logger.error) == null ? void 0 : _l.call(logger, { err: error }, "Run agent failed");
      const errorCode = (0, import_agent_shared3.isErrorWithCode)(error) ? error.code : ErrorCode.INTERNAL_ERROR;
      const errorMessage = error instanceof Error ? error.message : String(error);
      return new Response(
        JSON.stringify({
          error: {
            code: errorCode,
            message: errorMessage
          },
          requestId
        }),
        {
          status: 500,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    const { result: events } = eventsResult;
    let heartbeat;
    const stream = new ReadableStream({
      async start(controller) {
        var _a3, _b2, _c2, _d2, _e2;
        const encoder = new TextEncoder();
        heartbeat = setInterval(() => {
          controller.enqueue(encoder.encode(":ping\n\n"));
        }, 15 * 1e3);
        let eventCount = 0;
        try {
          for await (const event of events) {
            eventCount++;
            (_a3 = logger.debug) == null ? void 0 : _a3.call(
              logger,
              { eventType: event.type, eventCount },
              "Emitting SSE event"
            );
            (_b2 = logger.trace) == null ? void 0 : _b2.call(logger, { aguiEvent: event }, "SSE event content");
            const sseChunk = `data: ${JSON.stringify(event)}

`;
            controller.enqueue(encoder.encode(sseChunk));
          }
          (_c2 = logger.info) == null ? void 0 : _c2.call(logger, { eventCount }, "Request completed");
        } catch (error) {
          (_d2 = logger.error) == null ? void 0 : _d2.call(logger, { err: error }, "Stream error");
          const errorCode = (0, import_agent_shared3.isErrorWithCode)(error) ? error.code : ErrorCode.INTERNAL_ERROR;
          const errorMessage = error instanceof Error ? error.message : String(error);
          const errorEvent = {
            type: import_client2.EventType.RUN_ERROR,
            code: errorCode,
            message: errorMessage
          };
          controller.enqueue(
            encoder.encode(`data: ${JSON.stringify(errorEvent)}

`)
          );
        } finally {
          if (heartbeat) clearInterval(heartbeat);
          controller.close();
          safeCleanup();
          if (serverSpan) {
            serverSpan.end();
            (_e2 = logger.debug) == null ? void 0 : _e2.call(logger, "\u2713 Server span ended");
          }
        }
      },
      cancel() {
        var _a3, _b2;
        (_a3 = logger.info) == null ? void 0 : _a3.call(logger, "Request cancelled by client");
        if (heartbeat) clearInterval(heartbeat);
        safeCleanup();
        if (serverSpan) {
          serverSpan.end();
          (_b2 = logger.debug) == null ? void 0 : _b2.call(logger, "\u2713 Server span ended (cancelled)");
        }
      }
    });
    const headers = new Headers({
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive"
    });
    return new Response(stream, { status: 200, headers });
  });
}
async function safeAsync(fn) {
  try {
    return {
      result: await fn()
    };
  } catch (error) {
    return { error };
  }
}
function safe(fn) {
  try {
    return {
      result: fn()
    };
  } catch (error) {
    return { error };
  }
}

// src/agui/healthz/index.ts
var healthz_exports = {};
__export(healthz_exports, {
  serverAdapter: () => serverAdapter
});
var import_server5 = require("@whatwg-node/server");
var serverAdapter = (0, import_server5.createServerAdapter)(() => new Response("OK"));

// src/agui/openai/index.ts
var openai_exports = {};
__export(openai_exports, {
  createServerAdapter: () => createServerAdapter3,
  handler: () => handler3
});

// src/agui/openai/handler.ts
var import_uuid4 = require("uuid");
var import_repeater3 = require("@repeaterjs/repeater");
function handler3(input, agent) {
  var _a;
  const res = handler(
    {
      messages: input.messages.map(openAIMessageToClientMessage),
      tools: (_a = input.tools) == null ? void 0 : _a.filter((tool) => tool.type === "function").map((tool) => ({
        name: tool.function.name,
        description: tool.function.description,
        parameters: tool.function.parameters
      })),
      conversationId: (0, import_uuid4.v4)()
    },
    agent
  );
  return new import_repeater3.Repeater(async (push, stop) => {
    const id = (0, import_uuid4.v4)();
    let tools = [];
    let lastWithToolCall = false;
    let maxIndex = 0;
    const toolIdToIndex = {};
    for await (let x of res) {
      if (x.type === "text") {
        lastWithToolCall = false;
        push({
          id,
          object: "chat.completion.chunk",
          model: "",
          choices: [
            {
              delta: {
                role: "assistant",
                content: x.content
              },
              index: 0,
              finish_reason: null
            }
          ],
          created: Date.now()
        });
      }
      if (x.type === "tool-call-start") {
        toolIdToIndex[x.toolCallId] = maxIndex;
        maxIndex++;
        tools.push({
          name: x.toolCallName,
          id: x.toolCallId,
          args: ""
        });
      }
      if (x.type === "tool-call-args") {
        tools.find((t) => t.id === x.toolCallId).args += x.delta;
      }
      if (x.type === "tool-call-end") {
        const index = tools.findIndex((t) => t.id === x.toolCallId);
        const [tool] = tools.splice(index, 1);
        lastWithToolCall = true;
        push({
          id,
          created: Date.now(),
          model: "",
          object: "chat.completion.chunk",
          choices: [
            {
              index: 0,
              finish_reason: null,
              delta: {
                tool_calls: [
                  {
                    index: toolIdToIndex[tool.id],
                    type: "function",
                    id: tool.id,
                    function: {
                      name: tool.name,
                      arguments: tool.args
                    }
                  }
                ]
              }
            }
          ]
        });
      }
    }
    push({
      id,
      object: "chat.completion.chunk",
      model: "",
      created: Date.now(),
      choices: [
        {
          finish_reason: lastWithToolCall ? "tool_calls" : "stop",
          index: 0,
          delta: {}
        }
      ]
    });
    stop();
  });
}
function openAIMessageToClientMessage(message) {
  var _a;
  if (message.role === "developer" || message.role === "system") {
    return {
      role: "system",
      content: typeof message.content === "string" ? message.content : message.content.map((p) => p.text).join("")
    };
  }
  if (message.role === "user") {
    return {
      role: "user",
      content: typeof message.content === "string" ? message.content : message.content.filter((p) => p.type === "text").map((p) => p.text).join("")
    };
  }
  if (message.role === "assistant") {
    return {
      role: "assistant",
      content: typeof message.content === "string" ? message.content : message.content.filter((p) => p.type === "text").map((p) => p.text).join(""),
      toolCalls: (_a = message.tool_calls) == null ? void 0 : _a.filter((t) => t.type === "function").map((toolCall) => ({
        id: toolCall.id,
        type: "function",
        function: {
          name: toolCall.function.name,
          arguments: toolCall.function.arguments
        }
      }))
    };
  }
  if (message.role === "tool") {
    return {
      role: "tool",
      content: typeof message.content === "string" ? message.content : message.content.map((c) => c.text).join(""),
      toolCallId: message.tool_call_id
    };
  }
  if (message.role === "function") {
    throw new Error("unreachable: function message is deprecated");
  }
}

// src/agui/openai/server.ts
var import_server6 = require("@whatwg-node/server");
function createServerAdapter3(createAgent) {
  return (0, import_server6.createServerAdapter)(async (request) => {
    const input = await request.json();
    const { agent: unknownAgent, cleanup } = await Promise.resolve(
      createAgent({ request })
    );
    const agent = "toAGUIAgent" in unknownAgent ? unknownAgent.toAGUIAgent() : unknownAgent;
    const events = handler3(input, agent);
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder();
        for await (const event of events) {
          const sseChunk = `data: ${JSON.stringify(event)}

`;
          controller.enqueue(encoder.encode(sseChunk));
        }
        controller.enqueue(encoder.encode("data: [DONE]\n\n"));
        controller.close();
        cleanup == null ? void 0 : cleanup();
      }
    });
    const headers = new Headers({
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive"
    });
    return new Response(stream, { status: 200, headers });
  });
}

// src/express.ts
var import_runtime = require("@copilotkit/runtime");
var import_express = __toESM(require("express"));
var import_cors = __toESM(require("cors"));
var import_async_hooks = require("async_hooks");
var import_server8 = require("@whatwg-node/server");
var DefaultFetchAPI = __toESM(require("@whatwg-node/fetch"));
async function setupObservabilityIfAvailable(configs) {
  try {
    const { setupObservability: setupObservability2 } = await import("@cloudbase/agent-observability/server");
    await setupObservability2(configs);
  } catch (error) {
  }
}
var preparedAgentStorage = new import_async_hooks.AsyncLocalStorage();
function agentCloneFn() {
  const preparedAgent = preparedAgentStorage.getStore();
  if (preparedAgent) {
    return preparedAgent;
  }
  throw new Error(
    "agent.clone() called outside of request context. This should not happen in normal operation."
  );
}
function run(props) {
  const { port, ...rest } = props;
  createExpressServer(rest).listen(
    typeof port === "number" ? port : parseInt(port)
  );
}
function createExpressServer(props) {
  const { cors: corsOption = true, ...rest } = props;
  const app = (0, import_express.default)();
  if (corsOption) {
    app.use(isCorsOptions(corsOption) ? (0, import_cors.default)(corsOption) : (0, import_cors.default)());
  }
  createExpressRoutes({
    ...rest,
    express: app
  });
  return app;
}
function createExpressRoutes({
  createAgent,
  basePath: _basePath,
  express,
  useAGUI: _useAGUI,
  aguiOptions,
  logger: _logger,
  observability
}) {
  var _a, _b, _c, _d;
  const useAGUI = _useAGUI ?? true;
  const logger = _logger ?? import_agent_shared2.noopLogger;
  const userProvidedBasePath = _basePath !== void 0;
  const serverLogger = ((_a = logger.child) == null ? void 0 : _a.call(logger, { component: "server" })) ?? logger;
  (_b = serverLogger.debug) == null ? void 0 : _b.call(
    serverLogger,
    { basePath: _basePath, useAGUI, userProvidedBasePath },
    "Initializing server routes"
  );
  if (observability) {
    setupObservabilityIfAvailable(observability).catch(() => {
    });
  }
  const sendMessageServerAdapter = useAGUI ? sendMessageAGUI_exports.createServerAdapter(createAgent, {
    logger: serverLogger
  }) : sendMessage_exports.createServerAdapter(createAgent);
  const openaiServerAdapter = openai_exports.createServerAdapter(createAgent);
  const healthzServerAdapter = healthz_exports.serverAdapter;
  if (userProvidedBasePath) {
    const basePath = _basePath;
    if (useAGUI) {
      createAGUIRoute({
        basePath,
        express,
        createAgent,
        logger: serverLogger,
        ...aguiOptions || {}
      });
    }
    express.use(`${basePath}send-message`, sendMessageServerAdapter);
    express.use(`${basePath}healthz`, healthzServerAdapter);
    express.use(`${basePath}chat/completions`, openaiServerAdapter);
    (_c = serverLogger.info) == null ? void 0 : _c.call(serverLogger, { basePath }, "Server routes initialized");
  } else {
    const simplePath = "/";
    const scfPath = "/v1/aibot/bots/:agentId/";
    if (useAGUI) {
      createAGUIRoute({
        basePath: simplePath,
        express,
        createAgent,
        logger: serverLogger,
        ...aguiOptions || {}
      });
      createAGUIRoute({
        basePath: scfPath,
        express,
        createAgent,
        logger: serverLogger,
        ...aguiOptions || {}
      });
    }
    express.use(`${simplePath}send-message`, sendMessageServerAdapter);
    express.use(`${simplePath}healthz`, healthzServerAdapter);
    express.use(`${simplePath}chat/completions`, openaiServerAdapter);
    express.use(`${scfPath}send-message`, sendMessageServerAdapter);
    express.use(`${scfPath}healthz`, healthzServerAdapter);
    express.use(`${scfPath}chat/completions`, openaiServerAdapter);
    (_d = serverLogger.info) == null ? void 0 : _d.call(
      serverLogger,
      { simplePath, scfPath },
      "Server routes initialized (dual endpoints)"
    );
  }
  return express;
}
var AGUIRpcHandlerPromiseMap = /* @__PURE__ */ new Map();
function getAGUIRpcHandler({
  createAgent,
  runtimeOptions,
  basePath,
  endpointOptions,
  request,
  logger,
  requestId
}) {
  const cached = AGUIRpcHandlerPromiseMap.get(basePath);
  if (cached) return cached;
  const handlerPromise = (async () => {
    const { agent } = await createAgent({ request, logger, requestId });
    const templateAgent = "toAGUIAgent" in agent ? agent.toAGUIAgent() : agent;
    templateAgent.clone = agentCloneFn;
    const runtime = new import_runtime.CopilotRuntime({
      agents: {
        default: templateAgent
      },
      ...runtimeOptions || {}
    });
    return (0, import_runtime.copilotRuntimeNodeExpressEndpoint)({
      endpoint: `${basePath}agui`,
      runtime,
      serviceAdapter: new import_runtime.EmptyAdapter(),
      ...endpointOptions || {}
    });
  })();
  AGUIRpcHandlerPromiseMap.set(basePath, handlerPromise);
  return handlerPromise;
}
function createAGUIRoute({
  express,
  basePath,
  createAgent,
  runtimeOptions,
  endpointOptions,
  logger
}) {
  var _a;
  const routeLogger = ((_a = logger.child) == null ? void 0 : _a.call(logger, { component: "agui-route" })) ?? logger;
  express.post(`${basePath}agui`, import_express.default.json(), async (req, res) => {
    var _a2, _b;
    const webRequest = (0, import_server8.normalizeNodeRequest)(req, DefaultFetchAPI);
    const requestId = getOrGenerateRequestId(webRequest.headers, "agui");
    const requestLogger = ((_a2 = routeLogger.child) == null ? void 0 : _a2.call(routeLogger, { requestId })) ?? routeLogger;
    (_b = requestLogger.info) == null ? void 0 : _b.call(requestLogger, { path: `${basePath}agui` }, "Request received");
    const { agent: rawAgent, cleanup } = await createAgent({
      request: webRequest,
      logger: requestLogger,
      requestId
    });
    const preparedAgent = "toAGUIAgent" in rawAgent ? rawAgent.toAGUIAgent() : rawAgent;
    preparedAgent.clone = agentCloneFn;
    const rpcHandler = await getAGUIRpcHandler({
      createAgent,
      basePath,
      runtimeOptions,
      endpointOptions,
      request: webRequest,
      logger: requestLogger,
      requestId
    });
    preparedAgentStorage.run(preparedAgent, () => {
      rpcHandler(req, res);
    });
    if (cleanup) {
      res.on("close", cleanup);
    }
  });
}
function isCorsOptions(cors2) {
  return typeof cors2 !== "boolean";
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ErrorCode,
  agui,
  createConsoleLogger,
  createExpressRoutes,
  createExpressServer,
  extractRequestId,
  generateRequestId,
  getOrGenerateRequestId,
  isErrorWithCode,
  noopLogger,
  run
});
