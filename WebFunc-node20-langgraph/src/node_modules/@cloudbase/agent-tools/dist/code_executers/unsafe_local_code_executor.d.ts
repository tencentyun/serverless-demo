import { BaseCodeExecutor, ICodeExecutorInput } from "./base_code_executor";
import type { Execution as BaseExecution, Result as BaseResult, Logs, ChartTypes, RawData, RunCodeOpts } from "@e2b/code-interpreter";
declare class ExecutionError {
    /**
     * Name of the error.
     **/
    name: string;
    /**
     * Value of the error.
     **/
    value: string;
    /**
     * The raw traceback of the error.
     **/
    traceback: string;
    constructor(name: any, value: any, traceback: any);
}
declare class Result implements BaseResult {
    readonly isMainResult: boolean;
    readonly text?: string;
    readonly html?: string;
    readonly markdown?: string;
    readonly svg?: string;
    readonly png?: string;
    readonly jpeg?: string;
    readonly pdf?: string;
    readonly latex?: string;
    readonly json?: string;
    readonly javascript?: string;
    readonly data?: Record<string, unknown>;
    readonly chart?: ChartTypes;
    readonly extra?: any;
    readonly raw: RawData;
    constructor(rawData: RawData, isMainResult: boolean);
    formats(): string[];
    toJSON(): {
        text: string | undefined;
        html: string | undefined;
        markdown: string | undefined;
        svg: string | undefined;
        png: string | undefined;
        jpeg: string | undefined;
        pdf: string | undefined;
        latex: string | undefined;
        json: string | undefined;
        javascript: string | undefined;
        extra?: any;
    };
}
declare class Execution implements BaseExecution {
    /**
     * List of result of the cell (interactively interpreted last line), display calls (e.g. matplotlib plots).
     */
    results: Result[];
    /**
     * Logs printed to stdout and stderr during execution.
     */
    logs: Logs;
    /**
     * An Error object if an error occurred, null otherwise.
     */
    error?: ExecutionError | undefined;
    /**
     * Execution count of the cell.
     */
    executionCount?: number | undefined;
    constructor(results: any[], logs: {
        stdout: any[];
        stderr: any[];
    }, error: any, executionCount: any);
    /**
     * Returns the text representation of the main result of the cell.
     */
    get text(): string;
    /**
     * Returns the serializable representation of the execution result.
     */
    toJSON(): {
        results: Result[];
        logs: Logs;
        error: ExecutionError;
    };
}
type TUnsafeLocalCodeExecutorOptions = Pick<RunCodeOpts, "timeoutMs" | "envs" | "onStdout" | "onStderr" | "onResult" | "onError">;
export declare class UnsafeLocalCodeExecutor extends BaseCodeExecutor {
    executor: CodeExecutor;
    options: Pick<RunCodeOpts, "timeoutMs" | "envs" | "onStdout" | "onStderr" | "onResult" | "onError">;
    constructor(options: TUnsafeLocalCodeExecutorOptions);
    _invoke(input: ICodeExecutorInput): Promise<Execution>;
}
declare class CodeExecutor {
    executionCount: number;
    constructor();
    runCode(language: any, code: any, options?: RunCodeOpts): Promise<Execution>;
    getLanguageConfig(language: any, code: any): any;
    executeCode(config: any, options?: RunCodeOpts): Promise<{
        success: boolean;
        exitCode: number | null;
        stdout: string;
        stderr: string;
    }>;
    private parseResults;
    private parsePythonResults;
    private parseJavaScriptResults;
    private isDataFrameLine;
    private inferArrayType;
    private calculateArrayStats;
    private calculateStandardDeviation;
    private getMostCommon;
    private getDecimalPlaces;
    private isJsonLine;
    private isNumber;
    private parseTableData;
    private convertTableToHtml;
    private parseTraceback;
}
export {};
//# sourceMappingURL=unsafe_local_code_executor.d.ts.map