import {
  AgentRunner,
  CopilotRuntime,
  InMemoryAgentRunner,
  VERSION,
  callAfterRequestMiddleware,
  callBeforeRequestMiddleware,
  createJsonRequest,
  expectString,
  handleConnectAgent,
  handleGetRuntimeInfo,
  handleRunAgent,
  handleStopAgent,
  handleTranscribe,
  parseMethodCall
} from "./chunk-2KPQGACC.mjs";

// src/endpoints/hono.ts
import { Hono } from "hono";
import { cors } from "hono/cors";
import { logger } from "@copilotkitnext/shared";
function createCopilotEndpoint({ runtime, basePath, cors: corsConfig }) {
  const app = new Hono();
  return app.basePath(basePath).use(
    "*",
    cors({
      origin: corsConfig?.origin ?? "*",
      allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH", "OPTIONS"],
      allowHeaders: ["*"],
      credentials: corsConfig?.credentials ?? false
    })
  ).use("*", async (c, next) => {
    const request = c.req.raw;
    const path = c.req.path;
    try {
      const maybeModifiedRequest = await callBeforeRequestMiddleware({
        runtime,
        request,
        path
      });
      if (maybeModifiedRequest) {
        c.set("modifiedRequest", maybeModifiedRequest);
      }
    } catch (error) {
      logger.error({ err: error, url: request.url, path }, "Error running before request middleware");
      if (error instanceof Response) {
        return error;
      }
      throw error;
    }
    await next();
  }).use("*", async (c, next) => {
    await next();
    const response = c.res;
    const path = c.req.path;
    callAfterRequestMiddleware({
      runtime,
      response,
      path
    }).catch((error) => {
      logger.error({ err: error, url: c.req.url, path }, "Error running after request middleware");
    });
  }).post("/agent/:agentId/run", async (c) => {
    const agentId = c.req.param("agentId");
    const request = c.get("modifiedRequest") || c.req.raw;
    try {
      return await handleRunAgent({
        runtime,
        request,
        agentId
      });
    } catch (error) {
      logger.error({ err: error, url: request.url, path: c.req.path }, "Error running request handler");
      throw error;
    }
  }).post("/agent/:agentId/connect", async (c) => {
    const agentId = c.req.param("agentId");
    const request = c.get("modifiedRequest") || c.req.raw;
    try {
      return await handleConnectAgent({
        runtime,
        request,
        agentId
      });
    } catch (error) {
      logger.error({ err: error, url: request.url, path: c.req.path }, "Error running request handler");
      throw error;
    }
  }).post("/agent/:agentId/stop/:threadId", async (c) => {
    const agentId = c.req.param("agentId");
    const threadId = c.req.param("threadId");
    const request = c.get("modifiedRequest") || c.req.raw;
    try {
      return await handleStopAgent({
        runtime,
        request,
        agentId,
        threadId
      });
    } catch (error) {
      logger.error({ err: error, url: request.url, path: c.req.path }, "Error running request handler");
      throw error;
    }
  }).get("/info", async (c) => {
    const request = c.get("modifiedRequest") || c.req.raw;
    try {
      return await handleGetRuntimeInfo({
        runtime,
        request
      });
    } catch (error) {
      logger.error({ err: error, url: request.url, path: c.req.path }, "Error running request handler");
      throw error;
    }
  }).post("/transcribe", async (c) => {
    const request = c.get("modifiedRequest") || c.req.raw;
    try {
      return await handleTranscribe({
        runtime,
        request
      });
    } catch (error) {
      logger.error({ err: error, url: request.url, path: c.req.path }, "Error running request handler");
      throw error;
    }
  }).notFound((c) => {
    return c.json({ error: "Not found" }, 404);
  });
}

// src/endpoints/hono-single.ts
import { Hono as Hono2 } from "hono";
import { cors as cors2 } from "hono/cors";
import { logger as logger2 } from "@copilotkitnext/shared";
function createCopilotEndpointSingleRoute({ runtime, basePath, cors: corsConfig }) {
  const app = new Hono2();
  const routePath = normalizePath(basePath);
  return app.basePath(routePath).use(
    "*",
    cors2({
      origin: corsConfig?.origin ?? "*",
      allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH", "OPTIONS"],
      allowHeaders: ["*"],
      credentials: corsConfig?.credentials ?? false
    })
  ).use("*", async (c, next) => {
    const request = c.req.raw;
    const path = c.req.path;
    try {
      const maybeModifiedRequest = await callBeforeRequestMiddleware({
        runtime,
        request,
        path
      });
      if (maybeModifiedRequest) {
        c.set("modifiedRequest", maybeModifiedRequest);
      }
    } catch (error) {
      logger2.error({ err: error, url: request.url, path }, "Error running before request middleware");
      if (error instanceof Response) {
        return error;
      }
      throw error;
    }
    await next();
  }).use("*", async (c, next) => {
    await next();
    const response = c.res;
    const path = c.req.path;
    callAfterRequestMiddleware({
      runtime,
      response,
      path
    }).catch((error) => {
      logger2.error({ err: error, url: c.req.url, path }, "Error running after request middleware");
    });
  }).post("/", async (c) => {
    const request = c.get("modifiedRequest") || c.req.raw;
    let methodCall;
    try {
      methodCall = await parseMethodCall(request);
    } catch (error) {
      if (error instanceof Response) {
        logger2.warn({ url: request.url }, "Invalid single-route payload");
        return error;
      }
      logger2.warn({ err: error, url: request.url }, "Invalid single-route payload");
      return c.json(
        {
          error: "invalid_request",
          message: error instanceof Error ? error.message : "Invalid request payload"
        },
        400
      );
    }
    try {
      switch (methodCall.method) {
        case "agent/run": {
          const agentId = expectString(methodCall.params, "agentId");
          const handlerRequest = createJsonRequest(request, methodCall.body);
          return await handleRunAgent({ runtime, request: handlerRequest, agentId });
        }
        case "agent/connect": {
          const agentId = expectString(methodCall.params, "agentId");
          const handlerRequest = createJsonRequest(request, methodCall.body);
          return await handleConnectAgent({ runtime, request: handlerRequest, agentId });
        }
        case "agent/stop": {
          const agentId = expectString(methodCall.params, "agentId");
          const threadId = expectString(methodCall.params, "threadId");
          return await handleStopAgent({ runtime, request, agentId, threadId });
        }
        case "info": {
          return await handleGetRuntimeInfo({ runtime, request });
        }
        case "transcribe": {
          const handlerRequest = createJsonRequest(request, methodCall.body);
          return await handleTranscribe({ runtime, request: handlerRequest });
        }
        default: {
          const exhaustiveCheck = methodCall.method;
          return exhaustiveCheck;
        }
      }
    } catch (error) {
      if (error instanceof Response) {
        return error;
      }
      logger2.error({ err: error, url: request.url, method: methodCall.method }, "Error running single-route handler");
      throw error;
    }
  }).notFound((c) => {
    return c.json({ error: "Not found" }, 404);
  });
}
function normalizePath(path) {
  if (!path) {
    throw new Error("basePath must be provided for single-route endpoint");
  }
  if (!path.startsWith("/")) {
    return `/${path}`;
  }
  if (path.length > 1 && path.endsWith("/")) {
    return path.slice(0, -1);
  }
  return path;
}

// src/runner/index.ts
import { finalizeRunEvents } from "@copilotkitnext/shared";

// src/transcription-service/transcription-service.ts
var TranscriptionService = class {
};
export {
  AgentRunner,
  CopilotRuntime,
  InMemoryAgentRunner,
  TranscriptionService,
  VERSION,
  createCopilotEndpoint,
  createCopilotEndpointSingleRoute,
  finalizeRunEvents
};
//# sourceMappingURL=index.mjs.map