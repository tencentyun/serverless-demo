"use strict";
/**
 * MCP Toolkit
 *
 * A toolkit that manages MCP tools from external servers
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MCPToolkit = void 0;
exports.createMCPToolkit = createMCPToolkit;
const utils_1 = require("../utils");
const mcp_client_manager_1 = require("./mcp-client-manager");
const client_tool_1 = require("./client-tool");
/**
 * MCP Toolkit - manages tools from external MCP servers
 */
class MCPToolkit extends utils_1.BaseToolkit {
    constructor(name = "mcp-toolkit") {
        super({ name });
        this.serverConfigs = new Map();
        this.clientManager = new mcp_client_manager_1.MCPClientManager();
    }
    /**
     * Add an MCP server and load its tools
     */
    async addServer(serverId, config) {
        await this.clientManager.addServer(serverId, config);
        this.serverConfigs.set(serverId, config);
        // Load tools from the server
        await this.loadServerTools(serverId);
    }
    /**
     * Load tools from a specific server
     */
    async loadServerTools(serverId) {
        const clientTools = this.clientManager.createClientTools(serverId);
        this.addTools(clientTools);
    }
    /**
     * Remove a server and its tools
     */
    async removeServer(serverId) {
        // Remove tools from this server
        const toolsToRemove = this.getTools().filter((tool) => tool instanceof client_tool_1.MCPClientTool && tool.name.startsWith(`${serverId}:`));
        for (const tool of toolsToRemove) {
            this.removeTool(tool.name);
        }
        // Disconnect from server
        await this.clientManager.disconnectServer(serverId);
        this.serverConfigs.delete(serverId);
    }
    /**
     * Get all connected servers
     */
    getConnectedServers() {
        return Array.from(this.serverConfigs.keys());
    }
    /**
     * Get tools from a specific server
     */
    getServerTools(serverId) {
        return this.getTools().filter((tool) => tool instanceof client_tool_1.MCPClientTool && tool.name.startsWith(`${serverId}:`));
    }
    /**
     * Refresh all server connections
     */
    async refresh() {
        // Clear existing tools
        const toolNames = this.getTools().map((tool) => tool.name);
        for (const toolName of toolNames) {
            this.removeTool(toolName);
        }
        // Refresh client manager
        await this.clientManager.refresh();
        // Reload all tools
        for (const serverId of this.serverConfigs.keys()) {
            await this.loadServerTools(serverId);
        }
    }
    /**
     * Get toolkit statistics
     */
    getStats() {
        const mcpStats = this.clientManager.getStats();
        return {
            name: this.name,
            description: this.description,
            toolCount: this.getTools().length,
            mcp: mcpStats,
        };
    }
    /**
     * Cleanup - disconnect from all servers
     */
    async cleanup() {
        await this.clientManager.disconnectAll();
        // Clear all tools
        const toolNames = this.getTools().map((tool) => tool.name);
        for (const toolName of toolNames) {
            this.removeTool(toolName);
        }
        this.serverConfigs.clear();
    }
    /**
     * Get the underlying client manager
     */
    getClientManager() {
        return this.clientManager;
    }
}
exports.MCPToolkit = MCPToolkit;
/**
 * Helper function to check if a config is a transport config
 */
function isTransportConfig(config) {
    return (config &&
        typeof config === "object" &&
        !("transport" in config) &&
        (("command" in config) ||
            ("url" in config) ||
            ("memoryId" in config) ||
            ("type" in config && config.type !== undefined)));
}
/**
 * Create a new MCP toolkit with servers
 *
 * @param servers - Server configurations in object mapping or array format
 * @param name - Optional toolkit name
 *
 * @example
 * // Object mapping format (recommended) - matches standard MCP config
 * const toolkit = await createMCPToolkit({
 *   time: {
 *     command: "uvx",
 *     args: ["mcp-server-time"]
 *   },
 *   weather: {
 *     url: "http://localhost:3000/mcp"
 *   }
 * });
 *
 * @example
 * // Object mapping with full MCPClientConfig
 * const toolkit = await createMCPToolkit({
 *   time: {
 *     name: "time-server",
 *     version: "1.0.0",
 *     transport: {
 *       command: "uvx",
 *       args: ["mcp-server-time"]
 *     }
 *   }
 * });
 *
 * @example
 * // Array format (backward compatible)
 * const toolkit = await createMCPToolkit([
 *   { id: "time", config: { transport: { command: "uvx", args: ["mcp-server-time"] } } }
 * ]);
 */
async function createMCPToolkit(servers, name) {
    const toolkit = new MCPToolkit(name);
    // Normalize servers to array format
    const serverArray = Array.isArray(servers)
        ? servers
        : Object.entries(servers).map(([id, configOrTransport]) => {
            // Check if it's a direct transport config or a full MCPClientConfig
            if (isTransportConfig(configOrTransport)) {
                // It's a transport config, wrap it in MCPClientConfig
                return {
                    id,
                    config: {
                        name: id,
                        version: "1.0.0",
                        transport: configOrTransport,
                    },
                };
            }
            else {
                // It's already a full MCPClientConfig
                return { id, config: configOrTransport };
            }
        });
    for (const { id, config } of serverArray) {
        await toolkit.addServer(id, config);
    }
    return toolkit;
}
//# sourceMappingURL=mcp-toolkit.js.map