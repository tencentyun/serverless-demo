{"version":3,"file":"types.js","names":[],"sources":["../../src/state/types.ts"],"sourcesContent":["import type {\n  StandardSchemaV1,\n  StandardJSONSchemaV1,\n  StandardTypedV1,\n} from \"@standard-schema/spec\";\n\ninterface CombinedProps<Input = unknown, Output = Input>\n  extends StandardSchemaV1.Props<Input, Output>,\n    StandardJSONSchemaV1.Props<Input, Output> {}\n\n/**\n * SerializableSchema is the core interface for any schema used by LangGraph state.\n *\n * @template Input - The type of input data the schema can be used to validate.\n * @template Output - The type of output produced after validation, post-refinement/coercion.\n *\n * @remarks\n * - SerializableSchema provides a single property, `~standard`, which must conform to\n *   both `StandardSchemaV1.Props` and `StandardJSONSchemaV1.Props`.\n * - This ensures all schemas are compatible with both runtime validation (e.g., type checks,\n *   coercion, custom refinements) and structured schema export/generation (e.g., producing\n *   a compatible JSON Schema).\n * - A value matching SerializableSchema can be passed directly to LangGraph state\n *   definitions, reducers, or other schema-accepting APIs.\n *\n * @example\n * ```ts\n * import { z } from \"zod\";\n *\n * // complies with SerializableSchema\n * const zodSchema = z.object({ x: z.string() });\n *\n * // Use in a StateObject definition:\n * const AgentState = new StateObject({\n *   data: schema\n * });\n * ```\n */\nexport interface SerializableSchema<Input = unknown, Output = Input> {\n  \"~standard\": CombinedProps<Input, Output>;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\nexport declare namespace SerializableSchema {\n  /**\n   * Infers the type of input expected by a SerializableSchema.\n   *\n   * @template T - A SerializableSchema instance.\n   * @returns The type of data that may be passed to the schema for validation.\n   *\n   * @example\n   * ```ts\n   * type MyInput = SerializableSchema.InferInput<typeof schema>;\n   * ```\n   */\n  export type InferInput<T extends SerializableSchema> =\n    StandardTypedV1.InferInput<T>;\n\n  /**\n   * Infers the output type yielded by a SerializableSchema, after parsing or coercion.\n   *\n   * @template T - A SerializableSchema instance.\n   * @returns The type produced by successfully validating/coercing input data.\n   *\n   * @example\n   * ```ts\n   * type MyOutput = SerializableSchema.InferOutput<typeof schema>;\n   * ```\n   */\n  export type InferOutput<T extends SerializableSchema> =\n    StandardTypedV1.InferOutput<T>;\n}\n\n/**\n * Type guard to check if a given value is a Standard Schema V1 object.\n *\n * @remarks\n * A Standard Schema object is expected to have a `~standard` property with a `validate` function.\n * This guard does NOT check for JSON schema support.\n *\n * @typeParam Input - The type of input validated by this schema.\n * @typeParam Output - The type of output produced after validation.\n * @param schema - The value to test.\n * @returns True if the schema conforms to the Standard Schema interface.\n *\n * @example\n * ```ts\n * if (isStandardSchema(mySchema)) {\n *   const result = mySchema[\"~standard\"].validate(input);\n * }\n * ```\n */\nexport function isStandardSchema<Input = unknown, Output = Input>(\n  schema: StandardSchemaV1<Input, Output>\n): schema is StandardSchemaV1<Input, Output>;\nexport function isStandardSchema<Input = unknown, Output = Input>(\n  schema: unknown\n): schema is StandardSchemaV1<Input, Output>;\nexport function isStandardSchema<Input = unknown, Output = Input>(\n  schema: StandardSchemaV1<Input, Output> | unknown\n): schema is StandardSchemaV1<Input, Output> {\n  return (\n    typeof schema === \"object\" &&\n    schema !== null &&\n    \"~standard\" in schema &&\n    typeof schema[\"~standard\"] === \"object\" &&\n    schema[\"~standard\"] !== null &&\n    \"validate\" in schema[\"~standard\"]\n  );\n}\n\n/**\n * Type guard to check if a given value is a Standard JSON Schema V1 object.\n *\n * @remarks\n * A Standard JSON Schema object is expected to have a `~standard` property with a `jsonSchema` function.\n * This may be used to generate a JSON Schema (for UI/form tooling, documentation, etc).\n *\n * @typeParam Input - The type of input described by this JSON schema.\n * @typeParam Output - The type of output described by this JSON schema.\n * @param schema - The value to test.\n * @returns True if the schema exposes JSON schema generation.\n *\n * @example\n * ```ts\n * if (isStandardJSONSchema(mySchema)) {\n *   const jschema = mySchema[\"~standard\"].jsonSchema();\n * }\n * ```\n */\nexport function isStandardJSONSchema<Input = unknown, Output = Input>(\n  schema: StandardJSONSchemaV1<Input, Output>\n): schema is StandardJSONSchemaV1<Input, Output>;\nexport function isStandardJSONSchema<Input = unknown, Output = Input>(\n  schema: unknown\n): schema is StandardJSONSchemaV1<Input, Output>;\nexport function isStandardJSONSchema<Input = unknown, Output = Input>(\n  schema: StandardJSONSchemaV1<Input, Output> | unknown\n): schema is StandardJSONSchemaV1<Input, Output> {\n  return (\n    typeof schema === \"object\" &&\n    schema !== null &&\n    \"~standard\" in schema &&\n    typeof schema[\"~standard\"] === \"object\" &&\n    schema[\"~standard\"] !== null &&\n    \"jsonSchema\" in schema[\"~standard\"]\n  );\n}\n\n/**\n * Type guard to check if a given value is a `SerializableSchema`, i.e.\n * both a Standard Schema and a Standard JSON Schema object.\n *\n * @remarks\n * This checks for both the presence of a Standard Schema V1 interface\n * and the ability to generate a JSON schema.\n *\n * @typeParam Input - The type of input described by the schema.\n * @typeParam Output - The type of output described by the schema.\n * @param schema - The value to test.\n * @returns True if the schema is a valid `SerializableSchema`.\n *\n * @example\n * ```ts\n * if (isSerializableSchema(schema)) {\n *   schema[\"~standard\"].validate(data);\n *   const json = schema[\"~standard\"].jsonSchema();\n * }\n * ```\n */\nexport function isSerializableSchema<Input = unknown, Output = Input>(\n  schema: SerializableSchema<Input, Output>\n): schema is SerializableSchema<Input, Output>;\nexport function isSerializableSchema<Input = unknown, Output = Input>(\n  schema: unknown\n): schema is SerializableSchema<Input, Output>;\nexport function isSerializableSchema<Input = unknown, Output = Input>(\n  schema: SerializableSchema<Input, Output> | unknown\n): schema is SerializableSchema<Input, Output> {\n  return isStandardSchema(schema) && isStandardJSONSchema(schema);\n}\n"],"mappings":";AAkGA,SAAgB,iBACd,QAC2C;AAC3C,QACE,OAAO,WAAW,YAClB,WAAW,QACX,eAAe,UACf,OAAO,OAAO,iBAAiB,YAC/B,OAAO,iBAAiB,QACxB,cAAc,OAAO;;AA6BzB,SAAgB,qBACd,QAC+C;AAC/C,QACE,OAAO,WAAW,YAClB,WAAW,QACX,eAAe,UACf,OAAO,OAAO,iBAAiB,YAC/B,OAAO,iBAAiB,QACxB,gBAAgB,OAAO;;AA+B3B,SAAgB,qBACd,QAC6C;AAC7C,QAAO,iBAAiB,OAAO,IAAI,qBAAqB,OAAO"}