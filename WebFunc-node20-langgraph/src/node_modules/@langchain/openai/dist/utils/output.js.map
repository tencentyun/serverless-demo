{"version":3,"file":"output.js","names":["model: string","method: unknown","response_format: ResponseFormatJSONSchema","parser: (content: string) => ParsedT","zodSchema: InteropZodType","name: string","props: Omit<ResponseFormatJSONSchema.JSONSchema, \"schema\" | \"strict\" | \"name\">","parseV4","content: string","messages: unknown"],"sources":["../../src/utils/output.ts"],"sourcesContent":["import { OpenAI as OpenAIClient } from \"openai\";\nimport {\n  InteropZodType,\n  isZodSchemaV3,\n  isZodSchemaV4,\n} from \"@langchain/core/utils/types\";\nimport { parse as parseV4 } from \"zod/v4/core\";\nimport { ResponseFormatJSONSchema } from \"openai/resources\";\nimport { zodResponseFormat } from \"openai/helpers/zod\";\nimport { ContentBlock, UsageMetadata } from \"@langchain/core/messages\";\nimport { toJsonSchema } from \"@langchain/core/utils/json_schema\";\n\nconst SUPPORTED_METHODS = [\n  \"jsonSchema\",\n  \"functionCalling\",\n  \"jsonMode\",\n] as const;\ntype SupportedMethod = (typeof SUPPORTED_METHODS)[number];\n\n/**\n * Get the structured output method for a given model. By default, it uses\n * `jsonSchema` if the model supports it, otherwise it uses `functionCalling`.\n *\n * @throws if the method is invalid, e.g. is not a string or invalid method is provided.\n * @param model - The model name.\n * @param config - The structured output method options.\n * @returns The structured output method.\n */\nexport function getStructuredOutputMethod(\n  model: string,\n  method: unknown\n): SupportedMethod {\n  /**\n   * If a method is provided, validate it.\n   */\n  if (\n    typeof method !== \"undefined\" &&\n    !SUPPORTED_METHODS.includes(method as SupportedMethod)\n  ) {\n    throw new Error(\n      `Invalid method: ${method}. Supported methods are: ${SUPPORTED_METHODS.join(\n        \", \"\n      )}`\n    );\n  }\n\n  const hasSupportForJsonSchema =\n    !model.startsWith(\"gpt-3\") &&\n    !model.startsWith(\"gpt-4-\") &&\n    model !== \"gpt-4\";\n\n  /**\n   * If the model supports JSON Schema, use it by default.\n   */\n  if (hasSupportForJsonSchema && !method) {\n    return \"jsonSchema\";\n  }\n\n  if (!hasSupportForJsonSchema && method === \"jsonSchema\") {\n    throw new Error(\n      `JSON Schema is not supported for model \"${model}\". Please use a different method, e.g. \"functionCalling\" or \"jsonMode\".`\n    );\n  }\n\n  /**\n   * If the model does not support JSON Schema, use function calling by default.\n   */\n  return (method as SupportedMethod) ?? \"functionCalling\";\n}\n\n// inlined from openai/lib/parser.ts\nfunction makeParseableResponseFormat<ParsedT>(\n  response_format: ResponseFormatJSONSchema,\n  parser: (content: string) => ParsedT\n) {\n  const obj = { ...response_format };\n\n  Object.defineProperties(obj, {\n    $brand: {\n      value: \"auto-parseable-response-format\",\n      enumerable: false,\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false,\n    },\n  });\n\n  return obj;\n}\n\nexport function interopZodResponseFormat(\n  zodSchema: InteropZodType,\n  name: string,\n  props: Omit<ResponseFormatJSONSchema.JSONSchema, \"schema\" | \"strict\" | \"name\">\n) {\n  if (isZodSchemaV3(zodSchema)) {\n    return zodResponseFormat(zodSchema, name, props);\n  }\n  if (isZodSchemaV4(zodSchema)) {\n    return makeParseableResponseFormat(\n      {\n        type: \"json_schema\",\n        json_schema: {\n          ...props,\n          name,\n          strict: true,\n          schema: toJsonSchema(zodSchema, {\n            cycles: \"ref\", // equivalent to nameStrategy: 'duplicate-ref'\n            reused: \"ref\", // equivalent to $refStrategy: 'extract-to-root'\n            override(ctx) {\n              ctx.jsonSchema.title = name; // equivalent to `name` property\n              // TODO: implement `nullableStrategy` patch-fix (zod doesn't support openApi3 json schema target)\n              // TODO: implement `openaiStrictMode` patch-fix (where optional properties without `nullable` are not supported)\n            },\n            /// property equivalents from native `zodResponseFormat` fn\n            // openaiStrictMode: true,\n            // name,\n            // nameStrategy: 'duplicate-ref',\n            // $refStrategy: 'extract-to-root',\n            // nullableStrategy: 'property',\n          }),\n        },\n      },\n      (content) => parseV4(zodSchema, JSON.parse(content))\n    );\n  }\n  throw new Error(\"Unsupported schema response format\");\n}\n\n/**\n * Handle multi modal response content.\n *\n * @param content The content of the message.\n * @param messages The messages of the response.\n * @returns The new content of the message.\n */\nexport function handleMultiModalOutput(\n  content: string,\n  messages: unknown\n): ContentBlock[] | string {\n  /**\n   * Handle OpenRouter image responses\n   * @see https://openrouter.ai/docs/features/multimodal/image-generation#api-usage\n   */\n  if (\n    messages &&\n    typeof messages === \"object\" &&\n    \"images\" in messages &&\n    Array.isArray(messages.images)\n  ) {\n    const images = messages.images\n      .filter((image) => typeof image?.image_url?.url === \"string\")\n      .map(\n        (image) =>\n          ({\n            type: \"image\",\n            url: image.image_url.url as string,\n          } as const)\n      );\n    return [{ type: \"text\", text: content }, ...images];\n  }\n\n  return content;\n}\n\n// TODO: make this a converter\nexport function _convertOpenAIResponsesUsageToLangChainUsage(\n  usage?: OpenAIClient.Responses.ResponseUsage\n): UsageMetadata {\n  const inputTokenDetails = {\n    ...(usage?.input_tokens_details?.cached_tokens != null && {\n      cache_read: usage?.input_tokens_details?.cached_tokens,\n    }),\n  };\n  const outputTokenDetails = {\n    ...(usage?.output_tokens_details?.reasoning_tokens != null && {\n      reasoning: usage?.output_tokens_details?.reasoning_tokens,\n    }),\n  };\n  return {\n    input_tokens: usage?.input_tokens ?? 0,\n    output_tokens: usage?.output_tokens ?? 0,\n    total_tokens: usage?.total_tokens ?? 0,\n    input_token_details: inputTokenDetails,\n    output_token_details: outputTokenDetails,\n  };\n}\n"],"mappings":";;;;;;AAYA,MAAM,oBAAoB;CACxB;CACA;CACA;AACD;;;;;;;;;;AAYD,SAAgB,0BACdA,OACAC,QACiB;;;;AAIjB,KACE,OAAO,WAAW,eAClB,CAAC,kBAAkB,SAAS,OAA0B,CAEtD,OAAM,IAAI,MACR,CAAC,gBAAgB,EAAE,OAAO,yBAAyB,EAAE,kBAAkB,KACrE,KACD,EAAE;CAIP,MAAM,0BACJ,CAAC,MAAM,WAAW,QAAQ,IAC1B,CAAC,MAAM,WAAW,SAAS,IAC3B,UAAU;;;;AAKZ,KAAI,2BAA2B,CAAC,OAC9B,QAAO;AAGT,KAAI,CAAC,2BAA2B,WAAW,aACzC,OAAM,IAAI,MACR,CAAC,wCAAwC,EAAE,MAAM,uEAAuE,CAAC;;;;AAO7H,QAAQ,UAA8B;AACvC;AAGD,SAAS,4BACPC,iBACAC,QACA;CACA,MAAM,MAAM,EAAE,GAAG,gBAAiB;CAElC,OAAO,iBAAiB,KAAK;EAC3B,QAAQ;GACN,OAAO;GACP,YAAY;EACb;EACD,WAAW;GACT,OAAO;GACP,YAAY;EACb;CACF,EAAC;AAEF,QAAO;AACR;AAED,SAAgB,yBACdC,WACAC,MACAC,OACA;AACA,KAAI,cAAc,UAAU,CAC1B,QAAO,kBAAkB,WAAW,MAAM,MAAM;AAElD,KAAI,cAAc,UAAU,CAC1B,QAAO,4BACL;EACE,MAAM;EACN,aAAa;GACX,GAAG;GACH;GACA,QAAQ;GACR,QAAQ,aAAa,WAAW;IAC9B,QAAQ;IACR,QAAQ;IACR,SAAS,KAAK;KACZ,IAAI,WAAW,QAAQ;IAGxB;GAOF,EAAC;EACH;CACF,GACD,CAAC,YAAYC,MAAQ,WAAW,KAAK,MAAM,QAAQ,CAAC,CACrD;AAEH,OAAM,IAAI,MAAM;AACjB;;;;;;;;AASD,SAAgB,uBACdC,SACAC,UACyB;;;;;AAKzB,KACE,YACA,OAAO,aAAa,YACpB,YAAY,YACZ,MAAM,QAAQ,SAAS,OAAO,EAC9B;EACA,MAAM,SAAS,SAAS,OACrB,OAAO,CAAC,UAAU,OAAO,OAAO,WAAW,QAAQ,SAAS,CAC5D,IACC,CAAC,WACE;GACC,MAAM;GACN,KAAK,MAAM,UAAU;EACtB,GACJ;AACH,SAAO,CAAC;GAAE,MAAM;GAAQ,MAAM;EAAS,GAAE,GAAG,MAAO;CACpD;AAED,QAAO;AACR"}