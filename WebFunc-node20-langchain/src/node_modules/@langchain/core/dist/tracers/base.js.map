{"version":3,"file":"base.js","names":["runTree?: RunTree","run?: Run","parentRun?: Run","value: any","defaultKey: string","x: BaseCallbackHandler","_fields?: BaseCallbackHandlerInput","runId?: string","error: unknown","parentRun: Run","childRun: Run","run: Run","parentRunId: string | undefined","llm: Serialized","prompts: string[]","runId: string","parentRunId?: string","extraParams?: KVMap","tags?: string[]","metadata?: KVMap","name?: string","messages: BaseMessage[][]","output: LLMResult","_parentRunId?: string","_tags?: string[]","extraParams?: Record<string, unknown>","chain: Serialized","inputs: ChainValues","runType?: string","extra?: Record<string, unknown>","outputs: ChainValues","kwargs?: { inputs?: Record<string, unknown> }","tool: Serialized","input: string","output: any","action: AgentAction","action: AgentFinish","retriever: Serialized","query: string","documents: Document<Record<string, unknown>>[]","text: string","token: string","idx: NewTokenIndices","fields?: HandleLLMNewTokenCallbackFields"],"sources":["../../src/tracers/base.ts"],"sourcesContent":["import { KVMap, BaseRun } from \"langsmith/schemas\";\nimport { RunTree, convertToDottedOrderFormat } from \"langsmith/run_trees\";\n\nimport type { ChainValues } from \"../utils/types/index.js\";\nimport type { AgentAction, AgentFinish } from \"../agents.js\";\nimport type { LLMResult } from \"../outputs.js\";\nimport type { BaseMessage } from \"../messages/base.js\";\nimport { Serialized } from \"../load/serializable.js\";\nimport {\n  BaseCallbackHandler,\n  BaseCallbackHandlerInput,\n  HandleLLMNewTokenCallbackFields,\n  NewTokenIndices,\n} from \"../callbacks/base.js\";\nimport type { Document } from \"../documents/document.js\";\nimport { getRuntimeEnvironment } from \"../utils/env.js\";\n\nexport type RunType = string;\n\n// TODO: Remove this type and just use the base LangSmith Run type.\nexport interface Run extends BaseRun {\n  // some optional fields are always present here\n  id: string;\n  start_time: number;\n  end_time?: number;\n  execution_order: number;\n  // some additional fields that don't exist in sdk runs\n  child_runs: this[];\n  child_execution_order: number;\n  events: Array<{\n    name: string;\n    time: string;\n    kwargs?: Record<string, unknown>;\n  }>;\n  trace_id?: string;\n  dotted_order?: string;\n  /** @internal */\n  _serialized_start_time?: string;\n}\n\n// TODO: Remove and just use base LangSmith Run type\nconst convertRunTreeToRun = (runTree?: RunTree): Run | undefined => {\n  if (!runTree) {\n    return undefined;\n  }\n  // Important that we return the raw run tree object since the reference\n  // is mutated in other places.\n  // TODO: Remove places where this is being done.\n\n  runTree.events = runTree.events ?? [];\n  runTree.child_runs = runTree.child_runs ?? [];\n  // TODO: Remove this cast and just use the LangSmith RunTree type.\n  return runTree as unknown as Run;\n};\n\nfunction convertRunToRunTree(run?: Run, parentRun?: Run): RunTree | undefined {\n  if (!run) {\n    return undefined;\n  }\n  return new RunTree({\n    ...run,\n    start_time: run._serialized_start_time ?? run.start_time,\n    parent_run: convertRunToRunTree(parentRun),\n    child_runs: run.child_runs\n      .map((r) => convertRunToRunTree(r))\n      .filter((r): r is RunTree => r !== undefined),\n    extra: {\n      ...run.extra,\n      runtime: getRuntimeEnvironment(),\n    },\n    tracingEnabled: false,\n  });\n}\n\nexport interface AgentRun extends Run {\n  actions: AgentAction[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _coerceToDict(value: any, defaultKey: string) {\n  return value && !Array.isArray(value) && typeof value === \"object\"\n    ? value\n    : { [defaultKey]: value };\n}\n\nexport function isBaseTracer(x: BaseCallbackHandler): x is BaseTracer {\n  return typeof (x as BaseTracer)._addRunToRunMap === \"function\";\n}\n\nexport abstract class BaseTracer extends BaseCallbackHandler {\n  /** @deprecated Use `runTreeMap` instead. */\n  protected runMap: Map<string, Run> = new Map();\n\n  protected runTreeMap: Map<string, RunTree> = new Map();\n\n  protected usesRunTreeMap = false;\n\n  constructor(_fields?: BaseCallbackHandlerInput) {\n    super(...arguments);\n  }\n\n  copy(): this {\n    return this;\n  }\n\n  protected getRunById(runId?: string): Run | undefined {\n    if (runId === undefined) {\n      return undefined;\n    }\n    return this.usesRunTreeMap\n      ? convertRunTreeToRun(this.runTreeMap.get(runId))\n      : this.runMap.get(runId);\n  }\n\n  protected stringifyError(error: unknown) {\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    if (error instanceof Error) {\n      return error.message + (error?.stack ? `\\n\\n${error.stack}` : \"\");\n    }\n\n    if (typeof error === \"string\") {\n      return error;\n    }\n\n    return `${error}`;\n  }\n\n  protected abstract persistRun(run: Run): Promise<void>;\n\n  protected _addChildRun(parentRun: Run, childRun: Run) {\n    parentRun.child_runs.push(childRun);\n  }\n\n  _addRunToRunMap(run: Run) {\n    const { dottedOrder: currentDottedOrder, microsecondPrecisionDatestring } =\n      convertToDottedOrderFormat(\n        new Date(run.start_time).getTime(),\n        run.id,\n        run.execution_order\n      );\n    const storedRun = { ...run };\n    const parentRun = this.getRunById(storedRun.parent_run_id);\n    if (storedRun.parent_run_id !== undefined) {\n      if (parentRun) {\n        this._addChildRun(parentRun, storedRun);\n        parentRun.child_execution_order = Math.max(\n          parentRun.child_execution_order,\n          storedRun.child_execution_order\n        );\n        storedRun.trace_id = parentRun.trace_id;\n        if (parentRun.dotted_order !== undefined) {\n          storedRun.dotted_order = [\n            parentRun.dotted_order,\n            currentDottedOrder,\n          ].join(\".\");\n          storedRun._serialized_start_time = microsecondPrecisionDatestring;\n        } else {\n          // This can happen naturally for callbacks added within a run\n          // console.debug(`Parent run with UUID ${storedRun.parent_run_id} has no dotted order.`);\n        }\n      } else {\n        // This can happen naturally for callbacks added within a run\n        // console.debug(\n        //   `Parent run with UUID ${storedRun.parent_run_id} not found.`\n        // );\n\n        // Child run with no trace_id and dotted_order causes 400 error on LangSmith.\n        // So we set the parent_run_id to undefined as a workaround.\n        // This run will be shown as isolated run on LangSmith.\n        storedRun.parent_run_id = undefined;\n      }\n    } else {\n      storedRun.trace_id = storedRun.id;\n      storedRun.dotted_order = currentDottedOrder;\n      storedRun._serialized_start_time = microsecondPrecisionDatestring;\n    }\n    if (this.usesRunTreeMap) {\n      const runTree = convertRunToRunTree(storedRun, parentRun);\n      if (runTree !== undefined) {\n        this.runTreeMap.set(storedRun.id, runTree);\n      }\n    } else {\n      this.runMap.set(storedRun.id, storedRun);\n    }\n    return storedRun;\n  }\n\n  protected async _endTrace(run: Run): Promise<void> {\n    const parentRun =\n      run.parent_run_id !== undefined && this.getRunById(run.parent_run_id);\n    if (parentRun) {\n      parentRun.child_execution_order = Math.max(\n        parentRun.child_execution_order,\n        run.child_execution_order\n      );\n    } else {\n      await this.persistRun(run);\n    }\n    await this.onRunUpdate?.(run);\n    if (this.usesRunTreeMap) {\n      this.runTreeMap.delete(run.id);\n    } else {\n      this.runMap.delete(run.id);\n    }\n  }\n\n  protected _getExecutionOrder(parentRunId: string | undefined): number {\n    const parentRun = parentRunId !== undefined && this.getRunById(parentRunId);\n    // If a run has no parent then execution order is 1\n    if (!parentRun) {\n      return 1;\n    }\n\n    return parentRun.child_execution_order + 1;\n  }\n\n  /**\n   * Create and add a run to the run map for LLM start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata\n      ? { ...extraParams, metadata }\n      : extraParams;\n    const run: Run = {\n      id: runId,\n      name: name ?? llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { prompts },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams ?? {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForLLMStart(\n        llm,\n        prompts,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onLLMStart?.(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for chat model start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const finalExtraParams = metadata\n      ? { ...extraParams, metadata }\n      : extraParams;\n    const run: Run = {\n      id: runId,\n      name: name ?? llm.id[llm.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: llm,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { messages },\n      execution_order,\n      child_runs: [],\n      child_execution_order: execution_order,\n      run_type: \"llm\",\n      extra: finalExtraParams ?? {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: KVMap,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForChatModelStart(\n        llm,\n        messages,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onLLMStart?.(run);\n    return run;\n  }\n\n  async handleLLMEnd(\n    output: LLMResult,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = output;\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    run.extra = { ...run.extra, ...extraParams };\n    await this.onLLMEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleLLMError(\n    error: unknown,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\"No LLM run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    run.extra = { ...run.extra, ...extraParams };\n    await this.onLLMError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for chain start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    runType?: string,\n    name?: string,\n    extra?: Record<string, unknown>\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? chain.id[chain.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: chain,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs,\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: runType ?? \"chain\",\n      child_runs: [],\n      extra: metadata ? { ...extra, metadata } : { ...extra },\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    runType?: string,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForChainStart(\n        chain,\n        inputs,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        runType,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onChainStart?.(run);\n    return run;\n  }\n\n  async handleChainEnd(\n    outputs: ChainValues,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.outputs = _coerceToDict(outputs, \"output\");\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    if (kwargs?.inputs !== undefined) {\n      run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n    }\n    await this.onChainEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleChainError(\n    error: unknown,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run) {\n      throw new Error(\"No chain run to end.\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    if (kwargs?.inputs !== undefined) {\n      run.inputs = _coerceToDict(kwargs.inputs, \"input\");\n    }\n    await this.onChainError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  /**\n   * Create and add a run to the run map for tool start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? tool.id[tool.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: tool,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { input },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"tool\",\n      child_runs: [],\n      extra: metadata ? { metadata } : {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForToolStart(\n        tool,\n        input,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onToolStart?.(run);\n    return run;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async handleToolEnd(output: any, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = { output };\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onToolEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleToolError(error: unknown, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"tool\") {\n      throw new Error(\"No tool run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onToolError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleAgentAction(action: AgentAction, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    const agentRun = run as AgentRun;\n    agentRun.actions = agentRun.actions || [];\n    agentRun.actions.push(action);\n    agentRun.events.push({\n      name: \"agent_action\",\n      time: new Date().toISOString(),\n      kwargs: { action },\n    });\n    await this.onAgentAction?.(run as AgentRun);\n  }\n\n  async handleAgentEnd(action: AgentFinish, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"agent_end\",\n      time: new Date().toISOString(),\n      kwargs: { action },\n    });\n    await this.onAgentEnd?.(run);\n  }\n\n  /**\n   * Create and add a run to the run map for retriever start events.\n   * This must sometimes be done synchronously to avoid race conditions\n   * when callbacks are backgrounded, so we expose it as a separate method here.\n   */\n  _createRunForRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ) {\n    const execution_order = this._getExecutionOrder(parentRunId);\n    const start_time = Date.now();\n    const run: Run = {\n      id: runId,\n      name: name ?? retriever.id[retriever.id.length - 1],\n      parent_run_id: parentRunId,\n      start_time,\n      serialized: retriever,\n      events: [\n        {\n          name: \"start\",\n          time: new Date(start_time).toISOString(),\n        },\n      ],\n      inputs: { query },\n      execution_order,\n      child_execution_order: execution_order,\n      run_type: \"retriever\",\n      child_runs: [],\n      extra: metadata ? { metadata } : {},\n      tags: tags || [],\n    };\n    return this._addRunToRunMap(run);\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: KVMap,\n    name?: string\n  ): Promise<Run> {\n    const run =\n      this.getRunById(runId) ??\n      this._createRunForRetrieverStart(\n        retriever,\n        query,\n        runId,\n        parentRunId,\n        tags,\n        metadata,\n        name\n      );\n    await this.onRunCreate?.(run);\n    await this.onRetrieverStart?.(run);\n    return run;\n  }\n\n  async handleRetrieverEnd(\n    documents: Document<Record<string, unknown>>[],\n    runId: string\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.outputs = { documents };\n    run.events.push({\n      name: \"end\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onRetrieverEnd?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleRetrieverError(error: unknown, runId: string): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"retriever\") {\n      throw new Error(\"No retriever run to end\");\n    }\n    run.end_time = Date.now();\n    run.error = this.stringifyError(error);\n    run.events.push({\n      name: \"error\",\n      time: new Date(run.end_time).toISOString(),\n    });\n    await this.onRetrieverError?.(run);\n    await this._endTrace(run);\n    return run;\n  }\n\n  async handleText(text: string, runId: string): Promise<void> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"chain\") {\n      return;\n    }\n    run.events.push({\n      name: \"text\",\n      time: new Date().toISOString(),\n      kwargs: { text },\n    });\n    await this.onText?.(run);\n  }\n\n  async handleLLMNewToken(\n    token: string,\n    idx: NewTokenIndices,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ): Promise<Run> {\n    const run = this.getRunById(runId);\n    if (!run || run?.run_type !== \"llm\") {\n      throw new Error(\n        `Invalid \"runId\" provided to \"handleLLMNewToken\" callback.`\n      );\n    }\n    run.events.push({\n      name: \"new_token\",\n      time: new Date().toISOString(),\n      kwargs: { token, idx, chunk: fields?.chunk },\n    });\n    await this.onLLMNewToken?.(run, token, { chunk: fields?.chunk });\n    return run;\n  }\n\n  // custom event handlers\n\n  onRunCreate?(run: Run): void | Promise<void>;\n\n  onRunUpdate?(run: Run): void | Promise<void>;\n\n  onLLMStart?(run: Run): void | Promise<void>;\n\n  onLLMEnd?(run: Run): void | Promise<void>;\n\n  onLLMError?(run: Run): void | Promise<void>;\n\n  onChainStart?(run: Run): void | Promise<void>;\n\n  onChainEnd?(run: Run): void | Promise<void>;\n\n  onChainError?(run: Run): void | Promise<void>;\n\n  onToolStart?(run: Run): void | Promise<void>;\n\n  onToolEnd?(run: Run): void | Promise<void>;\n\n  onToolError?(run: Run): void | Promise<void>;\n\n  onAgentAction?(run: Run): void | Promise<void>;\n\n  onAgentEnd?(run: Run): void | Promise<void>;\n\n  onRetrieverStart?(run: Run): void | Promise<void>;\n\n  onRetrieverEnd?(run: Run): void | Promise<void>;\n\n  onRetrieverError?(run: Run): void | Promise<void>;\n\n  onText?(run: Run): void | Promise<void>;\n\n  onLLMNewToken?(\n    run: Run,\n    token: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    kwargs?: { chunk: any }\n  ): void | Promise<void>;\n}\n"],"mappings":"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"}