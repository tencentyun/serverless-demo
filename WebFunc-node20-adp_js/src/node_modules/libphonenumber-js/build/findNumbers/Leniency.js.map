{"version":3,"file":"Leniency.js","names":["_parseDigits","_interopRequireDefault","require","_matchPhoneNumberStringAgainstPhoneNumber","_metadata2","_getCountryByCallingCode","_format","_util","e","__esModule","_createForOfIteratorHelperLoose","r","t","Symbol","iterator","call","next","bind","Array","isArray","_unsupportedIterableToArray","length","o","done","value","TypeError","a","_arrayLikeToArray","toString","slice","constructor","name","from","test","n","_default","exports","POSSIBLE","phoneNumber","_ref","candidate","metadata","VALID","_ref2","defaultCountry","isValid","containsOnlyValidXChars","STRICT_GROUPING","_ref3","regExpCache","containsMoreThanOneSlashInNationalNumber","isNationalPrefixPresentIfRequired","checkNumberGroupingIsValid","allNumberGroupsRemainGrouped","EXACT_GROUPING","_ref4","allNumberGroupsAreExactlyPresent","index","charAtIndex","charAt","charAtNextIndex","matchPhoneNumberStringAgainstPhoneNumber","substring","ext","parseDigits","_ref5","_metadata","__countryCallingCodeSource","Metadata","selectNumberingPlan","countryCallingCode","phoneNumberRegion","country","getCountryByCallingCode","nationalNumber","format","chooseFormatForNumber","numberingPlan","formats","nationalPrefixFormattingRule","nationalPrefixIsOptionalWhenFormattingInNationalFormat","usesNationalPrefix","Boolean","nationalPrefix","firstSlashInBodyIndex","indexOf","secondSlashInBodyIndex","candidateHasCountryCode","number","checkGroups","Error","normalizedCandidate","normalizeDigits","formattedNumberGroups","getNationalNumberGroups","alternateFormats","MetadataManager","getAlternateFormatsForCountry","getCountryCode","nationalSignificantNumber","util","getNationalSignificantNumber","_iterator","numberFormats","_step","alternateFormat","leadingDigitsPatterns","leadingDigitsRegExp","getPatternForRegExp","formattingPattern","formatNsnUsingPattern","split","rfc3966Format","formatNumber","endIndex","startIndex","candidateGroups","NON_DIGITS_PATTERN","candidateNumberGroupIndex","hasExtension","contains","formattedNumberGroupIndex","endsWith","fromIndex","getCountryCodeSource","CountryCodeSource","FROM_DEFAULT_COUNTRY","countryCode","String","i","region","getRegionCodeForCountryCode","getNddPrefixForRegion","Character","isDigit","startsWith","getExtension"],"sources":["../../source/findNumbers/Leniency.js"],"sourcesContent":["import parseDigits from '../helpers/parseDigits.js'\r\nimport matchPhoneNumberStringAgainstPhoneNumber from './matchPhoneNumberStringAgainstPhoneNumber.js'\r\nimport Metadata from '../metadata.js'\r\nimport getCountryByCallingCode from '../helpers/getCountryByCallingCode.js'\r\nimport { chooseFormatForNumber } from '../format.js'\r\n\r\nimport {\r\n\tstartsWith,\r\n\tendsWith\r\n} from './util.js'\r\n\r\n/**\r\n * Leniency when finding potential phone numbers in text segments\r\n * The levels here are ordered in increasing strictness.\r\n */\r\nexport default\r\n{\r\n\t/**\r\n\t * Phone numbers accepted are \"possible\", but not necessarily \"valid\".\r\n\t */\r\n\tPOSSIBLE(phoneNumber, { candidate, metadata })\r\n\t{\r\n\t\treturn true\r\n\t},\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"possible\" and \"valid\".\r\n\t * Numbers written in national format must have their national-prefix\r\n\t * present if it is usually written for a number of this type.\r\n\t */\r\n\tVALID(phoneNumber, { candidate, defaultCountry, metadata })\r\n\t{\r\n\t\tif (\r\n\t\t\t!phoneNumber.isValid() ||\r\n\t\t\t!containsOnlyValidXChars(phoneNumber, candidate, metadata)\r\n\t\t)\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\t// Skipped for simplicity.\r\n\t\t// return isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata })\r\n\t\treturn true\r\n\t},\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"valid\" and\r\n\t * are grouped in a possible way for this locale. For example, a US number written as\r\n\t * \"65 02 53 00 00\" and \"650253 0000\" are not accepted at this leniency level, whereas\r\n\t * \"650 253 0000\", \"650 2530000\" or \"6502530000\" are.\r\n\t * Numbers with more than one '/' symbol in the national significant number\r\n\t * are also dropped at this level.\r\n\t *\r\n\t * Warning: This level might result in lower coverage especially for regions outside of\r\n\t * country code \"+1\". If you are not sure about which level to use,\r\n\t * email the discussion group libphonenumber-discuss@googlegroups.com.\r\n\t */\r\n\tSTRICT_GROUPING(phoneNumber, { candidate, defaultCountry, metadata, regExpCache })\r\n\t{\r\n\t\tif (\r\n\t\t\t!phoneNumber.isValid() ||\r\n\t\t\t!containsOnlyValidXChars(phoneNumber, candidate, metadata) ||\r\n\t\t\tcontainsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) ||\r\n\t\t\t!isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata })\r\n\t\t)\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn checkNumberGroupingIsValid\r\n\t\t(\r\n\t\t\tphoneNumber,\r\n\t\t\tcandidate,\r\n\t\t\tmetadata,\r\n\t\t\tallNumberGroupsRemainGrouped,\r\n\t\t\tregExpCache\r\n\t\t)\r\n\t},\r\n\r\n\t/**\r\n\t * Phone numbers accepted are \"valid\" and are grouped in the same way\r\n\t * that we would have formatted it, or as a single block.\r\n\t * For example, a US number written as \"650 2530000\" is not accepted\r\n\t * at this leniency level, whereas \"650 253 0000\" or \"6502530000\" are.\r\n\t * Numbers with more than one '/' symbol are also dropped at this level.\r\n\t *\r\n\t * Warning: This level might result in lower coverage especially for regions outside of\r\n\t * country code \"+1\". If you are not sure about which level to use, email the discussion group\r\n\t * libphonenumber-discuss@googlegroups.com.\r\n\t */\r\n\tEXACT_GROUPING(phoneNumber, { candidate, defaultCountry, metadata, regExpCache })\r\n\t{\r\n\t\tif (\r\n\t\t\t!phoneNumber.isValid() ||\r\n\t\t\t!containsOnlyValidXChars(phoneNumber, candidate, metadata) ||\r\n\t\t\tcontainsMoreThanOneSlashInNationalNumber(phoneNumber, candidate) ||\r\n\t\t\t!isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata })\r\n\t\t)\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\r\n\t\treturn checkNumberGroupingIsValid\r\n\t\t(\r\n\t\t\tphoneNumber,\r\n\t\t\tcandidate,\r\n\t\t\tmetadata,\r\n\t\t\tallNumberGroupsAreExactlyPresent,\r\n\t\t\tregExpCache\r\n\t\t)\r\n\t}\r\n}\r\n\r\nfunction containsOnlyValidXChars(phoneNumber, candidate, metadata)\r\n{\r\n\t// The characters 'x' and 'X' can be (1) a carrier code, in which case they always precede the\r\n\t// national significant number or (2) an extension sign, in which case they always precede the\r\n\t// extension number. We assume a carrier code is more than 1 digit, so the first case has to\r\n\t// have more than 1 consecutive 'x' or 'X', whereas the second case can only have exactly 1 'x'\r\n\t// or 'X'. We ignore the character if it appears as the last character of the string.\r\n\tfor (let index = 0; index < candidate.length - 1; index++)\r\n\t{\r\n\t\tconst charAtIndex = candidate.charAt(index)\r\n\r\n\t\tif (charAtIndex === 'x' || charAtIndex === 'X')\r\n\t\t{\r\n\t\t\tconst charAtNextIndex = candidate.charAt(index + 1)\r\n\r\n\t\t\tif (charAtNextIndex === 'x' || charAtNextIndex === 'X')\r\n\t\t\t{\r\n\t\t\t\t// This is the carrier code case, in which the 'X's always precede the national\r\n\t\t\t\t// significant number.\r\n\t\t\t\tindex++\r\n\t\t\t\tif (matchPhoneNumberStringAgainstPhoneNumber(candidate.substring(index), phoneNumber, metadata) !== 'NSN_MATCH')\r\n\t\t\t\t{\r\n\t\t\t\t\treturn false\r\n\t\t\t\t}\r\n\t\t\t\t// This is the extension sign case, in which the 'x' or 'X' should always precede the\r\n\t\t\t\t// extension number.\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tconst ext = parseDigits(candidate.substring(index))\r\n\t\t\t\tif (ext) {\r\n\t\t\t\t\tif (phoneNumber.ext !== ext)  {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (phoneNumber.ext) {\r\n\t\t\t\t\t\treturn false\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunction isNationalPrefixPresentIfRequired(phoneNumber, { defaultCountry, metadata: _metadata })\r\n{\r\n\t// First, check how we deduced the country code. If it was written in international format, then\r\n\t// the national prefix is not required.\r\n\tif (phoneNumber.__countryCallingCodeSource !== 'FROM_DEFAULT_COUNTRY')\r\n\t{\r\n\t\treturn true\r\n\t}\r\n\r\n\tconst metadata = new Metadata(_metadata)\r\n\tmetadata.selectNumberingPlan(phoneNumber.countryCallingCode)\r\n\r\n\tconst phoneNumberRegion = phoneNumber.country || getCountryByCallingCode(phoneNumber.countryCallingCode, {\r\n\t\tnationalNumber: phoneNumber.nationalNumber,\r\n\t\tmetadata\r\n\t})\r\n\r\n\t// Check if a national prefix should be present when formatting this number.\r\n\tconst nationalNumber = phoneNumber.nationalNumber\r\n\tconst format = chooseFormatForNumber(metadata.numberingPlan.formats(), nationalNumber)\r\n\r\n\t// To do this, we check that a national prefix formatting rule was present\r\n\t// and that it wasn't just the first-group symbol ($1) with punctuation.\r\n\tif (format.nationalPrefixFormattingRule())\r\n\t{\r\n\t\tif (metadata.numberingPlan.nationalPrefixIsOptionalWhenFormattingInNationalFormat())\r\n\t\t{\r\n\t\t\t// The national-prefix is optional in these cases, so we don't need to check if it was present.\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\tif (!format.usesNationalPrefix())\r\n\t\t{\r\n\t\t\t// National Prefix not needed for this number.\r\n\t\t\treturn true\r\n\t\t}\r\n\r\n\t\treturn Boolean(phoneNumber.nationalPrefix)\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nexport function containsMoreThanOneSlashInNationalNumber(phoneNumber, candidate)\r\n{\r\n\tconst firstSlashInBodyIndex = candidate.indexOf('/')\r\n\tif (firstSlashInBodyIndex < 0)\r\n\t{\r\n\t\t// No slashes, this is okay.\r\n\t\treturn false\r\n\t}\r\n\r\n\t// Now look for a second one.\r\n\tconst secondSlashInBodyIndex = candidate.indexOf('/', firstSlashInBodyIndex + 1)\r\n\tif (secondSlashInBodyIndex < 0)\r\n\t{\r\n\t\t// Only one slash, this is okay.\r\n\t\treturn false\r\n\t}\r\n\r\n\t// If the first slash is after the country calling code, this is permitted.\r\n\tconst candidateHasCountryCode =\r\n\t\t\tphoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITH_PLUS_SIGN' ||\r\n\t\t\tphoneNumber.__countryCallingCodeSource === 'FROM_NUMBER_WITHOUT_PLUS_SIGN'\r\n\r\n\tif (candidateHasCountryCode && parseDigits(candidate.substring(0, firstSlashInBodyIndex)) === phoneNumber.countryCallingCode)\r\n\t{\r\n\t\t// Any more slashes and this is illegal.\r\n\t\treturn candidate.slice(secondSlashInBodyIndex + 1).indexOf('/') >= 0\r\n\t}\r\n\r\n\treturn true\r\n}\r\n\r\nfunction checkNumberGroupingIsValid(\r\n\tnumber,\r\n\tcandidate,\r\n\tmetadata,\r\n\tcheckGroups,\r\n\tregExpCache\r\n) {\r\n\tthrow new Error('This part of code hasn\\'t been ported')\r\n\r\n\tconst normalizedCandidate = normalizeDigits(candidate, true /* keep non-digits */)\r\n\tlet formattedNumberGroups = getNationalNumberGroups(metadata, number, null)\r\n\tif (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\r\n\t\treturn true\r\n\t}\r\n\r\n\t// If this didn't pass, see if there are any alternate formats that match, and try them instead.\r\n\tconst alternateFormats = MetadataManager.getAlternateFormatsForCountry(number.getCountryCode())\r\n\tconst nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n\r\n\tif (alternateFormats) {\r\n\t\tfor (const alternateFormat of alternateFormats.numberFormats()) {\r\n\t\t\tif (alternateFormat.leadingDigitsPatterns().length > 0) {\r\n\t\t\t\t// There is only one leading digits pattern for alternate formats.\r\n\t\t\t\tconst leadingDigitsRegExp = regExpCache.getPatternForRegExp('^' + alternateFormat.leadingDigitsPatterns()[0])\r\n\t\t\t\tif (!leadingDigitsRegExp.test(nationalSignificantNumber)) {\r\n\t\t\t\t\t// Leading digits don't match; try another one.\r\n\t\t\t\t\tcontinue\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tformattedNumberGroups = getNationalNumberGroups(metadata, number, alternateFormat)\r\n\t\t\tif (checkGroups(metadata, number, normalizedCandidate, formattedNumberGroups)) {\r\n\t\t\t\treturn true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\treturn false\r\n}\r\n\r\n/**\r\n * Helper method to get the national-number part of a number, formatted without any national\r\n * prefix, and return it as a set of digit blocks that would be formatted together following\r\n * standard formatting rules.\r\n */\r\nfunction getNationalNumberGroups(\r\n\tmetadata,\r\n\tnumber,\r\n\tformattingPattern\r\n) {\r\n\tthrow new Error('This part of code hasn\\'t been ported')\r\n\r\n\tif (formattingPattern) {\r\n\t\t// We format the NSN only, and split that according to the separator.\r\n\t\tconst nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n\t\treturn util.formatNsnUsingPattern(nationalSignificantNumber,\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tformattingPattern, 'RFC3966', metadata).split('-')\r\n\t}\r\n\r\n\t// This will be in the format +CC-DG1-DG2-DGX;ext=EXT where DG1..DGX represents groups of digits.\r\n\tconst rfc3966Format = formatNumber(number, 'RFC3966', metadata)\r\n\r\n\t// We remove the extension part from the formatted string before splitting it into different\r\n\t// groups.\r\n\tlet endIndex = rfc3966Format.indexOf(';')\r\n\tif (endIndex < 0) {\r\n\t\tendIndex = rfc3966Format.length\r\n\t}\r\n\r\n\t// The country-code will have a '-' following it.\r\n\tconst startIndex = rfc3966Format.indexOf('-') + 1\r\n\treturn rfc3966Format.slice(startIndex, endIndex).split('-')\r\n}\r\n\r\nfunction allNumberGroupsAreExactlyPresent\r\n(\r\n\tmetadata,\r\n\tnumber,\r\n\tnormalizedCandidate,\r\n\tformattedNumberGroups\r\n)\r\n{\r\n\tthrow new Error('This part of code hasn\\'t been ported')\r\n\r\n\tconst candidateGroups = normalizedCandidate.split(NON_DIGITS_PATTERN)\r\n\r\n\t// Set this to the last group, skipping it if the number has an extension.\r\n\tlet candidateNumberGroupIndex =\r\n\t\t\tnumber.hasExtension() ? candidateGroups.length - 2 : candidateGroups.length - 1\r\n\r\n\t// First we check if the national significant number is formatted as a block.\r\n\t// We use contains and not equals, since the national significant number may be present with\r\n\t// a prefix such as a national number prefix, or the country code itself.\r\n\tif (candidateGroups.length == 1\r\n\t\t\t|| candidateGroups[candidateNumberGroupIndex].contains(\r\n\t\t\t\t\tutil.getNationalSignificantNumber(number)))\r\n\t{\r\n\t\treturn true\r\n\t}\r\n\r\n\t// Starting from the end, go through in reverse, excluding the first group, and check the\r\n\t// candidate and number groups are the same.\r\n\tlet formattedNumberGroupIndex = (formattedNumberGroups.length - 1)\r\n\twhile (formattedNumberGroupIndex > 0 && candidateNumberGroupIndex >= 0)\r\n\t{\r\n\t\tif (candidateGroups[candidateNumberGroupIndex] !== formattedNumberGroups[formattedNumberGroupIndex])\r\n\t\t{\r\n\t\t\treturn false\r\n\t\t}\r\n\t\tformattedNumberGroupIndex--\r\n\t\tcandidateNumberGroupIndex--\r\n\t}\r\n\r\n\t// Now check the first group. There may be a national prefix at the start, so we only check\r\n\t// that the candidate group ends with the formatted number group.\r\n\treturn (candidateNumberGroupIndex >= 0\r\n\t\t\t&& endsWith(candidateGroups[candidateNumberGroupIndex], formattedNumberGroups[0]))\r\n}\r\n\r\n\r\nfunction allNumberGroupsRemainGrouped\r\n(\r\n\tmetadata,\r\n\tnumber,\r\n\tnormalizedCandidate,\r\n\tformattedNumberGroups\r\n)\r\n{\r\n\tthrow new Error('This part of code hasn\\'t been ported')\r\n\r\n\tlet fromIndex = 0\r\n\tif (number.getCountryCodeSource() !== CountryCodeSource.FROM_DEFAULT_COUNTRY)\r\n\t{\r\n\t\t// First skip the country code if the normalized candidate contained it.\r\n\t\tconst countryCode = String(number.getCountryCode())\r\n\t\tfromIndex = normalizedCandidate.indexOf(countryCode) + countryCode.length()\r\n\t}\r\n\r\n\t// Check each group of consecutive digits are not broken into separate groupings in the\r\n\t// {@code normalizedCandidate} string.\r\n\tfor (let i = 0; i < formattedNumberGroups.length; i++)\r\n\t{\r\n\t\t// Fails if the substring of {@code normalizedCandidate} starting from {@code fromIndex}\r\n\t\t// doesn't contain the consecutive digits in formattedNumberGroups[i].\r\n\t\tfromIndex = normalizedCandidate.indexOf(formattedNumberGroups[i], fromIndex)\r\n\t\tif (fromIndex < 0) {\r\n\t\t\treturn false\r\n\t\t}\r\n\t\t// Moves {@code fromIndex} forward.\r\n\t\tfromIndex += formattedNumberGroups[i].length()\r\n\t\tif (i == 0 && fromIndex < normalizedCandidate.length())\r\n\t\t{\r\n\t\t\t// We are at the position right after the NDC. We get the region used for formatting\r\n\t\t\t// information based on the country code in the phone number, rather than the number itself,\r\n\t\t\t// as we do not need to distinguish between different countries with the same country\r\n\t\t\t// calling code and this is faster.\r\n\t\t\tconst region = util.getRegionCodeForCountryCode(number.getCountryCode())\r\n\t\t\tif (util.getNddPrefixForRegion(region, true) != null\r\n\t\t\t\t\t&& Character.isDigit(normalizedCandidate.charAt(fromIndex))) {\r\n\t\t\t\t// This means there is no formatting symbol after the NDC. In this case, we only\r\n\t\t\t\t// accept the number if there is no formatting symbol at all in the number, except\r\n\t\t\t\t// for extensions. This is only important for countries with national prefixes.\r\n\t\t\t\tconst nationalSignificantNumber = util.getNationalSignificantNumber(number)\r\n\t\t\t\treturn startsWith\r\n\t\t\t\t(\r\n\t\t\t\t\tnormalizedCandidate.slice(fromIndex - formattedNumberGroups[i].length),\r\n\t\t\t\t\t nationalSignificantNumber\r\n\t\t\t\t)\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t// The check here makes sure that we haven't mistakenly already used the extension to\r\n\t// match the last group of the subscriber number. Note the extension cannot have\r\n\t// formatting in-between digits.\r\n\treturn normalizedCandidate.slice(fromIndex).contains(number.getExtension())\r\n}"],"mappings":"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","ignoreList":[]}