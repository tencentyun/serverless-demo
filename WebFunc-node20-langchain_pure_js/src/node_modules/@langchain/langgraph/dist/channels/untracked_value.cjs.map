{"version":3,"file":"untracked_value.cjs","names":["BaseChannel","InvalidUpdateError","EmptyChannelError"],"sources":["../../src/channels/untracked_value.ts"],"sourcesContent":["import { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\n// Sentinel value for missing/unset\nconst MISSING = Symbol.for(\"langgraph.channel.missing\");\n\n/**\n * Stores the last value received, never checkpointed.\n *\n * This channel stores values during graph execution but does NOT persist\n * the value to checkpoints. On restoration from a checkpoint, the value\n * will be reset to empty (or the initial value if provided).\n *\n * Useful for transient state like:\n * - Database connections\n * - Temporary caches\n * - Runtime-only configuration\n *\n * @internal\n */\nexport class UntrackedValueChannel<Value> extends BaseChannel<\n  Value,\n  Value,\n  undefined\n> {\n  lc_graph_name = \"UntrackedValue\";\n\n  /**\n   * If true, throws an error when multiple values are received in a single step.\n   * If false, stores the last value received.\n   */\n  guard: boolean;\n\n  /**\n   * The current value. MISSING sentinel indicates no value has been set.\n   */\n  private _value: Value | typeof MISSING = MISSING;\n\n  /**\n   * Optional factory function for the initial value.\n   */\n  private initialValueFactory?: () => Value;\n\n  constructor(options?: {\n    guard?: boolean;\n    initialValueFactory?: () => Value;\n  }) {\n    super();\n    this.guard = options?.guard ?? true;\n    this.initialValueFactory = options?.initialValueFactory;\n    if (this.initialValueFactory) {\n      this._value = this.initialValueFactory();\n    }\n  }\n\n  /**\n   * Return a new channel, ignoring the checkpoint since we don't persist.\n   * The initial value (if any) is restored.\n   */\n  fromCheckpoint(_checkpoint?: undefined): this {\n    const empty = new UntrackedValueChannel<Value>({\n      guard: this.guard,\n      initialValueFactory: this.initialValueFactory,\n    });\n    return empty as this;\n  }\n\n  /**\n   * Update the channel with the given values.\n   * If guard is true, throws if more than one value is received.\n   */\n  update(values: Value[]): boolean {\n    if (values.length === 0) {\n      return false;\n    }\n\n    if (values.length !== 1 && this.guard) {\n      throw new InvalidUpdateError(\n        \"UntrackedValue(guard=true) can receive only one value per step. \" +\n          \"Use guard=false if you want to store any one of multiple values.\",\n        { lc_error_code: \"INVALID_CONCURRENT_GRAPH_UPDATE\" }\n      );\n    }\n\n    this._value = values[values.length - 1];\n    return true;\n  }\n\n  /**\n   * Get the current value.\n   * @throws EmptyChannelError if no value has been set.\n   */\n  get(): Value {\n    if (this._value === MISSING) {\n      throw new EmptyChannelError();\n    }\n    return this._value;\n  }\n\n  /**\n   * Always returns undefined - untracked values are never checkpointed.\n   */\n  checkpoint(): undefined {\n    return undefined;\n  }\n\n  /**\n   * Return true if a value has been set.\n   */\n  isAvailable(): boolean {\n    return this._value !== MISSING;\n  }\n}\n"],"mappings":";;;;AAIA,MAAM,UAAU,OAAO,IAAI,4BAA4B;;;;;;;;;;;;;;;AAgBvD,IAAa,wBAAb,MAAa,8BAAqCA,yBAIhD;CACA,gBAAgB;;;;;CAMhB;;;;CAKA,AAAQ,SAAiC;;;;CAKzC,AAAQ;CAER,YAAY,SAGT;AACD,SAAO;AACP,OAAK,QAAQ,SAAS,SAAS;AAC/B,OAAK,sBAAsB,SAAS;AACpC,MAAI,KAAK,oBACP,MAAK,SAAS,KAAK,qBAAqB;;;;;;CAQ5C,eAAe,aAA+B;AAK5C,SAJc,IAAI,sBAA6B;GAC7C,OAAO,KAAK;GACZ,qBAAqB,KAAK;GAC3B,CAAC;;;;;;CAQJ,OAAO,QAA0B;AAC/B,MAAI,OAAO,WAAW,EACpB,QAAO;AAGT,MAAI,OAAO,WAAW,KAAK,KAAK,MAC9B,OAAM,IAAIC,kCACR,oIAEA,EAAE,eAAe,mCAAmC,CACrD;AAGH,OAAK,SAAS,OAAO,OAAO,SAAS;AACrC,SAAO;;;;;;CAOT,MAAa;AACX,MAAI,KAAK,WAAW,QAClB,OAAM,IAAIC,kCAAmB;AAE/B,SAAO,KAAK;;;;;CAMd,aAAwB;;;;CAOxB,cAAuB;AACrB,SAAO,KAAK,WAAW"}