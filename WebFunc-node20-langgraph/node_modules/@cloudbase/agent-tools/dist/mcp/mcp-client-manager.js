"use strict";
/**
 * MCP Client Manager
 *
 * Manages connections to external MCP servers and provides tools from those servers
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MCPClientManager = void 0;
const index_js_1 = require("@modelcontextprotocol/sdk/client/index.js");
const stdio_js_1 = require("@modelcontextprotocol/sdk/client/stdio.js");
const sse_js_1 = require("@modelcontextprotocol/sdk/client/sse.js");
const streamableHttp_js_1 = require("@modelcontextprotocol/sdk/client/streamableHttp.js");
const client_tool_1 = require("./client-tool");
const types_1 = require("./types");
const agkit_mcp_server_1 = require("./agkit-mcp-server");
/**
 * MCP Client Manager - manages connections to external MCP servers
 */
class MCPClientManager {
    constructor() {
        this.clients = new Map();
        this.transports = new Map();
        this.connections = new Map();
        this.availableTools = new Map();
        this.eventListeners = new Set();
        // Enhanced connection management
        this.connectionOptions = new Map();
        this.serverStatus = new Map();
        this.reconnectTimers = new Map();
        this.heartbeatTimers = new Map();
    }
    /**
     * Add a new MCP server connection
     */
    async addServer(serverId, config, connectionOptions) {
        if (this.clients.has(serverId)) {
            throw new Error(`Server '${serverId}' is already registered`);
        }
        // Set up connection options with defaults
        const options = {
            autoReconnect: true,
            reconnectDelay: 5000,
            maxReconnectAttempts: 3,
            ...connectionOptions,
        };
        // Initialize server status
        const status = {
            connected: false,
            toolCount: 0,
            resourceCount: 0,
            promptCount: 0,
            errors: [],
            lastActivity: new Date(),
            reconnectAttempts: 0,
        };
        let client;
        // If a pre-connected client is provided, use it directly
        if (config.client) {
            client = config.client;
            status.connected = true; // Assume pre-connected client is already connected
        }
        else {
            // Validate that transport config is provided
            if (!config.transport) {
                throw new Error(`Either 'client' or 'transport' must be provided in config`);
            }
            // Create new client
            client = new index_js_1.Client({
                name: config.name || "ag-kit-mcp-client",
                version: config.version || "1.0.0",
            }, {
                capabilities: {},
            });
        }
        this.clients.set(serverId, client);
        this.connections.set(serverId, config);
        this.connectionOptions.set(serverId, options);
        this.serverStatus.set(serverId, status);
        try {
            // Only connect if we created a new client (not pre-connected)
            if (!config.client) {
                await this.connectServer(serverId);
            }
            await this.loadServerTools(serverId);
            // Set up heartbeat if configured
            if (options.heartbeatInterval) {
                this.setupHeartbeat(serverId);
            }
        }
        catch (error) {
            // Clean up on failure
            this.cleanupServer(serverId);
            throw error;
        }
    }
    /**
     * Connect to a specific server
     */
    async connectServer(serverId) {
        const client = this.clients.get(serverId);
        const config = this.connections.get(serverId);
        const status = this.serverStatus.get(serverId);
        if (!client || !config || !status) {
            throw new Error(`Server '${serverId}' not found`);
        }
        // Validate transport config exists (should not be called for pre-connected clients)
        if (!config.transport) {
            throw new Error(`Transport config is required for server '${serverId}'`);
        }
        // Check if already connected
        if (status.connected && this.transports.has(serverId)) {
            console.log(`[MCPClientManager] Server '${serverId}' is already connected`);
            return;
        }
        // Create transport based on configuration
        const transport = await this.createTransport(config.transport);
        // Connect with timeout
        const connectPromise = client.connect(transport);
        const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error("Connection timeout")), config.transport.timeout || 10000);
        });
        await Promise.race([connectPromise, timeoutPromise]);
        this.transports.set(serverId, transport);
        // Update status
        status.connected = true;
        status.lastActivity = new Date();
        status.reconnectAttempts = 0;
        this.emit({
            type: "connected",
            clientName: serverId,
        });
    }
    /**
     * Create transport instance based on configuration
     */
    async createTransport(transportConfig) {
        const transportType = (0, types_1.detectTransportType)(transportConfig);
        switch (transportType) {
            case "stdio":
                if (!transportConfig.command) {
                    throw new Error("Command is required for stdio transport");
                }
                return new stdio_js_1.StdioClientTransport({
                    command: transportConfig.command,
                    args: transportConfig.args || [],
                });
            case "sse": {
                const { type, url, timeout, ...restOptions } = transportConfig;
                if (!url) {
                    throw new Error("URL is required for SSE transport");
                }
                return new sse_js_1.SSEClientTransport(new URL(url), restOptions);
            }
            case "streamableHttp": {
                const { type, url, timeout, ...restOptions } = transportConfig;
                if (!url) {
                    throw new Error("URL is required for StreamableHTTP transport");
                }
                return new streamableHttp_js_1.StreamableHTTPClientTransport(new URL(url), restOptions);
            }
            case "memory":
                if (!transportConfig.memoryId) {
                    throw new Error("Memory ID is required for InMemory transport");
                }
                // Import the memory transport registry from agkit-mcp-server
                return agkit_mcp_server_1.memoryTransportRegistry.getClientTransport(transportConfig.memoryId);
            case "custom":
                if (!transportConfig.transport) {
                    throw new Error("Transport instance is required for custom transport");
                }
                return transportConfig.transport;
            default:
                throw new Error(`Transport type '${transportType}' is not supported. ` +
                    `Supported types: stdio, sse, streamableHttp, memory, custom`);
        }
    }
    /**
     * Load tools from a specific server
     */
    async loadServerTools(serverId) {
        const client = this.clients.get(serverId);
        if (!client) {
            throw new Error(`Server '${serverId}' not found`);
        }
        try {
            const response = await client.listTools();
            // Type assertion for MCP SDK response
            const listResponse = response;
            this.availableTools.set(serverId, listResponse.tools || []);
            (listResponse.tools || []).forEach((tool) => {
                this.emit({
                    type: "tool_discovered",
                    tool: {
                        name: tool.name,
                        description: tool.description || "",
                        inputSchema: tool.inputSchema,
                    },
                });
            });
        }
        catch (error) {
            this.emit({
                type: "error",
                error: error instanceof Error ? error : new Error(String(error)),
                context: `load_tools:${serverId}`,
            });
            throw error;
        }
    }
    /**
     * Get all available tools from all connected servers
     */
    getAllTools(serverId) {
        const allTools = [];
        for (const [_serverId, tools] of serverId
            ? new Map([[serverId, this.getServerTools(serverId)]]).entries()
            : this.availableTools.entries()) {
            for (const tool of tools) {
                allTools.push({ serverId: _serverId, tool });
            }
        }
        return allTools;
    }
    /**
     * Get tools from a specific server
     */
    getServerTools(serverId) {
        return this.availableTools.get(serverId) || [];
    }
    /**
     * Create MCPClientTool instances for all available tools
     */
    createClientTools(serverId) {
        const clientTools = [];
        for (const { serverId: _serverId, tool } of this.getAllTools(serverId)) {
            // Use createClientTool to avoid code duplication
            const clientTool = this.createClientTool(_serverId, tool.name, `${_serverId}:${tool.name}` // Use server:tool format as AG-Kit tool name
            );
            clientTools.push(clientTool);
        }
        return clientTools;
    }
    /**
     * Create a specific client tool
     */
    createClientTool(serverId, toolName, agKitToolName) {
        const tools = this.getServerTools(serverId);
        const tool = tools.find((t) => t.name === toolName);
        if (!tool) {
            throw new Error(`Tool '${toolName}' not found on server '${serverId}'`);
        }
        const config = this.connections.get(serverId);
        const toolMetadata = {
            name: tool.name,
            description: tool.description || "",
            inputSchema: tool.inputSchema,
        };
        // Create a wrapper that uses this manager's client
        const client = new Proxy(this.clients.get(serverId), {
            get: (_, prop) => {
                if (prop === "callTool") {
                    return async (params) => {
                        return this.callTool(serverId, params.name, params.arguments);
                    };
                }
                return Reflect.get(_, prop);
            },
        });
        return new client_tool_1.MCPClientTool(client, toolMetadata, {
            name: agKitToolName || `${serverId}:${toolName}`,
        }, { includeMetadata: true });
    }
    /**
     * Call a tool on a specific server
     */
    async callTool(serverId, toolName, args) {
        const client = this.clients.get(serverId);
        if (!client) {
            throw new Error(`Server '${serverId}' not connected`);
        }
        try {
            this.emit({
                type: "tool_called",
                toolName: `${serverId}:${toolName}`,
                arguments: args,
            });
            const callResponse = await client.callTool({
                name: toolName,
                arguments: args,
            });
            this.emit({
                type: "tool_result",
                toolName: `${serverId}:${toolName}`,
                result: callResponse,
            });
            return callResponse;
        }
        catch (error) {
            this.emit({
                type: "error",
                error: error instanceof Error ? error : new Error(String(error)),
                context: `tool_call:${serverId}:${toolName}`,
            });
            throw error;
        }
    }
    /**
     * Disconnect from a specific server
     */
    async disconnectServer(serverId) {
        const client = this.clients.get(serverId);
        const transport = this.transports.get(serverId);
        if (client && transport) {
            try {
                await client.close();
                this.emit({
                    type: "disconnected",
                    clientName: serverId,
                });
            }
            catch (error) {
                this.emit({
                    type: "error",
                    error: error instanceof Error ? error : new Error(String(error)),
                    context: `disconnect:${serverId}`,
                });
                throw error;
            }
        }
        this.cleanupServer(serverId);
    }
    /**
     * Disconnect from all servers
     */
    async disconnectAll() {
        const serverIds = Array.from(this.clients.keys());
        for (const serverId of serverIds) {
            try {
                await this.disconnectServer(serverId);
            }
            catch (error) {
                console.error(`Error disconnecting from server '${serverId}':`, error);
            }
        }
    }
    /**
     * Refresh connections and reload tools
     */
    async refresh() {
        const serverIds = Array.from(this.connections.keys());
        for (const serverId of serverIds) {
            try {
                const config = this.connections.get(serverId);
                if (!config)
                    continue;
                // Skip refresh for pre-connected clients
                if (config.client) {
                    console.warn(`Skipping refresh for server '${serverId}' - it uses a pre-connected client. ` +
                        `Please handle refresh externally.`);
                    continue;
                }
                await this.disconnectServer(serverId);
                await this.addServer(serverId, config, this.connectionOptions.get(serverId));
            }
            catch (error) {
                console.error(`Error refreshing server '${serverId}':`, error);
            }
        }
    }
    /**
     * Check if a server is connected
     */
    isServerConnected(serverId) {
        const status = this.serverStatus.get(serverId);
        return status?.connected === true && this.transports.has(serverId);
    }
    /**
     * Get connection status for all servers
     */
    getConnectionStatus() {
        const status = {};
        for (const serverId of this.clients.keys()) {
            status[serverId] = this.isServerConnected(serverId);
        }
        return status;
    }
    /**
     * Add event listener
     */
    addEventListener(listener) {
        this.eventListeners.add(listener);
    }
    /**
     * Remove event listener
     */
    removeEventListener(listener) {
        return this.eventListeners.delete(listener);
    }
    /**
     * Emit event to all listeners
     */
    emit(event) {
        this.eventListeners.forEach((listener) => {
            try {
                listener(event);
            }
            catch (error) {
                console.error("[MCPClientManager] Error in event listener:", error);
            }
        });
    }
    /**
     * Get statistics
     */
    getStats() {
        return {
            connectedServers: this.clients.size,
            totalTools: Array.from(this.availableTools.values()).reduce((sum, tools) => sum + tools.length, 0),
            serverStatus: this.getConnectionStatus(),
        };
    }
    /**
     * Set up heartbeat to keep connection alive
     */
    setupHeartbeat(serverId) {
        const options = this.connectionOptions.get(serverId);
        if (!options?.heartbeatInterval)
            return;
        const config = this.connections.get(serverId);
        const heartbeatTimer = setInterval(async () => {
            const client = this.clients.get(serverId);
            const status = this.serverStatus.get(serverId);
            if (client && status?.connected) {
                try {
                    // Send ping to keep connection alive
                    await client.ping?.();
                    if (status) {
                        status.lastActivity = new Date();
                    }
                }
                catch (error) {
                    this.handleError(serverId, error instanceof Error ? error : new Error(String(error)), "heartbeat");
                    // Only auto-reconnect if we have transport config (not pre-connected client)
                    if (options.autoReconnect && config.transport) {
                        this.scheduleReconnect(serverId);
                    }
                }
            }
        }, options.heartbeatInterval);
        this.heartbeatTimers.set(serverId, heartbeatTimer);
    }
    /**
     * Schedule automatic reconnection
     */
    scheduleReconnect(serverId) {
        const options = this.connectionOptions.get(serverId);
        const status = this.serverStatus.get(serverId);
        const config = this.connections.get(serverId);
        if (!options?.autoReconnect || !status || !config)
            return;
        // Don't auto-reconnect pre-connected clients without callback
        if (config.client && !config.onReconnectNeeded) {
            this.emit({
                type: "error",
                error: new Error(`Cannot auto-reconnect server '${serverId}' - it uses a pre-connected client without onReconnectNeeded callback. ` +
                    `Please provide an onReconnectNeeded callback or handle reconnection externally.`),
                context: `auto_reconnect:${serverId}`,
            });
            return;
        }
        // Clear existing timer
        const existingTimer = this.reconnectTimers.get(serverId);
        if (existingTimer) {
            clearTimeout(existingTimer);
        }
        // Check if we've exceeded max attempts
        if (options.maxReconnectAttempts &&
            status.reconnectAttempts >= options.maxReconnectAttempts) {
            this.emit({
                type: "error",
                error: new Error(`Max reconnection attempts (${options.maxReconnectAttempts}) exceeded for server '${serverId}'`),
                context: `reconnect:${serverId}`,
            });
            return;
        }
        const reconnectTimer = setTimeout(async () => {
            try {
                status.reconnectAttempts = (status.reconnectAttempts || 0) + 1;
                await this.reconnectServer(serverId);
            }
            catch (error) {
                console.error(`Reconnection failed for server '${serverId}':`, error);
                // Schedule another reconnect attempt
                this.scheduleReconnect(serverId);
            }
        }, options.reconnectDelay || 5000);
        this.reconnectTimers.set(serverId, reconnectTimer);
    }
    /**
     * Manually reconnect to a specific server
     */
    async reconnectServer(serverId) {
        const config = this.connections.get(serverId);
        if (!config) {
            throw new Error(`Server '${serverId}' not found`);
        }
        // Clear existing timer
        const existingTimer = this.reconnectTimers.get(serverId);
        if (existingTimer) {
            clearTimeout(existingTimer);
            this.reconnectTimers.delete(serverId);
        }
        try {
            await this.disconnectServer(serverId);
            // Handle pre-connected client with reconnection callback
            if (config.client) {
                if (config.onReconnectNeeded) {
                    // Use the reconnection callback to get a new connected client
                    const newClient = await config.onReconnectNeeded(serverId, config);
                    const newConfig = { ...config, client: newClient };
                    await this.addServer(serverId, newConfig, this.connectionOptions.get(serverId));
                }
                else {
                    throw new Error(`Cannot reconnect server '${serverId}' - it uses a pre-connected client but no onReconnectNeeded callback is provided. ` +
                        `Please provide an onReconnectNeeded callback or handle reconnection externally.`);
                }
            }
            else if (config.transport) {
                // Standard reconnection using transport config
                await this.addServer(serverId, config, this.connectionOptions.get(serverId));
            }
            else {
                throw new Error(`Cannot reconnect server '${serverId}' - no transport configuration or reconnection callback available`);
            }
        }
        catch (error) {
            this.handleError(serverId, error instanceof Error ? error : new Error(String(error)), "reconnection");
            throw error;
        }
    }
    /**
     * Handle errors and update status
     */
    handleError(serverId, error, context) {
        const status = this.serverStatus.get(serverId);
        if (!status)
            return;
        status.errors.push({
            timestamp: new Date(),
            error,
            context,
        });
        // Keep only last 10 errors
        if (status.errors.length > 10) {
            status.errors = status.errors.slice(-10);
        }
        this.emit({
            type: "error",
            error,
            context: `${context}:${serverId}`,
        });
    }
    /**
     * Clean up server resources
     */
    cleanupServer(serverId) {
        // Clear timers
        const reconnectTimer = this.reconnectTimers.get(serverId);
        if (reconnectTimer) {
            clearTimeout(reconnectTimer);
            this.reconnectTimers.delete(serverId);
        }
        const heartbeatTimer = this.heartbeatTimers.get(serverId);
        if (heartbeatTimer) {
            clearInterval(heartbeatTimer);
            this.heartbeatTimers.delete(serverId);
        }
        // Remove from maps
        this.clients.delete(serverId);
        this.connections.delete(serverId);
        this.transports.delete(serverId);
        this.availableTools.delete(serverId);
        this.connectionOptions.delete(serverId);
        this.serverStatus.delete(serverId);
    }
    /**
     * Get server status
     */
    getServerStatus(serverId) {
        return this.serverStatus.get(serverId);
    }
    /**
     * Get all server statuses
     */
    getAllServerStatuses() {
        const statuses = {};
        for (const [serverId, status] of this.serverStatus.entries()) {
            statuses[serverId] = { ...status };
        }
        return statuses;
    }
}
exports.MCPClientManager = MCPClientManager;
//# sourceMappingURL=mcp-client-manager.js.map