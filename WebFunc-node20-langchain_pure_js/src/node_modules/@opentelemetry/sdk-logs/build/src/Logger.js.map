{"version":3,"file":"Logger.js","sourceRoot":"","sources":["../../src/Logger.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;AAGH,sDAAyD;AAEzD,4CAK4B;AAE5B,mDAAgD;AAIhD,MAAa,MAAM;IACD,oBAAoB,CAAuB;IACnD,YAAY,CAA4B;IAC/B,aAAa,CAAyB;IAEvD,YACE,oBAA0C,EAC1C,WAAsC;QAEtC,IAAI,CAAC,oBAAoB,GAAG,oBAAoB,CAAC;QACjD,IAAI,CAAC,YAAY,GAAG,WAAW,CAAC;QAChC,sDAAsD;QACtD,mEAAmE;QACnE,6CAA6C;QAC7C,IAAI,CAAC,aAAa,GAAG,IAAI,CAAC,YAAY,CAAC,eAAe,CACpD,IAAI,CAAC,oBAAoB,CAC1B,CAAC;IACJ,CAAC;IAEM,IAAI,CAAC,SAA4B;QACtC,MAAM,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC;QAExC,MAAM,cAAc,GAAG,SAAS,CAAC,OAAO,IAAI,aAAO,CAAC,MAAM,EAAE,CAAC;QAE7D,mCAAmC;QACnC,MAAM,cAAc,GAClB,SAAS,CAAC,cAAc,IAAI,yBAAc,CAAC,WAAW,CAAC;QAEzD,uEAAuE;QACvE,oEAAoE;QACpE,qCAAqC;QACrC,IACE,cAAc,KAAK,yBAAc,CAAC,WAAW;YAC7C,cAAc,GAAG,YAAY,CAAC,eAAe,EAC7C;YACA,uDAAuD;YACvD,OAAO;SACR;QAED,sEAAsE;QACtE,sFAAsF;QACtF,IAAI,YAAY,CAAC,UAAU,EAAE;YAC3B,MAAM,WAAW,GAAG,WAAK,CAAC,cAAc,CAAC,cAAc,CAAC,CAAC;YACzD,IAAI,WAAW,IAAI,IAAA,wBAAkB,EAAC,WAAW,CAAC,EAAE;gBAClD,0DAA0D;gBAC1D,MAAM,SAAS,GACb,CAAC,WAAW,CAAC,UAAU,GAAG,gBAAU,CAAC,OAAO,CAAC,KAAK,gBAAU,CAAC,OAAO,CAAC;gBACvE,IAAI,CAAC,SAAS,EAAE;oBACd,kDAAkD;oBAClD,OAAO;iBACR;aACF;YACD,kFAAkF;YAClF,6DAA6D;SAC9D;QAED;;;;WAIG;QACH,MAAM,iBAAiB,GAAG,IAAI,6BAAa,CACzC,IAAI,CAAC,YAAY,EACjB,IAAI,CAAC,oBAAoB,EACzB;YACE,OAAO,EAAE,cAAc;YACvB,GAAG,SAAS;SACb,CACF,CAAC;QACF;;;WAGG;QACH,IAAI,CAAC,YAAY,CAAC,eAAe,CAAC,MAAM,CAAC,iBAAiB,EAAE,cAAc,CAAC,CAAC;QAC5E;;;WAGG;QACH,iBAAiB,CAAC,aAAa,EAAE,CAAC;IACpC,CAAC;CACF;AAhFD,wBAgFC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type * as logsAPI from '@opentelemetry/api-logs';\nimport { SeverityNumber } from '@opentelemetry/api-logs';\nimport type { InstrumentationScope } from '@opentelemetry/core';\nimport {\n  context,\n  trace,\n  TraceFlags,\n  isSpanContextValid,\n} from '@opentelemetry/api';\n\nimport { LogRecordImpl } from './LogRecordImpl';\nimport { LoggerProviderSharedState } from './internal/LoggerProviderSharedState';\nimport { LoggerConfig } from './types';\n\nexport class Logger implements logsAPI.Logger {\n  public readonly instrumentationScope: InstrumentationScope;\n  private _sharedState: LoggerProviderSharedState;\n  private readonly _loggerConfig: Required<LoggerConfig>;\n\n  constructor(\n    instrumentationScope: InstrumentationScope,\n    sharedState: LoggerProviderSharedState\n  ) {\n    this.instrumentationScope = instrumentationScope;\n    this._sharedState = sharedState;\n    // Cache the logger configuration at construction time\n    // Since we don't support re-configuration, this avoids map lookups\n    // and string allocations on each emit() call\n    this._loggerConfig = this._sharedState.getLoggerConfig(\n      this.instrumentationScope\n    );\n  }\n\n  public emit(logRecord: logsAPI.LogRecord): void {\n    const loggerConfig = this._loggerConfig;\n\n    const currentContext = logRecord.context || context.active();\n\n    // Apply minimum severity filtering\n    const recordSeverity =\n      logRecord.severityNumber ?? SeverityNumber.UNSPECIFIED;\n\n    // 1. Minimum severity: If the log record's SeverityNumber is specified\n    //    (i.e. not 0) and is less than the configured minimum_severity,\n    //    the log record MUST be dropped.\n    if (\n      recordSeverity !== SeverityNumber.UNSPECIFIED &&\n      recordSeverity < loggerConfig.minimumSeverity\n    ) {\n      // Log record is dropped due to minimum severity filter\n      return;\n    }\n\n    // 2. Trace-based: If trace_based is true, and if the log record has a\n    //    SpanId and the TraceFlags SAMPLED flag is unset, the log record MUST be dropped.\n    if (loggerConfig.traceBased) {\n      const spanContext = trace.getSpanContext(currentContext);\n      if (spanContext && isSpanContextValid(spanContext)) {\n        // Check if the trace is unsampled (SAMPLED flag is unset)\n        const isSampled =\n          (spanContext.traceFlags & TraceFlags.SAMPLED) === TraceFlags.SAMPLED;\n        if (!isSampled) {\n          // Log record is dropped due to trace-based filter\n          return;\n        }\n      }\n      // If there's no valid span context, the log record is not associated with a trace\n      // and therefore bypasses trace-based filtering (as per spec)\n    }\n\n    /**\n     * If a Logger was obtained with include_trace_context=true,\n     * the LogRecords it emits MUST automatically include the Trace Context from the active Context,\n     * if Context has not been explicitly set.\n     */\n    const logRecordInstance = new LogRecordImpl(\n      this._sharedState,\n      this.instrumentationScope,\n      {\n        context: currentContext,\n        ...logRecord,\n      }\n    );\n    /**\n     * the explicitly passed Context,\n     * the current Context, or an empty Context if the Logger was obtained with include_trace_context=false\n     */\n    this._sharedState.activeProcessor.onEmit(logRecordInstance, currentContext);\n    /**\n     * A LogRecordProcessor may freely modify logRecord for the duration of the OnEmit call.\n     * If logRecord is needed after OnEmit returns (i.e. for asynchronous processing) only reads are permitted.\n     */\n    logRecordInstance._makeReadonly();\n  }\n}\n"]}