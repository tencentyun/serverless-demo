/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  ClassifierTargetIn,
  ClassifierTargetIn$Outbound,
  ClassifierTargetIn$outboundSchema,
} from "./classifiertargetin.js";
import {
  ClassifierTrainingParametersIn,
  ClassifierTrainingParametersIn$Outbound,
  ClassifierTrainingParametersIn$outboundSchema,
} from "./classifiertrainingparametersin.js";
import {
  CompletionTrainingParametersIn,
  CompletionTrainingParametersIn$Outbound,
  CompletionTrainingParametersIn$outboundSchema,
} from "./completiontrainingparametersin.js";
import {
  FineTuneableModelType,
  FineTuneableModelType$outboundSchema,
} from "./finetuneablemodeltype.js";
import {
  GithubRepositoryIn,
  GithubRepositoryIn$Outbound,
  GithubRepositoryIn$outboundSchema,
} from "./githubrepositoryin.js";
import {
  TrainingFile,
  TrainingFile$Outbound,
  TrainingFile$outboundSchema,
} from "./trainingfile.js";
import {
  WandbIntegration,
  WandbIntegration$Outbound,
  WandbIntegration$outboundSchema,
} from "./wandbintegration.js";

export type JobInIntegrations = WandbIntegration;

export type Hyperparameters =
  | CompletionTrainingParametersIn
  | ClassifierTrainingParametersIn;

export type JobInRepositories = GithubRepositoryIn;

export type JobIn = {
  /**
   * The name of the model to fine-tune.
   */
  model: string;
  trainingFiles?: Array<TrainingFile> | undefined;
  /**
   * A list containing the IDs of uploaded files that contain validation data. If you provide these files, the data is used to generate validation metrics periodically during fine-tuning. These metrics can be viewed in `checkpoints` when getting the status of a running fine-tuning job. The same data should not be present in both train and validation files.
   */
  validationFiles?: Array<string> | null | undefined;
  /**
   * A string that will be added to your fine-tuning model name. For example, a suffix of "my-great-model" would produce a model name like `ft:open-mistral-7b:my-great-model:xxx...`
   */
  suffix?: string | null | undefined;
  /**
   * A list of integrations to enable for your fine-tuning job.
   */
  integrations?: Array<WandbIntegration> | null | undefined;
  /**
   * This field will be required in a future release.
   */
  autoStart?: boolean | undefined;
  invalidSampleSkipPercentage?: number | undefined;
  jobType?: FineTuneableModelType | null | undefined;
  hyperparameters:
    | CompletionTrainingParametersIn
    | ClassifierTrainingParametersIn;
  repositories?: Array<GithubRepositoryIn> | null | undefined;
  classifierTargets?: Array<ClassifierTargetIn> | null | undefined;
};

/** @internal */
export type JobInIntegrations$Outbound = WandbIntegration$Outbound;

/** @internal */
export const JobInIntegrations$outboundSchema: z.ZodType<
  JobInIntegrations$Outbound,
  z.ZodTypeDef,
  JobInIntegrations
> = WandbIntegration$outboundSchema;

export function jobInIntegrationsToJSON(
  jobInIntegrations: JobInIntegrations,
): string {
  return JSON.stringify(
    JobInIntegrations$outboundSchema.parse(jobInIntegrations),
  );
}

/** @internal */
export type Hyperparameters$Outbound =
  | CompletionTrainingParametersIn$Outbound
  | ClassifierTrainingParametersIn$Outbound;

/** @internal */
export const Hyperparameters$outboundSchema: z.ZodType<
  Hyperparameters$Outbound,
  z.ZodTypeDef,
  Hyperparameters
> = z.union([
  CompletionTrainingParametersIn$outboundSchema,
  ClassifierTrainingParametersIn$outboundSchema,
]);

export function hyperparametersToJSON(
  hyperparameters: Hyperparameters,
): string {
  return JSON.stringify(Hyperparameters$outboundSchema.parse(hyperparameters));
}

/** @internal */
export type JobInRepositories$Outbound = GithubRepositoryIn$Outbound;

/** @internal */
export const JobInRepositories$outboundSchema: z.ZodType<
  JobInRepositories$Outbound,
  z.ZodTypeDef,
  JobInRepositories
> = GithubRepositoryIn$outboundSchema;

export function jobInRepositoriesToJSON(
  jobInRepositories: JobInRepositories,
): string {
  return JSON.stringify(
    JobInRepositories$outboundSchema.parse(jobInRepositories),
  );
}

/** @internal */
export type JobIn$Outbound = {
  model: string;
  training_files?: Array<TrainingFile$Outbound> | undefined;
  validation_files?: Array<string> | null | undefined;
  suffix?: string | null | undefined;
  integrations?: Array<WandbIntegration$Outbound> | null | undefined;
  auto_start?: boolean | undefined;
  invalid_sample_skip_percentage: number;
  job_type?: string | null | undefined;
  hyperparameters:
    | CompletionTrainingParametersIn$Outbound
    | ClassifierTrainingParametersIn$Outbound;
  repositories?: Array<GithubRepositoryIn$Outbound> | null | undefined;
  classifier_targets?: Array<ClassifierTargetIn$Outbound> | null | undefined;
};

/** @internal */
export const JobIn$outboundSchema: z.ZodType<
  JobIn$Outbound,
  z.ZodTypeDef,
  JobIn
> = z.object({
  model: z.string(),
  trainingFiles: z.array(TrainingFile$outboundSchema).optional(),
  validationFiles: z.nullable(z.array(z.string())).optional(),
  suffix: z.nullable(z.string()).optional(),
  integrations: z.nullable(z.array(WandbIntegration$outboundSchema)).optional(),
  autoStart: z.boolean().optional(),
  invalidSampleSkipPercentage: z.number().default(0),
  jobType: z.nullable(FineTuneableModelType$outboundSchema).optional(),
  hyperparameters: z.union([
    CompletionTrainingParametersIn$outboundSchema,
    ClassifierTrainingParametersIn$outboundSchema,
  ]),
  repositories: z.nullable(z.array(GithubRepositoryIn$outboundSchema))
    .optional(),
  classifierTargets: z.nullable(z.array(ClassifierTargetIn$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    trainingFiles: "training_files",
    validationFiles: "validation_files",
    autoStart: "auto_start",
    invalidSampleSkipPercentage: "invalid_sample_skip_percentage",
    jobType: "job_type",
    classifierTargets: "classifier_targets",
  });
});

export function jobInToJSON(jobIn: JobIn): string {
  return JSON.stringify(JobIn$outboundSchema.parse(jobIn));
}
