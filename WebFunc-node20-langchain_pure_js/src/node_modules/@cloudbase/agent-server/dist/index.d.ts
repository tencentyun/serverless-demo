import { CreateCopilotRuntimeServerOptions } from '@copilotkit/runtime';
import { CopilotRuntimeOptions } from '@copilotkit/runtime/v2';
import expressLib, { Express } from 'express';
import * as _ag_ui_client from '@ag-ui/client';
import { AbstractAgent, RunAgentInput } from '@ag-ui/client';
import cors from 'cors';
import { Logger, SendMessageInput } from '@cloudbase/agent-shared';
export { LogFn, Logger, createConsoleLogger, isErrorWithCode, noopLogger } from '@cloudbase/agent-shared';
import { Repeater } from '@repeaterjs/repeater';
import * as _whatwg_node_server from '@whatwg-node/server';
import { OpenAI } from 'openai';

/**
 * Type-only reference to ObservabilityConfig for documentation purposes.
 * The actual type is: ObservabilityConfig | ObservabilityConfig[]
 *
 * At runtime, this accepts any value matching the ObservabilityConfig interface
 * from @cloudbase/agent-observability/server package (if installed).
 */
type ObservabilityConfigOrArray = any;
/**
 * Context passed to the agent factory function.
 * Contains request information for per-request agent configuration.
 */
interface AgentCreatorContext {
    /** The incoming HTTP request (Web Standard Request) */
    request: Request;
    /** Logger instance for this request (with requestId context). Only available when using AGUI routes. */
    logger?: Logger;
    /** Unique request ID for tracing. Only available when using AGUI routes. */
    requestId?: string;
}
type AgentCreatorRet = {
    agent: AbstractAgent | {
        toAGUIAgent(): AbstractAgent;
    };
    cleanup?: () => void;
};
/**
 * Factory function to create an agent.
 * Can optionally receive request context for per-request configuration.
 */
type AgentCreator = ((context: AgentCreatorContext) => AgentCreatorRet | Promise<AgentCreatorRet>) | (() => AgentCreatorRet | Promise<AgentCreatorRet>);
interface ICreateServer {
    createAgent: AgentCreator;
    basePath?: `/${string}/`;
    cors?: boolean | cors.CorsOptions;
    useAGUI?: boolean;
    aguiOptions?: AGUIOptions;
    /**
     * Logger instance for structured logging.
     *
     * @default noopLogger (silent - no output)
     *
     * @example
     * // Development: see all logs
     * createExpressServer({ createAgent, logger: console });
     *
     * // Production: structured JSON logs
     * import pino from 'pino';
     * createExpressServer({ createAgent, logger: pino({ level: 'info' }) });
     */
    logger?: Logger;
    /**
     * Observability configuration for trace exporters.
     *
     * Requires @cloudbase/agent-observability package to be installed.
     * If the package is not installed, this option is silently ignored.
     *
     * Type reference: ObservabilityConfig | ObservabilityConfig[] from @cloudbase/agent-observability/server
     *
     * @example
     * // Console exporter (from env AUTO_TRACES_STDOUT)
     * createExpressServer({ createAgent, observability: { type: 'console' } });
     *
     * // OTLP exporter (Langfuse, Jaeger, etc.)
     * createExpressServer({
     *   createAgent,
     *   observability: {
     *     type: 'otlp',
     *     url: 'https://cloud.langfuse.com/api/public/otlp/v1/traces',
     *     headers: { 'Authorization': 'Basic xxx' }
     *   }
     * });
     *
     * // Multiple exporters
     * createExpressServer({
     *   createAgent,
     *   observability: [
     *     { type: 'console' },
     *     { type: 'otlp', url: 'http://localhost:4318/v1/traces' }
     *   ]
     * });
     */
    observability?: ObservabilityConfigOrArray;
}
interface IRun extends ICreateServer {
    port?: number | string;
}
interface ICreateExpressRoutes extends Omit<ICreateServer, "cors"> {
    express: Express;
    observability?: ICreateServer["observability"];
}
declare function run(props: IRun): void;
declare function createExpressServer(props: ICreateServer): Express;
declare function createExpressRoutes({ createAgent, basePath: _basePath, express, useAGUI: _useAGUI, aguiOptions, logger: _logger, observability, }: ICreateExpressRoutes): expressLib.Express;
interface AGUIOptions {
    runtimeOptions?: Partial<CopilotRuntimeOptions>;
    endpointOptions?: Partial<CreateCopilotRuntimeServerOptions>;
}

declare function handler$2(input: SendMessageInput, agent: AbstractAgent): Repeater<{
    type: "text";
    content: string;
} | {
    type: "tool-call-start";
    toolCallId: string;
    toolCallName: string;
} | {
    type: "tool-call-args";
    toolCallId: string;
    delta: string;
} | {
    type: "tool-call-end";
    toolCallId: string;
} | {
    type: "tool-result";
    toolCallId: string;
    result: string;
} | {
    type: "interrupt";
    id: string;
    reason: string;
    payload: any;
}, any, unknown>;

declare function createServerAdapter$2(createAgent: AgentCreator): _whatwg_node_server.ServerAdapter<{}, _whatwg_node_server.ServerAdapterBaseObject<{}, (request: Request) => Promise<Response>>>;

declare namespace index$4 {
  export { createServerAdapter$2 as createServerAdapter, handler$2 as handler };
}

declare function handler$1(input: RunAgentInput, agent: AbstractAgent): Repeater<{
    type: _ag_ui_client.EventType;
    timestamp?: number | undefined;
    rawEvent?: any;
}, any, unknown>;

/**
 * Options for createServerAdapter
 */
interface CreateServerAdapterOptions {
    /**
     * Logger instance for structured logging.
     * @default noopLogger (silent)
     */
    logger?: Logger;
}
declare function createServerAdapter$1(createAgent: AgentCreator, options?: CreateServerAdapterOptions): _whatwg_node_server.ServerAdapter<{}, _whatwg_node_server.ServerAdapterBaseObject<{}, (request: Request) => Promise<Response>>>;

type index$3_CreateServerAdapterOptions = CreateServerAdapterOptions;
declare namespace index$3 {
  export { type index$3_CreateServerAdapterOptions as CreateServerAdapterOptions, createServerAdapter$1 as createServerAdapter, handler$1 as handler };
}

declare const serverAdapter: _whatwg_node_server.ServerAdapter<{}, _whatwg_node_server.ServerAdapterBaseObject<{}, () => Response>>;

declare const index$2_serverAdapter: typeof serverAdapter;
declare namespace index$2 {
  export { index$2_serverAdapter as serverAdapter };
}

type OpenAIMessage = OpenAI.Chat.Completions.ChatCompletionMessageParam;
type OpenAITool = OpenAI.Chat.Completions.ChatCompletionTool;
type ChatCompletionsInput = {
    messages: Array<OpenAIMessage>;
    tools?: Array<OpenAITool>;
};
declare function handler(input: ChatCompletionsInput, agent: AbstractAgent): Repeater<OpenAI.Chat.Completions.ChatCompletionChunk, any, unknown>;

declare function createServerAdapter(createAgent: AgentCreator): _whatwg_node_server.ServerAdapter<{}, _whatwg_node_server.ServerAdapterBaseObject<{}, (request: Request) => Promise<Response>>>;

declare const index$1_createServerAdapter: typeof createServerAdapter;
declare const index$1_handler: typeof handler;
declare namespace index$1 {
  export { index$1_createServerAdapter as createServerAdapter, index$1_handler as handler };
}

declare namespace index {
  export { index$2 as healthz, index$1 as openai, index$4 as sendMessage, index$3 as sendMessageAGUI };
}

/**
 * Generates a unique request ID for tracing.
 *
 * The request ID is used to:
 * 1. Correlate all logs from a single request
 * 2. Include in error responses for debugging
 * 3. Trace requests across distributed systems
 *
 * @param prefix - Optional prefix for the request ID (default: 'req')
 * @returns A unique request ID string
 *
 * @example
 * generateRequestId() // => 'req-a1b2c3d4-e5f6-7890-abcd-ef1234567890'
 * generateRequestId('agui') // => 'agui-a1b2c3d4-e5f6-7890-abcd-ef1234567890'
 */
declare function generateRequestId(prefix?: string): string;
/**
 * Extracts request ID from incoming request headers.
 * Supports common request ID header conventions.
 *
 * Header priority (first found wins):
 * 1. x-request-id
 * 2. x-correlation-id
 * 3. x-trace-id
 *
 * @param headers - Request headers (Headers object or plain object)
 * @returns The request ID from headers, or undefined if not found
 */
declare function extractRequestId(headers: Headers | Record<string, string | string[] | undefined>): string | undefined;
/**
 * Gets or generates a request ID.
 * First tries to extract from headers, then generates a new one.
 *
 * @param headers - Request headers
 * @param prefix - Prefix for generated IDs (default: 'req')
 * @returns Request ID (either extracted or generated)
 */
declare function getOrGenerateRequestId(headers: Headers | Record<string, string | string[] | undefined>, prefix?: string): string;

/**
 * AG-Kit Error Handling
 *
 * Error handling follows these rules:
 * 1. Pre-stream errors: Return JSON `{error: {code, message}, requestId}`
 * 2. In-stream errors: Emit RunError event `{type: "RUN_ERROR", code, message}`
 *
 * Adapters can:
 * - Directly emit RunError events into the stream
 * - Throw errors with a `code` property (server extracts and converts to RunError)
 * - Throw other errors (server uses fallback INTERNAL_ERROR code)
 */
declare const ErrorCode: {
    /** Invalid request format or parameters (400) */
    readonly INVALID_REQUEST: "INVALID_REQUEST";
    /** Internal server error (500) */
    readonly INTERNAL_ERROR: "INTERNAL_ERROR";
};
type ErrorCodeType = (typeof ErrorCode)[keyof typeof ErrorCode];

export { type AgentCreator, type AgentCreatorContext, ErrorCode, type ErrorCodeType, index as agui, createExpressRoutes, createExpressServer, extractRequestId, generateRequestId, getOrGenerateRequestId, run };
