import "./chunk-NFEGQTCC.mjs";

// src/server/setup.ts
var TRUTHY_ENV_VALUES = /* @__PURE__ */ new Set(["true", "1", "yes", "on"]);
var DEFAULT_BATCH_CONFIG = {
  maxExportBatchSize: 100,
  scheduledDelayMillis: 5e3,
  maxQueueSize: 2048,
  exportTimeoutMillis: 3e4
};
function mergeConfigs(paramConfigs) {
  const result = {
    console: null,
    otlp: [],
    custom: []
  };
  const autoTracesStdout = process.env.AUTO_TRACES_STDOUT?.toLowerCase() || "";
  if (TRUTHY_ENV_VALUES.has(autoTracesStdout)) {
    result.console = { type: "console" };
    console.debug(
      `[Observability] AUTO_TRACES_STDOUT=${autoTracesStdout}, console exporter enabled`
    );
  }
  for (const config of paramConfigs) {
    switch (config.type) {
      case "console":
        result.console = { ...result.console, ...config };
        break;
      case "otlp":
        result.otlp.push(config);
        break;
      case "custom":
        result.custom.push(config);
        break;
    }
  }
  return result;
}
function resolveBatchConfig(batch) {
  return { ...DEFAULT_BATCH_CONFIG, ...batch };
}
async function safeSetup(name, setupFn) {
  try {
    await setupFn();
  } catch (error) {
    console.warn(
      `[Observability] ${name} setup failed (non-fatal): ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
async function setupConsoleExporter(config) {
  const { trace } = await import("@opentelemetry/api");
  const { resourceFromAttributes } = await import("@opentelemetry/resources");
  const { NodeTracerProvider } = await import("@opentelemetry/sdk-trace-node");
  const { ConsoleSpanExporter, BatchSpanProcessor } = await import("@opentelemetry/sdk-trace-base");
  const batchConfig = resolveBatchConfig(config.batch);
  let provider = trace.getTracerProvider();
  const isRealProvider = "addSpanProcessor" in provider;
  if (isRealProvider) {
    const exporter = new ConsoleSpanExporter();
    const processor = new BatchSpanProcessor(exporter, batchConfig);
    provider.addSpanProcessor(processor);
    console.info(
      `[Observability] Console exporter configured (batch=${batchConfig.maxExportBatchSize}, delay=${batchConfig.scheduledDelayMillis}ms)`
    );
  } else {
    const resource = resourceFromAttributes({
      "service.name": process.env.OTEL_SERVICE_NAME || "ag-ui-server",
      "service.version": "1.0.0"
    });
    const exporter = new ConsoleSpanExporter();
    const processor = new BatchSpanProcessor(exporter, batchConfig);
    const tracerProvider = new NodeTracerProvider({
      resource,
      spanProcessors: [processor]
    });
    tracerProvider.register();
    console.info(
      `[Observability] Console exporter configured (batch=${batchConfig.maxExportBatchSize}, delay=${batchConfig.scheduledDelayMillis}ms)`
    );
  }
}
async function setupOTLPExporter(config) {
  const { trace } = await import("@opentelemetry/api");
  const { resourceFromAttributes } = await import("@opentelemetry/resources");
  const { NodeTracerProvider } = await import("@opentelemetry/sdk-trace-node");
  const { OTLPTraceExporter } = await import("./esm-PGEDANAI.mjs");
  const { BatchSpanProcessor } = await import("@opentelemetry/sdk-trace-base");
  const batchConfig = resolveBatchConfig(config.batch);
  let provider = trace.getTracerProvider();
  const isRealProvider = "addSpanProcessor" in provider;
  if (isRealProvider) {
    const exporter = new OTLPTraceExporter({
      url: config.url,
      headers: config.headers,
      timeoutMillis: config.timeout ?? 1e4
    });
    const processor = new BatchSpanProcessor(exporter, batchConfig);
    provider.addSpanProcessor(processor);
    console.info(
      `[Observability] OTLP exporter configured (url=${config.url}, batch=${batchConfig.maxExportBatchSize}, delay=${batchConfig.scheduledDelayMillis}ms)`
    );
  } else {
    const resource = resourceFromAttributes({
      "service.name": process.env.OTEL_SERVICE_NAME || "ag-ui-server",
      "service.version": "1.0.0"
    });
    const exporter = new OTLPTraceExporter({
      url: config.url,
      headers: config.headers,
      timeoutMillis: config.timeout ?? 1e4
    });
    const processor = new BatchSpanProcessor(exporter, batchConfig);
    const tracerProvider = new NodeTracerProvider({
      resource,
      spanProcessors: [processor]
    });
    tracerProvider.register();
    console.info(
      `[Observability] OTLP exporter configured (url=${config.url}, batch=${batchConfig.maxExportBatchSize}, delay=${batchConfig.scheduledDelayMillis}ms)`
    );
  }
}
async function setupCustomExporter(config) {
  await config.setup();
  console.info(`[Observability] Custom exporter setup completed`);
}
async function applyMergedConfigs(merged) {
  const setupTasks = [];
  if (merged.console) {
    setupTasks.push(safeSetup("Console exporter", () => setupConsoleExporter(merged.console)));
  }
  for (const otlp of merged.otlp) {
    setupTasks.push(safeSetup(`OTLP exporter (${otlp.url})`, () => setupOTLPExporter(otlp)));
  }
  for (const custom of merged.custom) {
    setupTasks.push(safeSetup("Custom exporter", () => setupCustomExporter(custom)));
  }
  await Promise.all(setupTasks);
  if (merged.console || merged.otlp.length > 0 || merged.custom.length > 0) {
    console.info(`[Observability] Setup completed`);
  }
}
var setupPromise = null;
async function setupObservability(configs) {
  if (setupPromise) {
    return setupPromise;
  }
  setupPromise = (async () => {
    try {
      const configsArray = configs ? Array.isArray(configs) ? configs : [configs] : [];
      const merged = mergeConfigs(configsArray);
      await applyMergedConfigs(merged);
    } catch (error) {
      setupPromise = null;
      console.warn(
        `[Observability] Setup failed: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  })();
  return setupPromise;
}

// src/server/config.ts
var ExporterType = {
  /** Console exporter - outputs traces to stdout */
  Console: "console",
  /** OTLP exporter - sends traces to OTLP-compatible backend */
  OTLP: "otlp",
  /** Custom exporter - user-defined setup logic */
  Custom: "custom"
};
export {
  ExporterType,
  setupObservability
};
//# sourceMappingURL=server.mjs.map