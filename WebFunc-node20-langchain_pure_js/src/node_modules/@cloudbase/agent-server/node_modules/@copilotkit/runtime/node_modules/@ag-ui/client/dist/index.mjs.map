{"version":3,"sources":["../src/apply/default.ts","../src/utils.ts","../src/agent/subscriber.ts","../src/verify/verify.ts","../src/transform/http.ts","../src/run/http-request.ts","../src/transform/sse.ts","../src/transform/proto.ts","../src/legacy/convert.ts","../src/legacy/types.ts","../src/agent/agent.ts","../src/chunks/transform.ts","../src/middleware/middleware.ts","../src/middleware/filter-tool-calls.ts","../src/middleware/backward-compatibility-0-0-39.ts","../package.json","../src/agent/http.ts","../src/compact/compact.ts","../src/index.ts"],"sourcesContent":["import {\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  Message,\n  DeveloperMessage,\n  SystemMessage,\n  AssistantMessage,\n  UserMessage,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  StateSnapshotEvent,\n  StateDeltaEvent,\n  MessagesSnapshotEvent,\n  CustomEvent,\n  BaseEvent,\n  ToolCallResultEvent,\n  ToolMessage,\n  RunAgentInput,\n  TextMessageEndEvent,\n  ToolCallEndEvent,\n  RawEvent,\n  RunStartedEvent,\n  RunFinishedEvent,\n  RunErrorEvent,\n  StepStartedEvent,\n  StepFinishedEvent,\n  ActivitySnapshotEvent,\n  ActivityDeltaEvent,\n  ActivityMessage,\n} from \"@ag-ui/core\";\nimport { mergeMap, mergeAll, defaultIfEmpty, concatMap } from \"rxjs/operators\";\nimport { of, EMPTY } from \"rxjs\";\nimport { structuredClone_ } from \"../utils\";\nimport { applyPatch } from \"fast-json-patch\";\nimport {\n  AgentStateMutation,\n  AgentSubscriber,\n  runSubscribersWithMutation,\n} from \"@/agent/subscriber\";\nimport { Observable } from \"rxjs\";\nimport { AbstractAgent } from \"@/agent/agent\";\nimport untruncateJson from \"untruncate-json\";\n\nexport const defaultApplyEvents = (\n  input: RunAgentInput,\n  events$: Observable<BaseEvent>,\n  agent: AbstractAgent,\n  subscribers: AgentSubscriber[],\n): Observable<AgentStateMutation> => {\n  let messages = structuredClone_(agent.messages);\n  let state = structuredClone_(input.state);\n  let currentMutation: AgentStateMutation = {};\n\n  const applyMutation = (mutation: AgentStateMutation) => {\n    if (mutation.messages !== undefined) {\n      messages = mutation.messages;\n      currentMutation.messages = mutation.messages;\n    }\n    if (mutation.state !== undefined) {\n      state = mutation.state;\n      currentMutation.state = mutation.state;\n    }\n  };\n\n  const emitUpdates = () => {\n    const result = structuredClone_(currentMutation) as AgentStateMutation;\n    currentMutation = {};\n    if (result.messages !== undefined || result.state !== undefined) {\n      return of(result);\n    }\n    return EMPTY;\n  };\n\n  return events$.pipe(\n    concatMap(async (event) => {\n      const mutation = await runSubscribersWithMutation(\n        subscribers,\n        messages,\n        state,\n        (subscriber, messages, state) =>\n          subscriber.onEvent?.({ event, agent, input, messages, state }),\n      );\n      applyMutation(mutation);\n\n      if (mutation.stopPropagation === true) {\n        return emitUpdates();\n      }\n\n      switch (event.type) {\n        case EventType.TEXT_MESSAGE_START: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageStartEvent?.({\n                event: event as TextMessageStartEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messageId, role = \"assistant\" } = event as TextMessageStartEvent;\n\n            // Create a new message using properties from the event\n            // Text messages can be developer, system, assistant, or user (not tool)\n            const newMessage: Message = {\n              id: messageId,\n              role: role,\n              content: \"\",\n            };\n\n            // Add the new message to the messages array\n            messages.push(newMessage);\n            applyMutation({ messages });\n          }\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_CONTENT: {\n          const { messageId, delta } = event as TextMessageContentEvent;\n\n          // Find the target message by ID\n          const targetMessage = messages.find((m) => m.id === messageId);\n          if (!targetMessage) {\n            console.warn(`TEXT_MESSAGE_CONTENT: No message found with ID '${messageId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageContentEvent?.({\n                event: event as TextMessageContentEvent,\n                messages,\n                state,\n                agent,\n                input,\n                textMessageBuffer:\n                  typeof targetMessage.content === \"string\" ? targetMessage.content : \"\",\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            // Append content to the correct message by ID\n            const existingContent =\n              typeof targetMessage.content === \"string\" ? targetMessage.content : \"\";\n            targetMessage.content = `${existingContent}${delta}`;\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_END: {\n          const { messageId } = event as TextMessageEndEvent;\n\n          // Find the target message by ID\n          const targetMessage = messages.find((m) => m.id === messageId);\n          if (!targetMessage) {\n            console.warn(`TEXT_MESSAGE_END: No message found with ID '${messageId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onTextMessageEndEvent?.({\n                event: event as TextMessageEndEvent,\n                messages,\n                state,\n                agent,\n                input,\n                textMessageBuffer:\n                  typeof targetMessage.content === \"string\" ? targetMessage.content : \"\",\n              }),\n          );\n          applyMutation(mutation);\n\n          await Promise.all(\n            subscribers.map((subscriber) => {\n              subscriber.onNewMessage?.({\n                message: targetMessage,\n                messages,\n                state,\n                agent,\n                input,\n              });\n            }),\n          );\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_START: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onToolCallStartEvent?.({\n                event: event as ToolCallStartEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { toolCallId, toolCallName, parentMessageId } = event as ToolCallStartEvent;\n\n            let targetMessage: AssistantMessage;\n\n            // Use last message if parentMessageId exists, we have messages, and the parentMessageId matches the last message's id\n            if (\n              parentMessageId &&\n              messages.length > 0 &&\n              messages[messages.length - 1].id === parentMessageId\n            ) {\n              targetMessage = messages[messages.length - 1] as AssistantMessage;\n            } else {\n              // Create a new message otherwise\n              targetMessage = {\n                id: parentMessageId || toolCallId,\n                role: \"assistant\",\n                toolCalls: [],\n              };\n              messages.push(targetMessage);\n            }\n\n            targetMessage.toolCalls ??= [];\n\n            // Add the new tool call\n            targetMessage.toolCalls.push({\n              id: toolCallId,\n              type: \"function\",\n              function: {\n                name: toolCallName,\n                arguments: \"\",\n              },\n            });\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_ARGS: {\n          const { toolCallId, delta } = event as ToolCallArgsEvent;\n\n          // Find the message containing this tool call\n          const targetMessage = messages.find((m) =>\n            (m as AssistantMessage).toolCalls?.some((tc) => tc.id === toolCallId),\n          ) as AssistantMessage;\n\n          if (!targetMessage) {\n            console.warn(\n              `TOOL_CALL_ARGS: No message found containing tool call with ID '${toolCallId}'`,\n            );\n            return emitUpdates();\n          }\n\n          // Find the specific tool call\n          const targetToolCall = targetMessage.toolCalls!.find((tc) => tc.id === toolCallId);\n          if (!targetToolCall) {\n            console.warn(`TOOL_CALL_ARGS: No tool call found with ID '${toolCallId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) => {\n              const toolCallBuffer = targetToolCall.function.arguments;\n              const toolCallName = targetToolCall.function.name;\n              let partialToolCallArgs = {};\n              try {\n                // Parse from toolCallBuffer only (before current delta is applied)\n                partialToolCallArgs = untruncateJson(toolCallBuffer);\n              } catch (error) {}\n\n              return subscriber.onToolCallArgsEvent?.({\n                event: event as ToolCallArgsEvent,\n                messages,\n                state,\n                agent,\n                input,\n                toolCallBuffer,\n                toolCallName,\n                partialToolCallArgs,\n              });\n            },\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            // Append the arguments to the correct tool call by ID\n            targetToolCall.function.arguments += delta;\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_END: {\n          const { toolCallId } = event as ToolCallEndEvent;\n\n          // Find the message containing this tool call\n          const targetMessage = messages.find((m) =>\n            (m as AssistantMessage).toolCalls?.some((tc) => tc.id === toolCallId),\n          ) as AssistantMessage;\n\n          if (!targetMessage) {\n            console.warn(\n              `TOOL_CALL_END: No message found containing tool call with ID '${toolCallId}'`,\n            );\n            return emitUpdates();\n          }\n\n          // Find the specific tool call\n          const targetToolCall = targetMessage.toolCalls!.find((tc) => tc.id === toolCallId);\n          if (!targetToolCall) {\n            console.warn(`TOOL_CALL_END: No tool call found with ID '${toolCallId}'`);\n            return emitUpdates();\n          }\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) => {\n              const toolCallArgsString = targetToolCall.function.arguments;\n              const toolCallName = targetToolCall.function.name;\n              let toolCallArgs = {};\n              try {\n                toolCallArgs = JSON.parse(toolCallArgsString);\n              } catch (error) {}\n              return subscriber.onToolCallEndEvent?.({\n                event: event as ToolCallEndEvent,\n                messages,\n                state,\n                agent,\n                input,\n                toolCallName,\n                toolCallArgs,\n              });\n            },\n          );\n          applyMutation(mutation);\n\n          await Promise.all(\n            subscribers.map((subscriber) => {\n              subscriber.onNewToolCall?.({\n                toolCall: targetToolCall,\n                messages,\n                state,\n                agent,\n                input,\n              });\n            }),\n          );\n\n          return emitUpdates();\n        }\n\n        case EventType.TOOL_CALL_RESULT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onToolCallResultEvent?.({\n                event: event as ToolCallResultEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messageId, toolCallId, content, role } = event as ToolCallResultEvent;\n\n            const toolMessage: ToolMessage = {\n              id: messageId,\n              toolCallId,\n              role: role || \"tool\",\n              content: content,\n            };\n\n            messages.push(toolMessage);\n\n            await Promise.all(\n              subscribers.map((subscriber) => {\n                subscriber.onNewMessage?.({\n                  message: toolMessage,\n                  messages,\n                  state,\n                  agent,\n                  input,\n                });\n              }),\n            );\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.STATE_SNAPSHOT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStateSnapshotEvent?.({\n                event: event as StateSnapshotEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { snapshot } = event as StateSnapshotEvent;\n\n            // Replace state with the literal snapshot\n            state = snapshot;\n\n            applyMutation({ state });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.STATE_DELTA: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStateDeltaEvent?.({\n                event: event as StateDeltaEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { delta } = event as StateDeltaEvent;\n\n            try {\n              // Apply the JSON Patch operations to the current state without mutating the original\n              const result = applyPatch(state, delta, true, false);\n              state = result.newDocument;\n              applyMutation({ state });\n            } catch (error: unknown) {\n              const errorMessage = error instanceof Error ? error.message : String(error);\n              console.warn(\n                `Failed to apply state patch:\\n` +\n                  `Current state: ${JSON.stringify(state, null, 2)}\\n` +\n                  `Patch operations: ${JSON.stringify(delta, null, 2)}\\n` +\n                  `Error: ${errorMessage}`,\n              );\n              // If patch failed, only emit updates if there were subscriber mutations\n              // This prevents emitting updates when both patch fails AND no subscriber mutations\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.MESSAGES_SNAPSHOT: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onMessagesSnapshotEvent?.({\n                event: event as MessagesSnapshotEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const { messages: newMessages } = event as MessagesSnapshotEvent;\n\n            // Replace messages with the snapshot\n            messages = newMessages;\n\n            applyMutation({ messages });\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.ACTIVITY_SNAPSHOT: {\n          const activityEvent = event as ActivitySnapshotEvent;\n          const existingIndex = messages.findIndex((m) => m.id === activityEvent.messageId);\n          const existingMessage = existingIndex >= 0 ? messages[existingIndex] : undefined;\n          const existingActivityMessage =\n            existingMessage?.role === \"activity\" ? (existingMessage as ActivityMessage) : undefined;\n          const replace = activityEvent.replace ?? true;\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onActivitySnapshotEvent?.({\n                event: activityEvent,\n                messages,\n                state,\n                agent,\n                input,\n                activityMessage: existingActivityMessage,\n                existingMessage,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            const activityMessage: ActivityMessage = {\n              id: activityEvent.messageId,\n              role: \"activity\",\n              activityType: activityEvent.activityType,\n              content: structuredClone_(activityEvent.content),\n            };\n\n            let createdMessage: ActivityMessage | undefined;\n\n            if (existingIndex === -1) {\n              messages.push(activityMessage);\n              createdMessage = activityMessage;\n            } else if (existingActivityMessage) {\n              if (replace) {\n                messages[existingIndex] = {\n                  ...existingActivityMessage,\n                  activityType: activityEvent.activityType,\n                  content: structuredClone_(activityEvent.content),\n                };\n              }\n            } else if (replace) {\n              messages[existingIndex] = activityMessage;\n              createdMessage = activityMessage;\n            }\n\n            applyMutation({ messages });\n\n            if (createdMessage) {\n              await Promise.all(\n                subscribers.map((subscriber) =>\n                  subscriber.onNewMessage?.({\n                    message: createdMessage,\n                    messages,\n                    state,\n                    agent,\n                    input,\n                  }),\n                ),\n              );\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.ACTIVITY_DELTA: {\n          const activityEvent = event as ActivityDeltaEvent;\n          const existingIndex = messages.findIndex((m) => m.id === activityEvent.messageId);\n          if (existingIndex === -1) {\n            console.warn(\n              `ACTIVITY_DELTA: No message found with ID '${activityEvent.messageId}' to apply patch`,\n            );\n            return emitUpdates();\n          }\n\n          const existingMessage = messages[existingIndex];\n          if (existingMessage.role !== \"activity\") {\n            console.warn(\n              `ACTIVITY_DELTA: Message '${activityEvent.messageId}' is not an activity message`,\n            );\n            return emitUpdates();\n          }\n\n          const existingActivityMessage = existingMessage as ActivityMessage;\n\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onActivityDeltaEvent?.({\n                event: activityEvent,\n                messages,\n                state,\n                agent,\n                input,\n                activityMessage: existingActivityMessage,\n              }),\n          );\n          applyMutation(mutation);\n\n          if (mutation.stopPropagation !== true) {\n            try {\n              const baseContent = structuredClone_(existingActivityMessage.content ?? {});\n\n              const result = applyPatch(\n                baseContent,\n                activityEvent.patch ?? [],\n                true,\n                false,\n              );\n              const updatedContent = result.newDocument as ActivityMessage[\"content\"];\n\n              messages[existingIndex] = {\n                ...existingActivityMessage,\n                content: structuredClone_(updatedContent),\n                activityType: activityEvent.activityType,\n              };\n\n              applyMutation({ messages });\n            } catch (error: unknown) {\n              const errorMessage = error instanceof Error ? error.message : String(error);\n              console.warn(\n                `Failed to apply activity patch for '${activityEvent.messageId}': ${errorMessage}`,\n              );\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.RAW: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRawEvent?.({\n                event: event as RawEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.CUSTOM: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onCustomEvent?.({\n                event: event as CustomEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_STARTED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunStartedEvent?.({\n                event: event as RunStartedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          // Handle input.messages if present and stopPropagation is not set\n          if (mutation.stopPropagation !== true) {\n            const runStartedEvent = event as RunStartedEvent;\n\n            // Check if the event contains input with messages\n            if (runStartedEvent.input?.messages) {\n              // Add messages that aren't already present (checked by ID)\n              for (const message of runStartedEvent.input.messages) {\n                const existingMessage = messages.find((m) => m.id === message.id);\n                if (!existingMessage) {\n                  messages.push(message);\n                }\n              }\n\n              // Apply mutation to emit the updated messages\n              applyMutation({ messages });\n            }\n          }\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_FINISHED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunFinishedEvent?.({\n                event: event as RunFinishedEvent,\n                messages,\n                state,\n                agent,\n                input,\n                result: (event as RunFinishedEvent).result,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.RUN_ERROR: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onRunErrorEvent?.({\n                event: event as RunErrorEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.STEP_STARTED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStepStartedEvent?.({\n                event: event as StepStartedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.STEP_FINISHED: {\n          const mutation = await runSubscribersWithMutation(\n            subscribers,\n            messages,\n            state,\n            (subscriber, messages, state) =>\n              subscriber.onStepFinishedEvent?.({\n                event: event as StepFinishedEvent,\n                messages,\n                state,\n                agent,\n                input,\n              }),\n          );\n          applyMutation(mutation);\n\n          return emitUpdates();\n        }\n\n        case EventType.TEXT_MESSAGE_CHUNK: {\n          throw new Error(\"TEXT_MESSAGE_CHUNK must be tranformed before being applied\");\n        }\n\n        case EventType.TOOL_CALL_CHUNK: {\n          throw new Error(\"TOOL_CALL_CHUNK must be tranformed before being applied\");\n        }\n\n        case EventType.THINKING_START: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_END: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_START: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_CONTENT: {\n          return emitUpdates();\n        }\n\n        case EventType.THINKING_TEXT_MESSAGE_END: {\n          return emitUpdates();\n        }\n      }\n\n      // This makes TypeScript check that the switch is exhaustive\n      // If a new EventType is added, this will cause a compile error\n      const _exhaustiveCheck: never = event.type;\n      return emitUpdates();\n    }),\n    mergeAll(),\n    // Only use defaultIfEmpty when there are subscribers to avoid emitting empty updates\n    // when patches fail and there are no subscribers (like in state patching test)\n    subscribers.length > 0 ? defaultIfEmpty({} as AgentStateMutation) : (stream: any) => stream,\n  );\n};\n","import { v4 as uuidv4 } from \"uuid\";\n\nexport const structuredClone_ = <T>(obj: T): T => {\n  if (typeof structuredClone === \"function\") {\n    return structuredClone(obj);\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(obj));\n  } catch (err) {\n    return { ...obj } as T;\n  }\n};\n\n/**\n * Generate a random UUID v4\n * Cross-platform compatible (Node.js, browsers, React Native)\n */\nexport function randomUUID(): string {\n  return uuidv4();\n}\n\n// Note: semver helpers were removed in favor of using\n// the external `compare-versions` library directly at call sites.\n\n\n/**\n * Parses a semantic version string into its numeric components.\n * Supports incomplete versions (e.g. \"1\", \"1.2\") by defaulting missing segments to zero.\n *\n * @throws If the version string is not a valid semantic version.\n */\n// (Intentionally left minimal.)\n","import {\n  BaseEvent,\n  Message,\n  RunAgentInput,\n  RunErrorEvent,\n  RunFinishedEvent,\n  RunStartedEvent,\n  State,\n  StateDeltaEvent,\n  StateSnapshotEvent,\n  StepFinishedEvent,\n  StepStartedEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  ToolCallStartEvent,\n  MessagesSnapshotEvent,\n  RawEvent,\n  CustomEvent,\n  ToolCall,\n  ActivitySnapshotEvent,\n  ActivityDeltaEvent,\n  ActivityMessage,\n} from \"@ag-ui/core\";\nimport { AbstractAgent } from \"./agent\";\nimport { structuredClone_ } from \"@/utils\";\n\nexport interface AgentStateMutation {\n  messages?: Message[];\n  state?: State;\n  stopPropagation?: boolean;\n}\n\nexport interface AgentSubscriberParams {\n  messages: Message[];\n  state: State;\n  agent: AbstractAgent;\n  input: RunAgentInput;\n}\n\n// Utility type to allow callbacks to be implemented either synchronously or asynchronously.\nexport type MaybePromise<T> = T | Promise<T>;\n\nexport interface AgentSubscriber {\n  // Request lifecycle\n  onRunInitialized?(\n    params: AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n  onRunFailed?(\n    params: { error: Error } & AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n  onRunFinalized?(\n    params: AgentSubscriberParams,\n  ): MaybePromise<Omit<AgentStateMutation, \"stopPropagation\"> | void>;\n\n  // Events\n  onEvent?(\n    params: { event: BaseEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onRunStartedEvent?(\n    params: { event: RunStartedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onRunFinishedEvent?(\n    params: { event: RunFinishedEvent; result?: any } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onRunErrorEvent?(\n    params: { event: RunErrorEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStepStartedEvent?(\n    params: { event: StepStartedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onStepFinishedEvent?(\n    params: { event: StepFinishedEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onTextMessageStartEvent?(\n    params: { event: TextMessageStartEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onTextMessageContentEvent?(\n    params: {\n      event: TextMessageContentEvent;\n      textMessageBuffer: string;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onTextMessageEndEvent?(\n    params: { event: TextMessageEndEvent; textMessageBuffer: string } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onToolCallStartEvent?(\n    params: { event: ToolCallStartEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onToolCallArgsEvent?(\n    params: {\n      event: ToolCallArgsEvent;\n      toolCallBuffer: string;\n      toolCallName: string;\n      partialToolCallArgs: Record<string, any>;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n  onToolCallEndEvent?(\n    params: {\n      event: ToolCallEndEvent;\n      toolCallName: string;\n      toolCallArgs: Record<string, any>;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onToolCallResultEvent?(\n    params: { event: ToolCallResultEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStateSnapshotEvent?(\n    params: { event: StateSnapshotEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onStateDeltaEvent?(\n    params: { event: StateDeltaEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onMessagesSnapshotEvent?(\n    params: { event: MessagesSnapshotEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onActivitySnapshotEvent?(\n    params: {\n      event: ActivitySnapshotEvent;\n      activityMessage?: ActivityMessage;\n      existingMessage?: Message;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onActivityDeltaEvent?(\n    params: {\n      event: ActivityDeltaEvent;\n      activityMessage?: ActivityMessage;\n    } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onRawEvent?(\n    params: { event: RawEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  onCustomEvent?(\n    params: { event: CustomEvent } & AgentSubscriberParams,\n  ): MaybePromise<AgentStateMutation | void>;\n\n  // State changes\n  onMessagesChanged?(\n    params: Omit<AgentSubscriberParams, \"input\"> & { input?: RunAgentInput },\n  ): MaybePromise<void>;\n  onStateChanged?(\n    params: Omit<AgentSubscriberParams, \"input\"> & { input?: RunAgentInput },\n  ): MaybePromise<void>;\n  onNewMessage?(\n    params: { message: Message } & Omit<AgentSubscriberParams, \"input\"> & {\n        input?: RunAgentInput;\n      },\n  ): MaybePromise<void>;\n  onNewToolCall?(\n    params: { toolCall: ToolCall } & Omit<AgentSubscriberParams, \"input\"> & {\n        input?: RunAgentInput;\n      },\n  ): MaybePromise<void>;\n}\n\nexport async function runSubscribersWithMutation(\n  subscribers: AgentSubscriber[],\n  initialMessages: Message[],\n  initialState: State,\n  executor: (\n    subscriber: AgentSubscriber,\n    messages: Message[],\n    state: State,\n  ) => MaybePromise<AgentStateMutation | void>,\n): Promise<AgentStateMutation> {\n  let messages: Message[] = initialMessages;\n  let state: State = initialState;\n\n  let stopPropagation: boolean | undefined = undefined;\n\n  for (const subscriber of subscribers) {\n    try {\n      const mutation = await executor(\n        subscriber,\n        structuredClone_(messages),\n        structuredClone_(state),\n      );\n\n      if (mutation === undefined) {\n        // Nothing returned â€“ keep going\n        continue;\n      }\n\n      // Merge messages/state so next subscriber sees latest view\n      if (mutation.messages !== undefined) {\n        messages = mutation.messages;\n      }\n\n      if (mutation.state !== undefined) {\n        state = mutation.state;\n      }\n\n      stopPropagation = mutation.stopPropagation;\n\n      if (stopPropagation === true) {\n        break;\n      }\n    } catch (error) {\n      // Log subscriber errors but continue processing (silence during tests)\n      const isTestEnvironment =\n        process.env.NODE_ENV === \"test\" || process.env.JEST_WORKER_ID !== undefined;\n\n      if (!isTestEnvironment) {\n        console.error(\"Subscriber error:\", error);\n      }\n      // Continue to next subscriber unless we want to stop propagation\n      continue;\n    }\n  }\n\n  return {\n    ...(JSON.stringify(messages) !== JSON.stringify(initialMessages) ? { messages } : {}),\n    ...(JSON.stringify(state) !== JSON.stringify(initialState) ? { state } : {}),\n    ...(stopPropagation !== undefined ? { stopPropagation } : {}),\n  };\n}\n","import { BaseEvent, EventType, AGUIError } from \"@ag-ui/core\";\nimport { Observable, throwError, of } from \"rxjs\";\nimport { mergeMap } from \"rxjs/operators\";\n\nexport const verifyEvents =\n  (debug: boolean) =>\n  (source$: Observable<BaseEvent>): Observable<BaseEvent> => {\n    // Declare variables in closure to maintain state across events\n    let activeMessages = new Map<string, boolean>(); // Map of message ID -> active status\n    let activeToolCalls = new Map<string, boolean>(); // Map of tool call ID -> active status\n    let runFinished = false;\n    let runError = false; // New flag to track if RUN_ERROR has been sent\n    // New flags to track first/last event requirements\n    let firstEventReceived = false;\n    // Track active steps\n    let activeSteps = new Map<string, boolean>(); // Map of step name -> active status\n    let activeThinkingStep = false;\n    let activeThinkingStepMessage = false;\n    let runStarted = false; // Track if a run has started\n\n    // Function to reset state for a new run\n    const resetRunState = () => {\n      activeMessages.clear();\n      activeToolCalls.clear();\n      activeSteps.clear();\n      activeThinkingStep = false;\n      activeThinkingStepMessage = false;\n      runFinished = false;\n      runError = false;\n      runStarted = true;\n    };\n\n    return source$.pipe(\n      // Process each event through our state machine\n      mergeMap((event) => {\n        const eventType = event.type;\n\n        if (debug) {\n          console.debug(\"[VERIFY]:\", JSON.stringify(event));\n        }\n\n        // Check if run has errored\n        if (runError) {\n          return throwError(\n            () =>\n              new AGUIError(\n                `Cannot send event type '${eventType}': The run has already errored with 'RUN_ERROR'. No further events can be sent.`,\n              ),\n          );\n        }\n\n        // Check if run has already finished (but allow new RUN_STARTED to start a new run)\n        if (runFinished && eventType !== EventType.RUN_ERROR && eventType !== EventType.RUN_STARTED) {\n          return throwError(\n            () =>\n              new AGUIError(\n                `Cannot send event type '${eventType}': The run has already finished with 'RUN_FINISHED'. Start a new run with 'RUN_STARTED'.`,\n              ),\n          );\n        }\n\n        // Handle first event requirement and sequential RUN_STARTED\n        if (!firstEventReceived) {\n          firstEventReceived = true;\n          if (eventType !== EventType.RUN_STARTED && eventType !== EventType.RUN_ERROR) {\n            return throwError(() => new AGUIError(`First event must be 'RUN_STARTED'`));\n          }\n        } else if (eventType === EventType.RUN_STARTED) {\n          // Allow RUN_STARTED after RUN_FINISHED (new run), but not during an active run\n          if (runStarted && !runFinished) {\n            return throwError(\n              () =>\n                new AGUIError(\n                  `Cannot send 'RUN_STARTED' while a run is still active. The previous run must be finished with 'RUN_FINISHED' before starting a new run.`,\n                ),\n            );\n          }\n          // If we're here, it's either the first RUN_STARTED or a new run after RUN_FINISHED\n          if (runFinished) {\n            // This is a new run after the previous one finished, reset state\n            resetRunState();\n          }\n        }\n\n        // Validate event based on type and current state\n        switch (eventType) {\n          // Text message flow\n          case EventType.TEXT_MESSAGE_START: {\n            const messageId = (event as any).messageId;\n\n            // Check if this message is already in progress\n            if (activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_START' event: A text message with ID '${messageId}' is already in progress. Complete it with 'TEXT_MESSAGE_END' first.`,\n                  ),\n              );\n            }\n\n            activeMessages.set(messageId, true);\n            return of(event);\n          }\n\n          case EventType.TEXT_MESSAGE_CONTENT: {\n            const messageId = (event as any).messageId;\n\n            // Must be in a message with this ID\n            if (!activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_CONTENT' event: No active text message found with ID '${messageId}'. Start a text message with 'TEXT_MESSAGE_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.TEXT_MESSAGE_END: {\n            const messageId = (event as any).messageId;\n\n            // Must be in a message with this ID\n            if (!activeMessages.has(messageId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TEXT_MESSAGE_END' event: No active text message found with ID '${messageId}'. A 'TEXT_MESSAGE_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Remove message from active set\n            activeMessages.delete(messageId);\n            return of(event);\n          }\n\n          // Tool call flow\n          case EventType.TOOL_CALL_START: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Check if this tool call is already in progress\n            if (activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_START' event: A tool call with ID '${toolCallId}' is already in progress. Complete it with 'TOOL_CALL_END' first.`,\n                  ),\n              );\n            }\n\n            activeToolCalls.set(toolCallId, true);\n            return of(event);\n          }\n\n          case EventType.TOOL_CALL_ARGS: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Must be in a tool call with this ID\n            if (!activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_ARGS' event: No active tool call found with ID '${toolCallId}'. Start a tool call with 'TOOL_CALL_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.TOOL_CALL_END: {\n            const toolCallId = (event as any).toolCallId;\n\n            // Must be in a tool call with this ID\n            if (!activeToolCalls.has(toolCallId)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'TOOL_CALL_END' event: No active tool call found with ID '${toolCallId}'. A 'TOOL_CALL_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Remove tool call from active set\n            activeToolCalls.delete(toolCallId);\n            return of(event);\n          }\n\n          // Step flow\n          case EventType.STEP_STARTED: {\n            const stepName = (event as any).stepName;\n            if (activeSteps.has(stepName)) {\n              return throwError(\n                () => new AGUIError(`Step \"${stepName}\" is already active for 'STEP_STARTED'`),\n              );\n            }\n            activeSteps.set(stepName, true);\n            return of(event);\n          }\n\n          case EventType.STEP_FINISHED: {\n            const stepName = (event as any).stepName;\n            if (!activeSteps.has(stepName)) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'STEP_FINISHED' for step \"${stepName}\" that was not started`,\n                  ),\n              );\n            }\n            activeSteps.delete(stepName);\n            return of(event);\n          }\n\n          // Run flow\n          case EventType.RUN_STARTED: {\n            // We've already validated this above\n            runStarted = true;\n            return of(event);\n          }\n\n          case EventType.RUN_FINISHED: {\n            // Can't be the first event (already checked)\n            // and can't happen after already being finished (already checked)\n\n            // Check that all steps are finished before run ends\n            if (activeSteps.size > 0) {\n              const unfinishedSteps = Array.from(activeSteps.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while steps are still active: ${unfinishedSteps}`,\n                  ),\n              );\n            }\n\n            // Check that all messages are finished before run ends\n            if (activeMessages.size > 0) {\n              const unfinishedMessages = Array.from(activeMessages.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while text messages are still active: ${unfinishedMessages}`,\n                  ),\n              );\n            }\n\n            // Check that all tool calls are finished before run ends\n            if (activeToolCalls.size > 0) {\n              const unfinishedToolCalls = Array.from(activeToolCalls.keys()).join(\", \");\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'RUN_FINISHED' while tool calls are still active: ${unfinishedToolCalls}`,\n                  ),\n              );\n            }\n\n            runFinished = true;\n            return of(event);\n          }\n\n          case EventType.RUN_ERROR: {\n            // RUN_ERROR can happen at any time\n            runError = true; // Set flag to prevent any further events\n            return of(event);\n          }\n\n          case EventType.CUSTOM: {\n            return of(event);\n          }\n\n          // Text message flow\n          case EventType.THINKING_TEXT_MESSAGE_START: {\n            if (!activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_START' event: A thinking step is not in progress. Create one with 'THINKING_START' first.`,\n                  ),\n              );\n            }\n            // Can't start a message if one is already in progress\n            if (activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_START' event: A thinking message is already in progress. Complete it with 'THINKING_TEXT_MESSAGE_END' first.`,\n                  ),\n              );\n            }\n\n            activeThinkingStepMessage = true;\n            return of(event);\n          }\n\n          case EventType.THINKING_TEXT_MESSAGE_CONTENT: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_CONTENT' event: No active thinking message found. Start a message with 'THINKING_TEXT_MESSAGE_START' first.`,\n                  ),\n              );\n            }\n\n            return of(event);\n          }\n\n          case EventType.THINKING_TEXT_MESSAGE_END: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStepMessage) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_TEXT_MESSAGE_END' event: No active thinking message found. A 'THINKING_TEXT_MESSAGE_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Reset message state\n            activeThinkingStepMessage = false;\n            return of(event);\n          }\n\n          case EventType.THINKING_START: {\n            if (activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_START' event: A thinking step is already in progress. End it with 'THINKING_END' first.`,\n                  ),\n              );\n            }\n\n            activeThinkingStep = true;\n            return of(event);\n          }\n\n          case EventType.THINKING_END: {\n            // Must be in a message and IDs must match\n            if (!activeThinkingStep) {\n              return throwError(\n                () =>\n                  new AGUIError(\n                    `Cannot send 'THINKING_END' event: No active thinking step found. A 'THINKING_START' event must be sent first.`,\n                  ),\n              );\n            }\n\n            // Reset message state\n            activeThinkingStep = false;\n            return of(event);\n          }\n\n          default: {\n            return of(event);\n          }\n        }\n      }),\n    );\n  };\n","import { BaseEvent, EventSchemas } from \"@ag-ui/core\";\nimport { Subject, ReplaySubject, Observable } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\nimport { parseSSEStream } from \"./sse\";\nimport { parseProtoStream } from \"./proto\";\nimport * as proto from \"@ag-ui/proto\";\nimport { EventType } from \"@ag-ui/core\";\n\n/**\n * Transforms HTTP events into BaseEvents using the appropriate format parser based on content type.\n */\nexport const transformHttpEventStream = (source$: Observable<HttpEvent>): Observable<BaseEvent> => {\n  const eventSubject = new Subject<BaseEvent>();\n\n  // Use ReplaySubject to buffer events until we decide on the parser\n  const bufferSubject = new ReplaySubject<HttpEvent>();\n\n  // Flag to track whether we've set up the parser\n  let parserInitialized = false;\n\n  // Subscribe to source and buffer events while we determine the content type\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      // Forward event to buffer\n      bufferSubject.next(event);\n\n      // If we get headers and haven't initialized a parser yet, check content type\n      if (event.type === HttpEventType.HEADERS && !parserInitialized) {\n        parserInitialized = true;\n        const contentType = event.headers.get(\"content-type\");\n\n        // Choose parser based on content type\n        if (contentType === proto.AGUI_MEDIA_TYPE) {\n          // Use protocol buffer parser\n          parseProtoStream(bufferSubject).subscribe({\n            next: (event) => eventSubject.next(event),\n            error: (err) => eventSubject.error(err),\n            complete: () => eventSubject.complete(),\n          });\n        } else {\n          // Use SSE JSON parser for all other cases\n          parseSSEStream(bufferSubject).subscribe({\n            next: (json) => {\n              try {\n                const parsedEvent = EventSchemas.parse(json);\n                eventSubject.next(parsedEvent as BaseEvent);\n              } catch (err) {\n                eventSubject.error(err);\n              }\n            },\n            error: (err) => {\n              if ((err as DOMException)?.name === \"AbortError\") {\n                eventSubject.next({\n                  type: EventType.RUN_ERROR,\n                  message: (err as DOMException).message || \"Request aborted\",\n                  code: \"abort\",\n                  rawEvent: err,\n                });\n                eventSubject.complete();\n                return;\n              }\n              return eventSubject.error(err)\n            },\n            complete: () => eventSubject.complete(),\n          });\n        }\n      } else if (!parserInitialized) {\n        eventSubject.error(new Error(\"No headers event received before data events\"));\n      }\n    },\n    error: (err) => {\n      bufferSubject.error(err);\n      eventSubject.error(err);\n    },\n    complete: () => {\n      bufferSubject.complete();\n    },\n  });\n\n  return eventSubject.asObservable();\n};\n","import { Observable, from, defer, throwError } from \"rxjs\";\nimport { mergeMap, switchMap } from \"rxjs/operators\";\n\nexport enum HttpEventType {\n  HEADERS = \"headers\",\n  DATA = \"data\",\n}\n\nexport interface HttpDataEvent {\n  type: HttpEventType.DATA;\n  data?: Uint8Array;\n}\n\nexport interface HttpHeadersEvent {\n  type: HttpEventType.HEADERS;\n  status: number;\n  headers: Headers;\n}\n\nexport type HttpEvent = HttpDataEvent | HttpHeadersEvent;\n\nexport const runHttpRequest = (url: string, requestInit: RequestInit): Observable<HttpEvent> => {\n  // Defer the fetch so that it's executed when subscribed to\n  return defer(() => from(fetch(url, requestInit))).pipe(\n    switchMap((response) => {\n      if (!response.ok) {\n        const contentType = response.headers.get(\"content-type\") || \"\";\n        // Read the (small) error body once, then error the stream\n        return from(response.text()).pipe(\n          mergeMap((text) => {\n            let payload: unknown = text;\n            if (contentType.includes(\"application/json\")) {\n              try { payload = JSON.parse(text); } catch {/* keep raw text */}\n            }\n            const err: any = new Error(\n              `HTTP ${response.status}: ${typeof payload === \"string\" ? payload : JSON.stringify(payload)}`\n            );\n            err.status = response.status;\n            err.payload = payload;\n            return throwError(() => err);\n          })\n        );\n      }\n      // Emit headers event first\n      const headersEvent: HttpHeadersEvent = {\n        type: HttpEventType.HEADERS,\n        status: response.status,\n        headers: response.headers,\n      };\n\n      const reader = response.body?.getReader();\n      if (!reader) {\n        return throwError(() => new Error(\"Failed to getReader() from response\"));\n      }\n\n      return new Observable<HttpEvent>((subscriber) => {\n        // Emit headers event first\n        subscriber.next(headersEvent);\n\n        (async () => {\n          try {\n            while (true) {\n              const { done, value } = await reader.read();\n              if (done) break;\n              // Emit data event instead of raw Uint8Array\n              const dataEvent: HttpDataEvent = {\n                type: HttpEventType.DATA,\n                data: value,\n              };\n              subscriber.next(dataEvent);\n            }\n            subscriber.complete();\n          } catch (error) {\n            subscriber.error(error);\n          }\n        })();\n\n        return () => {\n          reader.cancel().catch((error) => {\n            if ((error as DOMException)?.name === \"AbortError\") {\n              return;\n            }\n\n            throw error;\n          });\n        };\n      });\n    }),\n  );\n};\n","import { Observable, Subject } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\n\n/**\n * Parses a stream of HTTP events into a stream of JSON objects using Server-Sent Events (SSE) format.\n * Strictly follows the SSE standard where:\n * - Events are separated by double newlines ('\\n\\n')\n * - Only 'data:' prefixed lines are processed\n * - Multi-line data events are supported and joined\n * - Non-data fields (event, id, retry) are ignored\n */\nexport const parseSSEStream = (source$: Observable<HttpEvent>): Observable<any> => {\n  const jsonSubject = new Subject<any>();\n  // Create TextDecoder with stream option set to true to handle split UTF-8 characters\n  const decoder = new TextDecoder(\"utf-8\", { fatal: false });\n  let buffer = \"\";\n\n  // Subscribe to the source once and multicast to all subscribers\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      if (event.type === HttpEventType.HEADERS) {\n        return;\n      }\n\n      if (event.type === HttpEventType.DATA && event.data) {\n        // Decode chunk carefully to handle UTF-8\n        const text = decoder.decode(event.data, { stream: true });\n        buffer += text;\n\n        // Process complete events (separated by double newlines)\n        const events = buffer.split(/\\n\\n/);\n        // Keep the last potentially incomplete event in buffer\n        buffer = events.pop() || \"\";\n\n        for (const event of events) {\n          processSSEEvent(event);\n        }\n      }\n    },\n    error: (err) => jsonSubject.error(err),\n    complete: () => {\n      // Use the final call to decoder.decode() to flush any remaining bytes\n      if (buffer) {\n        buffer += decoder.decode();\n        // Process any remaining SSE event data\n        processSSEEvent(buffer);\n      }\n      jsonSubject.complete();\n    },\n  });\n\n  /**\n   * Helper function to process an SSE event.\n   * Extracts and joins data lines, then parses the result as JSON.\n   * \n   * Follows the SSE spec by processing lines starting with 'data:',\n   * ignoring a single space if it is present after the colon.\n   * \n   * @param eventText The raw event text to process\n   */\n  function processSSEEvent(eventText: string) {\n    const lines = eventText.split(\"\\n\");\n    const dataLines: string[] = [];\n\n    for (const line of lines) {\n      if (line.startsWith(\"data:\")) {\n        // Remove 'data:' prefix, and optionally a single space afterwards\n        dataLines.push(line.slice(5).replace(/^ /, \"\"));\n      }\n    }\n\n    // Only process if we have data lines\n    if (dataLines.length > 0) {\n      try {\n        // Join multi-line data and parse JSON\n        const jsonStr = dataLines.join(\"\\n\");\n        const json = JSON.parse(jsonStr);\n        jsonSubject.next(json);\n      } catch (err) {\n        jsonSubject.error(err);\n      }\n    }\n  }\n\n  return jsonSubject.asObservable();\n};\n","import { Observable, Subject } from \"rxjs\";\nimport { HttpEvent, HttpEventType } from \"../run/http-request\";\nimport { BaseEvent } from \"@ag-ui/core\";\nimport * as proto from \"@ag-ui/proto\";\n\n/**\n * Parses a stream of HTTP events into a stream of BaseEvent objects using Protocol Buffer format.\n * Each message is prefixed with a 4-byte length header (uint32 in big-endian format)\n * followed by the protocol buffer encoded message.\n */\nexport const parseProtoStream = (source$: Observable<HttpEvent>): Observable<BaseEvent> => {\n  const eventSubject = new Subject<BaseEvent>();\n  let buffer = new Uint8Array(0);\n\n  source$.subscribe({\n    next: (event: HttpEvent) => {\n      if (event.type === HttpEventType.HEADERS) {\n        return;\n      }\n\n      if (event.type === HttpEventType.DATA && event.data) {\n        // Append the new data to our buffer\n        const newBuffer = new Uint8Array(buffer.length + event.data.length);\n        newBuffer.set(buffer, 0);\n        newBuffer.set(event.data, buffer.length);\n        buffer = newBuffer;\n\n        // Process as many complete messages as possible\n        processBuffer();\n      }\n    },\n    error: (err) => eventSubject.error(err),\n    complete: () => {\n      // Try to process any remaining data in the buffer\n      if (buffer.length > 0) {\n        try {\n          processBuffer();\n        } catch (error: unknown) {\n          console.warn(\"Incomplete or invalid protocol buffer data at stream end\");\n        }\n      }\n      eventSubject.complete();\n    },\n  });\n\n  /**\n   * Process as many complete messages as possible from the buffer\n   */\n  function processBuffer() {\n    // Keep processing while we have enough data for at least a header (4 bytes)\n    while (buffer.length >= 4) {\n      // Read message length from the first 4 bytes (big-endian uint32)\n      const view = new DataView(buffer.buffer, buffer.byteOffset, 4);\n      const messageLength = view.getUint32(0, false); // false = big-endian\n\n      // Check if we have the complete message (header + message body)\n      const totalLength = 4 + messageLength;\n      if (buffer.length < totalLength) {\n        // Not enough data yet, wait for more\n        break;\n      }\n\n      try {\n        // Extract the message (skipping the 4-byte header)\n        const message = buffer.slice(4, totalLength);\n\n        // Decode the protocol buffer message using the imported decode function\n        const event = proto.decode(message);\n\n        // Emit the parsed event\n        eventSubject.next(event);\n\n        // Remove the processed message from the buffer\n        buffer = buffer.slice(totalLength);\n      } catch (error: unknown) {\n        const errorMessage = error instanceof Error ? error.message : String(error);\n        eventSubject.error(new Error(`Failed to decode protocol buffer message: ${errorMessage}`));\n        return;\n      }\n    }\n  }\n\n  return eventSubject.asObservable();\n};\n","import { mergeMap } from \"rxjs/operators\";\nimport { applyPatch } from \"fast-json-patch\";\n\nimport {\n  BaseEvent,\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  CustomEvent,\n  StateSnapshotEvent,\n  StepStartedEvent,\n  Message,\n  StateDeltaEvent,\n  MessagesSnapshotEvent,\n  ToolCall,\n  RunErrorEvent,\n} from \"@ag-ui/core\";\nimport { Observable } from \"rxjs\";\nimport {\n  LegacyTextMessageStart,\n  LegacyTextMessageContent,\n  LegacyTextMessageEnd,\n  LegacyActionExecutionStart,\n  LegacyActionExecutionArgs,\n  LegacyActionExecutionEnd,\n  LegacyRuntimeEventTypes,\n  LegacyRuntimeProtocolEvent,\n  LegacyMetaEvent,\n  LegacyAgentStateMessage,\n  LegacyMessage,\n  LegacyTextMessage,\n  LegacyActionExecutionMessage,\n  LegacyResultMessage,\n  LegacyActionExecutionResult,\n  LegacyRunError\n} from \"./types\";\nimport untruncateJson from \"untruncate-json\";\n\nconst flattenMessageContentToText = (content: Message[\"content\"]) => {\n  if (typeof content === \"string\") {\n    return content;\n  }\n\n  if (!Array.isArray(content)) {\n    return undefined;\n  }\n\n  const textParts = content\n    .filter((part): part is { type: \"text\"; text: string } => part.type === \"text\")\n    .map((part) => part.text)\n    .filter((text) => text.length > 0);\n\n  if (textParts.length === 0) {\n    return undefined;\n  }\n\n  return textParts.join(\"\\n\");\n};\n\ninterface PredictStateValue {\n  state_key: string;\n  tool: string;\n  tool_argument: string;\n}\n\nexport const convertToLegacyEvents =\n  (threadId: string, runId: string, agentName: string) =>\n  (events$: Observable<BaseEvent>): Observable<LegacyRuntimeProtocolEvent> => {\n    let currentState: any = {};\n    let running = true;\n    let active = true;\n    let nodeName = \"\";\n    let syncedMessages: Message[] | null = null;\n    let predictState: PredictStateValue[] | null = null;\n    let currentToolCalls: ToolCall[] = [];\n    let toolCallNames: Record<string, string> = {};\n\n    const updateCurrentState = (newState: any) => {\n      // the legacy protocol will only support object state\n      if (typeof newState === \"object\" && newState !== null) {\n        if (\"messages\" in newState) {\n          delete newState.messages;\n        }\n        currentState = newState;\n      }\n    };\n\n    return events$.pipe(\n      mergeMap((event) => {\n        switch (event.type) {\n          case EventType.TEXT_MESSAGE_START: {\n            const startEvent = event as TextMessageStartEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageStart,\n                messageId: startEvent.messageId,\n                role: startEvent.role,\n              } as LegacyTextMessageStart,\n            ];\n          }\n          case EventType.TEXT_MESSAGE_CONTENT: {\n            const contentEvent = event as TextMessageContentEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageContent,\n                messageId: contentEvent.messageId,\n                content: contentEvent.delta,\n              } as LegacyTextMessageContent,\n            ];\n          }\n          case EventType.TEXT_MESSAGE_END: {\n            const endEvent = event as TextMessageEndEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.TextMessageEnd,\n                messageId: endEvent.messageId,\n              } as LegacyTextMessageEnd,\n            ];\n          }\n          case EventType.TOOL_CALL_START: {\n            const startEvent = event as ToolCallStartEvent;\n\n            currentToolCalls.push({\n              id: startEvent.toolCallId,\n              type: \"function\",\n              function: {\n                name: startEvent.toolCallName,\n                arguments: \"\",\n              },\n            });\n\n            active = true;\n            toolCallNames[startEvent.toolCallId] = startEvent.toolCallName;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionStart,\n                actionExecutionId: startEvent.toolCallId,\n                actionName: startEvent.toolCallName,\n                parentMessageId: startEvent.parentMessageId,\n              } as LegacyActionExecutionStart,\n            ];\n          }\n          case EventType.TOOL_CALL_ARGS: {\n            const argsEvent = event as ToolCallArgsEvent;\n\n            // Find the tool call by ID instead of using the last one\n            const currentToolCall = currentToolCalls.find((tc) => tc.id === argsEvent.toolCallId);\n            if (!currentToolCall) {\n              console.warn(`TOOL_CALL_ARGS: No tool call found with ID '${argsEvent.toolCallId}'`);\n              return [];\n            }\n\n            currentToolCall.function.arguments += argsEvent.delta;\n            let didUpdateState = false;\n\n            if (predictState) {\n              let currentPredictState = predictState.find(\n                (s) => s.tool == currentToolCall.function.name,\n              );\n\n              if (currentPredictState) {\n                try {\n                  const currentArgs = JSON.parse(\n                    untruncateJson(currentToolCall.function.arguments),\n                  );\n                  if (\n                    currentPredictState.tool_argument &&\n                    currentPredictState.tool_argument in currentArgs\n                  ) {\n                    updateCurrentState({\n                      ...currentState,\n                      [currentPredictState.state_key]:\n                        currentArgs[currentPredictState.tool_argument],\n                    });\n                    didUpdateState = true;\n                  } else if (!currentPredictState.tool_argument) {\n                    updateCurrentState({\n                      ...currentState,\n                      [currentPredictState.state_key]: currentArgs,\n                    });\n                    didUpdateState = true;\n                  }\n                } catch (e) {}\n              }\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionArgs,\n                actionExecutionId: argsEvent.toolCallId,\n                args: argsEvent.delta,\n              } as LegacyActionExecutionArgs,\n              ...(didUpdateState\n                ? [\n                    {\n                      type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                      threadId,\n                      agentName,\n                      nodeName,\n                      runId,\n                      running,\n                      role: \"assistant\",\n                      state: JSON.stringify(currentState),\n                      active,\n                    },\n                  ]\n                : []),\n            ];\n          }\n          case EventType.TOOL_CALL_END: {\n            const endEvent = event as ToolCallEndEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionEnd,\n                actionExecutionId: endEvent.toolCallId,\n              } as LegacyActionExecutionEnd,\n            ];\n          }\n          case EventType.TOOL_CALL_RESULT: {\n            const resultEvent = event as ToolCallResultEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.ActionExecutionResult,\n                actionExecutionId: resultEvent.toolCallId,\n                result: resultEvent.content,\n                actionName: toolCallNames[resultEvent.toolCallId] || \"unknown\",\n              } as LegacyActionExecutionResult,\n            ];\n          }\n          case EventType.RAW: {\n            // The legacy protocol doesn't support raw events\n            return [];\n          }\n          case EventType.CUSTOM: {\n            const customEvent = event as CustomEvent;\n            switch (customEvent.name) {\n              case \"Exit\":\n                running = false;\n                break;\n              case \"PredictState\":\n                predictState = customEvent.value as PredictStateValue[];\n                break;\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.MetaEvent,\n                name: customEvent.name,\n                value: customEvent.value,\n              } as LegacyMetaEvent,\n            ];\n          }\n          case EventType.STATE_SNAPSHOT: {\n            const stateEvent = event as StateSnapshotEvent;\n            updateCurrentState(stateEvent.snapshot);\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.STATE_DELTA: {\n            const deltaEvent = event as StateDeltaEvent;\n            const result = applyPatch(currentState, deltaEvent.delta, true, false);\n            if (!result) {\n              return [];\n            }\n            updateCurrentState(result.newDocument);\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.MESSAGES_SNAPSHOT: {\n            const messagesSnapshot = event as MessagesSnapshotEvent;\n            syncedMessages = messagesSnapshot.messages;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify({\n                  ...currentState,\n                  ...(syncedMessages ? { messages: syncedMessages } : {}),\n                }),\n                active: true,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.RUN_STARTED: {\n            // There is nothing to do in the legacy protocol\n            return [];\n          }\n          case EventType.RUN_FINISHED: {\n            if (syncedMessages) {\n              currentState.messages = syncedMessages;\n            }\n\n            // Only do an update if state is not empty\n            if (Object.keys(currentState).length === 0) {\n              return [];\n            }\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify({\n                  ...currentState,\n                  ...(syncedMessages\n                    ? {\n                        messages: convertMessagesToLegacyFormat(syncedMessages),\n                      }\n                    : {}),\n                }),\n                active: false,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.RUN_ERROR: {\n            const errorEvent = event as RunErrorEvent;\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.RunError,\n                message: errorEvent.message,\n                code: errorEvent.code,\n              } as LegacyRunError,\n            ];\n          }\n          case EventType.STEP_STARTED: {\n            const stepStarted = event as StepStartedEvent;\n            nodeName = stepStarted.stepName;\n\n            currentToolCalls = [];\n            predictState = null;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active: true,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          case EventType.STEP_FINISHED: {\n            currentToolCalls = [];\n            predictState = null;\n\n            return [\n              {\n                type: LegacyRuntimeEventTypes.enum.AgentStateMessage,\n                threadId,\n                agentName,\n                nodeName,\n                runId,\n                running,\n                role: \"assistant\",\n                state: JSON.stringify(currentState),\n                active: false,\n              } as LegacyAgentStateMessage,\n            ];\n          }\n          default: {\n            return [];\n          }\n        }\n      }),\n    );\n  };\n\nexport function convertMessagesToLegacyFormat(messages: Message[]): LegacyMessage[] {\n  const result: LegacyMessage[] = [];\n\n  for (const message of messages) {\n    if (message.role === \"assistant\" || message.role === \"user\" || message.role === \"system\") {\n      const textContent = flattenMessageContentToText(message.content);\n      if (textContent) {\n        const textMessage: LegacyTextMessage = {\n          id: message.id,\n          role: message.role,\n          content: textContent,\n        };\n        result.push(textMessage);\n      }\n      if (message.role === \"assistant\" && message.toolCalls && message.toolCalls.length > 0) {\n        for (const toolCall of message.toolCalls) {\n          const actionExecutionMessage: LegacyActionExecutionMessage = {\n            id: toolCall.id,\n            name: toolCall.function.name,\n            arguments: JSON.parse(toolCall.function.arguments),\n            parentMessageId: message.id,\n          };\n          result.push(actionExecutionMessage);\n        }\n      }\n    } else if (message.role === \"tool\") {\n      let actionName = \"unknown\";\n      for (const m of messages) {\n        if (m.role === \"assistant\" && m.toolCalls?.length) {\n          for (const toolCall of m.toolCalls) {\n            if (toolCall.id === message.toolCallId) {\n              actionName = toolCall.function.name;\n              break;\n            }\n          }\n        }\n      }\n      const toolMessage: LegacyResultMessage = {\n        id: message.id,\n        result: message.content,\n        actionExecutionId: message.toolCallId,\n        actionName,\n      };\n      result.push(toolMessage);\n    }\n  }\n\n  return result;\n}\n","import { z } from \"zod\";\n\n// Protocol Events\nexport const LegacyRuntimeEventTypes = z.enum([\n  \"TextMessageStart\",\n  \"TextMessageContent\",\n  \"TextMessageEnd\",\n  \"ActionExecutionStart\",\n  \"ActionExecutionArgs\",\n  \"ActionExecutionEnd\",\n  \"ActionExecutionResult\",\n  \"AgentStateMessage\",\n  \"MetaEvent\",\n  \"RunStarted\",\n  \"RunFinished\",\n  \"RunError\",\n  \"NodeStarted\",\n  \"NodeFinished\",\n]);\n\nexport const LegacyRuntimeMetaEventName = z.enum([\n  \"LangGraphInterruptEvent\",\n  \"PredictState\",\n  \"Exit\",\n]);\n\nexport const LegacyTextMessageStart = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageStart),\n  messageId: z.string(),\n  parentMessageId: z.string().optional(),\n  role: z.string().optional(),\n});\n\nexport const LegacyTextMessageContent = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageContent),\n  messageId: z.string(),\n  content: z.string(),\n});\n\nexport const LegacyTextMessageEnd = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.TextMessageEnd),\n  messageId: z.string(),\n});\n\nexport const LegacyActionExecutionStart = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionStart),\n  actionExecutionId: z.string(),\n  actionName: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyActionExecutionArgs = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionArgs),\n  actionExecutionId: z.string(),\n  args: z.string(),\n});\n\nexport const LegacyActionExecutionEnd = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionEnd),\n  actionExecutionId: z.string(),\n});\n\nexport const LegacyActionExecutionResult = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.ActionExecutionResult),\n  actionName: z.string(),\n  actionExecutionId: z.string(),\n  result: z.string(),\n});\n\nexport const LegacyAgentStateMessage = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.AgentStateMessage),\n  threadId: z.string(),\n  agentName: z.string(),\n  nodeName: z.string(),\n  runId: z.string(),\n  active: z.boolean(),\n  role: z.string(),\n  state: z.string(),\n  running: z.boolean(),\n});\n\nexport const LegacyMetaEvent = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.MetaEvent),\n  name: LegacyRuntimeMetaEventName,\n  value: z.any(),\n});\n\n\nexport const LegacyRunError = z.object({\n  type: z.literal(LegacyRuntimeEventTypes.enum.RunError),\n  message: z.string(),\n  code: z.string().optional(),\n});\n\nexport const LegacyRuntimeProtocolEvent = z.discriminatedUnion(\"type\", [\n  LegacyTextMessageStart,\n  LegacyTextMessageContent,\n  LegacyTextMessageEnd,\n  LegacyActionExecutionStart,\n  LegacyActionExecutionArgs,\n  LegacyActionExecutionEnd,\n  LegacyActionExecutionResult,\n  LegacyAgentStateMessage,\n  LegacyMetaEvent,\n  LegacyRunError,\n]);\n\n// Protocol Event type exports\nexport type RuntimeEventTypes = z.infer<typeof LegacyRuntimeEventTypes>;\nexport type RuntimeMetaEventName = z.infer<typeof LegacyRuntimeMetaEventName>;\nexport type LegacyTextMessageStart = z.infer<typeof LegacyTextMessageStart>;\nexport type LegacyTextMessageContent = z.infer<typeof LegacyTextMessageContent>;\nexport type LegacyTextMessageEnd = z.infer<typeof LegacyTextMessageEnd>;\nexport type LegacyActionExecutionStart = z.infer<typeof LegacyActionExecutionStart>;\nexport type LegacyActionExecutionArgs = z.infer<typeof LegacyActionExecutionArgs>;\nexport type LegacyActionExecutionEnd = z.infer<typeof LegacyActionExecutionEnd>;\nexport type LegacyActionExecutionResult = z.infer<typeof LegacyActionExecutionResult>;\nexport type LegacyAgentStateMessage = z.infer<typeof LegacyAgentStateMessage>;\nexport type LegacyMetaEvent = z.infer<typeof LegacyMetaEvent>;\nexport type LegacyRuntimeProtocolEvent = z.infer<typeof LegacyRuntimeProtocolEvent>;\nexport type LegacyRunError = z.infer<typeof LegacyRunError>;\n\n// Message schemas (with kind discriminator)\nexport const LegacyTextMessageSchema = z.object({\n  id: z.string(),\n  role: z.string(),\n  content: z.string(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyActionExecutionMessageSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  arguments: z.any(),\n  parentMessageId: z.string().optional(),\n});\n\nexport const LegacyResultMessageSchema = z.object({\n  id: z.string(),\n  result: z.any(),\n  actionExecutionId: z.string(),\n  actionName: z.string(),\n});\n\n// Message type exports\nexport type LegacyTextMessage = z.infer<typeof LegacyTextMessageSchema>;\nexport type LegacyActionExecutionMessage = z.infer<typeof LegacyActionExecutionMessageSchema>;\nexport type LegacyResultMessage = z.infer<typeof LegacyResultMessageSchema>;\nexport type LegacyMessage = LegacyTextMessage | LegacyActionExecutionMessage | LegacyResultMessage;\n","import { defaultApplyEvents } from \"@/apply/default\";\nimport { Message, State, RunAgentInput, BaseEvent, ToolCall, AssistantMessage } from \"@ag-ui/core\";\n\nimport { AgentConfig, RunAgentParameters } from \"./types\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { structuredClone_ } from \"@/utils\";\nimport { compareVersions } from \"compare-versions\";\nimport { catchError, map, tap } from \"rxjs/operators\";\nimport { finalize } from \"rxjs/operators\";\nimport { takeUntil } from \"rxjs/operators\";\nimport { pipe, Observable, from, of, EMPTY, Subject } from \"rxjs\";\nimport { verifyEvents } from \"@/verify\";\nimport { convertToLegacyEvents } from \"@/legacy/convert\";\nimport { LegacyRuntimeProtocolEvent } from \"@/legacy/types\";\nimport { lastValueFrom } from \"rxjs\";\nimport { transformChunks } from \"@/chunks\";\nimport { AgentStateMutation, AgentSubscriber, runSubscribersWithMutation } from \"./subscriber\";\nimport { AGUIConnectNotImplementedError } from \"@ag-ui/core\";\nimport {\n  Middleware,\n  MiddlewareFunction,\n  FunctionMiddleware,\n  BackwardCompatibility_0_0_39,\n} from \"@/middleware\";\nimport packageJson from \"../../package.json\";\n\nexport interface RunAgentResult {\n  result: any;\n  newMessages: Message[];\n}\n\nexport abstract class AbstractAgent {\n  public agentId?: string;\n  public description: string;\n  public threadId: string;\n  public messages: Message[];\n  public state: State;\n  public debug: boolean = false;\n  public subscribers: AgentSubscriber[] = [];\n  public isRunning: boolean = false;\n  private middlewares: Middleware[] = [];\n  // Emits to immediately detach from the active run (stop processing its stream)\n  private activeRunDetach$?: Subject<void>;\n  private activeRunCompletionPromise?: Promise<void>;\n\n  get maxVersion() {\n    return packageJson.version;\n  }\n\n  constructor({\n    agentId,\n    description,\n    threadId,\n    initialMessages,\n    initialState,\n    debug,\n  }: AgentConfig = {}) {\n    this.agentId = agentId;\n    this.description = description ?? \"\";\n    this.threadId = threadId ?? uuidv4();\n    this.messages = structuredClone_(initialMessages ?? []);\n    this.state = structuredClone_(initialState ?? {});\n    this.debug = debug ?? false;\n\n    if (compareVersions(this.maxVersion, \"0.0.39\") <= 0) {\n      this.middlewares.unshift(new BackwardCompatibility_0_0_39());\n    }\n  }\n\n  public subscribe(subscriber: AgentSubscriber) {\n    this.subscribers.push(subscriber);\n    return {\n      unsubscribe: () => {\n        this.subscribers = this.subscribers.filter((s) => s !== subscriber);\n      },\n    };\n  }\n\n  abstract run(input: RunAgentInput): Observable<BaseEvent>;\n\n  public use(...middlewares: (Middleware | MiddlewareFunction)[]): this {\n    const normalizedMiddlewares = middlewares.map((middleware) =>\n      typeof middleware === \"function\" ? new FunctionMiddleware(middleware) : middleware,\n    );\n    this.middlewares.push(...normalizedMiddlewares);\n    return this;\n  }\n\n  public async runAgent(\n    parameters?: RunAgentParameters,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    try {\n      this.isRunning = true;\n      this.agentId = this.agentId ?? uuidv4();\n      const input = this.prepareRunAgentInput(parameters);\n      let result: any = undefined;\n      const currentMessageIds = new Set(this.messages.map((message) => message.id));\n\n      const subscribers: AgentSubscriber[] = [\n        {\n          onRunFinishedEvent: (params) => {\n            result = params.result;\n          },\n        },\n        ...this.subscribers,\n        subscriber ?? {},\n      ];\n\n      await this.onInitialize(input, subscribers);\n\n      // Per-run detachment signal + completion promise\n      this.activeRunDetach$ = new Subject<void>();\n      let resolveActiveRunCompletion: (() => void) | undefined;\n      this.activeRunCompletionPromise = new Promise<void>((resolve) => {\n        resolveActiveRunCompletion = resolve;\n      });\n\n      const pipeline = pipe(\n        () => {\n          // Build middleware chain using reduceRight so middlewares can intercept runs.\n          if (this.middlewares.length === 0) {\n            return this.run(input);\n          }\n\n          const chainedAgent = this.middlewares.reduceRight(\n            (nextAgent: AbstractAgent, middleware) =>\n              ({\n                run: (i: RunAgentInput) => middleware.run(i, nextAgent),\n              }) as AbstractAgent,\n            this, // Original agent is the final 'next'\n          );\n\n          return chainedAgent.run(input);\n        },\n        transformChunks(this.debug),\n        verifyEvents(this.debug),\n        // Stop processing immediately when this run is detached\n        (source$) => source$.pipe(takeUntil(this.activeRunDetach$!)),\n        (source$) => this.apply(input, source$, subscribers),\n        (source$) => this.processApplyEvents(input, source$, subscribers),\n        catchError((error) => {\n          this.isRunning = false;\n          return this.onError(input, error, subscribers);\n        }),\n        finalize(() => {\n          this.isRunning = false;\n          void this.onFinalize(input, subscribers);\n          resolveActiveRunCompletion?.();\n          resolveActiveRunCompletion = undefined;\n          this.activeRunCompletionPromise = undefined;\n          this.activeRunDetach$ = undefined;\n        }),\n      );\n\n      await lastValueFrom(pipeline(of(null)));\n      const newMessages = structuredClone_(this.messages).filter(\n        (message: Message) => !currentMessageIds.has(message.id),\n      );\n      return { result, newMessages };\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  protected connect(input: RunAgentInput): Observable<BaseEvent> {\n    throw new AGUIConnectNotImplementedError();\n  }\n  public async connectAgent(\n    parameters?: RunAgentParameters,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    try {\n      this.isRunning = true;\n      this.agentId = this.agentId ?? uuidv4();\n      const input = this.prepareRunAgentInput(parameters);\n      let result: any = undefined;\n      const currentMessageIds = new Set(this.messages.map((message) => message.id));\n\n      const subscribers: AgentSubscriber[] = [\n        {\n          onRunFinishedEvent: (params) => {\n            result = params.result;\n          },\n        },\n        ...this.subscribers,\n        subscriber ?? {},\n      ];\n\n      await this.onInitialize(input, subscribers);\n\n      // Per-run detachment signal + completion promise\n      this.activeRunDetach$ = new Subject<void>();\n      let resolveActiveRunCompletion: (() => void) | undefined;\n      this.activeRunCompletionPromise = new Promise<void>((resolve) => {\n        resolveActiveRunCompletion = resolve;\n      });\n\n      const pipeline = pipe(\n        () => this.connect(input),\n        transformChunks(this.debug),\n        verifyEvents(this.debug),\n        // Stop processing immediately when this run is detached\n        (source$) => source$.pipe(takeUntil(this.activeRunDetach$!)),\n        (source$) => this.apply(input, source$, subscribers),\n        (source$) => this.processApplyEvents(input, source$, subscribers),\n        catchError((error) => {\n          this.isRunning = false;\n          if (!(error instanceof AGUIConnectNotImplementedError)) {\n            return this.onError(input, error, subscribers);\n          }\n          return EMPTY;\n        }),\n        finalize(() => {\n          this.isRunning = false;\n          void this.onFinalize(input, subscribers);\n          resolveActiveRunCompletion?.();\n          resolveActiveRunCompletion = undefined;\n          this.activeRunCompletionPromise = undefined;\n          this.activeRunDetach$ = undefined;\n        }),\n      );\n\n      await lastValueFrom(pipeline(of(null))); // wait for stream completion before toggling isRunning\n      const newMessages = structuredClone_(this.messages).filter(\n        (message: Message) => !currentMessageIds.has(message.id),\n      );\n      return { result, newMessages };\n    } finally {\n      this.isRunning = false;\n    }\n  }\n\n  public abortRun() {}\n\n  public async detachActiveRun(): Promise<void> {\n    if (!this.activeRunDetach$) {\n      return;\n    }\n    const completion = this.activeRunCompletionPromise ?? Promise.resolve();\n    this.activeRunDetach$.next();\n    this.activeRunDetach$?.complete();\n    await completion;\n  }\n\n  protected apply(\n    input: RunAgentInput,\n    events$: Observable<BaseEvent>,\n    subscribers: AgentSubscriber[],\n  ): Observable<AgentStateMutation> {\n    return defaultApplyEvents(input, events$, this, subscribers);\n  }\n\n  protected processApplyEvents(\n    input: RunAgentInput,\n    events$: Observable<AgentStateMutation>,\n    subscribers: AgentSubscriber[],\n  ): Observable<AgentStateMutation> {\n    return events$.pipe(\n      tap((event) => {\n        if (event.messages) {\n          this.messages = event.messages;\n          subscribers.forEach((subscriber) => {\n            subscriber.onMessagesChanged?.({\n              messages: this.messages,\n              state: this.state,\n              agent: this,\n              input,\n            });\n          });\n        }\n        if (event.state) {\n          this.state = event.state;\n          subscribers.forEach((subscriber) => {\n            subscriber.onStateChanged?.({\n              state: this.state,\n              messages: this.messages,\n              agent: this,\n              input,\n            });\n          });\n        }\n      }),\n    );\n  }\n\n  protected prepareRunAgentInput(parameters?: RunAgentParameters): RunAgentInput {\n    const clonedMessages = structuredClone_(this.messages) as Message[];\n    const messagesWithoutActivity = clonedMessages.filter((message) => message.role !== \"activity\");\n\n    return {\n      threadId: this.threadId,\n      runId: parameters?.runId || uuidv4(),\n      tools: structuredClone_(parameters?.tools ?? []),\n      context: structuredClone_(parameters?.context ?? []),\n      forwardedProps: structuredClone_(parameters?.forwardedProps ?? {}),\n      state: structuredClone_(this.state),\n      messages: messagesWithoutActivity,\n    };\n  }\n\n  protected async onInitialize(input: RunAgentInput, subscribers: AgentSubscriber[]) {\n    const onRunInitializedMutation = await runSubscribersWithMutation(\n      subscribers,\n      this.messages,\n      this.state,\n      (subscriber, messages, state) =>\n        subscriber.onRunInitialized?.({ messages, state, agent: this, input }),\n    );\n    if (\n      onRunInitializedMutation.messages !== undefined ||\n      onRunInitializedMutation.state !== undefined\n    ) {\n      if (onRunInitializedMutation.messages) {\n        this.messages = onRunInitializedMutation.messages;\n        input.messages = onRunInitializedMutation.messages;\n        subscribers.forEach((subscriber) => {\n          subscriber.onMessagesChanged?.({\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n            input,\n          });\n        });\n      }\n      if (onRunInitializedMutation.state) {\n        this.state = onRunInitializedMutation.state;\n        input.state = onRunInitializedMutation.state;\n        subscribers.forEach((subscriber) => {\n          subscriber.onStateChanged?.({\n            state: this.state,\n            messages: this.messages,\n            agent: this,\n            input,\n          });\n        });\n      }\n    }\n  }\n\n  protected onError(input: RunAgentInput, error: Error, subscribers: AgentSubscriber[]) {\n    return from(\n      runSubscribersWithMutation(\n        subscribers,\n        this.messages,\n        this.state,\n        (subscriber, messages, state) =>\n          subscriber.onRunFailed?.({ error, messages, state, agent: this, input }),\n      ),\n    ).pipe(\n      map((onRunFailedMutation) => {\n        const mutation = onRunFailedMutation as AgentStateMutation;\n        if (mutation.messages !== undefined || mutation.state !== undefined) {\n          if (mutation.messages !== undefined) {\n            this.messages = mutation.messages;\n            subscribers.forEach((subscriber) => {\n              subscriber.onMessagesChanged?.({\n                messages: this.messages,\n                state: this.state,\n                agent: this,\n                input,\n              });\n            });\n          }\n          if (mutation.state !== undefined) {\n            this.state = mutation.state;\n            subscribers.forEach((subscriber) => {\n              subscriber.onStateChanged?.({\n                state: this.state,\n                messages: this.messages,\n                agent: this,\n                input,\n              });\n            });\n          }\n        }\n\n        if (mutation.stopPropagation !== true) {\n          console.error(\"Agent execution failed:\", error);\n          throw error;\n        }\n\n        // Return an empty mutation instead of null to prevent EmptyError\n        return {} as AgentStateMutation;\n      }),\n    );\n  }\n\n  protected async onFinalize(input: RunAgentInput, subscribers: AgentSubscriber[]) {\n    const onRunFinalizedMutation = await runSubscribersWithMutation(\n      subscribers,\n      this.messages,\n      this.state,\n      (subscriber, messages, state) =>\n        subscriber.onRunFinalized?.({ messages, state, agent: this, input }),\n    );\n\n    if (\n      onRunFinalizedMutation.messages !== undefined ||\n      onRunFinalizedMutation.state !== undefined\n    ) {\n      if (onRunFinalizedMutation.messages !== undefined) {\n        this.messages = onRunFinalizedMutation.messages;\n        subscribers.forEach((subscriber) => {\n          subscriber.onMessagesChanged?.({\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n            input,\n          });\n        });\n      }\n      if (onRunFinalizedMutation.state !== undefined) {\n        this.state = onRunFinalizedMutation.state;\n        subscribers.forEach((subscriber) => {\n          subscriber.onStateChanged?.({\n            state: this.state,\n            messages: this.messages,\n            agent: this,\n            input,\n          });\n        });\n      }\n    }\n  }\n\n  public clone() {\n    const cloned = Object.create(Object.getPrototypeOf(this));\n\n    cloned.agentId = this.agentId;\n    cloned.description = this.description;\n    cloned.threadId = this.threadId;\n    cloned.messages = structuredClone_(this.messages);\n    cloned.state = structuredClone_(this.state);\n    cloned.debug = this.debug;\n    cloned.isRunning = this.isRunning;\n    cloned.subscribers = [...this.subscribers];\n    cloned.middlewares = [...this.middlewares];\n\n    return cloned;\n  }\n\n  public addMessage(message: Message) {\n    // Add message to the messages array\n    this.messages.push(message);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onNewMessage sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onNewMessage?.({\n          message,\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n\n      // Fire onNewToolCall if the message is from assistant and contains tool calls\n      if (message.role === \"assistant\" && message.toolCalls) {\n        for (const toolCall of message.toolCalls) {\n          for (const subscriber of this.subscribers) {\n            await subscriber.onNewToolCall?.({\n              toolCall,\n              messages: this.messages,\n              state: this.state,\n              agent: this,\n            });\n          }\n        }\n      }\n\n      // Fire onMessagesChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public addMessages(messages: Message[]) {\n    // Add all messages to the messages array\n    this.messages.push(...messages);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onNewMessage and onNewToolCall for each message sequentially\n      for (const message of messages) {\n        // Fire onNewMessage sequentially\n        for (const subscriber of this.subscribers) {\n          await subscriber.onNewMessage?.({\n            message,\n            messages: this.messages,\n            state: this.state,\n            agent: this,\n          });\n        }\n\n        // Fire onNewToolCall if the message is from assistant and contains tool calls\n        if (message.role === \"assistant\" && message.toolCalls) {\n          for (const toolCall of message.toolCalls) {\n            for (const subscriber of this.subscribers) {\n              await subscriber.onNewToolCall?.({\n                toolCall,\n                messages: this.messages,\n                state: this.state,\n                agent: this,\n              });\n            }\n          }\n        }\n      }\n\n      // Fire onMessagesChanged once at the end sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public setMessages(messages: Message[]) {\n    // Replace the entire messages array\n    this.messages = structuredClone_(messages);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onMessagesChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onMessagesChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public setState(state: State) {\n    // Replace the entire state\n    this.state = structuredClone_(state);\n\n    // Notify subscribers sequentially in the background\n    (async () => {\n      // Fire onStateChanged sequentially\n      for (const subscriber of this.subscribers) {\n        await subscriber.onStateChanged?.({\n          messages: this.messages,\n          state: this.state,\n          agent: this,\n        });\n      }\n    })();\n  }\n\n  public legacy_to_be_removed_runAgentBridged(\n    config?: RunAgentParameters,\n  ): Observable<LegacyRuntimeProtocolEvent> {\n    this.agentId = this.agentId ?? uuidv4();\n    const input = this.prepareRunAgentInput(config);\n\n    // Build middleware chain for legacy bridge\n    const runObservable = (() => {\n      if (this.middlewares.length === 0) {\n        return this.run(input);\n      }\n\n      const chainedAgent = this.middlewares.reduceRight(\n        (nextAgent: AbstractAgent, middleware) =>\n          ({\n            run: (i: RunAgentInput) => middleware.run(i, nextAgent),\n          }) as AbstractAgent,\n        this,\n      );\n\n      return chainedAgent.run(input);\n    })();\n\n    return runObservable.pipe(\n      transformChunks(this.debug),\n      verifyEvents(this.debug),\n      convertToLegacyEvents(this.threadId, input.runId, this.agentId),\n      (events$: Observable<LegacyRuntimeProtocolEvent>) => {\n        return events$.pipe(\n          map((event) => {\n            if (this.debug) {\n              console.debug(\"[LEGACY]:\", JSON.stringify(event));\n            }\n            return event;\n          }),\n        );\n      },\n    );\n  }\n}\n","import { mergeMap, Observable, finalize } from \"rxjs\";\nimport {\n  BaseEvent,\n  TextMessageChunkEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  TextMessageStartEvent,\n  ToolCallArgsEvent,\n  ToolCallChunkEvent,\n  ToolCallEndEvent,\n  ToolCallStartEvent,\n} from \"@ag-ui/core\";\nimport { EventType } from \"@ag-ui/core\";\n\ninterface TextMessageFields {\n  messageId: string;\n}\n\ninterface ToolCallFields {\n  toolCallId: string;\n  toolCallName: string;\n  parentMessageId?: string;\n}\n\nexport const transformChunks =\n  (debug: boolean) =>\n  (events$: Observable<BaseEvent>): Observable<BaseEvent> => {\n    let textMessageFields: TextMessageFields | undefined;\n    let toolCallFields: ToolCallFields | undefined;\n    let mode: \"text\" | \"tool\" | undefined;\n\n    const closeTextMessage = () => {\n      if (!textMessageFields || mode !== \"text\") {\n        throw new Error(\"No text message to close\");\n      }\n      const event = {\n        type: EventType.TEXT_MESSAGE_END,\n        messageId: textMessageFields.messageId,\n      } as TextMessageEndEvent;\n      mode = undefined;\n      textMessageFields = undefined;\n\n      if (debug) {\n        console.debug(\"[TRANSFORM]: TEXT_MESSAGE_END\", JSON.stringify(event));\n      }\n\n      return event;\n    };\n\n    const closeToolCall = () => {\n      if (!toolCallFields || mode !== \"tool\") {\n        throw new Error(\"No tool call to close\");\n      }\n      const event = {\n        type: EventType.TOOL_CALL_END,\n        toolCallId: toolCallFields.toolCallId,\n      } as ToolCallEndEvent;\n      mode = undefined;\n      toolCallFields = undefined;\n\n      if (debug) {\n        console.debug(\"[TRANSFORM]: TOOL_CALL_END\", JSON.stringify(event));\n      }\n\n      return event;\n    };\n\n    const closePendingEvent = () => {\n      if (mode === \"text\") {\n        return [closeTextMessage()];\n      }\n      if (mode === \"tool\") {\n        return [closeToolCall()];\n      }\n      return [];\n    };\n\n    return events$.pipe(\n      mergeMap((event) => {\n        switch (event.type) {\n          case EventType.TEXT_MESSAGE_START:\n          case EventType.TEXT_MESSAGE_CONTENT:\n          case EventType.TEXT_MESSAGE_END:\n          case EventType.TOOL_CALL_START:\n          case EventType.TOOL_CALL_ARGS:\n          case EventType.TOOL_CALL_END:\n          case EventType.TOOL_CALL_RESULT:\n          case EventType.STATE_SNAPSHOT:\n          case EventType.STATE_DELTA:\n          case EventType.MESSAGES_SNAPSHOT:\n          case EventType.CUSTOM:\n          case EventType.RUN_STARTED:\n          case EventType.RUN_FINISHED:\n          case EventType.RUN_ERROR:\n          case EventType.STEP_STARTED:\n          case EventType.STEP_FINISHED:\n          case EventType.THINKING_START:\n          case EventType.THINKING_END:\n          case EventType.THINKING_TEXT_MESSAGE_START:\n          case EventType.THINKING_TEXT_MESSAGE_CONTENT:\n          case EventType.THINKING_TEXT_MESSAGE_END:\n            return [...closePendingEvent(), event];\n          case EventType.RAW:\n          case EventType.ACTIVITY_SNAPSHOT:\n          case EventType.ACTIVITY_DELTA:\n            return [event];\n          case EventType.TEXT_MESSAGE_CHUNK:\n            const messageChunkEvent = event as TextMessageChunkEvent;\n            const textMessageResult = [];\n            if (\n              // we are not in a text message\n              mode !== \"text\" ||\n              // or the message id is different\n              (messageChunkEvent.messageId !== undefined &&\n                messageChunkEvent.messageId !== textMessageFields?.messageId)\n            ) {\n              // close the current message if any\n              textMessageResult.push(...closePendingEvent());\n            }\n\n            // we are not in a text message, start a new one\n            if (mode !== \"text\") {\n              if (messageChunkEvent.messageId === undefined) {\n                throw new Error(\"First TEXT_MESSAGE_CHUNK must have a messageId\");\n              }\n\n              textMessageFields = {\n                messageId: messageChunkEvent.messageId,\n              };\n              mode = \"text\";\n\n              const textMessageStartEvent = {\n                type: EventType.TEXT_MESSAGE_START,\n                messageId: messageChunkEvent.messageId,\n                role: messageChunkEvent.role || \"assistant\",\n              } as TextMessageStartEvent;\n\n              textMessageResult.push(textMessageStartEvent);\n\n              if (debug) {\n                console.debug(\n                  \"[TRANSFORM]: TEXT_MESSAGE_START\",\n                  JSON.stringify(textMessageStartEvent),\n                );\n              }\n            }\n\n            if (messageChunkEvent.delta !== undefined) {\n              const textMessageContentEvent = {\n                type: EventType.TEXT_MESSAGE_CONTENT,\n                messageId: textMessageFields!.messageId,\n                delta: messageChunkEvent.delta,\n              } as TextMessageContentEvent;\n\n              textMessageResult.push(textMessageContentEvent);\n\n              if (debug) {\n                console.debug(\n                  \"[TRANSFORM]: TEXT_MESSAGE_CONTENT\",\n                  JSON.stringify(textMessageContentEvent),\n                );\n              }\n            }\n\n            return textMessageResult;\n          case EventType.TOOL_CALL_CHUNK:\n            const toolCallChunkEvent = event as ToolCallChunkEvent;\n            const toolMessageResult = [];\n            if (\n              // we are not in a text message\n              mode !== \"tool\" ||\n              // or the tool call id is different\n              (toolCallChunkEvent.toolCallId !== undefined &&\n                toolCallChunkEvent.toolCallId !== toolCallFields?.toolCallId)\n            ) {\n              // close the current message if any\n              toolMessageResult.push(...closePendingEvent());\n            }\n\n            if (mode !== \"tool\") {\n              if (toolCallChunkEvent.toolCallId === undefined) {\n                throw new Error(\"First TOOL_CALL_CHUNK must have a toolCallId\");\n              }\n              if (toolCallChunkEvent.toolCallName === undefined) {\n                throw new Error(\"First TOOL_CALL_CHUNK must have a toolCallName\");\n              }\n              toolCallFields = {\n                toolCallId: toolCallChunkEvent.toolCallId,\n                toolCallName: toolCallChunkEvent.toolCallName,\n                parentMessageId: toolCallChunkEvent.parentMessageId,\n              };\n              mode = \"tool\";\n\n              const toolCallStartEvent = {\n                type: EventType.TOOL_CALL_START,\n                toolCallId: toolCallChunkEvent.toolCallId,\n                toolCallName: toolCallChunkEvent.toolCallName,\n                parentMessageId: toolCallChunkEvent.parentMessageId,\n              } as ToolCallStartEvent;\n\n              toolMessageResult.push(toolCallStartEvent);\n\n              if (debug) {\n                console.debug(\"[TRANSFORM]: TOOL_CALL_START\", JSON.stringify(toolCallStartEvent));\n              }\n            }\n\n            if (toolCallChunkEvent.delta !== undefined) {\n              const toolCallArgsEvent = {\n                type: EventType.TOOL_CALL_ARGS,\n                toolCallId: toolCallFields!.toolCallId,\n                delta: toolCallChunkEvent.delta,\n              } as ToolCallArgsEvent;\n\n              toolMessageResult.push(toolCallArgsEvent);\n\n              if (debug) {\n                console.debug(\"[TRANSFORM]: TOOL_CALL_ARGS\", JSON.stringify(toolCallArgsEvent));\n              }\n            }\n\n            return toolMessageResult;\n        }\n        const _exhaustiveCheck: never = event.type;\n        return [];\n      }),\n      finalize(() => {\n        // This ensures that we close any pending events when the source observable completes\n        closePendingEvent();\n      }),\n    );\n  };\n","import { AbstractAgent } from \"@/agent\";\nimport { RunAgentInput, BaseEvent, Message } from \"@ag-ui/core\";\nimport { Observable, ReplaySubject } from \"rxjs\";\nimport { concatMap } from \"rxjs/operators\";\nimport { transformChunks } from \"@/chunks\";\nimport { defaultApplyEvents } from \"@/apply\";\nimport { structuredClone_ } from \"@/utils\";\n\nexport type MiddlewareFunction = (\n  input: RunAgentInput,\n  next: AbstractAgent,\n) => Observable<BaseEvent>;\n\nexport interface EventWithState {\n  event: BaseEvent;\n  messages: Message[];\n  state: any;\n}\n\nexport abstract class Middleware {\n  abstract run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent>;\n\n  /**\n   * Runs the next agent in the chain with automatic chunk transformation.\n   */\n  protected runNext(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    return next.run(input).pipe(\n      transformChunks(false), // Always transform chunks to full events\n    );\n  }\n\n  /**\n   * Runs the next agent and tracks state, providing current messages and state with each event.\n   * The messages and state represent the state AFTER the event has been applied.\n   */\n  protected runNextWithState(\n    input: RunAgentInput,\n    next: AbstractAgent,\n  ): Observable<EventWithState> {\n    let currentMessages = structuredClone_(input.messages || []);\n    let currentState = structuredClone_(input.state || {});\n\n    // Use a ReplaySubject to feed events one by one\n    const eventSubject = new ReplaySubject<BaseEvent>();\n\n    // Set up defaultApplyEvents to process events\n    const mutations$ = defaultApplyEvents(input, eventSubject, next, []);\n\n    // Subscribe to track state changes\n    mutations$.subscribe((mutation) => {\n      if (mutation.messages !== undefined) {\n        currentMessages = mutation.messages;\n      }\n      if (mutation.state !== undefined) {\n        currentState = mutation.state;\n      }\n    });\n\n    return this.runNext(input, next).pipe(\n      concatMap(async (event) => {\n        // Feed the event to defaultApplyEvents and wait for it to process\n        eventSubject.next(event);\n\n        // Give defaultApplyEvents a chance to process\n        await new Promise((resolve) => setTimeout(resolve, 0));\n\n        // Return event with current state\n        return {\n          event,\n          messages: structuredClone_(currentMessages),\n          state: structuredClone_(currentState),\n        };\n      }),\n    );\n  }\n}\n\n// Wrapper class to convert a function into a Middleware instance\nexport class FunctionMiddleware extends Middleware {\n  constructor(private fn: MiddlewareFunction) {\n    super();\n  }\n\n  run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    return this.fn(input, next);\n  }\n}\n","import { Middleware } from \"./middleware\";\nimport { AbstractAgent } from \"@/agent\";\nimport {\n  RunAgentInput,\n  BaseEvent,\n  EventType,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n} from \"@ag-ui/core\";\nimport { Observable } from \"rxjs\";\nimport { filter } from \"rxjs/operators\";\n\ntype FilterToolCallsConfig =\n  | { allowedToolCalls: string[]; disallowedToolCalls?: never }\n  | { disallowedToolCalls: string[]; allowedToolCalls?: never };\n\nexport class FilterToolCallsMiddleware extends Middleware {\n  private blockedToolCallIds = new Set<string>();\n  private readonly allowedTools?: Set<string>;\n  private readonly disallowedTools?: Set<string>;\n\n  constructor(config: FilterToolCallsConfig) {\n    super();\n\n    // Runtime validation (belt and suspenders approach)\n    if (config.allowedToolCalls && config.disallowedToolCalls) {\n      throw new Error(\"Cannot specify both allowedToolCalls and disallowedToolCalls\");\n    }\n\n    if (!config.allowedToolCalls && !config.disallowedToolCalls) {\n      throw new Error(\"Must specify either allowedToolCalls or disallowedToolCalls\");\n    }\n\n    if (config.allowedToolCalls) {\n      this.allowedTools = new Set(config.allowedToolCalls);\n    } else if (config.disallowedToolCalls) {\n      this.disallowedTools = new Set(config.disallowedToolCalls);\n    }\n  }\n\n  run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    // Use runNext which already includes transformChunks\n    return this.runNext(input, next).pipe(\n      filter((event) => {\n        // Handle TOOL_CALL_START events\n        if (event.type === EventType.TOOL_CALL_START) {\n          const toolCallStartEvent = event as ToolCallStartEvent;\n          const shouldFilter = this.shouldFilterTool(toolCallStartEvent.toolCallName);\n\n          if (shouldFilter) {\n            // Track this tool call ID as blocked\n            this.blockedToolCallIds.add(toolCallStartEvent.toolCallId);\n            return false; // Filter out this event\n          }\n\n          return true; // Allow this event\n        }\n\n        // Handle TOOL_CALL_ARGS events\n        if (event.type === EventType.TOOL_CALL_ARGS) {\n          const toolCallArgsEvent = event as ToolCallArgsEvent;\n          return !this.blockedToolCallIds.has(toolCallArgsEvent.toolCallId);\n        }\n\n        // Handle TOOL_CALL_END events\n        if (event.type === EventType.TOOL_CALL_END) {\n          const toolCallEndEvent = event as ToolCallEndEvent;\n          return !this.blockedToolCallIds.has(toolCallEndEvent.toolCallId);\n        }\n\n        // Handle TOOL_CALL_RESULT events\n        if (event.type === EventType.TOOL_CALL_RESULT) {\n          const toolCallResultEvent = event as ToolCallResultEvent;\n          const isBlocked = this.blockedToolCallIds.has(toolCallResultEvent.toolCallId);\n\n          if (isBlocked) {\n            // Clean up the blocked ID after the last event\n            this.blockedToolCallIds.delete(toolCallResultEvent.toolCallId);\n            return false;\n          }\n\n          return true;\n        }\n\n        // Allow all other events through\n        return true;\n      }),\n    );\n  }\n\n  private shouldFilterTool(toolName: string): boolean {\n    if (this.allowedTools) {\n      // If using allowed list, filter out tools NOT in the list\n      return !this.allowedTools.has(toolName);\n    } else if (this.disallowedTools) {\n      // If using disallowed list, filter out tools IN the list\n      return this.disallowedTools.has(toolName);\n    }\n\n    return false;\n  }\n}\n","import { Middleware } from \"./middleware\";\nimport { AbstractAgent } from \"@/agent\";\nimport type { RunAgentInput, BaseEvent } from \"@ag-ui/core\";\nimport type { Observable } from \"rxjs\";\n\ntype InputMessage = RunAgentInput[\"messages\"][number];\n\nfunction sanitizeMessageContent(message: InputMessage): InputMessage {\n  const rawContent = (message as { content?: unknown }).content;\n\n  if (Array.isArray(rawContent)) {\n    const concatenatedContent = rawContent\n      .filter(\n        (part): part is { type: \"text\"; text: string } =>\n          typeof part === \"object\" &&\n          part !== null &&\n          \"type\" in part &&\n          (part as { type: unknown }).type === \"text\" &&\n          typeof (part as { text?: unknown }).text === \"string\",\n      )\n      .map((part) => part.text)\n      .join(\"\");\n\n    return {\n      ...message,\n      content: concatenatedContent,\n    } as InputMessage;\n  }\n\n  if (typeof rawContent === \"string\") {\n    return message;\n  }\n\n  return {\n    ...message,\n    content: \"\",\n  } as InputMessage;\n}\n\n/**\n * Middleware placeholder that maintains compatibility with AG-UI 0.0.39 flows.\n * Currently it simply forwards all events to the next middleware/agent.\n */\nexport class BackwardCompatibility_0_0_39 extends Middleware {\n  override run(input: RunAgentInput, next: AbstractAgent): Observable<BaseEvent> {\n    const { parentRunId: _parentRunId, ...rest } = input;\n    const sanitizedInput: RunAgentInput = {\n      ...rest,\n      messages: rest.messages.map(sanitizeMessageContent),\n    } as RunAgentInput;\n\n    return this.runNext(sanitizedInput, next);\n  }\n}\n","{\n  \"name\": \"@ag-ui/client\",\n  \"author\": \"Markus Ecker <markus.ecker@gmail.com>\",\n  \"version\": \"0.0.43\",\n  \"private\": false,\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"main\": \"./dist/index.js\",\n  \"module\": \"./dist/index.mjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"sideEffects\": false,\n  \"files\": [\n    \"dist/**\",\n    \"README.md\"\n  ],\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch\",\n    \"clean\": \"rm -rf dist .turbo node_modules\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"test\": \"jest\",\n    \"link:global\": \"pnpm link --global\",\n    \"unlink:global\": \"pnpm unlink --global\"\n  },\n  \"dependencies\": {\n    \"@ag-ui/core\": \"workspace:*\",\n    \"@ag-ui/encoder\": \"workspace:*\",\n    \"@ag-ui/proto\": \"workspace:*\",\n    \"@types/uuid\": \"^10.0.0\",\n    \"compare-versions\": \"^6.1.1\",\n    \"fast-json-patch\": \"^3.1.1\",\n    \"rxjs\": \"7.8.1\",\n    \"untruncate-json\": \"^0.0.1\",\n    \"uuid\": \"^11.1.0\",\n    \"zod\": \"^3.22.4\"\n  },\n  \"devDependencies\": {\n    \"@types/jest\": \"^29.5.14\",\n    \"@types/node\": \"^20.11.19\",\n    \"jest\": \"^29.7.0\",\n    \"ts-jest\": \"^29.1.2\",\n    \"tsup\": \"^8.0.2\",\n    \"typescript\": \"^5.3.3\"\n  }\n}\n","import { AbstractAgent, RunAgentResult } from \"./agent\";\nimport { runHttpRequest } from \"@/run/http-request\";\nimport { HttpAgentConfig, RunAgentParameters } from \"./types\";\nimport { RunAgentInput, BaseEvent } from \"@ag-ui/core\";\nimport { structuredClone_ } from \"@/utils\";\nimport { transformHttpEventStream } from \"@/transform/http\";\nimport { Observable } from \"rxjs\";\nimport { AgentSubscriber } from \"./subscriber\";\n\ninterface RunHttpAgentConfig extends RunAgentParameters {\n  abortController?: AbortController;\n}\n\nexport class HttpAgent extends AbstractAgent {\n  public url: string;\n  public headers: Record<string, string>;\n  public abortController: AbortController = new AbortController();\n\n  /**\n   * Returns the fetch config for the http request.\n   * Override this to customize the request.\n   *\n   * @returns The fetch config for the http request.\n   */\n  protected requestInit(input: RunAgentInput): RequestInit {\n    return {\n      method: \"POST\",\n      headers: {\n        ...this.headers,\n        \"Content-Type\": \"application/json\",\n        Accept: \"text/event-stream\",\n      },\n      body: JSON.stringify(input),\n      signal: this.abortController.signal,\n    };\n  }\n\n  public runAgent(\n    parameters?: RunHttpAgentConfig,\n    subscriber?: AgentSubscriber,\n  ): Promise<RunAgentResult> {\n    this.abortController = parameters?.abortController ?? new AbortController();\n    return super.runAgent(parameters, subscriber);\n  }\n\n  abortRun() {\n    this.abortController.abort();\n    super.abortRun();\n  }\n\n  constructor(config: HttpAgentConfig) {\n    super(config);\n    this.url = config.url;\n    this.headers = structuredClone_(config.headers ?? {});\n  }\n\n  run(input: RunAgentInput): Observable<BaseEvent> {\n    const httpEvents = runHttpRequest(this.url, this.requestInit(input));\n    return transformHttpEventStream(httpEvents);\n  }\n\n  public clone(): HttpAgent {\n    const cloned = super.clone() as HttpAgent;\n    cloned.url = this.url;\n    cloned.headers = structuredClone_(this.headers ?? {});\n\n    const newController = new AbortController();\n    const originalSignal = this.abortController.signal as AbortSignal & { reason?: unknown };\n    if (originalSignal.aborted) {\n      newController.abort(originalSignal.reason);\n    }\n    cloned.abortController = newController;\n\n    return cloned;\n  }\n}\n","import {\n  BaseEvent,\n  EventType,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n} from \"@ag-ui/core\";\n\n/**\n * Compacts streaming events by consolidating multiple deltas into single events.\n * For text messages: multiple content deltas become one concatenated delta.\n * For tool calls: multiple args deltas become one concatenated delta.\n * Events between related streaming events are reordered to keep streaming events together.\n *\n * @param events - Array of events to compact\n * @returns Compacted array of events\n */\nexport function compactEvents(events: BaseEvent[]): BaseEvent[] {\n  const compacted: BaseEvent[] = [];\n  const pendingTextMessages = new Map<\n    string,\n    {\n      start?: TextMessageStartEvent;\n      contents: TextMessageContentEvent[];\n      end?: TextMessageEndEvent;\n      otherEvents: BaseEvent[];\n    }\n  >();\n  const pendingToolCalls = new Map<\n    string,\n    {\n      start?: ToolCallStartEvent;\n      args: ToolCallArgsEvent[];\n      end?: ToolCallEndEvent;\n      otherEvents: BaseEvent[];\n    }\n  >();\n\n  for (const event of events) {\n    // Handle text message streaming events\n    if (event.type === EventType.TEXT_MESSAGE_START) {\n      const startEvent = event as TextMessageStartEvent;\n      const messageId = startEvent.messageId;\n\n      if (!pendingTextMessages.has(messageId)) {\n        pendingTextMessages.set(messageId, {\n          contents: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingTextMessages.get(messageId)!;\n      pending.start = startEvent;\n    } else if (event.type === EventType.TEXT_MESSAGE_CONTENT) {\n      const contentEvent = event as TextMessageContentEvent;\n      const messageId = contentEvent.messageId;\n\n      if (!pendingTextMessages.has(messageId)) {\n        pendingTextMessages.set(messageId, {\n          contents: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingTextMessages.get(messageId)!;\n      pending.contents.push(contentEvent);\n    } else if (event.type === EventType.TEXT_MESSAGE_END) {\n      const endEvent = event as TextMessageEndEvent;\n      const messageId = endEvent.messageId;\n\n      if (!pendingTextMessages.has(messageId)) {\n        pendingTextMessages.set(messageId, {\n          contents: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingTextMessages.get(messageId)!;\n      pending.end = endEvent;\n\n      // Flush this message's events\n      flushTextMessage(messageId, pending, compacted);\n      pendingTextMessages.delete(messageId);\n    } else if (event.type === EventType.TOOL_CALL_START) {\n      const startEvent = event as ToolCallStartEvent;\n      const toolCallId = startEvent.toolCallId;\n\n      if (!pendingToolCalls.has(toolCallId)) {\n        pendingToolCalls.set(toolCallId, {\n          args: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingToolCalls.get(toolCallId)!;\n      pending.start = startEvent;\n    } else if (event.type === EventType.TOOL_CALL_ARGS) {\n      const argsEvent = event as ToolCallArgsEvent;\n      const toolCallId = argsEvent.toolCallId;\n\n      if (!pendingToolCalls.has(toolCallId)) {\n        pendingToolCalls.set(toolCallId, {\n          args: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingToolCalls.get(toolCallId)!;\n      pending.args.push(argsEvent);\n    } else if (event.type === EventType.TOOL_CALL_END) {\n      const endEvent = event as ToolCallEndEvent;\n      const toolCallId = endEvent.toolCallId;\n\n      if (!pendingToolCalls.has(toolCallId)) {\n        pendingToolCalls.set(toolCallId, {\n          args: [],\n          otherEvents: [],\n        });\n      }\n\n      const pending = pendingToolCalls.get(toolCallId)!;\n      pending.end = endEvent;\n\n      // Flush this tool call's events\n      flushToolCall(toolCallId, pending, compacted);\n      pendingToolCalls.delete(toolCallId);\n    } else {\n      // For non-streaming events, check if we're in the middle of any streaming sequences\n      let addedToBuffer = false;\n\n      // Check text messages\n      for (const [messageId, pending] of pendingTextMessages) {\n        // If we have a start but no end yet, this event is \"in between\"\n        if (pending.start && !pending.end) {\n          pending.otherEvents.push(event);\n          addedToBuffer = true;\n          break;\n        }\n      }\n\n      // Check tool calls if not already buffered\n      if (!addedToBuffer) {\n        for (const [toolCallId, pending] of pendingToolCalls) {\n          // If we have a start but no end yet, this event is \"in between\"\n          if (pending.start && !pending.end) {\n            pending.otherEvents.push(event);\n            addedToBuffer = true;\n            break;\n          }\n        }\n      }\n\n      // If not in the middle of any streaming sequence, add directly to compacted\n      if (!addedToBuffer) {\n        compacted.push(event);\n      }\n    }\n  }\n\n  // Flush any remaining incomplete messages\n  for (const [messageId, pending] of pendingTextMessages) {\n    flushTextMessage(messageId, pending, compacted);\n  }\n\n  // Flush any remaining incomplete tool calls\n  for (const [toolCallId, pending] of pendingToolCalls) {\n    flushToolCall(toolCallId, pending, compacted);\n  }\n\n  return compacted;\n}\n\nfunction flushTextMessage(\n  messageId: string,\n  pending: {\n    start?: TextMessageStartEvent;\n    contents: TextMessageContentEvent[];\n    end?: TextMessageEndEvent;\n    otherEvents: BaseEvent[];\n  },\n  compacted: BaseEvent[],\n): void {\n  // Add start event if present\n  if (pending.start) {\n    compacted.push(pending.start);\n  }\n\n  // Compact all content events into one\n  if (pending.contents.length > 0) {\n    const concatenatedDelta = pending.contents.map((c) => c.delta).join(\"\");\n\n    const compactedContent: TextMessageContentEvent = {\n      type: EventType.TEXT_MESSAGE_CONTENT,\n      messageId: messageId,\n      delta: concatenatedDelta,\n    };\n\n    compacted.push(compactedContent);\n  }\n\n  // Add end event if present\n  if (pending.end) {\n    compacted.push(pending.end);\n  }\n\n  // Add any events that were in between\n  for (const otherEvent of pending.otherEvents) {\n    compacted.push(otherEvent);\n  }\n}\n\nfunction flushToolCall(\n  toolCallId: string,\n  pending: {\n    start?: ToolCallStartEvent;\n    args: ToolCallArgsEvent[];\n    end?: ToolCallEndEvent;\n    otherEvents: BaseEvent[];\n  },\n  compacted: BaseEvent[],\n): void {\n  // Add start event if present\n  if (pending.start) {\n    compacted.push(pending.start);\n  }\n\n  // Compact all args events into one\n  if (pending.args.length > 0) {\n    const concatenatedArgs = pending.args.map((a) => a.delta).join(\"\");\n\n    const compactedArgs: ToolCallArgsEvent = {\n      type: EventType.TOOL_CALL_ARGS,\n      toolCallId: toolCallId,\n      delta: concatenatedArgs,\n    };\n\n    compacted.push(compactedArgs);\n  }\n\n  // Add end event if present\n  if (pending.end) {\n    compacted.push(pending.end);\n  }\n\n  // Add any events that were in between\n  for (const otherEvent of pending.otherEvents) {\n    compacted.push(otherEvent);\n  }\n}\n","export * from \"./apply\";\nexport * from \"./verify\";\nexport * from \"./transform\";\nexport * from \"./run\";\nexport * from \"./legacy\";\nexport * from \"./agent\";\nexport * from \"./utils\";\nexport * from \"./compact\";\nexport * from \"@ag-ui/core\";\nexport * from \"./chunks\";\nexport * from \"./middleware\";\n\nexport { Middleware, FilterToolCallsMiddleware } from \"./middleware\";\nexport type { MiddlewareFunction } from \"./middleware\";\n"],"mappings":"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","names":["EventType","mergeAll","defaultIfEmpty","concatMap","of","EMPTY","uuidv4","structuredClone_","obj","err","__spreadValues","randomUUID","uuidv4","applyPatch","runSubscribersWithMutation","subscribers","initialMessages","initialState","executor","messages","state","stopPropagation","subscriber","mutation","structuredClone_","error","__spreadValues","untruncateJson","defaultApplyEvents","input","events$","agent","subscribers","messages","structuredClone_","state","currentMutation","applyMutation","mutation","emitUpdates","result","of","EMPTY","concatMap","event","_a","_b","_c","_d","_e","runSubscribersWithMutation","subscriber","EventType","messageId","role","newMessage","delta","targetMessage","m","existingContent","toolCallId","toolCallName","parentMessageId","tc","targetToolCall","toolCallBuffer","partialToolCallArgs","untruncateJson","error","toolCallArgsString","toolCallArgs","content","toolMessage","snapshot","applyPatch","errorMessage","newMessages","activityEvent","existingIndex","existingMessage","existingActivityMessage","replace","activityMessage","createdMessage","__spreadProps","__spreadValues","baseContent","updatedContent","runStartedEvent","message","_exhaustiveCheck","mergeAll","defaultIfEmpty","stream","EventType","AGUIError","throwError","of","mergeMap","verifyEvents","debug","source$","activeMessages","activeToolCalls","runFinished","runError","firstEventReceived","activeSteps","activeThinkingStep","activeThinkingStepMessage","runStarted","resetRunState","event","eventType","messageId","toolCallId","stepName","unfinishedSteps","unfinishedMessages","unfinishedToolCalls","EventSchemas","Subject","ReplaySubject","Observable","from","defer","throwError","mergeMap","switchMap","runHttpRequest","url","requestInit","defer","from","switchMap","response","_a","contentType","mergeMap","text","payload","e","err","throwError","headersEvent","reader","Observable","subscriber","done","value","dataEvent","error","Subject","parseSSEStream","source$","jsonSubject","Subject","decoder","buffer","event","text","events","processSSEEvent","err","eventText","lines","dataLines","line","jsonStr","json","Subject","proto","parseProtoStream","source$","eventSubject","Subject","buffer","event","newBuffer","processBuffer","err","error","totalLength","message","errorMessage","proto","EventType","transformHttpEventStream","source$","eventSubject","Subject","bufferSubject","ReplaySubject","parserInitialized","event","parseProtoStream","err","parseSSEStream","json","parsedEvent","EventSchemas","mergeMap","applyPatch","EventType","z","LegacyRuntimeEventTypes","LegacyRuntimeMetaEventName","LegacyTextMessageStart","LegacyTextMessageContent","LegacyTextMessageEnd","LegacyActionExecutionStart","LegacyActionExecutionArgs","LegacyActionExecutionEnd","LegacyActionExecutionResult","LegacyAgentStateMessage","LegacyMetaEvent","LegacyRunError","LegacyRuntimeProtocolEvent","LegacyTextMessageSchema","LegacyActionExecutionMessageSchema","LegacyResultMessageSchema","untruncateJson","flattenMessageContentToText","content","textParts","part","text","convertToLegacyEvents","threadId","runId","agentName","events$","currentState","running","active","nodeName","syncedMessages","predictState","currentToolCalls","toolCallNames","updateCurrentState","newState","mergeMap","event","EventType","startEvent","LegacyRuntimeEventTypes","contentEvent","endEvent","argsEvent","currentToolCall","tc","didUpdateState","currentPredictState","s","currentArgs","untruncateJson","__spreadProps","__spreadValues","e","resultEvent","customEvent","result","applyPatch","convertMessagesToLegacyFormat","errorEvent","messages","_a","message","textContent","textMessage","toolCall","actionExecutionMessage","actionName","m","toolMessage","uuidv4","compareVersions","catchError","map","tap","finalize","takeUntil","pipe","from","of","EMPTY","Subject","lastValueFrom","mergeMap","finalize","EventType","transformChunks","debug","events$","textMessageFields","toolCallFields","mode","closeTextMessage","event","closeToolCall","closePendingEvent","messageChunkEvent","textMessageResult","textMessageStartEvent","textMessageContentEvent","toolCallChunkEvent","toolMessageResult","toolCallStartEvent","toolCallArgsEvent","_exhaustiveCheck","AGUIConnectNotImplementedError","ReplaySubject","concatMap","Middleware","input","next","transformChunks","currentMessages","structuredClone_","currentState","eventSubject","ReplaySubject","defaultApplyEvents","mutation","concatMap","event","resolve","FunctionMiddleware","fn","EventType","filter","FilterToolCallsMiddleware","Middleware","config","input","next","event","toolCallStartEvent","toolCallArgsEvent","toolCallEndEvent","toolCallResultEvent","toolName","sanitizeMessageContent","message","rawContent","concatenatedContent","part","__spreadProps","__spreadValues","BackwardCompatibility_0_0_39","Middleware","input","next","_a","_parentRunId","rest","__objRest","sanitizedInput","package_default","AbstractAgent","agentId","description","threadId","initialMessages","initialState","debug","uuidv4","structuredClone_","compareVersions","BackwardCompatibility_0_0_39","package_default","subscriber","s","middlewares","normalizedMiddlewares","middleware","FunctionMiddleware","parameters","_a","input","result","currentMessageIds","message","subscribers","params","Subject","resolveActiveRunCompletion","resolve","pipeline","pipe","nextAgent","i","transformChunks","verifyEvents","source$","takeUntil","catchError","error","finalize","lastValueFrom","of","newMessages","AGUIConnectNotImplementedError","EMPTY","_b","completion","events$","defaultApplyEvents","tap","event","_c","messagesWithoutActivity","onRunInitializedMutation","runSubscribersWithMutation","messages","state","from","map","onRunFailedMutation","mutation","onRunFinalizedMutation","cloned","toolCall","config","convertToLegacyEvents","HttpAgent","AbstractAgent","config","_a","structuredClone_","input","__spreadProps","__spreadValues","parameters","subscriber","httpEvents","runHttpRequest","transformHttpEventStream","cloned","newController","originalSignal","EventType","compactEvents","events","compacted","pendingTextMessages","pendingToolCalls","event","startEvent","messageId","pending","contentEvent","endEvent","flushTextMessage","toolCallId","argsEvent","flushToolCall","addedToBuffer","concatenatedDelta","c","compactedContent","otherEvent","concatenatedArgs","a","compactedArgs"]}