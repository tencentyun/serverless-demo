import { z } from "zod/v4";
import { TBaseToolInvokeInput } from "./types/zod";
import type { IBaseToolOptions, ToolExecutionContext, IToolkitOptions } from "./types/index";
export declare class ToolResult<TOutput = any> {
    success: boolean;
    data?: TOutput;
    error?: string;
    executionTime?: number;
    error_type?: "validation" | "security" | "file_not_found" | "permission" | "execution" | "unknown";
    constructor({ success, data, error, error_type, executionTime, }: {
        success: boolean;
        data?: TOutput;
        error?: string;
        error_type?: ToolResult["error_type"];
        executionTime?: number;
    });
}
/**
 * Generic error handler that converts exceptions/errors to standardized error responses
 */
export declare function handleToolError(error: unknown, context?: string, errorType?: ToolResult["error_type"], details?: any): ToolResult;
export declare abstract class BaseTool<TSchema extends z.ZodTypeAny = z.ZodTypeAny, TState = Record<string, unknown>, TOutput = any> {
    name: IBaseToolOptions<TSchema>["name"];
    description?: IBaseToolOptions<TSchema>["description"];
    requiresApproval?: IBaseToolOptions<TSchema>["requiresApproval"];
    readonly schema?: IBaseToolOptions<TSchema>["schema"];
    constructor(options: IBaseToolOptions<TSchema>);
    getDisplay(params: {
        name: string;
        input: any;
    }): string;
    protected validateInput(input: any): ToolResult;
    protected abstract _invoke<TInput extends TBaseToolInvokeInput<TSchema>>(input: TInput, context?: ToolExecutionContext<TState>): Promise<TOutput | ToolResult<TOutput>>;
    invoke<TInput extends TBaseToolInvokeInput<TSchema>>(input: TInput, context?: ToolExecutionContext<TState>): Promise<ToolResult<TOutput>>;
    getMetadata(): {
        name: string;
        description: string;
        schema: TSchema;
    };
}
interface IDynamicToolOptions<TSchema extends z.ZodTypeAny, TState = Record<string, unknown>, TOutput = any> extends IBaseToolOptions {
    schema: TSchema;
    func: BaseTool<TSchema, TState, TOutput>["_invoke"];
}
export declare class DynamicTool<TSchema extends z.ZodTypeAny = z.ZodTypeAny, TState = Record<string, unknown>, TOutput = any> extends BaseTool<TSchema, TState, TOutput> {
    private func;
    constructor(options: IDynamicToolOptions<TSchema, TState, TOutput>);
    protected _invoke(input: any, context?: any): Promise<TOutput | ToolResult<TOutput>>;
}
export type ToolkitEvent = {
    type: "tool_added";
    tool: BaseTool;
} | {
    type: "tool_removed";
    toolName: string;
} | {
    type: "tool_executed";
    toolName: string;
    result: ToolResult;
} | {
    type: "toolkit_initialized";
    toolkit: BaseToolkit;
} | {
    type: "toolkit_destroyed";
    toolkit: BaseToolkit;
};
export type ToolkitEventListener = (event: ToolkitEvent) => void;
export declare class BaseToolkit<TState extends Record<string, unknown> = Record<string, unknown>> {
    readonly name: string;
    readonly description?: string;
    context?: ToolExecutionContext<TState> | any;
    private tools;
    private eventListeners;
    private initialized;
    constructor(options: IToolkitOptions<TState>);
    initialize(): Promise<void>;
    destroy(): Promise<void>;
    protected onInitialize(): Promise<void>;
    protected onDestroy(): Promise<void>;
    addTool(tool: BaseTool): this;
    addTools(tools: BaseTool[]): this;
    removeTool(toolName: string): boolean;
    getTool(name: string): BaseTool | undefined;
    getTools(): BaseTool[];
    getToolNames(): string[];
    hasTool(name: string): boolean;
    searchTools(query: string): BaseTool[];
    invokeTool(toolName: string, input: any, context?: ToolExecutionContext<TState>): Promise<ToolResult>;
    invokeTools(invocations: Array<{
        toolName: string;
        input: any;
        context?: ToolExecutionContext<TState>;
    }>): Promise<ToolResult[]>;
    setContext(context: ToolExecutionContext<TState>): this;
    getContext(): ToolExecutionContext<TState> | undefined;
    addEventListener(listener: ToolkitEventListener): this;
    removeEventListener(listener: ToolkitEventListener): boolean;
    private emit;
    getMetadata(): {
        name: string;
        description: string;
        toolCount: number;
        tools: {
            name: string;
            description: string;
            schema: z.ZodType<unknown, unknown, z.core.$ZodTypeInternals<unknown, unknown>>;
        }[];
        initialized: boolean;
    };
    validate(): {
        valid: boolean;
        errors: string[];
    };
    clone(newName?: string): BaseToolkit;
}
export declare function tool<TSchema extends z.ZodTypeAny = z.ZodTypeAny, TState = Record<string, unknown>, TOutput = any>(func: IDynamicToolOptions<TSchema, TState, TOutput>["func"], options: Omit<IDynamicToolOptions<TSchema, TState, TOutput>, "func"> & {
    getDisplay?: (params: {
        name: string;
        input: any;
    }) => string;
}): DynamicTool<TSchema, TState, TOutput>;
export declare class ToolkitManager {
    private toolkits;
    register(toolkit: BaseToolkit): this;
    unregister(toolkitName: string): boolean;
    getToolkit(name: string): BaseToolkit | undefined;
    getToolkits(): BaseToolkit[];
    getAllTools(): Array<{
        toolkit: string;
        tool: BaseTool;
    }>;
    findTool(toolName: string): Array<{
        toolkit: string;
        tool: BaseTool;
    }>;
    initializeAll(): Promise<void>;
    destroyAll(): Promise<void>;
}
export declare const toolkitManager: ToolkitManager;
export declare function stripAnsi(string: any): string;
export {};
//# sourceMappingURL=utils.d.ts.map