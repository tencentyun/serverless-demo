import { z } from 'zod/v4';
import * as _cloudbase_agent_tools from '@cloudbase/agent-tools';
import { BaseTool, ToolExecutionContext } from '@cloudbase/agent-tools';
export { ToolExecutionContext } from '@cloudbase/agent-tools';
import { TiktokenEncoding } from 'tiktoken';
import { EventEmitter } from 'events';
import { AbstractAgent, AgentConfig as AgentConfig$1, RunAgentInput, BaseEvent as BaseEvent$2 } from '@ag-ui/client';
import { Observable } from 'rxjs';
import { Db, MongoClientOptions } from 'mongodb';
import { MysqlConnectionOptions } from 'typeorm/driver/mysql/MysqlConnectionOptions.js';
export { MysqlConnectionOptions } from 'typeorm/driver/mysql/MysqlConnectionOptions.js';
import { DataSource, Repository } from 'typeorm';
import { MemoryClient as MemoryClient$1 } from 'mem0ai';

/**
 * Enhanced error handling system for AG-Kit
 */
declare abstract class AGKitError extends Error {
    abstract readonly code: string;
    abstract readonly category: ErrorCategory;
    readonly timestamp: Date;
    readonly context?: Record<string, unknown>;
    readonly cause?: Error;
    constructor(message: string, context?: Record<string, unknown>, cause?: Error);
    toJSON(): {
        name: string;
        code: string;
        category: ErrorCategory;
        message: string;
        timestamp: string;
        context: Record<string, unknown> | undefined;
        stack: string | undefined;
    };
}
declare enum ErrorCategory {
    CONFIGURATION = "CONFIGURATION",
    NETWORK = "NETWORK",
    MODEL = "MODEL",
    TOOL = "TOOL",
    VALIDATION = "VALIDATION",
    RUNTIME = "RUNTIME",
    MEMORY = "MEMORY",
    CONTROL_FLOW = "CONTROL_FLOW"
}
declare class ConfigurationError extends AGKitError {
    readonly code = "CONFIG_ERROR";
    readonly category = ErrorCategory.CONFIGURATION;
}
declare class InvalidModelProviderError extends AGKitError {
    readonly code = "INVALID_MODEL_PROVIDER";
    readonly category = ErrorCategory.CONFIGURATION;
}
declare class MissingRequiredConfigError extends AGKitError {
    readonly code = "MISSING_REQUIRED_CONFIG";
    readonly category = ErrorCategory.CONFIGURATION;
}
declare class NetworkError extends AGKitError {
    readonly code = "NETWORK_ERROR";
    readonly category = ErrorCategory.NETWORK;
}
declare class TimeoutError extends AGKitError {
    readonly code = "TIMEOUT_ERROR";
    readonly category = ErrorCategory.NETWORK;
}
declare class RateLimitError extends AGKitError {
    readonly code = "RATE_LIMIT_ERROR";
    readonly category = ErrorCategory.NETWORK;
}
declare class ModelError extends AGKitError {
    readonly code = "MODEL_ERROR";
    readonly category = ErrorCategory.MODEL;
}
declare class ModelProviderError$1 extends AGKitError {
    readonly code = "MODEL_PROVIDER_ERROR";
    readonly category = ErrorCategory.MODEL;
}
declare class TokenLimitError extends AGKitError {
    readonly code = "TOKEN_LIMIT_ERROR";
    readonly category = ErrorCategory.MODEL;
}
declare class InvalidModelResponseError extends AGKitError {
    readonly code = "INVALID_MODEL_RESPONSE";
    readonly category = ErrorCategory.MODEL;
}
declare class ToolError extends AGKitError {
    readonly code = "TOOL_ERROR";
    readonly category = ErrorCategory.TOOL;
}
declare class ToolExecutionError extends AGKitError {
    readonly code = "TOOL_EXECUTION_ERROR";
    readonly category = ErrorCategory.TOOL;
}
declare class ToolNotFoundError extends AGKitError {
    readonly code = "TOOL_NOT_FOUND";
    readonly category = ErrorCategory.TOOL;
}
declare class ToolValidationError extends AGKitError {
    readonly code = "TOOL_VALIDATION_ERROR";
    readonly category = ErrorCategory.TOOL;
}
declare class ValidationError extends AGKitError {
    readonly code = "VALIDATION_ERROR";
    readonly category = ErrorCategory.VALIDATION;
}
declare class SchemaValidationError extends AGKitError {
    readonly code = "SCHEMA_VALIDATION_ERROR";
    readonly category = ErrorCategory.VALIDATION;
}
declare class RuntimeError extends AGKitError {
    readonly code = "RUNTIME_ERROR";
    readonly category = ErrorCategory.RUNTIME;
}
declare class StateError extends AGKitError {
    readonly code = "STATE_ERROR";
    readonly category = ErrorCategory.RUNTIME;
}
declare class ExecutionError extends AGKitError {
    readonly code = "EXECUTION_ERROR";
    readonly category = ErrorCategory.RUNTIME;
}
declare class MemoryError extends AGKitError {
    readonly code = "MEMORY_ERROR";
    readonly category = ErrorCategory.MEMORY;
}
declare class MemoryLimitError extends AGKitError {
    readonly code = "MEMORY_LIMIT_ERROR";
    readonly category = ErrorCategory.MEMORY;
}
declare class ControlFlowError extends AGKitError {
    readonly code = "CONTROL_FLOW_ERROR";
    readonly category = ErrorCategory.CONTROL_FLOW;
}
declare class HumanApprovalRequiredError extends AGKitError {
    readonly code = "HUMAN_APPROVAL_REQUIRED";
    readonly category = ErrorCategory.CONTROL_FLOW;
}
interface ErrorHandler {
    handle(error: AGKitError): Promise<void> | void;
    canHandle(error: AGKitError): boolean;
}
declare class LoggingErrorHandler implements ErrorHandler {
    canHandle(error: AGKitError): boolean;
    handle(error: AGKitError): void;
}
declare class RetryErrorHandler implements ErrorHandler {
    private maxRetries;
    private retryableCategories;
    constructor(maxRetries?: number, retryableCategories?: ErrorCategory[]);
    canHandle(error: AGKitError): boolean;
    handle(error: AGKitError): Promise<void>;
}
interface ErrorRecoveryStrategy {
    canRecover(error: AGKitError): boolean;
    recover(error: AGKitError): Promise<unknown>;
}
declare class FallbackModelStrategy implements ErrorRecoveryStrategy {
    canRecover(error: AGKitError): boolean;
    recover(error: AGKitError): Promise<unknown>;
}
declare class ErrorContextBuilder {
    private context;
    withAgentId(agentId: string): this;
    withRunId(runId: string): this;
    withToolName(toolName: string): this;
    withModelName(modelName: string): this;
    withRetryCount(count: number): this;
    withCustom(key: string, value: unknown): this;
    build(): Record<string, unknown>;
}
declare function isRetryableError(error: AGKitError): boolean;
declare function isConfigurationError(error: AGKitError): boolean;
declare function isToolError(error: AGKitError): boolean;
declare function createErrorContext(): ErrorContextBuilder;

/**
 * @fileoverview Token utilities for text processing and token management
 */
/**
 * Tokenizer interface for encoding, decoding, and counting tokens
 */
interface ITokenizer {
    /** Encode text into tokens */
    encode(text: string): Uint32Array;
    /** Decode tokens back to text */
    decode(tokens: Uint32Array): string;
    /** Count the number of tokens in text */
    countTokens(text: string): number;
}
/**
 * Default tokenizer implementation based on tiktoken
 * Provides accurate token counting for OpenAI models
 */
declare class TiktokenTokenizer implements ITokenizer {
    /** Tiktoken encoding instance for token operations */
    private encoding;
    /**
     * Creates a new TiktokenTokenizer instance
     * @param encodingName - Tiktoken encoding name, defaults to 'o200k_base'
     */
    constructor(encodingName?: TiktokenEncoding);
    /**
     * Encode text into token array
     * @param text - Text to encode
     * @returns Array of token IDs
     */
    encode(text: string): Uint32Array;
    /**
     * Decode tokens back to text
     * @param tokens - Token array to decode
     * @returns Decoded text string
     */
    decode(tokens: Uint32Array): string;
    /**
     * Count the number of tokens in text
     * @param text - Text to count tokens for
     * @returns Number of tokens
     */
    countTokens(text: string): number;
    /**
     * Free the encoding resources
     */
    free(): void;
}
/**
 * Token trimming utility class for managing message token limits
 * Similar to LangChain's trimMessage functionality
 */
declare class TokenTrimmer {
    /** Tokenizer instance for token counting */
    private tokenizer;
    /**
     * Creates a new TokenTrimmer instance
     * @param tokenizer - Optional tokenizer, defaults to TiktokenTokenizer
     */
    constructor(tokenizer?: ITokenizer);
    /**
     * Calculate the token count for a message including role and content
     * @param message - Message object with role and content
     * @returns Total token count including formatting overhead
     */
    countMessageTokens(message: {
        role: string;
        content: string;
    }): number;
    /**
     * Trim message list to fit within token limits
     * Preserves messages starting from newest or oldest based on strategy
     * @param events - Array of events with message objects
     * @param maxTokens - Maximum token limit
     * @param strategy - Trimming strategy: 'newest_first' or 'oldest_first'
     * @returns Trimmed array of events within token limit
     */
    trimMessages<T extends {
        message: {
            role: string;
            content: string;
        };
    }>(events: T[], maxTokens: number, strategy?: "newest_first" | "oldest_first"): T[];
    /**
     * Truncate a single message to fit within token limits
     * @param event - Event to truncate
     * @param maxTokens - Maximum token limit
     * @returns Truncated event or null if cannot fit
     */
    private truncateMessage;
    /**
     * Free tokenizer resources
     */
    free(): void;
}

/**
 * @fileoverview Base memory interfaces and abstract class for short-term memory management
 */

/**
 * Message interface representing a conversation message
 */
interface Message$2 {
    /** Unique identifier for the message */
    id: string;
    /** Role of the message sender */
    role: "user" | "assistant" | "system" | "tool";
    /** Content of the message */
    content: string;
    /** Optional timestamp when the message was created */
    timestamp?: Date;
    /** Optional tool calls associated with the message */
    toolCalls?: any[];
    /** Optional tool call identifier */
    toolCallId?: string;
}
/**
 * Memory event interface combining message and state information
 */
interface IMemoryEvent {
    /** The message content */
    message: Message$2;
    /** Additional state information */
    state: Record<string, any>;
}
type TInputMemoryEvent = Omit<IMemoryEvent, "message"> & {
    message: Omit<Message$2, "id"> & {
        id?: Message$2["id"];
    };
};
/**
 * Options for listing and querying memory events
 */
interface ListOptions {
    /** Maximum number of tokens to include in results */
    maxTokens?: number;
    /** Maximum number of events to return */
    limit?: number;
    /** Number of events to skip (for pagination) */
    offset?: number;
    /** Sort order by timestamp */
    order?: "asc" | "desc";
    /** Session identifier for multi-session support */
    sessionId?: string;
}
/**
 * Options for adding memory events
 */
interface AddOptions {
    /** Session identifier for multi-session support */
    sessionId?: string;
}
/**
 * Options for deleting memory events
 */
interface DeleteOptions {
    /** Session identifier for multi-session support */
    sessionId?: string;
}
/**
 * Options for retrieving memory events
 */
interface RetrieveOptions {
    /** Session identifier for multi-session support */
    sessionId?: string;
}
/**
 * Options for clearing memory events
 */
interface ClearOptions {
    /** Session identifier for multi-session support. If not provided, clears all sessions */
    sessionId?: string;
}
/**
 * Branch information for session management
 */
interface BranchInfo {
    /** Branch name */
    name: string;
    /** When the branch was created */
    createdAt: Date;
    /** Event ID this branch was created from */
    fromEventId?: string;
    /** Whether this is the currently active branch */
    isActive: boolean;
}
/**
 * Compaction metadata stored in event.state.__compaction__
 */
interface CompactionMetadata {
    /** Original full message content before compaction */
    originalContent: string;
    /** Original token count */
    originalTokens: number;
    /** Compacted token count */
    compactedTokens: number;
}
/**
 * Structured summary schema (not free-form text)
 */
interface StructuredSummary {
    content: string;
    count: number;
    timeRange: {
        start?: Date;
        end?: Date;
    };
    timestamp: Date;
}
/**
 * Context thresholds configuration
 */
interface ContextThresholds {
    /** Pre-rot threshold - where performance starts degrading */
    preRotThreshold: number;
    /** Trigger compaction at this percentage of pre-rot threshold */
    compactionTrigger: number;
    /** Trigger summarization at this percentage of pre-rot threshold */
    summarizationTrigger: number;
    /** Number of recent events to keep */
    recentToKeep: number;
}
interface IBaseMemoryOptions {
    tokenizer?: ITokenizer;
    thresholds?: Partial<ContextThresholds>;
    summarizer?: (events: IMemoryEvent[]) => Promise<StructuredSummary>;
}
/**
 * Abstract base class for short-term memory implementations
 *
 * Provides the core interface for storing, retrieving, and managing
 * conversation events in short-term memory systems with built-in
 * context engineering capabilities.
 */
declare abstract class BaseMemory {
    tokenTrimmer: TokenTrimmer;
    protected thresholds?: ContextThresholds;
    protected compactionCount: number;
    protected summarizationCount: number;
    protected lastCompactionGain: number;
    constructor(config?: IBaseMemoryOptions);
    /**
     * Returns a list of events stored in the memory
     * @param options - Optional filtering and pagination options
     * @returns Promise resolving to array of memory events
     */
    abstract list(options?: ListOptions): Promise<IMemoryEvent[]>;
    /**
     * Add a single memory event to storage
     * @param event - The memory event to store
     * @param options - Optional configuration including session ID
     * @returns Promise that resolves when the event is stored
     */
    abstract add(event: TInputMemoryEvent, options?: AddOptions): Promise<void>;
    /**
     * Add multiple memory events efficiently
     *
     * Implementations should override this method to handle bulk addition
     * efficiently and avoid unnecessary round-trips to the underlying store.
     *
     * @param list - Array of memory events to store
     * @returns Promise that resolves when all events are stored
     */
    addList(list: TInputMemoryEvent[], options?: AddOptions): Promise<void>;
    abstract update(params: {
        sessionId?: string;
        event: Partial<IMemoryEvent>;
    }): Promise<void>;
    /**
     * Delete memory events from storage
     * @param args - Implementation-specific arguments for deletion
     * @returns Promise that resolves when deletion is complete
     */
    abstract delete(...args: any[]): Promise<void>;
    /**
     * Retrieve memory events based on search criteria
     * @param args - Implementation-specific arguments for retrieval
     * @returns Promise resolving to array of matching memory events
     */
    abstract retrieve(...args: any[]): Promise<IMemoryEvent[]>;
    /**
     * Remove all events from storage
     * @returns Promise that resolves when all events are cleared
     * @throws Error if not implemented by subclass
     */
    clear(): Promise<void>;
    /**
     * Create a new branch from current session state
     * @param branchName - Name for the new branch
     * @param fromEventId - Optional event ID to branch from
     * @returns Promise resolving to branch ID
     * @throws Error if not implemented by subclass
     */
    branch(branchName: string, fromEventId?: string): Promise<string>;
    /**
     * Switch to a different branch or checkout to a specific event
     * @param target - Branch name or event ID to checkout
     * @param options - Optional configuration
     * @param options.type - Type of checkout: 'branch' or 'event' (default: auto-detect)
     * @param options.sessionId - Session ID when checking out to an event
     * @returns Promise that resolves when checkout is complete
     * @throws Error if not implemented by subclass
     *
     * @example
     * // Checkout to a branch
     * await memory.checkout('experiment-1');
     *
     * // Checkout to a specific event (deletes all events after it)
     * await memory.checkout('event-123', { type: 'event', sessionId: 'session-1' });
     */
    checkout(target: string, options?: {
        type?: "branch" | "event";
        sessionId?: string;
    }): Promise<void>;
    /**
     * List all available branches
     * @returns Promise resolving to array of branch information
     * @throws Error if not implemented by subclass
     */
    listBranches(): Promise<BranchInfo[]>;
    /**
     * Delete a branch
     * @param branchName - Name of the branch to delete
     * @returns Promise that resolves when deletion is complete
     * @throws Error if not implemented by subclass or trying to delete active branch
     */
    deleteBranch(branchName: string): Promise<void>;
    /**
     * Clean up all inactive branches, keeping only the main branch
     * This is useful for maintaining a single trunk after experimentation
     * @param keepBranches - Optional list of branch names to keep (in addition to active branch)
     * @returns Promise that resolves when cleanup is complete
     * @throws Error if not implemented by subclass
     */
    cleanupBranches(keepBranches?: string[]): Promise<void>;
    /**
     * Check if an event is compacted
     * @param event - Event to check
     * @returns True if event has compaction metadata
     */
    isCompacted(event: IMemoryEvent): boolean;
    /**
     * Decompress a compacted event
     * @param event - Event to decompress
     * @returns Decompressed event with original content and state
     */
    decompressEvent(event: IMemoryEvent): IMemoryEvent;
    /**
     * Decompress multiple events
     * @param events - Events to decompress
     * @returns Array of decompressed events
     */
    decompressEvents(events: IMemoryEvent[]): IMemoryEvent[];
    /**
     * Manage context automatically when adding events
     * Subclasses should call this method after adding events if context management is enabled
     */
    protected manageContext({ sessionId, events, }: {
        sessionId: string;
        events: IMemoryEvent[];
    }): Promise<{
        events: IMemoryEvent[];
    }>;
    /**
     * Perform compaction (reversible externalization to event.state)
     * Subclasses should override this method to implement compaction logic
     * @returns Token gain from compaction
     */
    protected performCompaction({ sessionId, events, }: {
        sessionId?: string;
        events: IMemoryEvent[];
    }): Promise<{
        events: IMemoryEvent[];
        gain: number;
    }>;
    /**
     * Compact a single event - store full content in state
     */
    protected compactEvent({ sessionId, event, }: {
        sessionId?: string;
        event: IMemoryEvent;
    }): Promise<IMemoryEvent>;
    /**
     * Perform summarization (irreversible refinement)
     * @param sessionId - Optional session identifier (implementation-specific)
     */
    protected performSummarization({ sessionId, events, }: {
        sessionId?: string;
        events: IMemoryEvent[];
    }): Promise<{
        events: IMemoryEvent[];
        summary?: StructuredSummary;
    }>;
    /**
     * Store summary (to be implemented by subclasses)
     * @param summary - The structured summary to store
     */
    protected storeSummary(params: {
        sessionId?: string;
        summary: StructuredSummary;
    }): Promise<void>;
    /**
     * Clear summarized events (to be implemented by subclasses)
     * @param sessionId - Optional session identifier (implementation-specific)
     * @param recentToKeep - Number of recent events to keep
     */
    protected clearSummarizedEvents(params: {
        sessionId?: string;
        recentToKeep: number;
    }): Promise<void>;
    /**
     * Get current token count for a session
     */
    protected getCurrentTokenCount(events: IMemoryEvent[]): Promise<number>;
    /**
     * Create default structured summary
     */
    summarizer(events: IMemoryEvent[]): Promise<StructuredSummary>;
}

/**
 * @fileoverview In-memory implementation using unified adapter architecture
 *
 * In-memory Memory implementation providing volatile storage using
 * JavaScript arrays with support for CRUD operations, session management,
 * branch isolation, and soft delete using cursor-based approach.
 *
 * @example
 * ```typescript
 * const memory = new InMemoryMemory({
 *   sessionId: 'user-session-123'
 * });
 *
 * await memory.add({
 *   message: { id: '1', role: 'user', content: 'Hello' },
 *   state: { userId: 'user123' }
 * });
 *
 * const events = await memory.list({ limit: 10 });
 * ```
 */

/**
 * In-Memory Memory implementation using unified adapter architecture
 *
 * Provides volatile storage using JavaScript arrays with support for
 * session-based memory management, CRUD operations, branch isolation, optional context engineering,
 * and efficient soft delete using cursor-based approach.
 */
declare class InMemoryMemory extends BaseMemory {
    /** Session identifier for memory isolation */
    sessionId: string;
    /** Whether to enable automatic context management */
    private enableContextManagement;
    private collectionManager;
    private documentConverter;
    private stateManager;
    private cursorManager;
    private branchManager;
    private summaryManager;
    /**
     * Creates a new InMemoryMemory instance
     * @param options - Configuration options
     * @param options.sessionId - Unique session identifier (default: 'default')
     * @param options.enableContextManagement - Whether to automatically manage context (default: true if thresholds provided)
     */
    constructor(options?: {
        sessionId?: string;
        enableContextManagement?: boolean;
    } & ConstructorParameters<typeof BaseMemory>[0]);
    /**
     * Returns events from in-memory storage with filtering, pagination, and token limiting
     * Respects branch isolation using branch path and snapshot time
     * @param options - Optional filtering and pagination options
     * @returns Promise resolving to filtered array of memory events
     */
    list(options?: ListOptions): Promise<IMemoryEvent[]>;
    /**
     * Adds a new event to in-memory storage
     * @param event - The memory event to add
     * @param options - Optional session and branch options
     */
    add(event: TInputMemoryEvent, options?: AddOptions): Promise<void>;
    /**
     * Adds multiple events to in-memory storage
     * @param list - Array of memory events to add
     * @param options - Optional session and branch options
     */
    addList(list: TInputMemoryEvent[], options?: AddOptions): Promise<void>;
    /**
     * Update an existing event in memory storage
     * @param params - Update parameters including session ID and event
     */
    update(params: {
        sessionId: string;
        event: Partial<IMemoryEvent> & {
            message: {
                id: string;
            };
        };
    }): Promise<void>;
    /**
     * Deletes an event from in-memory storage by message ID or event object
     * @param params - Delete parameters including event reference or message ID
     */
    delete(params: {
        event: IMemoryEvent;
        sessionId?: string;
    } | string | number, options?: {
        sessionId?: string;
    }): Promise<void>;
    /**
     * Deletes an event by ID or index
     * @param idOrIndex - Event message ID or array index
     * @param options - Optional session options
     */
    deleteByIdOrIndex(idOrIndex: string | number, options?: DeleteOptions | {
        sessionId?: string;
    }): Promise<void>;
    /**
     * Clears events from in-memory storage
     * @param options - Optional session-specific clearing
     */
    clear(options?: ClearOptions): Promise<void>;
    /**
     * Gets the count of events in in-memory storage
     * @param options - Optional session filtering
     * @returns Promise resolving to the count of events
     */
    getCount(options?: {
        sessionId?: string;
    }): Promise<number>;
    /**
     * Retrieve events using content-based search
     * @param query - Search query text to match against message content
     * @param options - Optional search and session options
     * @returns Promise resolving to array of matching memory events
     */
    retrieve(query: string, options?: RetrieveOptions): Promise<IMemoryEvent[]>;
    /**
     * Get summaries for a session
     * @param sessionId - Optional session identifier
     * @returns Array of structured summaries
     */
    getSummaries(sessionId?: string): Promise<StructuredSummary[]>;
    /**
     * Store summary implementation
     * @param params - Summary storage parameters
     */
    protected storeSummary(params: {
        sessionId?: string;
        summary: StructuredSummary;
    }): Promise<void>;
    /**
     * Clear summarized events implementation using soft delete
     * Sets cursor to hide old events without actually deleting them
     * @param params - Clear parameters
     */
    protected clearSummarizedEvents(params: {
        sessionId?: string;
        recentToKeep: number;
    }): Promise<void>;
    /**
     * Create a new branch from the current state
     * @param branchName - Name of the new branch
     * @param fromEventId - Optional event ID to branch from
     * @returns Promise resolving to the branch name
     */
    branch(branchName: string, fromEventId?: string): Promise<string>;
    /**
     * Switch to a different branch or checkout to a specific event
     * @param target - Branch name or event ID
     * @param options - Optional checkout options
     */
    checkout(target: string, options?: {
        type?: "branch" | "event";
        sessionId?: string;
    }): Promise<void>;
    /**
     * Delete a branch
     * @param branchName - Name of the branch to delete
     */
    deleteBranch(branchName: string): Promise<void>;
    /**
     * List all branches for the current session
     * @returns Promise resolving to array of branch information
     */
    listBranches(): Promise<BranchInfo[]>;
    /**
     * Get current branch name
     * @returns Promise resolving to current branch name
     */
    getCurrentBranch(): Promise<string>;
    /**
     * Clean up branches, keeping only specified branches and the current active branch
     * @param keepBranches - Optional list of branch names to keep (in addition to active branch)
     */
    cleanupBranches(keepBranches?: string[]): Promise<void>;
    /**
     * Clear all collections (useful for testing)
     */
    clearAll(): void;
    /**
     * Check if the memory storage is empty
     * @param options - Optional session options
     * @returns Promise resolving to true if no events are stored
     */
    isEmpty(options?: {
        sessionId?: string;
    }): Promise<boolean>;
    /**
     * Get all session IDs currently stored in memory
     * @returns Array of session identifiers
     */
    getSessionIds(): string[];
    /**
     * Check if a specific session exists
     * @param sessionId - The session identifier to check
     * @returns True if the session exists
     */
    hasSession(sessionId: string): boolean;
    /**
     * Get raw session events (for testing purposes)
     * @param sessionId - The session identifier
     * @returns Array of raw events without decompression
     */
    getSessionEvents(sessionId: string): IMemoryEvent[];
}

/**
 * Abstract base class for API communication stubs
 */
declare abstract class Stub {
    abstract post(path: string, body: Record<string, any>, timeout?: number): Promise<any>;
    abstract close(): void;
}

/**
 * Sort order constants
 */
declare class Order {
    /** Ascending sort order */
    static readonly ASCENDING = 1;
    /** Descending sort order */
    static readonly DESCENDING = -1;
}
/**
 * Common types used across the SDK
 */
interface QueryOptions$1 {
    orderBy?: Record<string, number>;
    limit?: number;
    offset?: number;
}
interface SearchOptions extends QueryOptions$1 {
    content: string;
}
interface WhereClause {
    [key: string]: any;
}
interface Message$1 {
    role: string;
    content: string;
}

/**
 * Configuration options for MemoryClient
 */
interface IMemoryClientOptions {
    endpoint: string;
    apiKey: string;
    memoryId: string;
    defaultActorId?: string;
    timeout?: number;
    stub?: Stub;
}
interface IEvent extends Record<string, any> {
    event_id: string;
    created_at: number;
    updated_at: number;
}
/**
 * High-level Agent Memory client with essential operations
 */
declare class MemoryClient {
    private defaultMemoryId;
    private defaultActorId?;
    private stub;
    constructor(options: IMemoryClientOptions);
    /**
     * Close the client connection
     */
    close(): void;
    private getMemoryId;
    private getActorId;
    /**
     * Create a new session
     */
    createSession(options?: {
        name?: string;
        memoryId?: string;
        actorId?: string;
    }): Promise<any>;
    /**
     * Query sessions based on conditions
     */
    querySessions(options?: {
        memoryId?: string;
        actorId?: string;
    } & QueryOptions$1): Promise<any>;
    /**
     * Update an existing session
     */
    updateSession(options: {
        sessionId: string;
        name: string;
        memoryId?: string;
        actorId?: string;
    }): Promise<any>;
    /**
     * Delete an existing session
     */
    deleteSession(options: {
        sessionId: string;
        memoryId?: string;
        actorId?: string;
    }): Promise<any>;
    /**
     * Search sessions based on conditions and keywords
     */
    searchSessions(options: {
        content: string;
        memoryId?: string;
        actorId?: string;
    } & Omit<QueryOptions$1, "offset">): Promise<any>;
    /**
     * Append events to a session
     */
    appendEvent(options: {
        sessionId: string;
        messages: Record<string, any>;
        memoryId?: string;
        actorId?: string;
    }): Promise<{
        event_id: string;
    }>;
    /**
     * Query events based on conditions
     */
    queryEvents(options?: {
        memoryId?: string;
        actorId?: string;
        sessionId?: string;
        where?: WhereClause;
    } & QueryOptions$1): Promise<{
        events: IEvent[];
        total_count: number;
    }>;
    /**
     * Delete an event from a session
     */
    deleteEvent(options: {
        sessionId: string;
        eventId: string;
        memoryId?: string;
        actorId?: string;
    }): Promise<any>;
    /**
     * Set state for a session
     */
    setState(options: {
        sessionId: string;
        state: Record<string, any>;
        memoryId?: string;
        actorId?: string;
    }): Promise<any>;
    /**
     * Get state for a session
     */
    getStates(options: {
        sessionId: string;
        keys?: string[];
        memoryId?: string;
        actorId?: string;
    }): Promise<any>;
    /**
     * Get all states for an actor in a memory
     */
    getAllStates(options: {
        sessionId: string;
        memoryId?: string;
        actorId?: string;
    }): Promise<any>;
    /**
     * Delete specified state keys for a session
     */
    deleteStates(options: {
        sessionId: string;
        keys?: string[];
        memoryId?: string;
        actorId?: string;
    }): Promise<any>;
    /**
     * Flush all states for a session
     */
    flushStates(options: {
        sessionId: string;
        memoryId?: string;
        actorId?: string;
    }): Promise<any>;
    /**
     * Append records to a session
     */
    appendRecord(options: {
        sessionId: string;
        content: string;
        strategy: string;
        memoryId?: string;
        actorId?: string;
    }): Promise<any>;
    /**
     * Query records based on conditions
     */
    queryRecords(options?: {
        memoryId?: string;
        actorId?: string;
        sessionId?: string;
        strategies?: string[];
        where?: WhereClause;
    } & QueryOptions$1): Promise<{
        records: {
            created_at: number;
            updated_at: number;
            event_ids: string;
            record_content: string;
            record_id: string;
            score: number;
            strategy_name: string;
        }[];
        total_count: number;
    }>;
    /**
     * Update an existing record
     */
    updateRecord(options: {
        sessionId: string;
        recordId: string;
        content: string;
        memoryId?: string;
        actorId?: string;
    }): Promise<any>;
    /**
     * Delete an existing record
     */
    deleteRecord(options: {
        sessionId: string;
        recordId: string;
        memoryId?: string;
        actorId?: string;
    }): Promise<any>;
    /**
     * Search records based on conditions and keywords
     */
    searchRecords(options: {
        content: string;
        memoryId?: string;
        actorId?: string;
        sessionId?: string;
        strategies?: string[];
        where?: WhereClause;
    } & Omit<QueryOptions$1, "offset">): Promise<{
        records: {
            created_at: number;
            updated_at: number;
            event_ids: string;
            record_content: string;
            record_id: string;
            score: number;
            strategy_name: string;
        }[];
        total_count: number;
    }>;
}

/**
 * @fileoverview TDAI cloud-based memory implementation for production environments
 *
 * TDAI Memory implementation providing cloud-based persistent storage with semantic search,
 * advanced querying capabilities, and production-grade scalability through TDAI services.
 *
 * @example
 * ```typescript
 * const memory = new TDAIMemory({
 *   sessionId: 'user-session-123',
 *   clientOptions: { apiKey: 'your-api-key' },
 *   useCache: true
 * });
 * await memory.add({ message: { id: '1', role: 'user', content: 'Hello' } });
 * const results = await memory.retrieve('greeting');
 * ```
 */
declare class TDAIMemory extends BaseMemory {
    /** TDAI client instance for cloud operations */
    private client;
    /** Session identifier for memory isolation */
    private sessionId;
    /** Cache storage for improved performance */
    private cachedMap;
    /** Whether local caching is enabled */
    private useCache;
    /** Whether to enable automatic context management */
    private enableContextManagement;
    /**
     * Creates a new TDAIMemory instance
     * @param options - Configuration options
     * @param options.sessionId - Unique session identifier
     * @param options.client - Optional pre-configured TDAI client
     * @param options.clientOptions - TDAI client configuration if client not provided
     * @param options.useCache - Enable local caching for better performance
     * @param options.enableContextManagement - Whether to automatically manage context after adding events (default: true)
     */
    constructor(options: {
        sessionId: string;
        client?: MemoryClient;
        clientOptions?: IMemoryClientOptions;
        useCache?: boolean;
        enableContextManagement?: boolean;
    } & ConstructorParameters<typeof BaseMemory>[0]);
    /**
     * Returns events from TDAI service with filtering, pagination, and token limiting
     * @param options - Optional filtering and pagination options
     * @returns Promise resolving to filtered array of memory events
     */
    list(options?: ListOptions): Promise<IMemoryEvent[]>;
    /**
     * Add a single event to TDAI cloud storage
     * @param event - The memory event to store
     * @param options - Optional session options
     */
    add(event: IMemoryEvent, options?: AddOptions): Promise<void>;
    /**
     * Add multiple events efficiently with sequential processing
     * @param list - Array of memory events to store
     */
    addList(list: IMemoryEvent[], options?: AddOptions): Promise<void>;
    update({ sessionId, event }: {
        sessionId?: string;
        event: IMemoryEvent;
    }): Promise<void>;
    /**
     * Delete an event from TDAI cloud storage
     * @param idOrIndex - Event ID (string) or array index (number, not yet implemented)
     */
    delete(idOrIndex: string | number): Promise<void>;
    /**
     * Retrieve events using TDAI's search capabilities
     * @param query - Optional search query for content matching
     * @returns Promise resolving to array of matching events
     */
    retrieve(query?: string): Promise<IMemoryEvent[]>;
    /**
     * Clear all events.
     */
    /**
     * Check if the session contains any events
     * @returns Promise resolving to true if no events are stored
     */
    isEmpty(): Promise<boolean>;
    /**
     * Get the current number of events stored in the session
     * @returns Promise resolving to the count of stored events
     */
    getCount(): Promise<number>;
    /**
     * Convert TDAI events to IMemoryEvent format for compatibility
     * @param events - Array of TDAI events to convert
     * @returns Array of converted memory events
     */
    private convertTDAIEventsToMemoryEvents;
    /**
     * Extract state from metadata, excluding message-specific fields
     * @param metadata - Event metadata object
     * @returns Cleaned state object without message fields
     */
    private extractStateFromMetadata;
    /**
     * Clean up branches - not supported by TDAI Memory
     * @param keepBranches - Ignored parameter
     * @throws Error indicating branch operations are not supported
     */
    cleanupBranches(keepBranches?: string[]): Promise<void>;
}

/**
 * CloudBase Memory Types
 *
 * This file contains all type definitions used by CloudBase memory implementation.
 */
/**
 * CloudBase app interface
 */
interface CloudBaseApp {
    database(): CloudBaseDatabase;
}
/**
 * CloudBase database interface
 */
interface CloudBaseDatabase {
    collection(name: string): CloudBaseCollection;
    command: any;
    RegExp(options: {
        regexp: string;
        options?: string;
    }): any;
}
/**
 * CloudBase collection interface
 */
interface CloudBaseCollection {
    add(data: any): Promise<any>;
    doc(id: string): CloudBaseDocument;
    where(condition: any): CloudBaseQuery;
    get(): Promise<CloudBaseQueryResult>;
}
/**
 * CloudBase document interface
 */
interface CloudBaseDocument {
    get(): Promise<CloudBaseQueryResult>;
    update(data: any): Promise<any>;
    remove(): Promise<any>;
}
/**
 * CloudBase query interface
 */
interface CloudBaseQuery {
    where(condition: any): CloudBaseQuery;
    orderBy(field: string, order: "asc" | "desc"): CloudBaseQuery;
    skip(offset: number): CloudBaseQuery;
    limit(limit: number): CloudBaseQuery;
    get(): Promise<CloudBaseQueryResult>;
    count(): Promise<{
        total: number;
    }>;
    remove(options?: any): Promise<any>;
}
/**
 * CloudBase query result interface
 */
interface CloudBaseQueryResult {
    data: any[];
}

/**
 * Query Builder Interface
 *
 * Database-agnostic query builder for constructing queries
 */
/**
 * Comparison operators
 */
type ComparisonOperator = "eq" | "ne" | "gt" | "gte" | "lt" | "lte" | "in" | "nin";
/**
 * Query builder interface
 */
interface IQueryBuilder {
    /**
     * Add a WHERE condition
     */
    where(field: string, operator: ComparisonOperator, value: any): this;
    /**
     * Add an AND condition
     */
    and(field: string, operator: ComparisonOperator, value: any): this;
    /**
     * Add an OR condition with multiple sub-conditions
     */
    or(conditions: IQueryBuilder[]): this;
    /**
     * Add an IN condition
     */
    in(field: string, values: any[]): this;
    /**
     * Add a regex/pattern matching condition
     */
    regex(field: string, pattern: string, options?: string): this;
    /**
     * Build the final query object for the specific database
     */
    build(): any;
    /**
     * Clone the query builder
     */
    clone(): IQueryBuilder;
}
/**
 * Update builder interface
 */
interface IUpdateBuilder {
    /**
     * Set a field value
     */
    set(field: string, value: any): this;
    /**
     * Set multiple field values
     */
    setMultiple(updates: Record<string, any>): this;
    /**
     * Unset/remove a field
     */
    unset(field: string): this;
    /**
     * Increment a numeric field
     */
    increment(field: string, value: number): this;
    /**
     * Build the final update object for the specific database
     */
    build(): any;
}

/**
 * Common Memory Types
 *
 * Shared type definitions for database-backed memory implementations
 */
/**
 * Generic database document structure
 */
interface BaseMemoryDocument {
    _id?: string;
    sessionId: string;
    messageId: string;
    branchPath: string;
    role: string;
    content: string;
    toolCalls?: any[];
    toolCallId?: string;
    state: Record<string, any>;
    createdAt: Date;
    updatedAt: Date;
}
/**
 * Database adapter interface
 * Abstracts database-specific operations
 */
interface IDatabaseAdapter {
    getCollection(name: string): any;
    find<T = any>(collection: any, query: any, options?: QueryOptions): Promise<T[]>;
    findOne<T = any>(collection: any, query: any): Promise<T | null>;
    insertOne<T = any>(collection: any, document: Partial<T>): Promise<T>;
    insertMany<T = any>(collection: any, documents: Partial<T>[]): Promise<{
        insertedCount: number;
    }>;
    updateOne(collection: any, filter: any, update: any): Promise<{
        modifiedCount: number;
    }>;
    deleteOne(collection: any, filter: any): Promise<{
        deletedCount: number;
    }>;
    deleteMany(collection: any, filter: any): Promise<{
        deletedCount: number;
    }>;
    count(collection: any, query: any): Promise<number>;
    createQueryBuilder(): IQueryBuilder;
    createUpdateBuilder(): IUpdateBuilder;
}

/**
 * Query options
 */
interface QueryOptions {
    sort?: Record<string, 1 | -1>;
    skip?: number;
    limit?: number;
}

/**
 * @fileoverview CloudBase cloud-based memory implementation for Tencent CloudBase
 *
 * CloudBase Memory implementation providing cloud-based persistent storage using
 * Tencent CloudBase database service with support for CRUD operations, session management,
 * branch isolation, and soft delete using cursor-based approach.
 *
 * @example
 * ```typescript
 * import cloudbase from '@cloudbase/node-sdk';
 *
 * const app = cloudbase.init({
 *   env: 'your-env-id',
 *   secretId: 'your-secret-id',
 *   secretKey: 'your-secret-key'
 * });
 *
 * const memory = new CloudBaseMemory({
 *   app,
 *   collectionName: 'memory_events',
 *   sessionId: 'user-session-123'
 * });
 *
 * await memory.add({
 *   message: { id: '1', role: 'user', content: 'Hello' },
 *   state: { userId: 'user123' }
 * });
 *
 * const events = await memory.list({ limit: 10 });
 * ```
 */

/**
 * CloudBase Memory implementation for Tencent CloudBase
 *
 * Provides persistent storage using CloudBase database service with support for
 * session-based memory management, CRUD operations, branch isolation, optional context engineering,
 * and efficient soft delete using cursor-based approach.
 */
declare class CloudBaseMemory extends BaseMemory {
    /** Session identifier for memory isolation */
    sessionId: string;
    /** Whether to enable automatic context management */
    private enableContextManagement;
    private collectionManager;
    private documentConverter;
    private stateManager;
    private cursorManager;
    private branchManager;
    private summaryManager;
    /**
     * Creates a new CloudBaseMemory instance
     * @param options - Configuration options
     * @param options.app - CloudBase app instance from @cloudbase/node-sdk
     * @param options.collectionName - Collection name for storing events (default: 'memory_events')
     * @param options.summaryCollectionName - Collection name for storing summaries (default: 'memory_summaries')
     * @param options.stateCollectionName - Collection name for storing session state (default: 'memory_state')
     * @param options.sessionId - Unique session identifier (default: 'default')
     * @param options.enableContextManagement - Whether to automatically manage context (default: true if thresholds provided)
     */
    constructor(options: {
        app: CloudBaseApp;
        collectionName?: string;
        summaryCollectionName?: string;
        stateCollectionName?: string;
        sessionId?: string;
        enableContextManagement?: boolean;
    } & ConstructorParameters<typeof BaseMemory>[0]);
    /**
     * Returns events from CloudBase database with filtering, pagination, and token limiting
     * Respects branch isolation using branch path and snapshot time
     * @param options - Optional filtering and pagination options
     * @returns Promise resolving to filtered array of memory events
     */
    list(options?: ListOptions): Promise<IMemoryEvent[]>;
    /**
     * Add a single event to CloudBase database
     * @param event - The memory event to store
     * @param options - Optional session options
     */
    add(event: IMemoryEvent, options?: AddOptions): Promise<void>;
    /**
     * Add multiple events efficiently
     * @param list - Array of memory events to store
     * @param options - Optional session options
     */
    addList(list: IMemoryEvent[], options?: AddOptions): Promise<void>;
    /**
     * Update an event in CloudBase database
     * @param params - Update parameters
     */
    update(params: {
        sessionId?: string;
        event: IMemoryEvent;
    }): Promise<void>;
    /**
     * Delete an event from CloudBase database
     * @param idOrIndex - Message ID (string) to delete
     * @param options - Optional session options
     */
    delete(idOrIndex: string | number, options?: DeleteOptions): Promise<void>;
    /**
     * Clear all events from CloudBase database
     * @param options - Optional session options. If sessionId provided, clears only that session using soft delete.
     */
    clear(options?: ClearOptions): Promise<void>;
    /**
     * Check if the session contains any events (respecting soft delete)
     * @param options - Optional session options
     * @returns Promise resolving to true if no events are stored
     */
    isEmpty(options?: {
        sessionId?: string;
    }): Promise<boolean>;
    /**
     * Get the current number of events stored in the session (respecting soft delete)
     * @param options - Optional session options
     * @returns Promise resolving to the count of stored events
     */
    getCount(options?: {
        sessionId?: string;
    }): Promise<number>;
    /**
     * Retrieve events using content-based search
     * @param query - Search query text to match against message content
     * @param options - Optional session options
     * @returns Promise resolving to array of matching events
     */
    retrieve(query: string, options?: RetrieveOptions): Promise<IMemoryEvent[]>;
    /**
     * Get summaries for a session
     * @param sessionId - Optional session identifier
     * @returns Array of structured summaries
     */
    getSummaries(sessionId?: string): Promise<StructuredSummary[]>;
    /**
     * Store summary implementation
     * @param params - Summary storage parameters
     */
    protected storeSummary(params: {
        sessionId?: string;
        summary: StructuredSummary;
    }): Promise<void>;
    /**
     * Clear summarized events implementation using soft delete
     * Sets cursor to hide old events without actually deleting them
     * @param params - Clear parameters
     */
    protected clearSummarizedEvents(params: {
        sessionId: string | undefined;
        recentToKeep: number;
    }): Promise<void>;
    /**
     * Create a new branch from current session state
     * @param branchName - Name for the new branch
     * @param fromEventId - Optional event ID to branch from
     * @returns Promise resolving to branch ID
     */
    branch(branchName: string, fromEventId?: string): Promise<string>;
    /**
     * Switch to a different branch or checkout to a specific event
     * @param target - Branch name or event ID to checkout
     * @param options - Optional configuration
     */
    checkout(target: string, options?: {
        type?: "branch" | "event";
        sessionId?: string;
    }): Promise<void>;
    /**
     * Delete a branch
     * @param branchName - Name of the branch to delete
     */
    deleteBranch(branchName: string): Promise<void>;
    /**
     * List all branches
     * @returns Promise resolving to array of branch information
     */
    listBranches(): Promise<BranchInfo[]>;
    /**
     * Get current branch name
     * @returns Promise resolving to current branch name
     */
    getCurrentBranch(): Promise<string>;
    /**
     * Clean up branches, keeping only specified branches and the current active branch
     * @param keepBranches - Optional list of branch names to keep (in addition to active branch)
     */
    cleanupBranches(keepBranches?: string[]): Promise<void>;
}

/**
 * @fileoverview MongoDB memory implementation for persistent storage
 *
 * MongoDB Memory implementation providing persistent storage using MongoDB
 * with support for CRUD operations, session management, branch isolation,
 * and soft delete using cursor-based approach.
 *
 * @example
 * ```typescript
 * import { MongoClient } from 'mongodb';
 *
 * const client = new MongoClient('mongodb://localhost:27017');
 * await client.connect();
 * const db = client.db('ag_kit_memory');
 *
 * const memory = new MongoDBMemory({
 *   db,
 *   sessionId: 'user-session-123',
 *   collectionName: 'memory_events'
 * });
 *
 * await memory.add({
 *   message: { id: '1', role: 'user', content: 'Hello' },
 *   state: { userId: 'user123' }
 * });
 *
 * const events = await memory.list({ limit: 10 });
 * ```
 */

/**
 * Configuration options for MongoDBMemory
 */
interface MongoDBMemoryConfig extends IBaseMemoryOptions {
    db?: Db;
    connectionString?: string;
    databaseName?: string;
    clientOptions?: MongoClientOptions;
    collectionName?: string;
    stateCollectionName?: string;
    summaryCollectionName?: string;
    sessionId?: string;
    enableContextManagement?: boolean;
}
/**
 * MongoDB Memory implementation for persistent storage
 *
 * Provides persistent storage using MongoDB with support for
 * session-based memory management, CRUD operations, branch isolation, optional context engineering,
 * and efficient soft delete using cursor-based approach.
 */
declare class MongoDBMemory extends BaseMemory {
    /** Session identifier for memory isolation */
    sessionId: string;
    /** Whether to enable automatic context management */
    private enableContextManagement;
    private db;
    private client?;
    private collectionManager;
    private documentConverter;
    private stateManager;
    private cursorManager;
    private branchManager;
    private summaryManager;
    /**
     * Creates a new MongoDBMemory instance
     * @param config - Configuration options
     * @param config.db - MongoDB database instance
     * @param config.connectionString - MongoDB connection string for auto-initialization
     * @param config.databaseName - Database name (default: 'ag_kit_memory')
     * @param config.collectionName - Collection name for storing events (default: 'memory_events')
     * @param config.summaryCollectionName - Collection name for storing summaries (default: 'memory_summaries')
     * @param config.stateCollectionName - Collection name for storing session state (default: 'memory_state')
     * @param config.sessionId - Unique session identifier (default: 'default')
     * @param config.enableContextManagement - Whether to automatically manage context (default: true if thresholds provided)
     */
    constructor(config: MongoDBMemoryConfig);
    /**
     * Initialize MongoDB connection and managers
     */
    initialize(config: MongoDBMemoryConfig): Promise<void>;
    /**
     * Initialize all manager instances
     */
    private _initializeManagers;
    /**
     * Add a single event to MongoDB database
     * @param event - The memory event to store
     * @param options - Optional session options
     */
    add(event: IMemoryEvent, options?: AddOptions): Promise<void>;
    /**
     * Add multiple events efficiently
     * @param list - Array of memory events to store
     * @param options - Optional session options
     */
    addList(list: IMemoryEvent[], options?: AddOptions): Promise<void>;
    /**
     * Returns events from MongoDB database with filtering, pagination, and token limiting
     * Respects branch isolation using branch path and snapshot time
     * @param options - Optional filtering and pagination options
     * @returns Promise resolving to filtered array of memory events
     */
    list(options?: ListOptions): Promise<IMemoryEvent[]>;
    /**
     * Update an event in MongoDB database
     * @param params - Update parameters
     */
    update(params: {
        sessionId?: string;
        event: IMemoryEvent;
    }): Promise<void>;
    /**
     * Delete an event from MongoDB database
     * @param messageId - Message ID (string) to delete
     * @param options - Optional session options
     */
    delete(messageId: string): Promise<void>;
    /**
     * Clear all events from MongoDB database
     * @param options - Optional session options. If sessionId provided, clears only that session using soft delete.
     */
    clear(options?: ClearOptions): Promise<void>;
    /**
     * Check if the session contains any events (respecting soft delete)
     * @param options - Optional session options
     * @returns Promise resolving to true if no events are stored
     */
    isEmpty(options?: {
        sessionId?: string;
    }): Promise<boolean>;
    /**
     * Get the current number of events stored in the session (respecting soft delete)
     * @param options - Optional session options
     * @returns Promise resolving to the count of stored events
     */
    getCount(options?: {
        sessionId?: string;
    }): Promise<number>;
    /**
     * Retrieve events using content-based search
     * @param query - Search query text to match against message content
     * @param options - Optional session options
     * @returns Promise resolving to array of matching events
     */
    retrieve(query: string, options?: RetrieveOptions): Promise<IMemoryEvent[]>;
    /**
     * Get summaries for a session
     * @param sessionId - Optional session identifier
     * @returns Array of structured summaries
     */
    getSummaries(sessionId?: string): Promise<StructuredSummary[]>;
    /**
     * Store summary implementation
     * @param params - Summary storage parameters
     */
    protected storeSummary(params: {
        sessionId?: string;
        summary: StructuredSummary;
    }): Promise<void>;
    /**
     * Clear summarized events implementation using soft delete
     * Sets cursor to hide old events without actually deleting them
     * @param params - Clear parameters
     */
    protected clearSummarizedEvents(params: {
        sessionId: string | undefined;
        recentToKeep: number;
    }): Promise<void>;
    /**
     * Create a new branch from current session state
     * @param branchName - Name for the new branch
     * @param fromEventId - Optional event ID to branch from
     * @returns Promise resolving to branch ID
     */
    branch(branchName: string, fromEventId?: string): Promise<string>;
    /**
     * Switch to a different branch or checkout to a specific event
     * @param target - Branch name or event ID to checkout
     * @param options - Optional configuration
     */
    checkout(target: string, options?: {
        type?: "branch" | "event";
        sessionId?: string;
    }): Promise<void>;
    /**
     * Delete a branch
     * @param branchName - Name of the branch to delete
     */
    deleteBranch(branchName: string): Promise<void>;
    /**
     * List all branches
     * @returns Promise resolving to array of branch information
     */
    listBranches(): Promise<BranchInfo[]>;
    /**
     * Get current branch name
     * @returns Promise resolving to current branch name
     */
    getCurrentBranch(): Promise<string>;
    /**
     * Clean up branches, keeping only specified branches and the current active branch
     * @param keepBranches - Optional list of branch names to keep (in addition to active branch)
     */
    cleanupBranches(keepBranches?: string[]): Promise<void>;
    /**
     * Close MongoDB connection (if managed by this instance)
     */
    close(): Promise<void>;
    /**
     * Check if MongoDB connection is ready
     */
    isReady(): boolean;
    /**
     * Get database instance (for advanced usage)
     */
    getDatabase(): Db;
    /**
     * Ensure MongoDB is initialized before operations
     */
    private ensureInitialized;
}

/**
 * Document Converter
 *
 * Converts between memory events and database documents
 */

declare class DocumentConverter {
    /**
     * Convert memory event to database document
     */
    toDocument(event: IMemoryEvent, sessionId: string, branchPath: string): Omit<BaseMemoryDocument, "_id">;
    /**
     * Convert database document to memory event
     */
    fromDocument(doc: BaseMemoryDocument): IMemoryEvent;
}

/**
 * @fileoverview TypeORM memory implementation for persistent storage
 *
 * TypeORM Memory implementation providing persistent storage using TypeORM
 * with support for CRUD operations, session management, branch isolation,
 * and soft delete using cursor-based approach. Supports multiple databases
 * including MySQL, PostgreSQL, and SQLite.
 *
 * @example
 * ```typescript
 * import { DataSource } from 'typeorm';
 *
 * const dataSource = new DataSource({
 *   type: 'sqlite',
 *   database: ':memory:',
 *   entities: [MemoryEvent, MemoryState, MemorySummary],
 *   synchronize: true
 * });
 * await dataSource.initialize();
 *
 * const memory = new TypeORMMemory({
 *   dataSource,
 *   sessionId: 'user-session-123',
 *   eventTableName: 'memory_events'
 * });
 *
 * await memory.add({
 *   message: { id: '1', role: 'user', content: 'Hello' },
 *   state: { userId: 'user123' }
 * });
 *
 * const events = await memory.list({ limit: 10 });
 * ```
 */

/**
 * Configuration options for TypeORMMemory
 */
interface TypeORMMemoryConfig extends IBaseMemoryOptions {
    dataSource: DataSource;
    eventTableName?: string;
    stateTableName?: string;
    summaryTableName?: string;
    sessionId?: string;
    enableContextManagement?: boolean;
    documentConverter?: DocumentConverter;
}
/**
 * TypeORM Memory implementation for persistent storage
 *
 * Provides persistent storage using TypeORM with support for
 * session-based memory management, CRUD operations, branch isolation, optional context engineering,
 * and efficient soft delete using cursor-based approach.
 */
declare class TypeORMMemory extends BaseMemory {
    /** Session identifier for memory isolation */
    sessionId: string;
    /** Whether to enable automatic context management */
    private enableContextManagement;
    private dataSource;
    private collectionManager;
    private documentConverter;
    private stateManager;
    private cursorManager;
    private branchManager;
    private summaryManager;
    /**
     * Creates a new TypeORMMemory instance
     * @param config - Configuration options
     * @param config.dataSource - TypeORM DataSource instance
     * @param config.eventTableName - Table name for storing events (default: 'memory_events')
     * @param config.summaryTableName - Table name for storing summaries (default: 'memory_summaries')
     * @param config.stateTableName - Table name for storing session state (default: 'memory_state')
     * @param config.sessionId - Unique session identifier (default: 'default')
     * @param config.enableContextManagement - Whether to automatically manage context (default: true if thresholds provided)
     */
    constructor(config: TypeORMMemoryConfig);
    private _initializationPromise;
    /**
     * Initialize entities and managers asynchronously
     */
    private _initialize;
    /**
     * Initialize entities based on table names and ensure DataSource uses them
     * This approach ensures that the same entity classes are used for both
     * DataSource registration and repository creation
     */
    private _initializeEntities;
    /**
     * Initialize all manager instances
     */
    private _initializeManagers;
    /**
     * Add a single event to TypeORM database
     * @param event - The memory event to store
     * @param options - Optional session options
     */
    add(event: IMemoryEvent, options?: AddOptions): Promise<void>;
    /**
     * Add multiple events efficiently
     * @param list - Array of memory events to store
     * @param options - Optional session options
     */
    addList(list: IMemoryEvent[], options?: AddOptions): Promise<void>;
    /**
     * Returns events from TypeORM database with filtering, pagination, and token limiting
     * Respects branch isolation using branch path and snapshot time
     * @param options - Optional filtering and pagination options
     * @returns Promise resolving to filtered array of memory events
     */
    list(options?: ListOptions): Promise<IMemoryEvent[]>;
    /**
     * Update an event in TypeORM database
     * @param params - Update parameters
     */
    update(params: {
        sessionId?: string;
        event: IMemoryEvent;
    }): Promise<void>;
    /**
     * Delete an event from TypeORM database
     * @param idOrIndex - Message ID (string) to delete
     * @param options - Optional session options
     */
    delete(idOrIndex: string | number, options?: DeleteOptions): Promise<void>;
    /**
     * Clear all events from TypeORM database
     * @param options - Optional session options. If sessionId provided, clears only that session using soft delete.
     */
    clear(options?: ClearOptions): Promise<void>;
    /**
     * Check if the session contains any events (respecting soft delete)
     * @param options - Optional session options
     * @returns Promise resolving to true if no events are stored
     */
    isEmpty(options?: {
        sessionId?: string;
    }): Promise<boolean>;
    /**
     * Get the current number of events stored in the session (respecting soft delete)
     * @param options - Optional session options
     * @returns Promise resolving to the count of stored events
     */
    getCount(options?: {
        sessionId?: string;
    }): Promise<number>;
    /**
     * Retrieve events using content-based search
     * @param query - Search query text to match against message content
     * @param options - Optional session options
     * @returns Promise resolving to array of matching events
     */
    retrieve(query: string, options?: RetrieveOptions): Promise<IMemoryEvent[]>;
    /**
     * Get summaries for a session
     * @param sessionId - Optional session identifier
     * @returns Array of structured summaries
     */
    getSummaries(sessionId?: string): Promise<StructuredSummary[]>;
    /**
     * Store summary implementation
     * @param params - Summary storage parameters
     */
    protected storeSummary(params: {
        sessionId?: string;
        summary: StructuredSummary;
    }): Promise<void>;
    /**
     * Clear summarized events implementation using soft delete
     * Sets cursor to hide old events without actually deleting them
     * @param params - Clear parameters
     */
    protected clearSummarizedEvents(params: {
        sessionId: string | undefined;
        recentToKeep: number;
    }): Promise<void>;
    /**
     * Create a new branch from current session state
     * @param branchName - Name for the new branch
     * @param fromEventId - Optional event ID to branch from
     * @returns Promise resolving to branch ID
     */
    branch(branchName: string, fromEventId?: string): Promise<string>;
    /**
     * Switch to a different branch or checkout to a specific event
     * @param target - Branch name or event ID to checkout
     * @param options - Optional configuration
     */
    checkout(target: string, options?: {
        type?: "branch" | "event";
        sessionId?: string;
    }): Promise<void>;
    /**
     * Delete a branch
     * @param branchName - Name of the branch to delete
     */
    deleteBranch(branchName: string): Promise<void>;
    /**
     * List all branches
     * @returns Promise resolving to array of branch information
     */
    listBranches(): Promise<BranchInfo[]>;
    /**
     * Get current branch name
     * @returns Promise resolving to current branch name
     */
    getCurrentBranch(): Promise<string>;
    /**
     * Clean up branches, keeping only specified branches and the current active branch
     * @param keepBranches - Optional list of branch names to keep (in addition to active branch)
     */
    cleanupBranches(keepBranches?: string[]): Promise<void>;
    /**
     * Check if TypeORM connection is ready
     */
    isReady(): boolean;
    /**
     * Close TypeORM DataSource connection and clean up resources
     * This method should be called when the memory instance is no longer needed
     * to properly release database connections and prevent connection leaks
     *
     * @throws Error if there's an issue closing the connection
     *
     * @example
     * ```typescript
     * const memory = new TypeORMMemory({ dataSource, sessionId: 'test' });
     * // ... use memory
     * await memory.close(); // Clean up when done
     * ```
     */
    close(): Promise<void>;
    /**
     * Get DataSource instance (for advanced usage)
     */
    getDataSource(): DataSource;
    /**
     * Ensure TypeORM is initialized before operations
     */
    ensureInitialized(): Promise<void>;
    /**
     * Create a TypeORM DataSource configuration
     */
    static createDataSource(config: {
        type: "mysql" | "postgres" | "sqlite";
        host?: string;
        port?: number;
        username?: string;
        password?: string;
        database?: string;
        filename?: string;
        synchronize?: boolean;
        logging?: boolean;
    }): DataSource;
}

/**
 * @fileoverview MySQL Memory implementation for persistent storage
 *
 * MySQL Memory implementation providing persistent storage using TypeORM
 * with MySQL-specific optimizations. Extends TypeORMMemory to provide
 * all advanced features including CRUD operations, session management,
 * branch isolation, context engineering, and soft delete using cursor-based approach.
 *
 * @example
 * ```typescript
 * // Basic usage
 * const memory = MySQLMemory.create({
 *   host: 'localhost',
 *   port: 3306,
 *   username: 'root',
 *   password: 'password',
 *   database: 'myapp',
 *   sessionId: 'user-session-123'
 * });
 *
 * await memory.add({
 *   message: { id: '1', role: 'user', content: 'Hello' },
 *   state: { userId: 'user123' }
 * });
 *
 * const events = await memory.list({ limit: 10 });
 *
 * // Clean up when done
 * await memory.close();
 * ```
 *
 * @example
 * ```typescript
 * // Advanced configuration with connection pooling and context management
 * const memory = new MySQLMemory({
 *   connection: {
 *     host: 'localhost',
 *     port: 3306,
 *     username: 'root',
 *     password: 'password',
 *     database: 'myapp',
 *     pool: {
 *       max: 20,
 *       min: 5,
 *       acquireTimeoutMillis: 30000,
 *       idleTimeoutMillis: 300000
 *     }
 *   },
 *   sessionId: 'user-session-123',
 *   eventTableName: 'custom_events',
 *   stateTableName:
 *     maxTokens: 8000,
 *     targetTokens: 6000,
 *     summaryTokens: 1000
 *   },
 *   enableContextManagement: true
 * });
 * ```
 *
 * @example
 * ```typescript
 * // Using connection string
 * const memory = MySQLMemory.fromConnectionString(
 *   'mysql://user:pass@localhost:3306/mydb',
 *   'session-123',
 *   {
 *     thresholds: { maxTokens: 10000 },
 *     enableContextManagement: true
 *   }
 * );
 * ```
 */

/**
 * MySQL-specific connection configuration
 * Extends TypeORM's MysqlConnectionOptions with additional AG-Kit specific options
 */
interface MySQLConnectionConfig extends Omit<MysqlConnectionOptions, "type" | "entities" | "synchronize" | "logging"> {
    /** MySQL host */
    host: string;
    /** MySQL port (default: 3306) */
    port?: number;
    /** MySQL username */
    username: string;
    /** MySQL password */
    password: string;
    /** MySQL database name */
    database: string;
}
/**
 * Configuration options for MySQLMemory
 */
type MySQLMemoryConfig = {
    /** Database connection configuration */
    connection: MySQLConnectionConfig;
    /** Whether to automatically initialize database schema (default: true) */
    autoInitialize?: boolean;
    /** Enable SQL query logging for debugging (default: false) */
    enableLogging?: boolean;
} & Omit<ConstructorParameters<typeof TypeORMMemory>[0], "dataSource">;
/**
 * MySQL Memory implementation using TypeORM
 *
 * This class extends TypeORMMemory and provides MySQL-specific configuration
 * and optimizations while leveraging all the advanced features including:
 * - Session-based memory isolation
 * - CRUD operations with soft delete
 * - Branch management and checkout
 * - Context engineering and automatic summarization
 * - Connection pooling and performance optimization
 * - Transaction support
 * - Schema synchronization
 * - Migration support
 * - MySQL-specific query optimizations
 */
declare class MySQLMemory extends TypeORMMemory {
    /**
     * Creates a new MySQLMemory instance
     * @param config - MySQL-specific configuration options
     */
    constructor(config: MySQLMemoryConfig);
    /**
     * Create a MySQL DataSource configuration with optimizations
     */
    private static createMySQLDataSource;
    /**
     * Create a MySQL Memory instance with connection string
     *
     * @param connectionString - MySQL connection string (mysql://username:password@host:port/database)
     * @param sessionId - Session identifier for memory isolation
     * @param options - Additional configuration options
     * @returns MySQLMemory instance
     * 'custom_state',
     *   summaryTableName: 'custom_summaries',
     *   thresholds: {
     * @example
     * ```typescript
     * const memory = MySQLMemory.fromConnectionString(
     *   'mysql://user:pass@localhost:3306/mydb',
     *   'session-123',
     *   {
     *     thresholds: { maxTokens: 10000 },
     *     enableContextManagement: true
     *   }
     * );
     * ```
     */
    static fromConnectionString(connectionString: string, sessionId: string, options?: Partial<MySQLMemoryConfig>): MySQLMemory;
    /**
     * Create a MySQL Memory instance with simple configuration
     *
     * @param config - Simple configuration object
     * @returns MySQLMemory instance
     *
     * @example
     * ```typescript
     * const memory = MySQLMemory.create({
     *   host: 'localhost',
     *   port: 3306,
     *   username: 'root',
     *   password: 'password',
     *   database: 'myapp',
     *   sessionId: 'user-session-123'
     * });
     * ```
     */
    static create(config: MySQLMemoryConfig): MySQLMemory;
    /**
     * Get MySQL-specific connection information
     * @returns Connection information object
     */
    getConnectionInfo(): {
        host: string;
        port: number;
        database: string;
        username: string;
    };
}

/**
 * Simplified TypeORM Adapter
 *
 * Simple adapter that works with TypeORM repositories
 */

declare class TypeORMAdapter implements IDatabaseAdapter {
    /**
     * Get collection (for TypeORM, this is handled by CollectionManager)
     * This method is required by IDatabaseAdapter but not used directly
     */
    getCollection(name: string): any;
    /**
     * Find documents using TypeORM repository
     */
    find<T = any>(repository: Repository<any>, query: any, options?: QueryOptions): Promise<T[]>;
    /**
     * Check if query is a complex query from our query builder
     */
    private isComplexQuery;
    /**
     * Handle complex queries with custom where clauses
     */
    private handleComplexQuery;
    /**
     * Handle array queries (OR conditions)
     */
    private handleArrayQuery;
    /**
     * Handle array queries containing complex queries
     */
    private handleComplexArrayQuery;
    /**
     * Build OR conditions from mixed query array
     */
    private buildOrConditions;
    /**
     * Process complex query condition
     */
    private processComplexCondition;
    /**
     * Process simple query condition
     */
    private processSimpleCondition;
    /**
     * Handle simple array queries using TypeORM's built-in OR handling
     */
    private handleSimpleArrayQuery;
    /**
     * Handle simple single queries
     */
    private handleSimpleQuery;
    /**
     * Apply query options to QueryBuilder
     */
    private applyQueryOptions;
    /**
     * Apply query options to FindManyOptions
     */
    private applyFindOptions;
    /**
     * Find one document
     */
    findOne<T = any>(repository: Repository<any>, query: any): Promise<T | null>;
    /**
     * Insert one document
     */
    insertOne<T = any>(repository: Repository<any>, document: Partial<T>): Promise<T>;
    /**
     * Insert many documents
     */
    insertMany<T = any>(repository: Repository<any>, documents: Partial<T>[]): Promise<{
        insertedCount: number;
    }>;
    /**
     * Update one document
     */
    updateOne(repository: Repository<any>, filter: any, update: any): Promise<{
        modifiedCount: number;
    }>;
    /**
     * Delete one document
     */
    deleteOne(repository: Repository<any>, filter: any): Promise<{
        deletedCount: number;
    }>;
    /**
     * Delete many documents
     */
    deleteMany(repository: Repository<any>, filter: any): Promise<{
        deletedCount: number;
    }>;
    /**
     * Execute delete operation with proper query handling
     */
    private executeDelete;
    /**
     * Count documents
     */
    count(repository: Repository<any>, query: any): Promise<number>;
    /**
     * Create query builder
     */
    createQueryBuilder(): IQueryBuilder;
    /**
     * Create update builder
     */
    createUpdateBuilder(): IUpdateBuilder;
}

/**
 * TypeORM Query Builder Implementation
 *
 * Provides type-safe query building for TypeORM with SQL injection protection
 */

declare class TypeORMQueryBuilder implements IQueryBuilder {
    private conditions;
    private parameters;
    private paramCounter;
    private orConditions;
    where(field: string, operator: any, value: any): this;
    and(field: string, operator: any, value: any): this;
    or(conditions: IQueryBuilder[]): this;
    in(field: string, values: any[]): this;
    regex(field: string, pattern: string, options?: string): this;
    clone(): IQueryBuilder;
    build(): any;
    private addCondition;
}
declare class TypeORMUpdateBuilder implements IUpdateBuilder {
    private updates;
    set(field: string, value: any): this;
    setMultiple(updates: Record<string, any>): this;
    unset(field: string): this;
    increment(field: string, value: number): this;
    build(): any;
}

/**
 * TypeORM Entity for Memory Events using Decorator Syntax
 *
 * More standard TypeORM approach with better IDE support and type safety
 */

/**
 * Memory Event Entity using TypeORM decorators
 *
 * This approach provides:
 * - Better IDE support and autocomplete
 * - Type safety at compile time
 * - Standard TypeORM patterns
 * - Wider compatibility across databases
 */
declare class MemoryEvent implements BaseMemoryDocument {
    _id: string;
    sessionId: string;
    messageId: string;
    branchPath: string;
    role: string;
    content: string;
    toolCalls?: any[];
    toolCallId?: string;
    state: Record<string, any>;
    createdAt: Date;
    updatedAt: Date;
}
type MemoryEventEntity = MemoryEvent;

/**
 * Memory entity interface representing a stored memory item
 */
interface MemoryEntity {
    /** Unique identifier for the memory */
    id: string;
    /** Memory strategy/category for classification */
    strategy: string;
    /** Role of the message creator */
    role?: "user" | "assistant";
    /** Memory content text */
    content: string;
    /** Additional metadata for the memory */
    metadata: Record<string, any>;
    /** Creation timestamp */
    createdAt: Date;
    /** Last update timestamp */
    updatedAt?: Date;
}
/**
 * Memory query interface for searching and filtering memories
 */
interface MemoryQuery {
    /** Semantic query text for content matching */
    query?: string;
    /** Strategy filter - single strategy or array of strategies */
    strategy?: string | string[];
    /** Maximum number of results to return */
    limit?: number;
    /** Number of results to skip for pagination */
    offset?: number;
    /** Sorting criteria with field names and directions */
    orderBy?: Record<string, 1 | -1>;
    /** Custom filtering conditions - implementers can add any query conditions */
    [key: string]: any;
}
/**
 * @fileoverview Abstract base class for long-term memory implementations
 *
 * This base class defines the core interface and common functionality for long-term memory systems.
 * Concrete implementations can be based on different storage backends such as vector databases,
 * graph databases, or other persistent storage solutions.
 *
 * @example
 * ```typescript
 * class CustomLongTermMemory extends BaseLongTermMemory {
 *   async record(memory: MemoryEntity): Promise<void> {
 *     // Custom implementation
 *   }
 *   // ... implement other required methods
 * }
 * ```
 */
declare abstract class BaseLongTermMemory {
    /** Configuration object for the memory implementation */
    protected config: any;
    /**
     * Creates a new BaseLongTermMemory instance
     * @param config - Configuration object for the memory implementation
     */
    constructor(config?: any);
    /**
     * Record a new memory entity
     * @param memory - The memory entity to store
     */
    abstract record(memory: MemoryEntity): Promise<void>;
    /**
     * Record multiple memory entities in batch
     * @param memories - Array of memory entities to store
     */
    abstract recordBatch(memories: MemoryEntity[]): Promise<void>;
    /**
     * Retrieve memories based on query conditions
     * @param query - Query conditions for filtering and searching
     */
    abstract retrieve(query: MemoryQuery): Promise<MemoryEntity[]>;
    /**
     * Delete memory by ID or query conditions
     * @param memoryId - Memory ID (string) or query conditions (MemoryQuery)
     */
    abstract delete(memoryId: string | MemoryQuery): Promise<void>;
    /**
     * Update an existing memory entity
     * @param memoryId - ID of the memory to update
     * @param updates - Partial memory entity with fields to update
     */
    abstract update(memoryId: string, updates: Partial<MemoryEntity>): Promise<void>;
    /**
     * Clear all memories for a specific strategy or all memories
     * @param strategy - Optional strategy filter; if not specified, clears all memories
     */
    abstract clear(strategy?: string): Promise<void>;
    /**
     * Extract and record memories from conversation messages
     * @param messages - Array of conversation messages to analyze
     * @param context - Additional context information for extraction
     * @returns Promise resolving to array of extracted memory entities
     */
    abstract extractAndRecord(messages: Message[], context: Record<string, any>): Promise<MemoryEntity[]>;
    /**
     * Perform semantic search on stored memories
     * @param query - Search query text for semantic matching
     * @param options - Optional search parameters and filters
     * @returns Promise resolving to array of semantically similar memories
     */
    abstract semanticSearch(query: string, options?: MemoryQuery): Promise<MemoryEntity[]>;
    /**
     * Get memories related to a specific memory entity
     * @param memoryId - ID of the memory to find relations for
     * @param depth - Relationship depth to traverse, defaults to 1
     * @returns Promise resolving to array of related memory entities
     */
    abstract getRelatedMemories(memoryId: string, depth?: number): Promise<MemoryEntity[]>;
    /**
     * Consolidate and optimize stored memories
     * Includes operations like deduplication, merging, decay, and reinforcement
     * @returns Promise that resolves when consolidation is complete
     */
    abstract consolidate(): Promise<void>;
    /**
     * Generate a unique memory ID
     * Implementers can override this method to customize ID generation strategy
     * @returns Unique memory identifier string
     */
    protected generateMemoryId(): string;
}

/**
 * TDAI 
 */
interface TDAILongTermMemoryConfig {
    client: MemoryClient;
    sessionId?: string;
}
/**
 *  TDAI 
 *
 *  TDAI  records API 
 */
declare class TDAILongTermMemory extends BaseLongTermMemory {
    private client;
    private sessionId;
    constructor(config: TDAILongTermMemoryConfig);
    /**
     * 
     */
    record(memory: Pick<MemoryEntity, "content" | "strategy" | "metadata">): Promise<void>;
    /**
     * 
     */
    recordBatch(memories: MemoryEntity[]): Promise<void>;
    /**
     * 
     */
    retrieve(query: MemoryQuery): Promise<MemoryEntity[]>;
    /**
     * 
     */
    delete(recordId: string | MemoryQuery): Promise<void>;
    /**
     * 
     */
    update(memoryId: string, updates: Partial<MemoryEntity>): Promise<void>;
    /**
     * 
     */
    semanticSearch(query: string, options?: MemoryQuery): Promise<MemoryEntity[]>;
    /**
     * 
     */
    clear(strategy?: string): Promise<void>;
    /**
     * 
     * TODO:  LLM 
     */
    extractAndRecord(messages: Message[], context: Record<string, any>): Promise<MemoryEntity[]>;
    /**
     * 
     */
    getRelatedMemories(memoryId: string, depth?: number): Promise<MemoryEntity[]>;
    /**
     * TODO: imply 
     * 
     * 
     * 
     */
    consolidate(): Promise<void>;
}

type ClientOptions = ConstructorParameters<typeof MemoryClient$1>[0];
/**
 * Mem0 Long Term Memory Configuration
 * Based on MemoryClient's ClientOptions with additional agent-specific options
 */
interface Mem0LongTermMemoryConfig extends ClientOptions {
    /** Default user ID for memory operations */
    userId?: string;
    /** Default agent ID for memory operations */
    agentId?: string;
    /** Default app ID for memory operations */
    appId?: string;
}
/**
 * Mem0LongTermMemory - Implementation using official Mem0 SDK
 *
 * This implementation provides intelligent memory management using Mem0's
 * advanced features including automatic memory extraction, semantic search,
 * and intelligent memory consolidation.
 */
declare class Mem0LongTermMemory extends BaseLongTermMemory {
    private client;
    private defaultOptions;
    constructor(config: Mem0LongTermMemoryConfig);
    /**
     * Record a new memory entity
     */
    record(memory: MemoryEntity): Promise<void>;
    /**
     * Record multiple memories in batch
     */
    recordBatch(memories: MemoryEntity[]): Promise<void>;
    /**
     * Retrieve memories based on query
     */
    retrieve(query: MemoryQuery): Promise<MemoryEntity[]>;
    /**
     * Delete memory by ID or query
     */
    delete(memoryId: string | MemoryQuery): Promise<void>;
    /**
     * Update memory content or metadata
     */
    update(memoryId: string, updates: Partial<MemoryEntity>): Promise<void>;
    /**
     * Clear memories by strategy
     */
    clear(strategy?: string): Promise<void>;
    /**
     * Extract and record memories from conversation messages
     */
    extractAndRecord(messages: any[], context: Record<string, any>): Promise<MemoryEntity[]>;
    /**
     * Semantic search using Mem0's intelligent search
     */
    semanticSearch(query: string, options?: MemoryQuery): Promise<MemoryEntity[]>;
    /**
     * Get related memories using Mem0's graph-based relationships
     */
    getRelatedMemories(memoryId: string, depth?: number): Promise<MemoryEntity[]>;
    /**
     * Consolidate memories - Mem0 handles this automatically, but we can trigger it
     */
    consolidate(): Promise<void>;
    /**
     * Get memory history for a specific memory
     */
    getMemoryHistory(memoryId: string): Promise<any[]>;
    /**
     * Get all users (if available)
     */
    getUsers(): Promise<any>;
    /**
     * Provide feedback on a memory
     */
    provideFeedback(memoryId: string, feedback: "POSITIVE" | "NEGATIVE" | "VERY_NEGATIVE", reason?: string): Promise<void>;
    /**
     * Test connection to Mem0
     */
    ping(): Promise<void>;
    /**
     * Convert Mem0 Memory objects to MemoryEntity
     */
    private convertToMemoryEntities;
    /**
     * Convert single Mem0 Memory to MemoryEntity
     */
    private convertMem0ToMemoryEntity;
}

/**
 * Error thrown when parameters are incorrect
 */
declare class ParamError extends Error {
    constructor(message: string);
}
/**
 * TDAI API Exception
 */
declare class TDAIException extends Error {
    code?: string | number;
    message: string;
    requestId?: string;
    constructor(data: {
        code?: string | number;
        message?: string;
        req_id?: string;
    }, requestId?: string);
    toString(): string;
}

type StateConstraint = Record<string, unknown>;
type OutputConstraint = string | Record<string, unknown> | Array<unknown>;

interface AgentConfig<TState extends StateConstraint = StateConstraint, TOutput extends OutputConstraint = string> {
    name: string;
    description?: string;
    model: ModelProvider$1 | string;
    instructions?: string | InstructionProvider<TState>;
    stateType?: new () => TState;
    outputType?: OutputType<TOutput>;
    modelSettings?: ModelSettings;
    tools?: BaseTool<any, TState>[];
    memory?: BaseMemory;
    humanInTheLoop?: HumanInTheLoopConfig;
    controlFlow?: ControlFlowConfig;
}
type InstructionProvider<TState extends StateConstraint> = (state: TState, context: RunContext<TState>) => string | Promise<string>;
type OutputType<TOutput extends OutputConstraint> = "string" | "structured" | {
    schema: z.ZodObject<any>;
};
interface ModelSettings {
    temperature?: number;
    maxTokens?: number;
    topP?: number;
    frequencyPenalty?: number;
    presencePenalty?: number;
    stop?: string[];
}
interface HumanInTheLoopConfig {
    enabled: boolean;
    requireApproval?: string[];
    highRiskTools?: string[];
    timeout?: number;
    defaultAction?: "approve" | "reject" | "pause";
}
interface ControlFlowConfig {
    maxSteps?: number;
    errorRetryLimit?: number;
    pauseOnHumanInput?: boolean;
    customHandler?: ControlFlowHandler<any>;
}
interface RunOptions<TState extends StateConstraint = StateConstraint> {
    state?: TState;
    conversationId?: string;
    runId?: string;
    userId?: string;
    model?: string;
    temperature?: number;
    maxTokens?: number;
    stream?: boolean;
    tools?: BaseTool<any, TState>[];
    timeout?: number;
    retryAttempts?: number;
    metadata?: Record<string, any>;
    requireApproval?: boolean;
    resume?: {
        interruptId: string;
        payload: string;
    };
    signal?: AbortSignal;
    onEvent?: (event: any) => void;
}
interface RunContext<TState = unknown> {
    conversationId: string;
    runId: string;
    userId?: string;
    requestId?: string;
    messages: Message[];
    state?: TState;
    metadata?: Record<string, any>;
}
interface MessageMetadata {
    state?: Record<string, unknown>;
    conversationId?: string;
    runId?: string;
    userId?: string;
    [key: string]: unknown;
}
interface Message {
    id: string;
    role: "user" | "assistant" | "system" | "tool";
    content: string;
    toolCalls?: ToolCall$1[];
    toolCallId?: string;
    timestamp?: Date;
    metadata?: MessageMetadata;
}
interface ToolCall$1 {
    id: string;
    function: {
        name: string;
        arguments: string;
    };
}
interface AgentState<TState = unknown> {
    businessState: TState;
    context: RunContext<TState>;
    conversationId?: string;
    runId?: string;
    status: "idle" | "running" | "paused" | "error";
    lastActivity?: Date;
}
interface AgentResult<TOutput = string> {
    success: boolean;
    data?: TOutput;
    messages: Message[];
    toolCalls?: ToolCall$1[];
    error?: AgentError;
    metadata: {
        conversationId: string;
        runId: string;
        executionTime: number;
        tokenUsage?: TokenUsage;
    };
}
type AgentError = AGKitError;
interface TokenUsage {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
}
interface ModelProvider$1 {
    chat: {
        completions: {
            create: (params: any) => Promise<any>;
            stream: (params: any) => AsyncIterable<any>;
        };
    };
}
interface MemoryProvider {
    saveMessage(conversationId: string, message: Message): Promise<void>;
    getMessages(conversationId: string, limit?: number): Promise<Message[]>;
    clearHistory(conversationId: string): Promise<void>;
    saveMemory(conversationId: string, key: string, value: any): Promise<void>;
    getMemory(conversationId: string, key: string): Promise<any>;
    searchMemory(conversationId: string, query: string): Promise<any[]>;
}
interface ControlFlowHandler<TState = unknown> {
    handleNextStep(context: any, state?: TState): Promise<ControlFlowDecision>;
    handleToolCall(toolCall: ToolCall$1, context: any, state?: TState): Promise<ToolCallDecision>;
    handleError(error: AgentError, context: any, state?: TState): Promise<ErrorHandlingDecision>;
}
type ControlFlowDecision = {
    action: "continue";
    nextStep: any;
} | {
    action: "pause";
    reason: string;
    resumeData?: any;
} | {
    action: "complete";
    result: any;
} | {
    action: "interrupt";
    reason: string;
    payload?: any;
} | {
    action: "escalate";
    target: "human" | "agent";
    context: any;
};
type ToolCallDecision = {
    action: "execute";
    immediate: boolean;
} | {
    action: "request_approval";
    approver: "human" | "agent";
} | {
    action: "reject";
    reason: string;
} | {
    action: "modify";
    newParams: any;
};
type ErrorHandlingDecision = {
    action: "retry";
    maxAttempts: number;
} | {
    action: "recover";
    recoveryStep: any;
} | {
    action: "escalate";
    target: "human" | "agent";
} | {
    action: "abort";
    reason: string;
};
interface ConversationConfig {
    metadata?: Record<string, any>;
    ttl?: number;
    maxHistoryLength?: number;
}

declare enum EventType$1 {
    TEXT_MESSAGE_START = "TEXT_MESSAGE_START",
    TEXT_MESSAGE_CONTENT = "TEXT_MESSAGE_CONTENT",
    TEXT_MESSAGE_END = "TEXT_MESSAGE_END",
    TOOL_CALL_START = "TOOL_CALL_START",
    TOOL_CALL_ARGS = "TOOL_CALL_ARGS",
    TOOL_CALL_END = "TOOL_CALL_END",
    STATE_SNAPSHOT = "STATE_SNAPSHOT",
    STATE_DELTA = "STATE_DELTA",
    MESSAGES_SNAPSHOT = "MESSAGES_SNAPSHOT",
    RAW = "RAW",
    CUSTOM = "CUSTOM",
    RUN_STARTED = "RUN_STARTED",
    RUN_FINISHED = "RUN_FINISHED",
    RUN_ERROR = "RUN_ERROR",
    STEP_STARTED = "STEP_STARTED",
    STEP_FINISHED = "STEP_FINISHED",
    TEXT_MESSAGE_CHUNK = "TEXT_MESSAGE_CHUNK",
    TOOL_CALL_CHUNK = "TOOL_CALL_CHUNK",
    TOOL_CALL_RESULT = "TOOL_CALL_RESULT",
    TOOL_REGISTERED = "TOOL_REGISTERED",
    TOOL_UNREGISTERED = "TOOL_UNREGISTERED",
    TOOL_VALIDATION_FAILED = "TOOL_VALIDATION_FAILED",
    STATE_UPDATE = "STATE_UPDATE",
    APPROVAL_REQUIRED = "APPROVAL_REQUIRED",
    APPROVAL_RECEIVED = "APPROVAL_RECEIVED",
    CONVERSATION_CREATED = "CONVERSATION_CREATED",
    CONVERSATION_UPDATED = "CONVERSATION_UPDATED",
    CONVERSATION_DELETED = "CONVERSATION_DELETED",
    CONTROL_FLOW_DECISION = "CONTROL_FLOW_DECISION",
    EXECUTION_PAUSED = "EXECUTION_PAUSED",
    EXECUTION_RESUMED = "EXECUTION_RESUMED"
}
interface BaseEvent$1 {
    type: EventType$1;
    timestamp?: number;
    rawEvent?: any;
}
interface RunStartedEvent extends BaseEvent$1 {
    type: EventType$1.RUN_STARTED;
    threadId: string;
    runId: string;
    input?: string | Message[];
    options?: any;
}
interface RunFinishedEvent extends BaseEvent$1 {
    type: EventType$1.RUN_FINISHED;
    threadId: string;
    runId: string;
    result?: any;
    executionTime?: number;
}
interface RunErrorEvent extends BaseEvent$1 {
    type: EventType$1.RUN_ERROR;
    threadId: string;
    runId: string;
    code?: string;
    message: string;
    executionTime?: number;
}
interface StepStartedEvent extends BaseEvent$1 {
    type: EventType$1.STEP_STARTED;
    stepName: string;
}
interface StepFinishedEvent extends BaseEvent$1 {
    type: EventType$1.STEP_FINISHED;
    stepName: string;
}
interface TextMessageStartEvent extends BaseEvent$1 {
    type: EventType$1.TEXT_MESSAGE_START;
    messageId: string;
    role?: string;
}
interface TextMessageContentEvent extends BaseEvent$1 {
    type: EventType$1.TEXT_MESSAGE_CONTENT;
    messageId: string;
    delta: string;
}
interface TextMessageEndEvent extends BaseEvent$1 {
    type: EventType$1.TEXT_MESSAGE_END;
    messageId: string;
}
interface TextMessageChunkEvent extends BaseEvent$1 {
    type: EventType$1.TEXT_MESSAGE_CHUNK;
    messageId?: string;
    role?: string;
    delta?: string;
}
interface MessagesSnapshotEvent extends BaseEvent$1 {
    type: EventType$1.MESSAGES_SNAPSHOT;
    messages: Message[];
}
interface ToolCallStartEvent extends BaseEvent$1 {
    type: EventType$1.TOOL_CALL_START;
    toolCallId: string;
    toolCallName: string;
    parentMessageId?: string;
}
interface ToolCallArgsEvent extends BaseEvent$1 {
    type: EventType$1.TOOL_CALL_ARGS;
    toolCallId: string;
    delta: string;
}
interface ToolCallEndEvent extends BaseEvent$1 {
    type: EventType$1.TOOL_CALL_END;
    toolCallId: string;
}
interface ToolCallChunkEvent extends BaseEvent$1 {
    type: EventType$1.TOOL_CALL_CHUNK;
    toolCallId?: string;
    toolCallName?: string;
    parentMessageId?: string;
    delta?: string;
}
interface ToolCallResultEvent extends BaseEvent$1 {
    type: EventType$1.TOOL_CALL_RESULT;
    toolCallId: string;
    content: string;
    messageId: string;
    conversationId: string;
    runId: string;
}
interface ToolRegisteredEvent extends BaseEvent$1 {
    type: EventType$1.TOOL_REGISTERED;
    toolName: string;
}
interface ToolUnregisteredEvent extends BaseEvent$1 {
    type: EventType$1.TOOL_UNREGISTERED;
    toolName: string;
}
interface ToolValidationFailedEvent extends BaseEvent$1 {
    type: EventType$1.TOOL_VALIDATION_FAILED;
    toolName: string;
    input: any;
    error: string;
}
interface StateUpdateEvent extends BaseEvent$1 {
    type: EventType$1.STATE_UPDATE;
    state: any;
    conversationId: string;
    runId: string;
}
interface ApprovalRequiredEvent extends BaseEvent$1 {
    type: EventType$1.APPROVAL_REQUIRED;
    interruptId: string;
    toolName: string;
    params: any;
    conversationId: string;
    runId: string;
    message: string;
    context: any;
}
interface ApprovalReceivedEvent extends BaseEvent$1 {
    type: EventType$1.APPROVAL_RECEIVED;
    interruptId: string;
    action: 'approve' | 'reject' | 'modify';
    value?: any;
    reason?: string;
    conversationId: string;
    runId: string;
}
interface ErrorEvent extends BaseEvent$1 {
    type: EventType$1.RUN_ERROR;
    error: AgentError;
    context?: any;
    conversationId?: string;
    runId?: string;
}
interface StateSnapshotEvent extends BaseEvent$1 {
    type: EventType$1.STATE_SNAPSHOT;
    snapshot: any;
}
interface StateDeltaEvent extends BaseEvent$1 {
    type: EventType$1.STATE_DELTA;
    delta: any[];
}
interface ConversationCreatedEvent extends BaseEvent$1 {
    type: EventType$1.CONVERSATION_CREATED;
    conversation: any;
    conversationId: string;
}
interface ConversationUpdatedEvent extends BaseEvent$1 {
    type: EventType$1.CONVERSATION_UPDATED;
    conversation: any;
    conversationId: string;
    updates: any;
}
interface ConversationDeletedEvent extends BaseEvent$1 {
    type: EventType$1.CONVERSATION_DELETED;
    conversationId: string;
}
interface ControlFlowDecisionEvent extends BaseEvent$1 {
    type: EventType$1.CONTROL_FLOW_DECISION;
    decision: any;
    context: any;
    conversationId: string;
    runId: string;
}
interface ExecutionPausedEvent extends BaseEvent$1 {
    type: EventType$1.EXECUTION_PAUSED;
    reason: string;
    resumeData?: any;
    conversationId: string;
    runId: string;
}
interface ExecutionResumedEvent extends BaseEvent$1 {
    type: EventType$1.EXECUTION_RESUMED;
    resumeData?: any;
    conversationId: string;
    runId: string;
}
interface RawEvent extends BaseEvent$1 {
    type: EventType$1.RAW;
    event: any;
    source?: string;
}
interface CustomEvent extends BaseEvent$1 {
    type: EventType$1.CUSTOM;
    name: string;
    value?: any;
}
type AgentEvent = RunStartedEvent | RunFinishedEvent | RunErrorEvent | StepStartedEvent | StepFinishedEvent | TextMessageStartEvent | TextMessageContentEvent | TextMessageEndEvent | TextMessageChunkEvent | MessagesSnapshotEvent | ToolCallStartEvent | ToolCallArgsEvent | ToolCallEndEvent | ToolCallChunkEvent | ToolCallResultEvent | ToolRegisteredEvent | ToolUnregisteredEvent | ToolValidationFailedEvent | StateUpdateEvent | StateSnapshotEvent | StateDeltaEvent | ApprovalRequiredEvent | ApprovalReceivedEvent | ErrorEvent | ConversationCreatedEvent | ConversationUpdatedEvent | ConversationDeletedEvent | ControlFlowDecisionEvent | ExecutionPausedEvent | ExecutionResumedEvent | RawEvent | CustomEvent;
interface EventData$1 {
    [EventType$1.TEXT_MESSAGE_START]: TextMessageStartEvent;
    [EventType$1.TEXT_MESSAGE_CONTENT]: TextMessageContentEvent;
    [EventType$1.TEXT_MESSAGE_END]: TextMessageEndEvent;
    [EventType$1.TOOL_CALL_START]: ToolCallStartEvent;
    [EventType$1.TOOL_CALL_ARGS]: ToolCallArgsEvent;
    [EventType$1.TOOL_CALL_END]: ToolCallEndEvent;
    [EventType$1.STATE_SNAPSHOT]: StateSnapshotEvent;
    [EventType$1.STATE_DELTA]: StateDeltaEvent;
    [EventType$1.MESSAGES_SNAPSHOT]: MessagesSnapshotEvent;
    [EventType$1.RAW]: RawEvent;
    [EventType$1.CUSTOM]: CustomEvent;
    [EventType$1.RUN_STARTED]: RunStartedEvent;
    [EventType$1.RUN_FINISHED]: RunFinishedEvent;
    [EventType$1.RUN_ERROR]: RunErrorEvent;
    [EventType$1.STEP_STARTED]: StepStartedEvent;
    [EventType$1.STEP_FINISHED]: StepFinishedEvent;
    [EventType$1.TEXT_MESSAGE_CHUNK]: TextMessageChunkEvent;
    [EventType$1.TOOL_CALL_CHUNK]: ToolCallChunkEvent;
    [EventType$1.TOOL_CALL_RESULT]: ToolCallResultEvent;
    [EventType$1.TOOL_REGISTERED]: ToolRegisteredEvent;
    [EventType$1.TOOL_UNREGISTERED]: ToolUnregisteredEvent;
    [EventType$1.TOOL_VALIDATION_FAILED]: ToolValidationFailedEvent;
    [EventType$1.STATE_UPDATE]: StateUpdateEvent;
    [EventType$1.APPROVAL_REQUIRED]: ApprovalRequiredEvent;
    [EventType$1.APPROVAL_RECEIVED]: ApprovalReceivedEvent;
    [EventType$1.RUN_ERROR]: RunErrorEvent;
    [EventType$1.CONVERSATION_CREATED]: ConversationCreatedEvent;
    [EventType$1.CONVERSATION_UPDATED]: ConversationUpdatedEvent;
    [EventType$1.CONVERSATION_DELETED]: ConversationDeletedEvent;
    [EventType$1.CONTROL_FLOW_DECISION]: ControlFlowDecisionEvent;
    [EventType$1.EXECUTION_PAUSED]: ExecutionPausedEvent;
    [EventType$1.EXECUTION_RESUMED]: ExecutionResumedEvent;
}
type EventHandler$1<T extends EventType$1> = (data: EventData$1[T]) => void;
declare class EventSystem extends EventEmitter {
    constructor();
    emit<T extends EventType$1>(event: T, data: EventData$1[T]): boolean;
    on<T extends EventType$1>(event: T, handler: EventHandler$1<T>): this;
    once<T extends EventType$1>(event: T, handler: EventHandler$1<T>): this;
    off<T extends EventType$1>(event: T, handler: EventHandler$1<T>): this;
    removeAllListeners<T extends EventType$1>(event?: T): this;
    listenerCount<T extends EventType$1>(event: T): number;
    getEventNames(): EventType$1[];
    hasListeners<T extends EventType$1>(event: T): boolean;
    safeEmit<T extends EventType$1>(event: T, data: EventData$1[T]): boolean;
    waitFor<T extends EventType$1>(event: T, timeout?: number): Promise<EventData$1[T]>;
    waitForAny<T extends EventType$1>(events: T[], timeout?: number): Promise<{
        event: T;
        data: EventData$1[T];
    }>;
}

declare class Agent<TState extends StateConstraint = StateConstraint, TOutput extends OutputConstraint = string> {
    private config;
    private modelProvider;
    private eventSystem;
    private toolProxy;
    private toolExecutionHandler;
    private messageBuilder;
    private agentExecutor;
    private state;
    private isRunning;
    private isPaused;
    private memory;
    /**
     * Create a message with state metadata for memory storage
     */
    private createMessageWithState;
    /**
     * Get conversation messages from memory
     */
    private getConversationMessages;
    /**
     * Add messages to memory
     */
    private addMessages;
    /**
     * Extract current state from messages
     */
    private extractStateFromMessages;
    constructor(config: AgentConfig<TState, TOutput>);
    run(input: string | Message[], state?: TState, options?: RunOptions<TState>): Promise<AgentResult<TOutput>>;
    stream(input: string | Message[], state?: TState, options?: RunOptions<TState>): AsyncIterableIterator<AgentEvent>;
    addTool<T extends BaseTool<any, TState>>(tool: T): void;
    removeTool(toolName: string): boolean;
    getTool(toolName: string): BaseTool<any, TState> | undefined;
    getTools(): BaseTool<any, TState>[];
    getToolCount(): number;
    hasTool(toolName: string): boolean;
    getToolNames(): string[];
    getToolsRequiringApproval(): BaseTool<any, TState>[];
    executeTool(toolName: string, input: unknown, context?: Partial<ToolExecutionContext>): Promise<unknown>;
    validateToolInput(toolName: string, input: unknown): boolean;
    getToolMetadata(toolName: string): {
        name: string;
        description?: string;
        hasSchema: boolean;
        requiresApproval: boolean;
    } | null;
    createConversation(userId?: string, config?: any): Promise<any>;
    getConversation(conversationId: string): Promise<any>;
    deleteConversation(conversationId: string): Promise<void>;
    getState(): AgentState<TState>;
    setState(state: Partial<AgentState<TState>>): void;
    start(): Promise<void>;
    pause(): Promise<void>;
    resume(resumeData?: any): Promise<void>;
    stop(): Promise<void>;
    on<T extends EventType$1>(event: T, handler: (data: any) => void): void;
    off<T extends EventType$1>(event: T, handler: (data: any) => void): void;
    private initializeState;
    private initializeModelProvider;
    private initializeTools;
    private initializeEventListeners;
    private createRunContext;
    private emitEvent;
    private executeAgentCore;
    private createAgentError;
    get name(): string;
    get description(): string | undefined;
    get isActive(): boolean;
    get isPausedState(): boolean;
    toAGUIAgent(): any;
    destroy(): void;
}

/**
 * Type validation utilities for enhanced type safety
 */

declare function isStateConstraint(value: unknown): value is StateConstraint;
declare function isOutputConstraint(value: unknown): value is OutputConstraint;
declare const StateConstraintSchema: z.ZodRecord<z.ZodString, z.ZodUnknown>;
declare const OutputConstraintSchema: z.ZodUnion<readonly [z.ZodString, z.ZodRecord<z.ZodString, z.ZodUnknown>, z.ZodArray<z.ZodUnknown>]>;
declare function validateState<T extends StateConstraint>(value: unknown, schema?: z.ZodSchema<T>): T;
declare function validateOutput<T extends OutputConstraint>(value: unknown, schema?: z.ZodSchema<T>): T;
declare class TypeChecker {
    private static instance;
    static getInstance(): TypeChecker;
    checkType<T>(value: unknown, typeName: string): value is T;
    validateObjectStructure(obj: unknown, requiredKeys: string[], optionalKeys?: string[]): obj is Record<string, unknown>;
    validateDeepType(value: unknown, expectedType: string): boolean;
}
declare function createTypeSafeState<T extends StateConstraint>(initialState: T): T;
declare function createTypeSafeOutput<T extends OutputConstraint>(output: T): T;
declare function validateTypes<T extends StateConstraint, U extends OutputConstraint>(stateSchema?: z.ZodSchema<T>, outputSchema?: z.ZodSchema<U>): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor;
declare const typeChecker: TypeChecker;

/**
 * Optimized Event System with batching and async processing
 */

declare enum EventType {
    RUN_STARTED = "run_started",
    RUN_FINISHED = "run_finished",
    RUN_FAILED = "run_failed",
    TEXT_MESSAGE_START = "text_message_start",
    TEXT_MESSAGE_CONTENT = "text_message_content",
    TEXT_MESSAGE_END = "text_message_end",
    MESSAGES_SNAPSHOT = "messages_snapshot",
    TOOL_CALL_START = "tool_call_start",
    TOOL_CALL_ARGS = "tool_call_args",
    TOOL_CALL_END = "tool_call_end",
    TOOL_CALL_RESULT = "tool_call_result",
    STATE_UPDATE = "state_update",
    APPROVAL_REQUIRED = "approval_required",
    APPROVAL_RECEIVED = "approval_received",
    ERROR = "error",
    CONVERSATION_CREATED = "conversation_created",
    CONVERSATION_UPDATED = "conversation_updated",
    CONVERSATION_DELETED = "conversation_deleted",
    CONTROL_FLOW_DECISION = "control_flow_decision",
    EXECUTION_PAUSED = "execution_paused",
    EXECUTION_RESUMED = "execution_resumed"
}
interface BaseEvent {
    type: EventType;
    conversationId?: string;
    runId?: string;
    timestamp?: number;
}
type EventData = {
    [EventType.RUN_STARTED]: BaseEvent & {
        conversationId: string;
        runId: string;
    };
    [EventType.RUN_FINISHED]: BaseEvent & {
        conversationId: string;
        runId: string;
        executionTime: number;
    };
    [EventType.RUN_FAILED]: BaseEvent & {
        conversationId: string;
        runId: string;
        error: AgentError;
    };
    [EventType.TEXT_MESSAGE_START]: BaseEvent & {
        messageId: string;
        content: string;
    };
    [EventType.TEXT_MESSAGE_CONTENT]: BaseEvent & {
        messageId: string;
        content: string;
        delta: string;
    };
    [EventType.TEXT_MESSAGE_END]: BaseEvent & {
        messageId: string;
        content: string;
    };
    [EventType.MESSAGES_SNAPSHOT]: BaseEvent & {
        messages: Message[];
    };
    [EventType.TOOL_CALL_START]: BaseEvent & {
        toolCallId: string;
        toolName: string;
    };
    [EventType.TOOL_CALL_ARGS]: BaseEvent & {
        toolCallId: string;
        args: any;
    };
    [EventType.TOOL_CALL_END]: BaseEvent & {
        toolCallId: string;
        result: any;
    };
    [EventType.TOOL_CALL_RESULT]: BaseEvent & {
        toolCallId: string;
        result: any;
    };
    [EventType.STATE_UPDATE]: BaseEvent & {
        state: any;
    };
    [EventType.APPROVAL_REQUIRED]: BaseEvent & {
        toolName: string;
        args: any;
    };
    [EventType.APPROVAL_RECEIVED]: BaseEvent & {
        toolName: string;
        approved: boolean;
    };
    [EventType.ERROR]: BaseEvent & {
        error: AgentError;
    };
    [EventType.CONVERSATION_CREATED]: BaseEvent & {
        conversationId: string;
    };
    [EventType.CONVERSATION_UPDATED]: BaseEvent & {
        conversationId: string;
        messages: Message[];
    };
    [EventType.CONVERSATION_DELETED]: BaseEvent & {
        conversationId: string;
    };
    [EventType.CONTROL_FLOW_DECISION]: BaseEvent & {
        decision: string;
        context: any;
    };
    [EventType.EXECUTION_PAUSED]: BaseEvent & {
        reason: string;
    };
    [EventType.EXECUTION_RESUMED]: BaseEvent & {
        reason: string;
    };
};
type EventHandler<T extends EventType> = (data: EventData[T]) => void | Promise<void>;
interface EventProcessingOptions {
    batchSize: number;
    batchTimeout: number;
    maxConcurrentHandlers: number;
    enableBatching: boolean;
    enableAsyncProcessing: boolean;
}
declare class OptimizedEventSystem extends EventEmitter {
    private eventQueue;
    private batchTimer?;
    private processingHandlers;
    private options;
    private isProcessing;
    constructor(options?: Partial<EventProcessingOptions>);
    emit<T extends EventType>(event: T, data: EventData[T]): boolean;
    private addToBatch;
    private processBatch;
    private processBatchAsync;
    private processBatchSync;
    private processEventImmediately;
    private getEventPriority;
    on<T extends EventType>(event: T, handler: EventHandler<T>): this;
    once<T extends EventType>(event: T, handler: EventHandler<T>): this;
    getPerformanceMetrics(): {
        queueSize: number;
        processingHandlers: number;
        isProcessing: boolean;
    };
    flush(): Promise<void>;
    destroy(): void;
}
declare function createOptimizedEventSystem(options?: Partial<EventProcessingOptions>): OptimizedEventSystem;
declare const optimizedEventSystem: OptimizedEventSystem;

interface ToolCall {
    id: string;
    function: {
        name: string;
        arguments: string;
    };
}
interface ChatCompletionParams {
    model: string;
    messages: Message[];
    temperature?: number;
    max_tokens?: number;
    top_p?: number;
    frequency_penalty?: number;
    presence_penalty?: number;
    tools?: ToolDefinition[];
    tool_choice?: 'auto' | 'none' | {
        type: 'function';
        function: {
            name: string;
        };
    };
    stream?: boolean;
    stop?: string[];
    /**
     * AbortSignal for cancelling the LLM request.
     * When aborted, the underlying HTTP request will be cancelled.
     */
    signal?: AbortSignal;
}
interface ToolDefinition {
    type: 'function';
    function: {
        name: string;
        description?: string;
        parameters: any;
    };
}
interface ChatCompletion {
    id: string;
    object: 'chat.completion';
    created: number;
    model: string;
    choices: Array<{
        index: number;
        message: {
            role: 'assistant';
            content: string | null;
            tool_calls?: ToolCall[];
        };
        finish_reason: 'stop' | 'length' | 'content_filter' | 'tool_calls';
    }>;
    usage: {
        prompt_tokens: number;
        completion_tokens: number;
        total_tokens: number;
    };
}
interface ChatCompletionChunk {
    id: string;
    object: 'chat.completion.chunk';
    created: number;
    model: string;
    choices: Array<{
        index: number;
        delta: {
            role?: 'assistant';
            content?: string;
            tool_calls?: ToolCall[];
        };
        finish_reason?: 'stop' | 'length' | 'content_filter' | 'tool_calls';
    }>;
}
interface ModelProvider {
    chat: {
        completions: {
            create: (params: ChatCompletionParams) => Promise<ChatCompletion>;
            stream: (params: ChatCompletionParams) => AsyncIterable<ChatCompletionChunk>;
        };
    };
    supportsTools(): boolean;
    supportsStreaming(): boolean;
    formatTools(tools: any[]): ToolDefinition[];
    parseToolCalls(response: ChatCompletion): ToolCall[];
    getProviderName(): string;
    getDefaultModel(): string;
    validateConfig(config: any): boolean;
}
interface ModelProviderConfig {
    apiKey: string;
    baseURL?: string;
    defaultModel?: string;
    timeout?: number;
    maxRetries?: number;
    retryDelay?: number;
    proxy?: string;
    rejectUnauthorized?: boolean;
}
interface ModelProviderError extends Error {
    type: 'authentication' | 'rate_limit' | 'quota_exceeded' | 'invalid_request' | 'server_error' | 'timeout' | 'aborted' | 'unknown';
    status?: number;
    code?: string;
    details?: any;
}
interface ModelProviderFactory {
    createOpenAI(config: ModelProviderConfig): ModelProvider;
    createAnthropic(config: ModelProviderConfig): ModelProvider;
    createCustom(config: ModelProviderConfig & {
        providerType: string;
    }): ModelProvider;
}
declare abstract class BaseModelProvider implements ModelProvider {
    protected config: ModelProviderConfig;
    protected defaultModel: string;
    constructor(config: ModelProviderConfig);
    abstract get chat(): {
        completions: {
            create: (params: ChatCompletionParams) => Promise<ChatCompletion>;
            stream: (params: ChatCompletionParams) => AsyncIterable<ChatCompletionChunk>;
        };
    };
    abstract getProviderName(): string;
    abstract getDefaultModel(): string;
    abstract formatTools(tools: any[]): ToolDefinition[];
    abstract parseToolCalls(response: ChatCompletion): ToolCall[];
    supportsTools(): boolean;
    supportsStreaming(): boolean;
    validateConfig(config: any): boolean;
    protected createError(message: string, type: ModelProviderError['type'], details?: any): ModelProviderError;
    protected withRetry<T>(operation: () => Promise<T>, maxRetries?: number, delay?: number): Promise<T>;
    protected isNonRetryableError(error: Error): boolean;
    protected formatMessages(messages: Message[]): any[];
    protected parseMessages(response: any): Message[];
}
declare class ModelProviderRegistry {
    private providers;
    private defaultProvider?;
    register(name: string, provider: ModelProvider): this;
    unregister(name: string): boolean;
    get(name: string): ModelProvider | undefined;
    getAll(): Map<string, ModelProvider>;
    setDefault(name: string): this;
    getDefault(): ModelProvider | undefined;
    listNames(): string[];
    has(name: string): boolean;
    clear(): void;
}
declare const modelProviderRegistry: ModelProviderRegistry;

interface OpenAIFetchOptions {
    fetch?: typeof fetch;
    dispatcher?: any;
    [key: string]: any;
}
interface OpenAIProviderConfig extends ModelProviderConfig {
    organization?: string;
    project?: string;
    fetchOptions?: OpenAIFetchOptions;
}
declare class OpenAIProvider extends BaseModelProvider implements ModelProvider {
    private client;
    protected config: OpenAIProviderConfig;
    constructor(config: OpenAIProviderConfig);
    get chat(): {
        completions: {
            create: (params: ChatCompletionParams) => Promise<ChatCompletion>;
            stream: (params: ChatCompletionParams) => AsyncIterable<ChatCompletionChunk>;
        };
    };
    getProviderName(): string;
    getDefaultModel(): string;
    validateConfig(config: any): boolean;
    formatTools(tools: any[]): ToolDefinition[];
    parseToolCalls(response: ChatCompletion): ToolCall[];
    createCompletion(params: ChatCompletionParams): Promise<ChatCompletion>;
    createStream(params: ChatCompletionParams): AsyncIterable<ChatCompletionChunk>;
    private convertToOpenAIParams;
    private convertFromOpenAIResponse;
    private convertFromOpenAIChunk;
    private handleOpenAIError;
    getAvailableModels(): Promise<string[]>;
    isModelAvailable(model: string): Promise<boolean>;
    getModelInfo(model: string): Promise<any>;
    estimateTokens(params: ChatCompletionParams): Promise<number>;
    getUsage(startDate?: Date, endDate?: Date): Promise<any>;
}
declare function createOpenAIProvider(config: OpenAIProviderConfig): OpenAIProvider;
declare function createDefaultOpenAIProvider(apiKey: string, options?: Partial<OpenAIProviderConfig>): OpenAIProvider;

interface AnthropicProviderConfig extends ModelProviderConfig {
    anthropicVersion?: string;
}
declare class AnthropicProvider extends BaseModelProvider implements ModelProvider {
    private client;
    protected config: AnthropicProviderConfig;
    constructor(config: AnthropicProviderConfig);
    get chat(): {
        completions: {
            create: (params: ChatCompletionParams) => Promise<ChatCompletion>;
            stream: (params: ChatCompletionParams) => AsyncIterable<ChatCompletionChunk>;
        };
    };
    getProviderName(): string;
    getDefaultModel(): string;
    validateConfig(config: any): boolean;
    formatTools(tools: any[]): ToolDefinition[];
    parseToolCalls(response: ChatCompletion): ToolCall[];
    createCompletion(params: ChatCompletionParams): Promise<ChatCompletion>;
    createStream(params: ChatCompletionParams): AsyncIterable<ChatCompletionChunk>;
    private convertToAnthropicParams;
    private convertFromAnthropicResponse;
    private convertFromAnthropicChunk;
    private mapFinishReason;
    private handleAnthropicError;
    getAvailableModels(): Promise<string[]>;
    isModelAvailable(model: string): Promise<boolean>;
    getModelInfo(model: string): Promise<any>;
    estimateTokens(params: ChatCompletionParams): Promise<number>;
    getUsage(startDate?: Date, endDate?: Date): Promise<any>;
}
declare function createAnthropicProvider(config: AnthropicProviderConfig): AnthropicProvider;
declare function createDefaultAnthropicProvider(apiKey: string, options?: Partial<AnthropicProviderConfig>): AnthropicProvider;

declare class ProviderFactory implements ModelProviderFactory {
    private registry;
    constructor(registry?: ModelProviderRegistry);
    createOpenAI(config: ModelProviderConfig): ModelProvider;
    createAnthropic(config: ModelProviderConfig): ModelProvider;
    createCustom(config: ModelProviderConfig & {
        providerType: string;
    }): ModelProvider;
    createFromEnv(providerType?: string): ModelProvider;
    private getApiKeyFromEnv;
    private getBaseURLFromEnv;
    private getDefaultModelFromEnv;
    private getTimeoutFromEnv;
    private getMaxRetriesFromEnv;
    private getRetryDelayFromEnv;
    createWithValidation(config: ModelProviderConfig & {
        providerType: string;
    }): ModelProvider;
    private validateConfig;
    getRegistry(): ModelProviderRegistry;
}
declare function createOpenAIProviderFromEnv(): ModelProvider;
declare function createAnthropicProviderFromEnv(): ModelProvider;
declare function createProviderFromConfig(config: {
    type: 'openai' | 'anthropic';
    apiKey: string;
    baseURL?: string;
    defaultModel?: string;
    timeout?: number;
    maxRetries?: number;
    retryDelay?: number;
}): ModelProvider;
declare function createProviderFromApiKey(apiKey: string, options?: Partial<ModelProviderConfig>): ModelProvider;
declare const ProviderPresets: {
    openai: {
        gpt4: (apiKey: string) => ModelProvider;
        gpt4Turbo: (apiKey: string) => ModelProvider;
        gpt35Turbo: (apiKey: string) => ModelProvider;
    };
    anthropic: {
        claude3Opus: (apiKey: string) => ModelProvider;
        claude3Sonnet: (apiKey: string) => ModelProvider;
        claude3Haiku: (apiKey: string) => ModelProvider;
    };
};
declare const providerFactory: ProviderFactory;

/**
 * Configuration validation using Zod schemas
 */

declare const ModelSettingsSchema: z.ZodObject<{
    temperature: z.ZodOptional<z.ZodNumber>;
    maxTokens: z.ZodOptional<z.ZodNumber>;
    topP: z.ZodOptional<z.ZodNumber>;
    frequencyPenalty: z.ZodOptional<z.ZodNumber>;
    presencePenalty: z.ZodOptional<z.ZodNumber>;
    stop: z.ZodOptional<z.ZodArray<z.ZodString>>;
}, z.core.$strip>;
declare const HumanInTheLoopConfigSchema: z.ZodObject<{
    enabled: z.ZodBoolean;
    requireApproval: z.ZodOptional<z.ZodArray<z.ZodString>>;
    highRiskTools: z.ZodOptional<z.ZodArray<z.ZodString>>;
    timeout: z.ZodOptional<z.ZodNumber>;
    defaultAction: z.ZodOptional<z.ZodEnum<{
        approve: "approve";
        reject: "reject";
        pause: "pause";
    }>>;
}, z.core.$strip>;
declare const ControlFlowConfigSchema: z.ZodObject<{
    maxSteps: z.ZodOptional<z.ZodNumber>;
    errorRetryLimit: z.ZodOptional<z.ZodNumber>;
    pauseOnHumanInput: z.ZodOptional<z.ZodBoolean>;
    customHandler: z.ZodOptional<z.ZodObject<{
        handleNextStep: z.ZodCustom<CallableFunction, CallableFunction>;
        handleToolCall: z.ZodCustom<CallableFunction, CallableFunction>;
        handleError: z.ZodCustom<CallableFunction, CallableFunction>;
    }, z.core.$strip>>;
}, z.core.$strip>;
declare const ToolDefinitionSchema: z.ZodObject<{
    name: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
    schema: z.ZodOptional<z.ZodAny>;
    invoke: z.ZodOptional<z.ZodCustom<CallableFunction, CallableFunction>>;
    requiresApproval: z.ZodOptional<z.ZodBoolean>;
}, z.core.$strip>;
declare const OutputTypeSchema: z.ZodUnion<readonly [z.ZodLiteral<"string">, z.ZodLiteral<"structured">, z.ZodObject<{
    schema: z.ZodAny;
}, z.core.$strip>]>;
declare const AgentConfigSchema: z.ZodObject<{
    name: z.ZodString;
    description: z.ZodOptional<z.ZodString>;
    model: z.ZodUnion<readonly [z.ZodString, z.ZodAny]>;
    instructions: z.ZodOptional<z.ZodUnion<readonly [z.ZodString, z.ZodCustom<CallableFunction, CallableFunction>]>>;
    stateType: z.ZodOptional<z.ZodAny>;
    outputType: z.ZodOptional<z.ZodUnion<readonly [z.ZodLiteral<"string">, z.ZodLiteral<"structured">, z.ZodObject<{
        schema: z.ZodAny;
    }, z.core.$strip>]>>;
    modelSettings: z.ZodOptional<z.ZodObject<{
        temperature: z.ZodOptional<z.ZodNumber>;
        maxTokens: z.ZodOptional<z.ZodNumber>;
        topP: z.ZodOptional<z.ZodNumber>;
        frequencyPenalty: z.ZodOptional<z.ZodNumber>;
        presencePenalty: z.ZodOptional<z.ZodNumber>;
        stop: z.ZodOptional<z.ZodArray<z.ZodString>>;
    }, z.core.$strip>>;
    tools: z.ZodOptional<z.ZodArray<z.ZodObject<{
        name: z.ZodString;
        description: z.ZodOptional<z.ZodString>;
        schema: z.ZodOptional<z.ZodAny>;
        invoke: z.ZodOptional<z.ZodCustom<CallableFunction, CallableFunction>>;
        requiresApproval: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>>;
    memory: z.ZodOptional<z.ZodAny>;
    humanInTheLoop: z.ZodOptional<z.ZodObject<{
        enabled: z.ZodBoolean;
        requireApproval: z.ZodOptional<z.ZodArray<z.ZodString>>;
        highRiskTools: z.ZodOptional<z.ZodArray<z.ZodString>>;
        timeout: z.ZodOptional<z.ZodNumber>;
        defaultAction: z.ZodOptional<z.ZodEnum<{
            approve: "approve";
            reject: "reject";
            pause: "pause";
        }>>;
    }, z.core.$strip>>;
    controlFlow: z.ZodOptional<z.ZodObject<{
        maxSteps: z.ZodOptional<z.ZodNumber>;
        errorRetryLimit: z.ZodOptional<z.ZodNumber>;
        pauseOnHumanInput: z.ZodOptional<z.ZodBoolean>;
        customHandler: z.ZodOptional<z.ZodObject<{
            handleNextStep: z.ZodCustom<CallableFunction, CallableFunction>;
            handleToolCall: z.ZodCustom<CallableFunction, CallableFunction>;
            handleError: z.ZodCustom<CallableFunction, CallableFunction>;
        }, z.core.$strip>>;
    }, z.core.$strip>>;
}, z.core.$strip>;
declare const RunOptionsSchema: z.ZodObject<{
    state: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnknown>>;
    conversationId: z.ZodOptional<z.ZodString>;
    runId: z.ZodOptional<z.ZodString>;
    userId: z.ZodOptional<z.ZodString>;
    model: z.ZodOptional<z.ZodString>;
    temperature: z.ZodOptional<z.ZodNumber>;
    maxTokens: z.ZodOptional<z.ZodNumber>;
    stream: z.ZodOptional<z.ZodBoolean>;
    tools: z.ZodOptional<z.ZodArray<z.ZodObject<{
        name: z.ZodString;
        description: z.ZodOptional<z.ZodString>;
        schema: z.ZodOptional<z.ZodAny>;
        invoke: z.ZodOptional<z.ZodCustom<CallableFunction, CallableFunction>>;
        requiresApproval: z.ZodOptional<z.ZodBoolean>;
    }, z.core.$strip>>>;
    humanInTheLoop: z.ZodOptional<z.ZodObject<{
        enabled: z.ZodBoolean;
        requireApproval: z.ZodOptional<z.ZodArray<z.ZodString>>;
        highRiskTools: z.ZodOptional<z.ZodArray<z.ZodString>>;
        timeout: z.ZodOptional<z.ZodNumber>;
        defaultAction: z.ZodOptional<z.ZodEnum<{
            approve: "approve";
            reject: "reject";
            pause: "pause";
        }>>;
    }, z.core.$strip>>;
    controlFlow: z.ZodOptional<z.ZodObject<{
        maxSteps: z.ZodOptional<z.ZodNumber>;
        errorRetryLimit: z.ZodOptional<z.ZodNumber>;
        pauseOnHumanInput: z.ZodOptional<z.ZodBoolean>;
        customHandler: z.ZodOptional<z.ZodObject<{
            handleNextStep: z.ZodCustom<CallableFunction, CallableFunction>;
            handleToolCall: z.ZodCustom<CallableFunction, CallableFunction>;
            handleError: z.ZodCustom<CallableFunction, CallableFunction>;
        }, z.core.$strip>>;
    }, z.core.$strip>>;
}, z.core.$strip>;
declare class ConfigValidator {
    private static instance;
    static getInstance(): ConfigValidator;
    validateAgentConfig<T extends Record<string, unknown>>(config: unknown, context?: Record<string, unknown>): T;
    validateRunOptions<T extends Record<string, unknown>>(options: unknown, context?: Record<string, unknown>): T;
    validateModelSettings<T extends Record<string, unknown>>(settings: unknown): T;
    validateToolDefinitions<T extends Record<string, unknown>[]>(tools: unknown): T;
    validateHumanInTheLoopConfig<T extends Record<string, unknown>>(config: unknown): T;
    validateControlFlowConfig<T extends Record<string, unknown>>(config: unknown): T;
    checkRequiredFields(config: Record<string, unknown>, requiredFields: string[]): void;
    private formatZodErrors;
    validateWithCustomSchema<T>(data: unknown, schema: z.ZodSchema<T>, errorMessage: string): T;
}
declare function validateConfig(schema: z.ZodSchema): (target: any, propertyKey: string, descriptor: PropertyDescriptor) => PropertyDescriptor;
declare const configValidator: ConfigValidator;
declare function validateAgentName(name: unknown): string;
declare function validateModelProvider(provider: unknown): string | object;
declare function validateInstructions(instructions: unknown): string | Function;

/**
 * Tool Proxy System for managing and executing tools
 * Provides a unified interface for tool management and execution
 */
declare class ToolProxy<TState extends StateConstraint = StateConstraint> {
    private tools;
    private eventSystem;
    private executionContext;
    constructor(eventSystem: EventSystem, context?: Partial<ToolExecutionContext>);
    /**
     * Register a tool with the proxy
     */
    registerTool(tool: BaseTool<any, TState>): void;
    /**
     * Remove a tool from the proxy
     */
    unregisterTool(toolName: string): boolean;
    /**
     * Get a tool by name
     */
    getTool(toolName: string): BaseTool<any, TState> | undefined;
    /**
     * Get all registered tools
     */
    getAllTools(): BaseTool<any, TState>[];
    /**
     * Get the number of registered tools
     */
    getToolCount(): number;
    /**
     * Get tool names
     */
    getToolNames(): string[];
    /**
     * Check if a tool is registered
     */
    hasTool(toolName: string): boolean;
    /**
     * Execute a tool with the given input
     */
    executeTool(toolName: string, input: unknown, context?: Partial<ToolExecutionContext>, state?: TState): Promise<unknown>;
    /**
     * Execute multiple tools in parallel
     */
    executeToolsParallel(executions: Array<{
        toolName: string;
        input: unknown;
        context?: Partial<ToolExecutionContext>;
    }>, state?: TState): Promise<Array<{
        toolName: string;
        result: unknown;
        error?: Error;
    }>>;
    /**
     * Execute multiple tools sequentially
     */
    executeToolsSequential(executions: Array<{
        toolName: string;
        input: unknown;
        context?: Partial<ToolExecutionContext>;
    }>, state?: TState): Promise<Array<{
        toolName: string;
        result: unknown;
        error?: Error;
    }>>;
    /**
     * Validate tool input against schema if available
     */
    validateToolInput(toolName: string, input: unknown): boolean;
    /**
     * Get tool metadata
     */
    getToolMetadata(toolName: string): {
        name: string;
        description?: string;
        hasSchema: boolean;
        requiresApproval: boolean;
    } | null;
    /**
     * Update execution context
     */
    updateExecutionContext(context: Partial<ToolExecutionContext>): void;
    /**
     * Get current execution context
     */
    getExecutionContext(): ToolExecutionContext;
    /**
     * Clear all tools
     */
    clearTools(): void;
    /**
     * Get tools that require approval
     */
    getToolsRequiringApproval(): BaseTool<any, TState>[];
    /**
     * Validate tool definition
     */
    private validateToolDefinition;
}

/**
 * Create a tool with Zod schema validation
 */
declare function createTypedTool<TInput = any, TState extends StateConstraint = StateConstraint>(name: string, description: string, schema: z.ZodObject<any>, handler: (input: TInput, context: ToolExecutionContext & {
    state?: TState;
}) => Promise<unknown>, options?: {
    requiresApproval?: boolean;
}): _cloudbase_agent_tools.DynamicTool<any, Record<string, unknown>, any>;
/**
 * Create a tool with input/output logging
 */
declare function createLoggedTool<TState extends StateConstraint = StateConstraint>(name: string, description: string, handler: (input: any, context: ToolExecutionContext & {
    state?: TState;
}) => Promise<any>, options?: {
    schema?: z.ZodObject<any>;
    requiresApproval?: boolean;
    logLevel?: "debug" | "info" | "warn" | "error";
}): BaseTool<any, TState>;
/**
 * Create a tool with retry logic
 */
declare function createRetryTool<TState extends StateConstraint = StateConstraint>(name: string, description: string, handler: (input: any, context: ToolExecutionContext & {
    state?: TState;
}) => Promise<any>, options?: {
    schema?: z.ZodObject<any>;
    requiresApproval?: boolean;
    maxRetries?: number;
    retryDelay?: number;
    retryCondition?: (error: Error) => boolean;
}): BaseTool<any, TState>;
/**
 * Create a tool with timeout
 */
declare function createTimeoutTool<TState extends StateConstraint = StateConstraint>(name: string, description: string, handler: (input: any, context: ToolExecutionContext & {
    state?: TState;
}) => Promise<any>, options?: {
    schema?: z.ZodObject<any>;
    requiresApproval?: boolean;
    timeout?: number;
}): BaseTool<any, TState>;
/**
 * Create a tool that combines multiple tools
 */
declare function createCompositeTool<TState extends StateConstraint = StateConstraint>(name: string, description: string, tools: BaseTool<any, TState>[], options?: {
    requiresApproval?: boolean;
    executionMode?: "sequential" | "parallel";
}): BaseTool<any, TState>;

/**
 * Conversation management utilities for handling conversations and state in message metadata
 */
declare class ConversationManager<TState extends StateConstraint = StateConstraint> {
    conversations: Map<string, Message[]>;
    private currentState;
    /**
     * Create a message with state metadata
     */
    createMessageWithState(role: Message['role'], content: string, conversationId: string, options?: {
        runId?: string;
        userId?: string;
        toolCalls?: any[];
        toolCallId?: string;
    }): Message;
    /**
     * Extract current state from messages
     */
    extractStateFromMessages(messages: Message[]): TState;
    /**
     * Get conversation messages
     */
    getConversationMessages(conversationId: string): Message[];
    /**
     * Add messages to conversation
     */
    addMessages(conversationId: string, messages: Message[]): void;
    /**
     * Get current state for conversation
     */
    getCurrentState(conversationId: string): TState;
    /**
     * Update state for conversation
     */
    updateState(conversationId: string, stateChanges: Partial<TState>): void;
    /**
     * Clear conversation data
     */
    clearConversation(conversationId: string): void;
    /**
     * Deep clone an object to prevent reference sharing
     */
    private deepClone;
}

/**
 * AGKitAgent - AG-UI protocol implementation for AG-Kit Agent
 */

declare class AGKitAgent extends AbstractAgent {
    private agent;
    constructor(agent: Agent, config?: Partial<AgentConfig$1>);
    run(input: RunAgentInput): Observable<BaseEvent$2>;
    private _run;
    /**
     * Bridge a single AG-Kit event to AG-UI event format
     * This is called per-event for a specific run (no global listeners)
     */
    private bridgeEvent;
    destroy(): void;
}

/**
 * Converter utility to transform AG-Kit Agent to AG-UI AbstractAgent
 */

/**
 * Convert AG-Kit Agent to AbstractAgent for AG-UI server integration
 */
declare function toAGUIAgent(agent: Agent | AbstractAgent, config?: Partial<AgentConfig$1>): AbstractAgent;

export { AGKitAgent, AGKitError, Agent, type AgentConfig, AgentConfigSchema, type AgentError, type AgentEvent, type AgentResult, type AgentState, AnthropicProvider, type AnthropicProviderConfig, type ApprovalReceivedEvent, type ApprovalRequiredEvent, type BaseEvent$1 as BaseEvent, BaseLongTermMemory, BaseMemory, BaseModelProvider, type BranchInfo, type ChatCompletion, type ChatCompletionChunk, type ChatCompletionParams, CloudBaseMemory, type CompactionMetadata, ConfigValidator, ConfigurationError, type ContextThresholds, type ControlFlowConfig, ControlFlowConfigSchema, type ControlFlowDecision, type ControlFlowDecisionEvent, ControlFlowError, type ControlFlowHandler, type ConversationConfig, type ConversationCreatedEvent, type ConversationDeletedEvent, ConversationManager, type ConversationUpdatedEvent, type CustomEvent, ErrorCategory, ErrorContextBuilder, type ErrorEvent, type ErrorHandler, type ErrorHandlingDecision, type ErrorRecoveryStrategy, type EventData$1 as EventData, type EventHandler$1 as EventHandler, EventSystem, EventType$1 as EventType, ExecutionError, type ExecutionPausedEvent, type ExecutionResumedEvent, FallbackModelStrategy, HumanApprovalRequiredError, type HumanInTheLoopConfig, HumanInTheLoopConfigSchema, type IMemoryClientOptions, type IMemoryEvent, type ITokenizer, InMemoryMemory, type InstructionProvider, InvalidModelProviderError, InvalidModelResponseError, type ListOptions, LoggingErrorHandler, Mem0LongTermMemory, type Mem0LongTermMemoryConfig, MemoryClient, type MemoryEntity, MemoryError, type MemoryEventEntity, MemoryLimitError, type MemoryProvider, type MemoryQuery, type Message, type MessageMetadata, type MessagesSnapshotEvent, MissingRequiredConfigError, ModelError, type ModelProvider$1 as ModelProvider, type ModelProviderConfig, ModelProviderError$1 as ModelProviderError, ModelProviderRegistry, type ModelSettings, ModelSettingsSchema, MongoDBMemory, type MongoDBMemoryConfig, type MySQLConnectionConfig, MySQLMemory, type MySQLMemoryConfig, NetworkError, OpenAIProvider, type OpenAIProviderConfig, OptimizedEventSystem, Order, type OutputConstraint, OutputConstraintSchema, type OutputType, OutputTypeSchema, ParamError, ProviderFactory, ProviderPresets, type QueryOptions$1 as QueryOptions, RateLimitError, type RawEvent, RetryErrorHandler, type RunContext, type RunErrorEvent, type RunFinishedEvent, type RunOptions, RunOptionsSchema, type RunStartedEvent, RuntimeError, SchemaValidationError, type SearchOptions, type StateConstraint, StateConstraintSchema, type StateDeltaEvent, StateError, type StateSnapshotEvent, type StateUpdateEvent, type StepFinishedEvent, type StepStartedEvent, type StructuredSummary, TDAIException, TDAILongTermMemory, type TDAILongTermMemoryConfig, TDAIMemory, type Message$1 as TDAIMessage, type TextMessageChunkEvent, type TextMessageContentEvent, type TextMessageEndEvent, type TextMessageStartEvent, TiktokenTokenizer, TimeoutError, TokenLimitError, TokenTrimmer, type TokenUsage, type ToolCall$1 as ToolCall, type ToolCallArgsEvent, type ToolCallChunkEvent, type ToolCallDecision, type ToolCallEndEvent, type ToolCallResultEvent, type ToolCallStartEvent, ToolDefinitionSchema, ToolError, ToolExecutionError, ToolNotFoundError, ToolProxy, type ToolRegisteredEvent, type ToolUnregisteredEvent, ToolValidationError, type ToolValidationFailedEvent, TypeChecker, TypeORMAdapter, TypeORMMemory, type TypeORMMemoryConfig, TypeORMQueryBuilder, TypeORMUpdateBuilder, ValidationError, type WhereClause, configValidator, createAnthropicProvider, createAnthropicProviderFromEnv, createCompositeTool, createDefaultAnthropicProvider, createDefaultOpenAIProvider, createErrorContext, createLoggedTool, createOpenAIProvider, createOpenAIProviderFromEnv, createOptimizedEventSystem, createProviderFromApiKey, createProviderFromConfig, createRetryTool, createTimeoutTool, createTypeSafeOutput, createTypeSafeState, createTypedTool, isConfigurationError, isOutputConstraint, isRetryableError, isStateConstraint, isToolError, modelProviderRegistry, optimizedEventSystem, providerFactory, toAGUIAgent, typeChecker, validateAgentName, validateConfig, validateInstructions, validateModelProvider, validateOutput, validateState, validateTypes };
