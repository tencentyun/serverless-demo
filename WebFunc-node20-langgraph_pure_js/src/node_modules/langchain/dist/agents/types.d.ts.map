{"version":3,"file":"types.d.ts","names":["InteropZodObject","InteropZodType","START","END","StateGraph","LanguageModelLike","BaseMessage","SystemMessage","MessageStructure","MessageToolDefinition","BaseCheckpointSaver","BaseStore","Messages","ClientTool","ServerTool","DynamicStructuredTool","StructuredToolInterface","ResponseFormat","ToolStrategy","TypedToolStrategy","ProviderStrategy","JsonSchemaFormat","ResponseFormatUndefined","AgentMiddleware","AnyAnnotationRoot","InferSchemaInput","InferMiddlewareStates","InferMiddlewareContexts","JumpToTarget","AgentTypeConfig","TResponse","TState","TContext","TMiddleware","TTools","Record","DefaultAgentTypeConfig","InferMiddlewareTools","T","InferMiddlewareToolsArray","First","Rest","CombineTools","TAgentTools","ExtractToolDefinition","SchemaInputT","ToolOutputT","ToolsToMessageToolSet","K","N","ResolveAgentTypeConfig","Types","InferAgentType","InferAgentResponse","InferAgentStateSchema","InferAgentState","InferAgentContextSchema","InferAgentContext","InferAgentMiddleware","InferAgentTools","Interrupt","TValue","BuiltInState","TMessageStructure","UserInput","TStateSchema","ToolCall","ToolResult","JumpTo","ExecutedToolCall","CreateAgentParams","StructuredResponseType","StateSchema","ContextSchema","ResponseFormatType","AbortSignal","ExtractZodArrayTypes","A","WithStateGraphNodes","Graph","SD","S","U","I","O","C"],"sources":["../../src/agents/types.d.ts"],"sourcesContent":["import type { InteropZodObject, InteropZodType } from \"@langchain/core/utils/types\";\nimport type { START, END, StateGraph } from \"@langchain/langgraph\";\nimport type { LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport type { BaseMessage, SystemMessage, MessageStructure, MessageToolDefinition } from \"@langchain/core/messages\";\nimport type { BaseCheckpointSaver, BaseStore } from \"@langchain/langgraph-checkpoint\";\nimport type { Messages } from \"@langchain/langgraph/\";\nimport type { ClientTool, ServerTool, DynamicStructuredTool, StructuredToolInterface } from \"@langchain/core/tools\";\nimport type { ResponseFormat, ToolStrategy, TypedToolStrategy, ProviderStrategy, JsonSchemaFormat, ResponseFormatUndefined } from \"./responses.js\";\nimport type { AgentMiddleware, AnyAnnotationRoot, InferSchemaInput, InferMiddlewareStates, InferMiddlewareContexts } from \"./middleware/types.js\";\nimport type { JumpToTarget } from \"./constants.js\";\n/**\n * Type bag that encapsulates all agent type parameters.\n *\n * This interface bundles all the generic type parameters used throughout the agent system\n * into a single configuration object. This pattern simplifies type signatures and makes\n * it easier to add new type parameters without changing multiple function signatures.\n *\n * @typeParam TResponse - The structured response type when using `responseFormat`.\n *   Defaults to `Record<string, any>`. Set to `ResponseFormatUndefined` when no\n *   response format is configured.\n *\n * @typeParam TState - The custom state schema type. Can be an `AnnotationRoot`,\n *   `InteropZodObject`, or `undefined`. The state persists across agent invocations\n *   when using a checkpointer.\n *\n * @typeParam TContext - The context schema type. Context is read-only and not\n *   persisted between invocations. Defaults to `AnyAnnotationRoot`.\n *\n * @typeParam TMiddleware - The middleware array type. Must be a readonly array\n *   of `AgentMiddleware` instances.\n *\n * @typeParam TTools - The combined tools type from both `createAgent` tools parameter\n *   and middleware tools. This is a readonly array of `ClientTool | ServerTool`.\n *\n * @example\n * ```typescript\n * // Define a type configuration\n * type MyAgentTypes = AgentTypeConfig<\n *   { name: string; email: string },  // Response type\n *   typeof MyStateSchema,              // State schema\n *   typeof MyContextSchema,            // Context schema\n *   typeof myMiddleware,               // Middleware array\n *   typeof myTools                     // Tools array\n * >;\n *\n * // Use with ReactAgent\n * const agent: ReactAgent<MyAgentTypes> = createAgent({ ... });\n * ```\n */\nexport interface AgentTypeConfig<TResponse extends Record<string, any> | ResponseFormatUndefined = Record<string, any> | ResponseFormatUndefined, TState extends AnyAnnotationRoot | InteropZodObject | undefined = AnyAnnotationRoot | InteropZodObject | undefined, TContext extends AnyAnnotationRoot | InteropZodObject = AnyAnnotationRoot | InteropZodObject, TMiddleware extends readonly AgentMiddleware[] = readonly AgentMiddleware[], TTools extends readonly (ClientTool | ServerTool)[] = readonly (ClientTool | ServerTool)[]> {\n    /** The structured response type when using `responseFormat` */\n    Response: TResponse;\n    /** The custom state schema type */\n    State: TState;\n    /** The context schema type */\n    Context: TContext;\n    /** The middleware array type */\n    Middleware: TMiddleware;\n    /** The combined tools type from agent and middleware */\n    Tools: TTools;\n}\n/**\n * Default type configuration for agents.\n * Used when no explicit type parameters are provided.\n */\nexport interface DefaultAgentTypeConfig extends AgentTypeConfig {\n    Response: Record<string, any>;\n    State: undefined;\n    Context: AnyAnnotationRoot;\n    Middleware: readonly AgentMiddleware[];\n    Tools: readonly (ClientTool | ServerTool)[];\n}\n/**\n * Helper type to infer tools from a single middleware instance.\n * Extracts the TTools type parameter from AgentMiddleware.\n */\nexport type InferMiddlewareTools<T extends AgentMiddleware> = T extends AgentMiddleware<any, any, any, infer TTools> ? TTools extends readonly (ClientTool | ServerTool)[] ? TTools : readonly [] : readonly [];\n/**\n * Helper type to infer and merge tools from an array of middleware.\n * Recursively extracts tools from each middleware and combines them into a single tuple.\n */\nexport type InferMiddlewareToolsArray<T extends readonly AgentMiddleware[]> = T extends readonly [] ? readonly [] : T extends readonly [infer First, ...infer Rest] ? First extends AgentMiddleware ? Rest extends readonly AgentMiddleware[] ? readonly [\n    ...InferMiddlewareTools<First>,\n    ...InferMiddlewareToolsArray<Rest>\n] : InferMiddlewareTools<First> : readonly [] : readonly [];\n/**\n * Helper type to combine agent tools with middleware tools into a single readonly array.\n */\nexport type CombineTools<TAgentTools extends readonly (ClientTool | ServerTool)[], TMiddleware extends readonly AgentMiddleware[]> = readonly [...TAgentTools, ...InferMiddlewareToolsArray<TMiddleware>];\n/**\n * Helper type to extract the tool name, input type, and output type from a tool.\n * Converts a single tool to a MessageToolDefinition entry.\n */\ntype ExtractToolDefinition<T> = T extends DynamicStructuredTool<infer _SchemaT, infer _SchemaOutputT, infer SchemaInputT, infer ToolOutputT, infer _NameT> ? MessageToolDefinition<SchemaInputT, ToolOutputT> : T extends StructuredToolInterface<infer _SchemaT, infer SchemaInputT, infer ToolOutputT> ? MessageToolDefinition<SchemaInputT, ToolOutputT> : MessageToolDefinition;\n/**\n * Helper type to convert an array of tools (ClientTool | ServerTool)[] to a MessageToolSet.\n * This maps each tool's name (as a literal type) to its MessageToolDefinition containing\n * the input and output types.\n *\n * @example\n * ```typescript\n * const myTool = tool(async (input: { a: number }) => 42, {\n *   name: \"myTool\",\n *   schema: z.object({ a: z.number() })\n * });\n *\n * // Results in: { myTool: MessageToolDefinition<{ a: number }, number> }\n * type ToolSet = ToolsToMessageToolSet<readonly [typeof myTool]>;\n * ```\n */\nexport type ToolsToMessageToolSet<T extends readonly (ClientTool | ServerTool)[]> = {\n    [K in T[number] as K extends {\n        name: infer N extends string;\n    } ? N : never]: ExtractToolDefinition<K>;\n};\n/**\n * Helper type to resolve an AgentTypeConfig from either:\n * - An AgentTypeConfig directly\n * - A ReactAgent instance (using `typeof agent`)\n *\n * @example\n * ```typescript\n * const agent = createAgent({ ... });\n *\n * // From ReactAgent instance\n * type Types = ResolveAgentTypeConfig<typeof agent>;\n *\n * // From AgentTypeConfig directly\n * type Types2 = ResolveAgentTypeConfig<AgentTypeConfig<...>>;\n * ```\n */\nexport type ResolveAgentTypeConfig<T> = T extends {\n    \"~agentTypes\": infer Types;\n} ? Types extends AgentTypeConfig ? Types : never : T extends AgentTypeConfig ? T : never;\n/**\n * Helper type to extract any property from an AgentTypeConfig or ReactAgent.\n *\n * @typeParam T - The AgentTypeConfig or ReactAgent to extract from\n * @typeParam K - The property key to extract (\"Response\" | \"State\" | \"Context\" | \"Middleware\" | \"Tools\")\n *\n * @example\n * ```typescript\n * const agent = createAgent({ tools: [myTool], ... });\n *\n * // Extract from agent instance\n * type Tools = InferAgentType<typeof agent, \"Tools\">;\n *\n * // Extract from type config\n * type Response = InferAgentType<MyTypeConfig, \"Response\">;\n * ```\n */\nexport type InferAgentType<T, K extends keyof AgentTypeConfig> = ResolveAgentTypeConfig<T>[K];\n/**\n * Shorthand helper to extract the Response type from an AgentTypeConfig or ReactAgent.\n *\n * @example\n * ```typescript\n * const agent = createAgent({ responseFormat: z.object({ name: z.string() }), ... });\n * type Response = InferAgentResponse<typeof agent>;  // { name: string }\n * ```\n */\nexport type InferAgentResponse<T> = InferAgentType<T, \"Response\">;\n/**\n * Shorthand helper to extract the raw State schema type from an AgentTypeConfig or ReactAgent.\n * This returns just the `stateSchema` type passed to `createAgent`, not merged with middleware.\n *\n * For the complete merged state (what `invoke` returns), use {@link InferAgentState}.\n *\n * @example\n * ```typescript\n * const agent = createAgent({ stateSchema: mySchema, ... });\n * type Schema = InferAgentStateSchema<typeof agent>;\n * ```\n */\nexport type InferAgentStateSchema<T> = InferAgentType<T, \"State\">;\n/**\n * Helper type to infer the full merged state from an agent, including:\n * - The agent's own state schema (if provided via `stateSchema`)\n * - All middleware states\n *\n * This matches the state type returned by `invoke` and used throughout the agent.\n *\n * @example\n * ```typescript\n * const middleware = createMiddleware({\n *   name: \"counter\",\n *   stateSchema: z.object({ count: z.number() }),\n * });\n *\n * const agent = createAgent({\n *   model: \"gpt-4\",\n *   tools: [],\n *   stateSchema: z.object({ userId: z.string() }),\n *   middleware: [middleware],\n * });\n *\n * type State = InferAgentState<typeof agent>;\n * // { userId: string; count: number }\n * ```\n */\nexport type InferAgentState<T> = InferSchemaInput<InferAgentType<T, \"State\">> & InferMiddlewareStates<InferAgentType<T, \"Middleware\">>;\n/**\n * Shorthand helper to extract the raw Context schema type from an AgentTypeConfig or ReactAgent.\n * This returns just the `contextSchema` type passed to `createAgent`, not merged with middleware.\n *\n * For the complete merged context (agent context + middleware contexts), use {@link InferAgentContext}.\n *\n * @example\n * ```typescript\n * const agent = createAgent({ contextSchema: myContextSchema, ... });\n * type Schema = InferAgentContextSchema<typeof agent>;\n * ```\n */\nexport type InferAgentContextSchema<T> = InferAgentType<T, \"Context\">;\n/**\n * Helper type to infer the full merged context from an agent, including:\n * - The agent's own context schema (if provided via `contextSchema`)\n * - All middleware context schemas\n *\n * This matches the context type available throughout the agent runtime.\n *\n * @example\n * ```typescript\n * const middleware = createMiddleware({\n *   name: \"auth\",\n *   contextSchema: z.object({ userId: z.string() }),\n * });\n *\n * const agent = createAgent({\n *   model: \"gpt-4\",\n *   tools: [],\n *   contextSchema: z.object({ sessionId: z.string() }),\n *   middleware: [middleware],\n * });\n *\n * type Context = InferAgentContext<typeof agent>;\n * // { sessionId: string; userId: string }\n * ```\n */\nexport type InferAgentContext<T> = InferSchemaInput<InferAgentType<T, \"Context\">> & InferMiddlewareContexts<InferAgentType<T, \"Middleware\">>;\n/**\n * Shorthand helper to extract the Middleware type from an AgentTypeConfig or ReactAgent.\n *\n * @example\n * ```typescript\n * const agent = createAgent({ middleware: [authMiddleware, loggingMiddleware], ... });\n * type Middleware = InferAgentMiddleware<typeof agent>;\n * ```\n */\nexport type InferAgentMiddleware<T> = InferAgentType<T, \"Middleware\">;\n/**\n * Shorthand helper to extract the Tools type from an AgentTypeConfig or ReactAgent.\n *\n * @example\n * ```typescript\n * const agent = createAgent({ tools: [searchTool, calculatorTool], ... });\n * type Tools = InferAgentTools<typeof agent>;  // readonly [typeof searchTool, typeof calculatorTool]\n * ```\n */\nexport type InferAgentTools<T> = InferAgentType<T, \"Tools\">;\nexport type N = typeof START | \"model_request\" | \"tools\";\n/**\n * Represents information about an interrupt.\n */\nexport interface Interrupt<TValue = unknown> {\n    /**\n     * The ID of the interrupt.\n     */\n    id: string;\n    /**\n     * The requests for human input.\n     */\n    value: TValue;\n}\nexport interface BuiltInState<TMessageStructure extends MessageStructure = MessageStructure> {\n    messages: BaseMessage<TMessageStructure>[];\n    __interrupt__?: Interrupt[];\n    /**\n     * Optional property to control routing after afterModel middleware execution.\n     * When set by middleware, the agent will jump to the specified node instead of\n     * following normal routing logic. The property is automatically cleared after use.\n     *\n     * - \"model_request\": Jump back to the model for another LLM call\n     * - \"tools\": Jump to tool execution (requires tools to be available)\n     */\n    jumpTo?: JumpToTarget;\n}\n/**\n * Base input type for `.invoke` and `.stream` methods.\n */\nexport type UserInput<TStateSchema extends AnyAnnotationRoot | InteropZodObject | undefined = undefined> = InferSchemaInput<TStateSchema> & {\n    messages: Messages;\n};\n/**\n * Information about a tool call that has been executed.\n */\nexport interface ToolCall {\n    /**\n     * The ID of the tool call.\n     */\n    id: string;\n    /**\n     * The name of the tool that was called.\n     */\n    name: string;\n    /**\n     * The arguments that were passed to the tool.\n     */\n    args: Record<string, any>;\n    /**\n     * The result of the tool call.\n     */\n    result?: unknown;\n    /**\n     * An optional error message if the tool call failed.\n     */\n    error?: string;\n}\n/**\n * Information about a tool result from a tool execution.\n */\nexport interface ToolResult {\n    /**\n     * The ID of the tool call.\n     */\n    id: string;\n    /**\n     * The result of the tool call.\n     */\n    result: any;\n    /**\n     * An optional error message if the tool call failed.\n     */\n    error?: string;\n}\n/**\n * jump targets (internal)\n */\nexport type JumpTo = \"model_request\" | \"tools\" | typeof END;\n/**\n * Information about a tool call that has been executed.\n */\nexport interface ExecutedToolCall {\n    /**\n     * The name of the tool that was called.\n     */\n    name: string;\n    /**\n     * The arguments that were passed to the tool.\n     */\n    args: Record<string, unknown>;\n    /**\n     * The ID of the tool call.\n     */\n    tool_id: string;\n    /**\n     * The result of the tool call (if available).\n     */\n    result?: unknown;\n}\nexport type CreateAgentParams<StructuredResponseType extends Record<string, any> = Record<string, any>, StateSchema extends AnyAnnotationRoot | InteropZodObject | undefined = undefined, ContextSchema extends AnyAnnotationRoot | InteropZodObject = AnyAnnotationRoot, ResponseFormatType = InteropZodType<StructuredResponseType> | InteropZodType<unknown>[] | JsonSchemaFormat | JsonSchemaFormat[] | ResponseFormat | TypedToolStrategy<StructuredResponseType> | ToolStrategy<StructuredResponseType> | ProviderStrategy<StructuredResponseType> | ResponseFormatUndefined> = {\n    /**\n     * Defines a model to use for the agent. You can either pass in an instance of a LangChain chat model\n     * or a string. If a string is provided the agent initializes a ChatModel based on the provided model name and provider.\n     * It supports various model providers and allows for runtime configuration of model parameters.\n     *\n     * @uses {@link initChatModel}\n     * @example\n     * ```ts\n     * const agent = createAgent({\n     *   model: \"anthropic:claude-3-7-sonnet-latest\",\n     *   // ...\n     * });\n     * ```\n     *\n     * @example\n     * ```ts\n     * import { ChatOpenAI } from \"@langchain/openai\";\n     * const agent = createAgent({\n     *   model: new ChatOpenAI({ model: \"gpt-4o\" }),\n     *   // ...\n     * });\n     * ```\n     */\n    model: string | LanguageModelLike;\n    /**\n     * A list of tools or a ToolNode.\n     *\n     * @example\n     * ```ts\n     * import { tool } from \"langchain\";\n     *\n     * const weatherTool = tool(() => \"Sunny!\", {\n     *   name: \"get_weather\",\n     *   description: \"Get the weather for a location\",\n     *   schema: z.object({\n     *     location: z.string().describe(\"The location to get weather for\"),\n     *   }),\n     * });\n     *\n     * const agent = createAgent({\n     *   tools: [weatherTool],\n     *   // ...\n     * });\n     * ```\n     */\n    tools?: (ServerTool | ClientTool)[];\n    /**\n     * An optional system message for the model.\n     *\n     * **Use a `string`** for simple, static system prompts. This is the most common use case\n     * and works well with template literals for dynamic content. When a string is provided,\n     * it's converted to a single text block internally.\n     *\n     * **Use a `SystemMessage`** when you need advanced features that require structured content:\n     * - **Anthropic cache control**: Use `SystemMessage` with array content to enable per-block\n     *   cache control settings (e.g., `cache_control: { type: \"ephemeral\" }`). This allows you\n     *   to have different cache settings for different parts of your system prompt.\n     * - **Multiple content blocks**: When you need multiple text blocks with different metadata\n     *   or formatting requirements.\n     * - **Integration with existing code**: When working with code that already produces\n     *   `SystemMessage` instances.\n     *\n     * @example Using a string (recommended for most cases)\n     * ```ts\n     * const agent = createAgent({\n     *   model: \"anthropic:claude-3-5-sonnet\",\n     *   systemPrompt: \"You are a helpful assistant.\",\n     *   // ...\n     * });\n     * ```\n     *\n     * @example Using a string with template literals\n     * ```ts\n     * const userRole = \"premium\";\n     * const agent = createAgent({\n     *   model: \"anthropic:claude-3-5-sonnet\",\n     *   systemPrompt: `You are a helpful assistant for ${userRole} users.`,\n     *   // ...\n     * });\n     * ```\n     *\n     * @example Using SystemMessage with cache control (Anthropic)\n     * ```ts\n     * import { SystemMessage } from \"@langchain/core/messages\";\n     *\n     * const agent = createAgent({\n     *   model: \"anthropic:claude-3-5-sonnet\",\n     *   systemPrompt: new SystemMessage({\n     *     content: [\n     *       {\n     *         type: \"text\",\n     *         text: \"You are a helpful assistant.\",\n     *       },\n     *       {\n     *         type: \"text\",\n     *         text: \"Today's date is 2024-06-01.\",\n     *         cache_control: { type: \"ephemeral\" },\n     *       },\n     *     ],\n     *   }),\n     *   // ...\n     * });\n     * ```\n     *\n     * @example Using SystemMessage (simple)\n     * ```ts\n     * import { SystemMessage } from \"@langchain/core/messages\";\n     *\n     * const agent = createAgent({\n     *   model: \"anthropic:claude-3-5-sonnet\",\n     *   systemPrompt: new SystemMessage(\"You are a helpful assistant.\"),\n     *   // ...\n     * });\n     * ```\n     */\n    systemPrompt?: string | SystemMessage;\n    /**\n     * An optional schema for the agent state. It allows you to define custom state properties that persist\n     * across agent invocations and can be accessed in hooks, middleware, and throughout the agent's execution.\n     * The state is persisted when using a checkpointer and can be updated by middleware or during execution.\n     *\n     * As opposed to the context (defined in `contextSchema`), the state is persisted between agent invocations\n     * when using a checkpointer, making it suitable for maintaining conversation history, user preferences,\n     * or any other data that should persist across multiple interactions.\n     *\n     * @example\n     * ```ts\n     * import { z } from \"zod\";\n     * import { createAgent } from \"@langchain/langgraph\";\n     *\n     * const agent = createAgent({\n     *   model: \"openai:gpt-4o\",\n     *   tools: [getWeather],\n     *   stateSchema: z.object({\n     *     userPreferences: z.object({\n     *       temperatureUnit: z.enum([\"celsius\", \"fahrenheit\"]).default(\"celsius\"),\n     *       location: z.string().optional(),\n     *     }).optional(),\n     *     conversationCount: z.number().default(0),\n     *   }),\n     *   prompt: (state, config) => {\n     *     const unit = state.userPreferences?.temperatureUnit || \"celsius\";\n     *     return [\n     *       new SystemMessage(`You are a helpful assistant. Use ${unit} for temperature.`),\n     *     ];\n     *   },\n     * });\n     *\n     * const result = await agent.invoke({\n     *   messages: [\n     *     new HumanMessage(\"What's the weather like?\"),\n     *   ],\n     *   userPreferences: {\n     *     temperatureUnit: \"fahrenheit\",\n     *     location: \"New York\",\n     *   },\n     *   conversationCount: 1,\n     * });\n     * ```\n     */\n    stateSchema?: StateSchema;\n    /**\n     * An optional schema for the context. It allows to pass in a typed context object into the agent\n     * invocation and allows to access it in hooks such as `prompt` and middleware.\n     * As opposed to the agent state, defined in `stateSchema`, the context is not persisted between\n     * agent invocations.\n     *\n     * @example\n     * ```ts\n     * const agent = createAgent({\n     *   llm: model,\n     *   tools: [getWeather],\n     *   contextSchema: z.object({\n     *     capital: z.string(),\n     *   }),\n     *   prompt: (state, config) => {\n     *     return [\n     *       new SystemMessage(`You are a helpful assistant. The capital of France is ${config.context.capital}.`),\n     *     ];\n     *   },\n     * });\n     *\n     * const result = await agent.invoke({\n     *   messages: [\n     *     new SystemMessage(\"You are a helpful assistant.\"),\n     *     new HumanMessage(\"What is the capital of France?\"),\n     *   ],\n     * }, {\n     *   context: {\n     *     capital: \"Paris\",\n     *   },\n     * });\n     * ```\n     */\n    contextSchema?: ContextSchema;\n    /**\n     * An optional checkpoint saver to persist the agent's state.\n     * @see {@link https://docs.langchain.com/oss/javascript/langgraph/persistence | Checkpointing}\n     */\n    checkpointer?: BaseCheckpointSaver | boolean;\n    /**\n     * An optional store to persist the agent's state.\n     * @see {@link https://docs.langchain.com/oss/javascript/langgraph/memory#memory-storage | Long-term memory}\n     */\n    store?: BaseStore;\n    /**\n     * An optional schema for the final agent output.\n     *\n     * If provided, output will be formatted to match the given schema and returned in the 'structuredResponse' state key.\n     * If not provided, `structuredResponse` will not be present in the output state.\n     *\n     * Can be passed in as:\n     *   - Zod schema\n     *     ```ts\n     *     const agent = createAgent({\n     *       responseFormat: z.object({\n     *         capital: z.string(),\n     *       }),\n     *       // ...\n     *     });\n     *     ```\n     *   - JSON schema\n     *     ```ts\n     *     const agent = createAgent({\n     *       responseFormat: {\n     *         type: \"json_schema\",\n     *         schema: {\n     *           type: \"object\",\n     *           properties: {\n     *             capital: { type: \"string\" },\n     *           },\n     *           required: [\"capital\"],\n     *         },\n     *       },\n     *       // ...\n     *     });\n     *     ```\n     *   - Create React Agent ResponseFormat\n     *     ```ts\n     *     import { providerStrategy, toolStrategy } from \"langchain\";\n     *     const agent = createAgent({\n     *       responseFormat: providerStrategy(\n     *         z.object({\n     *           capital: z.string(),\n     *         })\n     *       ),\n     *       // or\n     *       responseFormat: [\n     *         toolStrategy({ ... }),\n     *         toolStrategy({ ... }),\n     *       ]\n     *       // ...\n     *     });\n     *     ```\n     *\n     * **Note**: The graph will make a separate call to the LLM to generate the structured response after the agent loop is finished.\n     * This is not the only strategy to get structured responses, see more options in [this guide](https://langchain-ai.github.io/langgraph/how-tos/react-agent-structured-output/).\n     */\n    responseFormat?: ResponseFormatType;\n    /**\n     * Middleware instances to run during agent execution.\n     * Each middleware can define its own state schema and hook into the agent lifecycle.\n     *\n     * @see {@link https://docs.langchain.com/oss/javascript/langchain/middleware | Middleware}\n     */\n    middleware?: readonly AgentMiddleware[];\n    /**\n     * An optional name for the agent.\n     */\n    name?: string;\n    /**\n     * An optional description for the agent.\n     * This can be used to describe the agent to the underlying supervisor LLM.\n     */\n    description?: string;\n    /**\n     * Use to specify how to expose the agent name to the underlying supervisor LLM.\n     *   - `undefined`: Relies on the LLM provider {@link AIMessage#name}. Currently, only OpenAI supports this.\n     *   - `\"inline\"`: Add the agent name directly into the content field of the {@link AIMessage} using XML-style tags.\n     *       Example: `\"How can I help you\"` -> `\"<name>agent_name</name><content>How can I help you?</content>\"`\n     */\n    includeAgentName?: \"inline\" | undefined;\n    /**\n     * An optional abort signal that indicates that the overall operation should be aborted.\n     */\n    signal?: AbortSignal;\n    /**\n     * Determines the version of the graph to create.\n     *\n     * Can be one of\n     * - `\"v1\"`: The tool node processes a single message. All tool calls in the message are\n     *           executed in parallel within the tool node.\n     * - `\"v2\"`: The tool node processes a single tool call. Tool calls are distributed across\n     *           multiple instances of the tool node using the Send API.\n     *\n     * @default `\"v2\"`\n     */\n    version?: \"v1\" | \"v2\";\n};\n/**\n * Type helper to extract union type from an array of Zod schemas\n */\nexport type ExtractZodArrayTypes<T extends readonly InteropZodType<any>[]> = T extends readonly [InteropZodType<infer A>, ...infer Rest] ? Rest extends readonly InteropZodType<any>[] ? A | ExtractZodArrayTypes<Rest> : A : never;\nexport type WithStateGraphNodes<K extends string, Graph> = Graph extends StateGraph<infer SD, infer S, infer U, infer N, infer I, infer O, infer C> ? StateGraph<SD, S, U, N | K, I, O, C> : never;\nexport {};\n//# sourceMappingURL=types.d.ts.map"],"mappings":"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"}