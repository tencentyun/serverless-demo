{"version":3,"file":"constants.d.ts","names":["PendingWrite","START","END","INPUT","COPY","ERROR","CACHE_NS_WRITES","CONFIG_KEY_SEND","CONFIG_KEY_CALL","CONFIG_KEY_READ","CONFIG_KEY_CHECKPOINTER","CONFIG_KEY_RESUMING","CONFIG_KEY_TASK_ID","CONFIG_KEY_STREAM","CONFIG_KEY_RESUME_VALUE","CONFIG_KEY_RESUME_MAP","CONFIG_KEY_SCRATCHPAD","CONFIG_KEY_PREVIOUS_STATE","CONFIG_KEY_DURABILITY","CONFIG_KEY_CHECKPOINT_ID","CONFIG_KEY_CHECKPOINT_NS","CONFIG_KEY_NODE_FINISHED","CONFIG_KEY_CHECKPOINT_MAP","CONFIG_KEY_ABORT_SIGNALS","INTERRUPT","RESUME","NO_WRITES","RETURN","PREVIOUS","RUNTIME_PLACEHOLDER","RECURSION_LIMIT_DEFAULT","TAG_HIDDEN","TAG_NOSTREAM","SELF","TASKS","PUSH","PULL","TASK_NAMESPACE","NULL_TASK_ID","RESERVED","CHECKPOINT_NAMESPACE_SEPARATOR","CHECKPOINT_NAMESPACE_END","COMMAND_SYMBOL","CommandInstance","Record","Resume","Update","Nodes","CommandParams","SendInterface","Node","Args","_isSendInterface","Send","_isSend","Interrupt","Value","isInterrupted","Command","Omit","isCommand","_deserializeCommandSendObjectGraph","Map"],"sources":["../src/constants.d.ts"],"sourcesContent":["import { PendingWrite } from \"@langchain/langgraph-checkpoint\";\n/** Special reserved node name denoting the start of a graph. */\nexport declare const START = \"__start__\";\n/** Special reserved node name denoting the end of a graph. */\nexport declare const END = \"__end__\";\nexport declare const INPUT = \"__input__\";\nexport declare const COPY = \"__copy__\";\nexport declare const ERROR = \"__error__\";\n/** Special reserved cache namespaces */\nexport declare const CACHE_NS_WRITES = \"__pregel_ns_writes\";\nexport declare const CONFIG_KEY_SEND = \"__pregel_send\";\n/** config key containing function used to call a node (push task) */\nexport declare const CONFIG_KEY_CALL = \"__pregel_call\";\nexport declare const CONFIG_KEY_READ = \"__pregel_read\";\nexport declare const CONFIG_KEY_CHECKPOINTER = \"__pregel_checkpointer\";\nexport declare const CONFIG_KEY_RESUMING = \"__pregel_resuming\";\nexport declare const CONFIG_KEY_TASK_ID = \"__pregel_task_id\";\nexport declare const CONFIG_KEY_STREAM = \"__pregel_stream\";\nexport declare const CONFIG_KEY_RESUME_VALUE = \"__pregel_resume_value\";\nexport declare const CONFIG_KEY_RESUME_MAP = \"__pregel_resume_map\";\nexport declare const CONFIG_KEY_SCRATCHPAD = \"__pregel_scratchpad\";\n/** config key containing state from previous invocation of graph for the given thread */\nexport declare const CONFIG_KEY_PREVIOUS_STATE = \"__pregel_previous\";\nexport declare const CONFIG_KEY_DURABILITY = \"__pregel_durability\";\nexport declare const CONFIG_KEY_CHECKPOINT_ID = \"checkpoint_id\";\nexport declare const CONFIG_KEY_CHECKPOINT_NS = \"checkpoint_ns\";\nexport declare const CONFIG_KEY_NODE_FINISHED = \"__pregel_node_finished\";\nexport declare const CONFIG_KEY_CHECKPOINT_MAP = \"checkpoint_map\";\nexport declare const CONFIG_KEY_ABORT_SIGNALS = \"__pregel_abort_signals\";\n/** Special channel reserved for graph interrupts */\nexport declare const INTERRUPT = \"__interrupt__\";\n/** Special channel reserved for graph resume */\nexport declare const RESUME = \"__resume__\";\n/** Special channel reserved for cases when a task exits without any writes */\nexport declare const NO_WRITES = \"__no_writes__\";\n/** Special channel reserved for graph return */\nexport declare const RETURN = \"__return__\";\n/** Special channel reserved for graph previous state */\nexport declare const PREVIOUS = \"__previous__\";\nexport declare const RUNTIME_PLACEHOLDER = \"__pregel_runtime_placeholder__\";\nexport declare const RECURSION_LIMIT_DEFAULT = 25;\nexport declare const TAG_HIDDEN = \"langsmith:hidden\";\nexport declare const TAG_NOSTREAM = \"langsmith:nostream\";\nexport declare const SELF = \"__self__\";\nexport declare const TASKS = \"__pregel_tasks\";\nexport declare const PUSH = \"__pregel_push\";\nexport declare const PULL = \"__pregel_pull\";\nexport declare const TASK_NAMESPACE = \"6ba7b831-9dad-11d1-80b4-00c04fd430c8\";\nexport declare const NULL_TASK_ID = \"00000000-0000-0000-0000-000000000000\";\nexport declare const RESERVED: string[];\nexport declare const CHECKPOINT_NAMESPACE_SEPARATOR = \"|\";\nexport declare const CHECKPOINT_NAMESPACE_END = \":\";\n/** @internal */\ndeclare const COMMAND_SYMBOL: unique symbol;\n/**\n * Instance of a {@link Command} class.\n *\n * This is used to avoid IntelliSense suggesting public fields\n * of {@link Command} class when a plain object is expected.\n *\n * @see {@link Command}\n * @internal\n */\nexport declare class CommandInstance<Resume = unknown, Update extends Record<string, unknown> = Record<string, unknown>, Nodes extends string = string> {\n    [COMMAND_SYMBOL]: CommandParams<Resume, Update, Nodes>;\n    constructor(args: CommandParams<Resume, Update, Nodes>);\n}\nexport interface SendInterface<Node extends string = string, Args = any> {\n    node: Node;\n    args: Args;\n}\nexport declare function _isSendInterface(x: unknown): x is SendInterface;\n/**\n *\n * A message or packet to send to a specific node in the graph.\n *\n * The `Send` class is used within a `StateGraph`'s conditional edges to\n * dynamically invoke a node with a custom state at the next step.\n *\n * Importantly, the sent state can differ from the core graph's state,\n * allowing for flexible and dynamic workflow management.\n *\n * One such example is a \"map-reduce\" workflow where your graph invokes\n * the same node multiple times in parallel with different states,\n * before aggregating the results back into the main graph's state.\n *\n * @example\n * ```typescript\n * import { Annotation, Send, StateGraph } from \"@langchain/langgraph\";\n *\n * const ChainState = Annotation.Root({\n *   subjects: Annotation<string[]>,\n *   jokes: Annotation<string[]>({\n *     reducer: (a, b) => a.concat(b),\n *   }),\n * });\n *\n * const continueToJokes = async (state: typeof ChainState.State) => {\n *   return state.subjects.map((subject) => {\n *     return new Send(\"generate_joke\", { subjects: [subject] });\n *   });\n * };\n *\n * const graph = new StateGraph(ChainState)\n *   .addNode(\"generate_joke\", (state) => ({\n *     jokes: [`Joke about ${state.subjects}`],\n *   }))\n *   .addConditionalEdges(\"__start__\", continueToJokes)\n *   .addEdge(\"generate_joke\", \"__end__\")\n *   .compile();\n *\n * const res = await graph.invoke({ subjects: [\"cats\", \"dogs\"] });\n * console.log(res);\n *\n * // Invoking with two subjects results in a generated joke for each\n * // { subjects: [\"cats\", \"dogs\"], jokes: [`Joke about cats`, `Joke about dogs`] }\n * ```\n */\nexport declare class Send<Node extends string = string, Args = any> implements SendInterface<Node, Args> {\n    lg_name: string;\n    node: Node;\n    args: Args;\n    constructor(node: Node, args: Args);\n    toJSON(): {\n        lg_name: string;\n        node: Node;\n        args: Args;\n    };\n}\nexport declare function _isSend(x: unknown): x is Send;\nexport type Interrupt<Value = any> = {\n    id?: string;\n    value?: Value;\n};\n/**\n * Checks if the given graph invoke / stream chunk contains interrupt.\n *\n * @example\n * ```ts\n * import { INTERRUPT, isInterrupted } from \"@langchain/langgraph\";\n *\n * const values = await graph.invoke({ foo: \"bar\" });\n * if (isInterrupted<string>(values)) {\n *   const interrupt = values[INTERRUPT][0].value;\n * }\n * ```\n *\n * @param values - The values to check.\n * @returns `true` if the values contain an interrupt, `false` otherwise.\n */\nexport declare function isInterrupted<Value = unknown>(values: unknown): values is {\n    [INTERRUPT]: Interrupt<Value>[];\n};\nexport type CommandParams<Resume = unknown, Update extends Record<string, unknown> = Record<string, unknown>, Nodes extends string = string> = {\n    /**\n     * A discriminator field used to identify the type of object. Must be populated when serializing.\n     *\n     * Optional because it's not required to specify this when directly constructing a {@link Command}\n     * object.\n     */\n    lg_name?: \"Command\";\n    /**\n     * Value to resume execution with. To be used together with {@link interrupt}.\n     */\n    resume?: Resume;\n    /**\n     * Graph to send the command to. Supported values are:\n     *   - None: the current graph (default)\n     *   - The specific name of the graph to send the command to\n     *   - {@link Command.PARENT}: closest parent graph (only supported when returned from a node in a subgraph)\n     */\n    graph?: string;\n    /**\n     * Update to apply to the graph's state.\n     */\n    update?: Update | [string, unknown][];\n    /**\n     * Can be one of the following:\n     *   - name of the node to navigate to next (any node that belongs to the specified `graph`)\n     *   - sequence of node names to navigate to next\n     *   - `Send` object (to execute a node with the input provided)\n     *   - sequence of `Send` objects\n     */\n    goto?: Nodes | SendInterface<Nodes> | (Nodes | SendInterface<Nodes>)[];\n};\n/**\n * One or more commands to update the graph's state and send messages to nodes.\n * Can be used to combine routing logic with state updates in lieu of conditional edges\n *\n * @example\n * ```ts\n * import { Annotation, Command } from \"@langchain/langgraph\";\n *\n * // Define graph state\n * const StateAnnotation = Annotation.Root({\n *   foo: Annotation<string>,\n * });\n *\n * // Define the nodes\n * const nodeA = async (_state: typeof StateAnnotation.State) => {\n *   console.log(\"Called A\");\n *   // this is a replacement for a real conditional edge function\n *   const goto = Math.random() > .5 ? \"nodeB\" : \"nodeC\";\n *   // note how Command allows you to BOTH update the graph state AND route to the next node\n *   return new Command({\n *     // this is the state update\n *     update: {\n *       foo: \"a\",\n *     },\n *     // this is a replacement for an edge\n *     goto,\n *   });\n * };\n *\n * // Nodes B and C are unchanged\n * const nodeB = async (state: typeof StateAnnotation.State) => {\n *   console.log(\"Called B\");\n *   return {\n *     foo: state.foo + \"|b\",\n *   };\n * }\n *\n * const nodeC = async (state: typeof StateAnnotation.State) => {\n *   console.log(\"Called C\");\n *   return {\n *     foo: state.foo + \"|c\",\n *   };\n * }\n *\n * import { StateGraph } from \"@langchain/langgraph\";\n\n * // NOTE: there are no edges between nodes A, B and C!\n * const graph = new StateGraph(StateAnnotation)\n *   .addNode(\"nodeA\", nodeA, {\n *     ends: [\"nodeB\", \"nodeC\"],\n *   })\n *   .addNode(\"nodeB\", nodeB)\n *   .addNode(\"nodeC\", nodeC)\n *   .addEdge(\"__start__\", \"nodeA\")\n *   .compile();\n *\n * await graph.invoke({ foo: \"\" });\n *\n * // Randomly oscillates between\n * // { foo: 'a|c' } and { foo: 'a|b' }\n * ```\n */\nexport declare class Command<Resume = unknown, Update extends Record<string, unknown> = Record<string, unknown>, Nodes extends string = string> extends CommandInstance<Resume, Update, Nodes> {\n    readonly lg_name = \"Command\";\n    lc_direct_tool_output: boolean;\n    /**\n     * Graph to send the command to. Supported values are:\n     *   - None: the current graph (default)\n     *   - The specific name of the graph to send the command to\n     *   - {@link Command.PARENT}: closest parent graph (only supported when returned from a node in a subgraph)\n     */\n    graph?: string;\n    /**\n     * Update to apply to the graph's state as a result of executing the node that is returning the command.\n     * Written to the state as if the node had simply returned this value instead of the Command object.\n     */\n    update?: Update | [string, unknown][];\n    /**\n     * Value to resume execution with. To be used together with {@link interrupt}.\n     */\n    resume?: Resume;\n    /**\n     * Can be one of the following:\n     *   - name of the node to navigate to next (any node that belongs to the specified `graph`)\n     *   - sequence of node names to navigate to next\n     *   - {@link Send} object (to execute a node with the exact input provided in the {@link Send} object)\n     *   - sequence of {@link Send} objects\n     */\n    goto?: Nodes | Send<Nodes> | (Nodes | Send<Nodes>)[];\n    static PARENT: string;\n    constructor(args: Omit<CommandParams<Resume, Update, Nodes>, \"lg_name\">);\n    /**\n     * Convert the update field to a list of {@link PendingWrite} tuples\n     * @returns List of {@link PendingWrite} tuples of the form `[channelKey, value]`.\n     * @internal\n     */\n    _updateAsTuples(): PendingWrite[];\n    toJSON(): {\n        lg_name: string;\n        update: Update | [string, unknown][] | undefined;\n        resume: Resume | undefined;\n        goto: Nodes | (Nodes | {\n            lg_name: string;\n            node: Nodes;\n            args: any;\n        })[] | {\n            lg_name: string;\n            node: Nodes;\n            args: any;\n        } | undefined;\n    };\n}\n/**\n * A type guard to check if the given value is a {@link Command}.\n *\n * Useful for type narrowing when working with the {@link Command} object.\n *\n * @param x - The value to check.\n * @returns `true` if the value is a {@link Command}, `false` otherwise.\n */\nexport declare function isCommand(x: unknown): x is Command;\n/**\n * Reconstructs Command and Send objects from a deeply nested tree of anonymous objects\n * matching their interfaces.\n *\n * This is only exported for testing purposes. It is NOT intended to be used outside of\n * the Command and Send classes.\n *\n * @internal\n *\n * @param x - The command send tree to convert.\n * @param seen - A map of seen objects to avoid infinite loops.\n * @returns The converted command send tree.\n */\nexport declare function _deserializeCommandSendObjectGraph(x: unknown, seen?: Map<object, unknown>): unknown;\nexport {};\n"],"mappings":";;;;cAEqBC,KAAAA;AAArB;AAEqBC,cAAAA,GAAAA,GAAG,SAAA;;AAkH2EiD,cAxF9E3B,SAAAA,GAwF8E2B,eAAAA;;;;AAAP,cAhFvEvB,QAAAA,GAgFuE,cAAA;;cAjE9Ec,cAkImBK,EAAAA,OAAAA,MAAAA;;;;;;AAgEjC;;;;AAAwKF,cAxLnJF,eAwLmJE,CAAAA,SAAAA,OAAAA,EAAAA,eAxLlGD,MAwLkGC,CAAAA,MAAAA,EAAAA,OAAAA,CAAAA,GAxLxED,MAwLwEC,CAAAA,MAAAA,EAAAA,OAAAA,CAAAA,EAAAA,cAAAA,MAAAA,GAAAA,MAAAA,CAAAA,CAAAA;GAvLnKH,cAAAA,CAuL2KI,EAvL1JE,aAuL0JF,CAvL5ID,MAuL4IC,EAvLpIA,MAuLoIA,EAvL5HC,KAuL4HD,CAAAA;aAAQC,CAAAA,IAAAA,EAtLlKC,aAsLkKD,CAtLpJF,MAsLoJE,EAtL5ID,MAsL4IC,EAtLpIA,KAsLoIA,CAAAA;;AAkB3KF,UAtMII,aAsMJJ,CAAAA,aAAAA,MAAAA,GAAAA,MAAAA,EAAAA,OAAAA,GAAAA,CAAAA,CAAAA;MAQFE,EA7MDG,IA6MCH;MAAaA,EA5MdI,IA4McJ;;;;;;;;;;;;;;;;;;AAgCxB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cA3LqBM,0DAA0DJ,cAAcC,MAAMC;;QAEzFD;QACAC;oBACYD,YAAYC;;;UAGpBD;UACAC;;;KAIFI;;UAEAC;;;;;;;;;;;;;;;;;;iBAkBYC;GACnBjC,SAAAA,GAAY+B,UAAUC;;KAEfR,+CAA+CJ,0BAA0BA;;;;;;;;;;;WAWxEC;;;;;;;;;;;WAWAC;;;;;;;;SAQFC,QAAQE,cAAcF,UAAUA,QAAQE,cAAcF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAgE5CW,yCAAyCd,0BAA0BA,gEAAgED,gBAAgBE,QAAQC,QAAQC;;;;;;;;;;;;;;WAc3KD;;;;WAIAD;;;;;;;;SAQFE,QAAQM,KAAKN,UAAUA,QAAQM,KAAKN;;oBAEzBY,KAAKX,cAAcH,QAAQC,QAAQC;;;;;;qBAMlC/C;;;YAGP8C;YACAD;UACFE,SAASA;;YAELA;;;;YAIAA;;;;;;;;;;;;;iBAaMa,SAAAA,mBAA4BF"}