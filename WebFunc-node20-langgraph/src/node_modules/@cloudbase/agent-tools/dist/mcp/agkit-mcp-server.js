"use strict";
/**
 * AG-Kit MCP Server
 *
 * A unified MCP server that directly exposes AG-Kit tools via the MCP protocol.
 * For HTTP transports, provides transport instances for integration with any HTTP server.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.memoryTransportRegistry = exports.AGKitMCPServer = exports.MemoryTransportRegistry = void 0;
exports.zodSchemaToMCPSchema = zodSchemaToMCPSchema;
exports.convertAGKitToolToMCPMetadata = convertAGKitToolToMCPMetadata;
exports.createAGKitMCPServer = createAGKitMCPServer;
const node_crypto_1 = require("node:crypto");
const index_js_1 = require("@modelcontextprotocol/sdk/server/index.js");
const stdio_js_1 = require("@modelcontextprotocol/sdk/server/stdio.js");
const sse_js_1 = require("@modelcontextprotocol/sdk/server/sse.js");
const streamableHttp_js_1 = require("@modelcontextprotocol/sdk/server/streamableHttp.js");
const inMemory_js_1 = require("@modelcontextprotocol/sdk/inMemory.js");
const types_js_1 = require("@modelcontextprotocol/sdk/types.js");
// Global registry for memory transports using official InMemoryTransport
class MemoryTransportRegistry {
    constructor() {
        this.transports = new Map();
        this.servers = new Map();
    }
    static getInstance() {
        if (!MemoryTransportRegistry.instance) {
            MemoryTransportRegistry.instance = new MemoryTransportRegistry();
        }
        return MemoryTransportRegistry.instance;
    }
    registerServer(memoryId, server) {
        this.servers.set(memoryId, server);
    }
    unregisterServer(memoryId) {
        this.servers.delete(memoryId);
        this.transports.delete(memoryId);
    }
    getServer(memoryId) {
        return this.servers.get(memoryId);
    }
    /**
     * Creates a pair of InMemory transports (server and client)
     * Uses official InMemoryTransport.createLinkedPair()
     */
    createTransportPair(memoryId) {
        let transportPair = this.transports.get(memoryId);
        if (!transportPair) {
            // Use official InMemoryTransport to create a linked pair
            const [serverTransport, clientTransport] = inMemory_js_1.InMemoryTransport.createLinkedPair();
            transportPair = {
                server: serverTransport,
                client: clientTransport,
            };
            this.transports.set(memoryId, transportPair);
        }
        return transportPair;
    }
    /**
     * Gets the client transport for client connections
     */
    getClientTransport(memoryId) {
        const transportPair = this.transports.get(memoryId);
        if (!transportPair) {
            throw new Error(`No transport pair found with memory ID: ${memoryId}`);
        }
        return transportPair.client;
    }
    /**
     * Gets the server-side transport
     */
    getServerTransport(memoryId) {
        const transportPair = this.transports.get(memoryId);
        if (!transportPair) {
            throw new Error(`No transport pair found with memory ID: ${memoryId}`);
        }
        return transportPair.server;
    }
    // Direct API for memory-based tool calls (backward compatibility)
    async callTool(memoryId, toolName, args) {
        const server = this.servers.get(memoryId);
        if (!server) {
            throw new Error(`No MCP server found with memory ID: ${memoryId}`);
        }
        return server.callTool(toolName, args);
    }
    async listTools(memoryId) {
        const server = this.servers.get(memoryId);
        if (!server) {
            throw new Error(`No MCP server found with memory ID: ${memoryId}`);
        }
        return server.listTools();
    }
}
exports.MemoryTransportRegistry = MemoryTransportRegistry;
/**
 * Converts a zod schema to MCP JSON schema format
 */
function zodSchemaToMCPSchema(zodSchema) {
    try {
        // Try to get the schema definition
        const def = zodSchema._def;
        if (!def) {
            return { type: "object", properties: {}, additionalProperties: true };
        }
        switch (def.type) {
            case "object":
                const properties = {};
                const required = [];
                if (def.shape) {
                    const shape = typeof def.shape === "function" ? def.shape() : def.shape;
                    for (const [key, value] of Object.entries(shape)) {
                        const propSchema = zodSchemaToMCPSchema(value);
                        properties[key] = propSchema;
                        // Check if field is required (not optional)
                        const propDef = value?._def;
                        if (propDef && propDef.type !== "optional") {
                            required.push(key);
                        }
                    }
                }
                return {
                    type: "object",
                    properties,
                    required: required.length > 0 ? required : undefined,
                    additionalProperties: false,
                };
            case "string":
                const stringSchema = { type: "string" };
                if (def.description)
                    stringSchema.description = def.description;
                return stringSchema;
            case "number":
                const numberSchema = { type: "number" };
                if (def.description)
                    numberSchema.description = def.description;
                return numberSchema;
            case "boolean":
                const booleanSchema = { type: "boolean" };
                if (def.description)
                    booleanSchema.description = def.description;
                return booleanSchema;
            case "array":
                const arraySchema = {
                    type: "array",
                    items: def.element
                        ? zodSchemaToMCPSchema(def.element)
                        : { type: "any" },
                };
                if (def.description)
                    arraySchema.description = def.description;
                return arraySchema;
            case "optional":
                return zodSchemaToMCPSchema(def.innerType);
            case "enum":
                const enumSchema = {
                    type: "string",
                    enum: def.entries ? Object.keys(def.entries) : [],
                };
                if (def.description)
                    enumSchema.description = def.description;
                return enumSchema;
            case "union":
                // For unions, we'll use the first type or fallback to any
                if (def.options && def.options.length > 0) {
                    return zodSchemaToMCPSchema(def.options[0]);
                }
                return { type: "any", description: def.description };
            case "record":
                const recordSchema = {
                    type: "object",
                    additionalProperties: def.valueType
                        ? zodSchemaToMCPSchema(def.valueType)
                        : { type: "any" },
                };
                if (def.description)
                    recordSchema.description = def.description;
                return recordSchema;
            default:
                return { type: "any", description: def.description };
        }
    }
    catch (error) {
        console.warn("Failed to convert zod schema to MCP schema:", error);
        return { type: "object", properties: {}, additionalProperties: true };
    }
}
/**
 * Converts AG-Kit BaseTool to MCP tool metadata
 */
function convertAGKitToolToMCPMetadata(tool, config = {
    name: "ag-kit-mcp-server",
    version: "1.0.0",
}, toolConfig) {
    const toolMetadata = tool.getMetadata();
    // Convert zod schema to MCP JSON schema
    const inputSchema = zodSchemaToMCPSchema(tool.schema);
    // Determine final name - toolConfig.name takes precedence, then namePrefix from toolConfig
    let finalName = toolMetadata.name;
    if (toolConfig?.name) {
        finalName = toolConfig.name;
    }
    else if (toolConfig?.namePrefix) {
        finalName = `${toolConfig.namePrefix}${toolMetadata.name}`;
    }
    // Determine final description - toolConfig.description takes precedence
    let finalDescription = toolMetadata.description || `AG-Kit tool: ${toolMetadata.name}`;
    if (toolConfig?.description) {
        finalDescription = toolConfig.description;
    }
    return {
        name: finalName,
        description: finalDescription,
        inputSchema,
    };
}
/**
 * AG-Kit MCP Server
 *
 * A unified server that directly handles AG-Kit tools and MCP protocol
 */
class AGKitMCPServer {
    constructor(config = {
        name: "ag-kit-mcp-server",
        version: "1.0.0",
    }) {
        this.tools = new Map();
        this.toolConfigs = new Map();
        this.eventListeners = new Set();
        this.isRunning = false;
        this.currentTransport = null;
        this.transportType = null;
        this.config = {
            enableLogging: true,
            includeMetadata: true,
            errorHandling: "return_error",
            ...config,
        };
        // Create MCP server
        this.server = new index_js_1.Server({
            name: config.name,
            version: config.version,
        }, {
            capabilities: {
                tools: {},
            },
        });
        this.setupServerHandlers();
    }
    /**
     * Setup MCP server request handlers
     */
    setupServerHandlers() {
        // Handle list tools request
        this.server.setRequestHandler(types_js_1.ListToolsRequestSchema, async () => {
            try {
                const tools = this.getToolsMetadata();
                this.emit({
                    type: "tool_discovered",
                    tool: {
                        name: `${tools.length} tools listed`,
                        description: "",
                        inputSchema: { type: "object" },
                    },
                });
                if (this.config.enableLogging) {
                    console.log(`[AGKitMCPServer] Listed ${tools.length} tools`);
                }
                return {
                    tools: tools.map((tool) => ({
                        name: tool.name,
                        description: tool.description || "",
                        inputSchema: tool.inputSchema,
                    })),
                };
            }
            catch (error) {
                const mcpError = new types_js_1.McpError(types_js_1.ErrorCode.InternalError, `Failed to list tools: ${error instanceof Error ? error.message : String(error)}`);
                this.emit({
                    type: "error",
                    error: error instanceof Error ? error : new Error(String(error)),
                    context: "list_tools",
                });
                throw mcpError;
            }
        });
        // Handle call tool request
        this.server.setRequestHandler(types_js_1.CallToolRequestSchema, async (request) => {
            const { name, arguments: args } = request.params;
            try {
                this.emit({
                    type: "tool_called",
                    toolName: name,
                    arguments: args,
                });
                if (this.config.enableLogging) {
                    console.log(`[AGKitMCPServer] Calling tool: ${name}`, args);
                }
                // Call the tool directly
                const result = await this.callTool(name, args || {});
                this.emit({
                    type: "tool_result",
                    toolName: name,
                    result,
                });
                if (this.config.enableLogging) {
                    console.log(`[AGKitMCPServer] Tool ${name} completed:`, result.isError ? "ERROR" : "SUCCESS");
                }
                return {
                    content: result.content,
                    isError: result.isError,
                };
            }
            catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                this.emit({
                    type: "error",
                    error: error instanceof Error ? error : new Error(String(error)),
                    context: `call_tool:${name}`,
                });
                if (this.config.enableLogging) {
                    console.error(`[AGKitMCPServer] Tool ${name} failed:`, errorMessage);
                }
                const mcpError = new types_js_1.McpError(types_js_1.ErrorCode.InternalError, `Tool execution failed: ${errorMessage}`);
                throw mcpError;
            }
        });
    }
    /**
     * Register an AG-Kit tool with the server
     * @param tool - The AG-Kit tool instance to register
     * @param toolConfig - Optional configuration for the tool (name, description, etc.)
     * @returns The MCP metadata for the registered tool
     */
    registerTool(tool, toolConfig) {
        const mcpMetadata = convertAGKitToolToMCPMetadata(tool, this.config, toolConfig);
        this.tools.set(mcpMetadata.name, tool);
        if (toolConfig) {
            this.toolConfigs.set(mcpMetadata.name, toolConfig);
        }
        if (this.config.enableLogging) {
            console.log(`[AGKitMCPServer] Registered tool: ${mcpMetadata.name}`);
        }
        this.emit({
            type: "tool_discovered",
            tool: mcpMetadata,
        });
        return mcpMetadata;
    }
    /**
     * Register multiple AG-Kit tools
     */
    registerTools(tools, toolConfig) {
        const metadataList = tools.map((tool) => this.registerTool(tool, toolConfig));
        if (this.config.enableLogging) {
            console.log(`[AGKitMCPServer] Registered ${tools.length} tools`);
        }
        return metadataList;
    }
    /**
     * Unregister a tool
     */
    unregisterTool(name) {
        this.toolConfigs.delete(name);
        const success = this.tools.delete(name);
        if (success && this.config.enableLogging) {
            console.log(`[AGKitMCPServer] Unregistered tool: ${name}`);
        }
        return success;
    }
    /**
     * Execute a tool via MCP call format
     */
    async callTool(name, args) {
        const tool = this.tools.get(name);
        if (!tool) {
            return {
                content: [
                    {
                        type: "text",
                        text: `Tool '${name}' not found. Available tools: ${Array.from(this.tools.keys()).join(", ")}`,
                    },
                ],
                isError: true,
            };
        }
        try {
            // Transform input if configured
            const transformedArgs = this.config.transformInput
                ? this.config.transformInput(args)
                : args;
            // Execute the AG-Kit tool
            const result = await tool.invoke(transformedArgs);
            // Handle AG-Kit tool result
            if (!result.success) {
                if (this.config.errorHandling === "throw") {
                    throw new Error(result.error || "Tool execution failed");
                }
                return {
                    content: [
                        {
                            type: "text",
                            text: result.error || "Tool execution failed",
                        },
                    ],
                    isError: true,
                };
            }
            // Transform output if configured
            let outputData = result.data;
            if (this.config.transformOutput) {
                outputData = this.config.transformOutput(outputData);
            }
            // Format successful result
            let content;
            if (typeof outputData === "string") {
                content = [{ type: "text", text: outputData }];
            }
            else if (outputData && typeof outputData === "object") {
                // Try to format as JSON if it's an object
                content = [
                    {
                        type: "text",
                        text: JSON.stringify(outputData, null, 2),
                    },
                ];
            }
            else {
                content = [
                    {
                        type: "text",
                        text: String(outputData),
                    },
                ];
            }
            // Add metadata if configured
            if (this.config.includeMetadata && result.executionTime !== undefined) {
                content.push({
                    type: "text",
                    text: `\n[Execution time: ${result.executionTime}ms]`,
                });
            }
            return {
                content,
                isError: false,
            };
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            if (this.config.errorHandling === "throw") {
                throw error;
            }
            return {
                content: [
                    {
                        type: "text",
                        text: `Error executing tool '${name}': ${errorMessage}`,
                    },
                ],
                isError: true,
            };
        }
    }
    /**
     * Get all registered tool metadata
     */
    getToolsMetadata() {
        return Array.from(this.tools.entries()).map(([name, tool]) => {
            const toolConfig = this.toolConfigs.get(name);
            return convertAGKitToolToMCPMetadata(tool, this.config, toolConfig);
        });
    }
    /**
     * List all registered tools in MCP format
     */
    listTools() {
        const tools = [];
        Array.from(this.tools.entries()).forEach(([toolName, tool]) => {
            const toolConfig = this.toolConfigs.get(toolName);
            const metadata = convertAGKitToolToMCPMetadata(tool, this.config, toolConfig);
            tools.push({
                name: toolName,
                description: metadata.description || "",
                inputSchema: metadata.inputSchema,
            });
        });
        return tools;
    }
    /**
     * Get specific tool metadata
     */
    getToolMetadata(name) {
        const tool = this.tools.get(name);
        if (!tool)
            return null;
        const toolConfig = this.toolConfigs.get(name);
        return convertAGKitToolToMCPMetadata(tool, this.config, toolConfig);
    }
    /**
     * Check if a tool is registered
     */
    hasTool(name) {
        return this.tools.has(name);
    }
    /**
     * Get list of available tool names
     */
    getAvailableTools() {
        return Array.from(this.tools.keys());
    }
    /**
     * Get tool statistics
     */
    getStats() {
        const toolNames = Array.from(this.tools.keys());
        const toolTypes = {};
        Array.from(this.tools.values()).forEach((tool) => {
            const metadata = tool.getMetadata();
            const type = metadata.type || metadata.name || "unknown";
            toolTypes[type] = (toolTypes[type] || 0) + 1;
        });
        return {
            totalTools: this.tools.size,
            toolNames,
            toolTypes,
            isRunning: this.isRunning,
            serverInfo: {
                name: this.config.name,
                version: this.config.version,
                description: this.config.description,
            },
        };
    }
    /**
     * Start the MCP server with specified transport
     */
    async run(transportConfig) {
        if (this.isRunning) {
            throw new Error("Server is already running");
        }
        try {
            this.transportType = transportConfig.type;
            if (this.config.enableLogging) {
                console.log(`[AGKitMCPServer] Starting ${this.config.name} v${this.config.version} with ${transportConfig.type} transport`);
                console.log(`[AGKitMCPServer] Registered tools: ${this.getAvailableTools().join(", ")}`);
            }
            this.isRunning = true;
            this.emit({
                type: "connected",
                clientName: transportConfig.type,
            });
            switch (transportConfig.type) {
                case "stdio":
                    const stdioTransport = new stdio_js_1.StdioServerTransport();
                    this.currentTransport = stdioTransport;
                    await this.server.connect(stdioTransport);
                    break;
                case "sse":
                    // SSE transport - provide factory function to user
                    if (transportConfig.sseSetup) {
                        // Create SSE transport factory function
                        const createTransport = async (endpoint, response, options) => {
                            const transport = new sse_js_1.SSEServerTransport(endpoint, response, {
                                enableDnsRebindingProtection: options?.enableDnsRebindingProtection ?? false,
                                allowedHosts: options?.allowedHosts,
                                allowedOrigins: options?.allowedOrigins,
                            });
                            // Connect to MCP server
                            await this.server.connect(transport);
                            this.currentTransport = transport;
                            if (this.config.enableLogging) {
                                console.log(`[AGKitMCPServer] SSE transport created and connected for endpoint: ${endpoint}`);
                            }
                            return transport;
                        };
                        // Call user callback with factory function
                        await transportConfig.sseSetup(this, createTransport);
                    }
                    if (this.config.enableLogging) {
                        console.log(`[AGKitMCPServer] SSE transport setup completed`);
                    }
                    this.isRunning = true;
                    break;
                case "streamableHttp":
                    // StreamableHTTP transport - provide factory function to user
                    if (transportConfig.streamableHttpSetup) {
                        // Create StreamableHTTP transport factory function
                        const createTransport = async (options) => {
                            const transport = new streamableHttp_js_1.StreamableHTTPServerTransport({
                                sessionIdGenerator: options?.sessionIdGenerator || (() => (0, node_crypto_1.randomUUID)()),
                                enableJsonResponse: options?.enableJsonResponse ?? true,
                                enableDnsRebindingProtection: options?.enableDnsRebindingProtection ?? false,
                                allowedHosts: options?.allowedHosts,
                                allowedOrigins: options?.allowedOrigins,
                            });
                            // Connect to MCP server
                            await this.server.connect(transport);
                            this.currentTransport = transport;
                            if (this.config.enableLogging) {
                                console.log(`[AGKitMCPServer] StreamableHTTP transport created and connected`);
                            }
                            return transport;
                        };
                        // Call user callback with factory function
                        await transportConfig.streamableHttpSetup(this, createTransport);
                    }
                    if (this.config.enableLogging) {
                        console.log(`[AGKitMCPServer] StreamableHTTP transport setup completed`);
                    }
                    this.isRunning = true;
                    break;
                case "memory":
                    const memoryId = transportConfig.memoryId || "default";
                    const registry = MemoryTransportRegistry.getInstance();
                    // Use official InMemoryTransport to create transport pair
                    const transportPair = registry.createTransportPair(memoryId);
                    // Server connects to server transport
                    this.currentTransport = transportPair.server;
                    this.memoryId = memoryId;
                    // Register server to registry
                    registry.registerServer(memoryId, this);
                    // Connect server
                    await this.server.connect(transportPair.server);
                    if (this.config.enableLogging) {
                        console.log(`[AGKitMCPServer] Memory transport ready with ID: ${memoryId}`);
                        console.log(`[AGKitMCPServer] Use MemoryTransportRegistry.getInstance().getClientTransport('${memoryId}') to get client transport`);
                    }
                    break;
                default:
                    throw new Error(`Unsupported transport type: ${transportConfig.type}`);
            }
            if (this.config.enableLogging) {
                console.log(`[AGKitMCPServer] Server started successfully`);
            }
        }
        catch (error) {
            this.isRunning = false;
            this.currentTransport = null;
            this.transportType = null;
            this.emit({
                type: "error",
                error: error instanceof Error ? error : new Error(String(error)),
                context: "server_start",
            });
            if (this.config.enableLogging) {
                console.error(`[AGKitMCPServer] Failed to start server:`, error);
            }
            throw error;
        }
    }
    /**
     * Start the MCP server with stdio transport (backward compatibility)
     */
    async runStdio() {
        return this.run({ type: "stdio" });
    }
    /**
     * Start the MCP server with memory transport
     */
    async runMemory(memoryId = "default") {
        return this.run({ type: "memory", memoryId });
    }
    /**
     * Run with StreamableHTTP transport using user-provided setup callback
     * @param setup - Callback function to integrate with user's HTTP server
     * @param options - Optional transport configuration (deprecated - use factory function parameters)
     */
    async runStreamableHttp(setup, options) {
        return this.run({
            type: "streamableHttp",
            streamableHttpSetup: setup,
        });
    }
    /**
     * Run with SSE transport using user-provided setup callback
     * @param setup - Callback function to integrate with user's HTTP server
     * @param options - Optional transport configuration (deprecated - use factory function parameters)
     */
    async runSSE(setup, options) {
        return this.run({
            type: "sse",
            sseSetup: setup,
        });
    }
    /**
     * Stop the server
     */
    async stop() {
        if (!this.isRunning) {
            return;
        }
        try {
            // Clean up based on transport type
            if (this.transportType === "memory" && this.memoryId) {
                MemoryTransportRegistry.getInstance().unregisterServer(this.memoryId);
            }
            if (this.currentTransport) {
                await this.currentTransport.close();
            }
            // Only close server for stdio transports (others manage their own lifecycle)
            if (this.transportType !== "memory" &&
                this.transportType !== "sse" &&
                this.transportType !== "streamableHttp") {
                await this.server.close();
            }
            this.isRunning = false;
            this.currentTransport = null;
            this.emit({
                type: "disconnected",
                clientName: this.transportType || "unknown",
            });
            if (this.config.enableLogging) {
                console.log(`[AGKitMCPServer] Server stopped (${this.transportType} transport)`);
            }
            this.transportType = null;
            this.memoryId = undefined;
        }
        catch (error) {
            this.emit({
                type: "error",
                error: error instanceof Error ? error : new Error(String(error)),
                context: "server_stop",
            });
            if (this.config.enableLogging) {
                console.error(`[AGKitMCPServer] Error stopping server:`, error);
            }
            throw error;
        }
    }
    /**
     * Check if server is running
     */
    isServerRunning() {
        return this.isRunning;
    }
    /**
     * Get current transport type
     */
    getTransportType() {
        return this.transportType;
    }
    /**
     * Get memory ID (for memory transport)
     */
    getMemoryId() {
        return this.memoryId;
    }
    /**
     * Get server connection info
     */
    getConnectionInfo() {
        return {
            isRunning: this.isRunning,
            transportType: this.transportType,
            memoryId: this.memoryId,
        };
    }
    /**
     * Add event listener
     */
    addEventListener(listener) {
        this.eventListeners.add(listener);
    }
    /**
     * Remove event listener
     */
    removeEventListener(listener) {
        return this.eventListeners.delete(listener);
    }
    /**
     * Emit event to all listeners
     */
    emit(event) {
        this.eventListeners.forEach((listener) => {
            try {
                listener(event);
            }
            catch (error) {
                console.error("[AGKitMCPServer] Error in event listener:", error);
            }
        });
    }
    /**
     * Update server configuration
     */
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
    }
    /**
     * Get current configuration
     */
    getConfig() {
        return { ...this.config };
    }
    /**
     * Clear all registered tools
     */
    clearTools() {
        this.tools.clear();
        this.toolConfigs.clear();
        if (this.config.enableLogging) {
            console.log(`[AGKitMCPServer] Cleared all tools`);
        }
    }
}
exports.AGKitMCPServer = AGKitMCPServer;
/**
 * Utility function to create and start an AG-Kit MCP server
 */
async function createAGKitMCPServer(config, tools = []) {
    const server = new AGKitMCPServer(config);
    if (tools.length > 0) {
        server.registerTools(tools);
    }
    return server;
}
/**
 * Global memory transport registry instance
 */
exports.memoryTransportRegistry = MemoryTransportRegistry.getInstance();
//# sourceMappingURL=agkit-mcp-server.js.map