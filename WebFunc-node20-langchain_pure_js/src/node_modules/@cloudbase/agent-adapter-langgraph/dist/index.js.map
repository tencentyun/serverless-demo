{"version":3,"sources":["../../../observability/dist/chunk-NFEGQTCC.mjs","../../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/src/trace/SemanticConventions.ts","../../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/src/trace/index.ts","../../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/src/resource/SemanticResourceAttributes.ts","../../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/src/resource/index.ts","../../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/src/index.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/platform/node/globalThis.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/platform/node/index.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/platform/index.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/version.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/internal/semver.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/internal/global-utils.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag/ComponentLogger.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag/types.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag/internal/logLevelLogger.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/diag.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/context/context.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/context/NoopContextManager.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/context.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/trace_flags.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/invalid-span-constants.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/NonRecordingSpan.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/context-utils.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/spancontext-utils.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/NoopTracer.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/ProxyTracer.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/NoopTracerProvider.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/ProxyTracerProvider.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/status.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/context-api.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/trace.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace-api.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/index.ts","../../../observability/src/core/constants.ts","../../../observability/src/core/attributes.ts","../../../observability/src/core/tracerProvider.ts","../../../observability/src/core/spanWrapper.ts","../../../observability/src/index.ts","../../../observability/src/langchain/CallbackHandler.ts","../src/index.ts","../src/agent.ts","../src/util.ts","../src/checkpoint.ts","../src/store/tdai-store.ts"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\nexport {\n  __esm,\n  __export,\n  __toCommonJS\n};\n//# sourceMappingURL=chunk-NFEGQTCC.mjs.map","/**\n * Semantic conventions for OpenInference tracing\n */\n\nexport const SemanticAttributePrefixes = {\n  input: \"input\",\n  output: \"output\",\n  llm: \"llm\",\n  retrieval: \"retrieval\",\n  reranker: \"reranker\",\n  messages: \"messages\",\n  message: \"message\",\n  document: \"document\",\n  embedding: \"embedding\",\n  tool: \"tool\",\n  tool_call: \"tool_call\",\n  metadata: \"metadata\",\n  tag: \"tag\",\n  session: \"session\",\n  user: \"user\",\n  openinference: \"openinference\",\n  message_content: \"message_content\",\n  image: \"image\",\n  audio: \"audio\",\n  prompt: \"prompt\",\n  agent: \"agent\",\n  graph: \"graph\",\n} as const;\n\nexport const LLMAttributePostfixes = {\n  provider: \"provider\",\n  system: \"system\",\n  model_name: \"model_name\",\n  token_count: \"token_count\",\n  input_messages: \"input_messages\",\n  output_messages: \"output_messages\",\n  invocation_parameters: \"invocation_parameters\",\n  prompts: \"prompts\",\n  prompt_template: \"prompt_template\",\n  function_call: \"function_call\",\n  tools: \"tools\",\n  cost: \"cost\",\n} as const;\n\nexport const LLMPromptTemplateAttributePostfixes = {\n  variables: \"variables\",\n  template: \"template\",\n} as const;\n\nexport const RetrievalAttributePostfixes = {\n  documents: \"documents\",\n} as const;\n\nexport const RerankerAttributePostfixes = {\n  input_documents: \"input_documents\",\n  output_documents: \"output_documents\",\n  query: \"query\",\n  model_name: \"model_name\",\n  top_k: \"top_k\",\n} as const;\n\nexport const EmbeddingAttributePostfixes = {\n  embeddings: \"embeddings\",\n  text: \"text\",\n  model_name: \"model_name\",\n  vector: \"vector\",\n} as const;\n\nexport const ToolAttributePostfixes = {\n  name: \"name\",\n  description: \"description\",\n  parameters: \"parameters\",\n  json_schema: \"json_schema\",\n} as const;\n\nexport const MessageAttributePostfixes = {\n  role: \"role\",\n  content: \"content\",\n  contents: \"contents\",\n  name: \"name\",\n  function_call_name: \"function_call_name\",\n  function_call_arguments_json: \"function_call_arguments_json\",\n  tool_calls: \"tool_calls\",\n  tool_call_id: \"tool_call_id\",\n} as const;\n\nexport const MessageContentsAttributePostfixes = {\n  type: \"type\",\n  text: \"text\",\n  image: \"image\",\n} as const;\n\nexport const ImageAttributesPostfixes = {\n  url: \"url\",\n} as const;\n\nexport const ToolCallAttributePostfixes = {\n  function_name: \"function.name\",\n  function_arguments_json: \"function.arguments\",\n  id: \"id\",\n} as const;\n\nexport const DocumentAttributePostfixes = {\n  id: \"id\",\n  content: \"content\",\n  score: \"score\",\n  metadata: \"metadata\",\n} as const;\n\nexport const TagAttributePostfixes = {\n  tags: \"tags\",\n} as const;\n\nexport const SessionAttributePostfixes = {\n  id: \"id\",\n} as const;\n\nexport const UserAttributePostfixes = {\n  id: \"id\",\n} as const;\n\nexport const AudioAttributesPostfixes = {\n  url: \"url\",\n  mime_type: \"mime_type\",\n  transcript: \"transcript\",\n} as const;\n\nexport const PromptAttributePostfixes = {\n  vendor: \"vendor\",\n  id: \"id\",\n  url: \"url\",\n} as const;\n\nexport const AgentPostfixes = {\n  name: \"name\",\n} as const;\n\nexport const GraphPostfixes = {\n  node_id: \"node.id\",\n  node_name: \"node.name\",\n  node_parent_id: \"node.parent_id\",\n} as const;\n/**\n * The input to any span\n */\nexport const INPUT_VALUE = `${SemanticAttributePrefixes.input}.value` as const;\nexport const INPUT_MIME_TYPE =\n  `${SemanticAttributePrefixes.input}.mime_type` as const;\n/**\n * The output of any span\n */\nexport const OUTPUT_VALUE =\n  `${SemanticAttributePrefixes.output}.value` as const;\nexport const OUTPUT_MIME_TYPE =\n  `${SemanticAttributePrefixes.output}.mime_type` as const;\n/**\n * The messages sent to the LLM for completions\n * Typically seen in OpenAI chat completions\n * @see https://beta.openai.com/docs/api-reference/completions/create\n */\nexport const LLM_INPUT_MESSAGES =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.input_messages}` as const;\n\n/**\n * The prompts sent to the LLM for completions\n * Typically seen in OpenAI legacy completions\n * @see https://beta.openai.com/docs/api-reference/completions/create\n */\nexport const LLM_PROMPTS =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.prompts}` as const;\n\n/**\n * The JSON representation of the parameters passed to the LLM\n */\nexport const LLM_INVOCATION_PARAMETERS =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.invocation_parameters}` as const;\n\n/**\n * The messages received from the LLM for completions\n * Typically seen in OpenAI chat completions\n * @see https://platform.openai.com/docs/api-reference/chat/object#choices-message\n */\nexport const LLM_OUTPUT_MESSAGES =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.output_messages}` as const;\n\n/**\n * The name of the LLM model\n */\nexport const LLM_MODEL_NAME =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.model_name}` as const;\n\n/**\n * The provider of the inferences. E.g. the cloud provider\n */\nexport const LLM_PROVIDER =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.provider}` as const;\n\n/**\n * The AI product as identified by the client or server\n */\nexport const LLM_SYSTEM =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.system}` as const;\n\n/** Token count for the completion by the llm (in tokens) */\nexport const LLM_TOKEN_COUNT_COMPLETION =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion` as const;\n\n/** Token count for the reasoning steps in the completion (in tokens) */\nexport const LLM_TOKEN_COUNT_COMPLETION_DETAILS_REASONING =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion_details.reasoning` as const;\n\n/** Token count for audio input generated by the model (in tokens) */\nexport const LLM_TOKEN_COUNT_COMPLETION_DETAILS_AUDIO =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion_details.audio` as const;\n\n/** Token count for the prompt to the llm (in tokens) */\nexport const LLM_TOKEN_COUNT_PROMPT =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt` as const;\n\n/** Token count for the tokens written to cache (in tokens) */\nexport const LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_WRITE =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.cache_write` as const;\n\n/** Token count for the tokens retrieved from cache (in tokens) */\nexport const LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_READ =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.cache_read` as const;\n\n/** Token count for the input tokens in the prompt that were cached (in tokens) */\nexport const LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_INPUT =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.cache_input` as const;\n\n/** Token count for audio input presented in the prompt (in tokens) */\nexport const LLM_TOKEN_COUNT_PROMPT_DETAILS_AUDIO =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.audio` as const;\n\n/** Token count for the entire transaction with the llm (in tokens) */\nexport const LLM_TOKEN_COUNT_TOTAL =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.total` as const;\n\n/**\n * Key prefix for additional prompt token count details. Each detail should be a separate attribute\n * with this prefix, e.g. llm.token_count.prompt_details.reasoning, llm.token_count.prompt_details.audio.\n * All values should be in tokens (integer count of tokens).\n */\nexport const LLM_TOKEN_COUNT_PROMPT_DETAILS =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details` as const;\n\n/**\n * Key prefix for additional completion token count details. Each detail should be a separate attribute\n * with this prefix, e.g. llm.token_count.completion_details.reasoning, llm.token_count.completion_details.audio.\n * All values should be in tokens (integer count of tokens).\n */\nexport const LLM_TOKEN_COUNT_COMPLETION_DETAILS =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion_details` as const;\n\n/**\n * Key prefix for cost information. When these keys are transformed into a JSON-like structure, it would look like:\n * {\n *     \"prompt\": 0.0021,  # Cost in USD\n *     \"completion\": 0.0045,  # Cost in USD\n *     \"total\": 0.0066,  # Cost in USD\n *     \"completion_details\": {\n *         \"output\": 0.0009,  # Cost in USD\n *         \"reasoning\": 0.0024,    # Cost in USD (e.g., 80 tokens * $0.03/1K tokens)\n *         \"audio\": 0.0012  # Cost in USD (e.g., 40 tokens * $0.03/1K tokens)\n *     },\n *     \"prompt_details\": {\n *         \"input\": 0.0003,  # Cost in USD\n *         \"cache_write\": 0.0006,  # Cost in USD (e.g., 20 tokens * $0.03/1K tokens)\n *         \"cache_read\": 0.0003,   # Cost in USD (e.g., 10 tokens * $0.03/1K tokens)\n *         \"cache_input\": 0.0006,  # Cost in USD (e.g., 20 tokens * $0.03/1K tokens)\n *         \"audio\": 0.0003   # Cost in USD (e.g., 10 tokens * $0.03/1K tokens)\n *     }\n * }\n * Note: This is a key prefix - individual attributes are stored as separate span attributes with this prefix,\n * e.g. llm.cost.prompt, llm.cost.completion_details.reasoning, etc. The JSON structure shown above represents\n * how these separate attributes can be conceptually organized.\n * All monetary values are in USD with floating point precision.\n */\nexport const LLM_COST =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}` as const;\n\n/** Cost of the prompt tokens in USD */\nexport const LLM_COST_PROMPT =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt` as const;\n\n/** Cost of the completion tokens in USD */\nexport const LLM_COST_COMPLETION =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion` as const;\n\n/** Total cost of the LLM call in USD (prompt + completion) */\nexport const LLM_COST_TOTAL =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.total` as const;\n\n/** Total cost of input tokens in USD. This represents the cost of tokens that were used as input\n * to the model, which may be different from the prompt cost if there are additional processing steps. */\nexport const LLM_COST_INPUT =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.input` as const;\n\n/** Total cost of output tokens in USD. This represents the cost of tokens that were generated as output\n * by the model, which may be different from the completion cost if there are additional processing steps. */\nexport const LLM_COST_OUTPUT =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion_details.output` as const;\n\n/** Cost of reasoning steps in the completion in USD */\nexport const LLM_COST_COMPLETION_DETAILS_REASONING =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion_details.reasoning` as const;\n\n/** Cost of audio tokens in the completion in USD */\nexport const LLM_COST_COMPLETION_DETAILS_AUDIO =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion_details.audio` as const;\n\n/** Cost of prompt tokens written to cache in USD */\nexport const LLM_COST_PROMPT_DETAILS_CACHE_WRITE =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.cache_write` as const;\n\n/** Cost of prompt tokens read from cache in USD */\nexport const LLM_COST_PROMPT_DETAILS_CACHE_READ =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.cache_read` as const;\n\n/** Cost of input tokens in the prompt that were cached in USD */\nexport const LLM_COST_PROMPT_DETAILS_CACHE_INPUT =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.cache_input` as const;\n\n/** Cost of audio tokens in the prompt in USD */\nexport const LLM_COST_PROMPT_DETAILS_AUDIO =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.audio` as const;\n\n/**\n * The role that the LLM assumes the message is from\n * during the LLM invocation\n */\nexport const MESSAGE_ROLE =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.role}` as const;\n\n/**\n * The name of the message. This is only used for role 'function' where the name\n * of the function is captured in the name field and the parameters are captured in the\n * content.\n */\nexport const MESSAGE_NAME =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.name}` as const;\n\n/**\n * The tool calls generated by the model, such as function calls.\n */\nexport const MESSAGE_TOOL_CALLS =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.tool_calls}` as const;\n\n/**\n * The id of the tool call on a \"tool\" role message\n */\nexport const MESSAGE_TOOL_CALL_ID =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.tool_call_id}` as const;\n\n/**\n * tool_call.function.name\n */\nexport const TOOL_CALL_FUNCTION_NAME =\n  `${SemanticAttributePrefixes.tool_call}.${ToolCallAttributePostfixes.function_name}` as const;\n\n/**\n * tool_call.function.argument (JSON string)\n */\nexport const TOOL_CALL_FUNCTION_ARGUMENTS_JSON =\n  `${SemanticAttributePrefixes.tool_call}.${ToolCallAttributePostfixes.function_arguments_json}` as const;\n\n/**\n * The id of the tool call\n */\nexport const TOOL_CALL_ID =\n  `${SemanticAttributePrefixes.tool_call}.${ToolCallAttributePostfixes.id}` as const;\n\n/**\n * The LLM function call function name\n */\nexport const MESSAGE_FUNCTION_CALL_NAME =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.function_call_name}` as const;\n\n/**\n * The LLM function call function arguments in a json string\n */\nexport const MESSAGE_FUNCTION_CALL_ARGUMENTS_JSON =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.function_call_arguments_json}` as const;\n/**\n * The content of the message sent to the LLM\n */\nexport const MESSAGE_CONTENT =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.content}` as const;\n/**\n * The array of contents for the message sent to the LLM. Each element of the array is\n * an `message_content` object.\n */\nexport const MESSAGE_CONTENTS =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.contents}` as const;\n/**\n * The type of content sent to the LLM\n */\nexport const MESSAGE_CONTENT_TYPE =\n  `${SemanticAttributePrefixes.message_content}.${MessageContentsAttributePostfixes.type}` as const;\n/**\n * The text content of the message sent to the LLM\n */\nexport const MESSAGE_CONTENT_TEXT =\n  `${SemanticAttributePrefixes.message_content}.${MessageContentsAttributePostfixes.text}` as const;\n/**\n * The image content of the message sent to the LLM\n */\nexport const MESSAGE_CONTENT_IMAGE =\n  `${SemanticAttributePrefixes.message_content}.${MessageContentsAttributePostfixes.image}` as const;\n/**\n * The http or base64 link to the image\n */\nexport const IMAGE_URL =\n  `${SemanticAttributePrefixes.image}.${ImageAttributesPostfixes.url}` as const;\n\nexport const DOCUMENT_ID =\n  `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.id}` as const;\n\nexport const DOCUMENT_CONTENT =\n  `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.content}` as const;\n\nexport const DOCUMENT_SCORE =\n  `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.score}` as const;\n\nexport const DOCUMENT_METADATA =\n  `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.metadata}` as const;\n\n/**\n * The text that was embedded to create the vector\n */\nexport const EMBEDDING_TEXT =\n  `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.text}` as const;\n\n/**\n * The name of the model that was used to create the vector\n */\nexport const EMBEDDING_MODEL_NAME =\n  `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.model_name}` as const;\n\n/**\n * The embedding vector. Typically a high dimensional vector of floats or ints\n */\nexport const EMBEDDING_VECTOR =\n  `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.vector}` as const;\n\n/**\n * The embedding list root\n */\nexport const EMBEDDING_EMBEDDINGS =\n  `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.embeddings}` as const;\n\n/**\n * The retrieval documents list root\n */\nexport const RETRIEVAL_DOCUMENTS =\n  `${SemanticAttributePrefixes.retrieval}.${RetrievalAttributePostfixes.documents}` as const;\n\nconst PROMPT_TEMPLATE_PREFIX =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.prompt_template}` as const;\n\n/**\n * The JSON representation of the variables used in the prompt template\n */\nexport const PROMPT_TEMPLATE_VARIABLES =\n  `${PROMPT_TEMPLATE_PREFIX}.variables` as const;\n\n/**\n * A prompt template\n */\nexport const PROMPT_TEMPLATE_TEMPLATE =\n  `${PROMPT_TEMPLATE_PREFIX}.template` as const;\n\n/**\n * The JSON representation of a function call of an LLM\n */\nexport const LLM_FUNCTION_CALL =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.function_call}` as const;\n\n/**\n * List of tools that are advertised to the LLM to be able to call\n */\nexport const LLM_TOOLS =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.tools}` as const;\n\n/**\n * The name of a tool\n */\nexport const TOOL_NAME =\n  `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.name}` as const;\n\n/**\n * The description of a tool\n */\nexport const TOOL_DESCRIPTION =\n  `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.description}` as const;\n\n/**\n * The parameters of the tool represented as a JSON string\n */\nexport const TOOL_PARAMETERS =\n  `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.parameters}` as const;\n\n/**\n * The json schema of a tool input, It is RECOMMENDED that this be in the\n * OpenAI tool calling format: https://platform.openai.com/docs/assistants/tools\n */\nexport const TOOL_JSON_SCHEMA =\n  `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.json_schema}` as const;\n\n/**\n * The session id of a trace. Used to correlate spans in a single session.\n */\nexport const SESSION_ID =\n  `${SemanticAttributePrefixes.session}.${SessionAttributePostfixes.id}` as const;\n\n/**\n * The user id of a trace. Used to correlate spans for a single user.\n */\nexport const USER_ID =\n  `${SemanticAttributePrefixes.user}.${UserAttributePostfixes.id}` as const;\n\n/**\n * The documents used as input to the reranker\n */\nexport const RERANKER_INPUT_DOCUMENTS =\n  `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.input_documents}` as const;\n\n/**\n * The documents output by the reranker\n */\nexport const RERANKER_OUTPUT_DOCUMENTS =\n  `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.output_documents}` as const;\n\n/**\n * The query string for the reranker\n */\nexport const RERANKER_QUERY =\n  `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.query}` as const;\n\n/**\n * The model name for the reranker\n */\nexport const RERANKER_MODEL_NAME =\n  `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.model_name}` as const;\n\n/**\n * The top k parameter for the reranker\n */\nexport const RERANKER_TOP_K =\n  `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.top_k}` as const;\n\n/**\n * Metadata for a span, used to store user-defined key-value pairs\n */\nexport const METADATA = \"metadata\" as const;\n\n/**\n * A prompt template version\n */\nexport const PROMPT_TEMPLATE_VERSION =\n  `${PROMPT_TEMPLATE_PREFIX}.version` as const;\n\n/**\n * The tags associated with a span\n */\nexport const TAG_TAGS =\n  `${SemanticAttributePrefixes.tag}.${TagAttributePostfixes.tags}` as const;\n\n/**\n * The url of an audio file\n */\nexport const AUDIO_URL =\n  `${SemanticAttributePrefixes.audio}.${AudioAttributesPostfixes.url}` as const;\n\n/**\n * The audio mime type\n */\nexport const AUDIO_MIME_TYPE =\n  `${SemanticAttributePrefixes.audio}.${AudioAttributesPostfixes.mime_type}` as const;\n\n/**\n * The audio transcript as text\n */\nexport const AUDIO_TRANSCRIPT =\n  `${SemanticAttributePrefixes.audio}.${AudioAttributesPostfixes.transcript}` as const;\n/**\n * The vendor or origin of the prompt, e.g. a prompt library, a specialized service, etc.\n */\nexport const PROMPT_VENDOR =\n  `${SemanticAttributePrefixes.prompt}.${PromptAttributePostfixes.vendor}` as const;\n\n/**\n * A vendor-specific id used to locate the prompt\n */\nexport const PROMPT_ID =\n  `${SemanticAttributePrefixes.prompt}.${PromptAttributePostfixes.id}` as const;\n\n/**\n * A vendor-specific URL used to locate the prompt\n */\nexport const PROMPT_URL =\n  `${SemanticAttributePrefixes.prompt}.${PromptAttributePostfixes.url}` as const;\n\n/**\n * The name of the agent. Agents that perform the same functions should have the same name.\n */\nexport const AGENT_NAME =\n  `${SemanticAttributePrefixes.agent}.${AgentPostfixes.name}` as const;\n\n/**\n * The id of the node in the execution graph. This along with graph.node.parent_id are used to visualize the execution graph.\n */\nexport const GRAPH_NODE_ID =\n  `${SemanticAttributePrefixes.graph}.${GraphPostfixes.node_id}` as const;\n\n/**\n * The name of the node in the execution graph. Use this to present a human readable name for the node. Optional\n */\n\nexport const GRAPH_NODE_NAME =\n  `${SemanticAttributePrefixes.graph}.${GraphPostfixes.node_name}` as const;\n\n/**\n * This references the id of the parent node. Leaving this unset or set as empty string implies that the current span is the root node.\n */\nexport const GRAPH_NODE_PARENT_ID =\n  `${SemanticAttributePrefixes.graph}.${GraphPostfixes.node_parent_id}` as const;\n\nexport const SemanticConventions = {\n  IMAGE_URL,\n  INPUT_VALUE,\n  INPUT_MIME_TYPE,\n  OUTPUT_VALUE,\n  OUTPUT_MIME_TYPE,\n  LLM_INPUT_MESSAGES,\n  LLM_OUTPUT_MESSAGES,\n  LLM_MODEL_NAME,\n  LLM_PROMPTS,\n  LLM_INVOCATION_PARAMETERS,\n  LLM_TOKEN_COUNT_COMPLETION,\n  LLM_TOKEN_COUNT_COMPLETION_DETAILS,\n  LLM_TOKEN_COUNT_COMPLETION_DETAILS_REASONING,\n  LLM_TOKEN_COUNT_COMPLETION_DETAILS_AUDIO,\n  LLM_TOKEN_COUNT_PROMPT,\n  LLM_TOKEN_COUNT_PROMPT_DETAILS,\n  LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_WRITE,\n  LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_READ,\n  LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_INPUT,\n  LLM_TOKEN_COUNT_PROMPT_DETAILS_AUDIO,\n  LLM_TOKEN_COUNT_TOTAL,\n  LLM_SYSTEM,\n  LLM_PROVIDER,\n  LLM_TOOLS,\n  LLM_COST,\n  LLM_COST_PROMPT,\n  LLM_COST_COMPLETION,\n  LLM_COST_TOTAL,\n  LLM_COST_INPUT,\n  LLM_COST_OUTPUT,\n  LLM_COST_COMPLETION_DETAILS_REASONING,\n  LLM_COST_COMPLETION_DETAILS_AUDIO,\n  LLM_COST_PROMPT_DETAILS_CACHE_WRITE,\n  LLM_COST_PROMPT_DETAILS_CACHE_READ,\n  LLM_COST_PROMPT_DETAILS_CACHE_INPUT,\n  LLM_COST_PROMPT_DETAILS_AUDIO,\n  MESSAGE_ROLE,\n  MESSAGE_NAME,\n  MESSAGE_TOOL_CALLS,\n  MESSAGE_TOOL_CALL_ID,\n  TOOL_CALL_ID,\n  TOOL_CALL_FUNCTION_NAME,\n  TOOL_CALL_FUNCTION_ARGUMENTS_JSON,\n  MESSAGE_FUNCTION_CALL_NAME,\n  MESSAGE_FUNCTION_CALL_ARGUMENTS_JSON,\n  MESSAGE_CONTENT,\n  MESSAGE_CONTENTS,\n  MESSAGE_CONTENT_IMAGE,\n  MESSAGE_CONTENT_TEXT,\n  MESSAGE_CONTENT_TYPE,\n  DOCUMENT_ID,\n  DOCUMENT_CONTENT,\n  DOCUMENT_SCORE,\n  DOCUMENT_METADATA,\n  EMBEDDING_EMBEDDINGS,\n  EMBEDDING_TEXT,\n  EMBEDDING_MODEL_NAME,\n  EMBEDDING_VECTOR,\n  TOOL_DESCRIPTION,\n  TOOL_NAME,\n  TOOL_PARAMETERS,\n  TOOL_JSON_SCHEMA,\n  PROMPT_TEMPLATE_VARIABLES,\n  PROMPT_TEMPLATE_TEMPLATE,\n  PROMPT_TEMPLATE_VERSION,\n  RERANKER_INPUT_DOCUMENTS,\n  RERANKER_OUTPUT_DOCUMENTS,\n  RERANKER_QUERY,\n  RERANKER_MODEL_NAME,\n  RERANKER_TOP_K,\n  LLM_FUNCTION_CALL,\n  RETRIEVAL_DOCUMENTS,\n  SESSION_ID,\n  USER_ID,\n  METADATA,\n  TAG_TAGS,\n  OPENINFERENCE_SPAN_KIND: `${SemanticAttributePrefixes.openinference}.span.kind`,\n  PROMPT_VENDOR,\n  PROMPT_ID,\n  PROMPT_URL,\n  AGENT_NAME,\n  GRAPH_NODE_ID,\n  GRAPH_NODE_NAME,\n  GRAPH_NODE_PARENT_ID,\n} as const;\n\nexport enum OpenInferenceSpanKind {\n  LLM = \"LLM\",\n  CHAIN = \"CHAIN\",\n  TOOL = \"TOOL\",\n  RETRIEVER = \"RETRIEVER\",\n  RERANKER = \"RERANKER\",\n  EMBEDDING = \"EMBEDDING\",\n  AGENT = \"AGENT\",\n  GUARDRAIL = \"GUARDRAIL\",\n  EVALUATOR = \"EVALUATOR\",\n}\n\n/**\n * An enum of common mime types. Not exhaustive.\n */\nexport enum MimeType {\n  TEXT = \"text/plain\",\n  JSON = \"application/json\",\n  AUDIO_WAV = \"audio/wav\",\n}\n\nexport enum LLMSystem {\n  OPENAI = \"openai\",\n  ANTHROPIC = \"anthropic\",\n  MISTRALAI = \"mistralai\",\n  COHERE = \"cohere\",\n  VERTEXAI = \"vertexai\",\n  AI21 = \"ai21\",\n  META = \"meta\",\n  AMAZON = \"amazon\",\n}\n\nexport enum LLMProvider {\n  OPENAI = \"openai\",\n  ANTHROPIC = \"anthropic\",\n  MISTRALAI = \"mistralai\",\n  COHERE = \"cohere\",\n  // Cloud Providers of LLM systems\n  GOOGLE = \"google\",\n  AWS = \"aws\",\n  AZURE = \"azure\",\n  XAI = \"xai\",\n  DEEPSEEK = \"deepseek\",\n}\n","export * from \"./SemanticConventions\";\n","const PROJECT_NAME = \"openinference.project.name\";\n\n/**\n * The project name to group traces under for openinference compatible services\n */\nexport const SEMRESATTRS_PROJECT_NAME = PROJECT_NAME;\n","export * from \"./SemanticResourceAttributes\";\n","export * from \"./trace\";\nexport * from \"./resource\";\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** only globals that common to node and browsers are allowed */\n// eslint-disable-next-line node/no-unsupported-features/es-builtins\nexport const _globalThis = typeof globalThis === 'object' ? globalThis : global;\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport * from './globalThis';\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport * from './node';\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '1.9.0';\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VERSION } from '../version';\n\nconst re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\n\n/**\n * Create a function to test an API version to see if it is compatible with the provided ownVersion.\n *\n * The returned function has the following semantics:\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param ownVersion version which should be checked against\n */\nexport function _makeCompatibilityCheck(\n  ownVersion: string\n): (globalVersion: string) => boolean {\n  const acceptedVersions = new Set<string>([ownVersion]);\n  const rejectedVersions = new Set<string>();\n\n  const myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    // we cannot guarantee compatibility so we always return noop\n    return () => false;\n  }\n\n  const ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4],\n  };\n\n  // if ownVersion has a prerelease tag, versions must match exactly\n  if (ownVersionParsed.prerelease != null) {\n    return function isExactmatch(globalVersion: string): boolean {\n      return globalVersion === ownVersion;\n    };\n  }\n\n  function _reject(v: string) {\n    rejectedVersions.add(v);\n    return false;\n  }\n\n  function _accept(v: string) {\n    acceptedVersions.add(v);\n    return true;\n  }\n\n  return function isCompatible(globalVersion: string): boolean {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n\n    const globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      // cannot parse other version\n      // we cannot guarantee compatibility so we always noop\n      return _reject(globalVersion);\n    }\n\n    const globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4],\n    };\n\n    // if globalVersion has a prerelease tag, versions must match exactly\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n\n    // major versions must match\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.major === 0) {\n      if (\n        ownVersionParsed.minor === globalVersionParsed.minor &&\n        ownVersionParsed.patch <= globalVersionParsed.patch\n      ) {\n        return _accept(globalVersion);\n      }\n\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n\n    return _reject(globalVersion);\n  };\n}\n\n/**\n * Test an API version to see if it is compatible with this API.\n *\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param version version of the API requesting an instance of the global API\n */\nexport const isCompatible = _makeCompatibilityCheck(VERSION);\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { ContextManager } from '../context/types';\nimport { DiagLogger } from '../diag/types';\nimport { _globalThis } from '../platform';\nimport { TextMapPropagator } from '../propagation/TextMapPropagator';\nimport type { TracerProvider } from '../trace/tracer_provider';\nimport { VERSION } from '../version';\nimport { isCompatible } from './semver';\n\nconst major = VERSION.split('.')[0];\nconst GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\n  `opentelemetry.js.api.${major}`\n);\n\nconst _global = _globalThis as OTelGlobal;\n\nexport function registerGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type,\n  instance: OTelGlobalAPI[Type],\n  diag: DiagLogger,\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = _global[\n    GLOBAL_OPENTELEMETRY_API_KEY\n  ] ?? {\n    version: VERSION,\n  });\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(\n      `@opentelemetry/api: Attempted duplicate registration of API: ${type}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  if (api.version !== VERSION) {\n    // All registered APIs must be of the same version exactly\n    const err = new Error(\n      `@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${VERSION}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  api[type] = instance;\n  diag.debug(\n    `@opentelemetry/api: Registered a global for ${type} v${VERSION}.`\n  );\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type\n): OTelGlobalAPI[Type] | undefined {\n  const globalVersion = _global[GLOBAL_OPENTELEMETRY_API_KEY]?.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return _global[GLOBAL_OPENTELEMETRY_API_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof OTelGlobalAPI, diag: DiagLogger) {\n  diag.debug(\n    `@opentelemetry/api: Unregistering a global for ${type} v${VERSION}.`\n  );\n  const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype OTelGlobal = {\n  [GLOBAL_OPENTELEMETRY_API_KEY]?: OTelGlobalAPI;\n};\n\ntype OTelGlobalAPI = {\n  version: string;\n\n  diag?: DiagLogger;\n  trace?: TracerProvider;\n  context?: ContextManager;\n  metrics?: MeterProvider;\n  propagation?: TextMapPropagator;\n};\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getGlobal } from '../internal/global-utils';\nimport { ComponentLoggerOptions, DiagLogger, DiagLogFunction } from './types';\n\n/**\n * Component Logger which is meant to be used as part of any component which\n * will add automatically additional namespace in front of the log message.\n * It will then forward all message to global diag logger\n * @example\n * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });\n * cLogger.debug('test');\n * // @opentelemetry/instrumentation-http test\n */\nexport class DiagComponentLogger implements DiagLogger {\n  private _namespace: string;\n\n  constructor(props: ComponentLoggerOptions) {\n    this._namespace = props.namespace || 'DiagComponentLogger';\n  }\n\n  public debug(...args: any[]): void {\n    return logProxy('debug', this._namespace, args);\n  }\n\n  public error(...args: any[]): void {\n    return logProxy('error', this._namespace, args);\n  }\n\n  public info(...args: any[]): void {\n    return logProxy('info', this._namespace, args);\n  }\n\n  public warn(...args: any[]): void {\n    return logProxy('warn', this._namespace, args);\n  }\n\n  public verbose(...args: any[]): void {\n    return logProxy('verbose', this._namespace, args);\n  }\n}\n\nfunction logProxy(\n  funcName: keyof DiagLogger,\n  namespace: string,\n  args: any\n): void {\n  const logger = getGlobal('diag');\n  // shortcut if logger not set\n  if (!logger) {\n    return;\n  }\n\n  args.unshift(namespace);\n  return logger[funcName](...(args as Parameters<DiagLogFunction>));\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type DiagLogFunction = (message: string, ...args: unknown[]) => void;\n\n/**\n * Defines an internal diagnostic logger interface which is used to log internal diagnostic\n * messages, you can set the default diagnostic logger via the {@link DiagAPI} setLogger function.\n * API provided implementations include :-\n * - a No-Op {@link createNoopDiagLogger}\n * - a {@link DiagLogLevel} filtering wrapper {@link createLogLevelDiagLogger}\n * - a general Console {@link DiagConsoleLogger} version.\n */\nexport interface DiagLogger {\n  /** Log an error scenario that was not expected and caused the requested operation to fail. */\n  error: DiagLogFunction;\n\n  /**\n   * Log a warning scenario to inform the developer of an issues that should be investigated.\n   * The requested operation may or may not have succeeded or completed.\n   */\n  warn: DiagLogFunction;\n\n  /**\n   * Log a general informational message, this should not affect functionality.\n   * This is also the default logging level so this should NOT be used for logging\n   * debugging level information.\n   */\n  info: DiagLogFunction;\n\n  /**\n   * Log a general debug message that can be useful for identifying a failure.\n   * Information logged at this level may include diagnostic details that would\n   * help identify a failure scenario.\n   * For example: Logging the order of execution of async operations.\n   */\n  debug: DiagLogFunction;\n\n  /**\n   * Log a detailed (verbose) trace level logging that can be used to identify failures\n   * where debug level logging would be insufficient, this level of tracing can include\n   * input and output parameters and as such may include PII information passing through\n   * the API. As such it is recommended that this level of tracing should not be enabled\n   * in a production environment.\n   */\n  verbose: DiagLogFunction;\n}\n\n/**\n * Defines the available internal logging levels for the diagnostic logger, the numeric values\n * of the levels are defined to match the original values from the initial LogLevel to avoid\n * compatibility/migration issues for any implementation that assume the numeric ordering.\n */\nexport enum DiagLogLevel {\n  /** Diagnostic Logging level setting to disable all logging (except and forced logs) */\n  NONE = 0,\n\n  /** Identifies an error scenario */\n  ERROR = 30,\n\n  /** Identifies a warning scenario */\n  WARN = 50,\n\n  /** General informational log message */\n  INFO = 60,\n\n  /** General debug log message */\n  DEBUG = 70,\n\n  /**\n   * Detailed trace level logging should only be used for development, should only be set\n   * in a development environment.\n   */\n  VERBOSE = 80,\n\n  /** Used to set the logging level to include all logging */\n  ALL = 9999,\n}\n\n/**\n * Defines options for ComponentLogger\n */\nexport interface ComponentLoggerOptions {\n  namespace: string;\n}\n\nexport interface DiagLoggerOptions {\n  /**\n   * The {@link DiagLogLevel} used to filter logs sent to the logger.\n   *\n   * @defaultValue DiagLogLevel.INFO\n   */\n  logLevel?: DiagLogLevel;\n\n  /**\n   * Setting this value to `true` will suppress the warning message normally emitted when registering a logger when another logger is already registered.\n   */\n  suppressOverrideMessage?: boolean;\n}\n\nexport interface DiagLoggerApi {\n  /**\n   * Set the global DiagLogger and DiagLogLevel.\n   * If a global diag logger is already set, this will override it.\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param options - A {@link DiagLoggerOptions} object. If not provided, default values will be set.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, options?: DiagLoggerOptions): boolean;\n\n  /**\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param logLevel - The {@link DiagLogLevel} used to filter logs sent to the logger. If not provided it will default to {@link DiagLogLevel.INFO}.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, logLevel?: DiagLogLevel): boolean;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagLogFunction, DiagLogger, DiagLogLevel } from '../types';\n\nexport function createLogLevelDiagLogger(\n  maxLevel: DiagLogLevel,\n  logger: DiagLogger\n): DiagLogger {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n\n  // In case the logger is null or undefined\n  logger = logger || {};\n\n  function _filterFunc(\n    funcName: keyof DiagLogger,\n    theLevel: DiagLogLevel\n  ): DiagLogFunction {\n    const theFunc = logger[funcName];\n\n    if (typeof theFunc === 'function' && maxLevel >= theLevel) {\n      return theFunc.bind(logger);\n    }\n    return function () {};\n  }\n\n  return {\n    error: _filterFunc('error', DiagLogLevel.ERROR),\n    warn: _filterFunc('warn', DiagLogLevel.WARN),\n    info: _filterFunc('info', DiagLogLevel.INFO),\n    debug: _filterFunc('debug', DiagLogLevel.DEBUG),\n    verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport {\n  ComponentLoggerOptions,\n  DiagLogFunction,\n  DiagLogger,\n  DiagLoggerApi,\n  DiagLogLevel,\n} from '../diag/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\n\nconst API_NAME = 'diag';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\nexport class DiagAPI implements DiagLogger, DiagLoggerApi {\n  private static _instance?: DiagAPI;\n\n  /** Get the singleton instance of the DiagAPI API */\n  public static instance(): DiagAPI {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Private internal constructor\n   * @private\n   */\n  private constructor() {\n    function _logProxy(funcName: keyof DiagLogger): DiagLogFunction {\n      return function (...args) {\n        const logger = getGlobal('diag');\n        // shortcut if logger not set\n        if (!logger) return;\n        return logger[funcName](...args);\n      };\n    }\n\n    // Using self local variable for minification purposes as 'this' cannot be minified\n    const self = this;\n\n    // DiagAPI specific functions\n\n    const setLogger: DiagLoggerApi['setLogger'] = (\n      logger,\n      optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }\n    ) => {\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        const err = new Error(\n          'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'\n        );\n        self.error(err.stack ?? err.message);\n        return false;\n      }\n\n      if (typeof optionsOrLogLevel === 'number') {\n        optionsOrLogLevel = {\n          logLevel: optionsOrLogLevel,\n        };\n      }\n\n      const oldLogger = getGlobal('diag');\n      const newLogger = createLogLevelDiagLogger(\n        optionsOrLogLevel.logLevel ?? DiagLogLevel.INFO,\n        logger\n      );\n      // There already is an logger registered. We'll let it know before overwriting it.\n      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n        const stack = new Error().stack ?? '<failed to generate stacktrace>';\n        oldLogger.warn(`Current logger will be overwritten from ${stack}`);\n        newLogger.warn(\n          `Current logger will overwrite one already registered from ${stack}`\n        );\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.setLogger = setLogger;\n\n    self.disable = () => {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = (options: ComponentLoggerOptions) => {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n\n  public setLogger!: DiagLoggerApi['setLogger'];\n  /**\n   *\n   */\n  public createComponentLogger!: (\n    options: ComponentLoggerOptions\n  ) => DiagLogger;\n\n  // DiagLogger implementation\n  public verbose!: DiagLogFunction;\n  public debug!: DiagLogFunction;\n  public info!: DiagLogFunction;\n  public warn!: DiagLogFunction;\n  public error!: DiagLogFunction;\n\n  /**\n   * Unregister the global logger and return to Noop\n   */\n  public disable!: () => void;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from './types';\n\n/** Get a key to uniquely identify a context value */\nexport function createContextKey(description: string) {\n  // The specification states that for the same input, multiple calls should\n  // return different keys. Due to the nature of the JS dependency management\n  // system, this creates problems where multiple versions of some package\n  // could hold different keys for the same property.\n  //\n  // Therefore, we use Symbol.for which returns the same key for the same input.\n  return Symbol.for(description);\n}\n\nclass BaseContext implements Context {\n  private _currentContext!: Map<symbol, unknown>;\n\n  /**\n   * Construct a new context which inherits values from an optional parent context.\n   *\n   * @param parentContext a context from which to inherit values\n   */\n  constructor(parentContext?: Map<symbol, unknown>) {\n    // for minification\n    const self = this;\n\n    self._currentContext = parentContext ? new Map(parentContext) : new Map();\n\n    self.getValue = (key: symbol) => self._currentContext.get(key);\n\n    self.setValue = (key: symbol, value: unknown): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.set(key, value);\n      return context;\n    };\n\n    self.deleteValue = (key: symbol): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.delete(key);\n      return context;\n    };\n  }\n\n  /**\n   * Get a value from the context.\n   *\n   * @param key key which identifies a context value\n   */\n  public getValue!: (key: symbol) => unknown;\n\n  /**\n   * Create a new context which inherits from this context and has\n   * the given key set to the given value.\n   *\n   * @param key context key for which to set the value\n   * @param value value to set for the given key\n   */\n  public setValue!: (key: symbol, value: unknown) => Context;\n\n  /**\n   * Return a new context which inherits from this context but does\n   * not contain a value for the given key.\n   *\n   * @param key context key for which to clear a value\n   */\n  public deleteValue!: (key: symbol) => Context;\n}\n\n/** The root context is used as the default parent context when there is no active context */\nexport const ROOT_CONTEXT: Context = new BaseContext();\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ROOT_CONTEXT } from './context';\nimport * as types from './types';\n\nexport class NoopContextManager implements types.ContextManager {\n  active(): types.Context {\n    return ROOT_CONTEXT;\n  }\n\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    _context: types.Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return fn.call(thisArg, ...args);\n  }\n\n  bind<T>(_context: types.Context, target: T): T {\n    return target;\n  }\n\n  enable(): this {\n    return this;\n  }\n\n  disable(): this {\n    return this;\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopContextManager } from '../context/NoopContextManager';\nimport { Context, ContextManager } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'context';\nconst NOOP_CONTEXT_MANAGER = new NoopContextManager();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Context API\n */\nexport class ContextAPI {\n  private static _instance?: ContextAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Context API */\n  public static getInstance(): ContextAPI {\n    if (!this._instance) {\n      this._instance = new ContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current context manager.\n   *\n   * @returns true if the context manager was successfully registered, else false\n   */\n  public setGlobalContextManager(contextManager: ContextManager): boolean {\n    return registerGlobal(API_NAME, contextManager, DiagAPI.instance());\n  }\n\n  /**\n   * Get the currently active context\n   */\n  public active(): Context {\n    return this._getContextManager().active();\n  }\n\n  /**\n   * Execute a function with an active context\n   *\n   * @param context context to be active during function execution\n   * @param fn function to execute in a context\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  public with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return this._getContextManager().with(context, fn, thisArg, ...args);\n  }\n\n  /**\n   * Bind a context to a target function or event emitter\n   *\n   * @param context context to bind to the event emitter or function. Defaults to the currently active context\n   * @param target function or event emitter to bind\n   */\n  public bind<T>(context: Context, target: T): T {\n    return this._getContextManager().bind(context, target);\n  }\n\n  private _getContextManager(): ContextManager {\n    return getGlobal(API_NAME) || NOOP_CONTEXT_MANAGER;\n  }\n\n  /** Disable and remove the global context manager */\n  public disable() {\n    this._getContextManager().disable();\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum TraceFlags {\n  /** Represents no flag set. */\n  NONE = 0x0,\n  /** Bit to represent whether trace is sampled in trace flags. */\n  SAMPLED = 0x1 << 0,\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanContext } from './span_context';\nimport { TraceFlags } from './trace_flags';\n\nexport const INVALID_SPANID = '0000000000000000';\nexport const INVALID_TRACEID = '00000000000000000000000000000000';\nexport const INVALID_SPAN_CONTEXT: SpanContext = {\n  traceId: INVALID_TRACEID,\n  spanId: INVALID_SPANID,\n  traceFlags: TraceFlags.NONE,\n};\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Exception } from '../common/Exception';\nimport { TimeInput } from '../common/Time';\nimport { SpanAttributes } from './attributes';\nimport { INVALID_SPAN_CONTEXT } from './invalid-span-constants';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { SpanStatus } from './status';\nimport { Link } from './link';\n\n/**\n * The NonRecordingSpan is the default {@link Span} that is used when no Span\n * implementation is available. All operations are no-op including context\n * propagation.\n */\nexport class NonRecordingSpan implements Span {\n  constructor(\n    private readonly _spanContext: SpanContext = INVALID_SPAN_CONTEXT\n  ) {}\n\n  // Returns a SpanContext.\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  // By default does nothing\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  // By default does nothing\n  setAttributes(_attributes: SpanAttributes): this {\n    return this;\n  }\n\n  // By default does nothing\n  addEvent(_name: string, _attributes?: SpanAttributes): this {\n    return this;\n  }\n\n  addLink(_link: Link): this {\n    return this;\n  }\n\n  addLinks(_links: Link[]): this {\n    return this;\n  }\n\n  // By default does nothing\n  setStatus(_status: SpanStatus): this {\n    return this;\n  }\n\n  // By default does nothing\n  updateName(_name: string): this {\n    return this;\n  }\n\n  // By default does nothing\n  end(_endTime?: TimeInput): void {}\n\n  // isRecording always returns false for NonRecordingSpan.\n  isRecording(): boolean {\n    return false;\n  }\n\n  // By default does nothing\n  recordException(_exception: Exception, _time?: TimeInput): void {}\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { ContextAPI } from '../api/context';\n\n/**\n * span key\n */\nconst SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');\n\n/**\n * Return the span if one exists\n *\n * @param context context to get span from\n */\nexport function getSpan(context: Context): Span | undefined {\n  return (context.getValue(SPAN_KEY) as Span) || undefined;\n}\n\n/**\n * Gets the span from the current context, if one exists.\n */\nexport function getActiveSpan(): Span | undefined {\n  return getSpan(ContextAPI.getInstance().active());\n}\n\n/**\n * Set the span on a context\n *\n * @param context context to use as parent\n * @param span span to set active\n */\nexport function setSpan(context: Context, span: Span): Context {\n  return context.setValue(SPAN_KEY, span);\n}\n\n/**\n * Remove current span stored in the context\n *\n * @param context context to delete span from\n */\nexport function deleteSpan(context: Context): Context {\n  return context.deleteValue(SPAN_KEY);\n}\n\n/**\n * Wrap span context in a NoopSpan and set as span in a new\n * context\n *\n * @param context context to set active span on\n * @param spanContext span context to be wrapped\n */\nexport function setSpanContext(\n  context: Context,\n  spanContext: SpanContext\n): Context {\n  return setSpan(context, new NonRecordingSpan(spanContext));\n}\n\n/**\n * Get the span context of the span if it exists.\n *\n * @param context context to get values from\n */\nexport function getSpanContext(context: Context): SpanContext | undefined {\n  return getSpan(context)?.spanContext();\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { INVALID_SPANID, INVALID_TRACEID } from './invalid-span-constants';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\n\nconst VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nconst VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\n\nexport function isValidTraceId(traceId: string): boolean {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\n\nexport function isValidSpanId(spanId: string): boolean {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\n\n/**\n * Returns true if this {@link SpanContext} is valid.\n * @return true if this {@link SpanContext} is valid.\n */\nexport function isSpanContextValid(spanContext: SpanContext): boolean {\n  return (\n    isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId)\n  );\n}\n\n/**\n * Wrap the given {@link SpanContext} in a new non-recording {@link Span}\n *\n * @param spanContext span context to be wrapped\n * @returns a new non-recording {@link Span} with the provided context\n */\nexport function wrapSpanContext(spanContext: SpanContext): Span {\n  return new NonRecordingSpan(spanContext);\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { Context } from '../context/types';\nimport { getSpanContext, setSpan } from '../trace/context-utils';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { isSpanContextValid } from './spancontext-utils';\nimport { SpanOptions } from './SpanOptions';\nimport { SpanContext } from './span_context';\nimport { Tracer } from './tracer';\n\nconst contextApi = ContextAPI.getInstance();\n\n/**\n * No-op implementations of {@link Tracer}.\n */\nexport class NoopTracer implements Tracer {\n  // startSpan starts a noop span.\n  startSpan(\n    name: string,\n    options?: SpanOptions,\n    context = contextApi.active()\n  ): Span {\n    const root = Boolean(options?.root);\n    if (root) {\n      return new NonRecordingSpan();\n    }\n\n    const parentFromContext = context && getSpanContext(context);\n\n    if (\n      isSpanContext(parentFromContext) &&\n      isSpanContextValid(parentFromContext)\n    ) {\n      return new NonRecordingSpan(parentFromContext);\n    } else {\n      return new NonRecordingSpan();\n    }\n  }\n\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    ctx: Context | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | SpanOptions,\n    arg3?: F | Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: SpanOptions | undefined;\n    let ctx: Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as SpanOptions | undefined;\n      ctx = arg3 as Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? contextApi.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = setSpan(parentContext, span);\n\n    return contextApi.with(contextWithSpanSet, fn, undefined, span);\n  }\n}\n\nfunction isSpanContext(spanContext: any): spanContext is SpanContext {\n  return (\n    typeof spanContext === 'object' &&\n    typeof spanContext['spanId'] === 'string' &&\n    typeof spanContext['traceId'] === 'string' &&\n    typeof spanContext['traceFlags'] === 'number'\n  );\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { NoopTracer } from './NoopTracer';\nimport { Span } from './span';\nimport { SpanOptions } from './SpanOptions';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER = new NoopTracer();\n\n/**\n * Proxy tracer provided by the proxy tracer provider\n */\nexport class ProxyTracer implements Tracer {\n  // When a real implementation is provided, this will be it\n  private _delegate?: Tracer;\n\n  constructor(\n    private _provider: TracerDelegator,\n    public readonly name: string,\n    public readonly version?: string,\n    public readonly options?: TracerOptions\n  ) {}\n\n  startSpan(name: string, options?: SpanOptions, context?: Context): Span {\n    return this._getTracer().startSpan(name, options, context);\n  }\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    _name: string,\n    _options: F | SpanOptions,\n    _context?: F | Context,\n    _fn?: F\n  ): ReturnType<F> {\n    const tracer = this._getTracer();\n    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n  }\n\n  /**\n   * Try to get a tracer from the proxy tracer provider.\n   * If the proxy tracer provider has no delegate, return a noop tracer.\n   */\n  private _getTracer() {\n    if (this._delegate) {\n      return this._delegate;\n    }\n\n    const tracer = this._provider.getDelegateTracer(\n      this.name,\n      this.version,\n      this.options\n    );\n\n    if (!tracer) {\n      return NOOP_TRACER;\n    }\n\n    this._delegate = tracer;\n    return this._delegate;\n  }\n}\n\nexport interface TracerDelegator {\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopTracer } from './NoopTracer';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\nimport { TracerProvider } from './tracer_provider';\n\n/**\n * An implementation of the {@link TracerProvider} which returns an impotent\n * Tracer for all calls to `getTracer`.\n *\n * All operations are no-op.\n */\nexport class NoopTracerProvider implements TracerProvider {\n  getTracer(\n    _name?: string,\n    _version?: string,\n    _options?: TracerOptions\n  ): Tracer {\n    return new NoopTracer();\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Tracer } from './tracer';\nimport { TracerProvider } from './tracer_provider';\nimport { ProxyTracer } from './ProxyTracer';\nimport { NoopTracerProvider } from './NoopTracerProvider';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER_PROVIDER = new NoopTracerProvider();\n\n/**\n * Tracer provider which provides {@link ProxyTracer}s.\n *\n * Before a delegate is set, tracers provided are NoOp.\n *   When a delegate is set, traces are provided from the delegate.\n *   When a delegate is set after tracers have already been provided,\n *   all tracers already provided will use the provided delegate implementation.\n */\nexport class ProxyTracerProvider implements TracerProvider {\n  private _delegate?: TracerProvider;\n\n  /**\n   * Get a {@link ProxyTracer}\n   */\n  getTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n    return (\n      this.getDelegateTracer(name, version, options) ??\n      new ProxyTracer(this, name, version, options)\n    );\n  }\n\n  getDelegate(): TracerProvider {\n    return this._delegate ?? NOOP_TRACER_PROVIDER;\n  }\n\n  /**\n   * Set the delegate tracer provider\n   */\n  setDelegate(delegate: TracerProvider) {\n    this._delegate = delegate;\n  }\n\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined {\n    return this._delegate?.getTracer(name, version, options);\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport interface SpanStatus {\n  /** The status code of this message. */\n  code: SpanStatusCode;\n  /** A developer-facing error message. */\n  message?: string;\n}\n\n/**\n * An enumeration of status codes.\n */\nexport enum SpanStatusCode {\n  /**\n   * The default status.\n   */\n  UNSET = 0,\n  /**\n   * The operation has been validated by an Application developer or\n   * Operator to have completed successfully.\n   */\n  OK = 1,\n  /**\n   * The operation contains an error.\n   */\n  ERROR = 2,\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { ContextAPI } from './api/context';\n/** Entrypoint for context API */\nexport const context = ContextAPI.getInstance();\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { ProxyTracerProvider } from '../trace/ProxyTracerProvider';\nimport {\n  isSpanContextValid,\n  wrapSpanContext,\n} from '../trace/spancontext-utils';\nimport { Tracer } from '../trace/tracer';\nimport { TracerProvider } from '../trace/tracer_provider';\nimport {\n  deleteSpan,\n  getActiveSpan,\n  getSpan,\n  getSpanContext,\n  setSpan,\n  setSpanContext,\n} from '../trace/context-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'trace';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Tracing API\n */\nexport class TraceAPI {\n  private static _instance?: TraceAPI;\n\n  private _proxyTracerProvider = new ProxyTracerProvider();\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Trace API */\n  public static getInstance(): TraceAPI {\n    if (!this._instance) {\n      this._instance = new TraceAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global tracer.\n   *\n   * @returns true if the tracer provider was successfully registered, else false\n   */\n  public setGlobalTracerProvider(provider: TracerProvider): boolean {\n    const success = registerGlobal(\n      API_NAME,\n      this._proxyTracerProvider,\n      DiagAPI.instance()\n    );\n    if (success) {\n      this._proxyTracerProvider.setDelegate(provider);\n    }\n    return success;\n  }\n\n  /**\n   * Returns the global tracer provider.\n   */\n  public getTracerProvider(): TracerProvider {\n    return getGlobal(API_NAME) || this._proxyTracerProvider;\n  }\n\n  /**\n   * Returns a tracer from the global tracer provider.\n   */\n  public getTracer(name: string, version?: string): Tracer {\n    return this.getTracerProvider().getTracer(name, version);\n  }\n\n  /** Remove the global tracer provider */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n    this._proxyTracerProvider = new ProxyTracerProvider();\n  }\n\n  public wrapSpanContext = wrapSpanContext;\n\n  public isSpanContextValid = isSpanContextValid;\n\n  public deleteSpan = deleteSpan;\n\n  public getSpan = getSpan;\n\n  public getActiveSpan = getActiveSpan;\n\n  public getSpanContext = getSpanContext;\n\n  public setSpan = setSpan;\n\n  public setSpanContext = setSpanContext;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TraceAPI } from './api/trace';\n/** Entrypoint for trace API */\nexport const trace = TraceAPI.getInstance();\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport { BaggageEntry, BaggageEntryMetadata, Baggage } from './baggage/types';\nexport { baggageEntryMetadataFromString } from './baggage/utils';\nexport { Exception } from './common/Exception';\nexport { HrTime, TimeInput } from './common/Time';\nexport { Attributes, AttributeValue } from './common/Attributes';\n\n// Context APIs\nexport { createContextKey, ROOT_CONTEXT } from './context/context';\nexport { Context, ContextManager } from './context/types';\nexport type { ContextAPI } from './api/context';\n\n// Diag APIs\nexport { DiagConsoleLogger } from './diag/consoleLogger';\nexport {\n  DiagLogFunction,\n  DiagLogger,\n  DiagLogLevel,\n  ComponentLoggerOptions,\n  DiagLoggerOptions,\n} from './diag/types';\nexport type { DiagAPI } from './api/diag';\n\n// Metrics APIs\nexport { createNoopMeter } from './metrics/NoopMeter';\nexport { MeterOptions, Meter } from './metrics/Meter';\nexport { MeterProvider } from './metrics/MeterProvider';\nexport {\n  ValueType,\n  Counter,\n  Gauge,\n  Histogram,\n  MetricOptions,\n  Observable,\n  ObservableCounter,\n  ObservableGauge,\n  ObservableUpDownCounter,\n  UpDownCounter,\n  BatchObservableCallback,\n  MetricAdvice,\n  MetricAttributes,\n  MetricAttributeValue,\n  ObservableCallback,\n} from './metrics/Metric';\nexport {\n  BatchObservableResult,\n  ObservableResult,\n} from './metrics/ObservableResult';\nexport type { MetricsAPI } from './api/metrics';\n\n// Propagation APIs\nexport {\n  TextMapPropagator,\n  TextMapSetter,\n  TextMapGetter,\n  defaultTextMapGetter,\n  defaultTextMapSetter,\n} from './propagation/TextMapPropagator';\nexport type { PropagationAPI } from './api/propagation';\n\n// Trace APIs\nexport { SpanAttributes, SpanAttributeValue } from './trace/attributes';\nexport { Link } from './trace/link';\nexport { ProxyTracer, TracerDelegator } from './trace/ProxyTracer';\nexport { ProxyTracerProvider } from './trace/ProxyTracerProvider';\nexport { Sampler } from './trace/Sampler';\nexport { SamplingDecision, SamplingResult } from './trace/SamplingResult';\nexport { SpanContext } from './trace/span_context';\nexport { SpanKind } from './trace/span_kind';\nexport { Span } from './trace/span';\nexport { SpanOptions } from './trace/SpanOptions';\nexport { SpanStatus, SpanStatusCode } from './trace/status';\nexport { TraceFlags } from './trace/trace_flags';\nexport { TraceState } from './trace/trace_state';\nexport { createTraceState } from './trace/internal/utils';\nexport { TracerProvider } from './trace/tracer_provider';\nexport { Tracer } from './trace/tracer';\nexport { TracerOptions } from './trace/tracer_options';\nexport {\n  isSpanContextValid,\n  isValidTraceId,\n  isValidSpanId,\n} from './trace/spancontext-utils';\nexport {\n  INVALID_SPANID,\n  INVALID_TRACEID,\n  INVALID_SPAN_CONTEXT,\n} from './trace/invalid-span-constants';\nexport type { TraceAPI } from './api/trace';\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { context } from './context-api';\nimport { diag } from './diag-api';\nimport { metrics } from './metrics-api';\nimport { propagation } from './propagation-api';\nimport { trace } from './trace-api';\n\n// Named export.\nexport { context, diag, metrics, propagation, trace };\n// Default export.\nexport default {\n  context,\n  diag,\n  metrics,\n  propagation,\n  trace,\n};\n","/**\n * OTEL attribute constants for AG-Kit observability.\n *\n * Uses OpenInference semantic conventions where applicable:\n * https://github.com/Arize-ai/openinference/tree/main/spec\n *\n * Falls back to AG-Kit specific attributes where OpenInference\n * doesn't define a standard.\n *\n * @module\n */\n\nimport {\n  SemanticConventions,\n  OpenInferenceSpanKind,\n} from \"@arizeai/openinference-semantic-conventions\";\n\n// Re-export OpenInference types for convenience\nexport { OpenInferenceSpanKind };\n\n/**\n * SDK information\n */\nexport const OBSERVABILITY_TRACER_NAME = \"agkit-tracer\";\nexport const OBSERVABILITY_SDK_NAME = \"@agkit/observability\";\n// Version will be injected from package.json\n\n/**\n * Combined attribute namespace for internal use\n * Provides a single namespace for all OTEL attributes used by AG-Kit\n *\n * Combines OpenInference SemanticConventions with AG-Kit specific attributes\n */\nexport const OtelSpanAttributes = {\n  // OpenInference - re-export all standard conventions\n  ...SemanticConventions,\n\n  // AG-Kit Trace attributes (non-standard)\n  TRACE_NAME: \"trace.name\",\n  TRACE_TAGS: \"trace.tags\",\n  TRACE_PUBLIC: \"trace.public\",\n  TRACE_METADATA: \"trace.metadata\",\n  TRACE_INPUT: \"trace.input\",\n  TRACE_OUTPUT: \"trace.output\",\n\n  // AG-Kit Observation attributes (non-standard)\n  OBSERVATION_TYPE: \"observation.type\",\n  OBSERVATION_LEVEL: \"observation.level\",\n  OBSERVATION_STATUS_MESSAGE: \"observation.status_message\",\n  OBSERVATION_INPUT: \"observation.input\",\n  OBSERVATION_OUTPUT: \"observation.output\",\n  OBSERVATION_METADATA: \"observation.metadata\",\n\n  // AG-Kit LLM-specific (non-standard)\n  LLM_COMPLETION_START_TIME: \"llm.completion_start_time\",\n  LLM_MODEL_PARAMETERS: \"llm.model_parameters\",\n  LLM_USAGE_DETAILS: \"llm.usage_details\",\n  LLM_COST_DETAILS: \"llm.cost_details\",\n\n  // AG-Kit Retriever-specific (non-standard)\n  RETRIEVER_NAME: \"retriever.name\",\n  RETRIEVER_QUERY: \"retriever.query\",\n  RETRIEVER_INDEX_ID: \"retriever.index_id\",\n  RETRIEVER_TOP_K: \"retriever.top_k\",\n\n  // AG-Kit General (non-standard)\n  ENVIRONMENT: \"environment\",\n  RELEASE: \"release\",\n  VERSION: \"version\",\n} as const;\n\n/**\n * Type for the OtelSpanAttributes object values\n */\nexport type OtelSpanAttributeValues = typeof OtelSpanAttributes[keyof typeof OtelSpanAttributes];\n","import { OBSERVABILITY_TRACER_NAME, OtelSpanAttributes } from \"./constants.js\";\nimport { SemanticConventions } from \"@arizeai/openinference-semantic-conventions\";\nimport { ObservationAttributes, TraceAttributes, ObservationType } from \"../types.js\";\nimport { type Attributes } from \"@opentelemetry/api\";\n\n/**\n * Creates OpenTelemetry attributes from trace attributes.\n *\n * Converts user-friendly trace attributes into OpenTelemetry attribute format\n * using OpenInference semantic conventions where applicable.\n *\n * @param attributes - Trace attributes to convert\n * @returns OpenTelemetry attributes object\n *\n * @example\n * ```typescript\n * const otelAttributes = createTraceAttributes({\n *   name: 'user-workflow',\n *   userId: 'user-123',\n *   sessionId: 'session-456',\n *   tags: ['checkout', 'payment']\n * });\n * ```\n *\n * @public\n */\nexport function createTraceAttributes({\n  name,\n  userId,\n  sessionId,\n  version,\n  release,\n  input,\n  output,\n  metadata,\n  tags,\n  environment,\n  public: isPublic,\n}: TraceAttributes = {}): Attributes {\n  const attributes = {\n    [OtelSpanAttributes.TRACE_NAME]: name,\n    // Use OpenInference standard attributes for user and session\n    [OtelSpanAttributes.USER_ID]: userId,\n    [OtelSpanAttributes.SESSION_ID]: sessionId,\n    [OtelSpanAttributes.VERSION]: version,\n    [OtelSpanAttributes.RELEASE]: release,\n    [OtelSpanAttributes.TRACE_INPUT]: _serialize(input),\n    [OtelSpanAttributes.TRACE_OUTPUT]: _serialize(output),\n    [OtelSpanAttributes.TRACE_TAGS]: tags,\n    [OtelSpanAttributes.ENVIRONMENT]: environment,\n    [OtelSpanAttributes.TRACE_PUBLIC]: isPublic,\n    ..._flattenAndSerializeMetadata(metadata, OtelSpanAttributes.TRACE_METADATA),\n  };\n\n  return Object.fromEntries(\n    Object.entries(attributes).filter(([_, v]) => v != null),\n  );\n}\n\n/**\n * Creates OpenTelemetry attributes from observation attributes.\n *\n * Maps observation attributes to OpenInference semantic conventions:\n * - Uses `openinference.span.kind` for span type\n * - Uses `llm.*` for LLM-specific attributes\n * - Uses `tool.*` for tool-specific attributes\n * - Falls back to `agkit.observation.*` for non-standard attributes\n *\n * @param type - Observation type (llm, tool, chain, etc.)\n * @param attributes - Observation attributes to convert\n * @returns OpenTelemetry attributes object\n *\n * @public\n */\nexport function createObservationAttributes(\n  type: ObservationType,\n  attributes: ObservationAttributes,\n): Attributes {\n  const {\n    metadata,\n    input,\n    output,\n    level,\n    statusMessage,\n    version,\n    completionStartTime,\n    model,\n    modelParameters,\n    usageDetails,\n  } = attributes;\n\n  // Base attributes for all observation types\n  const otelAttributes: Attributes = {\n    [SemanticConventions.OPENINFERENCE_SPAN_KIND]: type.toUpperCase(),\n    [OtelSpanAttributes.OBSERVATION_TYPE]: type,\n    [OtelSpanAttributes.OBSERVATION_LEVEL]: level,\n    [OtelSpanAttributes.OBSERVATION_STATUS_MESSAGE]: statusMessage,\n    [OtelSpanAttributes.VERSION]: version,\n    // Use OpenInference input.value convention\n    [SemanticConventions.INPUT_VALUE]: _serialize(input),\n    // Also set legacy agkit.observation.input for compatibility\n    [OtelSpanAttributes.OBSERVATION_INPUT]: _serialize(input),\n    // Use OpenInference output.value convention\n    [SemanticConventions.OUTPUT_VALUE]: _serialize(output),\n    // Also set legacy agkit.observation.output for compatibility\n    [OtelSpanAttributes.OBSERVATION_OUTPUT]: _serialize(output),\n  };\n\n  // LLM-specific attributes\n  if (type === \"llm\") {\n    if (model) {\n      otelAttributes[SemanticConventions.LLM_MODEL_NAME] = model;\n    }\n    if (modelParameters) {\n      otelAttributes[SemanticConventions.LLM_INVOCATION_PARAMETERS] =\n        _serialize(modelParameters);\n      // Also set agkit.llm.model_parameters for compatibility\n      otelAttributes[OtelSpanAttributes.LLM_MODEL_PARAMETERS] =\n        _serialize(modelParameters);\n    }\n    if (usageDetails) {\n      // Map to OpenInference llm.token_count.* attributes\n      if (typeof usageDetails === \"object\") {\n        const usage = usageDetails as Record<string, number>;\n        if (usage.promptTokens !== undefined) {\n          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_PROMPT] =\n            usage.promptTokens;\n        }\n        if (usage.completionTokens !== undefined) {\n          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_COMPLETION] =\n            usage.completionTokens;\n        }\n        if (usage.totalTokens !== undefined) {\n          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_TOTAL] =\n            usage.totalTokens;\n        }\n      }\n      // Also set legacy agkit.llm.usage_details for compatibility\n      otelAttributes[OtelSpanAttributes.LLM_USAGE_DETAILS] =\n        _serialize(usageDetails);\n    }\n    if (completionStartTime) {\n      otelAttributes[OtelSpanAttributes.LLM_COMPLETION_START_TIME] =\n        _serialize(completionStartTime);\n    }\n  }\n\n  // Embedding-specific attributes\n  if (type === \"embedding\") {\n    if (model) {\n      otelAttributes[SemanticConventions.EMBEDDING_MODEL_NAME] = model;\n    }\n    if (modelParameters) {\n      otelAttributes[SemanticConventions.LLM_INVOCATION_PARAMETERS] =\n        _serialize(modelParameters);\n    }\n  }\n\n  // Add metadata (use OpenInference metadata convention)\n  const metadataAttrs = _flattenAndSerializeMetadata(\n    metadata,\n    SemanticConventions.METADATA,\n  );\n  Object.assign(otelAttributes, metadataAttrs);\n\n  // Also add agkit.observation.metadata for compatibility\n  const obsetvabilityMetadataAttrs = _flattenAndSerializeMetadata(\n    metadata,\n    OtelSpanAttributes.OBSERVATION_METADATA\n  );\n  Object.assign(otelAttributes, obsetvabilityMetadataAttrs);\n\n  // Filter out null/undefined values\n  return Object.fromEntries(\n    Object.entries(otelAttributes).filter(([_, v]) => v != null),\n  );\n}\n\n/**\n * Safely serializes an object to JSON string.\n *\n * @param obj - Object to serialize\n * @returns JSON string or undefined if null/undefined\n * @internal\n */\nfunction _serialize(obj: unknown): string | undefined {\n  try {\n    if (typeof obj === \"string\") return obj;\n    if (obj instanceof Date) return obj.toISOString();\n    return obj != null ? JSON.stringify(obj) : undefined;\n  } catch {\n    return \"<failed to serialize>\";\n  }\n}\n\n/**\n * Flattens and serializes metadata into OpenTelemetry attribute format.\n *\n * Converts nested metadata objects into dot-notation attribute keys.\n * For example, `{ database: { host: 'localhost' } }` becomes\n * `{ 'metadata.database.host': 'localhost' }` (or 'agkit.observation.metadata.database.host').\n *\n * @param metadata - Metadata object to flatten\n * @param prefix - Attribute prefix (e.g., 'metadata' or 'agkit.observation.metadata')\n * @returns Flattened metadata attributes\n * @internal\n */\nfunction _flattenAndSerializeMetadata(\n  metadata: unknown,\n  prefix: string,\n): Record<string, string> {\n  const metadataAttributes: Record<string, string> = {};\n\n  if (metadata === undefined || metadata === null) {\n    return metadataAttributes;\n  }\n\n  if (typeof metadata !== \"object\" || Array.isArray(metadata)) {\n    const serialized = _serialize(metadata);\n    if (serialized) {\n      metadataAttributes[prefix] = serialized;\n    }\n  } else {\n    for (const [key, value] of Object.entries(metadata)) {\n      const serialized = typeof value === \"string\" ? value : _serialize(value);\n      if (serialized) {\n        metadataAttributes[`${prefix}.${key}`] = serialized;\n      }\n    }\n  }\n\n  return metadataAttributes;\n}\n","import { TracerProvider, trace, context } from \"@opentelemetry/api\";\n\nconst OBSERVABILITY_GLOBAL_SYMBOL = Symbol.for(\"observability\");\n\ntype ObservabilityGlobalState = {\n  isolatedTracerProvider: TracerProvider | null;\n};\n\nfunction createState(): ObservabilityGlobalState {\n  return {\n    isolatedTracerProvider: null,\n  };\n}\n\ninterface GlobalThis {\n  [OBSERVABILITY_GLOBAL_SYMBOL]?: ObservabilityGlobalState;\n}\n\n/**\n * Gets the global state for tracing observability.\n *\n * @returns The global state object\n * @internal\n */\nfunction getObservabilityGlobalState(): ObservabilityGlobalState {\n  const initialState = createState();\n\n  try {\n    const g = globalThis as typeof globalThis & GlobalThis;\n\n    if (typeof g !== \"object\" || g === null) {\n      console.warn(\n        \"[Observability] globalThis is not available, using fallback state\",\n      );\n      return initialState;\n    }\n\n    if (!g[OBSERVABILITY_GLOBAL_SYMBOL]) {\n      Object.defineProperty(g, OBSERVABILITY_GLOBAL_SYMBOL, {\n        value: initialState,\n        writable: false,\n        configurable: false,\n        enumerable: false,\n      });\n    }\n\n    return g[OBSERVABILITY_GLOBAL_SYMBOL]!;\n  } catch (err) {\n    console.error(\n      `[Observability] Failed to access global state: ${err instanceof Error ? err.message : String(err)}`,\n    );\n    return initialState;\n  }\n}\n\n/**\n * Sets an isolated TracerProvider for tracing tracing operations.\n *\n * This allows tracing to use its own TracerProvider instance, separate from\n * the global OpenTelemetry TracerProvider.\n *\n * Note: While this isolates span processing and export, it does NOT provide\n * complete trace isolation. OpenTelemetry context (trace IDs, parent spans)\n * is still shared between the global and isolated providers.\n *\n * @param provider - The TracerProvider instance to use, or null to clear\n *\n * @example\n * ```typescript\n * import { NodeTracerProvider } from '@opentelemetry/sdk-trace-node';\n * import { setTracerProvider } from './observability';\n *\n * const provider = new NodeTracerProvider();\n * setTracerProvider(provider);\n * ```\n *\n * @public\n */\nexport function setTracerProvider(provider: TracerProvider | null) {\n  getObservabilityGlobalState().isolatedTracerProvider = provider;\n}\n\n/**\n * Gets the TracerProvider for tracing tracing operations.\n *\n * Returns the isolated TracerProvider if one has been set via setTracerProvider(),\n * otherwise falls back to the global OpenTelemetry TracerProvider.\n *\n * @returns The TracerProvider instance to use for tracing tracing\n *\n * @example\n * ```typescript\n * import { getTracerProvider } from './observability';\n *\n * const provider = getTracerProvider();\n * const tracer = provider.getTracer('my-tracer', '1.0.0');\n * ```\n *\n * @public\n */\nexport function getTracerProvider(): TracerProvider {\n  const { isolatedTracerProvider } = getObservabilityGlobalState();\n\n  if (isolatedTracerProvider) return isolatedTracerProvider;\n\n  return trace.getTracerProvider();\n}\n\n/**\n * Gets the OpenTelemetry tracer instance for tracing.\n *\n * Returns a tracer specifically configured for tracing with the correct\n * tracer name and version.\n *\n * @returns The tracing OpenTelemetry tracer instance\n *\n * @example\n * ```typescript\n * import { getTracer } from './observability';\n *\n * const tracer = getTracer();\n * const span = tracer.startSpan('my-operation');\n * ```\n *\n * @public\n */\nexport function getTracer() {\n  return getTracerProvider().getTracer(\n    OBSERVABILITY_SDK_NAME,\n    OBSERVABILITY_SDK_VERSION\n  );\n}\n\n// SDK version - could be read from package.json in production\nconst OBSERVABILITY_SDK_NAME = \"ag-kit-observability\";\nconst OBSERVABILITY_SDK_VERSION = \"0.1.0\";\n","import { Span, TimeInput } from \"@opentelemetry/api\";\n\nimport { createObservationAttributes, createTraceAttributes } from \"./attributes.js\";\nimport { getTracer } from \"./tracerProvider.js\";\nimport {\n  BaseSpanAttributes,\n  LLMAttributes,\n  TraceAttributes,\n  ObservationType,\n} from \"../types.js\";\nimport type {\n  ToolAttributes,\n  AgentAttributes,\n  ChainAttributes,\n  RetrieverAttributes,\n  RerankerAttributes,\n  EvaluatorAttributes,\n  GuardrailAttributes,\n  EmbeddingAttributes,\n  ObservationAttributes,\n} from \"../types.js\";\n\n/**\n * Union type representing any observation wrapper.\n *\n * @public\n */\nexport type Observation =\n  | ObservationSpan\n  | ObservationLLM\n  | ObservationEmbedding\n  | ObservationAgent\n  | ObservationTool\n  | ObservationChain\n  | ObservationRetriever\n  | ObservationReranker\n  | ObservationEvaluator\n  | ObservationGuardrail;\n\n/**\n * Parameters for creating an observation wrapper.\n *\n * @internal\n */\ntype ObservationParams = {\n  otelSpan: Span;\n  type: ObservationType;\n  attributes?: BaseSpanAttributes | LLMAttributes;\n};\n\n/**\n * Base class for all observation wrappers.\n *\n * Provides common functionality for all observation types including:\n * - OpenTelemetry span integration\n * - Unique identification (span ID, trace ID)\n * - Lifecycle management (update, end)\n * - Trace context management\n * - Child observation creation\n *\n * @internal\n */\nabstract class BaseObservation {\n  /** The underlying OpenTelemetry span */\n  public readonly otelSpan: Span;\n  /** The observation type */\n  public readonly type: ObservationType;\n  /** The span ID from the OpenTelemetry span context */\n  public id: string;\n  /** The trace ID from the OpenTelemetry span context */\n  public traceId: string;\n\n  constructor(params: ObservationParams) {\n    this.otelSpan = params.otelSpan;\n    this.id = params.otelSpan.spanContext().spanId;\n    this.traceId = params.otelSpan.spanContext().traceId;\n    this.type = params.type;\n\n    if (params.attributes) {\n      this.otelSpan.setAttributes(\n        createObservationAttributes(params.type, params.attributes),\n      );\n    }\n  }\n\n  /** Gets the AG-Kit OpenTelemetry tracer instance */\n  protected get tracer() {\n    return getTracer();\n  }\n\n  /**\n   * Ends the observation, marking it as complete.\n   *\n   * @param endTime - Optional end time, defaults to current time\n   */\n  public end(endTime?: TimeInput) {\n    this.otelSpan.end(endTime);\n  }\n\n  /**\n   * Updates the OTEL span attributes.\n   *\n   * @param attributes - Attributes to update\n   * @internal\n   */\n  updateOtelSpanAttributes(attributes: ObservationAttributes) {\n    this.otelSpan.setAttributes(\n      createObservationAttributes(this.type, attributes),\n    );\n  }\n\n  /**\n   * Updates the parent trace with new attributes.\n   *\n   * @param attributes - Trace attributes to set\n   * @returns This observation for method chaining\n   */\n  public updateTrace(attributes: TraceAttributes) {\n    this.otelSpan.setAttributes(createTraceAttributes(attributes));\n    return this;\n  }\n\n  /**\n   * Creates a new child observation within this observation's context.\n   *\n   * @param name - Name for the child observation\n   * @param attributes - Type-specific attributes\n   * @param options - Configuration including observation type\n   * @returns Child observation instance\n   */\n  public startObservation(\n    name: string,\n    attributes: LLMAttributes,\n    options: { asType: \"llm\" },\n  ): ObservationLLM;\n  public startObservation(\n    name: string,\n    attributes: EmbeddingAttributes,\n    options: { asType: \"embedding\" },\n  ): ObservationEmbedding;\n  public startObservation(\n    name: string,\n    attributes: AgentAttributes,\n    options: { asType: \"agent\" },\n  ): ObservationAgent;\n  public startObservation(\n    name: string,\n    attributes: ToolAttributes,\n    options: { asType: \"tool\" },\n  ): ObservationTool;\n  public startObservation(\n    name: string,\n    attributes: ChainAttributes,\n    options: { asType: \"chain\" },\n  ): ObservationChain;\n  public startObservation(\n    name: string,\n    attributes: RetrieverAttributes,\n    options: { asType: \"retriever\" },\n  ): ObservationRetriever;\n  public startObservation(\n    name: string,\n    attributes: RerankerAttributes,\n    options: { asType: \"reranker\" },\n  ): ObservationReranker;\n  public startObservation(\n    name: string,\n    attributes: EvaluatorAttributes,\n    options: { asType: \"evaluator\" },\n  ): ObservationEvaluator;\n  public startObservation(\n    name: string,\n    attributes: GuardrailAttributes,\n    options: { asType: \"guardrail\" },\n  ): ObservationGuardrail;\n  public startObservation(\n    name: string,\n    attributes?: BaseSpanAttributes,\n    options?: { asType?: \"span\" },\n  ): ObservationSpan;\n  public startObservation(\n    name: string,\n    attributes?:\n      | BaseSpanAttributes\n      | LLMAttributes\n      | ToolAttributes\n      | AgentAttributes\n      | ChainAttributes\n      | RetrieverAttributes\n      | RerankerAttributes\n      | EvaluatorAttributes\n      | GuardrailAttributes\n      | EmbeddingAttributes,\n    options?: { asType?: ObservationType },\n  ): Observation {\n    // Import here to avoid circular dependency\n    const { startObservation: startObs } = require(\"../index.js\");\n    const { asType = \"span\" } = options || {};\n\n    return startObs(name, attributes, {\n      asType: asType as \"span\",\n      parentSpanContext: this.otelSpan.spanContext(),\n    });\n  }\n}\n\n// Type-specific observation classes\n\ntype ObservationSpanParams = {\n  otelSpan: Span;\n  attributes?: BaseSpanAttributes;\n};\n\n/**\n * General-purpose observation for tracking operations.\n *\n * @public\n */\nexport class ObservationSpan extends BaseObservation {\n  constructor(params: ObservationSpanParams) {\n    super({ ...params, type: \"span\" });\n  }\n\n  public update(attributes: BaseSpanAttributes): ObservationSpan {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationLLMParams = {\n  otelSpan: Span;\n  attributes?: LLMAttributes;\n};\n\n/**\n * LLM observation for tracking language model calls.\n *\n * @public\n */\nexport class ObservationLLM extends BaseObservation {\n  constructor(params: ObservationLLMParams) {\n    super({ ...params, type: \"llm\" });\n  }\n\n  public update(attributes: LLMAttributes): ObservationLLM {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationEmbeddingParams = {\n  otelSpan: Span;\n  attributes?: EmbeddingAttributes;\n};\n\n/**\n * Embedding observation for tracking embedding operations.\n *\n * @public\n */\nexport class ObservationEmbedding extends BaseObservation {\n  constructor(params: ObservationEmbeddingParams) {\n    super({ ...params, type: \"embedding\" });\n  }\n\n  public update(attributes: EmbeddingAttributes): ObservationEmbedding {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationAgentParams = {\n  otelSpan: Span;\n  attributes?: AgentAttributes;\n};\n\n/**\n * Agent observation for tracking AI agent workflows.\n *\n * @public\n */\nexport class ObservationAgent extends BaseObservation {\n  constructor(params: ObservationAgentParams) {\n    super({ ...params, type: \"agent\" });\n  }\n\n  public update(attributes: AgentAttributes): ObservationAgent {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationToolParams = {\n  otelSpan: Span;\n  attributes?: ToolAttributes;\n};\n\n/**\n * Tool observation for tracking tool calls.\n *\n * @public\n */\nexport class ObservationTool extends BaseObservation {\n  constructor(params: ObservationToolParams) {\n    super({ ...params, type: \"tool\" });\n  }\n\n  public update(attributes: ToolAttributes): ObservationTool {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationChainParams = {\n  otelSpan: Span;\n  attributes?: ChainAttributes;\n};\n\n/**\n * Chain observation for tracking multi-step workflows.\n *\n * @public\n */\nexport class ObservationChain extends BaseObservation {\n  constructor(params: ObservationChainParams) {\n    super({ ...params, type: \"chain\" });\n  }\n\n  public update(attributes: ChainAttributes): ObservationChain {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationRetrieverParams = {\n  otelSpan: Span;\n  attributes?: RetrieverAttributes;\n};\n\n/**\n * Retriever observation for tracking document retrieval.\n *\n * @public\n */\nexport class ObservationRetriever extends BaseObservation {\n  constructor(params: ObservationRetrieverParams) {\n    super({ ...params, type: \"retriever\" });\n  }\n\n  public update(attributes: RetrieverAttributes): ObservationRetriever {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationRerankerParams = {\n  otelSpan: Span;\n  attributes?: RerankerAttributes;\n};\n\n/**\n * Reranker observation for tracking reranking operations.\n *\n * @public\n */\nexport class ObservationReranker extends BaseObservation {\n  constructor(params: ObservationRerankerParams) {\n    super({ ...params, type: \"reranker\" });\n  }\n\n  public update(attributes: RerankerAttributes): ObservationReranker {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationEvaluatorParams = {\n  otelSpan: Span;\n  attributes?: EvaluatorAttributes;\n};\n\n/**\n * Evaluator observation for tracking evaluation operations.\n *\n * @public\n */\nexport class ObservationEvaluator extends BaseObservation {\n  constructor(params: ObservationEvaluatorParams) {\n    super({ ...params, type: \"evaluator\" });\n  }\n\n  public update(attributes: EvaluatorAttributes): ObservationEvaluator {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationGuardrailParams = {\n  otelSpan: Span;\n  attributes?: GuardrailAttributes;\n};\n\n/**\n * Guardrail observation for tracking safety checks.\n *\n * @public\n */\nexport class ObservationGuardrail extends BaseObservation {\n  constructor(params: ObservationGuardrailParams) {\n    super({ ...params, type: \"guardrail\" });\n  }\n\n  public update(attributes: GuardrailAttributes): ObservationGuardrail {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n","/**\n * Observability - OpenTelemetry-based tracing with OpenInference semantic conventions\n *\n * @packageDocumentation\n */\n\nimport { trace, context, TimeInput, SpanStatusCode, Span, SpanContext } from \"@opentelemetry/api\";\n\nimport {\n  createObservationAttributes,\n  createTraceAttributes,\n} from \"./core/attributes.js\";\nimport {\n  ObservationSpan,\n  ObservationLLM,\n  ObservationEmbedding,\n  ObservationAgent,\n  ObservationTool,\n  ObservationChain,\n  ObservationRetriever,\n  ObservationReranker,\n  ObservationEvaluator,\n  ObservationGuardrail,\n  type Observation,\n} from \"./core/spanWrapper.js\";\nimport { getTracer } from \"./core/tracerProvider.js\";\nimport {\n  ObservationType,\n  ObservationLevel,\n  BaseSpanAttributes,\n  LLMAttributes,\n  ToolAttributes,\n  AgentAttributes,\n  ChainAttributes,\n  RetrieverAttributes,\n  RerankerAttributes,\n  EvaluatorAttributes,\n  GuardrailAttributes,\n  EmbeddingAttributes,\n  ObservationAttributes,\n  TraceAttributes,\n} from \"./types.js\";\n\n// Export types\nexport type {\n  ObservationType,\n  ObservationLevel,\n  BaseSpanAttributes,\n  LLMAttributes,\n  ToolAttributes,\n  AgentAttributes,\n  ChainAttributes,\n  RetrieverAttributes,\n  RerankerAttributes,\n  EvaluatorAttributes,\n  GuardrailAttributes,\n  EmbeddingAttributes,\n  ObservationAttributes,\n  TraceAttributes,\n};\n\n// Export observation classes\nexport {\n  ObservationSpan,\n  ObservationLLM,\n  ObservationEmbedding,\n  ObservationAgent,\n  ObservationTool,\n  ObservationChain,\n  ObservationRetriever,\n  ObservationReranker,\n  ObservationEvaluator,\n  ObservationGuardrail,\n};\n\n// Export observation union type\nexport type { Observation };\n\n// Export core functions\nexport {\n  createTraceAttributes,\n  createObservationAttributes,\n} from \"./core/attributes.js\";\nexport {\n  setTracerProvider,\n  getTracerProvider,\n  getTracer,\n} from \"./core/tracerProvider.js\";\n\n/**\n * Options for starting observations (spans).\n *\n * @public\n */\nexport type StartObservationOptions = {\n  /** Custom start time for the observation */\n  startTime?: Date;\n  /** Parent span context to attach this observation to */\n  parentSpanContext?: SpanContext;\n};\n\n/**\n * Options for startObservation function.\n *\n * @public\n */\nexport type StartObservationOpts = StartObservationOptions & {\n  /** Type of observation to create. Defaults to 'span' */\n  asType?: ObservationType;\n};\n\n/**\n * Creates an OpenTelemetry span with the AG-Kit tracer.\n *\n * @param params - Parameters for span creation\n * @returns The created OpenTelemetry span\n * @internal\n */\nfunction createOtelSpan(params: {\n  name: string;\n  startTime?: TimeInput;\n  parentSpanContext?: SpanContext;\n}): Span {\n  return getTracer().startSpan(\n    params.name,\n    { startTime: params.startTime },\n    createParentContext(params.parentSpanContext),\n  );\n}\n\n/**\n * Creates a parent context from a span context.\n *\n * @param parentSpanContext - The span context to use as parent\n * @returns The created context or undefined if no parent provided\n * @internal\n */\nfunction createParentContext(\n  parentSpanContext?: SpanContext,\n): ReturnType<typeof trace.setSpanContext> | undefined {\n  if (!parentSpanContext) return;\n  return trace.setSpanContext(context.active(), parentSpanContext);\n}\n\n// Function overloads for proper type inference\n// Generic overload for dynamic asType (returns Observation union)\nexport function startObservation(\n  name: string,\n  attributes?: BaseSpanAttributes,\n  options?: StartObservationOpts & { asType?: ObservationType },\n): Observation;\n\n// Type-specific overloads for precise type inference\nexport function startObservation(\n  name: string,\n  attributes: LLMAttributes,\n  options: StartObservationOpts & { asType: \"llm\" },\n): ObservationLLM;\nexport function startObservation(\n  name: string,\n  attributes: EmbeddingAttributes,\n  options: StartObservationOpts & { asType: \"embedding\" },\n): ObservationEmbedding;\nexport function startObservation(\n  name: string,\n  attributes: AgentAttributes,\n  options: StartObservationOpts & { asType: \"agent\" },\n): ObservationAgent;\nexport function startObservation(\n  name: string,\n  attributes: ToolAttributes,\n  options: StartObservationOpts & { asType: \"tool\" },\n): ObservationTool;\nexport function startObservation(\n  name: string,\n  attributes: ChainAttributes,\n  options: StartObservationOpts & { asType: \"chain\" },\n): ObservationChain;\nexport function startObservation(\n  name: string,\n  attributes: RetrieverAttributes,\n  options: StartObservationOpts & { asType: \"retriever\" },\n): ObservationRetriever;\nexport function startObservation(\n  name: string,\n  attributes: RerankerAttributes,\n  options: StartObservationOpts & { asType: \"reranker\" },\n): ObservationReranker;\nexport function startObservation(\n  name: string,\n  attributes: EvaluatorAttributes,\n  options: StartObservationOpts & { asType: \"evaluator\" },\n): ObservationEvaluator;\nexport function startObservation(\n  name: string,\n  attributes: GuardrailAttributes,\n  options: StartObservationOpts & { asType: \"guardrail\" },\n): ObservationGuardrail;\nexport function startObservation(\n  name: string,\n  attributes?: BaseSpanAttributes,\n  options?: StartObservationOpts & { asType?: \"span\" },\n): ObservationSpan;\n\n/**\n * Creates and starts a new AG-Kit observation.\n *\n * Supports multiple observation types with full TypeScript type safety:\n * - **span**: General-purpose operations (default)\n * - **llm**: LLM calls and AI model interactions\n * - **embedding**: Text embedding and vector operations\n * - **agent**: AI agent workflows\n * - **tool**: Individual tool calls\n * - **chain**: Multi-step processes\n * - **retriever**: Document retrieval\n * - **reranker**: Result reranking\n * - **evaluator**: Quality assessment\n * - **guardrail**: Safety checks\n *\n * @param name - Descriptive name for the observation\n * @param attributes - Type-specific attributes\n * @param options - Configuration options\n * @returns Strongly-typed observation object\n *\n * @example\n * ```typescript\n * import { startObservation } from './observability';\n *\n * // LLM observation\n * const llm = startObservation('openai-gpt-4', {\n *   input: [{ role: 'user', content: 'Hello' }],\n *   model: 'gpt-4',\n *   modelParameters: { temperature: 0.7 }\n * }, { asType: 'llm' });\n *\n * // Tool observation\n * const tool = startObservation('weather-api', {\n *   input: { location: 'SF' }\n * }, { asType: 'tool' });\n *\n * // Chain observation\n * const chain = startObservation('rag-pipeline', {\n *   input: { question: 'What is AI?' }\n * }, { asType: 'chain' });\n * ```\n *\n * @public\n */\nexport function startObservation(\n  name: string,\n  attributes?:\n    | BaseSpanAttributes\n    | LLMAttributes\n    | EmbeddingAttributes\n    | AgentAttributes\n    | ToolAttributes\n    | ChainAttributes\n    | RetrieverAttributes\n    | RerankerAttributes\n    | EvaluatorAttributes\n    | GuardrailAttributes,\n  options?: StartObservationOpts,\n): Observation {\n  const { asType = \"span\", ...observationOptions } = options || {};\n\n  const otelSpan = createOtelSpan({\n    name,\n    ...observationOptions,\n  });\n\n  switch (asType) {\n    case \"llm\":\n      return new ObservationLLM({\n        otelSpan,\n        attributes: attributes as LLMAttributes,\n      });\n\n    case \"embedding\":\n      return new ObservationEmbedding({\n        otelSpan,\n        attributes: attributes as EmbeddingAttributes,\n      });\n\n    case \"agent\":\n      return new ObservationAgent({\n        otelSpan,\n        attributes: attributes as AgentAttributes,\n      });\n\n    case \"tool\":\n      return new ObservationTool({\n        otelSpan,\n        attributes: attributes as ToolAttributes,\n      });\n\n    case \"chain\":\n      return new ObservationChain({\n        otelSpan,\n        attributes: attributes as ChainAttributes,\n      });\n\n    case \"retriever\":\n      return new ObservationRetriever({\n        otelSpan,\n        attributes: attributes as RetrieverAttributes,\n      });\n\n    case \"reranker\":\n      return new ObservationReranker({\n        otelSpan,\n        attributes: attributes as RerankerAttributes,\n      });\n\n    case \"evaluator\":\n      return new ObservationEvaluator({\n        otelSpan,\n        attributes: attributes as EvaluatorAttributes,\n      });\n\n    case \"guardrail\":\n      return new ObservationGuardrail({\n        otelSpan,\n        attributes: attributes as GuardrailAttributes,\n      });\n\n    case \"span\":\n    default:\n      return new ObservationSpan({\n        otelSpan,\n        attributes: attributes as BaseSpanAttributes,\n      });\n  }\n}\n\n/**\n * Updates the currently active trace with new attributes.\n *\n * @param attributes - Trace attributes to set\n *\n * @example\n * ```typescript\n * import { updateActiveTrace } from './observability';\n *\n * updateActiveTrace({\n *   name: 'user-workflow',\n *   userId: 'user-123',\n *   tags: ['production']\n * });\n * ```\n *\n * @public\n */\nexport function updateActiveTrace(attributes: TraceAttributes) {\n  const span = trace.getActiveSpan();\n\n  if (!span) {\n    console.warn(\n      \"[Observability] No active OTEL span in context. Skipping trace update.\",\n    );\n    return;\n  }\n\n  span.setAttributes(createTraceAttributes(attributes));\n}\n\n/**\n * Gets the current active trace ID.\n *\n * @returns The trace ID of the currently active span, or undefined\n *\n * @public\n */\nexport function getActiveTraceId(): string | undefined {\n  return trace.getActiveSpan()?.spanContext().traceId;\n}\n\n/**\n * Gets the current active observation ID.\n *\n * @returns The span ID of the currently active span, or undefined\n *\n * @public\n */\nexport function getActiveSpanId(): string | undefined {\n  return trace.getActiveSpan()?.spanContext().spanId;\n}\n\n// ============================================================================\n// Active Observation Functions\n// ============================================================================\n\n/**\n * Options for startActiveObservation.\n *\n * @public\n */\nexport type StartActiveObservationOpts = StartObservationOpts & {\n  /** Whether to automatically end the observation when the function exits. Default: true */\n  endOnExit?: boolean;\n};\n\n/**\n * Wraps a Promise to automatically end the span when it resolves/rejects.\n *\n * @param promise - The promise to wrap\n * @param span - The OpenTelemetry span\n * @param endOnExit - Whether to end the span on exit\n * @returns The wrapped promise\n * @internal\n */\nfunction wrapPromise<T>(\n  promise: Promise<T>,\n  span: Span,\n  endOnExit: boolean | undefined,\n): Promise<T> {\n  return promise.then(\n    (value) => {\n      if (endOnExit !== false) {\n        span.end();\n      }\n      return value;\n    },\n    (err: unknown) => {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err instanceof Error ? err.message : \"Unknown error\",\n      });\n      if (endOnExit !== false) {\n        span.end();\n      }\n      throw err;\n    },\n  );\n}\n\n// Function overloads for startActiveObservation\nexport function startActiveObservation<\n  F extends (observation: ObservationSpan) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationLLM) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationEmbedding) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationAgent) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationTool) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationChain) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationRetriever) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationReranker) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationEvaluator) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationGuardrail) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\n\n/**\n * Creates an observation with automatic lifecycle management.\n *\n * This function creates an observation and executes a function with that observation\n * as a parameter. The observation is automatically ended when the function completes\n * (unless `endOnExit` is set to `false`).\n *\n * Supports both synchronous and asynchronous functions, with automatic error handling.\n *\n * @param name - Descriptive name for the observation\n * @param fn - Function to execute with the observation\n * @param options - Configuration options\n * @returns The result of the function\n *\n * @example\n * ```typescript\n * import { startActiveObservation } from './observability';\n *\n * // Synchronous function\n * const result = startActiveObservation('data-processing', (span) => {\n *   span.update({ input: { data: [1, 2, 3] } });\n *   const processed = data.map(x => x * 2);\n *   span.update({ output: { result: processed } });\n *   return processed;\n * }, { asType: 'span' });\n *\n * // Asynchronous function\n * const embeddings = await startActiveObservation(\n *   'text-embeddings',\n *   async (embedding) => {\n *     embedding.update({\n *       input: { texts: ['Hello', 'World'] },\n *       model: 'text-embedding-ada-002'\n *     });\n *\n *     const vectors = await generateEmbeddings(texts);\n *\n *     embedding.update({ output: { embeddings: vectors } });\n *     return vectors;\n *   },\n *   { asType: 'embedding' }\n * );\n *\n * // Disable automatic ending (for long-running operations)\n * startActiveObservation(\n *   'background-task',\n *   (span) => {\n *     span.update({ input: { taskId: '123' } });\n *     startBackgroundProcess(span);\n *     return 'started';\n *   },\n *   { asType: 'span', endOnExit: false }\n * );\n * ```\n *\n * @see {@link startObservation} for manual observation lifecycle management\n * @see {@link observe} for decorator-style function wrapping\n *\n * @public\n */\nexport function startActiveObservation<\n  F extends (observation: Observation) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F> {\n  const { asType = \"span\", endOnExit, ...observationOptions } = options || {};\n\n  return getTracer().startActiveSpan(\n    name,\n    { startTime: observationOptions?.startTime },\n    createParentContext(observationOptions?.parentSpanContext) ??\n      context.active(),\n    (span) => {\n      try {\n        let observation: Observation;\n\n        switch (asType) {\n          case \"llm\":\n            observation = new ObservationLLM({ otelSpan: span });\n            break;\n          case \"embedding\":\n            observation = new ObservationEmbedding({ otelSpan: span });\n            break;\n          case \"agent\":\n            observation = new ObservationAgent({ otelSpan: span });\n            break;\n          case \"tool\":\n            observation = new ObservationTool({ otelSpan: span });\n            break;\n          case \"chain\":\n            observation = new ObservationChain({ otelSpan: span });\n            break;\n          case \"retriever\":\n            observation = new ObservationRetriever({ otelSpan: span });\n            break;\n          case \"reranker\":\n            observation = new ObservationReranker({ otelSpan: span });\n            break;\n          case \"evaluator\":\n            observation = new ObservationEvaluator({ otelSpan: span });\n            break;\n          case \"guardrail\":\n            observation = new ObservationGuardrail({ otelSpan: span });\n            break;\n          case \"span\":\n          default:\n            observation = new ObservationSpan({ otelSpan: span });\n        }\n\n        const result = fn(observation as Parameters<F>[0]);\n\n        if (result instanceof Promise) {\n          return wrapPromise(\n            result,\n            span,\n            endOnExit,\n          ) as ReturnType<F>;\n        } else {\n          if (endOnExit !== false) {\n            span.end();\n          }\n          return result as ReturnType<F>;\n        }\n      } catch (err) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err instanceof Error ? err.message : \"Unknown error\",\n        });\n        if (endOnExit !== false) {\n          span.end();\n        }\n        throw err;\n      }\n    },\n  );\n}\n\n/**\n * Updates the currently active observation with new attributes.\n *\n * @param attributes - Observation attributes to set\n *\n * @example\n * ```typescript\n * import { updateActiveObservation } from './observability';\n *\n * // Within an active observation context\n * updateActiveObservation({\n *   metadata: { stage: 'processing' }\n * });\n * ```\n *\n * @public\n */\nexport function updateActiveObservation(\n  attributes: BaseSpanAttributes,\n): void {\n  const span = trace.getActiveSpan();\n\n  if (!span) {\n    console.warn(\n      \"[Observability] No active OTEL span in context. Skipping observation update.\",\n    );\n    return;\n  }\n\n  span.setAttributes(createObservationAttributes(\"span\", attributes));\n}\n\n// ============================================================================\n// Decorator Function\n// ============================================================================\n\n/**\n * Options for the observe decorator.\n *\n * @public\n */\nexport type ObserveOptions = Omit<StartObservationOpts, \"name\"> & {\n  /** Whether to capture function arguments as input. Default: true */\n  captureInput?: boolean;\n  /** Whether to capture return value as output. Default: true */\n  captureOutput?: boolean;\n};\n\n/**\n * Captures function arguments for observability input.\n *\n * @param args - Function arguments to capture\n * @returns Serialized arguments\n * @internal\n */\nfunction _captureArguments(args: unknown[]): Record<string, unknown> {\n  if (args.length === 0) return {};\n  if (args.length === 1) return { arg: args[0] };\n  return { args };\n}\n\n/**\n * Decorator function to add observability to any function.\n *\n * Wraps a function with automatic observation creation, input/output capture,\n * and lifecycle management. The observation is automatically ended when the\n * function completes.\n *\n * @param fn - Function to wrap\n * @param options - Configuration options\n * @returns Wrapped function with observability\n *\n * @example\n * ```typescript\n * import { observe } from './observability';\n *\n * // Wrap an existing function\n * const fetchData = observe(async (url: string) => {\n *   const response = await fetch(url);\n *   return response.json();\n * }, { asType: 'tool' });\n *\n * // Wrap with custom name\n * const processPayment = observe(\n *   async (amount: number, currency: string) => {\n *     return await paymentGateway.charge(amount, currency);\n *   },\n *   { name: 'payment-gateway-call', asType: 'tool' }\n * );\n *\n * // Class method decoration\n * class UserService {\n *   @observe({ asType: 'chain' })\n *   async getUser(id: string) {\n *     return await db.users.find(id);\n *   }\n * }\n * ```\n *\n * @public\n */\nexport function observe<T extends (...args: any[]) => any>(\n  fn: T,\n  options: ObserveOptions = {},\n): T {\n  const {\n    asType = \"span\",\n    captureInput = true,\n    captureOutput = true,\n    ...observationOptions\n  } = options;\n\n  const wrappedFunction = function (\n    this: any,\n    ...args: Parameters<T>\n  ): ReturnType<T> {\n    const name = fn.name || \"anonymous-function\";\n\n    // Prepare input data\n    const inputData = captureInput ? _captureArguments(args) : undefined;\n\n    // Create the observation\n    const observation = startObservation(\n      name,\n      inputData ? { input: inputData } : {},\n      {\n        ...observationOptions,\n        asType: asType as \"span\",\n      },\n    );\n\n    // Set the observation span as active in the context\n    const activeContext = trace.setSpan(context.active(), observation.otelSpan);\n\n    // Execute the function within the observation context\n    const result = context.with(activeContext, () => fn.apply(this, args));\n\n    // Handle promises\n    if (result instanceof Promise) {\n      return result.then(\n        (value) => {\n          if (captureOutput) {\n            observation.update({ output: value });\n          }\n          observation.end();\n          return value;\n        },\n        (err: unknown) => {\n          observation.update({\n            level: \"ERROR\",\n            statusMessage: err instanceof Error ? err.message : \"Unknown error\",\n          });\n          observation.end();\n          throw err;\n        },\n      ) as ReturnType<T>;\n    }\n\n    // Handle synchronous functions\n    if (captureOutput) {\n      observation.update({ output: result });\n    }\n    observation.end();\n\n    return result as ReturnType<T>;\n  };\n\n  // Preserve function properties\n  Object.defineProperty(wrappedFunction, \"name\", { value: fn.name });\n  Object.defineProperty(wrappedFunction, \"length\", { value: fn.length });\n\n  return wrappedFunction as T;\n}\n","/**\n * LangChain Callback Handler for AG-Kit Observability\n *\n * Converts LangChain callback events into AG-Kit observations with OpenInference semantics.\n */\n\nimport type { AgentAction, AgentFinish } from \"@langchain/core/agents\";\nimport { BaseCallbackHandler } from \"@langchain/core/callbacks/base\";\nimport type { Document } from \"@langchain/core/documents\";\nimport type { Serialized } from \"@langchain/core/load/serializable\";\nimport {\n  AIMessage,\n  AIMessageChunk,\n  BaseMessage,\n  type UsageMetadata,\n  type BaseMessageFields,\n  type MessageContent,\n} from \"@langchain/core/messages\";\nimport type { Generation, LLMResult } from \"@langchain/core/outputs\";\nimport type { ChainValues } from \"@langchain/core/utils/types\";\n\nimport {\n  startObservation,\n  type ObservationLLM,\n  type ObservationSpan,\n  type ObservationTool,\n  type Observation,\n  type ObservationAttributes,\n} from \"../index.js\";\nimport type { SpanContext } from \"@opentelemetry/api\";\nimport { type Logger, noopLogger } from \"@cloudbase/agent-shared\";\n\n/**\n * Constructor parameters for CallbackHandler.\n *\n * @public\n */\ntype ConstructorParams = {\n  userId?: string;\n  sessionId?: string;\n  tags?: string[];\n  version?: string;\n  traceMetadata?: Record<string, unknown>;\n  adapterName?: string;  // e.g., \"LangGraph\" or \"LangChain\"\n  /** Logger for debug output. Defaults to noopLogger (silent). */\n  logger?: Logger;\n};\n\n/**\n * Message format for LLM input/output.\n *\n * @public\n */\nexport type LlmMessage = {\n  role: string;\n  content: BaseMessageFields[\"content\"];\n  additional_kwargs?: BaseMessageFields[\"additional_kwargs\"];\n};\n\n/**\n * Anonymous message format (without role).\n *\n * @public\n */\nexport type AnonymousLlmMessage = {\n  content: BaseMessageFields[\"content\"];\n  additional_kwargs?: BaseMessageFields[\"additional_kwargs\"];\n};\n\n/**\n * Prompt information for linking to generations.\n *\n * @public\n */\ntype PromptInfo = {\n  name: string;\n  version: number;\n  isFallback: boolean;\n};\n\n/**\n * LangChain Callback Handler for AG-Kit Observability.\n *\n * This handler intercepts LangChain callbacks and converts them into\n * AG-Kit observations following OpenInference semantic conventions.\n *\n * @public\n */\nexport class CallbackHandler extends BaseCallbackHandler {\n  name = \"ObservabilityCallbackHandler\";\n\n  private userId?: string;\n  private version?: string;\n  private sessionId?: string;\n  private tags: string[];\n  private traceMetadata?: Record<string, unknown>;\n\n  private completionStartTimes: Record<string, Date> = {};\n  private promptToParentRunMap;\n  private runMap: Map<string, Observation> = new Map();\n\n  public last_trace_id: string | null = null;\n\n  // External parent context from AG-UI.Server span\n  private externalParentSpanContext?: SpanContext;\n\n  // Adapter name for ROOT span prefix\n  private adapterName?: string;\n\n  // Logger for debug output (defaults to noopLogger for silent operation)\n  private logger: Logger;\n\n  constructor(params?: ConstructorParams) {\n    super();\n\n    this.sessionId = params?.sessionId;\n    this.userId = params?.userId;\n    this.tags = params?.tags ?? [];\n    this.traceMetadata = params?.traceMetadata;\n    this.version = params?.version;\n    this.adapterName = params?.adapterName;\n    this.logger = params?.logger ?? noopLogger;\n\n    this.promptToParentRunMap = new Map<string, PromptInfo>();\n  }\n\n  /**\n   * Set external parent SpanContext from AG-UI.Server span.\n   * This allows the CallbackHandler to link LangChain/LangGraph spans\n   * to the server-level span, creating a unified trace hierarchy.\n   *\n   * @param spanContext - SpanContext from the AG-UI.Server span\n   * @public\n   */\n  setExternalParentContext(spanContext: SpanContext): void {\n    this.externalParentSpanContext = spanContext;\n  }\n\n  async handleLLMNewToken(\n    token: string,\n    _idx: any,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    _fields?: any\n  ): Promise<void> {\n    if (runId && !(runId in this.completionStartTimes)) {\n      this.logger.debug?.(`LLM first streaming token: ${runId}`);\n      this.completionStartTimes[runId] = new Date();\n    }\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    runType?: string,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Chain start with Id: ${runId}`);\n\n      const runName = name ?? chain.id.at(-1)?.toString() ?? \"Langchain Run\";\n\n      this.registerPromptInfo(parentRunId, metadata);\n\n      let finalInput: string | ChainValues = inputs;\n      if (\n        typeof inputs === \"object\" &&\n        \"input\" in inputs &&\n        Array.isArray(inputs[\"input\"]) &&\n        inputs[\"input\"].every((m: unknown) => m instanceof BaseMessage)\n      ) {\n        finalInput = inputs[\"input\"].map((m: BaseMessage) =>\n          this.extractChatMessageContent(m)\n        );\n      } else if (\n        typeof inputs === \"object\" &&\n        \"messages\" in inputs &&\n        Array.isArray(inputs[\"messages\"]) &&\n        inputs[\"messages\"].every((m: unknown) => m instanceof BaseMessage)\n      ) {\n        finalInput = inputs[\"messages\"].map((m: BaseMessage) =>\n          this.extractChatMessageContent(m)\n        );\n      } else if (\n        typeof inputs === \"object\" &&\n        \"content\" in inputs &&\n        typeof inputs[\"content\"] === \"string\"\n      ) {\n        finalInput = inputs[\"content\"];\n      }\n\n      const observation = this.startAndRegisterObservation({\n        runName,\n        parentRunId,\n        runId,\n        tags,\n        metadata,\n        attributes: {\n          input: finalInput,\n        },\n        asType: \"span\",\n      });\n\n      const traceTags = [...new Set([...(tags ?? []), ...this.tags])];\n\n      if (!parentRunId) {\n        observation.updateTrace({\n          tags: traceTags,\n          userId:\n            metadata &&\n            \"userId\" in metadata &&\n            typeof metadata[\"userId\"] === \"string\"\n              ? metadata[\"userId\"]\n              : this.userId,\n          sessionId:\n            metadata &&\n            \"sessionId\" in metadata &&\n            typeof metadata[\"sessionId\"] === \"string\"\n              ? metadata[\"sessionId\"]\n              : this.sessionId,\n          metadata: this.traceMetadata,\n          version: this.version,\n        });\n      }\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleAgentAction(\n    action: AgentAction,\n    runId: string,\n    parentRunId?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Agent action ${action.tool} with ID: ${runId}`);\n      this.startAndRegisterObservation({\n        runId,\n        parentRunId,\n        runName: action.tool,\n        attributes: {\n          input: action,\n        },\n        asType: \"tool\",\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleAgentEnd?(\n    action: AgentFinish,\n    runId: string,\n    _parentRunId?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Agent finish with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: { output: action },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleChainError(\n    err: any,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Chain error: ${err} with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          level: \"ERROR\",\n          statusMessage: err.toString(),\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleGenerationStart(\n    llm: Serialized,\n    messages: (LlmMessage | MessageContent | AnonymousLlmMessage)[],\n    runId: string,\n    parentRunId?: string | undefined,\n    extraParams?: Record<string, unknown> | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    this.logger.debug?.(\n      `Generation start with ID: ${runId} and parentRunId ${parentRunId}`\n    );\n\n    const runName = name ?? llm.id.at(-1)?.toString() ?? \"Langchain Generation\";\n\n    const modelParameters: Record<string, any> = {};\n    const invocationParams = extraParams?.[\"invocation_params\"];\n\n    for (const [key, value] of Object.entries({\n      temperature: (invocationParams as any)?.temperature,\n      max_tokens: (invocationParams as any)?.max_tokens,\n      top_p: (invocationParams as any)?.top_p,\n      frequency_penalty: (invocationParams as any)?.frequency_penalty,\n      presence_penalty: (invocationParams as any)?.presence_penalty,\n      request_timeout: (invocationParams as any)?.request_timeout,\n    })) {\n      if (value !== undefined && value !== null) {\n        modelParameters[key] = value;\n      }\n    }\n\n    interface InvocationParams {\n      _type?: string;\n      model?: string;\n      model_name?: string;\n      repo_id?: string;\n    }\n\n    let extractedModelName: string | undefined;\n    if (extraParams) {\n      const invocationParamsModelName = (\n        extraParams.invocation_params as InvocationParams\n      ).model;\n      const metadataModelName =\n        metadata && \"ls_model_name\" in metadata\n          ? (metadata[\"ls_model_name\"] as string)\n          : undefined;\n\n      extractedModelName = invocationParamsModelName ?? metadataModelName;\n    }\n\n    const registeredPrompt = this.promptToParentRunMap.get(\n      parentRunId ?? \"root\"\n    );\n    if (registeredPrompt && parentRunId) {\n      this.deregisterPromptInfo(parentRunId);\n    }\n\n    this.startAndRegisterObservation({\n      runId,\n      parentRunId,\n      metadata,\n      tags,\n      runName,\n      attributes: {\n        input: messages,\n        model: extractedModelName,\n        modelParameters: modelParameters,\n      },\n      asType: \"llm\",\n    });\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string | undefined,\n    extraParams?: Record<string, unknown> | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Chat model start with ID: ${runId}`);\n\n      const prompts = messages.flatMap((message) =>\n        message.map((m) => this.extractChatMessageContent(m))\n      );\n\n      this.handleGenerationStart(\n        llm,\n        prompts,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleChainEnd(\n    outputs: ChainValues,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Chain end with ID: ${runId}`);\n\n      let finalOutput: ChainValues | string = outputs;\n      if (\n        typeof outputs === \"object\" &&\n        \"output\" in outputs &&\n        typeof outputs[\"output\"] === \"string\"\n      ) {\n        finalOutput = outputs[\"output\"];\n      } else if (\n        typeof outputs === \"object\" &&\n        \"messages\" in outputs &&\n        Array.isArray(outputs[\"messages\"]) &&\n        outputs[\"messages\"].every((m: unknown) => m instanceof BaseMessage)\n      ) {\n        finalOutput = {\n          messages: outputs.messages.map((message: BaseMessage) =>\n            this.extractChatMessageContent(message)\n          ),\n        };\n      }\n\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          output: finalOutput,\n        },\n      });\n      this.deregisterPromptInfo(runId);\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string | undefined,\n    extraParams?: Record<string, unknown> | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`LLM start with ID: ${runId}`);\n      this.handleGenerationStart(\n        llm,\n        prompts,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Tool start with ID: ${runId}`);\n      this.startAndRegisterObservation({\n        runId,\n        parentRunId,\n        runName: name ?? tool.id.at(-1)?.toString() ?? \"Tool execution\",\n        attributes: {\n          input,\n        },\n        metadata,\n        tags,\n        asType: \"tool\",\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Retriever start with ID: ${runId}`);\n      this.startAndRegisterObservation({\n        runId,\n        parentRunId,\n        runName: name ?? retriever.id.at(-1)?.toString() ?? \"Retriever\",\n        attributes: {\n          input: query,\n        },\n        tags,\n        metadata,\n        asType: \"span\",\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleRetrieverEnd(\n    documents: Document<Record<string, any>>[],\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Retriever end with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          output: documents,\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleRetrieverError(\n    err: any,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Retriever error: ${err} with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          level: \"ERROR\",\n          statusMessage: err.toString(),\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleToolEnd(\n    output: string,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Tool end with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: { output },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleToolError(\n    err: any,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Tool error ${err} with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          level: \"ERROR\",\n          statusMessage: err.toString(),\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleLLMEnd(\n    output: LLMResult,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`LLM end with ID: ${runId}`);\n\n      const lastResponse =\n        output.generations[output.generations.length - 1][\n          output.generations[output.generations.length - 1].length - 1\n        ];\n      const llmUsage =\n        this.extractUsageMetadata(lastResponse) ??\n        output.llmOutput?.[\"tokenUsage\"];\n      const modelName = this.extractModelNameFromMetadata(lastResponse);\n\n      const usageDetails: Record<string, any> = {\n        input:\n          llmUsage?.input_tokens ??\n          (\"promptTokens\" in llmUsage ? llmUsage?.promptTokens : undefined),\n        output:\n          llmUsage?.output_tokens ??\n          (\"completionTokens\" in llmUsage\n            ? llmUsage?.completionTokens\n            : undefined),\n        total:\n          llmUsage?.total_tokens ??\n          (\"totalTokens\" in llmUsage ? llmUsage?.totalTokens : undefined),\n      };\n\n      if (llmUsage && \"input_token_details\" in llmUsage) {\n        for (const [key, val] of Object.entries(\n          llmUsage[\"input_token_details\"] ?? {}\n        )) {\n          usageDetails[`input_${key}`] = val;\n          if (\"input\" in usageDetails && typeof val === \"number\") {\n            usageDetails[\"input\"] = Math.max(0, usageDetails[\"input\"] - val);\n          }\n        }\n      }\n\n      if (llmUsage && \"output_token_details\" in llmUsage) {\n        for (const [key, val] of Object.entries(\n          llmUsage[\"output_token_details\"] ?? {}\n        )) {\n          usageDetails[`output_${key}`] = val;\n          if (\"output\" in usageDetails && typeof val === \"number\") {\n            usageDetails[\"output\"] = Math.max(0, usageDetails[\"output\"] - val);\n          }\n        }\n      }\n\n      const extractedOutput =\n        \"message\" in lastResponse\n          ? this.extractChatMessageContent(\n              lastResponse[\"message\"] as BaseMessage\n            )\n          : lastResponse.text;\n\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          model: modelName,\n          output: extractedOutput,\n          completionStartTime:\n            runId in this.completionStartTimes\n              ? this.completionStartTimes[runId]\n              : undefined,\n          usageDetails: usageDetails,\n        },\n      });\n\n      if (runId in this.completionStartTimes) {\n        delete this.completionStartTimes[runId];\n      }\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleLLMError(\n    err: any,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`LLM error ${err} with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          level: \"ERROR\",\n          statusMessage: err.toString(),\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  private registerPromptInfo(\n    parentRunId?: string,\n    metadata?: Record<string, unknown>\n  ): void {\n    if (metadata && \"promptInfo\" in metadata && parentRunId) {\n      this.promptToParentRunMap.set(\n        parentRunId,\n        metadata.promptInfo as PromptInfo\n      );\n    }\n  }\n\n  private deregisterPromptInfo(runId: string): void {\n    this.promptToParentRunMap.delete(runId);\n  }\n\n  private startAndRegisterObservation(params: {\n    runName: string;\n    runId: string;\n    parentRunId?: string;\n    attributes: Record<string, unknown>;\n    metadata?: Record<string, unknown>;\n    tags?: string[];\n    asType?: \"span\" | \"llm\" | \"tool\";\n  }): Observation {\n    const { runName, runId, parentRunId, attributes, metadata, tags, asType } =\n      params;\n\n    // Determine parent context:\n    // 1. If parentRunId exists, use the parent span from runMap (internal LangChain/LangGraph hierarchy)\n    // 2. If no parentRunId (ROOT span) but externalParentSpanContext exists, use it (link to AG-UI.Server)\n    // 3. Otherwise, create a new root span\n    let parentSpanContext: SpanContext | undefined;\n\n    if (parentRunId) {\n      // Internal parent from LangChain/LangGraph\n      parentSpanContext = this.runMap.get(parentRunId)?.otelSpan.spanContext();\n    } else if (this.externalParentSpanContext) {\n      // External parent from AG-UI.Server\n      parentSpanContext = this.externalParentSpanContext;\n    }\n\n    // Add adapter name prefix to ROOT span\n    let finalRunName = runName;\n    if (!parentRunId && this.adapterName) {\n      // ROOT span: add Adapter.LangGraph or Adapter.LangChain prefix\n      finalRunName = `Adapter.${this.adapterName}`;\n    }\n\n    const observation = startObservation(\n      finalRunName,\n      {\n        version: this.version,\n        metadata: this.joinTagsAndMetaData(tags, metadata),\n        ...attributes,\n      },\n      {\n        asType: asType ?? \"span\",\n        parentSpanContext,\n      }\n    );\n    this.runMap.set(runId, observation);\n\n    return observation;\n  }\n\n  private handleObservationEnd(params: {\n    runId: string;\n    attributes?: Record<string, unknown>;\n  }) {\n    const { runId, attributes = {} } = params;\n\n    const observation = this.runMap.get(runId);\n    if (!observation) {\n      this.logger.warn?.(\"Observation not found in runMap. Skipping operation.\");\n      return;\n    }\n\n    // Type-safe update: cast to ObservationAttributes which is the union of all observation attribute types\n    observation.update(attributes as ObservationAttributes).end();\n\n    this.last_trace_id = observation.traceId;\n    this.runMap.delete(runId);\n  }\n\n  private joinTagsAndMetaData(\n    tags?: string[] | undefined,\n    metadata1?: Record<string, unknown> | undefined,\n    metadata2?: Record<string, unknown> | undefined\n  ): Record<string, unknown> | undefined {\n    const finalDict: Record<string, unknown> = {};\n    if (tags && tags.length > 0) {\n      finalDict.tags = tags;\n    }\n    if (metadata1) {\n      Object.assign(finalDict, metadata1);\n    }\n    if (metadata2) {\n      Object.assign(finalDict, metadata2);\n    }\n    return this.stripObservabilityKeysFromMetadata(finalDict);\n  }\n\n  private stripObservabilityKeysFromMetadata(\n    metadata?: Record<string, unknown>\n  ): Record<string, unknown> | undefined {\n    if (!metadata) {\n      return;\n    }\n\n    const reservedKeys = [\"promptInfo\", \"userId\", \"sessionId\"];\n\n    return Object.fromEntries(\n      Object.entries(metadata).filter(([key, _]) => !reservedKeys.includes(key))\n    );\n  }\n\n  private extractUsageMetadata(\n    generation: Generation\n  ): UsageMetadata | undefined {\n    try {\n      const usageMetadata =\n        \"message\" in generation &&\n        (AIMessage.isInstance(generation[\"message\"]) ||\n          AIMessageChunk.isInstance(generation[\"message\"]))\n          ? generation[\"message\"].usage_metadata\n          : undefined;\n      return usageMetadata;\n    } catch (err) {\n      this.logger.debug?.(`Error extracting usage metadata: ${err}`);\n      return;\n    }\n  }\n\n  private extractModelNameFromMetadata(generation: any): string | undefined {\n    try {\n      return \"message\" in generation &&\n        (AIMessage.isInstance(generation[\"message\"]) ||\n          AIMessageChunk.isInstance(generation[\"message\"]))\n        ? generation[\"message\"].response_metadata.model_name\n        : undefined;\n    } catch {}\n  }\n\n  private extractChatMessageContent(\n    message: BaseMessage\n  ): LlmMessage | AnonymousLlmMessage | MessageContent {\n    let response = undefined;\n\n    if (message.getType() === \"human\") {\n      response = { content: message.content, role: \"user\" };\n    } else if (message.getType() === \"generic\") {\n      response = {\n        content: message.content,\n        role: \"human\",\n      };\n    } else if (message.getType() === \"ai\") {\n      response = { content: message.content, role: \"assistant\" };\n\n      if (\n        \"tool_calls\" in message &&\n        Array.isArray(message.tool_calls) &&\n        (message.tool_calls?.length ?? 0) > 0\n      ) {\n        (response as any)[\"tool_calls\"] = message[\"tool_calls\"];\n      }\n      if (\n        \"additional_kwargs\" in message &&\n        \"tool_calls\" in message[\"additional_kwargs\"]\n      ) {\n        (response as any)[\"tool_calls\"] =\n          message[\"additional_kwargs\"][\"tool_calls\"];\n      }\n    } else if (message.getType() === \"system\") {\n      response = { content: message.content, role: \"system\" };\n    } else if (message.getType() === \"function\") {\n      response = {\n        content: message.content,\n        additional_kwargs: message.additional_kwargs,\n        role: message.name,\n      };\n    } else if (message.getType() === \"tool\") {\n      response = {\n        content: message.content,\n        additional_kwargs: message.additional_kwargs,\n        role: message.name,\n      };\n    } else if (!message.name) {\n      response = { content: message.content };\n    } else {\n      response = {\n        role: message.name,\n        content: message.content,\n      };\n    }\n\n    if (\n      (message.additional_kwargs.function_call ||\n        message.additional_kwargs.tool_calls) &&\n      (response as any)[\"tool_calls\"] === undefined\n    ) {\n      return { ...response, additional_kwargs: message.additional_kwargs };\n    }\n\n    return response;\n  }\n}\n","export * from \"./agent\";\nexport { TDAISaver, type TDAISaverConfig } from \"./checkpoint\";\nexport { TDAIStore, type TDAIStoreConfig } from \"./store/tdai-store\";\n\n// Re-export Logger from shared for convenience\nexport { type Logger, noopLogger, createConsoleLogger } from \"@cloudbase/agent-shared\";\n","import {\n  RunAgentInput,\n  Message,\n  ToolCall,\n  BaseEvent,\n  EventType,\n  RunStartedEvent,\n  RunFinishedEvent,\n  RunErrorEvent,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  AbstractAgent,\n  AgentConfig,\n} from \"@ag-ui/client\";\n\nimport { Message as LangGraphMessage } from \"@langchain/langgraph-sdk\";\n\nimport { Observable, Subscriber } from \"rxjs\";\n\nimport {\n  Annotation,\n  AnnotationRoot,\n  StateDefinition,\n  StateGraph,\n  MessagesAnnotation,\n  Command,\n} from \"@langchain/langgraph\";\nimport { InteropZodObject } from \"@langchain/core/utils/types\";\nimport { convertActionsToDynamicStructuredTools } from \"./util\";\nimport { Logger, noopLogger, isErrorWithCode } from \"@cloudbase/agent-shared\";\n\n// Import observability callback (optional)\n// Will be loaded asynchronously on first use\nlet LangChainCallbackHandler: any;\nlet observabilityLoadAttempted = false;\n\ntype SDZod = StateDefinition | InteropZodObject;\n\ntype CompiledStateGraph<SD extends SDZod> = ReturnType<\n  StateGraph<SD>[\"compile\"]\n>;\n\ntype AnnotationInside<T> = T extends AnnotationRoot<infer U> ? U : never;\n\ntype ClientStateDefinition = AnnotationInside<typeof ClientStateAnnotation>;\n\nexport const ClientPropertiesAnnotation = Annotation.Root({\n  tools: Annotation<any[]>,\n});\n\nexport const ClientStateAnnotation = Annotation.Root({\n  client: Annotation<typeof ClientPropertiesAnnotation.State>,\n  ...MessagesAnnotation.spec,\n});\n\nexport type ClientState = typeof ClientStateAnnotation.State;\n\nexport class LanggraphAgent extends AbstractAgent {\n  compiledWorkflow?: CompiledStateGraph<ClientStateDefinition>;\n  private observabilityCallback?: any;\n  private adapterName: string;\n  private logger: Logger;\n\n  constructor(\n    agentConfig: AgentConfig & {\n      compiledWorkflow: any;\n      adapterName?: string;  // Optional: e.g., \"LangGraph\" or \"LangChain\"\n      /**\n       * Logger instance for structured logging.\n       * @default noopLogger (silent)\n       */\n      logger?: Logger;\n    }\n  ) {\n    super(agentConfig);\n    this.compiledWorkflow =\n      agentConfig.compiledWorkflow as CompiledStateGraph<ClientStateDefinition>;\n    // Observability callback will be lazily loaded in _run method\n    this.adapterName = agentConfig.adapterName || \"LangGraph\";\n\n    // Create component-specific child logger\n    const baseLogger = agentConfig.logger ?? noopLogger;\n    this.logger =\n      baseLogger.child?.({ component: \"langgraph-agent\" }) ?? baseLogger;\n  }\n\n  run(input: RunAgentInput) {\n    return new Observable<BaseEvent>((subscriber) => {\n      this._run(subscriber, input);\n    });\n  }\n\n  async _run(subscriber: Subscriber<BaseEvent>, input: RunAgentInput) {\n    const { messages, runId, threadId } = input;\n\n    // Create run-specific child logger with context\n    const logger = this.logger.child?.({ runId, threadId }) ?? this.logger;\n\n    logger.info?.(\"Run started\");\n\n    // Lazy load observability callback if not already attempted\n    if (!observabilityLoadAttempted && !this.observabilityCallback) {\n      observabilityLoadAttempted = true;\n      try {\n        logger.debug?.(\"Attempting to load observability...\");\n        const obsModule = await import(\"@cloudbase/agent-observability/langchain\");\n        LangChainCallbackHandler = obsModule.CallbackHandler;\n        if (LangChainCallbackHandler) {\n          this.observabilityCallback = new LangChainCallbackHandler({\n            adapterName: this.adapterName,\n            logger: logger,  // Reuse the run-specific logger with context\n          });\n          logger.debug?.(\" Observability callback created\");\n        }\n      } catch (e) {\n        logger.debug?.(\n          \" Observability not available:\",\n          e instanceof Error ? e.message : String(e)\n        );\n      }\n    }\n\n    // ============================================\n    // Observability: Restore server SpanContext\n    // ============================================\n    if (this.observabilityCallback && input.forwardedProps?.__agui_server_context) {\n      try {\n        const serverContextData = input.forwardedProps.__agui_server_context;\n\n        // Reconstruct SpanContext from serialized data\n        const serverSpanContext = {\n          traceId: serverContextData.traceId,\n          spanId: serverContextData.spanId,\n          traceFlags: serverContextData.traceFlags,\n          isRemote: false,\n        };\n\n        // Set external parent context in CallbackHandler\n        this.observabilityCallback.setExternalParentContext(serverSpanContext);\n\n        logger.debug?.(\" Server context restored:\", {\n          traceId: serverSpanContext.traceId,\n          spanId: serverSpanContext.spanId,\n        });\n      } catch (e) {\n        logger.debug?.(\"Failed to restore server context:\", e);\n      }\n    }\n\n\n    const runStartedEvent: RunStartedEvent = {\n      type: EventType.RUN_STARTED,\n      threadId,\n      runId,\n    };\n    logger.trace?.({ aguiEvent: runStartedEvent }, \"Emitting AGUI event\");\n    subscriber.next(runStartedEvent);\n\n    const isResume = !!input.forwardedProps?.resume;\n\n    // DEBUG: summary of input\n    const lastUserMessage = messages.filter((m) => m.role === \"user\").pop();\n    logger.debug?.(\n      {\n        isResume,\n        messageCount: messages.length,\n        toolCount: input.tools?.length ?? 0,\n        tools: input.tools?.map((t) => t.name),\n        lastUserMessage:\n          typeof lastUserMessage?.content === \"string\"\n            ? lastUserMessage.content.slice(0, 200)\n            : undefined,\n      },\n      \"Preparing stream input\"\n    );\n\n    // TRACE: full input\n    logger.trace?.({ messages, tools: input.tools }, \"Full input messages\");\n\n    // Convert messages to LangGraph format\n    const langChainMessages = isResume ? undefined : aguiMessagesToLangChain(messages);\n\n    // TRACE: converted LangGraph messages for debugging message ordering issues\n    if (langChainMessages) {\n      logger.trace?.(\n        {\n          langChainMessages,\n          messageCount: langChainMessages.length,\n          messageTypes: langChainMessages.map((m) => ({\n            type: m.type,\n            id: m.id,\n            hasToolCalls: \"tool_calls\" in m && Array.isArray(m.tool_calls) && m.tool_calls.length > 0,\n            toolCallId: \"tool_call_id\" in m ? m.tool_call_id : undefined,\n          })),\n        },\n        \"Converted LangGraph messages\"\n      );\n    }\n\n    const streamEventInput = isResume\n      ? new Command<unknown, Partial<ClientState>, \"__start__\">({\n          resume: JSON.stringify(input.forwardedProps?.resume?.payload),\n        })\n      : {\n          messages: langChainMessages,\n          client: {\n            tools: convertActionsToDynamicStructuredTools(\n              input.tools.map((x) => ({\n                ...x,\n                parameters:\n                  typeof x.parameters === \"string\"\n                    ? JSON.parse(x.parameters)\n                    : x.parameters,\n              }))\n            ),\n          },\n        };\n\n    const stream = this.compiledWorkflow!.streamEvents(streamEventInput, {\n      version: \"v2\",\n      ...(this.observabilityCallback\n        ? { callbacks: [this.observabilityCallback] }\n        : {}),\n      runId,\n      configurable: {\n        thread_id: threadId,\n      },\n    });\n\n    logger.debug?.(\"Stream created, starting event processing\");\n\n    const chatModelRuns: Array<{ runId: string; messageId?: string }> = [];\n\n    // Pre-populate handledToolCallIds with tool call IDs from INPUT messages.\n    // This prevents emitting duplicate TOOL_CALL_RESULT events for tool results\n    // that were already processed in a previous run and are now being sent back\n    // by the client as part of the message history.\n    const handledToolCallIds: Set<string> = new Set();\n    for (const msg of messages) {\n      if (msg.role === \"tool\" && msg.toolCallId) {\n        handledToolCallIds.add(msg.toolCallId);\n      }\n    }\n    if (handledToolCallIds.size > 0) {\n      logger.debug?.(\n        { count: handledToolCallIds.size },\n        \"Pre-populated handled tool call IDs from input messages\"\n      );\n    }\n\n    let interrupt:\n      | undefined\n      | {\n          id: string;\n          reason: string;\n          payload: unknown;\n        };\n\n    let currentToolCall: { name: string; args: string; id: string } | null =\n      null;\n\n    // Statistics for run summary\n    let eventCount = 0;\n    let toolCallCount = 0;\n    let textChunkCount = 0;\n\n    try {\n      for await (const event of stream) {\n        eventCount++;\n        // TRACE: full LangGraph event\n        logger.trace?.(\n          { eventType: event.event, eventCount, langGraphEvent: event },\n          \"Processing stream event\"\n        );\n\n        if (event.event.startsWith(\"ChannelWrite<\")) {\n          continue;\n        }\n\n        if (event.event === \"on_chat_model_start\") {\n          logger.debug?.(\n            { chatModelRunId: event.run_id },\n            \"Chat model started\"\n          );\n          chatModelRuns.push({ runId: event.run_id });\n          continue;\n        }\n\n        if (event.event === \"on_chat_model_stream\") {\n          // First, find or create chatModelRun and ensure messageId is set\n          // This must happen BEFORE processing tool_call_chunks so we have parentMessageId\n          const chatModelRun = chatModelRuns.find(\n            (run) => run.runId === event.run_id\n          );\n          if (!chatModelRun) {\n            logger.warn?.(\n              { chatModelRunId: event.run_id },\n              \"Received message from unknown chat model run\"\n            );\n            subscriber.next({\n              type: EventType.RUN_ERROR,\n              code: \"INTERNAL_ERROR\",\n              message: `Received a message from an unknown chat model run. Run Id: ${event.run_id}`,\n            } as RunErrorEvent);\n            continue;\n          }\n\n          // Initialize messageId if not set yet\n          const chunkId = event.data.chunk.id;\n          if (!chatModelRun.messageId) {\n            chatModelRun.messageId = chunkId;\n            const textStartEvent: TextMessageStartEvent = {\n              messageId: chunkId,\n              type: EventType.TEXT_MESSAGE_START,\n              role: \"assistant\",\n            };\n            logger.debug?.({ messageId: chunkId }, \"Text message started\");\n            logger.trace?.(\n              { aguiEvent: textStartEvent },\n              \"Emitting AGUI event\"\n            );\n            subscriber.next(textStartEvent);\n          } else if (chatModelRun.messageId !== chunkId) {\n            logger.warn?.(\n              {\n                expectedMessageId: chatModelRun.messageId,\n                receivedMessageId: chunkId,\n                chatModelRunId: event.run_id,\n              },\n              \"Received message with unexpected ID\"\n            );\n            subscriber.next({\n              type: EventType.RUN_ERROR,\n              code: \"INTERNAL_ERROR\",\n              message: `Received a message of unknown message id from current run. Run Id: ${event.run_id} Message Id from current run: ${chatModelRun.messageId} Message Id from received message: ${chunkId}`,\n            } as RunErrorEvent);\n            continue;\n          }\n\n          // Now process tool_call_chunks with parentMessageId available\n          if (\n            Array.isArray(event.data.chunk?.tool_call_chunks) &&\n            event.data.chunk?.tool_call_chunks?.length > 0\n          ) {\n            const parentMessageId = chatModelRun.messageId;\n            (\n              event.data.chunk.tool_call_chunks as Array<{\n                name: string;\n                args: unknown;\n                id: string;\n              }>\n            )\n              .map((x) => ({\n                ...x,\n                args:\n                  typeof x.args === \"string\"\n                    ? x.args\n                    : x.args\n                      ? JSON.stringify(x.args)\n                      : \"\",\n              }))\n              .forEach((toolCall) => {\n                if (currentToolCall) {\n                  if (toolCall.id && currentToolCall.id !== toolCall.id) {\n                    // end the current tool call\n                    const toolEndEvent: ToolCallEndEvent = {\n                      toolCallId: currentToolCall.id,\n                      type: EventType.TOOL_CALL_END,\n                    };\n                    logger.debug?.(\n                      {\n                        toolCallId: currentToolCall.id,\n                        toolCallName: currentToolCall.name,\n                      },\n                      \"Tool call ended\"\n                    );\n                    logger.trace?.(\n                      { aguiEvent: toolEndEvent },\n                      \"Emitting AGUI event\"\n                    );\n                    subscriber.next(toolEndEvent);\n\n                    // set the new tool call as the current tool call\n                    if (toolCall.name && toolCall.id) {\n                      currentToolCall = toolCall;\n                      toolCallCount++;\n                      const toolStartEvent: ToolCallStartEvent = {\n                        toolCallId: currentToolCall.id,\n                        toolCallName: currentToolCall.name,\n                        parentMessageId,\n                        type: EventType.TOOL_CALL_START,\n                      };\n                      logger.debug?.(\n                        {\n                          toolCallId: toolCall.id,\n                          toolCallName: toolCall.name,\n                        },\n                        \"Tool call started\"\n                      );\n                      logger.trace?.(\n                        { aguiEvent: toolStartEvent },\n                        \"Emitting AGUI event\"\n                      );\n                      subscriber.next(toolStartEvent);\n                      if (currentToolCall.args) {\n                        const toolArgsEvent: ToolCallArgsEvent = {\n                          toolCallId: currentToolCall.id,\n                          delta: currentToolCall.args,\n                          type: EventType.TOOL_CALL_ARGS,\n                        };\n                        logger.trace?.(\n                          { aguiEvent: toolArgsEvent },\n                          \"Emitting AGUI event\"\n                        );\n                        subscriber.next(toolArgsEvent);\n\n                        if (isValidJson(currentToolCall.args)) {\n                          // args is valid json, tool call streaming ends\n                          const toolEndEvent2: ToolCallEndEvent = {\n                            toolCallId: currentToolCall.id,\n                            type: EventType.TOOL_CALL_END,\n                          };\n                          logger.debug?.(\n                            { toolCallId: currentToolCall.id },\n                            \"Tool call ended (args complete)\"\n                          );\n                          logger.trace?.(\n                            { aguiEvent: toolEndEvent2 },\n                            \"Emitting AGUI event\"\n                          );\n                          subscriber.next(toolEndEvent2);\n                          currentToolCall = null;\n                        }\n                      }\n                    }\n                  } else {\n                    // update the current tool call\n                    if (toolCall.args) {\n                      currentToolCall.args += toolCall.args;\n                      const toolArgsEvent: ToolCallArgsEvent = {\n                        toolCallId: currentToolCall.id,\n                        delta: toolCall.args,\n                        type: EventType.TOOL_CALL_ARGS,\n                      };\n                      logger.trace?.(\n                        { aguiEvent: toolArgsEvent },\n                        \"Emitting AGUI event\"\n                      );\n                      subscriber.next(toolArgsEvent);\n\n                      if (isValidJson(currentToolCall.args)) {\n                        // args is valid json, tool call streaming ends\n                        const toolEndEvent: ToolCallEndEvent = {\n                          toolCallId: currentToolCall.id,\n                          type: EventType.TOOL_CALL_END,\n                        };\n                        logger.debug?.(\n                          { toolCallId: currentToolCall.id },\n                          \"Tool call ended (args complete)\"\n                        );\n                        logger.trace?.(\n                          { aguiEvent: toolEndEvent },\n                          \"Emitting AGUI event\"\n                        );\n                        subscriber.next(toolEndEvent);\n                        currentToolCall = null;\n                      }\n                    }\n                  }\n                } else {\n                  if (toolCall.name && toolCall.id) {\n                    currentToolCall = toolCall;\n                    toolCallCount++;\n                    const toolStartEvent: ToolCallStartEvent = {\n                      toolCallId: toolCall.id,\n                      toolCallName: toolCall.name,\n                      parentMessageId,\n                      type: EventType.TOOL_CALL_START,\n                    };\n                    logger.debug?.(\n                      { toolCallId: toolCall.id, toolCallName: toolCall.name },\n                      \"Tool call started\"\n                    );\n                    logger.trace?.(\n                      { aguiEvent: toolStartEvent },\n                      \"Emitting AGUI event\"\n                    );\n                    subscriber.next(toolStartEvent);\n                    if (toolCall.args) {\n                      const toolArgsEvent: ToolCallArgsEvent = {\n                        toolCallId: toolCall.id,\n                        delta: toolCall.args,\n                        type: EventType.TOOL_CALL_ARGS,\n                      };\n                      logger.trace?.(\n                        { aguiEvent: toolArgsEvent },\n                        \"Emitting AGUI event\"\n                      );\n                      subscriber.next(toolArgsEvent);\n\n                      if (isValidJson(toolCall.args)) {\n                        // args is valid json, tool call streaming ends\n                        const toolEndEvent: ToolCallEndEvent = {\n                          toolCallId: toolCall.id,\n                          type: EventType.TOOL_CALL_END,\n                        };\n                        logger.debug?.(\n                          { toolCallId: toolCall.id },\n                          \"Tool call ended (args complete)\"\n                        );\n                        logger.trace?.(\n                          { aguiEvent: toolEndEvent },\n                          \"Emitting AGUI event\"\n                        );\n                        subscriber.next(toolEndEvent);\n                        currentToolCall = null;\n                      }\n                    }\n                  }\n                }\n              });\n          }\n\n          // Process text content\n          const delta = event.data.chunk.content;\n          if (typeof delta === \"string\" && delta) {\n            textChunkCount++;\n            const textContentEvent: TextMessageContentEvent = {\n              messageId: chatModelRun.messageId!,\n              type: EventType.TEXT_MESSAGE_CONTENT,\n              delta,\n            };\n            logger.trace?.(\n              { aguiEvent: textContentEvent },\n              \"Emitting AGUI event\"\n            );\n            subscriber.next(textContentEvent);\n          }\n\n          continue;\n        }\n\n        if (event.event === \"on_chat_model_end\") {\n          const chatModelRun = chatModelRuns.find(\n            (run) => run.runId === event.run_id\n          );\n\n          if (!chatModelRun) {\n            logger.warn?.(\n              { chatModelRunId: event.run_id },\n              \"Received on_chat_model_end from unknown run\"\n            );\n            subscriber.next({\n              type: EventType.RUN_ERROR,\n              code: \"INTERNAL_ERROR\",\n              message: `Received a on_chat_model_end event from an unknown chat model run. Run Id: ${event.run_id}`,\n            } as RunErrorEvent);\n            continue;\n          }\n\n          const textEndEvent: TextMessageEndEvent = {\n            type: EventType.TEXT_MESSAGE_END,\n            messageId: chatModelRun.messageId!,\n          };\n          logger.debug?.(\n            { messageId: chatModelRun.messageId },\n            \"Text message ended\"\n          );\n          logger.trace?.({ aguiEvent: textEndEvent }, \"Emitting AGUI event\");\n          subscriber.next(textEndEvent);\n\n          continue;\n        }\n\n        // Handle on_tool_end: Pre-assign ID to toolMessage BEFORE messagesStateReducer runs.\n        // This ensures the same ID is used in:\n        // 1. TOOL_CALL_RESULT event (sent to frontend)\n        // 2. Checkpoint (stored in LangGraph state)\n        // 3. Second request (frontend sends back the same ID for deduplication)\n        if (event.event === \"on_tool_end\") {\n          const toolMessage = event.data.output;\n          if (toolMessage && toolMessage.tool_call_id) {\n            if (!handledToolCallIds.has(toolMessage.tool_call_id)) {\n              // Pre-assign ID before messagesStateReducer runs.\n              // The reducer checks: if (m.id === null || m.id === undefined) m.id = v4()\n              // By setting ID here, the reducer will skip assigning a new one.\n              if (!toolMessage.id) {\n                toolMessage.id = crypto.randomUUID();\n                // Also set lc_kwargs.id to match what the reducer does\n                if (toolMessage.lc_kwargs) {\n                  toolMessage.lc_kwargs.id = toolMessage.id;\n                }\n              }\n\n              const toolResultEvent: ToolCallResultEvent = {\n                toolCallId: toolMessage.tool_call_id,\n                type: EventType.TOOL_CALL_RESULT,\n                content:\n                  typeof toolMessage.content === \"string\"\n                    ? toolMessage.content\n                    : JSON.stringify(toolMessage.content),\n                messageId: toolMessage.id,\n              };\n              logger.debug?.(\n                {\n                  toolCallId: toolMessage.tool_call_id,\n                  messageId: toolMessage.id,\n                },\n                \"Tool call result received\"\n              );\n              logger.trace?.(\n                { aguiEvent: toolResultEvent },\n                \"Emitting AGUI event\"\n              );\n              subscriber.next(toolResultEvent);\n              handledToolCallIds.add(toolMessage.tool_call_id);\n            } else {\n              logger.trace?.(\n                { toolCallId: toolMessage.tool_call_id },\n                \"Skipping duplicate tool call result\"\n              );\n            }\n          }\n          continue;\n        }\n\n        if (event.event === \"on_chain_stream\") {\n          const chunk = event.data.chunk;\n\n          // TRACE: state updates including messages for debugging ordering issues\n          if (chunk?.messages && Array.isArray(chunk.messages)) {\n            logger.trace?.(\n              {\n                nodeName: event.name,\n                stateMessages: chunk.messages.map((m: LangGraphMessage) => ({\n                  type: m.type,\n                  id: m.id,\n                  contentPreview:\n                    typeof m.content === \"string\"\n                      ? m.content.slice(0, 100)\n                      : \"[non-string content]\",\n                  hasToolCalls:\n                    \"tool_calls\" in m &&\n                    Array.isArray(m.tool_calls) &&\n                    m.tool_calls.length > 0,\n                  toolCallId: \"tool_call_id\" in m ? m.tool_call_id : undefined,\n                })),\n                messageCount: chunk.messages.length,\n              },\n              \"State update with messages\"\n            );\n          }\n\n          // Handle interrupt\n          if (\n            chunk?.__interrupt__ &&\n            Array.isArray(chunk.__interrupt__) &&\n            chunk.__interrupt__.length > 0\n          ) {\n            const rawInterrupt = chunk.__interrupt__[0];\n\n            logger.debug?.(\n              { interruptId: rawInterrupt.id },\n              \"Interrupt received\"\n            );\n            // TODO: check if the interrupt is already set\n            interrupt = {\n              id: rawInterrupt.id,\n              // TODO: replace with actual reason\n              reason: \"agent requested interrupt\",\n              payload: rawInterrupt.value,\n            };\n          }\n        }\n      }\n\n      const stats = { eventCount, toolCallCount, textChunkCount };\n\n      if (interrupt) {\n        const runFinishedEvent = {\n          type: EventType.RUN_FINISHED,\n          threadId,\n          runId,\n          outcome: \"interrupt\",\n          interrupt,\n        } as RunFinishedEvent;\n        logger.info?.(\n          { outcome: \"interrupt\", interruptId: interrupt.id, ...stats },\n          \"Run finished with interrupt\"\n        );\n        logger.trace?.({ aguiEvent: runFinishedEvent }, \"Emitting AGUI event\");\n        subscriber.next(runFinishedEvent);\n      } else {\n        const runFinishedEvent: RunFinishedEvent = {\n          type: EventType.RUN_FINISHED,\n          threadId,\n          runId,\n        };\n        logger.info?.({ outcome: \"complete\", ...stats }, \"Run finished\");\n        logger.trace?.({ aguiEvent: runFinishedEvent }, \"Emitting AGUI event\");\n        subscriber.next(runFinishedEvent);\n      }\n    } catch (error) {\n      logger.error?.(\n        { err: error, eventCount, toolCallCount, textChunkCount },\n        \"Error during stream processing\"\n      );\n\n      // Extract code from error if available\n      const errorCode = isErrorWithCode(error)\n        ? error.code\n        : \"INTERNAL_ERROR\";\n      const errorMessage =\n        error instanceof Error ? error.message : String(error);\n\n      subscriber.next({\n        type: EventType.RUN_ERROR,\n        code: errorCode,\n        message: errorMessage,\n      } as RunErrorEvent);\n    }\n\n    subscriber.complete();\n  }\n\n  clone() {\n    const workflow = this.compiledWorkflow;\n    const logger = this.logger;\n    this.compiledWorkflow = undefined;\n\n    const cloned = super.clone() as LanggraphAgent;\n\n    this.compiledWorkflow = workflow;\n    cloned.compiledWorkflow = workflow;\n    cloned.logger = logger;\n\n    return cloned;\n  }\n}\n\nfunction aguiMessagesToLangChain(messages: Message[]): LangGraphMessage[] {\n  return messages.map((message, index) => {\n    switch (message.role) {\n      case \"user\":\n        if (typeof message.content === \"string\") {\n          return {\n            id: message.id,\n            role: message.role,\n            content: message.content,\n            type: \"human\",\n          };\n        } else {\n          return {\n            id: message.id,\n            role: message.role,\n            content: message.content.filter((m) => m.type === \"text\"),\n            type: \"human\",\n          };\n        }\n\n      case \"assistant\":\n        return {\n          id: message.id,\n          type: \"ai\",\n          role: message.role,\n          content: message.content ?? \"\",\n          tool_calls: (message.toolCalls ?? []).map((tc: ToolCall) => ({\n            id: tc.id,\n            name: tc.function.name,\n            args: JSON.parse(tc.function.arguments),\n            type: \"tool_call\",\n          })),\n        };\n      case \"system\":\n        return {\n          id: message.id,\n          role: message.role,\n          content: message.content,\n          type: \"system\",\n        };\n      case \"tool\":\n        return {\n          content: message.content,\n          role: message.role,\n          type: message.role,\n          tool_call_id: message.toolCallId,\n          id: message.id,\n        };\n      default:\n        // Note: Can't use this.logger here as this is a standalone function\n        // The error will be caught and logged by the caller\n        throw new Error(`Message role ${message.role} is not supported.`);\n    }\n  });\n}\n\nfunction isValidJson(json: string) {\n  try {\n    JSON.parse(json);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n","import { RunAgentInput } from \"@ag-ui/client\";\nimport { DynamicStructuredTool } from \"@langchain/core/tools\";\nimport z from \"zod/v4\";\n\nexport function convertActionsToDynamicStructuredTools(\n  tools: RunAgentInput[\"tools\"]\n): DynamicStructuredTool<any>[] {\n  return tools.map(convertActionToDynamicStructuredTool);\n}\n\nexport function convertActionToDynamicStructuredTool(\n  actionInput: RunAgentInput[\"tools\"][number]\n): DynamicStructuredTool<any> {\n  return new DynamicStructuredTool({\n    name: actionInput.name,\n    description: actionInput.description,\n    schema: convertJsonSchemaToZodSchema(actionInput.parameters, true),\n    func: async () => {\n      return \"\";\n    },\n  });\n}\n\nexport function convertJsonSchemaToZodSchema(\n  jsonSchema: any,\n  required: boolean\n): z.ZodSchema {\n  if (jsonSchema.type === \"object\") {\n    const spec: { [key: string]: z.ZodSchema } = {};\n\n    if (!jsonSchema.properties || !Object.keys(jsonSchema.properties).length) {\n      return !required ? z.object(spec).optional() : z.object(spec);\n    }\n\n    for (const [key, value] of Object.entries(jsonSchema.properties)) {\n      spec[key] = convertJsonSchemaToZodSchema(\n        value,\n        jsonSchema.required ? jsonSchema.required.includes(key) : false\n      );\n    }\n    let schema = z.object(spec).describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"string\") {\n    let schema = z.string().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"number\") {\n    let schema = z.number().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"boolean\") {\n    let schema = z.boolean().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"array\") {\n    let itemSchema = convertJsonSchemaToZodSchema(jsonSchema.items, true);\n    let schema = z.array(itemSchema).describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  }\n  throw new Error(\"Invalid JSON schema\");\n}\n","import {\n  BaseCheckpointSaver,\n  Checkpoint,\n  CheckpointMetadata,\n  CheckpointTuple,\n} from \"@langchain/langgraph\";\nimport type { RunnableConfig } from \"@langchain/core/runnables\";\nimport {\n  MemoryClient,\n  IMemoryClientOptions,\n  Order,\n} from \"@cloudbase/agent-agents\";\n\n// Define types locally if not available from langgraph\ntype PendingWrite = [string, any];\ntype CheckpointPendingWrite = [string, string, any];\n\ninterface CheckpointListOptions {\n  limit?: number;\n  before?: RunnableConfig;\n  filter?: Record<string, any>;\n}\n\nexport interface TDAISaverConfig extends IMemoryClientOptions {\n  checkpointType?: string;\n  checkpointWritesType?: string;\n}\n\n/**\n * TDAISaver - LangGraph checkpoint saver implementation using TDAI Memory\n *\n * Storage Strategy:\n * - Events (NoSQL): Store checkpoint data and pending writes in separate collections\n * - Supports namespaces and parent checkpoint relationships\n */\nexport class TDAISaver extends BaseCheckpointSaver {\n  private memoryClient: MemoryClient;\n  private checkpointType: string;\n  private checkpointWritesType: string;\n\n  constructor(config: TDAISaverConfig) {\n    super();\n    const {\n      checkpointType = \"checkpoints\",\n      checkpointWritesType = \"checkpoint_writes\",\n      ...clientConfig\n    } = config;\n\n    this.memoryClient = new MemoryClient(clientConfig);\n    this.checkpointType = checkpointType;\n    this.checkpointWritesType = checkpointWritesType;\n  }\n\n  /**\n   * Retrieves a checkpoint from TDAI Memory based on the provided config.\n   * If the config contains a \"checkpoint_id\" key, the checkpoint with the matching\n   * thread ID and checkpoint ID is retrieved. Otherwise, the latest checkpoint\n   * for the given thread ID is retrieved.\n   */\n  async getTuple(config: RunnableConfig): Promise<CheckpointTuple | undefined> {\n    try {\n      const {\n        thread_id,\n        checkpoint_ns = \"\",\n        checkpoint_id,\n      } = config.configurable ?? {};\n\n      if (!thread_id) {\n        return undefined;\n      }\n\n      const query: Record<string, any> = {\n        collection: this.checkpointType,\n        checkpoint_ns,\n      };\n\n      if (checkpoint_id) {\n        query.checkpoint_id = checkpoint_id;\n      }\n\n      // Query events for checkpoint data\n      const { events = [] } = await this.memoryClient.queryEvents({\n        sessionId: thread_id,\n        where: query,\n        orderBy: { checkpoint_id: Order.DESCENDING },\n        limit: 1,\n      });\n\n      if (events.length === 0) {\n        return undefined;\n      }\n\n      const doc = events[0];\n      const configurableValues = {\n        checkpoint_ns,\n        checkpoint_id: doc.checkpoint_id,\n      };\n\n      // Get checkpoint data (stored as JSON)\n      const checkpoint: Checkpoint = doc.checkpoint;\n\n      // Get pending writes\n      const { events: serializedWrites = [] } =\n        await this.memoryClient.queryEvents({\n          sessionId: thread_id,\n          where: {\n            collection: this.checkpointWritesType,\n            ...configurableValues,\n          },\n        });\n\n      const pendingWrites: CheckpointPendingWrite[] = serializedWrites.map(\n        (serializedWrite: any) => {\n          return [\n            serializedWrite.task_id,\n            serializedWrite.channel,\n            serializedWrite.value,\n          ] as CheckpointPendingWrite;\n        }\n      );\n\n      // Get metadata (stored as JSON)\n      const metadata: CheckpointMetadata = doc.metadata || {};\n\n      return {\n        config: { configurable: configurableValues },\n        checkpoint,\n        pendingWrites,\n        metadata,\n        parentConfig:\n          doc.parent_checkpoint_id != null\n            ? {\n                configurable: {\n                  thread_id,\n                  checkpoint_ns,\n                  checkpoint_id: doc.parent_checkpoint_id,\n                },\n              }\n            : undefined,\n      };\n    } catch (error) {\n      console.error(\"Error getting checkpoint:\", error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Retrieve a list of checkpoint tuples from TDAI Memory based on the provided config.\n   * The checkpoints are ordered by checkpoint ID in descending order (newest first).\n   */\n  async *list(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncGenerator<CheckpointTuple> {\n    const { limit, before, filter } = options ?? {};\n\n    if (!config?.configurable?.thread_id) {\n      throw new Error(\"Thread ID is required\");\n    }\n\n    const query: Record<string, any> = {\n      collection: this.checkpointType,\n    };\n\n    if (\n      config?.configurable?.checkpoint_ns !== undefined &&\n      config?.configurable?.checkpoint_ns !== null\n    ) {\n      query.checkpoint_ns = config.configurable.checkpoint_ns;\n    }\n\n    // Apply metadata filters\n    if (filter) {\n      Object.entries(filter).forEach(([key, value]) => {\n        query[`metadata.${key}`] = value;\n      });\n    }\n\n    // Apply before filter\n    if (before) {\n      query.checkpoint_id = { $lt: before.configurable?.checkpoint_id };\n    }\n\n    // Query events\n    const { events = [] } = await this.memoryClient.queryEvents({\n      sessionId: config?.configurable?.thread_id || \"default\",\n      where: query,\n      orderBy: { checkpoint_id: Order.DESCENDING },\n      limit: limit,\n    });\n\n    for (const doc of events) {\n      // Get checkpoint and metadata (stored directly without serialization)\n      const checkpoint: Checkpoint = doc.checkpoint;\n      const metadata: CheckpointMetadata = doc.metadata || {};\n\n      yield {\n        config: {\n          configurable: {\n            thread_id: doc.thread_id,\n            checkpoint_ns: doc.checkpoint_ns,\n            checkpoint_id: doc.checkpoint_id,\n          },\n        },\n        checkpoint,\n        metadata,\n        parentConfig: doc.parent_checkpoint_id\n          ? {\n              configurable: {\n                thread_id: doc.thread_id,\n                checkpoint_ns: doc.checkpoint_ns,\n                checkpoint_id: doc.parent_checkpoint_id,\n              },\n            }\n          : undefined,\n      };\n    }\n  }\n\n  /**\n   * Saves a checkpoint to TDAI Memory. The checkpoint is associated with the\n   * provided config and its parent config (if any).\n   */\n  async put(\n    config: RunnableConfig,\n    checkpoint: Checkpoint,\n    metadata: CheckpointMetadata\n  ): Promise<RunnableConfig> {\n    try {\n      const thread_id = config.configurable?.thread_id;\n      const checkpoint_ns = config.configurable?.checkpoint_ns ?? \"\";\n      const checkpoint_id = checkpoint.id;\n\n      if (thread_id === undefined) {\n        throw new Error(\n          `The provided config must contain a configurable field with a \"thread_id\" field.`\n        );\n      }\n\n      // Prepare document for storage (store as JSON)\n      const doc = {\n        collection: this.checkpointType,\n        checkpoint_ns,\n        checkpoint_id,\n        parent_checkpoint_id: config.configurable?.checkpoint_id,\n        checkpoint: checkpoint,\n        metadata: metadata,\n      };\n\n      const { events = [] } = await this.memoryClient.queryEvents({\n        sessionId: thread_id,\n        where: {\n          collection: this.checkpointType,\n          checkpoint_ns,\n          checkpoint_id,\n        },\n      });\n\n      if (events[0]) {\n        this.memoryClient.deleteEvent({\n          sessionId: thread_id,\n          eventId: events[0].id,\n          //   messages: doc,\n        });\n      } else {\n        await this.memoryClient.appendEvent({\n          sessionId: thread_id,\n          messages: doc,\n        });\n      }\n\n      return {\n        configurable: {\n          thread_id,\n          checkpoint_ns,\n          checkpoint_id,\n        },\n      };\n    } catch (error) {\n      console.error(\"Error saving checkpoint:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Saves intermediate writes associated with a checkpoint to TDAI Memory.\n   */\n  async putWrites(\n    config: RunnableConfig,\n    writes: PendingWrite[],\n    taskId: string\n  ): Promise<void> {\n    try {\n      const thread_id = config.configurable?.thread_id;\n      const checkpoint_ns = config.configurable?.checkpoint_ns;\n      const checkpoint_id = config.configurable?.checkpoint_id;\n\n      if (\n        thread_id === undefined ||\n        checkpoint_ns === undefined ||\n        checkpoint_id === undefined\n      ) {\n        throw new Error(\n          `The provided config must contain a configurable field with \"thread_id\", \"checkpoint_ns\" and \"checkpoint_id\" fields.`\n        );\n      }\n\n      // Process writes in parallel\n      const writePromises = writes.map(async ([channel, value], idx) => {\n        const writeDoc = {\n          collection: this.checkpointWritesType,\n          checkpoint_ns,\n          checkpoint_id,\n          task_id: taskId,\n          idx,\n          channel,\n          value: value, // Store directly as JSON\n        };\n\n        return this.memoryClient.appendEvent({\n          sessionId: thread_id,\n          messages: writeDoc,\n        });\n      });\n\n      await Promise.all(writePromises);\n    } catch (error) {\n      console.error(\"Error storing writes:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete all checkpoints and writes for a thread from TDAI Memory.\n   */\n  async deleteThread(threadId: string): Promise<void> {\n    try {\n      // Delete the entire session which will remove all data\n      await this.memoryClient.deleteSession({\n        sessionId: threadId,\n      });\n    } catch (error) {\n      console.error(\"Error deleting thread:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Close the memory client connection\n   */\n  close(): void {\n    this.memoryClient.close();\n  }\n}\n\n","import {\n  BaseStore,\n  type Operation,\n  type OperationResults,\n  type ListNamespacesOperation,\n  type PutOperation,\n  type GetOperation,\n  type Item,\n  type MatchCondition,\n} from \"@langchain/langgraph\";\n\nimport { MemoryClient } from \"@cloudbase/agent-agents\";\n\n/**\n * TDAI Store configuration\n */\nexport interface TDAIStoreConfig {\n  /**\n   * TDAI Memory Client instance for long-term storage\n   */\n  memoryClient: MemoryClient;\n\n  /**\n   * Session ID for storing records\n   */\n  sessionId: string;\n\n  /**\n   * Optional namespace prefix for all operations\n   */\n  namespacePrefix?: string[];\n\n  /**\n   * TTL configuration for records\n   */\n  ttl?: {\n    defaultTtlSeconds?: number;\n    sweepIntervalMinutes?: number;\n  };\n\n  /**\n   * Whether to ensure tables/collections exist on startup\n   */\n  ensureTables?: boolean;\n\n  /**\n   * Default strategy for storing records\n   */\n  defaultStrategy?: string;\n}\n\n/**\n * Filter operators for advanced filtering\n */\nexport interface FilterOperators {\n  $eq?: unknown;\n  $ne?: unknown;\n  $gt?: number | Date;\n  $gte?: number | Date;\n  $lt?: number | Date;\n  $lte?: number | Date;\n  $in?: unknown[];\n  $nin?: unknown[];\n  $exists?: boolean;\n  $regex?: string;\n}\n\n/**\n * TDAI implementation of the BaseStore interface.\n * Uses TDAI Memory Client for long-term record storage.\n */\nexport class TDAIStore extends BaseStore {\n  private client: MemoryClient;\n  private namespacePrefix: string[];\n  private ttlConfig?: TDAIStoreConfig[\"ttl\"];\n  private ensureTables: boolean;\n  private isSetup: boolean = false;\n  private isClosed: boolean = false;\n  private sweepInterval?: NodeJS.Timeout;\n  private sessionId: string;\n  private defaultStrategy: string;\n\n  constructor(config: TDAIStoreConfig) {\n    super();\n\n    this.client = config.memoryClient;\n    this.namespacePrefix = config.namespacePrefix || [];\n    this.ttlConfig = config.ttl;\n    this.ensureTables = config.ensureTables ?? true;\n    this.sessionId = config.sessionId || \"default_session\";\n    this.defaultStrategy = config.defaultStrategy || \"store\";\n  }\n\n  /**\n   * Create a storage key from namespace and key\n   */\n  private createStorageKey(namespace: string[], key: string): string {\n    const fullNamespace = [...this.namespacePrefix, ...namespace];\n    return `${fullNamespace.join(\":\")}:${key}`;\n  }\n\n  /**\n   * Parse a storage key back to namespace and key\n   */\n  private parseStorageKey(storageKey: string): {\n    namespace: string[];\n    key: string;\n  } {\n    const parts = storageKey.split(\":\");\n    const prefixLength = this.namespacePrefix.length;\n\n    // Remove the prefix from the namespace\n    const namespace = parts.slice(prefixLength, -1);\n    const key = parts[parts.length - 1];\n\n    return { namespace, key };\n  }\n\n  /**\n   * Put an item with optional TTL.\n   */\n  async put(\n    namespace: string[],\n    key: string,\n    value: Record<string, unknown>,\n    index?: false | string[],\n    options?: { ttl?: number }\n  ): Promise<void> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    const storageKey = this.createStorageKey(namespace, key);\n\n    // Prepare the content with metadata\n    const content = JSON.stringify({\n      storageKey,\n      namespace,\n      key,\n      value,\n      index,\n      ttl: options?.ttl || this.ttlConfig?.defaultTtlSeconds,\n    });\n\n    await this.client.appendRecord({\n      sessionId: this.sessionId,\n      content,\n      strategy: this.defaultStrategy,\n    });\n  }\n\n  /**\n   * Get an item by namespace and key.\n   */\n  async get(namespace: string[], key: string): Promise<Item | null> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    const storageKey = this.createStorageKey(namespace, key);\n\n    try {\n      const { records = [] } = await this.client.searchRecords({\n        content: storageKey,\n        sessionId: this.sessionId,\n        limit: 1,\n      });\n\n      if (!records.length) {\n        return null;\n      }\n\n      const record = records[0];\n      const data = JSON.parse(record.record_content);\n\n      // Check TTL if present\n      if (data.ttl && record.created_at) {\n        const createdTime = new Date(record.created_at).getTime();\n        const now = Date.now();\n        if (now > createdTime + data.ttl * 1000) {\n          // Item has expired, delete it\n          await this.delete(namespace, key);\n          return null;\n        }\n      }\n\n      return {\n        namespace,\n        key,\n        value: data.value,\n        createdAt: new Date(record.created_at || Date.now()),\n        updatedAt: new Date(record.updated_at || Date.now()),\n      };\n    } catch (error) {\n      return null;\n    }\n  }\n\n  /**\n   * Delete an item by namespace and key.\n   */\n  async delete(namespace: string[], key: string): Promise<void> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    const storageKey = this.createStorageKey(namespace, key);\n\n    try {\n      const { records = [] } = await this.client.searchRecords({\n        content: storageKey,\n        sessionId: this.sessionId,\n        limit: 1,\n      });\n\n      const record = records[0];\n      if (record) {\n        await this.client.deleteRecord({\n          sessionId: this.sessionId,\n          recordId: record.record_id,\n        });\n      }\n    } catch (error) {\n      // Ignore errors if item doesn't exist\n    }\n  }\n\n  /**\n   * List namespaces with optional filtering.\n   */\n  async listNamespaces(\n    options: {\n      prefix?: string[];\n      suffix?: string[];\n      maxDepth?: number;\n      limit?: number;\n      offset?: number;\n    } = {}\n  ): Promise<string[][]> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    const { prefix, suffix, maxDepth, limit = 100, offset = 0 } = options;\n\n    try {\n      // Get all records to extract namespaces\n      const { records = [] } = await this.client.queryRecords({\n        limit: 1000, // Large limit to get all records\n      });\n\n      const namespaceSet = new Set<string>();\n\n      for (const record of records) {\n        try {\n          const data = JSON.parse(record.record_content);\n          if (data.namespace) {\n            const namespace = data.namespace;\n\n            // Apply prefix filter if specified\n            if (prefix && prefix.length > 0) {\n              const hasPrefix = prefix.every((p, i) => namespace[i] === p);\n              if (!hasPrefix) continue;\n            }\n\n            // Apply suffix filter if specified\n            if (suffix && suffix.length > 0) {\n              const namespaceSuffix = namespace.slice(-suffix.length);\n              if (JSON.stringify(namespaceSuffix) !== JSON.stringify(suffix)) {\n                continue;\n              }\n            }\n\n            // Apply maxDepth filter if specified\n            if (maxDepth !== undefined && namespace.length > maxDepth) {\n              continue;\n            }\n\n            namespaceSet.add(JSON.stringify(namespace));\n          }\n        } catch (error) {\n          // Skip invalid records\n        }\n      }\n\n      // Convert back to arrays and apply pagination\n      const namespaces = Array.from(namespaceSet)\n        .map((ns) => JSON.parse(ns))\n        .sort()\n        .slice(offset, offset + limit);\n\n      return namespaces;\n    } catch (error) {\n      return [];\n    }\n  }\n\n  /**\n   * Execute multiple operations in a single batch.\n   */\n  async batch<Op extends Operation[]>(\n    operations: Op\n  ): Promise<OperationResults<Op>> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    const results: unknown[] = [];\n\n    for (const operation of operations) {\n      if (\"namespacePrefix\" in operation) {\n        // SearchOperation\n        results.push(await this.executeSearch(operation));\n      } else if (\"key\" in operation && !(\"value\" in operation)) {\n        // GetOperation\n        const getOp = operation as GetOperation;\n        results.push(await this.get(getOp.namespace, getOp.key));\n      } else if (\"value\" in operation) {\n        // PutOperation\n        const putOp = operation as PutOperation & {\n          options?: { ttl?: number };\n        };\n        if (putOp.value !== null) {\n          await this.put(\n            putOp.namespace,\n            putOp.key,\n            putOp.value,\n            putOp.index,\n            putOp.options\n          );\n        }\n        results.push(undefined);\n      } else if (\"matchConditions\" in operation) {\n        // ListNamespacesOperation\n        const listOp = operation as ListNamespacesOperation;\n        results.push(await this.executeListNamespaces(listOp));\n      } else {\n        throw new Error(\n          `Unsupported operation type: ${JSON.stringify(operation)}`\n        );\n      }\n    }\n\n    return results as OperationResults<Op>;\n  }\n\n  /**\n   * Execute search operation\n   */\n  private async executeSearch(operation: any): Promise<Item[]> {\n    const { namespacePrefix, ...searchOptions } = operation;\n    return this.search(namespacePrefix, searchOptions);\n  }\n\n  /**\n   * Execute list namespaces operation\n   */\n  private async executeListNamespaces(\n    operation: ListNamespacesOperation\n  ): Promise<string[][]> {\n    const { matchConditions, maxDepth, limit = 100, offset = 0 } = operation;\n\n    // Convert match conditions to prefix/suffix filters\n    let prefix: string[] | undefined;\n    let suffix: string[] | undefined;\n\n    if (matchConditions && matchConditions.length > 0) {\n      for (const condition of matchConditions) {\n        if (condition.matchType === \"prefix\") {\n          prefix = condition.path;\n        } else if (condition.matchType === \"suffix\") {\n          suffix = condition.path;\n        }\n      }\n    }\n\n    return this.listNamespaces({\n      prefix,\n      suffix,\n      maxDepth,\n      limit,\n      offset,\n    });\n  }\n\n  /**\n   * Initialize the store.\n   */\n  async setup(): Promise<void> {\n    if (this.isSetup) return;\n\n    // Start TTL sweeper if configured\n    if (this.ttlConfig?.sweepIntervalMinutes) {\n      const intervalMs = this.ttlConfig.sweepIntervalMinutes * 60 * 1000;\n      this.sweepInterval = setInterval(async () => {\n        try {\n          await this.sweepExpiredItems();\n        } catch (error) {\n          console.error(\"Error during TTL sweep:\", error);\n        }\n      }, intervalMs);\n    }\n\n    this.isSetup = true;\n  }\n\n  /**\n   * Start the store.\n   */\n  async start(): Promise<void> {\n    if (this.ensureTables && !this.isSetup) {\n      await this.setup();\n    }\n  }\n\n  /**\n   * Stop the store and close all connections.\n   */\n  async stop(): Promise<void> {\n    if (this.isClosed) return;\n\n    if (this.sweepInterval) {\n      clearInterval(this.sweepInterval);\n      this.sweepInterval = undefined;\n    }\n\n    this.client.close();\n    this.isClosed = true;\n  }\n\n  /**\n   * Manually sweep expired items from the store.\n   */\n  async sweepExpiredItems(): Promise<number> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    try {\n      const { records = [] } = await this.client.queryRecords({\n        limit: 1000,\n      });\n\n      let cleanedCount = 0;\n      const now = Date.now();\n\n      for (const record of records) {\n        try {\n          const data = JSON.parse(record.record_content);\n          if (data.ttl && data.createdAt) {\n            const createdTime = new Date(data.createdAt).getTime();\n            if (now > createdTime + data.ttl * 1000) {\n              await this.client.deleteRecord({\n                sessionId: this.sessionId,\n                recordId: record.record_id,\n              });\n              cleanedCount++;\n            }\n          }\n        } catch (error) {\n          // Skip invalid records\n        }\n      }\n\n      return cleanedCount;\n    } catch (error) {\n      return 0;\n    }\n  }\n\n  /**\n   * Get statistics about the store.\n   */\n  async getStats(): Promise<{\n    totalItems: number;\n    expiredItems: number;\n    namespaceCount: number;\n    oldestItem: Date | null;\n    newestItem: Date | null;\n  }> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    try {\n      const { records = [] } = await this.client.queryRecords({\n        limit: 1000,\n      });\n\n      let totalItems = 0;\n      let expiredItems = 0;\n      const namespaces = new Set<string>();\n      const dates: Date[] = [];\n      const now = Date.now();\n\n      for (const record of records) {\n        try {\n          const data = JSON.parse(record.record_content);\n          totalItems++;\n\n          if (data.namespace) {\n            namespaces.add(data.namespace.join(\":\"));\n          }\n\n          if (data.createdAt) {\n            dates.push(new Date(data.createdAt));\n          }\n\n          if (data.ttl && data.createdAt) {\n            const createdTime = new Date(data.createdAt).getTime();\n            if (now > createdTime + data.ttl * 1000) {\n              expiredItems++;\n            }\n          }\n        } catch (error) {\n          // Skip invalid records\n        }\n      }\n\n      const oldestItem =\n        dates.length > 0\n          ? new Date(Math.min(...dates.map((d) => d.getTime())))\n          : null;\n      const newestItem =\n        dates.length > 0\n          ? new Date(Math.max(...dates.map((d) => d.getTime())))\n          : null;\n\n      return {\n        totalItems,\n        expiredItems,\n        namespaceCount: namespaces.size,\n        oldestItem,\n        newestItem,\n      };\n    } catch (error) {\n      return {\n        totalItems: 0,\n        expiredItems: 0,\n        namespaceCount: 0,\n        oldestItem: null,\n        newestItem: null,\n      };\n    }\n  }\n\n  /**\n   * Search for items in the store with support for text search and filtering.\n   */\n  async search(\n    namespacePrefix: string[],\n    options: {\n      /**\n       * Filter conditions with support for advanced operators.\n       */\n      filter?: Record<\n        string,\n        string | number | boolean | null | FilterOperators\n      >;\n\n      /**\n       * Natural language search query.\n       */\n      query?: string;\n\n      /**\n       * Maximum number of results to return.\n       * @default 10\n       */\n      limit?: number;\n\n      /**\n       * Number of results to skip for pagination.\n       * @default 0\n       */\n      offset?: number;\n\n      /**\n       * Whether to refresh TTL for returned items.\n       */\n      refreshTtl?: boolean;\n    } = {}\n  ): Promise<Item[]> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    const { filter, query, limit = 10, offset = 0, refreshTtl } = options;\n\n    try {\n      // Build search query\n      const namespaceKey = [...this.namespacePrefix, ...namespacePrefix].join(\n        \":\"\n      );\n\n      let searchResult;\n      if (query) {\n        searchResult = await this.client.searchRecords({\n          content: query,\n          limit: limit + offset,\n        });\n      } else {\n        searchResult = await this.client.queryRecords({\n          limit: limit + offset,\n        });\n      }\n\n      const items: Item[] = [];\n      const now = Date.now();\n\n      if (searchResult.records) {\n        for (const record of searchResult.records.slice(\n          offset,\n          offset + limit\n        )) {\n          try {\n            const data = JSON.parse(record.record_content);\n\n            // Filter by namespace prefix\n            if (namespaceKey && !data.storageKey?.startsWith(namespaceKey)) {\n              continue;\n            }\n\n            // Check TTL\n            if (data.ttl && data.createdAt) {\n              const createdTime = new Date(data.createdAt).getTime();\n              if (now > createdTime + data.ttl * 1000) {\n                continue; // Skip expired items\n              }\n            }\n\n            // Apply filters (basic implementation)\n            if (filter) {\n              let matches = true;\n              for (const [key, value] of Object.entries(filter)) {\n                if (data.value[key] !== value) {\n                  matches = false;\n                  break;\n                }\n              }\n              if (!matches) continue;\n            }\n\n            const item: Item = {\n              namespace: data.namespace,\n              key: data.key,\n              value: data.value,\n              createdAt: new Date(record.created_at || Date.now()),\n              updatedAt: new Date(record.updated_at || Date.now()),\n            };\n\n            items.push(item);\n\n            // Refresh TTL if requested\n            if (refreshTtl && this.ttlConfig?.defaultTtlSeconds) {\n              await this.put(data.namespace, data.key, data.value, undefined, {\n                ttl: this.ttlConfig.defaultTtlSeconds,\n              });\n            }\n          } catch (error) {\n            // Skip invalid records\n          }\n        }\n      }\n\n      return items;\n    } catch (error) {\n      return [];\n    }\n  }\n}\n\n"],"mappings":"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","names":["__defProp","__getOwnPropDesc","__getOwnPropNames","__hasOwnProp","__esm","__export","__copyProps","__toCommonJS","OpenInferenceSpanKind","MimeType","LLMSystem","LLMProvider","isCompatible","DiagComponentLogger","DiagLogLevel","DiagAPI","__spreadArray","__read","BaseContext","context","NoopContextManager","__spreadArray","__read","API_NAME","init_context","ContextAPI","context","__spreadArray","__read","TraceFlags","NonRecordingSpan","context","init_context","init_context","NoopTracer","context","ProxyTracer","context","NoopTracerProvider","ProxyTracerProvider","SpanStatusCode","init_context","API_NAME","init_trace","TraceAPI","init_trace","init_esm","SemanticConventions","trace","context","init_esm","__esm","__toCommonJS","__export","z","import_agent_shared","import_langgraph","import_langgraph","import_agent_shared"]}