{"version":3,"file":"utils.cjs","names":["fn: () => T","toolCall: ToolCall | Record<string, unknown>","_isToolCall","x: unknown","params:\n    | (BaseMessageFields & { type: string } & Record<string, unknown>)\n    | SerializedConstructor","type: string","rest: BaseMessageFields & Record<string, unknown>","HumanMessage","AIMessage","SystemMessage","ToolMessage","RemoveMessage","addLangChainErrorFields","messageLike: BaseMessageLike","isBaseMessage","_isMessageFieldWithRole","messages: BaseMessage[]","string_messages: string[]","role: string","message: StoredMessage | StoredMessageV1","message: StoredMessage","FunctionMessage","ChatMessage","messages: StoredMessage[]","message: BaseMessage","HumanMessageChunk","aiChunkFields: AIMessageChunkFields","AIMessageChunk","SystemMessageChunk","FunctionMessageChunk","ChatMessageChunk","chunks: ToolCallChunk[]","toolCalls: ToolCall[]","invalidToolCalls: InvalidToolCall[]","chunks","parsedArgs: Record<string, unknown> | null","parsePartialJson"],"sources":["../../src/messages/utils.ts"],"sourcesContent":["import { addLangChainErrorFields } from \"../errors/index.js\";\nimport { SerializedConstructor } from \"../load/serializable.js\";\nimport { _isToolCall } from \"../tools/utils.js\";\nimport { parsePartialJson } from \"../utils/json.js\";\nimport { AIMessage, AIMessageChunk, AIMessageChunkFields } from \"./ai.js\";\nimport {\n  BaseMessageLike,\n  BaseMessage,\n  isBaseMessage,\n  StoredMessage,\n  StoredMessageV1,\n  BaseMessageFields,\n  _isMessageFieldWithRole,\n} from \"./base.js\";\nimport { ChatMessage, ChatMessageFields, ChatMessageChunk } from \"./chat.js\";\nimport {\n  FunctionMessage,\n  FunctionMessageChunk,\n  FunctionMessageFields,\n} from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { RemoveMessage } from \"./modifier.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport {\n  InvalidToolCall,\n  ToolCall,\n  ToolCallChunk,\n  ToolMessage,\n  ToolMessageFields,\n} from \"./tool.js\";\n\nexport type $Expand<T> = T extends infer U ? { [K in keyof U]: U[K] } : never;\n\n/**\n * Extracts the explicitly declared keys from a type T.\n *\n * @template T - The type to extract keys from\n * @returns A union of keys that are not string, number, or symbol\n */\ntype $KnownKeys<T> = {\n  [K in keyof T]: string extends K\n    ? never\n    : number extends K\n      ? never\n      : symbol extends K\n        ? never\n        : K;\n}[keyof T];\n\n/**\n * Detects if T has an index signature.\n *\n * @template T - The type to check for index signatures\n * @returns True if T has an index signature, false otherwise\n */\ntype $HasIndexSignature<T> = string extends keyof T\n  ? true\n  : number extends keyof T\n    ? true\n    : symbol extends keyof T\n      ? true\n      : false;\n\n/**\n * Detects if T has an index signature and no known keys.\n *\n * @template T - The type to check for index signatures and no known keys\n * @returns True if T has an index signature and no known keys, false otherwise\n */\ntype $OnlyIndexSignatures<T> =\n  $HasIndexSignature<T> extends true\n    ? [$KnownKeys<T>] extends [never]\n      ? true\n      : false\n    : false;\n\n/**\n * Recursively merges two object types T and U, with U taking precedence over T.\n *\n * This utility type performs a deep merge of two object types:\n * - For keys that exist in both T and U:\n *   - If both values are objects (Record<string, unknown>), recursively merge them\n *   - Otherwise, U's value takes precedence\n * - For keys that exist only in T, use T's value\n * - For keys that exist only in U, use U's value\n *\n * @template T - The first object type to merge\n * @template U - The second object type to merge (takes precedence over T)\n *\n * @example\n * ```ts\n * type ObjectA = {\n *   shared: { a: string; b: number };\n *   onlyInA: boolean;\n * };\n *\n * type ObjectB = {\n *   shared: { b: string; c: Date };\n *   onlyInB: symbol;\n * };\n *\n * type Merged = $MergeObjects<ObjectA, ObjectB>;\n * // Result: {\n * //   shared: { a: string; b: string; c: Date };\n * //   onlyInA: boolean;\n * //   onlyInB: symbol;\n * // }\n * ```\n */\nexport type $MergeObjects<T, U> =\n  // If U is purely index-signature based, prefer U as a whole\n  $OnlyIndexSignatures<U> extends true\n    ? U\n    : // If T is purely index-signature based, prefer U as a whole (prevents leaking broad index signatures)\n      $OnlyIndexSignatures<T> extends true\n      ? U\n      : {\n          [K in keyof T | keyof U]: K extends keyof T\n            ? K extends keyof U\n              ? T[K] extends Record<string, unknown>\n                ? U[K] extends Record<string, unknown>\n                  ? $MergeObjects<T[K], U[K]>\n                  : U[K]\n                : U[K]\n              : T[K]\n            : K extends keyof U\n              ? U[K]\n              : never;\n        };\n\n/**\n * Merges two discriminated unions A and B based on a discriminator key (defaults to \"type\").\n * For each possible value of the discriminator across both unions:\n * - If B has a member with that discriminator value, use B's member\n * - Otherwise use A's member with that discriminator value\n * This effectively merges the unions while giving B's members precedence over A's members.\n *\n * @template A - First discriminated union type that extends Record<Key, PropertyKey>\n * @template B - Second discriminated union type that extends Record<Key, PropertyKey>\n * @template Key - The discriminator key property, defaults to \"type\"\n */\nexport type $MergeDiscriminatedUnion<\n  A extends Record<Key, PropertyKey>,\n  B extends Record<Key, PropertyKey>,\n  Key extends PropertyKey = \"type\",\n> = {\n  // Create a mapped type over all possible discriminator values from both A and B\n  [T in A[Key] | B[Key]]: [Extract<B, Record<Key, T>>] extends [never] // Check if B has a member with this discriminator value\n    ? // If B doesn't have this discriminator value, use A's member\n      Extract<A, Record<Key, T>>\n    : // If B does have this discriminator value, merge A's and B's members (B takes precedence)\n      [Extract<A, Record<Key, T>>] extends [never]\n      ? Extract<B, Record<Key, T>>\n      : $MergeObjects<Extract<A, Record<Key, T>>, Extract<B, Record<Key, T>>>;\n  // Index into the mapped type with all possible discriminator values\n  // This converts the mapped type back into a union\n}[A[Key] | B[Key]];\n\nexport type Constructor<T> = new (...args: unknown[]) => T;\n\n/**\n * Immediately-invoked function expression.\n *\n * @param fn - The function to execute\n * @returns The result of the function\n */\nexport const iife = <T>(fn: () => T) => fn();\n\nfunction _coerceToolCall(\n  toolCall: ToolCall | Record<string, unknown>\n): ToolCall {\n  if (_isToolCall(toolCall)) {\n    return toolCall;\n  } else if (\n    typeof toolCall.id === \"string\" &&\n    toolCall.type === \"function\" &&\n    typeof toolCall.function === \"object\" &&\n    toolCall.function !== null &&\n    \"arguments\" in toolCall.function &&\n    typeof toolCall.function.arguments === \"string\" &&\n    \"name\" in toolCall.function &&\n    typeof toolCall.function.name === \"string\"\n  ) {\n    // Handle OpenAI tool call format\n    return {\n      id: toolCall.id,\n      args: JSON.parse(toolCall.function.arguments),\n      name: toolCall.function.name,\n      type: \"tool_call\",\n    };\n  } else {\n    // TODO: Throw an error?\n    return toolCall as unknown as ToolCall;\n  }\n}\n\nfunction isSerializedConstructor(x: unknown): x is SerializedConstructor {\n  return (\n    typeof x === \"object\" &&\n    x != null &&\n    (x as SerializedConstructor).lc === 1 &&\n    Array.isArray((x as SerializedConstructor).id) &&\n    (x as SerializedConstructor).kwargs != null &&\n    typeof (x as SerializedConstructor).kwargs === \"object\"\n  );\n}\n\nfunction _constructMessageFromParams(\n  params:\n    | (BaseMessageFields & { type: string } & Record<string, unknown>)\n    | SerializedConstructor\n) {\n  let type: string;\n  let rest: BaseMessageFields & Record<string, unknown>;\n  // Support serialized messages\n  if (isSerializedConstructor(params)) {\n    const className = params.id.at(-1);\n    if (className === \"HumanMessage\" || className === \"HumanMessageChunk\") {\n      type = \"user\";\n    } else if (className === \"AIMessage\" || className === \"AIMessageChunk\") {\n      type = \"assistant\";\n    } else if (\n      className === \"SystemMessage\" ||\n      className === \"SystemMessageChunk\"\n    ) {\n      type = \"system\";\n    } else if (\n      className === \"FunctionMessage\" ||\n      className === \"FunctionMessageChunk\"\n    ) {\n      type = \"function\";\n    } else if (\n      className === \"ToolMessage\" ||\n      className === \"ToolMessageChunk\"\n    ) {\n      type = \"tool\";\n    } else {\n      type = \"unknown\";\n    }\n    rest = params.kwargs as BaseMessageFields;\n  } else {\n    const { type: extractedType, ...otherParams } = params;\n    type = extractedType;\n    rest = otherParams;\n  }\n  if (type === \"human\" || type === \"user\") {\n    return new HumanMessage(rest);\n  } else if (type === \"ai\" || type === \"assistant\") {\n    const { tool_calls: rawToolCalls, ...other } = rest;\n    if (!Array.isArray(rawToolCalls)) {\n      return new AIMessage(rest);\n    }\n    const tool_calls = rawToolCalls.map(_coerceToolCall);\n    return new AIMessage({ ...other, tool_calls });\n  } else if (type === \"system\") {\n    return new SystemMessage(rest);\n  } else if (type === \"developer\") {\n    return new SystemMessage({\n      ...rest,\n      additional_kwargs: {\n        ...rest.additional_kwargs,\n        __openai_role__: \"developer\",\n      },\n    });\n  } else if (type === \"tool\" && \"tool_call_id\" in rest) {\n    return new ToolMessage({\n      ...rest,\n      content: rest.content,\n      tool_call_id: rest.tool_call_id as string,\n      name: rest.name,\n    });\n  } else if (type === \"remove\" && \"id\" in rest && typeof rest.id === \"string\") {\n    return new RemoveMessage({ ...rest, id: rest.id });\n  } else {\n    const error = addLangChainErrorFields(\n      new Error(\n        `Unable to coerce message from array: only human, AI, system, developer, or tool message coercion is currently supported.\\n\\nReceived: ${JSON.stringify(\n          params,\n          null,\n          2\n        )}`\n      ),\n      \"MESSAGE_COERCION_FAILURE\"\n    );\n    throw error;\n  }\n}\n\nexport function coerceMessageLikeToMessage(\n  messageLike: BaseMessageLike\n): BaseMessage {\n  if (typeof messageLike === \"string\") {\n    return new HumanMessage(messageLike);\n  } else if (isBaseMessage(messageLike)) {\n    return messageLike;\n  }\n  if (Array.isArray(messageLike)) {\n    const [type, content] = messageLike;\n    return _constructMessageFromParams({ type, content });\n  } else if (_isMessageFieldWithRole(messageLike)) {\n    const { role: type, ...rest } = messageLike;\n    return _constructMessageFromParams({ ...rest, type });\n  } else {\n    return _constructMessageFromParams(messageLike);\n  }\n}\n\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n *\n * Produces compact output like:\n * ```\n * Human: What's the weather?\n * AI: Let me check...[tool_calls]\n * Tool: 72Â°F and sunny\n * ```\n *\n * This avoids token inflation from metadata when stringifying message objects directly.\n */\nexport function getBufferString(\n  messages: BaseMessage[],\n  humanPrefix = \"Human\",\n  aiPrefix = \"AI\"\n): string {\n  const string_messages: string[] = [];\n  for (const m of messages) {\n    let role: string;\n    if (m.type === \"human\") {\n      role = humanPrefix;\n    } else if (m.type === \"ai\") {\n      role = aiPrefix;\n    } else if (m.type === \"system\") {\n      role = \"System\";\n    } else if (m.type === \"tool\") {\n      role = \"Tool\";\n    } else if (m.type === \"generic\") {\n      role = (m as ChatMessage).role;\n    } else {\n      throw new Error(`Got unsupported message type: ${m.type}`);\n    }\n    const nameStr = m.name ? `${m.name}, ` : \"\";\n\n    // Use m.text property which extracts only text content, avoiding metadata\n    // For non-string content (e.g., content blocks), m.text extracts only text blocks\n    const readableContent = m.text;\n\n    let message = `${role}: ${nameStr}${readableContent}`;\n\n    // Include tool calls for AI messages (matching Python's get_buffer_string behavior)\n    if (m.type === \"ai\") {\n      const aiMessage = m as AIMessage;\n      if (aiMessage.tool_calls && aiMessage.tool_calls.length > 0) {\n        message += JSON.stringify(aiMessage.tool_calls);\n      } else if (\n        aiMessage.additional_kwargs &&\n        \"function_call\" in aiMessage.additional_kwargs\n      ) {\n        // Legacy behavior assumes only one function call per message\n        message += JSON.stringify(aiMessage.additional_kwargs.function_call);\n      }\n    }\n\n    string_messages.push(message);\n  }\n  return string_messages.join(\"\\n\");\n}\n\n/**\n * Maps messages from an older format (V1) to the current `StoredMessage`\n * format. If the message is already in the `StoredMessage` format, it is\n * returned as is. Otherwise, it transforms the V1 message into a\n * `StoredMessage`. This function is important for maintaining\n * compatibility with older message formats.\n */\nfunction mapV1MessageToStoredMessage(\n  message: StoredMessage | StoredMessageV1\n): StoredMessage {\n  // TODO: Remove this mapper when we deprecate the old message format.\n  if ((message as StoredMessage).data !== undefined) {\n    return message as StoredMessage;\n  } else {\n    const v1Message = message as StoredMessageV1;\n    return {\n      type: v1Message.type,\n      data: {\n        content: v1Message.text,\n        role: v1Message.role,\n        name: undefined,\n        tool_call_id: undefined,\n      },\n    };\n  }\n}\n\nexport function mapStoredMessageToChatMessage(message: StoredMessage) {\n  const storedMessage = mapV1MessageToStoredMessage(message);\n  switch (storedMessage.type) {\n    case \"human\":\n      return new HumanMessage(storedMessage.data);\n    case \"ai\":\n      return new AIMessage(storedMessage.data);\n    case \"system\":\n      return new SystemMessage(storedMessage.data);\n    case \"function\":\n      if (storedMessage.data.name === undefined) {\n        throw new Error(\"Name must be defined for function messages\");\n      }\n      return new FunctionMessage(storedMessage.data as FunctionMessageFields);\n    case \"tool\":\n      if (storedMessage.data.tool_call_id === undefined) {\n        throw new Error(\"Tool call ID must be defined for tool messages\");\n      }\n      return new ToolMessage(storedMessage.data as ToolMessageFields);\n    case \"generic\": {\n      if (storedMessage.data.role === undefined) {\n        throw new Error(\"Role must be defined for chat messages\");\n      }\n      return new ChatMessage(storedMessage.data as ChatMessageFields);\n    }\n    default:\n      throw new Error(`Got unexpected type: ${storedMessage.type}`);\n  }\n}\n\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport function mapStoredMessagesToChatMessages(\n  messages: StoredMessage[]\n): BaseMessage[] {\n  return messages.map(mapStoredMessageToChatMessage);\n}\n\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport function mapChatMessagesToStoredMessages(\n  messages: BaseMessage[]\n): StoredMessage[] {\n  return messages.map((message) => message.toDict());\n}\n\nexport function convertToChunk(message: BaseMessage) {\n  const type = message._getType();\n  if (type === \"human\") {\n    return new HumanMessageChunk({ ...message });\n  } else if (type === \"ai\") {\n    let aiChunkFields: AIMessageChunkFields = {\n      ...message,\n    };\n    if (\"tool_calls\" in aiChunkFields) {\n      aiChunkFields = {\n        ...aiChunkFields,\n        tool_call_chunks: aiChunkFields.tool_calls?.map((tc) => ({\n          ...tc,\n          type: \"tool_call_chunk\",\n          index: undefined,\n          args: JSON.stringify(tc.args),\n        })),\n      };\n    }\n    return new AIMessageChunk({ ...aiChunkFields });\n  } else if (type === \"system\") {\n    return new SystemMessageChunk({ ...message });\n  } else if (type === \"function\") {\n    return new FunctionMessageChunk({ ...message });\n  } else if (ChatMessage.isInstance(message)) {\n    return new ChatMessageChunk({ ...message });\n  } else {\n    throw new Error(\"Unknown message type.\");\n  }\n}\n\n/**\n * Collapses an array of tool call chunks into complete tool calls.\n *\n * This function groups tool call chunks by their id and/or index, then attempts to\n * parse and validate the accumulated arguments for each group. Successfully parsed\n * tool calls are returned as valid `ToolCall` objects, while malformed ones are\n * returned as `InvalidToolCall` objects.\n *\n * @param chunks - An array of `ToolCallChunk` objects to collapse\n * @returns An object containing:\n *   - `tool_call_chunks`: The original input chunks\n *   - `tool_calls`: An array of successfully parsed and validated tool calls\n *   - `invalid_tool_calls`: An array of tool calls that failed parsing or validation\n *\n * @remarks\n * Chunks are grouped using the following matching logic:\n * - If a chunk has both an id and index, it matches chunks with the same id and index\n * - If a chunk has only an id, it matches chunks with the same id\n * - If a chunk has only an index, it matches chunks with the same index\n *\n * For each group, the function:\n * 1. Concatenates all `args` strings from the chunks\n * 2. Attempts to parse the concatenated string as JSON\n * 3. Validates that the result is a non-null object with a valid id\n * 4. Creates either a `ToolCall` (if valid) or `InvalidToolCall` (if invalid)\n */\nexport function collapseToolCallChunks(chunks: ToolCallChunk[]): {\n  tool_call_chunks: ToolCallChunk[];\n  tool_calls: ToolCall[];\n  invalid_tool_calls: InvalidToolCall[];\n} {\n  const groupedToolCallChunks = chunks.reduce((acc, chunk) => {\n    const matchedChunkIndex = acc.findIndex(([match]) => {\n      // If chunk has an id and index, match if both are present\n      if (\n        \"id\" in chunk &&\n        chunk.id &&\n        \"index\" in chunk &&\n        chunk.index !== undefined\n      ) {\n        return chunk.id === match.id && chunk.index === match.index;\n      }\n      // If chunk has an id, we match on id\n      if (\"id\" in chunk && chunk.id) {\n        return chunk.id === match.id;\n      }\n      // If chunk has an index, we match on index\n      if (\"index\" in chunk && chunk.index !== undefined) {\n        return chunk.index === match.index;\n      }\n      return false;\n    });\n    if (matchedChunkIndex !== -1) {\n      acc[matchedChunkIndex].push(chunk);\n    } else {\n      acc.push([chunk]);\n    }\n    return acc;\n  }, [] as ToolCallChunk[][]);\n\n  const toolCalls: ToolCall[] = [];\n  const invalidToolCalls: InvalidToolCall[] = [];\n  for (const chunks of groupedToolCallChunks) {\n    let parsedArgs: Record<string, unknown> | null = null;\n    const name = chunks[0]?.name ?? \"\";\n    const joinedArgs = chunks\n      .map((c) => c.args || \"\")\n      .join(\"\")\n      .trim();\n    const argsStr = joinedArgs.length ? joinedArgs : \"{}\";\n    const id = chunks[0]?.id;\n    try {\n      parsedArgs = parsePartialJson(argsStr);\n      if (\n        !id ||\n        parsedArgs === null ||\n        typeof parsedArgs !== \"object\" ||\n        Array.isArray(parsedArgs)\n      ) {\n        throw new Error(\"Malformed tool call chunk args.\");\n      }\n      toolCalls.push({\n        name,\n        args: parsedArgs,\n        id,\n        type: \"tool_call\",\n      });\n    } catch {\n      invalidToolCalls.push({\n        name,\n        args: argsStr,\n        id,\n        error: \"Malformed args.\",\n        type: \"invalid_tool_call\",\n      });\n    }\n  }\n  return {\n    tool_call_chunks: chunks,\n    tool_calls: toolCalls,\n    invalid_tool_calls: invalidToolCalls,\n  };\n}\n"],"mappings":"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"}