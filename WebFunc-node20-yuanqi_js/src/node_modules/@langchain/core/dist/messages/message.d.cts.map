{"version":3,"file":"message.d.cts","names":["ContentBlock","ResponseMetadata","UsageMetadata","$MergeDiscriminatedUnion","$MergeObjects","MessageType","NonNullable","MessageOutputVersion","MessageToolDefinition","TInput","TOutput","MessageToolSet","$MessageToolCallBlock","TStructure","MessageStructure","K","Tools","ToolCall","$InferToolCalls","TTools","Record","$InferToolOutputs","Partial","$NormalizeMessageOutputVersion","T","Extract","$MergeOutputVersion","U","TV","UV","Exclude","$MergeContentDefinition","$MergeMessageStructure","StandardMessageStructure","Text","$NormalizedMessageStructure","$InferMessageContentBlocks","TRole","S","C","PropertyKey","$InferMessageContent","Array","$InferMessageProperties","P","Omit","$InferMessageProperty","$InferResponseMetadata","Message","isMessage"],"sources":["../../src/messages/message.d.ts"],"sourcesContent":["import type { ContentBlock } from \"./content/index.js\";\nimport type { ResponseMetadata, UsageMetadata } from \"./metadata.js\";\nimport type { $MergeDiscriminatedUnion, $MergeObjects } from \"./utils.js\";\n/**\n * Represents the possible types of messages in the system.\n * Includes standard message types (\"ai\", \"human\", \"tool\", \"system\")\n * and allows for custom string types that are non-null.\n *\n * @example\n * ```ts\n * // Standard message types\n * const messageType1: MessageType = \"ai\";\n * const messageType2: MessageType = \"human\";\n *\n * // Custom message type\n * const messageType3: MessageType = \"custom_type\";\n * ```\n */\nexport type MessageType = \"ai\" | \"human\" | \"tool\" | \"system\" | (string & NonNullable<unknown>);\n/**\n * Represents the output version format for message content.\n *\n * This type determines how the content field is structured in a message:\n * - \"v0\": Content is represented as a simple string or array of content blocks\n *   - provides backward compatibility with simpler content representations\n * - \"v1\": Content follows the structured ContentBlock format with typed discriminated unions\n *   - enables full type safety and structured content block handling\n *\n * @example\n * ```ts\n * // v0 format - simple content representation\n * const v0Message: Message<{ outputVersion: \"v0\", content: ... }> = {\n *   type: \"human\",\n *   content: \"Hello world\" // string | Array<ContentBlock | ContentBlock.Text>\n * };\n *\n * // v1 format - structured content blocks\n * const v1Message: Message<{ outputVersion: \"v1\", content: ... }> = {\n *   type: \"human\",\n *   content: [\n *     { type: \"text\", text: \"Hello world\" },\n *     { type: \"image\", image_url: \"...\" }\n *   ] // Array<ContentBlock | ...> (determined by the structure)\n * };\n * ```\n */\nexport type MessageOutputVersion = \"v0\" | \"v1\";\n/**\n * Represents the input and output types of a tool that can be used in messages.\n *\n * @template TInput - The type of input the tool accepts.\n * @template TOutput - The type of output the tool produces.\n *\n * @example\n * ```ts\n * // Tool that takes a string input and returns a number\n * interface StringToNumberTool extends MessageToolDefinition<string, number> {\n *   input: string;\n *   output: number;\n * }\n * ```\n */\nexport interface MessageToolDefinition<TInput = unknown, TOutput = unknown> {\n    input: TInput;\n    output: TOutput;\n}\n/**\n * Represents a structured set of tools by mapping tool names to definitions\n * that can be used in messages.\n *\n * @example\n * ```ts\n * interface MyToolSet extends MessageToolSet {\n *   calculator: MessageToolDefinition<\n *     { operation: string; numbers: number[] },\n *     number\n *   >;\n *   translator: MessageToolDefinition<\n *     { text: string; targetLanguage: string },\n *     string\n *   >;\n * }\n * ```\n */\nexport interface MessageToolSet {\n    [key: string]: MessageToolDefinition;\n}\n/**\n * Represents a tool call block within a message structure by mapping tool names to their\n * corresponding tool call formats, including the input arguments and an optional identifier.\n *\n * @template TStructure - A message structure type that may contain tool definitions\n *\n * @example\n * ```ts\n * // Given a message structure with a calculator tool:\n * interface MyStructure extends MessageStructure {\n *   tools: {\n *     calculator: MessageToolDefinition<{ operation: string, numbers: number[] }, number>\n *   }\n * }\n *\n * // The tool call block would be:\n * type CalcToolCall = $MessageToolCallBlock<MyStructure>;\n * // Resolves to:\n * // {\n * //   type: \"tool_call\";\n * //   name: \"calculator\";\n * //   args: { operation: string, numbers: number[] };\n * //   id?: string;\n * // }\n * ```\n */\nexport type $MessageToolCallBlock<TStructure extends MessageStructure> = TStructure[\"tools\"] extends MessageToolSet ? {\n    [K in keyof TStructure[\"tools\"]]: K extends string ? TStructure[\"tools\"][K] extends MessageToolDefinition ? ContentBlock.Tools.ToolCall<K, TStructure[\"tools\"][K][\"input\"]> : never : never;\n}[keyof TStructure[\"tools\"]] : never;\n/**\n * Helper type to infer a union of ToolCall types from the tools defined in a MessageStructure.\n * This is used to type the `tool_calls` array in AIMessage based on the available tools.\n *\n * @template TStructure - A message structure type that may contain tool definitions\n *\n * @example\n * ```ts\n * // Given a message structure with tools:\n * interface MyStructure extends MessageStructure {\n *   tools: {\n *     calculator: MessageToolDefinition<{ a: number, b: number }, number>;\n *     search: MessageToolDefinition<{ query: string }, string[]>;\n *   }\n * }\n *\n * // The inferred tool calls would be:\n * type ToolCalls = $InferToolCalls<MyStructure>;\n * // Resolves to:\n * // | { type?: \"tool_call\"; id?: string; name: \"calculator\"; args: { a: number, b: number } }\n * // | { type?: \"tool_call\"; id?: string; name: \"search\"; args: { query: string } }\n * ```\n */\nexport type $InferToolCalls<TStructure extends MessageStructure> = NonNullable<TStructure[\"tools\"]> extends MessageToolSet ? NonNullable<TStructure[\"tools\"]> extends infer TTools extends MessageToolSet ? {\n    [K in keyof TTools]: K extends string ? TTools[K] extends MessageToolDefinition ? {\n        readonly type?: \"tool_call\";\n        id?: string;\n        name: K;\n        args: [unknown] extends [TTools[K][\"input\"]] ? Record<string, any> : TTools[K][\"input\"];\n    } : never : never;\n}[keyof TTools] : never : {\n    readonly type?: \"tool_call\";\n    id?: string;\n    name: string;\n    args: Record<string, any>;\n};\n/**\n * Helper type to infer a union of tool output types from the tools defined in a MessageStructure.\n * This is used to type the `content` of ToolMessage based on the available tool outputs.\n *\n * @template TStructure - A message structure type that may contain tool definitions\n *\n * @example\n * ```ts\n * // Given a message structure with tools:\n * interface MyStructure extends MessageStructure {\n *   tools: {\n *     calculator: MessageToolDefinition<{ a: number, b: number }, number>;\n *     search: MessageToolDefinition<{ query: string }, string[]>;\n *   }\n * }\n *\n * // The inferred tool outputs would be:\n * type ToolOutputs = $InferToolOutputs<MyStructure>;\n * // Resolves to: number | string[]\n * ```\n */\nexport type $InferToolOutputs<TStructure extends MessageStructure> = NonNullable<TStructure[\"tools\"]> extends MessageToolSet ? NonNullable<TStructure[\"tools\"]> extends infer TTools extends MessageToolSet ? {\n    [K in keyof TTools]: TTools[K] extends MessageToolDefinition ? TTools[K][\"output\"] : never;\n}[keyof TTools] : unknown : unknown;\n/**\n * Core interface that defines the structure of messages.\n *\n * @example\n * ```ts\n * // Basic message structure with just content blocks\n * interface SimpleMessageStructure extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Text;\n *     // allows for text + reasoning blocks in ai messages\n *     ai: ContentBlock.Text | ContentBlock.Reasoning;\n *   }\n * }\n *\n * // Message structure with tools and properties\n * interface AdvancedMessageStructure extends MessageStructure {\n *   tools: {\n *     calculator: MessageToolDefinition<\n *       { operation: string; numbers: number[] },\n *       number\n *     >;\n *   };\n *   content: {\n *     // allows for text + image blocks in human messages\n *     human: ContentBlock.Text | ContentBlock.Multimodal.Image;\n *     // only allows for text blocks in ai messages\n *     ai: ContentBlock.Text;\n *   };\n *   properties: {\n *     // pins properties to ai messages\n *     ai: {\n *       response_metadata: {\n *         confidence: number;\n *         model: string;\n *       };\n *     };\n *   }\n * }\n *\n * // Using with $MergeMessageStructure to combine structures\n * // The resulting type when passed into BaseMessage will have a calculator tool,\n * // allow for text + image blocks in human messages,\n * // and text + reasoning blocks + additional arbitrary properties in ai messages.\n * type CombinedStructure = $MergeMessageStructure<\n *   SimpleMessageStructure,\n *   AdvancedMessageStructure\n * >;\n *\n * // Using in a Message object\n * const message: Message<CombinedStructure> = {\n *   id: \"msg-123\",\n *   type: \"human\",\n *   content: [\n *     { type: \"text\", text: \"Hello!\" }\n *     { type: \"image\", mimeType: \"image/jpeg\", url: \"https://example.com/image.jpg\" }\n *     // this block will throw an error because it's not defined in the structure\n *     { type: \"reasoning\", reasoning: \"The answer is 42\" }\n *   ]\n * };\n * ```\n */\nexport interface MessageStructure<TTools extends MessageToolSet = MessageToolSet> {\n    /**\n     * Optional output version for the message structure.\n     * If not provided, defaults to \"v0\".\n     */\n    readonly outputVersion?: MessageOutputVersion;\n    /**\n     * Optional set of tool definitions that can be used in messages.\n     * Each tool is defined with input/output types and can be referenced in tool messages.\n     */\n    readonly tools?: TTools;\n    /**\n     * Optional mapping of message types to their allowed content blocks.\n     * Each message type can specify what content block types it supports (text, images, etc).\n     */\n    readonly content?: Partial<{\n        [key in MessageType]: ContentBlock;\n    }>;\n    /**\n     * Optional mapping of message types to arbitrary property objects.\n     * Allows attaching custom metadata or other information to specific message types.\n     */\n    readonly properties?: Partial<{\n        [key in MessageType]: Record<string, unknown>;\n    }>;\n}\n/**\n * Normalizes an arbitrary type to a message output version or undefined.\n * Accepts unknown and narrows to a valid MessageOutputVersion if present.\n */\ntype $NormalizeMessageOutputVersion<T> = Extract<T, MessageOutputVersion> | undefined;\n/**\n * Merges two output version types from message structures.\n *\n * This utility type determines the resulting output version when combining two message structures.\n * The merge logic follows these rules:\n *\n * - If both T and U are undefined, defaults to \"v0\" for backwards compatibility\n * - If T is undefined but U is defined, uses U's version\n * - If U is undefined but T is defined, uses T's version\n * - If both T and U are defined, U takes precedence (later structure wins)\n *\n * @template T - The output version from the first message structure\n * @template U - The output version from the second message structure\n *\n * @example\n * ```ts\n * // Both undefined - defaults to \"v0\"\n * type Result1 = $MergeOutputVersion<undefined, undefined>; // \"v0\"\n *\n * // One defined - uses the defined version\n * type Result2 = $MergeOutputVersion<undefined, \"v1\">; // \"v1\"\n * type Result3 = $MergeOutputVersion<\"v0\", undefined>; // \"v0\"\n *\n * // Both defined - second takes precedence\n * type Result4 = $MergeOutputVersion<\"v0\", \"v1\">; // \"v1\"\n * ```\n */\nexport type $MergeOutputVersion<T, U> = $NormalizeMessageOutputVersion<T> extends infer TV ? $NormalizeMessageOutputVersion<U> extends infer UV ? [TV, UV] extends [undefined, undefined] ? \"v0\" : [TV] extends [undefined] ? Exclude<UV, undefined> : [UV] extends [undefined] ? Exclude<TV, undefined> : UV : never : never;\n/**\n * Merges two content definition objects from message structures.\n *\n * This utility type combines content definitions from two message structures, handling\n * the merging of content block types for each message type. The merge logic follows\n * these rules:\n *\n * - For keys that exist in both T and U: Merges the content blocks using discriminated\n *   union merging based on the \"type\" property. This allows combining different content\n *   block types (e.g., text + image) for the same message type.\n * - For keys that exist only in T: Uses T's content definition as-is\n * - For keys that exist only in U: Uses U's content definition as-is\n *\n * @template T - The content definition from the first message structure\n * @template U - The content definition from the second message structure\n *\n * @example\n * ```ts\n * // T allows text content for human messages\n * type ContentA = {\n *   human: ContentBlock.Text;\n * };\n *\n * // U allows image content for human messages and text for AI messages\n * type ContentB = {\n *   human: ContentBlock.Multimodal.Image;\n *   ai: ContentBlock.Text;\n * };\n *\n * // Merged result allows both text and images for human messages, text for AI\n * type Merged = $MergeContentDefinition<ContentA, ContentB>;\n * // Result: {\n * //   human: ContentBlock.Text | ContentBlock.Multimodal.Image;\n * //   ai: ContentBlock.Text;\n * // }\n * ```\n */\nexport type $MergeContentDefinition<T, U> = {\n    [K in keyof T | keyof U as Extract<(K extends keyof T ? T[K] : never) | (K extends keyof U ? U[K] : never), ContentBlock> extends never ? never : K]: K extends keyof T ? K extends keyof U ? $MergeDiscriminatedUnion<Extract<T[K], ContentBlock>, Extract<U[K], ContentBlock>, \"type\"> : Extract<T[K], ContentBlock> : K extends keyof U ? Extract<U[K], ContentBlock> : never;\n};\n/**\n * Merges two message structures A and B into a combined structure.\n * This is a type utility that handles merging of tools, content blocks, and properties\n * from two message structures. The resulting type is usable as its own message structure.\n *\n * @example\n * ```ts\n * // Structure A allows text in human messages and has a confidence property on AI messages\n * interface StructureA extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Text;\n *   };\n *   properties: {\n *     ai: { confidence: number };\n *   }\n * }\n *\n * // Structure B allows images in human messages and has a model property on AI messages\n * interface StructureB extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Multimodal.Image;\n *   };\n *   properties: {\n *     ai: { model: string };\n *   }\n * }\n *\n * // Merged structure allows both text and images in human messages\n * // AI messages have both confidence and model properties\n * type Merged = $MergeMessageStructure<StructureA, StructureB>;\n * ```\n *\n * @template A - First message structure to merge\n * @template B - Second message structure to merge (takes precedence over A)\n */\nexport type $MergeMessageStructure<T extends MessageStructure, U extends MessageStructure> = {\n    outputVersion: $MergeOutputVersion<T[\"outputVersion\"], U[\"outputVersion\"]>;\n    tools: $MergeObjects<T[\"tools\"], U[\"tools\"]>;\n    content: $MergeContentDefinition<T[\"content\"], U[\"content\"]>;\n    properties: $MergeObjects<T[\"properties\"], U[\"properties\"]>;\n};\n/**\n * Standard message structured used to define the most basic message structure that's\n * used throughout the library.\n *\n * This is also the message structure that's used when a message structure is not provided.\n */\nexport interface StandardMessageStructure extends MessageStructure {\n    content: {\n        /** Text content for AI messages */\n        ai: ContentBlock.Text;\n        /** Text content for human messages */\n        human: ContentBlock.Text;\n        /** Text content for system messages */\n        system: ContentBlock.Text;\n        /** Text content for tool messages */\n        tool: ContentBlock.Text;\n    };\n    properties: {\n        /** Properties specific to AI messages */\n        ai: {\n            /** Metadata about the AI model response */\n            response_metadata: ResponseMetadata;\n            /** Usage statistics for the AI response */\n            usage_metadata: UsageMetadata;\n        };\n        human: {\n            /** Metadata about the human message */\n            response_metadata: Record<string, unknown>;\n        };\n        system: {\n            /** Metadata about the system message */\n            response_metadata: Record<string, unknown>;\n        };\n        tool: {\n            /** Metadata about the tool message */\n            response_metadata: Record<string, unknown>;\n        };\n    };\n}\n/**\n * Takes a message structure type T and normalizes it by merging it with the standard message structure.\n * If T is already a standard message structure, returns T unchanged.\n *\n * This ensures that any custom message structure includes all the standard message structure fields\n * by default while allowing overrides and extensions.\n *\n * @template T - The message structure type to normalize, must extend MessageStructure\n * @returns Either T if it's already a standard structure, or the merged result of T with standard structure\n */\nexport type $NormalizedMessageStructure<T extends MessageStructure> = T extends StandardMessageStructure ? T : $MergeMessageStructure<StandardMessageStructure, T>;\n/**\n * Infers the content blocks for a specific message type in a message structure.\n *\n * This utility type extracts the content block type that corresponds to a given message type\n * from the message structure's content definition.\n *\n * @template TStructure - The message structure to infer content from\n * @template TRole - The message role/type to get content for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The content block type for the specified type, or never if its not defined in the structure\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   content: {\n *     human: ContentBlock.Text;\n *     ai: ContentBlock.Text | ContentBlock.ToolCall;\n *   };\n * }\n *\n * type HumanContent = $InferMessageContentBlocks<MyStructure, \"human\">;\n * // HumanContent = ContentBlock.Text\n *\n * type AIContent = $InferMessageContentBlocks<MyStructure, \"ai\">;\n * // AIContent = ContentBlock.Text | ContentBlock.ToolCall\n * ```\n */\nexport type $InferMessageContentBlocks<TStructure extends MessageStructure, TRole extends MessageType> = $NormalizedMessageStructure<TStructure> extends infer S ? S extends MessageStructure ? S[\"content\"] extends infer C ? C extends Record<PropertyKey, ContentBlock> ? TRole extends keyof C ? [$MessageToolCallBlock<TStructure>] extends [never] ? C[TRole] : $MergeDiscriminatedUnion<NonNullable<C[TRole]>, $MessageToolCallBlock<TStructure>, \"type\"> : never : never : never : never : never;\n/**\n * Infers the content type for a specific message type from a message structure.\n *\n * This utility type determines the appropriate content type based on the message structure's\n * output version and the specified message type. The content type varies depending on the\n * output version (see {@link MessageOutputVersion})\n *\n * @template TStructure - The message structure to infer content from\n * @template TRole - The message role/type to get content for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The content type for the specified role based on the output version\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   outputVersion: \"v0\";\n *   content: {\n *     human: ContentBlock.Text;\n *     ai: ContentBlock.Text | ContentBlock.ToolCall;\n *   };\n * }\n *\n * type HumanContentV0 = $InferMessageContent<MyStructure, \"human\">;\n * // HumanContentV0 = string | Array<ContentBlock | ContentBlock.Text>\n *\n * interface MyStructureV1 extends MessageStructure {\n *   outputVersion: \"v1\";\n *   content: {\n *     human: ContentBlock.Text;\n *     ai: ContentBlock.Text | ContentBlock.Reasoning;\n *   };\n * }\n *\n * type HumanContentV1 = $InferMessageContent<MyStructureV1, \"human\">;\n * // HumanContentV1 = ContentBlock.Text\n *\n * type AIContentV1 = $InferMessageContent<MyStructureV1, \"ai\">;\n * // AIContentV1 = ContentBlock.Text | ContentBlock.Reasoning\n * ```\n */\nexport type $InferMessageContent<TStructure extends MessageStructure, TRole extends MessageType> = TRole extends \"tool\" ? $InferToolOutputs<TStructure> extends infer TOutput ? [TOutput] extends [never] ? string | Array<ContentBlock | ContentBlock.Text> : [unknown] extends [TOutput] ? string | Array<ContentBlock | ContentBlock.Text> : TOutput | string | Array<ContentBlock | ContentBlock.Text> : string | Array<ContentBlock | ContentBlock.Text> : TStructure[\"outputVersion\"] extends \"v1\" ? Array<$InferMessageContentBlocks<TStructure, TRole>> : string | Array<ContentBlock | ContentBlock.Text>;\n/**\n * Infers the properties for a specific message type from a message structure.\n *\n * This utility type extracts the properties object that corresponds to a given message type\n * from the message structure's properties definition, and excludes the reserved\n * \"content\" and \"type\" properties to avoid conflicts with the core message structure.\n *\n * If the specified type is not defined in the message structure's properties, it returns\n * a generic Record<string, unknown> type to allow for arbitrary properties.\n *\n * @template TStructure - The message structure to infer properties from\n * @template TRole - The message type/role to get properties for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The properties object type for the specified type, excluding \"content\" and \"type\"\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   properties: {\n *     ai: {\n *       response_metadata: { model: string };\n *       usage_metadata: { tokens: number };\n *       content: string; // This will be omitted\n *       type: string;    // This will be omitted\n *     };\n *     human: { metadata: Record<string, unknown> };\n *   };\n * }\n *\n * type AIProperties = $InferMessageProperties<MyStructure, \"ai\">;\n * // AIProperties = { response_metadata: { model: string }; usage_metadata: { tokens: number } }\n *\n * type HumanProperties = $InferMessageProperties<MyStructure, \"human\">;\n * // HumanProperties = { metadata: Record<string, unknown> }\n *\n * type SystemProperties = $InferMessageProperties<MyStructure, \"system\">;\n * // SystemProperties = Record<string, unknown> (fallback for undefined role)\n * ```\n */\nexport type $InferMessageProperties<TStructure extends MessageStructure, TRole extends MessageType> = $NormalizedMessageStructure<TStructure> extends infer S ? S extends MessageStructure ? S[\"properties\"] extends infer P | undefined ? P extends Record<PropertyKey, unknown> ? TRole extends keyof P ? Omit<P[TRole], \"content\" | \"type\"> : Record<string, unknown> : Record<string, unknown> : Record<string, unknown> : never : never;\n/**\n * Infers the type of a specific property for a message type from a message structure.\n *\n * This utility type extracts the type of a single property by name from the properties\n * object that corresponds to a given message type. If the specified property key does\n * not exist in the type's properties, it returns `never`.\n *\n * @template TStructure - The message structure to infer the property from\n * @template TRole - The message type/role to get the property for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @template K - The property key to extract the type for\n * @returns The type of the specified property, or `never` if the property doesn't exist\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   properties: {\n *     ai: {\n *       response_metadata: { model: string; temperature: number };\n *       usage_metadata: { input_tokens: number; output_tokens: number };\n *     };\n *     human: { metadata: Record<string, unknown> };\n *   };\n * }\n *\n * type ResponseMetadata = $InferMessageProperty<MyStructure, \"ai\", \"response_metadata\">;\n * // ResponseMetadata = { model: string; temperature: number }\n *\n * type UsageMetadata = $InferMessageProperty<MyStructure, \"ai\", \"usage_metadata\">;\n * // UsageMetadata = { input_tokens: number; output_tokens: number }\n *\n * type NonExistentProperty = $InferMessageProperty<MyStructure, \"ai\", \"nonExistent\">;\n * // NonExistentProperty = Record<string, unknown>\n *\n * type HumanMetadata = $InferMessageProperty<MyStructure, \"human\", \"metadata\">;\n * // HumanMetadata = Record<string, unknown>\n * ```\n */\nexport type $InferMessageProperty<TStructure extends MessageStructure, TRole extends MessageType, K extends string> = K extends keyof $InferMessageProperties<TStructure, TRole> ? $InferMessageProperties<TStructure, TRole>[K] : never;\n/**\n * Infers the response metadata type for a specific message type from a message structure.\n *\n * This utility type extracts the `response_metadata` property type for a given message type.\n *\n * @template TStructure - The message structure to infer the response metadata from\n * @template TRole - The message type/role to get the response metadata for (e.g., \"ai\", \"human\", \"system\", \"tool\")\n * @returns The type of the response_metadata property, or `Record<string, unknown>` as fallback\n *\n * @example\n * ```ts\n * interface MyStructure extends MessageStructure {\n *   properties: {\n *     ai: {\n *       response_metadata: { model: string; temperature: number; tokens: number };\n *     };\n *     human: { metadata: Record<string, unknown> };\n *   };\n * }\n *\n * type AIResponseMetadata = $InferResponseMetadata<MyStructure, \"ai\">;\n * // AIResponseMetadata = { model: string; temperature: number; tokens: number }\n *\n * type HumanResponseMetadata = $InferResponseMetadata<MyStructure, \"human\">;\n * // HumanResponseMetadata = Record<string, unknown> (fallback since not defined)\n * ```\n */\nexport type $InferResponseMetadata<TStructure extends MessageStructure, TRole extends MessageType> = $InferMessageProperty<TStructure, TRole, \"response_metadata\"> extends infer P ? [P] extends [never] ? Record<string, unknown> : P : never;\n/**\n * Represents a message object that organizes context for an LLM.\n *\n * @example\n * ```ts\n * // Basic message with text content\n * const message: Message = {\n *   id: \"msg-123\",\n *   name: \"user\",\n *   type: \"human\",\n *   content: [{ type: \"text\", text: \"Hello!\" }]\n * };\n *\n * // Basic ai message interface extension\n * interface MyMessage extends Message<StandardMessageStructure, \"ai\"> {\n *   // Additional AI-specific properties can be added here\n * }\n *`\n * // Custom message structure\n * interface CustomStructure extends MessageStructure {\n *   content: {\n *     ai: ContentBlock.Text | ContentBlock.ToolCall<\"search\", { query: string }>;\n *     human: ContentBlock.Text | ContentBlock.Multimodal.Image;\n *   };\n * }\n *\n * // Create a message with custom structure\n * const message: Message<CustomStructure> = {\n *   id: \"msg-123\",\n *   name: \"user\",\n *   type: \"ai\",\n *   content: [\n *     { type: \"text\", text: \"Hello!\" },\n *     {\n *       type: \"tool_call\",\n *       name: \"search\",\n *       args: { query: \"What is the capital of France?\" }\n *     }\n *   ]\n * };\n * ```\n */\nexport interface Message<TStructure extends MessageStructure = StandardMessageStructure, TRole extends MessageType = MessageType> {\n    /** The message type/role */\n    readonly type: TRole;\n    /** Unique identifier for this message */\n    id?: string;\n    /**\n     * An optional name for the message participant.\n     *\n     * This property is primarily used to:\n     *\n     * 1. **Identify agent roles in multi-agent systems**: When multiple agents\n     *    collaborate, setting `name` helps distinguish which agent produced a\n     *    message, preventing confusion about who said what.\n     *\n     * 2. **Pass participant names to model providers**: Some providers (notably\n     *    OpenAI, e.g. see {@link https://platform.openai.com/docs/api-reference/chat/create | OpenAI Chat Completions API})\n     *    use this field to differentiate between participants with the\n     *    same role. For example, when using OpenAI's Chat Completions API, the\n     *    `name` is included in the message payload sent to the model.\n     *\n     * @example\n     * ```typescript\n     * // Setting name on an AIMessage to identify the agent\n     * const message = new AIMessage({\n     *   content: \"I'll handle the calendar scheduling.\",\n     *   name: \"calendar_agent\"\n     * });\n     *\n     * // In a multi-agent system, this helps track message origins\n     * const researcherMessage = new AIMessage({\n     *   content: \"Here are the findings...\",\n     *   name: \"researcher\"\n     * });\n     * const writerMessage = new AIMessage({\n     *   content: \"I've drafted the report.\",\n     *   name: \"writer\"\n     * });\n     * ```\n     */\n    name?: string;\n    /** Array of content blocks that make up the message content */\n    content: $InferMessageContent<TStructure, TRole>;\n    /** Metadata about the message */\n    response_metadata?: Partial<$InferResponseMetadata<TStructure, TRole>>;\n}\n/**\n * Type guard to check if a value is a valid Message object.\n *\n * @param message - The value to check\n * @returns true if the value is a valid Message object, false otherwise\n */\nexport declare function isMessage(message: unknown): message is Message;\nexport {};\n//# sourceMappingURL=message.d.ts.map"],"mappings":"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"}