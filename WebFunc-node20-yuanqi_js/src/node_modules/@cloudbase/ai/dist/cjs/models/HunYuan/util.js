"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.titleCaseToSnakeCase = exports.processInput = void 0;
function processInput(input) {
    var messages = input.messages, model = input.model, temperature = input.temperature, tool_choice = input.tool_choice, tools = input.tools, top_p = input.top_p;
    var handleTools = function () {
        if (!tools)
            return undefined;
        tools.forEach(function (tool) {
            if (tool.type !== 'function')
                console.warn('`type` in tool is not \'function\'', tool);
        });
        return tools;
    };
    var handleMessages = function () {
        messages.forEach(function (message) {
            if ('tool_calls' in message) {
                message.tool_calls
                    .filter(function (tool_call) { return tool_call.type !== 'function'; })
                    .forEach(function (tool_call) { return console.warn('`type` in tool_call is not \'function\'', tool_call, message); });
            }
        });
        return messages;
    };
    return __assign(__assign({}, input), { messages: handleMessages(), model: model, tools: handleTools(), top_p: top_p, tool_choice: tool_choice, temperature: temperature });
}
exports.processInput = processInput;
function titleCaseToSnakeCase(obj) {
    if (typeof obj !== 'object' || obj == null)
        return obj;
    if (Array.isArray(obj))
        return obj.map(function (item) { return titleCaseToSnakeCase(item); });
    return Object.entries(obj).reduce(function (acc, _a) {
        var key = _a[0], value = _a[1];
        var snakeCaseKey = toSnakeCase(key);
        acc[snakeCaseKey] = typeof value === 'object' ? titleCaseToSnakeCase(value) : value;
        return acc;
    }, {});
    function toSnakeCase(s) {
        var ret = s.replace(/[A-Z]/g, function (match) { return "_".concat(match.toLowerCase()); });
        return ret.charAt(0) === '_' ? ret.slice(1) : ret;
    }
}
exports.titleCaseToSnakeCase = titleCaseToSnakeCase;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3NyYy9tb2RlbHMvSHVuWXVhbi91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBVUEsU0FBZ0IsWUFBWSxDQUFDLEtBQXlCO0lBQzVDLElBQUEsUUFBUSxHQUFvRCxLQUFLLFNBQXpELEVBQUUsS0FBSyxHQUE2QyxLQUFLLE1BQWxELEVBQUUsV0FBVyxHQUFnQyxLQUFLLFlBQXJDLEVBQUUsV0FBVyxHQUFtQixLQUFLLFlBQXhCLEVBQUUsS0FBSyxHQUFZLEtBQUssTUFBakIsRUFBRSxLQUFLLEdBQUssS0FBSyxNQUFWLENBQVU7SUFFekUsSUFBTSxXQUFXLEdBQUc7UUFDbEIsSUFBSSxDQUFDLEtBQUs7WUFBRSxPQUFPLFNBQVMsQ0FBQTtRQUM1QixLQUFLLENBQUMsT0FBTyxDQUFDLFVBQUMsSUFBSTtZQUNqQixJQUFJLElBQUksQ0FBQyxJQUFJLEtBQUssVUFBVTtnQkFBRSxPQUFPLENBQUMsSUFBSSxDQUFDLG9DQUFvQyxFQUFFLElBQUksQ0FBQyxDQUFBO1FBQ3hGLENBQUMsQ0FBQyxDQUFBO1FBQ0YsT0FBTyxLQUFrQyxDQUFBO0lBQzNDLENBQUMsQ0FBQTtJQUVELElBQU0sY0FBYyxHQUFHO1FBQ3JCLFFBQVEsQ0FBQyxPQUFPLENBQUMsVUFBQyxPQUFPO1lBQ3ZCLElBQUksWUFBWSxJQUFJLE9BQU8sRUFBRTtnQkFDM0IsT0FBTyxDQUFDLFVBQVU7cUJBQ2YsTUFBTSxDQUFDLFVBQUEsU0FBUyxJQUFJLE9BQUEsU0FBUyxDQUFDLElBQUksS0FBSyxVQUFVLEVBQTdCLENBQTZCLENBQUM7cUJBQ2xELE9BQU8sQ0FBQyxVQUFBLFNBQVMsSUFBSSxPQUFBLE9BQU8sQ0FBQyxJQUFJLENBQUMseUNBQXlDLEVBQUUsU0FBUyxFQUFFLE9BQU8sQ0FBQyxFQUEzRSxDQUEyRSxDQUFDLENBQUE7YUFDckc7UUFDSCxDQUFDLENBQUMsQ0FBQTtRQUNGLE9BQU8sUUFBd0MsQ0FBQTtJQUNqRCxDQUFDLENBQUE7SUFFRCw2QkFDSyxLQUFLLEtBQ1IsUUFBUSxFQUFFLGNBQWMsRUFBRSxFQUMxQixLQUFLLE9BQUEsRUFDTCxLQUFLLEVBQUUsV0FBVyxFQUFFLEVBQ3BCLEtBQUssT0FBQSxFQUNMLFdBQVcsYUFBQSxFQUNYLFdBQVcsYUFBQSxJQUNaO0FBQ0gsQ0FBQztBQS9CRCxvQ0ErQkM7QUFFRCxTQUFnQixvQkFBb0IsQ0FBQyxHQUFZO0lBQy9DLElBQUksT0FBTyxHQUFHLEtBQUssUUFBUSxJQUFJLEdBQUcsSUFBSSxJQUFJO1FBQUUsT0FBTyxHQUFHLENBQUE7SUFFdEQsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQztRQUFFLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxVQUFBLElBQUksSUFBSSxPQUFBLG9CQUFvQixDQUFDLElBQUksQ0FBQyxFQUExQixDQUEwQixDQUFDLENBQUE7SUFFMUUsT0FBTyxNQUFNLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxVQUFDLEdBQUcsRUFBRSxFQUFZO1lBQVgsR0FBRyxRQUFBLEVBQUUsS0FBSyxRQUFBO1FBQ2pELElBQU0sWUFBWSxHQUFHLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQTtRQUVyQyxHQUFHLENBQUMsWUFBWSxDQUFDLEdBQUcsT0FBTyxLQUFLLEtBQUssUUFBUSxDQUFDLENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFBO1FBQ25GLE9BQU8sR0FBRyxDQUFBO0lBQ1osQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFBO0lBRU4sU0FBUyxXQUFXLENBQUMsQ0FBUztRQUM1QixJQUFNLEdBQUcsR0FBRyxDQUFDLENBQUMsT0FBTyxDQUFDLFFBQVEsRUFBRSxVQUFBLEtBQUssSUFBSSxPQUFBLFdBQUksS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFFLEVBQXpCLENBQXlCLENBQUMsQ0FBQTtRQUNuRSxPQUFPLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEtBQUssR0FBRyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUE7SUFDbkQsQ0FBQztBQUNILENBQUM7QUFoQkQsb0RBZ0JDIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgZXFlcWVxICovXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb24gKi9cbmltcG9ydCB7IEh1bll1YW5JbnB1dERhdGEgfSBmcm9tICcuL3R5cGUnXG5pbXBvcnQgeyBCYXNlQ2hhdE1vZGVsSW5wdXQgfSBmcm9tICcuLi8uLi90eXBlJ1xuXG4vKipcbiAqIOi/memHjOeahCBwcm9jZXNzIOWPquaYr+WvueS4jeespuWQiOeahCBpbnB1dCDlgZogd2FybmluZ+OAglxuICog5a6e6ZmF5LiK6L+Y5piv5Lya5aaC5a6e5Lyg6YCS44CCXG4gKiDpmLLmraLmnKrmnaXmqKHlnovlj4LmlbDmm7TmlrDvvIxTREsg5rKh6Lef5LiK6ICM5a+86Ie055So5oi36L6T5YWl5peg5rOV55Sf5pWI44CCXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzSW5wdXQoaW5wdXQ6IEJhc2VDaGF0TW9kZWxJbnB1dCk6IEh1bll1YW5JbnB1dERhdGEge1xuICBjb25zdCB7IG1lc3NhZ2VzLCBtb2RlbCwgdGVtcGVyYXR1cmUsIHRvb2xfY2hvaWNlLCB0b29scywgdG9wX3AgfSA9IGlucHV0XG5cbiAgY29uc3QgaGFuZGxlVG9vbHMgPSAoKSA9PiB7XG4gICAgaWYgKCF0b29scykgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHRvb2xzLmZvckVhY2goKHRvb2wpID0+IHtcbiAgICAgIGlmICh0b29sLnR5cGUgIT09ICdmdW5jdGlvbicpIGNvbnNvbGUud2FybignYHR5cGVgIGluIHRvb2wgaXMgbm90IFxcJ2Z1bmN0aW9uXFwnJywgdG9vbClcbiAgICB9KVxuICAgIHJldHVybiB0b29scyBhcyBIdW5ZdWFuSW5wdXREYXRhWyd0b29scyddXG4gIH1cblxuICBjb25zdCBoYW5kbGVNZXNzYWdlcyA9ICgpID0+IHtcbiAgICBtZXNzYWdlcy5mb3JFYWNoKChtZXNzYWdlKSA9PiB7XG4gICAgICBpZiAoJ3Rvb2xfY2FsbHMnIGluIG1lc3NhZ2UpIHtcbiAgICAgICAgbWVzc2FnZS50b29sX2NhbGxzXG4gICAgICAgICAgLmZpbHRlcih0b29sX2NhbGwgPT4gdG9vbF9jYWxsLnR5cGUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgICAgLmZvckVhY2godG9vbF9jYWxsID0+IGNvbnNvbGUud2FybignYHR5cGVgIGluIHRvb2xfY2FsbCBpcyBub3QgXFwnZnVuY3Rpb25cXCcnLCB0b29sX2NhbGwsIG1lc3NhZ2UpKVxuICAgICAgfVxuICAgIH0pXG4gICAgcmV0dXJuIG1lc3NhZ2VzIGFzIEh1bll1YW5JbnB1dERhdGFbJ21lc3NhZ2VzJ11cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4uaW5wdXQsXG4gICAgbWVzc2FnZXM6IGhhbmRsZU1lc3NhZ2VzKCksXG4gICAgbW9kZWwsXG4gICAgdG9vbHM6IGhhbmRsZVRvb2xzKCksXG4gICAgdG9wX3AsXG4gICAgdG9vbF9jaG9pY2UsXG4gICAgdGVtcGVyYXR1cmUsXG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpdGxlQ2FzZVRvU25ha2VDYXNlKG9iajogdW5rbm93bikge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmogLy8g5aaC5p6c5LiN5piv5a+56LGh5oiW6ICF5pivbnVsbO+8jOWImeebtOaOpei/lOWbnlxuXG4gIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHJldHVybiBvYmoubWFwKGl0ZW0gPT4gdGl0bGVDYXNlVG9TbmFrZUNhc2UoaXRlbSkpIC8vIOWmguaenOaYr+aVsOe7hO+8jOmAkuW9kuWkhOeQhuavj+S4quWFg+e0oFxuXG4gIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopLnJlZHVjZSgoYWNjLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBjb25zdCBzbmFrZUNhc2VLZXkgPSB0b1NuYWtlQ2FzZShrZXkpXG5cbiAgICBhY2Nbc25ha2VDYXNlS2V5XSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgPyB0aXRsZUNhc2VUb1NuYWtlQ2FzZSh2YWx1ZSkgOiB2YWx1ZVxuICAgIHJldHVybiBhY2NcbiAgfSwge30pXG5cbiAgZnVuY3Rpb24gdG9TbmFrZUNhc2Uoczogc3RyaW5nKSB7XG4gICAgY29uc3QgcmV0ID0gcy5yZXBsYWNlKC9bQS1aXS9nLCBtYXRjaCA9PiBgXyR7bWF0Y2gudG9Mb3dlckNhc2UoKX1gKVxuICAgIHJldHVybiByZXQuY2hhckF0KDApID09PSAnXycgPyByZXQuc2xpY2UoMSkgOiByZXRcbiAgfVxufVxuIl19