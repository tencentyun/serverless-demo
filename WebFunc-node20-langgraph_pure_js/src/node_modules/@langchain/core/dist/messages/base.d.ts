import { ContentBlock } from "./content/index.js";
import { Serializable, SerializedConstructor } from "../load/serializable.js";
import { MessageStringFormat } from "./format.js";
import { $InferMessageContent, $InferResponseMetadata, Message, MessageStructure, MessageType } from "./message.js";

//#region src/messages/base.d.ts
/** @internal */
declare const MESSAGE_SYMBOL: unique symbol;
interface StoredMessageData {
  content: string;
  role: string | undefined;
  name: string | undefined;
  tool_call_id: string | undefined;
  additional_kwargs?: Record<string, any>;
  /** Response metadata. For example: response headers, logprobs, token counts, model name. */
  response_metadata?: Record<string, any>;
  id?: string;
}
interface StoredMessage {
  type: string;
  data: StoredMessageData;
}
interface StoredGeneration {
  text: string;
  message?: StoredMessage;
}
interface StoredMessageV1 {
  type: string;
  role: string | undefined;
  text: string;
}
type MessageContent = string | Array<ContentBlock>;
interface FunctionCall {
  /**
   * The arguments to call the function with, as generated by the model in JSON
   * format. Note that the model does not always generate valid JSON, and may
   * hallucinate parameters not defined by your function schema. Validate the
   * arguments in your code before calling your function.
   */
  arguments: string;
  /**
   * The name of the function to call.
   */
  name: string;
}
type BaseMessageFields<TStructure extends MessageStructure = MessageStructure, TRole extends MessageType = MessageType> = Pick<Message, "id" | "name"> & {
  content?: $InferMessageContent<TStructure, TRole>;
  contentBlocks?: Array<ContentBlock.Standard>;
  /** @deprecated */
  additional_kwargs?: {
    /**
     * @deprecated Use "tool_calls" field on AIMessages instead
     */
    function_call?: FunctionCall;
    /**
     * @deprecated Use "tool_calls" field on AIMessages instead
     */
    tool_calls?: OpenAIToolCall[];
    [key: string]: unknown;
  };
  response_metadata?: Partial<$InferResponseMetadata<TStructure, TRole>>;
};
declare function mergeContent(firstContent: MessageContent, secondContent: MessageContent): MessageContent;
/**
 * 'Merge' two statuses. If either value passed is 'error', it will return 'error'. Else
 * it will return 'success'.
 *
 * @param {"success" | "error" | undefined} left The existing value to 'merge' with the new value.
 * @param {"success" | "error" | undefined} right The new value to 'merge' with the existing value
 * @returns {"success" | "error"} The 'merged' value.
 */
declare function _mergeStatus(left?: "success" | "error", right?: "success" | "error"): "success" | "error" | undefined;
/**
 * Base class for all types of messages in a conversation. It includes
 * properties like `content`, `name`, and `additional_kwargs`. It also
 * includes methods like `toDict()` and `_getType()`.
 */
declare abstract class BaseMessage<TStructure extends MessageStructure = MessageStructure, TRole extends MessageType = MessageType> extends Serializable implements Message<TStructure, TRole> {
  lc_namespace: string[];
  lc_serializable: boolean;
  get lc_aliases(): Record<string, string>;
  readonly [MESSAGE_SYMBOL]: true;
  abstract readonly type: TRole;
  id?: string;
  /** @inheritdoc */
  name?: string;
  content: $InferMessageContent<TStructure, TRole>;
  additional_kwargs: NonNullable<BaseMessageFields<TStructure, TRole>["additional_kwargs"]>;
  response_metadata: NonNullable<BaseMessageFields<TStructure, TRole>["response_metadata"]>;
  /**
   * @deprecated Use .getType() instead or import the proper typeguard.
   * For example:
   *
   * ```ts
   * import { isAIMessage } from "@langchain/core/messages";
   *
   * const message = new AIMessage("Hello!");
   * isAIMessage(message); // true
   * ```
   */
  _getType(): MessageType;
  /**
   * @deprecated Use .type instead
   * The type of the message.
   */
  getType(): MessageType;
  constructor(arg: $InferMessageContent<TStructure, TRole> | BaseMessageFields<TStructure, TRole>);
  /** Get text content of the message. */
  get text(): string;
  get contentBlocks(): Array<ContentBlock.Standard>;
  toDict(): StoredMessage;
  static lc_name(): string;
  get _printableFields(): Record<string, unknown>;
  static isInstance(obj: unknown): obj is BaseMessage;
  _updateId(value: string | undefined): void;
  get [Symbol.toStringTag](): any;
  toFormattedString(format?: MessageStringFormat): string;
}
/**
 * @deprecated Use "tool_calls" field on AIMessages instead
 */
type OpenAIToolCall = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The function that the model called.
   */
  function: FunctionCall;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: "function";
  index?: number;
};
declare function isOpenAIToolCallArray(value?: unknown): value is OpenAIToolCall[];
declare function _mergeDicts(left: Record<string, any> | undefined, right: Record<string, any> | undefined): Record<string, any> | undefined;
declare function _mergeLists<Content extends ContentBlock>(left?: Content[], right?: Content[]): Content[] | undefined;
declare function _mergeObj<T = any>(left: T | undefined, right: T | undefined): T | undefined;
/**
 * Represents a chunk of a message, which can be concatenated with other
 * message chunks. It includes a method `_merge_kwargs_dict()` for merging
 * additional keyword arguments from another `BaseMessageChunk` into this
 * one. It also overrides the `__add__()` method to support concatenation
 * of `BaseMessageChunk` instances.
 */
declare abstract class BaseMessageChunk<TStructure extends MessageStructure = MessageStructure, TRole extends MessageType = MessageType> extends BaseMessage<TStructure, TRole> {
  abstract concat(chunk: BaseMessageChunk): BaseMessageChunk<TStructure, TRole>;
  static isInstance(obj: unknown): obj is BaseMessageChunk;
}
type MessageFieldWithRole = {
  role: MessageType;
  content: MessageContent;
  name?: string;
} & Record<string, unknown>;
declare function _isMessageFieldWithRole(x: BaseMessageLike): x is MessageFieldWithRole;
type BaseMessageLike = BaseMessage | MessageFieldWithRole | [MessageType, MessageContent] | string
/**
 * @deprecated Specifying "type" is deprecated and will be removed in 0.4.0.
 */ | ({
  type: MessageType | "user" | "assistant" | "placeholder";
} & BaseMessageFields & Record<string, unknown>) | SerializedConstructor;
/**
 * @deprecated Use {@link BaseMessage.isInstance} instead
 */
declare function isBaseMessage(messageLike?: unknown): messageLike is BaseMessage;
/**
 * @deprecated Use {@link BaseMessageChunk.isInstance} instead
 */
declare function isBaseMessageChunk(messageLike?: unknown): messageLike is BaseMessageChunk;
//#endregion
export { BaseMessage, BaseMessageChunk, BaseMessageFields, BaseMessageLike, FunctionCall, MessageContent, MessageFieldWithRole, OpenAIToolCall, StoredGeneration, StoredMessage, StoredMessageData, StoredMessageV1, _isMessageFieldWithRole, _mergeDicts, _mergeLists, _mergeObj, _mergeStatus, isBaseMessage, isBaseMessageChunk, isOpenAIToolCallArray, mergeContent };
//# sourceMappingURL=base.d.ts.map