import 'reflect-metadata';
import { TelemetryClient, CopilotKitLowLevelError, CopilotKitErrorCode, randomUUID, randomId, isTelemetryDisabled, CopilotKitMisuseError, getZodParameters, readBody, CopilotKitError, CopilotKitAgentDiscoveryError, parseJson, convertJsonSchemaToZodSchema } from '@copilotkit/shared';
import { HumanMessage, AIMessage, SystemMessage, ToolMessage } from '@langchain/core/messages';
import { DynamicStructuredTool } from '@langchain/core/tools';
import { registerEnumType, Field, InputType, ObjectType, createUnionType, InterfaceType, Query, Ctx, Mutation, Arg, Resolver, buildSchemaSync } from 'type-graphql';
import { tap, catchError, finalize, ReplaySubject, shareReplay, firstValueFrom, skipWhile, takeWhile, filter, Subject, take } from 'rxjs';
import { GraphQLJSON, GraphQLJSONObject } from 'graphql-scalars';
import { Repeater } from 'graphql-yoga';
import { plainToInstance } from 'class-transformer';
import { GraphQLError } from 'graphql';
import { createHash } from 'crypto';
import { InMemoryAgentRunner, CopilotRuntime as CopilotRuntime$1, createCopilotEndpointSingleRoute } from '@copilotkitnext/runtime';
import { BuiltInAgent } from '@copilotkitnext/agent';
import { useDeferStream } from '@graphql-yoga/plugin-defer-stream';
import createPinoLogger from 'pino';
import pretty from 'pino-pretty';
import { handle } from 'hono/vercel';
import { Readable } from 'stream';

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __commonJS = (cb, mod) => function __require2() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// package.json
var require_package = __commonJS({
  "package.json"(exports, module) {
    module.exports = {
      name: "@copilotkit/runtime",
      private: false,
      homepage: "https://github.com/CopilotKit/CopilotKit",
      repository: {
        type: "git",
        url: "https://github.com/CopilotKit/CopilotKit.git"
      },
      publishConfig: {
        access: "public"
      },
      version: "1.51.3",
      sideEffects: false,
      main: "./dist/index.js",
      module: "./dist/index.mjs",
      exports: {
        ".": {
          import: "./dist/index.mjs",
          require: "./dist/index.js",
          types: "./dist/index.d.ts"
        },
        "./v2": {
          import: "./dist/v2/index.mjs",
          require: "./dist/v2/index.js",
          types: "./dist/v2/index.d.ts"
        },
        "./langgraph": {
          import: "./dist/langgraph.mjs",
          require: "./dist/langgraph.js",
          types: "./dist/langgraph.d.ts"
        }
      },
      types: "./dist/index.d.ts",
      license: "MIT",
      scripts: {
        build: "pnpm run generate-graphql-schema && tsup",
        dev: 'tsup --watch --onSuccess "pnpm run generate-graphql-schema"',
        test: "jest --passWithNoTests",
        "check-types": "tsc --noEmit",
        clean: "rm -rf .turbo && rm -rf node_modules && rm -rf dist && rm -rf .next && rm -rf __snapshots__",
        "generate-graphql-schema": "rm -rf __snapshots__ && ts-node ./scripts/generate-gql-schema.ts",
        "link:global": "pnpm link --global",
        "unlink:global": "pnpm unlink --global"
      },
      devDependencies: {
        "@jest/globals": "^29.7.0",
        "@swc/core": "1.5.28",
        "@types/jest": "^29.5.12",
        "@types/node": "^18.11.17",
        "@whatwg-node/server": "^0.9.34",
        eslint: "^8.56.0",
        "eslint-config-custom": "workspace:*",
        jest: "^29.6.4",
        nodemon: "^3.1.3",
        "ts-jest": "^29.1.1",
        "ts-node": "^10.9.2",
        tsconfig: "workspace:*",
        tsup: "^6.7.0",
        typescript: "^5.2.3",
        vitest: "^3.2.4"
      },
      dependencies: {
        "@ag-ui/client": "^0.0.43",
        "@ag-ui/core": "^0.0.43",
        "@ag-ui/langgraph": "^0.0.23",
        "@copilotkit/shared": "workspace:*",
        "@copilotkitnext/agent": "workspace:*",
        "@copilotkitnext/runtime": "workspace:*",
        "@graphql-yoga/plugin-defer-stream": "^3.3.1",
        "@hono/node-server": "^1.13.5",
        "@scarf/scarf": "^1.3.0",
        "class-transformer": "^0.5.1",
        "class-validator": "^0.14.1",
        graphql: "^16.8.1",
        "graphql-scalars": "^1.23.0",
        "graphql-yoga": "^5.3.1",
        hono: "^4.11.4",
        openai: "^4.85.1",
        "partial-json": "^0.1.7",
        pino: "^9.2.0",
        "pino-pretty": "^11.2.1",
        "reflect-metadata": "^0.2.2",
        rxjs: "7.8.1",
        "type-graphql": "2.0.0-rc.1",
        zod: "^3.23.3"
      },
      peerDependencies: {
        "@anthropic-ai/sdk": "^0.57.0",
        "@copilotkit/shared": "workspace:*",
        "@copilotkitnext/agent": "workspace:*",
        "@copilotkitnext/runtime": "workspace:*",
        "@langchain/aws": ">=0.1.9",
        "@langchain/core": ">=0.3.66",
        "@langchain/community": ">=0.3.58",
        "@langchain/google-gauth": ">=0.1.0",
        "@langchain/langgraph-sdk": ">=0.1.2",
        "@langchain/openai": ">=0.4.2",
        "groq-sdk": ">=0.3.0 <1.0.0",
        langchain: ">=0.3.3",
        openai: "^4.85.1"
      },
      peerDependenciesMeta: {
        "@anthropic-ai/sdk": {
          optional: true
        },
        "@langchain/aws": {
          optional: true
        },
        "@langchain/community": {
          optional: true
        },
        "@langchain/google-gauth": {
          optional: true
        },
        "@langchain/langgraph-sdk": {
          optional: true
        },
        "@langchain/openai": {
          optional: true
        },
        "groq-sdk": {
          optional: true
        },
        langchain: {
          optional: true
        },
        openai: {
          optional: true
        }
      },
      keywords: [
        "copilotkit",
        "copilot",
        "react",
        "nextjs",
        "nodejs",
        "ai",
        "assistant",
        "javascript",
        "automation",
        "textarea"
      ]
    };
  }
});
function limitMessagesToTokenCount(messages, tools, model, maxTokens) {
  maxTokens || (maxTokens = maxTokensForOpenAIModel(model));
  const result = [];
  const toolsNumTokens = countToolsTokens(model, tools);
  if (toolsNumTokens > maxTokens) {
    throw new Error(`Too many tokens in function definitions: ${toolsNumTokens} > ${maxTokens}`);
  }
  maxTokens -= toolsNumTokens;
  for (const message of messages) {
    if ([
      "system",
      "developer"
    ].includes(message.role)) {
      const numTokens = countMessageTokens(model, message);
      maxTokens -= numTokens;
      if (maxTokens < 0) {
        throw new Error("Not enough tokens for system message.");
      }
    }
  }
  let cutoff = false;
  const reversedMessages = [
    ...messages
  ].reverse();
  for (const message of reversedMessages) {
    if ([
      "system",
      "developer"
    ].includes(message.role)) {
      result.unshift(message);
      continue;
    } else if (cutoff) {
      continue;
    }
    let numTokens = countMessageTokens(model, message);
    if (maxTokens < numTokens) {
      cutoff = true;
      continue;
    }
    result.unshift(message);
    maxTokens -= numTokens;
  }
  return result;
}
__name(limitMessagesToTokenCount, "limitMessagesToTokenCount");
function maxTokensForOpenAIModel(model) {
  return maxTokensByModel[model] || DEFAULT_MAX_TOKENS;
}
__name(maxTokensForOpenAIModel, "maxTokensForOpenAIModel");
var DEFAULT_MAX_TOKENS = 128e3;
var maxTokensByModel = {
  // o1
  o1: 2e5,
  "o1-2024-12-17": 2e5,
  "o1-mini": 128e3,
  "o1-mini-2024-09-12": 128e3,
  "o1-preview": 128e3,
  "o1-preview-2024-09-12": 128e3,
  // o3-mini
  "o3-mini": 2e5,
  "o3-mini-2025-01-31": 2e5,
  // GPT-4
  "gpt-4o": 128e3,
  "chatgpt-4o-latest": 128e3,
  "gpt-4o-2024-08-06": 128e3,
  "gpt-4o-2024-05-13": 128e3,
  "gpt-4o-mini": 128e3,
  "gpt-4o-mini-2024-07-18": 128e3,
  "gpt-4-turbo": 128e3,
  "gpt-4-turbo-2024-04-09": 128e3,
  "gpt-4-0125-preview": 128e3,
  "gpt-4-turbo-preview": 128e3,
  "gpt-4-1106-preview": 128e3,
  "gpt-4-vision-preview": 128e3,
  "gpt-4-1106-vision-preview": 128e3,
  "gpt-4-32k": 32768,
  "gpt-4-32k-0613": 32768,
  "gpt-4-32k-0314": 32768,
  "gpt-4": 8192,
  "gpt-4-0613": 8192,
  "gpt-4-0314": 8192,
  // GPT-3.5
  "gpt-3.5-turbo-0125": 16385,
  "gpt-3.5-turbo": 16385,
  "gpt-3.5-turbo-1106": 16385,
  "gpt-3.5-turbo-instruct": 4096,
  "gpt-3.5-turbo-16k": 16385,
  "gpt-3.5-turbo-0613": 4096,
  "gpt-3.5-turbo-16k-0613": 16385,
  "gpt-3.5-turbo-0301": 4097
};
function countToolsTokens(model, tools) {
  if (tools.length === 0) {
    return 0;
  }
  const json = JSON.stringify(tools);
  return countTokens(model, json);
}
__name(countToolsTokens, "countToolsTokens");
function countMessageTokens(model, message) {
  return countTokens(model, message.content || "");
}
__name(countMessageTokens, "countMessageTokens");
function countTokens(model, text) {
  return text.length / 3;
}
__name(countTokens, "countTokens");
function convertActionInputToOpenAITool(action) {
  return {
    type: "function",
    function: {
      name: action.name,
      description: action.description,
      parameters: parseJson(action.jsonSchema, {})
    }
  };
}
__name(convertActionInputToOpenAITool, "convertActionInputToOpenAITool");
function convertMessageToOpenAIMessage(message, options) {
  const { keepSystemRole } = options || {
    keepSystemRole: false
  };
  if (message.isTextMessage()) {
    let role = message.role;
    if (message.role === "system" && !keepSystemRole) {
      role = "developer";
    }
    return {
      role,
      content: message.content
    };
  } else if (message.isImageMessage()) {
    return {
      role: "user",
      content: [
        {
          type: "image_url",
          image_url: {
            url: `data:image/${message.format};base64,${message.bytes}`
          }
        }
      ]
    };
  } else if (message.isActionExecutionMessage()) {
    return {
      role: "assistant",
      tool_calls: [
        {
          id: message.id,
          type: "function",
          function: {
            name: message.name,
            arguments: JSON.stringify(message.arguments)
          }
        }
      ]
    };
  } else if (message.isResultMessage()) {
    return {
      role: "tool",
      content: message.result,
      tool_call_id: message.actionExecutionId
    };
  }
}
__name(convertMessageToOpenAIMessage, "convertMessageToOpenAIMessage");
function convertSystemMessageToAssistantAPI(message) {
  return {
    ...message,
    ...[
      "system",
      "developer"
    ].includes(message.role) && {
      role: "assistant",
      content: "THE FOLLOWING MESSAGE IS A SYSTEM MESSAGE: " + message.content
    }
  };
}
__name(convertSystemMessageToAssistantAPI, "convertSystemMessageToAssistantAPI");
function convertServiceAdapterError(error, adapterName) {
  var _a, _b, _c;
  const errorName = ((_a = error == null ? void 0 : error.constructor) == null ? void 0 : _a.name) || error.name;
  const errorMessage = (error == null ? void 0 : error.message) || String(error);
  const statusCode = error.status || error.statusCode || ((_b = error.response) == null ? void 0 : _b.status);
  const responseData = error.error || ((_c = error.response) == null ? void 0 : _c.data) || error.data;
  const structuredError = new CopilotKitLowLevelError({
    error: error instanceof Error ? error : new Error(errorMessage),
    url: `${adapterName} service adapter`,
    message: `${adapterName} API error: ${errorMessage}`
  });
  if (statusCode) {
    structuredError.statusCode = statusCode;
  }
  if (responseData) {
    structuredError.responseData = responseData;
  }
  if (errorName) {
    structuredError.originalErrorType = errorName;
  }
  let newCode;
  if (statusCode === 401) {
    newCode = CopilotKitErrorCode.AUTHENTICATION_ERROR;
  } else if (statusCode >= 400 && statusCode < 500) {
    newCode = CopilotKitErrorCode.CONFIGURATION_ERROR;
  } else if (statusCode >= 500) {
    newCode = CopilotKitErrorCode.NETWORK_ERROR;
  } else if (statusCode) {
    newCode = CopilotKitErrorCode.CONFIGURATION_ERROR;
  } else {
    newCode = CopilotKitErrorCode.NETWORK_ERROR;
  }
  structuredError.code = newCode;
  if (structuredError.extensions) {
    structuredError.extensions.code = newCode;
  }
  return structuredError;
}
__name(convertServiceAdapterError, "convertServiceAdapterError");

// src/service-adapters/openai/openai-adapter.ts
var DEFAULT_MODEL = "gpt-4o";
var OpenAIAdapter = class {
  model = DEFAULT_MODEL;
  provider = "openai";
  disableParallelToolCalls = false;
  _openai;
  keepSystemRole = false;
  get openai() {
    return this._openai;
  }
  get name() {
    return "OpenAIAdapter";
  }
  constructor(params) {
    if (params == null ? void 0 : params.openai) {
      this._openai = params.openai;
    }
    if (params == null ? void 0 : params.model) {
      this.model = params.model;
    }
    this.disableParallelToolCalls = (params == null ? void 0 : params.disableParallelToolCalls) || false;
    this.keepSystemRole = (params == null ? void 0 : params.keepSystemRole) ?? false;
  }
  ensureOpenAI() {
    if (!this._openai) {
      const OpenAI = __require("openai").default;
      this._openai = new OpenAI();
    }
    return this._openai;
  }
  async process(request) {
    const { threadId: threadIdFromRequest, model = this.model, messages, actions, eventSource, forwardedParameters } = request;
    const tools = actions.map(convertActionInputToOpenAITool);
    const threadId = threadIdFromRequest ?? randomUUID();
    const validToolUseIds = /* @__PURE__ */ new Set();
    for (const message of messages) {
      if (message.isActionExecutionMessage()) {
        validToolUseIds.add(message.id);
      }
    }
    const filteredMessages = messages.filter((message) => {
      if (message.isResultMessage()) {
        if (!validToolUseIds.has(message.actionExecutionId)) {
          return false;
        }
        validToolUseIds.delete(message.actionExecutionId);
        return true;
      }
      return true;
    });
    let openaiMessages = filteredMessages.map((m) => convertMessageToOpenAIMessage(m, {
      keepSystemRole: this.keepSystemRole
    }));
    openaiMessages = limitMessagesToTokenCount(openaiMessages, tools, model);
    let toolChoice = forwardedParameters == null ? void 0 : forwardedParameters.toolChoice;
    if ((forwardedParameters == null ? void 0 : forwardedParameters.toolChoice) === "function") {
      toolChoice = {
        type: "function",
        function: {
          name: forwardedParameters.toolChoiceFunctionName
        }
      };
    }
    try {
      const openai = this.ensureOpenAI();
      const stream = openai.beta.chat.completions.stream({
        model,
        stream: true,
        messages: openaiMessages,
        ...tools.length > 0 && {
          tools
        },
        ...(forwardedParameters == null ? void 0 : forwardedParameters.maxTokens) && {
          max_completion_tokens: forwardedParameters.maxTokens
        },
        ...(forwardedParameters == null ? void 0 : forwardedParameters.stop) && {
          stop: forwardedParameters.stop
        },
        ...toolChoice && {
          tool_choice: toolChoice
        },
        ...this.disableParallelToolCalls && {
          parallel_tool_calls: false
        },
        ...(forwardedParameters == null ? void 0 : forwardedParameters.temperature) && {
          temperature: forwardedParameters.temperature
        }
      });
      eventSource.stream(async (eventStream$) => {
        var _a, _b;
        let mode = null;
        let currentMessageId;
        let currentToolCallId;
        try {
          for await (const chunk of stream) {
            if (chunk.choices.length === 0) {
              continue;
            }
            const toolCall = (_a = chunk.choices[0].delta.tool_calls) == null ? void 0 : _a[0];
            const content = chunk.choices[0].delta.content;
            if (mode === "message" && (toolCall == null ? void 0 : toolCall.id)) {
              mode = null;
              eventStream$.sendTextMessageEnd({
                messageId: currentMessageId
              });
            } else if (mode === "function" && (toolCall === void 0 || (toolCall == null ? void 0 : toolCall.id))) {
              mode = null;
              eventStream$.sendActionExecutionEnd({
                actionExecutionId: currentToolCallId
              });
            }
            if (mode === null) {
              if (toolCall == null ? void 0 : toolCall.id) {
                mode = "function";
                currentToolCallId = toolCall.id;
                eventStream$.sendActionExecutionStart({
                  actionExecutionId: currentToolCallId,
                  parentMessageId: chunk.id,
                  actionName: toolCall.function.name
                });
              } else if (content) {
                mode = "message";
                currentMessageId = chunk.id;
                eventStream$.sendTextMessageStart({
                  messageId: currentMessageId
                });
              }
            }
            if (mode === "message" && content) {
              eventStream$.sendTextMessageContent({
                messageId: currentMessageId,
                content
              });
            } else if (mode === "function" && ((_b = toolCall == null ? void 0 : toolCall.function) == null ? void 0 : _b.arguments)) {
              eventStream$.sendActionExecutionArgs({
                actionExecutionId: currentToolCallId,
                args: toolCall.function.arguments
              });
            }
          }
          if (mode === "message") {
            eventStream$.sendTextMessageEnd({
              messageId: currentMessageId
            });
          } else if (mode === "function") {
            eventStream$.sendActionExecutionEnd({
              actionExecutionId: currentToolCallId
            });
          }
        } catch (error) {
          console.error("[OpenAI] Error during API call:", error);
          throw convertServiceAdapterError(error, "OpenAI");
        }
        eventStream$.complete();
      });
    } catch (error) {
      console.error("[OpenAI] Error during API call:", error);
      throw convertServiceAdapterError(error, "OpenAI");
    }
    return {
      threadId
    };
  }
};
__name(OpenAIAdapter, "OpenAIAdapter");
function convertMessageToLangChainMessage(message) {
  if (message.isTextMessage()) {
    if (message.role == "user") {
      return new HumanMessage(message.content);
    } else if (message.role == "assistant") {
      return new AIMessage(message.content);
    } else if (message.role === "system") {
      return new SystemMessage(message.content);
    }
  } else if (message.isActionExecutionMessage()) {
    return new AIMessage({
      content: "",
      tool_calls: [
        {
          id: message.id,
          args: message.arguments,
          name: message.name
        }
      ]
    });
  } else if (message.isResultMessage()) {
    return new ToolMessage({
      content: message.result,
      tool_call_id: message.actionExecutionId
    });
  }
}
__name(convertMessageToLangChainMessage, "convertMessageToLangChainMessage");
function convertActionInputToLangChainTool(actionInput) {
  return new DynamicStructuredTool({
    ...actionInput,
    name: actionInput.name,
    description: actionInput.description,
    schema: convertJsonSchemaToZodSchema(JSON.parse(actionInput.jsonSchema), true),
    func: async () => {
      return "";
    }
  });
}
__name(convertActionInputToLangChainTool, "convertActionInputToLangChainTool");
function isAIMessage(message) {
  return Object.prototype.toString.call(message) === "[object AIMessage]";
}
__name(isAIMessage, "isAIMessage");
function isAIMessageChunk(message) {
  return Object.prototype.toString.call(message) === "[object AIMessageChunk]";
}
__name(isAIMessageChunk, "isAIMessageChunk");
function isBaseMessageChunk(message) {
  return Object.prototype.toString.call(message) === "[object BaseMessageChunk]";
}
__name(isBaseMessageChunk, "isBaseMessageChunk");
function maybeSendActionExecutionResultIsMessage(eventStream$, actionExecution) {
  if (actionExecution) {
    eventStream$.sendActionExecutionResult({
      actionExecutionId: actionExecution.id,
      actionName: actionExecution.name,
      result: "Sending a message"
    });
  }
}
__name(maybeSendActionExecutionResultIsMessage, "maybeSendActionExecutionResultIsMessage");
async function streamLangChainResponse({ result, eventStream$, actionExecution }) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
  if (typeof result === "string") {
    if (!actionExecution || (actionExecution == null ? void 0 : actionExecution.returnDirect)) {
      eventStream$.sendActionExecutionResult({
        actionExecutionId: actionExecution.id,
        actionName: actionExecution.name,
        result
      });
      eventStream$.sendTextMessage(randomId(), result);
    } else {
      eventStream$.sendActionExecutionResult({
        actionExecutionId: actionExecution.id,
        actionName: actionExecution.name,
        result
      });
    }
  } else if (isAIMessage(result)) {
    maybeSendActionExecutionResultIsMessage(eventStream$, actionExecution);
    if (result.content) {
      eventStream$.sendTextMessage(randomId(), result.content);
    }
    for (const toolCall of result.tool_calls) {
      eventStream$.sendActionExecution({
        actionExecutionId: toolCall.id || randomId(),
        actionName: toolCall.name,
        args: JSON.stringify(toolCall.args)
      });
    }
  } else if (isBaseMessageChunk(result)) {
    maybeSendActionExecutionResultIsMessage(eventStream$, actionExecution);
    if ((_a = result.lc_kwargs) == null ? void 0 : _a.content) {
      eventStream$.sendTextMessage(randomId(), result.content);
    }
    if ((_b = result.lc_kwargs) == null ? void 0 : _b.tool_calls) {
      for (const toolCall of (_c = result.lc_kwargs) == null ? void 0 : _c.tool_calls) {
        eventStream$.sendActionExecution({
          actionExecutionId: toolCall.id || randomId(),
          actionName: toolCall.name,
          args: JSON.stringify(toolCall.args)
        });
      }
    }
  } else if (result && "getReader" in result) {
    maybeSendActionExecutionResultIsMessage(eventStream$, actionExecution);
    let reader = result.getReader();
    let mode = null;
    let currentMessageId;
    const toolCallDetails = {
      name: null,
      id: null,
      index: null,
      prevIndex: null
    };
    while (true) {
      try {
        const { done, value } = await reader.read();
        let toolCallName = void 0;
        let toolCallId = void 0;
        let toolCallArgs = void 0;
        let hasToolCall = false;
        let content = "";
        if (value && value.content) {
          content = Array.isArray(value.content) ? ((_d = value.content[0]) == null ? void 0 : _d.text) ?? "" : value.content;
        }
        if (isAIMessageChunk(value)) {
          let chunk = (_e = value.tool_call_chunks) == null ? void 0 : _e[0];
          toolCallArgs = chunk == null ? void 0 : chunk.args;
          hasToolCall = chunk != void 0;
          if (chunk == null ? void 0 : chunk.name)
            toolCallDetails.name = chunk.name;
          if ((chunk == null ? void 0 : chunk.index) != null) {
            toolCallDetails.index = chunk.index;
            if (toolCallDetails.prevIndex == null)
              toolCallDetails.prevIndex = chunk.index;
          }
          if (chunk == null ? void 0 : chunk.id)
            toolCallDetails.id = chunk.index != null ? `${chunk.id}-idx-${chunk.index}` : chunk.id;
          toolCallName = toolCallDetails.name;
          toolCallId = toolCallDetails.id;
        } else if (isBaseMessageChunk(value)) {
          let chunk = (_g = (_f = value.additional_kwargs) == null ? void 0 : _f.tool_calls) == null ? void 0 : _g[0];
          toolCallName = (_h = chunk == null ? void 0 : chunk.function) == null ? void 0 : _h.name;
          toolCallId = chunk == null ? void 0 : chunk.id;
          toolCallArgs = (_i = chunk == null ? void 0 : chunk.function) == null ? void 0 : _i.arguments;
          hasToolCall = (chunk == null ? void 0 : chunk.function) != void 0;
        }
        if (mode === "message" && (toolCallId || done)) {
          mode = null;
          eventStream$.sendTextMessageEnd({
            messageId: currentMessageId
          });
        } else if (mode === "function" && (!hasToolCall || done)) {
          mode = null;
          eventStream$.sendActionExecutionEnd({
            actionExecutionId: toolCallId
          });
        }
        if (done) {
          break;
        }
        if (mode === null) {
          if (hasToolCall && toolCallId && toolCallName) {
            mode = "function";
            eventStream$.sendActionExecutionStart({
              actionExecutionId: toolCallId,
              actionName: toolCallName,
              parentMessageId: (_j = value.lc_kwargs) == null ? void 0 : _j.id
            });
          } else if (content) {
            mode = "message";
            currentMessageId = ((_k = value.lc_kwargs) == null ? void 0 : _k.id) || randomId();
            eventStream$.sendTextMessageStart({
              messageId: currentMessageId
            });
          }
        }
        if (mode === "message" && content) {
          eventStream$.sendTextMessageContent({
            messageId: currentMessageId,
            content
          });
        } else if (mode === "function" && toolCallArgs) {
          if (toolCallDetails.index !== toolCallDetails.prevIndex) {
            eventStream$.sendActionExecutionEnd({
              actionExecutionId: toolCallId
            });
            eventStream$.sendActionExecutionStart({
              actionExecutionId: toolCallId,
              actionName: toolCallName,
              parentMessageId: (_l = value.lc_kwargs) == null ? void 0 : _l.id
            });
            toolCallDetails.prevIndex = toolCallDetails.index;
          }
          eventStream$.sendActionExecutionArgs({
            actionExecutionId: toolCallId,
            args: toolCallArgs
          });
        }
      } catch (error) {
        console.error("Error reading from stream", error);
        break;
      }
    }
  } else if (actionExecution) {
    eventStream$.sendActionExecutionResult({
      actionExecutionId: actionExecution.id,
      actionName: actionExecution.name,
      result: encodeResult(result)
    });
  } else {
    throw new Error("Invalid return type from LangChain function.");
  }
  eventStream$.complete();
}
__name(streamLangChainResponse, "streamLangChainResponse");
function encodeResult(result) {
  if (result === void 0) {
    return "";
  } else if (typeof result === "string") {
    return result;
  } else {
    return JSON.stringify(result);
  }
}
__name(encodeResult, "encodeResult");
var LangChainAdapter = class {
  options;
  /**
  * To use LangChain as a backend, provide a handler function to the adapter with your custom LangChain logic.
  */
  get name() {
    return "LangChainAdapter";
  }
  constructor(options) {
    this.options = options;
  }
  async process(request) {
    try {
      const { eventSource, model, actions, messages, runId, threadId: threadIdFromRequest } = request;
      const threadId = threadIdFromRequest ?? randomUUID();
      const result = await this.options.chainFn({
        messages: messages.map(convertMessageToLangChainMessage),
        tools: actions.map(convertActionInputToLangChainTool),
        model,
        threadId,
        runId
      });
      eventSource.stream(async (eventStream$) => {
        await streamLangChainResponse({
          result,
          eventStream$
        });
      });
      return {
        threadId
      };
    } finally {
      const { awaitAllCallbacks } = __require("@langchain/core/callbacks/promises");
      await awaitAllCallbacks();
    }
  }
};
__name(LangChainAdapter, "LangChainAdapter");

// src/service-adapters/google/google-genai-adapter.ts
var DEFAULT_MODEL2 = "gemini-2.5-flash";
var DEFAULT_API_VERSION = "v1";
var hasWarnedDefaultGoogleModel = false;
var GoogleGenerativeAIAdapter = class extends LangChainAdapter {
  provider = "google";
  model = DEFAULT_MODEL2;
  constructor(options) {
    if (!hasWarnedDefaultGoogleModel && !(options == null ? void 0 : options.model) && !(options == null ? void 0 : options.apiVersion)) {
      console.warn(`You are using the GoogleGenerativeAIAdapter without explicitly setting a model or apiVersion. CopilotKit will default to apiVersion="v1" and model="${DEFAULT_MODEL2}". To silence this warning, pass model and apiVersion when constructing the adapter.`);
      hasWarnedDefaultGoogleModel = true;
    }
    super({
      chainFn: async ({ messages, tools, threadId }) => {
        const { ChatGoogle } = __require("@langchain/google-gauth");
        const { AIMessage: AIMessage2 } = __require("@langchain/core/messages");
        const filteredMessages = messages.filter((message) => {
          if (!(message instanceof AIMessage2)) {
            return true;
          }
          const aiMsg = message;
          return aiMsg.content && String(aiMsg.content).trim().length > 0 || aiMsg.tool_calls && aiMsg.tool_calls.length > 0;
        });
        this.model = (options == null ? void 0 : options.model) ?? DEFAULT_MODEL2;
        const model = new ChatGoogle({
          apiKey: (options == null ? void 0 : options.apiKey) ?? process.env.GOOGLE_API_KEY,
          modelName: this.model,
          apiVersion: (options == null ? void 0 : options.apiVersion) ?? DEFAULT_API_VERSION
        }).bindTools(tools);
        return model.stream(filteredMessages, {
          metadata: {
            conversation_id: threadId
          }
        });
      }
    });
  }
};
__name(GoogleGenerativeAIAdapter, "GoogleGenerativeAIAdapter");

// src/service-adapters/openai/openai-assistant-adapter.ts
var OpenAIAssistantAdapter = class {
  _openai;
  codeInterpreterEnabled;
  assistantId;
  fileSearchEnabled;
  disableParallelToolCalls;
  keepSystemRole = false;
  get name() {
    return "OpenAIAssistantAdapter";
  }
  constructor(params) {
    if (params.openai) {
      this._openai = params.openai;
    }
    this.codeInterpreterEnabled = params.codeInterpreterEnabled === false || true;
    this.fileSearchEnabled = params.fileSearchEnabled === false || true;
    this.assistantId = params.assistantId;
    this.disableParallelToolCalls = (params == null ? void 0 : params.disableParallelToolCalls) || false;
    this.keepSystemRole = (params == null ? void 0 : params.keepSystemRole) ?? false;
  }
  ensureOpenAI() {
    if (!this._openai) {
      const OpenAI = __require("openai").default;
      this._openai = new OpenAI({});
    }
    return this._openai;
  }
  async process(request) {
    var _a, _b;
    const { messages, actions, eventSource, runId, forwardedParameters } = request;
    let threadId = (_b = (_a = request.extensions) == null ? void 0 : _a.openaiAssistantAPI) == null ? void 0 : _b.threadId;
    const openai = this.ensureOpenAI();
    if (!threadId) {
      threadId = (await openai.beta.threads.create()).id;
    }
    const lastMessage = messages.at(-1);
    let nextRunId = void 0;
    if (lastMessage.isResultMessage() && runId) {
      nextRunId = await this.submitToolOutputs(threadId, runId, messages, eventSource);
    } else if (lastMessage.isTextMessage()) {
      nextRunId = await this.submitUserMessage(threadId, messages, actions, eventSource, forwardedParameters);
    } else {
      throw new Error("No actionable message found in the messages");
    }
    return {
      runId: nextRunId,
      threadId,
      extensions: {
        ...request.extensions,
        openaiAssistantAPI: {
          threadId,
          runId: nextRunId
        }
      }
    };
  }
  async submitToolOutputs(threadId, runId, messages, eventSource) {
    const openai = this.ensureOpenAI();
    let run = await openai.beta.threads.runs.retrieve(threadId, runId);
    if (!run.required_action) {
      throw new Error("No tool outputs required");
    }
    const toolCallsIds = run.required_action.submit_tool_outputs.tool_calls.map((toolCall) => toolCall.id);
    const resultMessages = messages.filter((message) => message.isResultMessage() && toolCallsIds.includes(message.actionExecutionId));
    if (toolCallsIds.length != resultMessages.length) {
      throw new Error("Number of function results does not match the number of tool calls");
    }
    const toolOutputs = resultMessages.map((message) => {
      return {
        tool_call_id: message.actionExecutionId,
        output: message.result
      };
    });
    const stream = openai.beta.threads.runs.submitToolOutputsStream(threadId, runId, {
      tool_outputs: toolOutputs,
      ...this.disableParallelToolCalls && {
        parallel_tool_calls: false
      }
    });
    await this.streamResponse(stream, eventSource);
    return runId;
  }
  async submitUserMessage(threadId, messages, actions, eventSource, forwardedParameters) {
    const openai = this.ensureOpenAI();
    messages = [
      ...messages
    ];
    const instructionsMessage = messages.shift();
    const instructions = instructionsMessage.isTextMessage() ? instructionsMessage.content : "";
    const userMessage = messages.map((m) => convertMessageToOpenAIMessage(m, {
      keepSystemRole: this.keepSystemRole
    })).map(convertSystemMessageToAssistantAPI).at(-1);
    if (userMessage.role !== "user") {
      throw new Error("No user message found");
    }
    await openai.beta.threads.messages.create(threadId, {
      role: "user",
      content: userMessage.content
    });
    const openaiTools = actions.map(convertActionInputToOpenAITool);
    const tools = [
      ...openaiTools,
      ...this.codeInterpreterEnabled ? [
        {
          type: "code_interpreter"
        }
      ] : [],
      ...this.fileSearchEnabled ? [
        {
          type: "file_search"
        }
      ] : []
    ];
    let stream = openai.beta.threads.runs.stream(threadId, {
      assistant_id: this.assistantId,
      instructions,
      tools,
      ...(forwardedParameters == null ? void 0 : forwardedParameters.maxTokens) && {
        max_completion_tokens: forwardedParameters.maxTokens
      },
      ...this.disableParallelToolCalls && {
        parallel_tool_calls: false
      }
    });
    await this.streamResponse(stream, eventSource);
    return getRunIdFromStream(stream);
  }
  async streamResponse(stream, eventSource) {
    eventSource.stream(async (eventStream$) => {
      var _a, _b, _c, _d, _e, _f;
      let inFunctionCall = false;
      let currentMessageId;
      let currentToolCallId;
      for await (const chunk of stream) {
        switch (chunk.event) {
          case "thread.message.created":
            if (inFunctionCall) {
              eventStream$.sendActionExecutionEnd({
                actionExecutionId: currentToolCallId
              });
            }
            currentMessageId = chunk.data.id;
            eventStream$.sendTextMessageStart({
              messageId: currentMessageId
            });
            break;
          case "thread.message.delta":
            if (((_a = chunk.data.delta.content) == null ? void 0 : _a[0].type) === "text") {
              eventStream$.sendTextMessageContent({
                messageId: currentMessageId,
                content: (_b = chunk.data.delta.content) == null ? void 0 : _b[0].text.value
              });
            }
            break;
          case "thread.message.completed":
            eventStream$.sendTextMessageEnd({
              messageId: currentMessageId
            });
            break;
          case "thread.run.step.delta":
            let toolCallId;
            let toolCallName;
            let toolCallArgs;
            if (chunk.data.delta.step_details.type === "tool_calls" && ((_c = chunk.data.delta.step_details.tool_calls) == null ? void 0 : _c[0].type) === "function") {
              toolCallId = (_d = chunk.data.delta.step_details.tool_calls) == null ? void 0 : _d[0].id;
              toolCallName = (_e = chunk.data.delta.step_details.tool_calls) == null ? void 0 : _e[0].function.name;
              toolCallArgs = (_f = chunk.data.delta.step_details.tool_calls) == null ? void 0 : _f[0].function.arguments;
            }
            if (toolCallName && toolCallId) {
              if (inFunctionCall) {
                eventStream$.sendActionExecutionEnd({
                  actionExecutionId: currentToolCallId
                });
              }
              inFunctionCall = true;
              currentToolCallId = toolCallId;
              eventStream$.sendActionExecutionStart({
                actionExecutionId: currentToolCallId,
                parentMessageId: chunk.data.id,
                actionName: toolCallName
              });
            } else if (toolCallArgs) {
              eventStream$.sendActionExecutionArgs({
                actionExecutionId: currentToolCallId,
                args: toolCallArgs
              });
            }
            break;
        }
      }
      if (inFunctionCall) {
        eventStream$.sendActionExecutionEnd({
          actionExecutionId: currentToolCallId
        });
      }
      eventStream$.complete();
    });
  }
};
__name(OpenAIAssistantAdapter, "OpenAIAssistantAdapter");
function getRunIdFromStream(stream) {
  return new Promise((resolve, reject) => {
    let runIdGetter = /* @__PURE__ */ __name((event) => {
      if (event.event === "thread.run.created") {
        const runId = event.data.id;
        stream.off("event", runIdGetter);
        resolve(runId);
      }
    }, "runIdGetter");
    stream.on("event", runIdGetter);
  });
}
__name(getRunIdFromStream, "getRunIdFromStream");
var UnifyAdapter = class {
  apiKey;
  model;
  start;
  provider = "unify";
  get name() {
    return "UnifyAdapter";
  }
  constructor(options) {
    if (options == null ? void 0 : options.apiKey) {
      this.apiKey = options.apiKey;
    } else {
      this.apiKey = "UNIFY_API_KEY";
    }
    this.model = options == null ? void 0 : options.model;
    this.start = true;
  }
  async process(request) {
    const tools = request.actions.map(convertActionInputToOpenAITool);
    const OpenAI = __require("openai").default;
    const openai = new OpenAI({
      apiKey: this.apiKey,
      baseURL: "https://api.unify.ai/v0/"
    });
    const forwardedParameters = request.forwardedParameters;
    const messages = request.messages.map((m) => convertMessageToOpenAIMessage(m));
    const stream = await openai.chat.completions.create({
      model: this.model,
      messages,
      stream: true,
      ...tools.length > 0 && {
        tools
      },
      ...(forwardedParameters == null ? void 0 : forwardedParameters.temperature) && {
        temperature: forwardedParameters.temperature
      }
    });
    let model = null;
    let currentMessageId;
    let currentToolCallId;
    request.eventSource.stream(async (eventStream$) => {
      var _a, _b;
      let mode = null;
      for await (const chunk of stream) {
        if (this.start) {
          model = chunk.model;
          currentMessageId = randomId();
          eventStream$.sendTextMessageStart({
            messageId: currentMessageId
          });
          eventStream$.sendTextMessageContent({
            messageId: currentMessageId,
            content: `Model used: ${model}
`
          });
          eventStream$.sendTextMessageEnd({
            messageId: currentMessageId
          });
          this.start = false;
        }
        const toolCall = (_a = chunk.choices[0].delta.tool_calls) == null ? void 0 : _a[0];
        const content = chunk.choices[0].delta.content;
        if (mode === "message" && (toolCall == null ? void 0 : toolCall.id)) {
          mode = null;
          eventStream$.sendTextMessageEnd({
            messageId: currentMessageId
          });
        } else if (mode === "function" && (toolCall === void 0 || (toolCall == null ? void 0 : toolCall.id))) {
          mode = null;
          eventStream$.sendActionExecutionEnd({
            actionExecutionId: currentToolCallId
          });
        }
        if (mode === null) {
          if (toolCall == null ? void 0 : toolCall.id) {
            mode = "function";
            currentToolCallId = toolCall.id;
            eventStream$.sendActionExecutionStart({
              actionExecutionId: currentToolCallId,
              actionName: toolCall.function.name
            });
          } else if (content) {
            mode = "message";
            currentMessageId = chunk.id;
            eventStream$.sendTextMessageStart({
              messageId: currentMessageId
            });
          }
        }
        if (mode === "message" && content) {
          eventStream$.sendTextMessageContent({
            messageId: currentMessageId,
            content
          });
        } else if (mode === "function" && ((_b = toolCall == null ? void 0 : toolCall.function) == null ? void 0 : _b.arguments)) {
          eventStream$.sendActionExecutionArgs({
            actionExecutionId: currentToolCallId,
            args: toolCall.function.arguments
          });
        }
      }
      if (mode === "message") {
        eventStream$.sendTextMessageEnd({
          messageId: currentMessageId
        });
      } else if (mode === "function") {
        eventStream$.sendActionExecutionEnd({
          actionExecutionId: currentToolCallId
        });
      }
      eventStream$.complete();
    });
    return {
      threadId: request.threadId || randomUUID()
    };
  }
};
__name(UnifyAdapter, "UnifyAdapter");
var DEFAULT_MODEL3 = "llama-3.3-70b-versatile";
var GroqAdapter = class {
  model = DEFAULT_MODEL3;
  provider = "groq";
  disableParallelToolCalls = false;
  _groq;
  get groq() {
    return this._groq;
  }
  get name() {
    return "GroqAdapter";
  }
  constructor(params) {
    if (params == null ? void 0 : params.groq) {
      this._groq = params.groq;
    }
    if (params == null ? void 0 : params.model) {
      this.model = params.model;
    }
    this.disableParallelToolCalls = (params == null ? void 0 : params.disableParallelToolCalls) || false;
  }
  ensureGroq() {
    if (!this._groq) {
      const { Groq } = __require("groq-sdk");
      this._groq = new Groq({});
    }
    return this._groq;
  }
  async process(request) {
    const { threadId, model = this.model, messages, actions, eventSource, forwardedParameters } = request;
    const tools = actions.map(convertActionInputToOpenAITool);
    let openaiMessages = messages.map((m) => convertMessageToOpenAIMessage(m, {
      keepSystemRole: true
    }));
    openaiMessages = limitMessagesToTokenCount(openaiMessages, tools, model);
    let toolChoice = forwardedParameters == null ? void 0 : forwardedParameters.toolChoice;
    if ((forwardedParameters == null ? void 0 : forwardedParameters.toolChoice) === "function") {
      toolChoice = {
        type: "function",
        function: {
          name: forwardedParameters.toolChoiceFunctionName
        }
      };
    }
    let stream;
    try {
      const groq = this.ensureGroq();
      stream = await groq.chat.completions.create({
        model,
        stream: true,
        messages: openaiMessages,
        ...tools.length > 0 && {
          tools
        },
        ...(forwardedParameters == null ? void 0 : forwardedParameters.maxTokens) && {
          max_tokens: forwardedParameters.maxTokens
        },
        ...(forwardedParameters == null ? void 0 : forwardedParameters.stop) && {
          stop: forwardedParameters.stop
        },
        ...toolChoice && {
          tool_choice: toolChoice
        },
        ...this.disableParallelToolCalls && {
          parallel_tool_calls: false
        },
        ...(forwardedParameters == null ? void 0 : forwardedParameters.temperature) && {
          temperature: forwardedParameters.temperature
        }
      });
    } catch (error) {
      throw convertServiceAdapterError(error, "Groq");
    }
    eventSource.stream(async (eventStream$) => {
      var _a, _b;
      let mode = null;
      let currentMessageId;
      let currentToolCallId;
      try {
        for await (const chunk of stream) {
          const toolCall = (_a = chunk.choices[0].delta.tool_calls) == null ? void 0 : _a[0];
          const content = chunk.choices[0].delta.content;
          if (mode === "message" && (toolCall == null ? void 0 : toolCall.id)) {
            mode = null;
            eventStream$.sendTextMessageEnd({
              messageId: currentMessageId
            });
          } else if (mode === "function" && (toolCall === void 0 || (toolCall == null ? void 0 : toolCall.id))) {
            mode = null;
            eventStream$.sendActionExecutionEnd({
              actionExecutionId: currentToolCallId
            });
          }
          if (mode === null) {
            if (toolCall == null ? void 0 : toolCall.id) {
              mode = "function";
              currentToolCallId = toolCall.id;
              eventStream$.sendActionExecutionStart({
                actionExecutionId: currentToolCallId,
                actionName: toolCall.function.name,
                parentMessageId: chunk.id
              });
            } else if (content) {
              mode = "message";
              currentMessageId = chunk.id;
              eventStream$.sendTextMessageStart({
                messageId: currentMessageId
              });
            }
          }
          if (mode === "message" && content) {
            eventStream$.sendTextMessageContent({
              messageId: currentMessageId,
              content
            });
          } else if (mode === "function" && ((_b = toolCall == null ? void 0 : toolCall.function) == null ? void 0 : _b.arguments)) {
            eventStream$.sendActionExecutionArgs({
              actionExecutionId: currentToolCallId,
              args: toolCall.function.arguments
            });
          }
        }
        if (mode === "message") {
          eventStream$.sendTextMessageEnd({
            messageId: currentMessageId
          });
        } else if (mode === "function") {
          eventStream$.sendActionExecutionEnd({
            actionExecutionId: currentToolCallId
          });
        }
      } catch (error) {
        throw convertServiceAdapterError(error, "Groq");
      }
      eventStream$.complete();
    });
    return {
      threadId: request.threadId || randomUUID()
    };
  }
};
__name(GroqAdapter, "GroqAdapter");
var MessageRole;
(function(MessageRole2) {
  MessageRole2["assistant"] = "assistant";
  MessageRole2["developer"] = "developer";
  MessageRole2["system"] = "system";
  MessageRole2["tool"] = "tool";
  MessageRole2["user"] = "user";
})(MessageRole || (MessageRole = {}));
var CopilotRequestType;
(function(CopilotRequestType2) {
  CopilotRequestType2["Chat"] = "Chat";
  CopilotRequestType2["Task"] = "Task";
  CopilotRequestType2["TextareaCompletion"] = "TextareaCompletion";
  CopilotRequestType2["TextareaPopover"] = "TextareaPopover";
  CopilotRequestType2["Suggestion"] = "Suggestion";
})(CopilotRequestType || (CopilotRequestType = {}));
var ActionInputAvailability;
(function(ActionInputAvailability2) {
  ActionInputAvailability2["disabled"] = "disabled";
  ActionInputAvailability2["enabled"] = "enabled";
  ActionInputAvailability2["remote"] = "remote";
})(ActionInputAvailability || (ActionInputAvailability = {}));
registerEnumType(MessageRole, {
  name: "MessageRole",
  description: "The role of the message"
});
registerEnumType(CopilotRequestType, {
  name: "CopilotRequestType",
  description: "The type of Copilot request"
});
registerEnumType(ActionInputAvailability, {
  name: "ActionInputAvailability",
  description: "The availability of the frontend action"
});
function _ts_decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate, "_ts_decorate");
function _ts_metadata(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata, "_ts_metadata");
var BaseMessageInput = class {
  id;
  createdAt;
};
__name(BaseMessageInput, "BaseMessageInput");
_ts_decorate([
  Field(() => String),
  _ts_metadata("design:type", String)
], BaseMessageInput.prototype, "id", void 0);
_ts_decorate([
  Field(() => Date),
  _ts_metadata("design:type", typeof Date === "undefined" ? Object : Date)
], BaseMessageInput.prototype, "createdAt", void 0);
BaseMessageInput = _ts_decorate([
  InputType()
], BaseMessageInput);

// src/graphql/inputs/message.input.ts
function _ts_decorate2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate2, "_ts_decorate");
function _ts_metadata2(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata2, "_ts_metadata");
var MessageInput = class extends BaseMessageInput {
  textMessage;
  actionExecutionMessage;
  resultMessage;
  agentStateMessage;
  imageMessage;
};
__name(MessageInput, "MessageInput");
_ts_decorate2([
  Field(() => TextMessageInput, {
    nullable: true
  }),
  _ts_metadata2("design:type", typeof TextMessageInput === "undefined" ? Object : TextMessageInput)
], MessageInput.prototype, "textMessage", void 0);
_ts_decorate2([
  Field(() => ActionExecutionMessageInput, {
    nullable: true
  }),
  _ts_metadata2("design:type", typeof ActionExecutionMessageInput === "undefined" ? Object : ActionExecutionMessageInput)
], MessageInput.prototype, "actionExecutionMessage", void 0);
_ts_decorate2([
  Field(() => ResultMessageInput, {
    nullable: true
  }),
  _ts_metadata2("design:type", typeof ResultMessageInput === "undefined" ? Object : ResultMessageInput)
], MessageInput.prototype, "resultMessage", void 0);
_ts_decorate2([
  Field(() => AgentStateMessageInput, {
    nullable: true
  }),
  _ts_metadata2("design:type", typeof AgentStateMessageInput === "undefined" ? Object : AgentStateMessageInput)
], MessageInput.prototype, "agentStateMessage", void 0);
_ts_decorate2([
  Field(() => ImageMessageInput, {
    nullable: true
  }),
  _ts_metadata2("design:type", typeof ImageMessageInput === "undefined" ? Object : ImageMessageInput)
], MessageInput.prototype, "imageMessage", void 0);
MessageInput = _ts_decorate2([
  InputType()
], MessageInput);
var TextMessageInput = class {
  content;
  parentMessageId;
  role;
};
__name(TextMessageInput, "TextMessageInput");
_ts_decorate2([
  Field(() => String),
  _ts_metadata2("design:type", String)
], TextMessageInput.prototype, "content", void 0);
_ts_decorate2([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata2("design:type", String)
], TextMessageInput.prototype, "parentMessageId", void 0);
_ts_decorate2([
  Field(() => MessageRole),
  _ts_metadata2("design:type", typeof MessageRole === "undefined" ? Object : MessageRole)
], TextMessageInput.prototype, "role", void 0);
TextMessageInput = _ts_decorate2([
  InputType()
], TextMessageInput);
var ActionExecutionMessageInput = class {
  name;
  arguments;
  parentMessageId;
  scope;
};
__name(ActionExecutionMessageInput, "ActionExecutionMessageInput");
_ts_decorate2([
  Field(() => String),
  _ts_metadata2("design:type", String)
], ActionExecutionMessageInput.prototype, "name", void 0);
_ts_decorate2([
  Field(() => String),
  _ts_metadata2("design:type", String)
], ActionExecutionMessageInput.prototype, "arguments", void 0);
_ts_decorate2([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata2("design:type", String)
], ActionExecutionMessageInput.prototype, "parentMessageId", void 0);
_ts_decorate2([
  Field(() => String, {
    nullable: true,
    deprecationReason: "This field will be removed in a future version"
  }),
  _ts_metadata2("design:type", typeof String === "undefined" ? Object : String)
], ActionExecutionMessageInput.prototype, "scope", void 0);
ActionExecutionMessageInput = _ts_decorate2([
  InputType()
], ActionExecutionMessageInput);
var ResultMessageInput = class {
  actionExecutionId;
  actionName;
  parentMessageId;
  result;
};
__name(ResultMessageInput, "ResultMessageInput");
_ts_decorate2([
  Field(() => String),
  _ts_metadata2("design:type", String)
], ResultMessageInput.prototype, "actionExecutionId", void 0);
_ts_decorate2([
  Field(() => String),
  _ts_metadata2("design:type", String)
], ResultMessageInput.prototype, "actionName", void 0);
_ts_decorate2([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata2("design:type", String)
], ResultMessageInput.prototype, "parentMessageId", void 0);
_ts_decorate2([
  Field(() => String),
  _ts_metadata2("design:type", String)
], ResultMessageInput.prototype, "result", void 0);
ResultMessageInput = _ts_decorate2([
  InputType()
], ResultMessageInput);
var AgentStateMessageInput = class {
  threadId;
  agentName;
  role;
  state;
  running;
  nodeName;
  runId;
  active;
};
__name(AgentStateMessageInput, "AgentStateMessageInput");
_ts_decorate2([
  Field(() => String),
  _ts_metadata2("design:type", String)
], AgentStateMessageInput.prototype, "threadId", void 0);
_ts_decorate2([
  Field(() => String),
  _ts_metadata2("design:type", String)
], AgentStateMessageInput.prototype, "agentName", void 0);
_ts_decorate2([
  Field(() => MessageRole),
  _ts_metadata2("design:type", typeof MessageRole === "undefined" ? Object : MessageRole)
], AgentStateMessageInput.prototype, "role", void 0);
_ts_decorate2([
  Field(() => String),
  _ts_metadata2("design:type", String)
], AgentStateMessageInput.prototype, "state", void 0);
_ts_decorate2([
  Field(() => Boolean),
  _ts_metadata2("design:type", Boolean)
], AgentStateMessageInput.prototype, "running", void 0);
_ts_decorate2([
  Field(() => String),
  _ts_metadata2("design:type", String)
], AgentStateMessageInput.prototype, "nodeName", void 0);
_ts_decorate2([
  Field(() => String),
  _ts_metadata2("design:type", String)
], AgentStateMessageInput.prototype, "runId", void 0);
_ts_decorate2([
  Field(() => Boolean),
  _ts_metadata2("design:type", Boolean)
], AgentStateMessageInput.prototype, "active", void 0);
AgentStateMessageInput = _ts_decorate2([
  InputType()
], AgentStateMessageInput);
var ImageMessageInput = class {
  format;
  bytes;
  parentMessageId;
  role;
};
__name(ImageMessageInput, "ImageMessageInput");
_ts_decorate2([
  Field(() => String),
  _ts_metadata2("design:type", String)
], ImageMessageInput.prototype, "format", void 0);
_ts_decorate2([
  Field(() => String),
  _ts_metadata2("design:type", String)
], ImageMessageInput.prototype, "bytes", void 0);
_ts_decorate2([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata2("design:type", String)
], ImageMessageInput.prototype, "parentMessageId", void 0);
_ts_decorate2([
  Field(() => MessageRole),
  _ts_metadata2("design:type", typeof MessageRole === "undefined" ? Object : MessageRole)
], ImageMessageInput.prototype, "role", void 0);
ImageMessageInput = _ts_decorate2([
  InputType()
], ImageMessageInput);
function _ts_decorate3(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate3, "_ts_decorate");
function _ts_metadata3(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata3, "_ts_metadata");
var ActionInput = class {
  name;
  description;
  jsonSchema;
  available;
};
__name(ActionInput, "ActionInput");
_ts_decorate3([
  Field(() => String),
  _ts_metadata3("design:type", String)
], ActionInput.prototype, "name", void 0);
_ts_decorate3([
  Field(() => String),
  _ts_metadata3("design:type", String)
], ActionInput.prototype, "description", void 0);
_ts_decorate3([
  Field(() => String),
  _ts_metadata3("design:type", String)
], ActionInput.prototype, "jsonSchema", void 0);
_ts_decorate3([
  Field(() => ActionInputAvailability, {
    nullable: true
  }),
  _ts_metadata3("design:type", typeof ActionInputAvailability === "undefined" ? Object : ActionInputAvailability)
], ActionInput.prototype, "available", void 0);
ActionInput = _ts_decorate3([
  InputType()
], ActionInput);

// src/graphql/inputs/frontend.input.ts
function _ts_decorate4(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate4, "_ts_decorate");
function _ts_metadata4(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata4, "_ts_metadata");
var FrontendInput = class {
  toDeprecate_fullContext;
  actions;
  url;
};
__name(FrontendInput, "FrontendInput");
_ts_decorate4([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata4("design:type", String)
], FrontendInput.prototype, "toDeprecate_fullContext", void 0);
_ts_decorate4([
  Field(() => [
    ActionInput
  ]),
  _ts_metadata4("design:type", Array)
], FrontendInput.prototype, "actions", void 0);
_ts_decorate4([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata4("design:type", String)
], FrontendInput.prototype, "url", void 0);
FrontendInput = _ts_decorate4([
  InputType()
], FrontendInput);
function _ts_decorate5(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate5, "_ts_decorate");
function _ts_metadata5(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata5, "_ts_metadata");
var GuardrailsRuleInput = class {
  allowList = [];
  denyList = [];
};
__name(GuardrailsRuleInput, "GuardrailsRuleInput");
_ts_decorate5([
  Field(() => [
    String
  ], {
    nullable: true
  }),
  _ts_metadata5("design:type", Array)
], GuardrailsRuleInput.prototype, "allowList", void 0);
_ts_decorate5([
  Field(() => [
    String
  ], {
    nullable: true
  }),
  _ts_metadata5("design:type", Array)
], GuardrailsRuleInput.prototype, "denyList", void 0);
GuardrailsRuleInput = _ts_decorate5([
  InputType()
], GuardrailsRuleInput);
var GuardrailsInput = class {
  inputValidationRules;
};
__name(GuardrailsInput, "GuardrailsInput");
_ts_decorate5([
  Field(() => GuardrailsRuleInput, {
    nullable: false
  }),
  _ts_metadata5("design:type", typeof GuardrailsRuleInput === "undefined" ? Object : GuardrailsRuleInput)
], GuardrailsInput.prototype, "inputValidationRules", void 0);
GuardrailsInput = _ts_decorate5([
  InputType()
], GuardrailsInput);

// src/graphql/inputs/cloud.input.ts
function _ts_decorate6(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate6, "_ts_decorate");
function _ts_metadata6(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata6, "_ts_metadata");
var CloudInput = class {
  guardrails;
};
__name(CloudInput, "CloudInput");
_ts_decorate6([
  Field(() => GuardrailsInput, {
    nullable: true
  }),
  _ts_metadata6("design:type", typeof GuardrailsInput === "undefined" ? Object : GuardrailsInput)
], CloudInput.prototype, "guardrails", void 0);
CloudInput = _ts_decorate6([
  InputType()
], CloudInput);
function _ts_decorate7(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate7, "_ts_decorate");
function _ts_metadata7(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata7, "_ts_metadata");
var ForwardedParametersInput = class {
  model;
  maxTokens;
  stop;
  toolChoice;
  toolChoiceFunctionName;
  temperature;
};
__name(ForwardedParametersInput, "ForwardedParametersInput");
_ts_decorate7([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata7("design:type", String)
], ForwardedParametersInput.prototype, "model", void 0);
_ts_decorate7([
  Field(() => Number, {
    nullable: true
  }),
  _ts_metadata7("design:type", Number)
], ForwardedParametersInput.prototype, "maxTokens", void 0);
_ts_decorate7([
  Field(() => [
    String
  ], {
    nullable: true
  }),
  _ts_metadata7("design:type", Array)
], ForwardedParametersInput.prototype, "stop", void 0);
_ts_decorate7([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata7("design:type", typeof String === "undefined" ? Object : String)
], ForwardedParametersInput.prototype, "toolChoice", void 0);
_ts_decorate7([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata7("design:type", String)
], ForwardedParametersInput.prototype, "toolChoiceFunctionName", void 0);
_ts_decorate7([
  Field(() => Number, {
    nullable: true
  }),
  _ts_metadata7("design:type", Number)
], ForwardedParametersInput.prototype, "temperature", void 0);
ForwardedParametersInput = _ts_decorate7([
  InputType()
], ForwardedParametersInput);
function _ts_decorate8(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate8, "_ts_decorate");
function _ts_metadata8(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata8, "_ts_metadata");
var AgentSessionInput = class {
  agentName;
  threadId;
  nodeName;
};
__name(AgentSessionInput, "AgentSessionInput");
_ts_decorate8([
  Field(() => String),
  _ts_metadata8("design:type", String)
], AgentSessionInput.prototype, "agentName", void 0);
_ts_decorate8([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata8("design:type", String)
], AgentSessionInput.prototype, "threadId", void 0);
_ts_decorate8([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata8("design:type", String)
], AgentSessionInput.prototype, "nodeName", void 0);
AgentSessionInput = _ts_decorate8([
  InputType()
], AgentSessionInput);
function _ts_decorate9(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate9, "_ts_decorate");
function _ts_metadata9(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata9, "_ts_metadata");
var AgentStateInput = class {
  agentName;
  state;
  config;
};
__name(AgentStateInput, "AgentStateInput");
_ts_decorate9([
  Field(() => String),
  _ts_metadata9("design:type", String)
], AgentStateInput.prototype, "agentName", void 0);
_ts_decorate9([
  Field(() => String),
  _ts_metadata9("design:type", String)
], AgentStateInput.prototype, "state", void 0);
_ts_decorate9([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata9("design:type", String)
], AgentStateInput.prototype, "config", void 0);
AgentStateInput = _ts_decorate9([
  InputType()
], AgentStateInput);
function _ts_decorate10(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate10, "_ts_decorate");
function _ts_metadata10(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata10, "_ts_metadata");
var ExtensionsInput = class {
  openaiAssistantAPI;
};
__name(ExtensionsInput, "ExtensionsInput");
_ts_decorate10([
  Field(() => OpenAIApiAssistantAPIInput, {
    nullable: true
  }),
  _ts_metadata10("design:type", typeof OpenAIApiAssistantAPIInput === "undefined" ? Object : OpenAIApiAssistantAPIInput)
], ExtensionsInput.prototype, "openaiAssistantAPI", void 0);
ExtensionsInput = _ts_decorate10([
  InputType()
], ExtensionsInput);
var OpenAIApiAssistantAPIInput = class {
  runId;
  threadId;
};
__name(OpenAIApiAssistantAPIInput, "OpenAIApiAssistantAPIInput");
_ts_decorate10([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata10("design:type", String)
], OpenAIApiAssistantAPIInput.prototype, "runId", void 0);
_ts_decorate10([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata10("design:type", String)
], OpenAIApiAssistantAPIInput.prototype, "threadId", void 0);
OpenAIApiAssistantAPIInput = _ts_decorate10([
  InputType()
], OpenAIApiAssistantAPIInput);
function _ts_decorate11(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate11, "_ts_decorate");
function _ts_metadata11(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata11, "_ts_metadata");
var MessageStatusCode;
(function(MessageStatusCode2) {
  MessageStatusCode2["Pending"] = "pending";
  MessageStatusCode2["Success"] = "success";
  MessageStatusCode2["Failed"] = "failed";
})(MessageStatusCode || (MessageStatusCode = {}));
registerEnumType(MessageStatusCode, {
  name: "MessageStatusCode"
});
var BaseMessageStatus = class {
  code;
};
__name(BaseMessageStatus, "BaseMessageStatus");
_ts_decorate11([
  Field(() => MessageStatusCode),
  _ts_metadata11("design:type", String)
], BaseMessageStatus.prototype, "code", void 0);
BaseMessageStatus = _ts_decorate11([
  ObjectType()
], BaseMessageStatus);
var PendingMessageStatus = class extends BaseMessageStatus {
  code = "pending";
};
__name(PendingMessageStatus, "PendingMessageStatus");
PendingMessageStatus = _ts_decorate11([
  ObjectType()
], PendingMessageStatus);
var SuccessMessageStatus = class extends BaseMessageStatus {
  code = "success";
};
__name(SuccessMessageStatus, "SuccessMessageStatus");
SuccessMessageStatus = _ts_decorate11([
  ObjectType()
], SuccessMessageStatus);
var FailedMessageStatus = class extends BaseMessageStatus {
  code = "failed";
  reason;
};
__name(FailedMessageStatus, "FailedMessageStatus");
_ts_decorate11([
  Field(() => String),
  _ts_metadata11("design:type", String)
], FailedMessageStatus.prototype, "reason", void 0);
FailedMessageStatus = _ts_decorate11([
  ObjectType()
], FailedMessageStatus);
var MessageStatusUnion = createUnionType({
  name: "MessageStatus",
  types: () => [
    PendingMessageStatus,
    SuccessMessageStatus,
    FailedMessageStatus
  ]
});
function _ts_decorate12(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate12, "_ts_decorate");
function _ts_metadata12(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata12, "_ts_metadata");
var ResponseStatusCode;
(function(ResponseStatusCode2) {
  ResponseStatusCode2["Pending"] = "pending";
  ResponseStatusCode2["Success"] = "success";
  ResponseStatusCode2["Failed"] = "failed";
})(ResponseStatusCode || (ResponseStatusCode = {}));
registerEnumType(ResponseStatusCode, {
  name: "ResponseStatusCode"
});
var BaseResponseStatus = /* @__PURE__ */ __name(class BaseResponseStatus2 {
  code;
}, "BaseResponseStatus");
_ts_decorate12([
  Field(() => ResponseStatusCode),
  _ts_metadata12("design:type", String)
], BaseResponseStatus.prototype, "code", void 0);
BaseResponseStatus = _ts_decorate12([
  InterfaceType({
    resolveType(value) {
      if (value.code === "success") {
        return SuccessResponseStatus;
      } else if (value.code === "failed") {
        return FailedResponseStatus;
      } else if (value.code === "pending") {
        return PendingResponseStatus;
      }
      return void 0;
    }
  }),
  ObjectType()
], BaseResponseStatus);
var PendingResponseStatus = class extends BaseResponseStatus {
  code = "pending";
};
__name(PendingResponseStatus, "PendingResponseStatus");
PendingResponseStatus = _ts_decorate12([
  ObjectType({
    implements: BaseResponseStatus
  })
], PendingResponseStatus);
var SuccessResponseStatus = class extends BaseResponseStatus {
  code = "success";
};
__name(SuccessResponseStatus, "SuccessResponseStatus");
SuccessResponseStatus = _ts_decorate12([
  ObjectType({
    implements: BaseResponseStatus
  })
], SuccessResponseStatus);
var FailedResponseStatusReason;
(function(FailedResponseStatusReason2) {
  FailedResponseStatusReason2["GUARDRAILS_VALIDATION_FAILED"] = "GUARDRAILS_VALIDATION_FAILED";
  FailedResponseStatusReason2["MESSAGE_STREAM_INTERRUPTED"] = "MESSAGE_STREAM_INTERRUPTED";
  FailedResponseStatusReason2["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
})(FailedResponseStatusReason || (FailedResponseStatusReason = {}));
registerEnumType(FailedResponseStatusReason, {
  name: "FailedResponseStatusReason"
});
var FailedResponseStatus = class extends BaseResponseStatus {
  code = "failed";
  reason;
  details = null;
};
__name(FailedResponseStatus, "FailedResponseStatus");
_ts_decorate12([
  Field(() => FailedResponseStatusReason),
  _ts_metadata12("design:type", String)
], FailedResponseStatus.prototype, "reason", void 0);
_ts_decorate12([
  Field(() => GraphQLJSON, {
    nullable: true
  }),
  _ts_metadata12("design:type", typeof Record === "undefined" ? Object : Record)
], FailedResponseStatus.prototype, "details", void 0);
FailedResponseStatus = _ts_decorate12([
  ObjectType({
    implements: BaseResponseStatus
  })
], FailedResponseStatus);
var ResponseStatusUnion = createUnionType({
  name: "ResponseStatus",
  types: () => [
    PendingResponseStatus,
    SuccessResponseStatus,
    FailedResponseStatus
  ]
});
function _ts_decorate13(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate13, "_ts_decorate");
function _ts_metadata13(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata13, "_ts_metadata");
var ExtensionsResponse = class {
  openaiAssistantAPI;
};
__name(ExtensionsResponse, "ExtensionsResponse");
_ts_decorate13([
  Field(() => OpenAIApiAssistantAPIResponse, {
    nullable: true
  }),
  _ts_metadata13("design:type", typeof OpenAIApiAssistantAPIResponse === "undefined" ? Object : OpenAIApiAssistantAPIResponse)
], ExtensionsResponse.prototype, "openaiAssistantAPI", void 0);
ExtensionsResponse = _ts_decorate13([
  ObjectType()
], ExtensionsResponse);
var OpenAIApiAssistantAPIResponse = class {
  runId;
  threadId;
};
__name(OpenAIApiAssistantAPIResponse, "OpenAIApiAssistantAPIResponse");
_ts_decorate13([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata13("design:type", String)
], OpenAIApiAssistantAPIResponse.prototype, "runId", void 0);
_ts_decorate13([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata13("design:type", String)
], OpenAIApiAssistantAPIResponse.prototype, "threadId", void 0);
OpenAIApiAssistantAPIResponse = _ts_decorate13([
  ObjectType()
], OpenAIApiAssistantAPIResponse);

// src/graphql/types/copilot-response.type.ts
function _ts_decorate14(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate14, "_ts_decorate");
function _ts_metadata14(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata14, "_ts_metadata");
var BaseMessageOutput = class {
  id;
  createdAt;
  status;
};
__name(BaseMessageOutput, "BaseMessageOutput");
_ts_decorate14([
  Field(() => String),
  _ts_metadata14("design:type", String)
], BaseMessageOutput.prototype, "id", void 0);
_ts_decorate14([
  Field(() => Date),
  _ts_metadata14("design:type", typeof Date === "undefined" ? Object : Date)
], BaseMessageOutput.prototype, "createdAt", void 0);
_ts_decorate14([
  Field(() => MessageStatusUnion),
  _ts_metadata14("design:type", Object)
], BaseMessageOutput.prototype, "status", void 0);
BaseMessageOutput = _ts_decorate14([
  InterfaceType({
    resolveType(value) {
      if (value.hasOwnProperty("content")) {
        return TextMessageOutput;
      } else if (value.hasOwnProperty("name")) {
        return ActionExecutionMessageOutput;
      } else if (value.hasOwnProperty("result")) {
        return ResultMessageOutput;
      } else if (value.hasOwnProperty("state")) {
        return AgentStateMessageOutput;
      } else if (value.hasOwnProperty("format") && value.hasOwnProperty("bytes")) {
        return ImageMessageOutput;
      }
      return void 0;
    }
  })
], BaseMessageOutput);
var TextMessageOutput = class {
  role;
  content;
  parentMessageId;
};
__name(TextMessageOutput, "TextMessageOutput");
_ts_decorate14([
  Field(() => MessageRole),
  _ts_metadata14("design:type", typeof MessageRole === "undefined" ? Object : MessageRole)
], TextMessageOutput.prototype, "role", void 0);
_ts_decorate14([
  Field(() => [
    String
  ]),
  _ts_metadata14("design:type", Array)
], TextMessageOutput.prototype, "content", void 0);
_ts_decorate14([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata14("design:type", String)
], TextMessageOutput.prototype, "parentMessageId", void 0);
TextMessageOutput = _ts_decorate14([
  ObjectType({
    implements: BaseMessageOutput
  })
], TextMessageOutput);
var ActionExecutionMessageOutput = class {
  name;
  scope;
  arguments;
  parentMessageId;
};
__name(ActionExecutionMessageOutput, "ActionExecutionMessageOutput");
_ts_decorate14([
  Field(() => String),
  _ts_metadata14("design:type", String)
], ActionExecutionMessageOutput.prototype, "name", void 0);
_ts_decorate14([
  Field(() => String, {
    nullable: true,
    deprecationReason: "This field will be removed in a future version"
  }),
  _ts_metadata14("design:type", String)
], ActionExecutionMessageOutput.prototype, "scope", void 0);
_ts_decorate14([
  Field(() => [
    String
  ]),
  _ts_metadata14("design:type", Array)
], ActionExecutionMessageOutput.prototype, "arguments", void 0);
_ts_decorate14([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata14("design:type", String)
], ActionExecutionMessageOutput.prototype, "parentMessageId", void 0);
ActionExecutionMessageOutput = _ts_decorate14([
  ObjectType({
    implements: BaseMessageOutput
  })
], ActionExecutionMessageOutput);
var ResultMessageOutput = class {
  actionExecutionId;
  actionName;
  result;
};
__name(ResultMessageOutput, "ResultMessageOutput");
_ts_decorate14([
  Field(() => String),
  _ts_metadata14("design:type", String)
], ResultMessageOutput.prototype, "actionExecutionId", void 0);
_ts_decorate14([
  Field(() => String),
  _ts_metadata14("design:type", String)
], ResultMessageOutput.prototype, "actionName", void 0);
_ts_decorate14([
  Field(() => String),
  _ts_metadata14("design:type", String)
], ResultMessageOutput.prototype, "result", void 0);
ResultMessageOutput = _ts_decorate14([
  ObjectType({
    implements: BaseMessageOutput
  })
], ResultMessageOutput);
var AgentStateMessageOutput = class {
  threadId;
  agentName;
  nodeName;
  runId;
  active;
  role;
  state;
  running;
};
__name(AgentStateMessageOutput, "AgentStateMessageOutput");
_ts_decorate14([
  Field(() => String),
  _ts_metadata14("design:type", String)
], AgentStateMessageOutput.prototype, "threadId", void 0);
_ts_decorate14([
  Field(() => String),
  _ts_metadata14("design:type", String)
], AgentStateMessageOutput.prototype, "agentName", void 0);
_ts_decorate14([
  Field(() => String),
  _ts_metadata14("design:type", String)
], AgentStateMessageOutput.prototype, "nodeName", void 0);
_ts_decorate14([
  Field(() => String),
  _ts_metadata14("design:type", String)
], AgentStateMessageOutput.prototype, "runId", void 0);
_ts_decorate14([
  Field(() => Boolean),
  _ts_metadata14("design:type", Boolean)
], AgentStateMessageOutput.prototype, "active", void 0);
_ts_decorate14([
  Field(() => MessageRole),
  _ts_metadata14("design:type", typeof MessageRole === "undefined" ? Object : MessageRole)
], AgentStateMessageOutput.prototype, "role", void 0);
_ts_decorate14([
  Field(() => String),
  _ts_metadata14("design:type", String)
], AgentStateMessageOutput.prototype, "state", void 0);
_ts_decorate14([
  Field(() => Boolean),
  _ts_metadata14("design:type", Boolean)
], AgentStateMessageOutput.prototype, "running", void 0);
AgentStateMessageOutput = _ts_decorate14([
  ObjectType({
    implements: BaseMessageOutput
  })
], AgentStateMessageOutput);
var ImageMessageOutput = class {
  format;
  bytes;
  role;
  parentMessageId;
};
__name(ImageMessageOutput, "ImageMessageOutput");
_ts_decorate14([
  Field(() => String),
  _ts_metadata14("design:type", String)
], ImageMessageOutput.prototype, "format", void 0);
_ts_decorate14([
  Field(() => String),
  _ts_metadata14("design:type", String)
], ImageMessageOutput.prototype, "bytes", void 0);
_ts_decorate14([
  Field(() => MessageRole),
  _ts_metadata14("design:type", typeof MessageRole === "undefined" ? Object : MessageRole)
], ImageMessageOutput.prototype, "role", void 0);
_ts_decorate14([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata14("design:type", String)
], ImageMessageOutput.prototype, "parentMessageId", void 0);
ImageMessageOutput = _ts_decorate14([
  ObjectType({
    implements: BaseMessageOutput
  })
], ImageMessageOutput);
var CopilotResponse = class {
  threadId;
  status;
  runId;
  messages;
  extensions;
  metaEvents;
};
__name(CopilotResponse, "CopilotResponse");
_ts_decorate14([
  Field(() => String),
  _ts_metadata14("design:type", String)
], CopilotResponse.prototype, "threadId", void 0);
_ts_decorate14([
  Field(() => ResponseStatusUnion),
  _ts_metadata14("design:type", Object)
], CopilotResponse.prototype, "status", void 0);
_ts_decorate14([
  Field({
    nullable: true
  }),
  _ts_metadata14("design:type", String)
], CopilotResponse.prototype, "runId", void 0);
_ts_decorate14([
  Field(() => [
    BaseMessageOutput
  ]),
  _ts_metadata14("design:type", Array)
], CopilotResponse.prototype, "messages", void 0);
_ts_decorate14([
  Field(() => ExtensionsResponse, {
    nullable: true
  }),
  _ts_metadata14("design:type", typeof ExtensionsResponse === "undefined" ? Object : ExtensionsResponse)
], CopilotResponse.prototype, "extensions", void 0);
_ts_decorate14([
  Field(() => [
    BaseMetaEvent
  ], {
    nullable: true
  }),
  _ts_metadata14("design:type", Array)
], CopilotResponse.prototype, "metaEvents", void 0);
CopilotResponse = _ts_decorate14([
  ObjectType()
], CopilotResponse);

// src/graphql/types/meta-events.type.ts
function _ts_decorate15(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate15, "_ts_decorate");
function _ts_metadata15(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata15, "_ts_metadata");
var MetaEventName;
(function(MetaEventName2) {
  MetaEventName2["LangGraphInterruptEvent"] = "LangGraphInterruptEvent";
  MetaEventName2["CopilotKitLangGraphInterruptEvent"] = "CopilotKitLangGraphInterruptEvent";
})(MetaEventName || (MetaEventName = {}));
registerEnumType(MetaEventName, {
  name: "MetaEventName",
  description: "Meta event types"
});
var BaseMetaEvent = class {
  type = "MetaEvent";
  name;
};
__name(BaseMetaEvent, "BaseMetaEvent");
_ts_decorate15([
  Field(() => String),
  _ts_metadata15("design:type", String)
], BaseMetaEvent.prototype, "type", void 0);
_ts_decorate15([
  Field(() => MetaEventName),
  _ts_metadata15("design:type", String)
], BaseMetaEvent.prototype, "name", void 0);
BaseMetaEvent = _ts_decorate15([
  InterfaceType({
    resolveType(value) {
      if (value.name === "LangGraphInterruptEvent") {
        return LangGraphInterruptEvent;
      } else if (value.name === "CopilotKitLangGraphInterruptEvent") {
        return CopilotKitLangGraphInterruptEvent;
      }
      return void 0;
    }
  }),
  InterfaceType()
], BaseMetaEvent);
var CopilotKitLangGraphInterruptEventData = class {
  value;
  messages;
};
__name(CopilotKitLangGraphInterruptEventData, "CopilotKitLangGraphInterruptEventData");
_ts_decorate15([
  Field(() => String),
  _ts_metadata15("design:type", String)
], CopilotKitLangGraphInterruptEventData.prototype, "value", void 0);
_ts_decorate15([
  Field(() => [
    BaseMessageOutput
  ]),
  _ts_metadata15("design:type", Array)
], CopilotKitLangGraphInterruptEventData.prototype, "messages", void 0);
CopilotKitLangGraphInterruptEventData = _ts_decorate15([
  ObjectType()
], CopilotKitLangGraphInterruptEventData);
var LangGraphInterruptEvent = class {
  name = "LangGraphInterruptEvent";
  value;
  response;
};
__name(LangGraphInterruptEvent, "LangGraphInterruptEvent");
_ts_decorate15([
  Field(() => MetaEventName),
  _ts_metadata15("design:type", typeof MetaEventName === "undefined" || false ? Object : "LangGraphInterruptEvent")
], LangGraphInterruptEvent.prototype, "name", void 0);
_ts_decorate15([
  Field(() => String),
  _ts_metadata15("design:type", String)
], LangGraphInterruptEvent.prototype, "value", void 0);
_ts_decorate15([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata15("design:type", String)
], LangGraphInterruptEvent.prototype, "response", void 0);
LangGraphInterruptEvent = _ts_decorate15([
  ObjectType({
    implements: BaseMetaEvent
  })
], LangGraphInterruptEvent);
var CopilotKitLangGraphInterruptEvent = class {
  name = "CopilotKitLangGraphInterruptEvent";
  data;
  response;
};
__name(CopilotKitLangGraphInterruptEvent, "CopilotKitLangGraphInterruptEvent");
_ts_decorate15([
  Field(() => MetaEventName),
  _ts_metadata15("design:type", typeof MetaEventName === "undefined" || false ? Object : "CopilotKitLangGraphInterruptEvent")
], CopilotKitLangGraphInterruptEvent.prototype, "name", void 0);
_ts_decorate15([
  Field(() => CopilotKitLangGraphInterruptEventData),
  _ts_metadata15("design:type", typeof CopilotKitLangGraphInterruptEventData === "undefined" ? Object : CopilotKitLangGraphInterruptEventData)
], CopilotKitLangGraphInterruptEvent.prototype, "data", void 0);
_ts_decorate15([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata15("design:type", String)
], CopilotKitLangGraphInterruptEvent.prototype, "response", void 0);
CopilotKitLangGraphInterruptEvent = _ts_decorate15([
  ObjectType({
    implements: BaseMetaEvent
  })
], CopilotKitLangGraphInterruptEvent);

// src/graphql/inputs/meta-event.input.ts
function _ts_decorate16(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate16, "_ts_decorate");
function _ts_metadata16(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata16, "_ts_metadata");
var MetaEventInput = class {
  name;
  value;
  response;
  messages;
};
__name(MetaEventInput, "MetaEventInput");
_ts_decorate16([
  Field(() => MetaEventName),
  _ts_metadata16("design:type", typeof MetaEventName === "undefined" ? Object : MetaEventName)
], MetaEventInput.prototype, "name", void 0);
_ts_decorate16([
  Field(() => String),
  _ts_metadata16("design:type", String)
], MetaEventInput.prototype, "value", void 0);
_ts_decorate16([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata16("design:type", String)
], MetaEventInput.prototype, "response", void 0);
_ts_decorate16([
  Field(() => [
    MessageInput
  ], {
    nullable: true
  }),
  _ts_metadata16("design:type", Array)
], MetaEventInput.prototype, "messages", void 0);
MetaEventInput = _ts_decorate16([
  InputType()
], MetaEventInput);
function _ts_decorate17(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate17, "_ts_decorate");
function _ts_metadata17(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata17, "_ts_metadata");
var CopilotContextInput = class {
  description;
  value;
};
__name(CopilotContextInput, "CopilotContextInput");
_ts_decorate17([
  Field(() => String),
  _ts_metadata17("design:type", String)
], CopilotContextInput.prototype, "description", void 0);
_ts_decorate17([
  Field(() => String),
  _ts_metadata17("design:type", String)
], CopilotContextInput.prototype, "value", void 0);
CopilotContextInput = _ts_decorate17([
  InputType()
], CopilotContextInput);

// src/graphql/inputs/generate-copilot-response.input.ts
function _ts_decorate18(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate18, "_ts_decorate");
function _ts_metadata18(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata18, "_ts_metadata");
var GenerateCopilotResponseMetadataInput = class {
  requestType;
};
__name(GenerateCopilotResponseMetadataInput, "GenerateCopilotResponseMetadataInput");
_ts_decorate18([
  Field(() => CopilotRequestType, {
    nullable: true
  }),
  _ts_metadata18("design:type", typeof CopilotRequestType === "undefined" ? Object : CopilotRequestType)
], GenerateCopilotResponseMetadataInput.prototype, "requestType", void 0);
GenerateCopilotResponseMetadataInput = _ts_decorate18([
  InputType()
], GenerateCopilotResponseMetadataInput);
var GenerateCopilotResponseInput = class {
  metadata;
  threadId;
  runId;
  messages;
  frontend;
  cloud;
  forwardedParameters;
  agentSession;
  agentState;
  agentStates;
  extensions;
  metaEvents;
  context;
};
__name(GenerateCopilotResponseInput, "GenerateCopilotResponseInput");
_ts_decorate18([
  Field(() => GenerateCopilotResponseMetadataInput, {
    nullable: false
  }),
  _ts_metadata18("design:type", typeof GenerateCopilotResponseMetadataInput === "undefined" ? Object : GenerateCopilotResponseMetadataInput)
], GenerateCopilotResponseInput.prototype, "metadata", void 0);
_ts_decorate18([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata18("design:type", String)
], GenerateCopilotResponseInput.prototype, "threadId", void 0);
_ts_decorate18([
  Field(() => String, {
    nullable: true
  }),
  _ts_metadata18("design:type", String)
], GenerateCopilotResponseInput.prototype, "runId", void 0);
_ts_decorate18([
  Field(() => [
    MessageInput
  ]),
  _ts_metadata18("design:type", Array)
], GenerateCopilotResponseInput.prototype, "messages", void 0);
_ts_decorate18([
  Field(() => FrontendInput),
  _ts_metadata18("design:type", typeof FrontendInput === "undefined" ? Object : FrontendInput)
], GenerateCopilotResponseInput.prototype, "frontend", void 0);
_ts_decorate18([
  Field(() => CloudInput, {
    nullable: true
  }),
  _ts_metadata18("design:type", typeof CloudInput === "undefined" ? Object : CloudInput)
], GenerateCopilotResponseInput.prototype, "cloud", void 0);
_ts_decorate18([
  Field(() => ForwardedParametersInput, {
    nullable: true
  }),
  _ts_metadata18("design:type", typeof ForwardedParametersInput === "undefined" ? Object : ForwardedParametersInput)
], GenerateCopilotResponseInput.prototype, "forwardedParameters", void 0);
_ts_decorate18([
  Field(() => AgentSessionInput, {
    nullable: true
  }),
  _ts_metadata18("design:type", typeof AgentSessionInput === "undefined" ? Object : AgentSessionInput)
], GenerateCopilotResponseInput.prototype, "agentSession", void 0);
_ts_decorate18([
  Field(() => AgentStateInput, {
    nullable: true
  }),
  _ts_metadata18("design:type", typeof AgentStateInput === "undefined" ? Object : AgentStateInput)
], GenerateCopilotResponseInput.prototype, "agentState", void 0);
_ts_decorate18([
  Field(() => [
    AgentStateInput
  ], {
    nullable: true
  }),
  _ts_metadata18("design:type", Array)
], GenerateCopilotResponseInput.prototype, "agentStates", void 0);
_ts_decorate18([
  Field(() => ExtensionsInput, {
    nullable: true
  }),
  _ts_metadata18("design:type", typeof ExtensionsInput === "undefined" ? Object : ExtensionsInput)
], GenerateCopilotResponseInput.prototype, "extensions", void 0);
_ts_decorate18([
  Field(() => [
    MetaEventInput
  ], {
    nullable: true
  }),
  _ts_metadata18("design:type", Array)
], GenerateCopilotResponseInput.prototype, "metaEvents", void 0);
_ts_decorate18([
  Field(() => [
    CopilotContextInput
  ], {
    nullable: true
  }),
  _ts_metadata18("design:type", Array)
], GenerateCopilotResponseInput.prototype, "context", void 0);
GenerateCopilotResponseInput = _ts_decorate18([
  InputType()
], GenerateCopilotResponseInput);
var Message = class {
  type;
  id;
  createdAt;
  status;
  constructor(props) {
    props.id ?? (props.id = randomId());
    props.status ?? (props.status = {
      code: MessageStatusCode.Success
    });
    props.createdAt ?? (props.createdAt = /* @__PURE__ */ new Date());
    Object.assign(this, props);
  }
  isTextMessage() {
    return this.type === "TextMessage";
  }
  isActionExecutionMessage() {
    return this.type === "ActionExecutionMessage";
  }
  isResultMessage() {
    return this.type === "ResultMessage";
  }
  isAgentStateMessage() {
    return this.type === "AgentStateMessage";
  }
  isImageMessage() {
    return this.type === "ImageMessage";
  }
};
__name(Message, "Message");
var Role = MessageRole;
var TextMessage = class extends Message {
  content;
  parentMessageId;
  role;
  type = "TextMessage";
  constructor(props) {
    super(props);
    this.type = "TextMessage";
  }
};
__name(TextMessage, "TextMessage");
var ActionExecutionMessage = class extends Message {
  type = "ActionExecutionMessage";
  name;
  arguments;
  parentMessageId;
};
__name(ActionExecutionMessage, "ActionExecutionMessage");
var ResultMessage = class extends Message {
  type = "ResultMessage";
  actionExecutionId;
  actionName;
  result;
  static encodeResult(result, error) {
    const errorObj = error ? typeof error === "string" ? {
      code: "ERROR",
      message: error
    } : error instanceof Error ? {
      code: "ERROR",
      message: error.message
    } : error : void 0;
    if (errorObj) {
      return JSON.stringify({
        error: errorObj,
        result: result || ""
      });
    }
    if (result === void 0) {
      return "";
    }
    return typeof result === "string" ? result : JSON.stringify(result);
  }
  static decodeResult(result) {
    if (!result) {
      return {
        result: ""
      };
    }
    try {
      const parsed = JSON.parse(result);
      if (parsed && typeof parsed === "object") {
        if ("error" in parsed) {
          return {
            error: parsed.error,
            result: parsed.result || ""
          };
        }
        return {
          result: JSON.stringify(parsed)
        };
      }
      return {
        result
      };
    } catch (e) {
      return {
        result
      };
    }
  }
  hasError() {
    try {
      const { error } = ResultMessage.decodeResult(this.result);
      return !!error;
    } catch {
      return false;
    }
  }
  getError() {
    try {
      const { error } = ResultMessage.decodeResult(this.result);
      return error;
    } catch {
      return void 0;
    }
  }
};
__name(ResultMessage, "ResultMessage");
var AgentStateMessage = class extends Message {
  type = "AgentStateMessage";
  threadId;
  agentName;
  nodeName;
  runId;
  active;
  role;
  state;
  running;
};
__name(AgentStateMessage, "AgentStateMessage");
var ImageMessage = class extends Message {
  type = "ImageMessage";
  format;
  bytes;
  role;
  parentMessageId;
};
__name(ImageMessage, "ImageMessage");

// src/service-adapters/events.ts
var RuntimeEventTypes;
(function(RuntimeEventTypes2) {
  RuntimeEventTypes2["TextMessageStart"] = "TextMessageStart";
  RuntimeEventTypes2["TextMessageContent"] = "TextMessageContent";
  RuntimeEventTypes2["TextMessageEnd"] = "TextMessageEnd";
  RuntimeEventTypes2["ActionExecutionStart"] = "ActionExecutionStart";
  RuntimeEventTypes2["ActionExecutionArgs"] = "ActionExecutionArgs";
  RuntimeEventTypes2["ActionExecutionEnd"] = "ActionExecutionEnd";
  RuntimeEventTypes2["ActionExecutionResult"] = "ActionExecutionResult";
  RuntimeEventTypes2["AgentStateMessage"] = "AgentStateMessage";
  RuntimeEventTypes2["MetaEvent"] = "MetaEvent";
  RuntimeEventTypes2["RunError"] = "RunError";
})(RuntimeEventTypes || (RuntimeEventTypes = {}));
var RuntimeMetaEventName;
(function(RuntimeMetaEventName2) {
  RuntimeMetaEventName2["LangGraphInterruptEvent"] = "LangGraphInterruptEvent";
  RuntimeMetaEventName2["LangGraphInterruptResumeEvent"] = "LangGraphInterruptResumeEvent";
  RuntimeMetaEventName2["CopilotKitLangGraphInterruptEvent"] = "CopilotKitLangGraphInterruptEvent";
})(RuntimeMetaEventName || (RuntimeMetaEventName = {}));

// src/utils/failed-response-status-reasons.ts
var GuardrailsValidationFailureResponse = class extends FailedResponseStatus {
  reason = FailedResponseStatusReason.GUARDRAILS_VALIDATION_FAILED;
  constructor({ guardrailsReason }) {
    super();
    this.details = {
      guardrailsReason
    };
  }
};
__name(GuardrailsValidationFailureResponse, "GuardrailsValidationFailureResponse");
var MessageStreamInterruptedResponse = class extends FailedResponseStatus {
  reason = FailedResponseStatusReason.MESSAGE_STREAM_INTERRUPTED;
  constructor({ messageId }) {
    super();
    this.details = {
      messageId,
      description: "Check the message for mode details"
    };
  }
};
__name(MessageStreamInterruptedResponse, "MessageStreamInterruptedResponse");
var UnknownErrorResponse = class extends FailedResponseStatus {
  reason = FailedResponseStatusReason.UNKNOWN_ERROR;
  constructor({ description, originalError }) {
    super();
    this.details = {
      description,
      originalError
    };
  }
};
__name(UnknownErrorResponse, "UnknownErrorResponse");

// src/graphql/message-conversion/agui-to-gql.ts
function extractAgentName(message) {
  if (message.role !== "assistant") {
    throw new Error(`Cannot extract agent name from message with role ${message.role}`);
  }
  return message.agentName || "unknown";
}
__name(extractAgentName, "extractAgentName");
function isAgentStateMessage(message) {
  return message.role === "assistant" && "agentName" in message && "state" in message;
}
__name(isAgentStateMessage, "isAgentStateMessage");
function hasImageProperty(message) {
  const canContainImage = message.role === "assistant" || message.role === "user";
  if (!canContainImage || message.image === void 0) {
    return false;
  }
  const isMalformed = message.image.format === void 0 || message.image.bytes === void 0;
  if (isMalformed) {
    return false;
  }
  return true;
}
__name(hasImageProperty, "hasImageProperty");
function normalizeMessageContent(content) {
  if (typeof content === "string" || typeof content === "undefined") {
    return content || "";
  }
  if (Array.isArray(content)) {
    return content.map((part) => {
      if ((part == null ? void 0 : part.type) === "text") {
        return part.text;
      }
      if ((part == null ? void 0 : part.type) === "binary") {
        return part.data || part.url || part.filename || `[binary:${part.mimeType}]`;
      }
      return "";
    }).filter(Boolean).join("\n");
  }
  if (content && typeof content === "object") {
    try {
      return JSON.stringify(content);
    } catch (error) {
      console.warn("Failed to serialize message content", error);
    }
  }
  return String(content ?? "");
}
__name(normalizeMessageContent, "normalizeMessageContent");
function aguiToGQL(messages, actions, coAgentStateRenders) {
  const gqlMessages = [];
  messages = Array.isArray(messages) ? messages : [
    messages
  ];
  const toolCallNames = {};
  for (const message of messages) {
    if (isAgentStateMessage(message)) {
      const agentName = extractAgentName(message);
      const state = "state" in message && message.state ? message.state : {};
      gqlMessages.push(new AgentStateMessage({
        id: message.id,
        agentName,
        state,
        role: Role.assistant
      }));
      if ("generativeUI" in message && message.generativeUI && coAgentStateRenders) {
        coAgentStateRenders[agentName] = {
          name: agentName,
          render: message.generativeUI
        };
      }
      continue;
    }
    if (hasImageProperty(message)) {
      gqlMessages.push(aguiMessageWithImageToGQLMessage(message));
      continue;
    }
    if (message.role === "assistant" && message.toolCalls) {
      gqlMessages.push(aguiTextMessageToGQLMessage(message));
      for (const toolCall of message.toolCalls) {
        toolCallNames[toolCall.id] = toolCall.function.name;
        const actionExecMsg = aguiToolCallToGQLActionExecution(toolCall, message.id);
        if ("generativeUI" in message && message.generativeUI && actions) {
          const actionName = toolCall.function.name;
          const specificAction = Object.values(actions).find((action) => action.name === actionName);
          const wildcardAction = Object.values(actions).find((action) => action.name === "*");
          if (specificAction) {
            specificAction.render = message.generativeUI;
          } else if (wildcardAction) {
            wildcardAction.render = message.generativeUI;
          }
        }
        gqlMessages.push(actionExecMsg);
      }
      continue;
    }
    if (message.role === "developer" || message.role === "system" || message.role === "assistant" || message.role === "user") {
      gqlMessages.push(aguiTextMessageToGQLMessage(message));
      continue;
    }
    if (message.role === "tool") {
      gqlMessages.push(aguiToolMessageToGQLResultMessage(message, toolCallNames));
      continue;
    }
    throw new Error(`Unknown message role: "${message.role}" in message with id: ${message.id}`);
  }
  return gqlMessages;
}
__name(aguiToGQL, "aguiToGQL");
function aguiTextMessageToGQLMessage(message) {
  if (message.role !== "developer" && message.role !== "system" && message.role !== "assistant" && message.role !== "user") {
    throw new Error(`Cannot convert message with role ${message.role} to TextMessage`);
  }
  let roleValue;
  if (message.role === "developer") {
    roleValue = Role.developer;
  } else if (message.role === "system") {
    roleValue = Role.system;
  } else if (message.role === "assistant") {
    roleValue = Role.assistant;
  } else {
    roleValue = Role.user;
  }
  return new TextMessage({
    id: message.id,
    content: normalizeMessageContent(message.content),
    role: roleValue
  });
}
__name(aguiTextMessageToGQLMessage, "aguiTextMessageToGQLMessage");
function aguiToolCallToGQLActionExecution(toolCall, parentMessageId) {
  if (toolCall.type !== "function") {
    throw new Error(`Unsupported tool call type: ${toolCall.type}`);
  }
  let argumentsObj;
  if (typeof toolCall.function.arguments === "string") {
    try {
      argumentsObj = JSON.parse(toolCall.function.arguments);
    } catch (error) {
      console.warn(`Failed to parse tool call arguments for ${toolCall.function.name}:`, error);
      argumentsObj = {};
    }
  } else if (typeof toolCall.function.arguments === "object" && toolCall.function.arguments !== null) {
    argumentsObj = toolCall.function.arguments;
  } else {
    console.warn(`Invalid tool call arguments type for ${toolCall.function.name}:`, typeof toolCall.function.arguments);
    argumentsObj = {};
  }
  return new ActionExecutionMessage({
    id: toolCall.id,
    name: toolCall.function.name,
    arguments: argumentsObj,
    parentMessageId
  });
}
__name(aguiToolCallToGQLActionExecution, "aguiToolCallToGQLActionExecution");
function aguiToolMessageToGQLResultMessage(message, toolCallNames) {
  if (message.role !== "tool") {
    throw new Error(`Cannot convert message with role ${message.role} to ResultMessage`);
  }
  if (!message.toolCallId) {
    throw new Error("Tool message must have a toolCallId");
  }
  const actionName = toolCallNames[message.toolCallId] || "unknown";
  let resultContent;
  const messageContent = message.content || "";
  if (typeof messageContent === "string") {
    resultContent = messageContent;
  } else if (typeof messageContent === "object" && messageContent !== null) {
    try {
      resultContent = JSON.stringify(messageContent);
    } catch (error) {
      console.warn(`Failed to stringify tool result for ${actionName}:`, error);
      resultContent = String(messageContent);
    }
  } else {
    resultContent = String(messageContent);
  }
  return new ResultMessage({
    id: message.id,
    result: resultContent,
    actionExecutionId: message.toolCallId,
    actionName: message.toolName || actionName
  });
}
__name(aguiToolMessageToGQLResultMessage, "aguiToolMessageToGQLResultMessage");
function aguiMessageWithImageToGQLMessage(message) {
  if (!hasImageProperty(message)) {
    throw new Error(`Cannot convert message to ImageMessage: missing format or bytes`);
  }
  let roleValue;
  if (message.role === "assistant") {
    roleValue = Role.assistant;
  } else {
    roleValue = Role.user;
  }
  if (message.role !== "assistant" && message.role !== "user") {
    throw new Error(`Cannot convert message with role ${message.role} to ImageMessage`);
  }
  return new ImageMessage({
    id: message.id,
    format: message.image.format,
    bytes: message.image.bytes,
    role: roleValue
  });
}
__name(aguiMessageWithImageToGQLMessage, "aguiMessageWithImageToGQLMessage");
var TelemetryAgentRunner = class {
  _runner;
  hashedLgcKey;
  constructor(config2) {
    this._runner = (config2 == null ? void 0 : config2.runner) ?? new InMemoryAgentRunner();
    this.hashedLgcKey = (config2 == null ? void 0 : config2.langsmithApiKey) ? createHash("sha256").update(config2.langsmithApiKey).digest("hex") : void 0;
  }
  /**
  * Runs an agent with telemetry tracking.
  * Wraps the underlying runner's Observable stream with telemetry events.
  */
  run(...args) {
    const streamInfo = {
      hashedLgcKey: this.hashedLgcKey
    };
    let streamErrored = false;
    telemetry_client_default.capture("oss.runtime.agent_execution_stream_started", {
      hashedLgcKey: this.hashedLgcKey
    });
    return this._runner.run(...args).pipe(
      // Extract metadata from events if available
      tap((event) => {
        var _a;
        const rawEvent = event.rawEvent;
        if (rawEvent == null ? void 0 : rawEvent.data) {
          const data = rawEvent.data;
          if ((_a = data == null ? void 0 : data.output) == null ? void 0 : _a.model) {
            streamInfo.model = data.output.model;
            streamInfo.provider = data.output.model;
          }
        }
        if (rawEvent == null ? void 0 : rawEvent.metadata) {
          const metadata = rawEvent.metadata;
          if (metadata == null ? void 0 : metadata.langgraph_host) {
            streamInfo.langGraphHost = metadata.langgraph_host;
          }
          if (metadata == null ? void 0 : metadata.langgraph_version) {
            streamInfo.langGraphVersion = metadata.langgraph_version;
          }
        }
      }),
      catchError((error) => {
        streamErrored = true;
        telemetry_client_default.capture("oss.runtime.agent_execution_stream_errored", {
          ...streamInfo,
          error: error instanceof Error ? error.message : String(error)
        });
        throw error;
      }),
      finalize(() => {
        if (!streamErrored) {
          telemetry_client_default.capture("oss.runtime.agent_execution_stream_ended", streamInfo);
        }
      })
    );
  }
  /**
  * Delegates to the underlying runner's connect method
  */
  connect(...args) {
    return this._runner.connect(...args);
  }
  /**
  * Delegates to the underlying runner's isRunning method
  */
  isRunning(...args) {
    return this._runner.isRunning(...args);
  }
  /**
  * Delegates to the underlying runner's stop method
  */
  stop(...args) {
    return this._runner.stop(...args);
  }
};
__name(TelemetryAgentRunner, "TelemetryAgentRunner");

// src/lib/runtime/types.ts
var EndpointType;
(function(EndpointType2) {
  EndpointType2["CopilotKit"] = "copilotKit";
  EndpointType2["LangGraphPlatform"] = "langgraph-platform";
})(EndpointType || (EndpointType = {}));

// src/lib/runtime/mcp-tools-utils.ts
function extractParametersFromSchema(toolOrSchema) {
  var _a;
  const parameters = [];
  const schema = "schema" in (toolOrSchema || {}) ? toolOrSchema.schema : toolOrSchema;
  const toolParameters = ((_a = schema == null ? void 0 : schema.parameters) == null ? void 0 : _a.jsonSchema) || (schema == null ? void 0 : schema.parameters);
  const properties = toolParameters == null ? void 0 : toolParameters.properties;
  const requiredParams = new Set((toolParameters == null ? void 0 : toolParameters.required) || []);
  if (!properties) {
    return parameters;
  }
  for (const paramName in properties) {
    if (Object.prototype.hasOwnProperty.call(properties, paramName)) {
      const paramDef = properties[paramName];
      let type = paramDef.type || "string";
      let description = paramDef.description || "";
      if (type === "array" && paramDef.items) {
        const itemType = paramDef.items.type || "object";
        if (itemType === "object" && paramDef.items.properties) {
          const itemProperties = Object.keys(paramDef.items.properties).join(", ");
          description = description + (description ? " " : "") + `Array of objects with properties: ${itemProperties}`;
        } else {
          type = `array<${itemType}>`;
        }
      }
      if (paramDef.enum && Array.isArray(paramDef.enum)) {
        const enumValues = paramDef.enum.join(" | ");
        description = description + (description ? " " : "") + `Allowed values: ${enumValues}`;
      }
      if (type === "object" && paramDef.properties) {
        const objectProperties = Object.keys(paramDef.properties).join(", ");
        description = description + (description ? " " : "") + `Object with properties: ${objectProperties}`;
      }
      parameters.push({
        name: paramName,
        type,
        description,
        required: requiredParams.has(paramName)
      });
    }
  }
  return parameters;
}
__name(extractParametersFromSchema, "extractParametersFromSchema");
function convertMCPToolsToActions(mcpTools, mcpEndpoint) {
  const actions = [];
  for (const [toolName, tool] of Object.entries(mcpTools)) {
    const parameters = extractParametersFromSchema(tool);
    const handler = /* @__PURE__ */ __name(async (params) => {
      try {
        const result = await tool.execute(params);
        return typeof result === "string" ? result : JSON.stringify(result);
      } catch (error) {
        console.error(`Error executing MCP tool '${toolName}' from endpoint ${mcpEndpoint}:`, error);
        throw new Error(`Execution failed for MCP tool '${toolName}': ${error instanceof Error ? error.message : String(error)}`);
      }
    }, "handler");
    actions.push({
      name: toolName,
      description: tool.description || `MCP tool: ${toolName} (from ${mcpEndpoint})`,
      parameters,
      handler,
      // Add metadata for easier identification/debugging
      _isMCPTool: true,
      _mcpEndpoint: mcpEndpoint
    });
  }
  return actions;
}
__name(convertMCPToolsToActions, "convertMCPToolsToActions");
function generateMcpToolInstructions(toolsMap) {
  if (!toolsMap || Object.keys(toolsMap).length === 0) {
    return "";
  }
  const toolEntries = Object.entries(toolsMap);
  const toolsDoc = toolEntries.map(([name, tool]) => {
    var _a;
    let paramsDoc = "    No parameters required";
    try {
      if (tool.schema && typeof tool.schema === "object") {
        const schema = tool.schema;
        const toolParameters = ((_a = schema.parameters) == null ? void 0 : _a.jsonSchema) || schema.parameters;
        const properties = (toolParameters == null ? void 0 : toolParameters.properties) || schema.properties;
        const requiredParams = (toolParameters == null ? void 0 : toolParameters.required) || schema.required || [];
        if (properties) {
          const paramsList = Object.entries(properties).map(([paramName, propSchema]) => {
            const propDetails = propSchema;
            const requiredMark = requiredParams.includes(paramName) ? "*" : "";
            let typeInfo = propDetails.type || "any";
            let description = propDetails.description ? ` - ${propDetails.description}` : "";
            if (typeInfo === "array" && propDetails.items) {
              const itemType = propDetails.items.type || "object";
              if (itemType === "object" && propDetails.items.properties) {
                const itemProps = Object.keys(propDetails.items.properties).join(", ");
                typeInfo = `array<object>`;
                description = description + (description ? " " : " - ") + `Array of objects with properties: ${itemProps}`;
              } else {
                typeInfo = `array<${itemType}>`;
              }
            }
            if (propDetails.enum && Array.isArray(propDetails.enum)) {
              const enumValues = propDetails.enum.join(" | ");
              description = description + (description ? " " : " - ") + `Allowed values: ${enumValues}`;
            }
            if (typeInfo === "object" && propDetails.properties) {
              const objectProps = Object.keys(propDetails.properties).join(", ");
              description = description + (description ? " " : " - ") + `Object with properties: ${objectProps}`;
            }
            return `    - ${paramName}${requiredMark} (${typeInfo})${description}`;
          });
          if (paramsList.length > 0) {
            paramsDoc = paramsList.join("\n");
          }
        }
      }
    } catch (e) {
      console.error(`Error parsing schema for tool ${name}:`, e);
    }
    return `- ${name}: ${tool.description || ""}
${paramsDoc}`;
  }).join("\n\n");
  return `You have access to the following external tools provided by Model Context Protocol (MCP) servers:

${toolsDoc}

When using these tools:
1. Only provide valid parameters according to their type requirements
2. Required parameters are marked with *
3. For array parameters, provide data in the correct array format
4. For object parameters, include all required nested properties
5. For enum parameters, use only the allowed values listed
6. Format API calls correctly with the expected parameter structure
7. Always check tool responses to determine your next action`;
}
__name(generateMcpToolInstructions, "generateMcpToolInstructions");
var CopilotRuntime = class {
  params;
  observability;
  // Cache MCP tools per endpoint to avoid re-fetching repeatedly
  mcpToolsCache = /* @__PURE__ */ new Map();
  runtimeArgs;
  _instance;
  constructor(params) {
    const agents = (params == null ? void 0 : params.agents) ?? {};
    const endpointAgents = this.assignEndpointsToAgents((params == null ? void 0 : params.remoteEndpoints) ?? []);
    const baseRunner = (params == null ? void 0 : params.runner) ?? new InMemoryAgentRunner();
    const runner = isTelemetryDisabled() ? baseRunner : new TelemetryAgentRunner({
      runner: baseRunner
    });
    this.runtimeArgs = {
      agents: {
        ...endpointAgents,
        ...agents
      },
      runner,
      // TODO: add support for transcriptionService from CopilotRuntimeOptionsVNext once it is ready
      // transcriptionService: params?.transcriptionService,
      beforeRequestMiddleware: this.createOnBeforeRequestHandler(params).bind(this),
      afterRequestMiddleware: this.createOnAfterRequestHandler(params).bind(this)
    };
    this.params = params;
    this.observability = params == null ? void 0 : params.observability_c;
  }
  get instance() {
    if (!this._instance) {
      this._instance = new CopilotRuntime$1(this.runtimeArgs);
    }
    return this._instance;
  }
  assignEndpointsToAgents(endpoints) {
    let result = {};
    if (endpoints.some((endpoint) => resolveEndpointType(endpoint) == EndpointType.LangGraphPlatform)) {
      throw new CopilotKitMisuseError({
        message: 'LangGraphPlatformEndpoint in remoteEndpoints is deprecated. Please use the "agents" option instead with LangGraphAgent from "@copilotkit/runtime/langgraph". Example: agents: { myAgent: new LangGraphAgent({ deploymentUrl: "...", graphId: "..." }) }'
      });
    }
    return result;
  }
  handleServiceAdapter(serviceAdapter) {
    this.runtimeArgs.agents = Promise.resolve(this.runtimeArgs.agents ?? {}).then(async (agents) => {
      var _a;
      let agentsList = agents;
      const isAgentsListEmpty = !Object.keys(agents).length;
      const hasServiceAdapter = Boolean(serviceAdapter);
      const illegalServiceAdapterNames = [
        "EmptyAdapter"
      ];
      const serviceAdapterCanBeUsedForAgent = !illegalServiceAdapterNames.includes(serviceAdapter.name);
      if (isAgentsListEmpty && (!hasServiceAdapter || !serviceAdapterCanBeUsedForAgent)) {
        throw new CopilotKitMisuseError({
          message: "No default agent provided. Please provide a default agent in the runtime config."
        });
      }
      if (isAgentsListEmpty) {
        agentsList.default = new BuiltInAgent({
          model: `${serviceAdapter.provider}/${serviceAdapter.model}`
        });
      }
      const actions = (_a = this.params) == null ? void 0 : _a.actions;
      if (actions) {
        const mcpTools = await this.getToolsFromMCP();
        agentsList = this.assignToolsToAgents(agents, [
          ...this.getToolsFromActions(actions),
          ...mcpTools
        ]);
      }
      return agentsList;
    });
  }
  // Receive this.params.action and turn it into the AbstractAgent tools
  getToolsFromActions(actions) {
    const actionsArray = typeof actions === "function" ? actions({
      properties: {},
      url: void 0
    }) : actions;
    return actionsArray.map((action) => {
      const zodSchema = getZodParameters(action.parameters || []);
      return {
        name: action.name,
        description: action.description || "",
        parameters: zodSchema,
        execute: () => Promise.resolve()
      };
    });
  }
  assignToolsToAgents(agents, tools) {
    if (!(tools == null ? void 0 : tools.length)) {
      return agents;
    }
    const enrichedAgents = {
      ...agents
    };
    for (const [agentId, agent] of Object.entries(enrichedAgents)) {
      const existingConfig = Reflect.get(agent, "config") ?? {};
      const existingTools = existingConfig.tools ?? [];
      const updatedConfig = {
        ...existingConfig,
        tools: [
          ...existingTools,
          ...tools
        ]
      };
      Reflect.set(agent, "config", updatedConfig);
      enrichedAgents[agentId] = agent;
    }
    return enrichedAgents;
  }
  createOnBeforeRequestHandler(params) {
    return async (hookParams) => {
      var _a, _b, _c, _d;
      const { request } = hookParams;
      const publicApiKey = request.headers.get("x-copilotcloud-public-api-key");
      const body = await readBody(request);
      const forwardedProps = body == null ? void 0 : body.forwardedProps;
      const cloudBaseUrl = process.env.COPILOT_CLOUD_BASE_URL || "https://api.cloud.copilotkit.ai";
      telemetry_client_default.capture("oss.runtime.copilot_request_created", {
        "cloud.guardrails.enabled": ((_a = forwardedProps == null ? void 0 : forwardedProps.cloud) == null ? void 0 : _a.guardrails) !== void 0,
        requestType: ((_b = forwardedProps == null ? void 0 : forwardedProps.metadata) == null ? void 0 : _b.requestType) ?? "unknown",
        "cloud.api_key_provided": !!publicApiKey,
        ...publicApiKey ? {
          "cloud.public_api_key": publicApiKey
        } : {},
        "cloud.base_url": cloudBaseUrl
      });
      if (request.method === "GET" || !body)
        return;
      const middlewareResult = await ((_c = params == null ? void 0 : params.beforeRequestMiddleware) == null ? void 0 : _c.call(params, hookParams));
      if ((_d = params == null ? void 0 : params.middleware) == null ? void 0 : _d.onBeforeRequest) {
        const { request: request2, runtime, path } = hookParams;
        const gqlMessages = aguiToGQL(body.messages).reduce((acc, msg) => {
          if ("role" in msg && msg.role === "user") {
            acc.inputMessages.push(msg);
          } else {
            acc.outputMessages.push(msg);
          }
          return acc;
        }, {
          inputMessages: [],
          outputMessages: []
        });
        const { inputMessages, outputMessages } = gqlMessages;
        params.middleware.onBeforeRequest({
          threadId: body.threadId,
          runId: body.runId,
          inputMessages,
          properties: body.forwardedProps,
          url: request2.url
        });
      }
      return middlewareResult;
    };
  }
  createOnAfterRequestHandler(params) {
    return async (hookParams) => {
      var _a, _b;
      (_a = params == null ? void 0 : params.afterRequestMiddleware) == null ? void 0 : _a.call(params, hookParams);
      if ((_b = params == null ? void 0 : params.middleware) == null ? void 0 : _b.onAfterRequest) {
        params.middleware.onAfterRequest({});
      }
    };
  }
  // Observability Methods
  /**
  * Log LLM request if observability is enabled
  */
  async logObservabilityBeforeRequest(requestData) {
    try {
      await this.observability.hooks.handleRequest(requestData);
    } catch (error) {
      console.error("Error logging LLM request:", error);
    }
  }
  /**
  * Log final LLM response after request completes
  */
  logObservabilityAfterRequest(outputMessagesPromise, baseData, streamedChunks, requestStartTime, publicApiKey) {
    try {
      outputMessagesPromise.then((outputMessages) => {
        const responseData = {
          threadId: baseData.threadId,
          runId: baseData.runId,
          model: baseData.model,
          // Use collected chunks for progressive mode or outputMessages for regular mode
          output: this.observability.progressive ? streamedChunks : outputMessages,
          latency: Date.now() - requestStartTime,
          timestamp: Date.now(),
          provider: baseData.provider,
          isFinalResponse: true,
          agentName: baseData.agentName,
          nodeName: baseData.nodeName
        };
        try {
          this.observability.hooks.handleResponse(responseData);
        } catch (logError) {
          console.error("Error logging LLM response:", logError);
        }
      }).catch((error) => {
        console.error("Failed to get output messages for logging:", error);
      });
    } catch (error) {
      console.error("Error setting up logging for LLM response:", error);
    }
  }
  // Resolve MCP tools to BuiltInAgent tool definitions
  // Optionally accepts request-scoped properties to merge request-provided mcpServers
  async getToolsFromMCP(options) {
    var _a, _b, _c, _d;
    const runtimeMcpServers = ((_a = this.params) == null ? void 0 : _a.mcpServers) ?? [];
    const createMCPClient = (_b = this.params) == null ? void 0 : _b.createMCPClient;
    const requestMcpServers = ((_c = options == null ? void 0 : options.properties) == null ? void 0 : _c.mcpServers) ?? ((_d = options == null ? void 0 : options.properties) == null ? void 0 : _d.mcpEndpoints) ?? [];
    const hasAnyServers = ((runtimeMcpServers == null ? void 0 : runtimeMcpServers.length) ?? 0) > 0 || ((requestMcpServers == null ? void 0 : requestMcpServers.length) ?? 0) > 0;
    if (!hasAnyServers) {
      return [];
    }
    if (!createMCPClient) {
      throw new CopilotKitMisuseError({
        message: "MCP Integration Error: `mcpServers` were provided, but the `createMCPClient` function was not passed to the CopilotRuntime constructor. Please provide an implementation for `createMCPClient`."
      });
    }
    const effectiveEndpoints = (() => {
      const byUrl = /* @__PURE__ */ new Map();
      for (const ep of runtimeMcpServers) {
        if (ep == null ? void 0 : ep.endpoint)
          byUrl.set(ep.endpoint, ep);
      }
      for (const ep of requestMcpServers) {
        if (ep == null ? void 0 : ep.endpoint)
          byUrl.set(ep.endpoint, ep);
      }
      return Array.from(byUrl.values());
    })();
    const allTools = [];
    for (const config2 of effectiveEndpoints) {
      const endpointUrl = config2.endpoint;
      const cached = this.mcpToolsCache.get(endpointUrl);
      if (cached) {
        allTools.push(...cached);
        continue;
      }
      try {
        const client = await createMCPClient(config2);
        const toolsMap = await client.tools();
        const toolDefs = Object.entries(toolsMap).map(([toolName, tool]) => {
          const params = extractParametersFromSchema(tool);
          const zodSchema = getZodParameters(params);
          return {
            name: toolName,
            description: tool.description || `MCP tool: ${toolName} (from ${endpointUrl})`,
            parameters: zodSchema,
            execute: () => Promise.resolve()
          };
        });
        this.mcpToolsCache.set(endpointUrl, toolDefs);
        allTools.push(...toolDefs);
      } catch (error) {
        console.error(`MCP: Failed to fetch tools from endpoint ${endpointUrl}. Skipping. Error:`, error);
        this.mcpToolsCache.set(endpointUrl, []);
      }
    }
    const dedupedByName = /* @__PURE__ */ new Map();
    for (const tool of allTools) {
      dedupedByName.set(tool.name, tool);
    }
    return Array.from(dedupedByName.values());
  }
};
__name(CopilotRuntime, "CopilotRuntime");
function copilotKitEndpoint(config2) {
  return {
    ...config2,
    type: EndpointType.CopilotKit
  };
}
__name(copilotKitEndpoint, "copilotKitEndpoint");
function langGraphPlatformEndpoint(config2) {
  return {
    ...config2,
    type: EndpointType.LangGraphPlatform
  };
}
__name(langGraphPlatformEndpoint, "langGraphPlatformEndpoint");
function resolveEndpointType(endpoint) {
  if (!endpoint.type) {
    if ("deploymentUrl" in endpoint && "agents" in endpoint) {
      return EndpointType.LangGraphPlatform;
    } else {
      return EndpointType.CopilotKit;
    }
  }
  return endpoint.type;
}
__name(resolveEndpointType, "resolveEndpointType");

// src/lib/telemetry-client.ts
var packageJson = require_package();
var telemetryClient = new TelemetryClient({
  packageName: packageJson.name,
  packageVersion: packageJson.version
});
function getRuntimeInstanceTelemetryInfo(options) {
  var _a, _b, _c, _d, _e;
  const runtime = options.runtime;
  const remoteEndpoints = ((_a = runtime.params) == null ? void 0 : _a.remoteEndpoints) ?? [];
  const endpointsInfo = remoteEndpoints.reduce((acc, endpoint) => {
    let info = {
      ...acc
    };
    const endpointType = resolveEndpointType(endpoint);
    if (!info.endpointTypes.includes(endpointType)) {
      info = {
        ...info,
        endpointTypes: [
          ...info.endpointTypes,
          endpointType
        ]
      };
    }
    if (endpointType === EndpointType.LangGraphPlatform) {
      const ep = endpoint;
      info = {
        ...info,
        agentsAmount: ep.agents.length,
        hashedKey: ep.langsmithApiKey ? createHash("sha256").update(ep.langsmithApiKey).digest("hex") : null
      };
    }
    return info;
  }, {
    endpointTypes: [],
    agentsAmount: null,
    hashedKey: null
  });
  const publicApiKey = (_b = options.cloud) == null ? void 0 : _b.publicApiKey;
  const apiKeyProvided = !!publicApiKey && publicApiKey.trim().length > 0;
  return {
    actionsAmount: ((_d = (_c = runtime.params) == null ? void 0 : _c.actions) == null ? void 0 : _d.length) ?? 0,
    endpointsAmount: remoteEndpoints.length,
    endpointTypes: endpointsInfo.endpointTypes,
    agentsAmount: Object.keys(runtime.instance.agents).length,
    hashedLgcKey: endpointsInfo.hashedKey,
    "cloud.api_key_provided": apiKeyProvided,
    ...apiKeyProvided ? {
      "cloud.public_api_key": publicApiKey
    } : {},
    ...((_e = options.cloud) == null ? void 0 : _e.baseUrl) ? {
      "cloud.base_url": options.cloud.baseUrl
    } : {}
  };
}
__name(getRuntimeInstanceTelemetryInfo, "getRuntimeInstanceTelemetryInfo");
var telemetry_client_default = telemetryClient;
function _ts_decorate19(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate19, "_ts_decorate");
function _ts_metadata19(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata19, "_ts_metadata");
var Agent = class {
  id;
  name;
  description;
};
__name(Agent, "Agent");
_ts_decorate19([
  Field(() => String),
  _ts_metadata19("design:type", String)
], Agent.prototype, "id", void 0);
_ts_decorate19([
  Field(() => String),
  _ts_metadata19("design:type", String)
], Agent.prototype, "name", void 0);
_ts_decorate19([
  Field(() => String),
  _ts_metadata19("design:type", String)
], Agent.prototype, "description", void 0);
Agent = _ts_decorate19([
  ObjectType()
], Agent);
var AgentsResponse = class {
  agents;
};
__name(AgentsResponse, "AgentsResponse");
_ts_decorate19([
  Field(() => [
    Agent
  ]),
  _ts_metadata19("design:type", Array)
], AgentsResponse.prototype, "agents", void 0);
AgentsResponse = _ts_decorate19([
  ObjectType()
], AgentsResponse);

// src/agents/langgraph/events.ts
var LangGraphEventTypes;
(function(LangGraphEventTypes2) {
  LangGraphEventTypes2["OnChainStart"] = "on_chain_start";
  LangGraphEventTypes2["OnChainStream"] = "on_chain_stream";
  LangGraphEventTypes2["OnChainEnd"] = "on_chain_end";
  LangGraphEventTypes2["OnChatModelStart"] = "on_chat_model_start";
  LangGraphEventTypes2["OnChatModelStream"] = "on_chat_model_stream";
  LangGraphEventTypes2["OnChatModelEnd"] = "on_chat_model_end";
  LangGraphEventTypes2["OnToolStart"] = "on_tool_start";
  LangGraphEventTypes2["OnToolEnd"] = "on_tool_end";
  LangGraphEventTypes2["OnCopilotKitStateSync"] = "on_copilotkit_state_sync";
  LangGraphEventTypes2["OnCopilotKitEmitMessage"] = "on_copilotkit_emit_message";
  LangGraphEventTypes2["OnCopilotKitEmitToolCall"] = "on_copilotkit_emit_tool_call";
  LangGraphEventTypes2["OnCustomEvent"] = "on_custom_event";
  LangGraphEventTypes2["OnInterrupt"] = "on_interrupt";
  LangGraphEventTypes2["OnCopilotKitInterrupt"] = "on_copilotkit_interrupt";
  LangGraphEventTypes2["OnCopilotKitError"] = "on_copilotkit_error";
})(LangGraphEventTypes || (LangGraphEventTypes = {}));
var MetaEventNames;
(function(MetaEventNames2) {
  MetaEventNames2["LangGraphInterruptEvent"] = "LangGraphInterruptEvent";
  MetaEventNames2["CopilotKitLangGraphInterruptEvent"] = "CopilotKitLangGraphInterruptEvent";
})(MetaEventNames || (MetaEventNames = {}));
var CustomEventNames;
(function(CustomEventNames2) {
  CustomEventNames2["CopilotKitManuallyEmitMessage"] = "copilotkit_manually_emit_message";
  CustomEventNames2["CopilotKitManuallyEmitToolCall"] = "copilotkit_manually_emit_tool_call";
  CustomEventNames2["CopilotKitManuallyEmitIntermediateState"] = "copilotkit_manually_emit_intermediate_state";
  CustomEventNames2["CopilotKitExit"] = "copilotkit_exit";
})(CustomEventNames || (CustomEventNames = {}));
function _ts_decorate20(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate20, "_ts_decorate");
function _ts_metadata20(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata20, "_ts_metadata");
function _ts_param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
__name(_ts_param, "_ts_param");
var invokeGuardrails = /* @__PURE__ */ __name(async ({ baseUrl, copilotCloudPublicApiKey, data, onResult, onError }) => {
  var _a;
  if (data.messages.length && ((_a = data.messages[data.messages.length - 1].textMessage) == null ? void 0 : _a.role) === MessageRole.user) {
    const messages = data.messages.filter((m) => m.textMessage !== void 0 && (m.textMessage.role === MessageRole.user || m.textMessage.role === MessageRole.assistant)).map((m) => ({
      role: m.textMessage.role,
      content: m.textMessage.content
    }));
    const lastMessage = messages[messages.length - 1];
    const restOfMessages = messages.slice(0, -1);
    const body = {
      input: lastMessage.content,
      validTopics: data.cloud.guardrails.inputValidationRules.allowList,
      invalidTopics: data.cloud.guardrails.inputValidationRules.denyList,
      messages: restOfMessages
    };
    const guardrailsResult = await fetch(`${baseUrl}/guardrails/validate`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "X-CopilotCloud-Public-API-Key": copilotCloudPublicApiKey
      },
      body: JSON.stringify(body)
    });
    if (guardrailsResult.ok) {
      const resultJson = await guardrailsResult.json();
      onResult(resultJson);
    } else {
      onError(await guardrailsResult.json());
    }
  }
}, "invokeGuardrails");
var CopilotResolver = class {
  async hello() {
    return "Hello World";
  }
  async availableAgents(ctx) {
    let logger2 = ctx.logger.child({
      component: "CopilotResolver.availableAgents"
    });
    logger2.debug("Processing");
    const agentsWithEndpoints = [];
    logger2.debug("Event source created, creating response");
    return {
      agents: agentsWithEndpoints.map(({ endpoint, ...agentWithoutEndpoint }) => agentWithoutEndpoint)
    };
  }
  async generateCopilotResponse(ctx, data, properties) {
    var _a, _b, _c, _d;
    telemetry_client_default.capture("oss.runtime.copilot_request_created", {
      "cloud.guardrails.enabled": ((_a = data.cloud) == null ? void 0 : _a.guardrails) !== void 0,
      requestType: data.metadata.requestType,
      "cloud.api_key_provided": !!ctx.request.headers.get("x-copilotcloud-public-api-key"),
      ...ctx.request.headers.get("x-copilotcloud-public-api-key") ? {
        "cloud.public_api_key": ctx.request.headers.get("x-copilotcloud-public-api-key")
      } : {},
      ...ctx._copilotkit.baseUrl ? {
        "cloud.base_url": ctx._copilotkit.baseUrl
      } : {
        "cloud.base_url": "https://api.cloud.copilotkit.ai"
      }
    });
    let logger2 = ctx.logger.child({
      component: "CopilotResolver.generateCopilotResponse"
    });
    logger2.debug({
      data
    }, "Generating Copilot response");
    if (properties) {
      logger2.debug("Properties provided, merging with context properties");
      ctx.properties = {
        ...ctx.properties,
        ...properties
      };
    }
    ctx._copilotkit.runtime;
    ctx._copilotkit.serviceAdapter;
    let copilotCloudPublicApiKey = null;
    let copilotCloudBaseUrl;
    const publicApiKeyFromHeaders = ctx.request.headers.get("x-copilotcloud-public-api-key");
    if (publicApiKeyFromHeaders) {
      copilotCloudPublicApiKey = publicApiKeyFromHeaders;
    }
    if (data.cloud) {
      logger2 = logger2.child({
        cloud: true
      });
      logger2.debug("Cloud configuration provided, checking for public API key in headers");
      if (!copilotCloudPublicApiKey) {
        logger2.error("Public API key not found in headers");
        throw new GraphQLError("X-CopilotCloud-Public-API-Key header is required");
      }
      if (process.env.COPILOT_CLOUD_BASE_URL) {
        copilotCloudBaseUrl = process.env.COPILOT_CLOUD_BASE_URL;
      } else if ((_b = ctx._copilotkit.cloud) == null ? void 0 : _b.baseUrl) {
        copilotCloudBaseUrl = (_c = ctx._copilotkit.cloud) == null ? void 0 : _c.baseUrl;
      } else {
        copilotCloudBaseUrl = "https://api.cloud.copilotkit.ai";
      }
      logger2 = logger2.child({
        copilotCloudBaseUrl
      });
    }
    logger2.debug("Setting up subjects");
    const responseStatus$ = new ReplaySubject();
    const interruptStreaming$ = new ReplaySubject();
    const guardrailsResult$ = new ReplaySubject();
    let outputMessages = [];
    let resolveOutputMessagesPromise;
    let rejectOutputMessagesPromise;
    new Promise((resolve, reject) => {
      resolveOutputMessagesPromise = resolve;
      rejectOutputMessagesPromise = reject;
    });
    if (copilotCloudPublicApiKey) {
      ctx.properties["copilotCloudPublicApiKey"] = copilotCloudPublicApiKey;
    }
    logger2.debug("Processing");
    let runtimeResponse;
    const { eventSource, threadId = randomId(), runId, serverSideActions, actionInputsWithoutAgents, extensions } = runtimeResponse;
    logger2.debug("Event source created, creating response");
    const eventStream = eventSource.processRuntimeEvents({
      serverSideActions,
      guardrailsResult$: ((_d = data.cloud) == null ? void 0 : _d.guardrails) ? guardrailsResult$ : null,
      actionInputsWithoutAgents: actionInputsWithoutAgents.filter(
        // TODO-AGENTS: do not exclude ALL server side actions
        (action) => !serverSideActions.find((serverSideAction) => serverSideAction.name == action.name)
      ),
      threadId
    }).pipe(
      // shareReplay() ensures that later subscribers will see the whole stream instead of
      // just the events that were emitted after the subscriber was added.
      shareReplay(),
      finalize(() => {
        logger2.debug("Event stream finalized");
      })
    );
    const response = {
      threadId,
      runId,
      status: firstValueFrom(responseStatus$),
      extensions,
      metaEvents: new Repeater(async (push, stop) => {
        let eventStreamSubscription;
        eventStreamSubscription = eventStream.subscribe({
          next: async (event) => {
            if (event.type != RuntimeEventTypes.MetaEvent) {
              return;
            }
            switch (event.name) {
              case LangGraphEventTypes.OnInterrupt:
                push(plainToInstance(LangGraphInterruptEvent, {
                  // @ts-ignore
                  type: event.type,
                  // @ts-ignore
                  name: RuntimeMetaEventName.LangGraphInterruptEvent,
                  // @ts-ignore
                  value: event.value
                }));
                break;
              case RuntimeMetaEventName.LangGraphInterruptEvent:
                push(plainToInstance(LangGraphInterruptEvent, {
                  type: event.type,
                  name: event.name,
                  value: event.value
                }));
                break;
              case RuntimeMetaEventName.CopilotKitLangGraphInterruptEvent:
                push(plainToInstance(CopilotKitLangGraphInterruptEvent, {
                  type: event.type,
                  name: event.name,
                  data: {
                    value: event.data.value,
                    messages: event.data.messages.map((message) => {
                      if (message.type === "TextMessage" || "content" in message && "role" in message) {
                        return plainToInstance(TextMessage, {
                          id: message.id,
                          createdAt: /* @__PURE__ */ new Date(),
                          content: [
                            message.content
                          ],
                          role: message.role,
                          status: new SuccessMessageStatus()
                        });
                      }
                      if ("arguments" in message) {
                        return plainToInstance(ActionExecutionMessage, {
                          name: message.name,
                          id: message.id,
                          arguments: [
                            JSON.stringify(message.arguments)
                          ],
                          createdAt: /* @__PURE__ */ new Date(),
                          status: new SuccessMessageStatus()
                        });
                      }
                      throw new Error("Unknown message in metaEvents copilot resolver");
                    })
                  }
                }));
                break;
            }
          },
          error: (err) => {
            var _a2, _b2;
            if (((_a2 = err == null ? void 0 : err.name) == null ? void 0 : _a2.includes("CopilotKit")) || ((_b2 = err == null ? void 0 : err.extensions) == null ? void 0 : _b2.visibility)) {
              responseStatus$.next(new UnknownErrorResponse({
                description: err.message || "Agent error occurred"
              }));
            } else {
              responseStatus$.next(new UnknownErrorResponse({
                description: `An unknown error has occurred in the event stream`
              }));
            }
            eventStreamSubscription == null ? void 0 : eventStreamSubscription.unsubscribe();
            stop();
          },
          complete: async () => {
            logger2.debug("Meta events stream completed");
            responseStatus$.next(new SuccessResponseStatus());
            eventStreamSubscription == null ? void 0 : eventStreamSubscription.unsubscribe();
            stop();
          }
        });
      }),
      messages: new Repeater(async (pushMessage, stopStreamingMessages) => {
        var _a2;
        logger2.debug("Messages repeater created");
        if ((_a2 = data.cloud) == null ? void 0 : _a2.guardrails) {
          logger2 = logger2.child({
            guardrails: true
          });
          logger2.debug("Guardrails is enabled, validating input");
          invokeGuardrails({
            baseUrl: copilotCloudBaseUrl,
            copilotCloudPublicApiKey,
            data,
            onResult: (result) => {
              logger2.debug({
                status: result.status
              }, "Guardrails validation done");
              guardrailsResult$.next(result);
              if (result.status === "denied") {
                responseStatus$.next(new GuardrailsValidationFailureResponse({
                  guardrailsReason: result.reason
                }));
                interruptStreaming$.next({
                  reason: `Interrupted due to Guardrails validation failure. Reason: ${result.reason}`
                });
                outputMessages = [
                  plainToInstance(TextMessage, {
                    id: randomId(),
                    createdAt: /* @__PURE__ */ new Date(),
                    content: result.reason,
                    role: MessageRole.assistant
                  })
                ];
                resolveOutputMessagesPromise(outputMessages);
              }
            },
            onError: (err) => {
              logger2.error({
                err
              }, "Error in guardrails validation");
              responseStatus$.next(new UnknownErrorResponse({
                description: `An unknown error has occurred in the guardrails validation`
              }));
              interruptStreaming$.next({
                reason: `Interrupted due to unknown error in guardrails validation`
              });
              rejectOutputMessagesPromise(err);
            }
          });
        }
        let eventStreamSubscription;
        logger2.debug("Event stream created, subscribing to event stream");
        eventStreamSubscription = eventStream.subscribe({
          next: async (event) => {
            switch (event.type) {
              case RuntimeEventTypes.MetaEvent:
                break;
              case RuntimeEventTypes.TextMessageStart:
                const textMessageContentStream = eventStream.pipe(
                  // skip until this message start event
                  skipWhile((e) => e !== event),
                  // take until the message end event
                  takeWhile((e) => !(e.type === RuntimeEventTypes.TextMessageEnd && e.messageId == event.messageId)),
                  // filter out any other message events or message ids
                  filter((e) => e.type == RuntimeEventTypes.TextMessageContent && e.messageId == event.messageId)
                );
                const streamingTextStatus = new Subject();
                const messageId = event.messageId;
                pushMessage({
                  id: messageId,
                  parentMessageId: event.parentMessageId,
                  status: firstValueFrom(streamingTextStatus),
                  createdAt: /* @__PURE__ */ new Date(),
                  role: MessageRole.assistant,
                  content: new Repeater(async (pushTextChunk, stopStreamingText) => {
                    logger2.debug("Text message content repeater created");
                    const textChunks = [];
                    let textSubscription;
                    interruptStreaming$.pipe(shareReplay(), take(1), tap(({ reason, messageId: messageId2 }) => {
                      logger2.debug({
                        reason,
                        messageId: messageId2
                      }, "Text streaming interrupted");
                      streamingTextStatus.next(plainToInstance(FailedMessageStatus, {
                        reason
                      }));
                      responseStatus$.next(new MessageStreamInterruptedResponse({
                        messageId: messageId2
                      }));
                      stopStreamingText();
                      textSubscription == null ? void 0 : textSubscription.unsubscribe();
                    })).subscribe();
                    logger2.debug("Subscribing to text message content stream");
                    textSubscription = textMessageContentStream.subscribe({
                      next: async (e) => {
                        if (e.type == RuntimeEventTypes.TextMessageContent) {
                          await pushTextChunk(e.content);
                          textChunks.push(e.content);
                        }
                      },
                      error: (err) => {
                        logger2.error({
                          err
                        }, "Error in text message content stream");
                        interruptStreaming$.next({
                          reason: "Error streaming message content",
                          messageId
                        });
                        stopStreamingText();
                        textSubscription == null ? void 0 : textSubscription.unsubscribe();
                      },
                      complete: () => {
                        logger2.debug("Text message content stream completed");
                        streamingTextStatus.next(new SuccessMessageStatus());
                        stopStreamingText();
                        textSubscription == null ? void 0 : textSubscription.unsubscribe();
                        outputMessages.push(plainToInstance(TextMessage, {
                          id: messageId,
                          createdAt: /* @__PURE__ */ new Date(),
                          content: textChunks.join(""),
                          role: MessageRole.assistant
                        }));
                      }
                    });
                  })
                });
                break;
              case RuntimeEventTypes.ActionExecutionStart:
                logger2.debug("Action execution start event received");
                const actionExecutionArgumentStream = eventStream.pipe(
                  skipWhile((e) => e !== event),
                  // take until the action execution end event
                  takeWhile((e) => !(e.type === RuntimeEventTypes.ActionExecutionEnd && e.actionExecutionId == event.actionExecutionId)),
                  // filter out any other action execution events or action execution ids
                  filter((e) => e.type == RuntimeEventTypes.ActionExecutionArgs && e.actionExecutionId == event.actionExecutionId)
                );
                const streamingArgumentsStatus = new Subject();
                pushMessage({
                  id: event.actionExecutionId,
                  parentMessageId: event.parentMessageId,
                  status: firstValueFrom(streamingArgumentsStatus),
                  createdAt: /* @__PURE__ */ new Date(),
                  name: event.actionName,
                  arguments: new Repeater(async (pushArgumentsChunk, stopStreamingArguments) => {
                    logger2.debug("Action execution argument stream created");
                    const argumentChunks = [];
                    let actionExecutionArgumentSubscription;
                    actionExecutionArgumentSubscription = actionExecutionArgumentStream.subscribe({
                      next: async (e) => {
                        if (e.type == RuntimeEventTypes.ActionExecutionArgs) {
                          await pushArgumentsChunk(e.args);
                          argumentChunks.push(e.args);
                        }
                      },
                      error: (err) => {
                        logger2.error({
                          err
                        }, "Error in action execution argument stream");
                        streamingArgumentsStatus.next(plainToInstance(FailedMessageStatus, {
                          reason: "An unknown error has occurred in the action execution argument stream"
                        }));
                        stopStreamingArguments();
                        actionExecutionArgumentSubscription == null ? void 0 : actionExecutionArgumentSubscription.unsubscribe();
                      },
                      complete: () => {
                        logger2.debug("Action execution argument stream completed");
                        streamingArgumentsStatus.next(new SuccessMessageStatus());
                        stopStreamingArguments();
                        actionExecutionArgumentSubscription == null ? void 0 : actionExecutionArgumentSubscription.unsubscribe();
                        outputMessages.push(plainToInstance(ActionExecutionMessage, {
                          id: event.actionExecutionId,
                          createdAt: /* @__PURE__ */ new Date(),
                          name: event.actionName,
                          arguments: argumentChunks.join("")
                        }));
                      }
                    });
                  })
                });
                break;
              case RuntimeEventTypes.ActionExecutionResult:
                logger2.debug({
                  result: event.result
                }, "Action execution result event received");
                pushMessage({
                  id: "result-" + event.actionExecutionId,
                  status: new SuccessMessageStatus(),
                  createdAt: /* @__PURE__ */ new Date(),
                  actionExecutionId: event.actionExecutionId,
                  actionName: event.actionName,
                  result: event.result
                });
                outputMessages.push(plainToInstance(ResultMessage, {
                  id: "result-" + event.actionExecutionId,
                  createdAt: /* @__PURE__ */ new Date(),
                  actionExecutionId: event.actionExecutionId,
                  actionName: event.actionName,
                  result: event.result
                }));
                break;
              case RuntimeEventTypes.AgentStateMessage:
                logger2.debug({
                  event
                }, "Agent message event received");
                pushMessage({
                  id: randomId(),
                  status: new SuccessMessageStatus(),
                  threadId: event.threadId,
                  agentName: event.agentName,
                  nodeName: event.nodeName,
                  runId: event.runId,
                  active: event.active,
                  state: event.state,
                  running: event.running,
                  role: MessageRole.assistant,
                  createdAt: /* @__PURE__ */ new Date()
                });
                outputMessages.push(plainToInstance(AgentStateMessage, {
                  id: randomId(),
                  threadId: event.threadId,
                  agentName: event.agentName,
                  nodeName: event.nodeName,
                  runId: event.runId,
                  active: event.active,
                  state: event.state,
                  running: event.running,
                  role: MessageRole.assistant,
                  createdAt: /* @__PURE__ */ new Date()
                }));
                break;
            }
          },
          error: (err) => {
            var _a3, _b2, _c2, _d2, _e, _f;
            if (err instanceof CopilotKitError || err instanceof CopilotKitLowLevelError || err instanceof Error && err.name && err.name.includes("CopilotKit") || ((_a3 = err == null ? void 0 : err.extensions) == null ? void 0 : _a3.visibility)) {
              responseStatus$.next(new UnknownErrorResponse({
                description: err.message || "Agent error occurred",
                // Include original error information for frontend to extract
                originalError: {
                  code: err.code || ((_b2 = err.extensions) == null ? void 0 : _b2.code),
                  statusCode: err.statusCode || ((_c2 = err.extensions) == null ? void 0 : _c2.statusCode),
                  severity: err.severity || ((_d2 = err.extensions) == null ? void 0 : _d2.severity),
                  visibility: err.visibility || ((_e = err.extensions) == null ? void 0 : _e.visibility),
                  originalErrorType: err.originalErrorType || ((_f = err.extensions) == null ? void 0 : _f.originalErrorType),
                  extensions: err.extensions
                }
              }));
              eventStreamSubscription == null ? void 0 : eventStreamSubscription.unsubscribe();
              rejectOutputMessagesPromise(err);
              stopStreamingMessages();
              return;
            }
            responseStatus$.next(new UnknownErrorResponse({
              description: `An unknown error has occurred in the event stream`
            }));
            eventStreamSubscription == null ? void 0 : eventStreamSubscription.unsubscribe();
            stopStreamingMessages();
            rejectOutputMessagesPromise(err);
          },
          complete: async () => {
            var _a3;
            logger2.debug("Event stream completed");
            if ((_a3 = data.cloud) == null ? void 0 : _a3.guardrails) {
              logger2.debug("Guardrails is enabled, waiting for guardrails result");
              await firstValueFrom(guardrailsResult$);
            }
            responseStatus$.next(new SuccessResponseStatus());
            eventStreamSubscription == null ? void 0 : eventStreamSubscription.unsubscribe();
            stopStreamingMessages();
            resolveOutputMessagesPromise(outputMessages);
          }
        });
      })
    };
    return response;
  }
};
__name(CopilotResolver, "CopilotResolver");
_ts_decorate20([
  Query(() => String),
  _ts_metadata20("design:type", Function),
  _ts_metadata20("design:paramtypes", []),
  _ts_metadata20("design:returntype", Promise)
], CopilotResolver.prototype, "hello", null);
_ts_decorate20([
  Query(() => AgentsResponse),
  _ts_param(0, Ctx()),
  _ts_metadata20("design:type", Function),
  _ts_metadata20("design:paramtypes", [
    typeof GraphQLContext === "undefined" ? Object : GraphQLContext
  ]),
  _ts_metadata20("design:returntype", Promise)
], CopilotResolver.prototype, "availableAgents", null);
_ts_decorate20([
  Mutation(() => CopilotResponse),
  _ts_param(0, Ctx()),
  _ts_param(1, Arg("data")),
  _ts_param(2, Arg("properties", () => GraphQLJSONObject, {
    nullable: true
  })),
  _ts_metadata20("design:type", Function),
  _ts_metadata20("design:paramtypes", [
    typeof GraphQLContext === "undefined" ? Object : GraphQLContext,
    typeof GenerateCopilotResponseInput === "undefined" ? Object : GenerateCopilotResponseInput,
    typeof CopilotRequestContextProperties === "undefined" ? Object : CopilotRequestContextProperties
  ]),
  _ts_metadata20("design:returntype", Promise)
], CopilotResolver.prototype, "generateCopilotResponse", null);
CopilotResolver = _ts_decorate20([
  Resolver(() => CopilotResponse)
], CopilotResolver);
function createLogger(options) {
  const { level, component } = options || {};
  const stream = pretty({
    colorize: true
  });
  const logger2 = createPinoLogger({
    level: process.env.LOG_LEVEL || level || "error",
    redact: {
      paths: [
        "pid",
        "hostname"
      ],
      remove: true
    }
  }, stream);
  if (component) {
    return logger2.child({
      component
    });
  } else {
    return logger2;
  }
}
__name(createLogger, "createLogger");
function _ts_decorate21(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate21, "_ts_decorate");
function _ts_metadata21(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata21, "_ts_metadata");
var LoadAgentStateResponse = class {
  threadId;
  threadExists;
  state;
  messages;
};
__name(LoadAgentStateResponse, "LoadAgentStateResponse");
_ts_decorate21([
  Field(() => String),
  _ts_metadata21("design:type", String)
], LoadAgentStateResponse.prototype, "threadId", void 0);
_ts_decorate21([
  Field(() => Boolean),
  _ts_metadata21("design:type", Boolean)
], LoadAgentStateResponse.prototype, "threadExists", void 0);
_ts_decorate21([
  Field(() => String),
  _ts_metadata21("design:type", String)
], LoadAgentStateResponse.prototype, "state", void 0);
_ts_decorate21([
  Field(() => String),
  _ts_metadata21("design:type", String)
], LoadAgentStateResponse.prototype, "messages", void 0);
LoadAgentStateResponse = _ts_decorate21([
  ObjectType()
], LoadAgentStateResponse);
function _ts_decorate22(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate22, "_ts_decorate");
function _ts_metadata22(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata22, "_ts_metadata");
var LoadAgentStateInput = class {
  threadId;
  agentName;
};
__name(LoadAgentStateInput, "LoadAgentStateInput");
_ts_decorate22([
  Field(() => String),
  _ts_metadata22("design:type", String)
], LoadAgentStateInput.prototype, "threadId", void 0);
_ts_decorate22([
  Field(() => String),
  _ts_metadata22("design:type", String)
], LoadAgentStateInput.prototype, "agentName", void 0);
LoadAgentStateInput = _ts_decorate22([
  InputType()
], LoadAgentStateInput);
function _ts_decorate23(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
__name(_ts_decorate23, "_ts_decorate");
function _ts_metadata23(k, v) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
    return Reflect.metadata(k, v);
}
__name(_ts_metadata23, "_ts_metadata");
function _ts_param2(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
__name(_ts_param2, "_ts_param");
var StateResolver = class {
  async loadAgentState(ctx, data) {
    const agents = [];
    const hasAgent = agents.some((agent) => agent.name === data.agentName);
    if (!hasAgent) {
      throw new CopilotKitAgentDiscoveryError({
        agentName: data.agentName,
        availableAgents: agents.map((a) => ({
          name: a.name,
          id: a.name
        }))
      });
    }
    const state = {};
    return state;
  }
};
__name(StateResolver, "StateResolver");
_ts_decorate23([
  Query(() => LoadAgentStateResponse),
  _ts_param2(0, Ctx()),
  _ts_param2(1, Arg("data")),
  _ts_metadata23("design:type", Function),
  _ts_metadata23("design:paramtypes", [
    typeof GraphQLContext === "undefined" ? Object : GraphQLContext,
    typeof LoadAgentStateInput === "undefined" ? Object : LoadAgentStateInput
  ]),
  _ts_metadata23("design:returntype", Promise)
], StateResolver.prototype, "loadAgentState", null);
StateResolver = _ts_decorate23([
  Resolver(() => LoadAgentStateResponse)
], StateResolver);

// src/lib/integrations/shared.ts
var packageJson2 = __toESM(require_package());
var logger = createLogger();
var addCustomHeaderPlugin = {
  onResponse({ response }) {
    response.headers.set("X-CopilotKit-Runtime-Version", packageJson2.version);
  }
};
async function createContext(initialContext, copilotKitContext, contextLogger, properties = {}) {
  logger.debug({
    copilotKitContext
  }, "Creating GraphQL context");
  const ctx = {
    ...initialContext,
    _copilotkit: {
      ...copilotKitContext
    },
    properties: {
      ...properties
    },
    logger: contextLogger
  };
  return ctx;
}
__name(createContext, "createContext");
function buildSchema(options = {}) {
  logger.debug("Building GraphQL schema...");
  const schema = buildSchemaSync({
    resolvers: [
      CopilotResolver,
      StateResolver
    ],
    emitSchemaFile: options.emitSchemaFile
  });
  logger.debug("GraphQL schema built successfully");
  return schema;
}
__name(buildSchema, "buildSchema");
function getCommonConfig(options) {
  var _a;
  const logLevel = process.env.LOG_LEVEL || options.logLevel || "error";
  createLogger({
    level: logLevel,
    component: "getCommonConfig"
  });
  const contextLogger = createLogger({
    level: logLevel
  });
  if (options.cloud) {
    telemetry_client_default.setCloudConfiguration({
      publicApiKey: options.cloud.publicApiKey,
      baseUrl: options.cloud.baseUrl
    });
  }
  if ((_a = options.properties) == null ? void 0 : _a._copilotkit) {
    telemetry_client_default.setGlobalProperties({
      _copilotkit: {
        ...options.properties._copilotkit
      }
    });
  }
  telemetry_client_default.setGlobalProperties({
    runtime: {
      serviceAdapter: options.serviceAdapter.constructor.name
    }
  });
  const userErrorCodes = [
    CopilotKitErrorCode.AGENT_NOT_FOUND,
    CopilotKitErrorCode.API_NOT_FOUND,
    CopilotKitErrorCode.REMOTE_ENDPOINT_NOT_FOUND,
    CopilotKitErrorCode.CONFIGURATION_ERROR,
    CopilotKitErrorCode.MISSING_PUBLIC_API_KEY_ERROR
  ];
  return {
    logging: createLogger({
      component: "Yoga GraphQL",
      level: logLevel
    }),
    schema: buildSchema(),
    plugins: [
      useDeferStream(),
      addCustomHeaderPlugin
    ],
    context: (ctx) => createContext(ctx, options, contextLogger, options.properties),
    // Suppress logging for user configuration errors
    maskedErrors: {
      maskError: (error, message, isDev) => {
        const originalError = error.originalError || error;
        const extensions = error.extensions;
        const errorCode = extensions == null ? void 0 : extensions.code;
        if (errorCode && userErrorCodes.includes(errorCode)) {
          console.debug("User configuration error:", error.message);
          return error;
        }
        if (originalError instanceof CopilotKitError && userErrorCodes.includes(originalError.code)) {
          console.debug("User configuration error:", error.message);
          return error;
        }
        console.error("Application error:", error);
        return error;
      }
    }
  };
}
__name(getCommonConfig, "getCommonConfig");
function copilotRuntimeNextJSAppRouterEndpoint(options) {
  var _a;
  const commonConfig = getCommonConfig(options);
  telemetry_client_default.setGlobalProperties({
    runtime: {
      framework: "nextjs-app-router"
    }
  });
  if ((_a = options.properties) == null ? void 0 : _a._copilotkit) {
    telemetry_client_default.setGlobalProperties({
      _copilotkit: options.properties._copilotkit
    });
  }
  telemetry_client_default.capture("oss.runtime.instance_created", getRuntimeInstanceTelemetryInfo(options));
  const logger2 = commonConfig.logging;
  logger2.debug("Creating NextJS App Router endpoint");
  const serviceAdapter = options.serviceAdapter;
  if (serviceAdapter) {
    options.runtime.handleServiceAdapter(serviceAdapter);
  }
  const copilotRoute = createCopilotEndpointSingleRoute({
    runtime: options.runtime.instance,
    basePath: options.baseUrl ?? options.endpoint,
    ...options.cors && {
      cors: options.cors
    }
  });
  const handleRequest = handle(copilotRoute);
  return {
    handleRequest
  };
}
__name(copilotRuntimeNextJSAppRouterEndpoint, "copilotRuntimeNextJSAppRouterEndpoint");
function readableStreamToNodeStream(webStream) {
  const reader = webStream.getReader();
  return new Readable({
    async read() {
      try {
        const { done, value } = await reader.read();
        if (done) {
          this.push(null);
        } else {
          this.push(Buffer.from(value));
        }
      } catch (err) {
        this.destroy(err);
      }
    }
  });
}
__name(readableStreamToNodeStream, "readableStreamToNodeStream");
function nodeStreamToReadableStream(nodeStream) {
  return new ReadableStream({
    start(controller) {
      nodeStream.on("data", (chunk) => {
        controller.enqueue(chunk instanceof Buffer ? new Uint8Array(chunk) : chunk);
      });
      nodeStream.on("end", () => {
        controller.close();
      });
      nodeStream.on("error", (err) => {
        controller.error(err);
      });
    },
    cancel() {
      nodeStream.destroy();
    }
  });
}
__name(nodeStreamToReadableStream, "nodeStreamToReadableStream");
function getFullUrl(req) {
  const path = req.url || "/";
  const host = req.headers["x-forwarded-host"] || req.headers.host || "localhost";
  const proto = req.headers["x-forwarded-proto"] || (req.socket.encrypted ? "https" : "http");
  return `${proto}://${host}${path}`;
}
__name(getFullUrl, "getFullUrl");
function toHeaders(rawHeaders) {
  const headers = new Headers();
  for (const [key, value] of Object.entries(rawHeaders)) {
    if (value === void 0)
      continue;
    if (Array.isArray(value)) {
      value.forEach((entry) => headers.append(key, entry));
      continue;
    }
    headers.append(key, value);
  }
  return headers;
}
__name(toHeaders, "toHeaders");
function isStreamConsumed(req) {
  const readableState = req._readableState;
  return Boolean(req.readableEnded || req.complete || (readableState == null ? void 0 : readableState.ended) || (readableState == null ? void 0 : readableState.endEmitted));
}
__name(isStreamConsumed, "isStreamConsumed");
function synthesizeBodyFromParsedBody(parsedBody, headers) {
  if (parsedBody === null || parsedBody === void 0) {
    return {
      body: null
    };
  }
  if (parsedBody instanceof Buffer || parsedBody instanceof Uint8Array) {
    return {
      body: parsedBody
    };
  }
  if (typeof parsedBody === "string") {
    return {
      body: parsedBody,
      contentType: headers.get("content-type") ?? "text/plain"
    };
  }
  return {
    body: JSON.stringify(parsedBody),
    contentType: "application/json"
  };
}
__name(synthesizeBodyFromParsedBody, "synthesizeBodyFromParsedBody");
function isDisturbedOrLockedError(error) {
  return error instanceof TypeError && typeof error.message === "string" && (error.message.includes("disturbed") || error.message.includes("locked"));
}
__name(isDisturbedOrLockedError, "isDisturbedOrLockedError");

// src/lib/integrations/node-http/index.ts
function copilotRuntimeNodeHttpEndpoint(options) {
  var _a;
  const commonConfig = getCommonConfig(options);
  telemetry_client_default.setGlobalProperties({
    runtime: {
      framework: "node-http"
    }
  });
  if ((_a = options.properties) == null ? void 0 : _a._copilotkit) {
    telemetry_client_default.setGlobalProperties({
      _copilotkit: options.properties._copilotkit
    });
  }
  telemetry_client_default.capture("oss.runtime.instance_created", getRuntimeInstanceTelemetryInfo(options));
  const logger2 = commonConfig.logging;
  logger2.debug("Creating Node HTTP endpoint");
  const serviceAdapter = options.serviceAdapter;
  if (serviceAdapter) {
    options.runtime.handleServiceAdapter(serviceAdapter);
  }
  const honoApp = createCopilotEndpointSingleRoute({
    runtime: options.runtime.instance,
    basePath: options.baseUrl ?? options.endpoint,
    ...options.cors && {
      cors: options.cors
    }
  });
  const handle2 = /* @__PURE__ */ __name(async function handler(req, res) {
    const url = getFullUrl(req);
    const hasBody = req.method !== "GET" && req.method !== "HEAD";
    const baseHeaders = toHeaders(req.headers);
    const parsedBody = req.body;
    const streamConsumed = isStreamConsumed(req) || parsedBody !== void 0;
    const canStream = hasBody && !streamConsumed;
    let requestBody = void 0;
    let useDuplex = false;
    if (hasBody && canStream) {
      requestBody = nodeStreamToReadableStream(req);
      useDuplex = true;
    }
    if (hasBody && streamConsumed) {
      if (parsedBody !== void 0) {
        const synthesized = synthesizeBodyFromParsedBody(parsedBody, baseHeaders);
        requestBody = synthesized.body ?? void 0;
        baseHeaders.delete("content-length");
        if (synthesized.contentType) {
          baseHeaders.set("content-type", synthesized.contentType);
        }
        logger2.debug("Request stream already consumed; using parsed req.body to rebuild request.");
      } else {
        logger2.warn("Request stream consumed with no available body; sending empty payload.");
        requestBody = void 0;
      }
    }
    const buildRequest = /* @__PURE__ */ __name((body, headers, duplex) => new Request(url, {
      method: req.method,
      headers,
      body,
      duplex: duplex ? "half" : void 0
    }), "buildRequest");
    let response;
    try {
      response = await honoApp.fetch(buildRequest(requestBody, baseHeaders, useDuplex));
    } catch (error) {
      if (isDisturbedOrLockedError(error) && hasBody) {
        logger2.warn("Encountered disturbed/locked request body; rebuilding request using parsed body or empty payload.");
        const fallbackHeaders = new Headers(baseHeaders);
        let fallbackBody;
        if (parsedBody !== void 0) {
          const synthesized = synthesizeBodyFromParsedBody(parsedBody, fallbackHeaders);
          fallbackBody = synthesized.body ?? void 0;
          fallbackHeaders.delete("content-length");
          if (synthesized.contentType) {
            fallbackHeaders.set("content-type", synthesized.contentType);
          }
        } else {
          fallbackBody = void 0;
        }
        response = await honoApp.fetch(buildRequest(fallbackBody, fallbackHeaders, false));
      } else {
        throw error;
      }
    }
    res.statusCode = response.status;
    response.headers.forEach((value, key) => {
      res.setHeader(key, value);
    });
    if (response.body) {
      readableStreamToNodeStream(response.body).pipe(res);
    } else {
      res.end();
    }
  }, "handler");
  return function(reqOrRequest, res) {
    if (reqOrRequest instanceof Request) {
      return honoApp.fetch(reqOrRequest);
    }
    if (!res) {
      throw new TypeError("ServerResponse is required for Node HTTP requests");
    }
    return handle2(reqOrRequest, res);
  };
}
__name(copilotRuntimeNodeHttpEndpoint, "copilotRuntimeNodeHttpEndpoint");

// src/lib/integrations/nextjs/pages-router.ts
var config = {
  api: {
    bodyParser: false
  }
};
function copilotRuntimeNextJSPagesRouterEndpoint(options) {
  var _a;
  const commonConfig = getCommonConfig(options);
  telemetry_client_default.setGlobalProperties({
    runtime: {
      framework: "nextjs-pages-router"
    }
  });
  if ((_a = options.properties) == null ? void 0 : _a._copilotkit) {
    telemetry_client_default.setGlobalProperties({
      _copilotkit: options.properties._copilotkit
    });
  }
  telemetry_client_default.capture("oss.runtime.instance_created", getRuntimeInstanceTelemetryInfo(options));
  const logger2 = commonConfig.logging;
  logger2.debug("Creating NextJS Pages Router endpoint");
  return copilotRuntimeNodeHttpEndpoint(options);
}
__name(copilotRuntimeNextJSPagesRouterEndpoint, "copilotRuntimeNextJSPagesRouterEndpoint");

// src/lib/integrations/node-express/index.ts
function copilotRuntimeNodeExpressEndpoint(options) {
  telemetry_client_default.setGlobalProperties({
    runtime: {
      framework: "node-express"
    }
  });
  telemetry_client_default.capture("oss.runtime.instance_created", getRuntimeInstanceTelemetryInfo(options));
  return copilotRuntimeNodeHttpEndpoint(options);
}
__name(copilotRuntimeNodeExpressEndpoint, "copilotRuntimeNodeExpressEndpoint");

// src/lib/integrations/nest/index.ts
function copilotRuntimeNestEndpoint(options) {
  telemetry_client_default.setGlobalProperties({
    runtime: {
      framework: "nest"
    }
  });
  telemetry_client_default.capture("oss.runtime.instance_created", getRuntimeInstanceTelemetryInfo(options));
  return copilotRuntimeNodeHttpEndpoint(options);
}
__name(copilotRuntimeNestEndpoint, "copilotRuntimeNestEndpoint");

// src/lib/index.ts
var LangGraphAgent = class {
  constructor() {
    throw new Error("LangGraphAgent import from @copilotkit/runtime is deprecated. Please import it from @copilotkit/runtime/langgraph instead");
  }
};
__name(LangGraphAgent, "LangGraphAgent");
var LangGraphHttpAgent = class {
  constructor() {
    throw new Error("LangGraphHttpAgent import from @copilotkit/runtime is deprecated. Please import it from @copilotkit/runtime/langgraph instead");
  }
};
__name(LangGraphHttpAgent, "LangGraphHttpAgent");

// src/service-adapters/langchain/langserve.ts
var RemoteChain = class {
  name;
  description;
  chainUrl;
  parameters;
  parameterType;
  constructor(options) {
    this.name = options.name;
    this.description = options.description;
    this.chainUrl = options.chainUrl;
    this.parameters = options.parameters;
    this.parameterType = options.parameterType || "multi";
  }
  async toAction() {
    if (!this.parameters) {
      await this.inferLangServeParameters();
    }
    return {
      name: this.name,
      description: this.description,
      parameters: this.parameters,
      handler: async (args) => {
        const { RemoteRunnable } = __require("langchain/runnables/remote");
        const runnable = new RemoteRunnable({
          url: this.chainUrl
        });
        let input;
        if (this.parameterType === "single") {
          input = args[Object.keys(args)[0]];
        } else {
          input = args;
        }
        return await runnable.invoke(input);
      }
    };
  }
  async inferLangServeParameters() {
    const supportedTypes = [
      "string",
      "number",
      "boolean"
    ];
    let schemaUrl = this.chainUrl.replace(/\/+$/, "") + "/input_schema";
    let schema = await fetch(schemaUrl).then((res) => res.json()).catch(() => {
      throw new Error("Failed to fetch langserve schema at " + schemaUrl);
    });
    if (supportedTypes.includes(schema.type)) {
      this.parameterType = "single";
      this.parameters = [
        {
          name: "input",
          type: schema.type,
          description: "The input to the chain"
        }
      ];
    } else if (schema.type === "object") {
      this.parameterType = "multi";
      this.parameters = Object.keys(schema.properties).map((key) => {
        var _a;
        let property = schema.properties[key];
        if (!supportedTypes.includes(property.type)) {
          throw new Error("Unsupported schema type");
        }
        return {
          name: key,
          type: property.type,
          description: property.description || "",
          required: ((_a = schema.required) == null ? void 0 : _a.includes(key)) || false
        };
      });
    } else {
      throw new Error("Unsupported schema type");
    }
  }
};
__name(RemoteChain, "RemoteChain");

// src/service-adapters/anthropic/utils.ts
function limitMessagesToTokenCount2(messages, tools, model, maxTokens) {
  maxTokens || (maxTokens = MAX_TOKENS);
  const result = [];
  const toolsNumTokens = countToolsTokens2(model, tools);
  if (toolsNumTokens > maxTokens) {
    throw new Error(`Too many tokens in function definitions: ${toolsNumTokens} > ${maxTokens}`);
  }
  maxTokens -= toolsNumTokens;
  for (const message of messages) {
    if (message.role === "system") {
      const numTokens = countMessageTokens2(model, message);
      maxTokens -= numTokens;
      if (maxTokens < 0) {
        throw new Error("Not enough tokens for system message.");
      }
    }
  }
  let cutoff = false;
  const reversedMessages = [
    ...messages
  ].reverse();
  for (const message of reversedMessages) {
    if (message.role === "system") {
      result.unshift(message);
      continue;
    } else if (cutoff) {
      continue;
    }
    let numTokens = countMessageTokens2(model, message);
    if (maxTokens < numTokens) {
      cutoff = true;
      continue;
    }
    result.unshift(message);
    maxTokens -= numTokens;
  }
  return result;
}
__name(limitMessagesToTokenCount2, "limitMessagesToTokenCount");
var MAX_TOKENS = 128e3;
function countToolsTokens2(model, tools) {
  if (tools.length === 0) {
    return 0;
  }
  const json = JSON.stringify(tools);
  return countTokens2(model, json);
}
__name(countToolsTokens2, "countToolsTokens");
function countMessageTokens2(model, message) {
  return countTokens2(model, JSON.stringify(message.content) || "");
}
__name(countMessageTokens2, "countMessageTokens");
function countTokens2(model, text) {
  return text.length / 3;
}
__name(countTokens2, "countTokens");
function convertActionInputToAnthropicTool(action) {
  return {
    name: action.name,
    description: action.description,
    input_schema: JSON.parse(action.jsonSchema)
  };
}
__name(convertActionInputToAnthropicTool, "convertActionInputToAnthropicTool");
function convertMessageToAnthropicMessage(message) {
  if (message.isTextMessage()) {
    if (message.role === "system") {
      return {
        role: "assistant",
        content: [
          {
            type: "text",
            text: "THE FOLLOWING MESSAGE IS A SYSTEM MESSAGE: " + message.content
          }
        ]
      };
    } else {
      return {
        role: message.role === "user" ? "user" : "assistant",
        content: [
          {
            type: "text",
            text: message.content
          }
        ]
      };
    }
  } else if (message.isImageMessage()) {
    let mediaType;
    switch (message.format) {
      case "jpeg":
        mediaType = "image/jpeg";
        break;
      case "png":
        mediaType = "image/png";
        break;
      case "webp":
        mediaType = "image/webp";
        break;
      case "gif":
        mediaType = "image/gif";
        break;
      default:
        throw new Error(`Unsupported image format: ${message.format}`);
    }
    return {
      role: "user",
      content: [
        {
          type: "image",
          source: {
            type: "base64",
            media_type: mediaType,
            data: message.bytes
          }
        }
      ]
    };
  } else if (message.isActionExecutionMessage()) {
    return {
      role: "assistant",
      content: [
        {
          id: message.id,
          type: "tool_use",
          input: message.arguments,
          name: message.name
        }
      ]
    };
  } else if (message.isResultMessage()) {
    return {
      role: "user",
      content: [
        {
          type: "tool_result",
          content: message.result || "Action completed successfully",
          tool_use_id: message.actionExecutionId
        }
      ]
    };
  }
}
__name(convertMessageToAnthropicMessage, "convertMessageToAnthropicMessage");
var DEFAULT_MODEL4 = "claude-3-5-sonnet-latest";
var AnthropicAdapter = class {
  model = DEFAULT_MODEL4;
  provider = "anthropic";
  promptCaching;
  _anthropic;
  get anthropic() {
    return this._anthropic;
  }
  get name() {
    return "AnthropicAdapter";
  }
  constructor(params) {
    if (params == null ? void 0 : params.anthropic) {
      this._anthropic = params.anthropic;
    }
    if (params == null ? void 0 : params.model) {
      this.model = params.model;
    }
    this.promptCaching = (params == null ? void 0 : params.promptCaching) || {
      enabled: false
    };
  }
  ensureAnthropic() {
    if (!this._anthropic) {
      const Anthropic = __require("@anthropic-ai/sdk").default;
      this._anthropic = new Anthropic({});
    }
    return this._anthropic;
  }
  /**
  * Adds cache control to system prompt
  */
  addSystemPromptCaching(system, debug = false) {
    if (!this.promptCaching.enabled || !system) {
      return system;
    }
    const originalTextLength = system.length;
    if (debug) {
      console.log(`[ANTHROPIC CACHE DEBUG] Added cache control to system prompt (${originalTextLength} chars).`);
    }
    return [
      {
        type: "text",
        text: system,
        cache_control: {
          type: "ephemeral"
        }
      }
    ];
  }
  /**
  * Adds cache control to the final message
  */
  addIncrementalMessageCaching(messages, debug = false) {
    if (!this.promptCaching.enabled || messages.length === 0) {
      return messages;
    }
    const finalMessage = messages[messages.length - 1];
    const messageNumber = messages.length;
    if (Array.isArray(finalMessage.content) && finalMessage.content.length > 0) {
      const finalBlock = finalMessage.content[finalMessage.content.length - 1];
      const updatedMessages = [
        ...messages.slice(0, -1),
        {
          ...finalMessage,
          content: [
            ...finalMessage.content.slice(0, -1),
            {
              ...finalBlock,
              cache_control: {
                type: "ephemeral"
              }
            }
          ]
        }
      ];
      if (debug) {
        console.log(`[ANTHROPIC CACHE DEBUG] Added cache control to final message (message ${messageNumber}).`);
      }
      return updatedMessages;
    }
    return messages;
  }
  shouldGenerateFallbackResponse(messages) {
    var _a, _b, _c;
    if (messages.length === 0)
      return false;
    const lastMessage = messages[messages.length - 1];
    const endsWithToolResult = lastMessage.role === "user" && Array.isArray(lastMessage.content) && lastMessage.content.some((content) => content.type === "tool_result");
    if (messages.length >= 3 && endsWithToolResult) {
      const lastThree = messages.slice(-3);
      const hasRecentToolPattern = ((_a = lastThree[0]) == null ? void 0 : _a.role) === "user" && // Initial user message
      ((_b = lastThree[1]) == null ? void 0 : _b.role) === "assistant" && // Assistant tool use
      Array.isArray(lastThree[1].content) && lastThree[1].content.some((content) => content.type === "tool_use") && ((_c = lastThree[2]) == null ? void 0 : _c.role) === "user" && // Tool result
      Array.isArray(lastThree[2].content) && lastThree[2].content.some((content) => content.type === "tool_result");
      return hasRecentToolPattern;
    }
    return endsWithToolResult;
  }
  async process(request) {
    const { threadId, model = this.model, messages: rawMessages, actions, eventSource, forwardedParameters } = request;
    const tools = actions.map(convertActionInputToAnthropicTool);
    const messages = [
      ...rawMessages
    ];
    const instructionsMessage = messages.shift();
    const instructions = instructionsMessage.isTextMessage() ? instructionsMessage.content : "";
    const validToolUseIds = /* @__PURE__ */ new Set();
    for (const message of messages) {
      if (message.isActionExecutionMessage()) {
        validToolUseIds.add(message.id);
      }
    }
    const processedToolResultIds = /* @__PURE__ */ new Set();
    const anthropicMessages = messages.map((message) => {
      if (message.isResultMessage()) {
        if (!validToolUseIds.has(message.actionExecutionId)) {
          return null;
        }
        if (processedToolResultIds.has(message.actionExecutionId)) {
          return null;
        }
        processedToolResultIds.add(message.actionExecutionId);
        return {
          role: "user",
          content: [
            {
              type: "tool_result",
              content: message.result || "Action completed successfully",
              tool_use_id: message.actionExecutionId
            }
          ]
        };
      }
      return convertMessageToAnthropicMessage(message);
    }).filter(Boolean).filter((msg) => {
      if (msg.role === "assistant" && Array.isArray(msg.content)) {
        const hasEmptyTextOnly = msg.content.length === 1 && msg.content[0].type === "text" && (!msg.content[0].text || msg.content[0].text.trim() === "");
        return !hasEmptyTextOnly;
      }
      return true;
    });
    const limitedMessages = limitMessagesToTokenCount2(anthropicMessages, tools, model);
    const cachedSystemPrompt = this.addSystemPromptCaching(instructions, this.promptCaching.debug);
    const cachedMessages = this.addIncrementalMessageCaching(limitedMessages, this.promptCaching.debug);
    let toolChoice = forwardedParameters == null ? void 0 : forwardedParameters.toolChoice;
    if ((forwardedParameters == null ? void 0 : forwardedParameters.toolChoice) === "function") {
      toolChoice = {
        type: "tool",
        name: forwardedParameters.toolChoiceFunctionName
      };
    }
    try {
      const createParams = {
        system: cachedSystemPrompt,
        model: this.model,
        messages: cachedMessages,
        max_tokens: (forwardedParameters == null ? void 0 : forwardedParameters.maxTokens) || 1024,
        ...(forwardedParameters == null ? void 0 : forwardedParameters.temperature) ? {
          temperature: forwardedParameters.temperature
        } : {},
        ...tools.length > 0 && {
          tools
        },
        ...toolChoice && {
          tool_choice: toolChoice
        },
        stream: true
      };
      const anthropic = this.ensureAnthropic();
      const stream = await anthropic.messages.create(createParams);
      eventSource.stream(async (eventStream$) => {
        let mode = null;
        let didOutputText = false;
        let currentMessageId = randomId();
        let currentToolCallId = randomId();
        let filterThinkingTextBuffer = new FilterThinkingTextBuffer();
        let hasReceivedContent = false;
        try {
          for await (const chunk of stream) {
            if (chunk.type === "message_start") {
              currentMessageId = chunk.message.id;
            } else if (chunk.type === "content_block_start") {
              hasReceivedContent = true;
              if (chunk.content_block.type === "text") {
                didOutputText = false;
                filterThinkingTextBuffer.reset();
                mode = "message";
              } else if (chunk.content_block.type === "tool_use") {
                currentToolCallId = chunk.content_block.id;
                eventStream$.sendActionExecutionStart({
                  actionExecutionId: currentToolCallId,
                  actionName: chunk.content_block.name,
                  parentMessageId: currentMessageId
                });
                mode = "function";
              }
            } else if (chunk.type === "content_block_delta") {
              if (chunk.delta.type === "text_delta") {
                const text = filterThinkingTextBuffer.onTextChunk(chunk.delta.text);
                if (text.length > 0) {
                  if (!didOutputText) {
                    eventStream$.sendTextMessageStart({
                      messageId: currentMessageId
                    });
                    didOutputText = true;
                  }
                  eventStream$.sendTextMessageContent({
                    messageId: currentMessageId,
                    content: text
                  });
                }
              } else if (chunk.delta.type === "input_json_delta") {
                eventStream$.sendActionExecutionArgs({
                  actionExecutionId: currentToolCallId,
                  args: chunk.delta.partial_json
                });
              }
            } else if (chunk.type === "content_block_stop") {
              if (mode === "message") {
                if (didOutputText) {
                  eventStream$.sendTextMessageEnd({
                    messageId: currentMessageId
                  });
                }
              } else if (mode === "function") {
                eventStream$.sendActionExecutionEnd({
                  actionExecutionId: currentToolCallId
                });
              }
            }
          }
        } catch (error) {
          throw convertServiceAdapterError(error, "Anthropic");
        }
        if (!hasReceivedContent && this.shouldGenerateFallbackResponse(cachedMessages)) {
          let fallbackContent = "Task completed successfully.";
          const lastMessage = cachedMessages[cachedMessages.length - 1];
          if ((lastMessage == null ? void 0 : lastMessage.role) === "user" && Array.isArray(lastMessage.content)) {
            const toolResult = lastMessage.content.find((c) => c.type === "tool_result");
            if ((toolResult == null ? void 0 : toolResult.content) && toolResult.content !== "Action completed successfully") {
              fallbackContent = toolResult.content;
            }
          }
          currentMessageId = randomId();
          eventStream$.sendTextMessageStart({
            messageId: currentMessageId
          });
          eventStream$.sendTextMessageContent({
            messageId: currentMessageId,
            content: fallbackContent
          });
          eventStream$.sendTextMessageEnd({
            messageId: currentMessageId
          });
        }
        eventStream$.complete();
      });
    } catch (error) {
      throw convertServiceAdapterError(error, "Anthropic");
    }
    return {
      threadId: threadId || randomUUID()
    };
  }
};
__name(AnthropicAdapter, "AnthropicAdapter");
var THINKING_TAG = "<thinking>";
var THINKING_TAG_END = "</thinking>";
var FilterThinkingTextBuffer = /* @__PURE__ */ __name(class FilterThinkingTextBuffer2 {
  buffer;
  didFilterThinkingTag = false;
  constructor() {
    this.buffer = "";
  }
  onTextChunk(text) {
    this.buffer += text;
    if (this.didFilterThinkingTag) {
      return text;
    }
    const potentialTag = this.buffer.slice(0, THINKING_TAG.length);
    if (THINKING_TAG.startsWith(potentialTag)) {
      if (this.buffer.includes(THINKING_TAG_END)) {
        const end = this.buffer.indexOf(THINKING_TAG_END);
        const filteredText = this.buffer.slice(end + THINKING_TAG_END.length);
        this.buffer = filteredText;
        this.didFilterThinkingTag = true;
        return filteredText;
      } else {
        return "";
      }
    }
    return text;
  }
  reset() {
    this.buffer = "";
    this.didFilterThinkingTag = false;
  }
}, "FilterThinkingTextBuffer");
var DEFAULT_MODEL5 = "llama3:latest";
var ExperimentalOllamaAdapter = class {
  model;
  provider = "ollama";
  get name() {
    return "OllamaAdapter";
  }
  constructor(options) {
    if (options == null ? void 0 : options.model) {
      this.model = options.model;
    } else {
      this.model = DEFAULT_MODEL5;
    }
  }
  async process(request) {
    const { messages, actions, eventSource } = request;
    const { Ollama } = __require("@langchain/community/llms/ollama");
    const ollama = new Ollama({
      model: this.model
    });
    const contents = messages.filter((m) => m.isTextMessage()).map((m) => m.content);
    const _stream = await ollama.stream(contents);
    eventSource.stream(async (eventStream$) => {
      const currentMessageId = randomId();
      eventStream$.sendTextMessageStart({
        messageId: currentMessageId
      });
      for await (const chunkText of _stream) {
        eventStream$.sendTextMessageContent({
          messageId: currentMessageId,
          content: chunkText
        });
      }
      eventStream$.sendTextMessageEnd({
        messageId: currentMessageId
      });
      eventStream$.complete();
    });
    return {
      threadId: request.threadId || randomUUID()
    };
  }
};
__name(ExperimentalOllamaAdapter, "ExperimentalOllamaAdapter");

// src/service-adapters/bedrock/bedrock-adapter.ts
var DEFAULT_MODEL6 = "amazon.nova-lite-v1:0";
var BedrockAdapter = class extends LangChainAdapter {
  provider = "bedrock";
  model = DEFAULT_MODEL6;
  constructor(options) {
    super({
      chainFn: async ({ messages, tools, threadId }) => {
        const { ChatBedrockConverse } = __require("@langchain/aws");
        this.model = (options == null ? void 0 : options.model) ?? "amazon.nova-lite-v1:0";
        const model = new ChatBedrockConverse({
          model: this.model,
          region: (options == null ? void 0 : options.region) ?? "us-east-1",
          credentials: (options == null ? void 0 : options.credentials) ? {
            accessKeyId: options.credentials.accessKeyId,
            secretAccessKey: options.credentials.secretAccessKey
          } : void 0
        }).bindTools(tools);
        return model.stream(messages);
      }
    });
  }
};
__name(BedrockAdapter, "BedrockAdapter");
var EmptyAdapter = class {
  async process(request) {
    return {
      threadId: request.threadId || randomUUID()
    };
  }
  get name() {
    return "EmptyAdapter";
  }
};
__name(EmptyAdapter, "EmptyAdapter");
var ExperimentalEmptyAdapter = EmptyAdapter;

export { AnthropicAdapter, BedrockAdapter, CopilotRuntime, EmptyAdapter, ExperimentalEmptyAdapter, ExperimentalOllamaAdapter, GoogleGenerativeAIAdapter, GroqAdapter, GuardrailsValidationFailureResponse, LangChainAdapter, LangGraphAgent, LangGraphHttpAgent, MessageStreamInterruptedResponse, OpenAIAdapter, OpenAIAssistantAdapter, RemoteChain, TelemetryAgentRunner, UnifyAdapter, UnknownErrorResponse, addCustomHeaderPlugin, buildSchema, config, convertMCPToolsToActions, convertServiceAdapterError, copilotKitEndpoint, copilotRuntimeNestEndpoint, copilotRuntimeNextJSAppRouterEndpoint, copilotRuntimeNextJSPagesRouterEndpoint, copilotRuntimeNodeExpressEndpoint, copilotRuntimeNodeHttpEndpoint, createContext, createLogger, extractParametersFromSchema, generateMcpToolInstructions, getCommonConfig, langGraphPlatformEndpoint, resolveEndpointType };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.mjs.map