{"version":3,"file":"hitl.d.cts","names":["z","ToolCall","InferInteropZodInput","AgentBuiltInState","Runtime","DescriptionFunctionSchema","Record","ZodTypeDef","ZodType","ZodUnknown","ZodTuple","ZodString","ZodPromise","ZodUnion","ZodFunction","DescriptionFactory","infer","DecisionType","ZodEnum","InterruptOnConfigSchema","ZodArray","ZodOptional","ZodAny","ZodRecord","ZodTypeAny","Promise","ZodObject","InterruptOnConfig","input","Action","ActionRequest","ReviewConfig","HITLRequest","ApproveDecision","EditDecision","RejectDecision","Decision","HITLResponse","contextSchema","ZodBoolean","ZodDefault","HumanInTheLoopMiddlewareConfig","humanInTheLoopMiddleware","NonNullable","__types_js7","AgentMiddleware"],"sources":["../../../src/agents/middleware/hitl.d.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport { ToolCall } from \"@langchain/core/messages\";\nimport { InferInteropZodInput } from \"@langchain/core/utils/types\";\nimport type { AgentBuiltInState, Runtime } from \"../runtime.js\";\ndeclare const DescriptionFunctionSchema: z.ZodFunction<z.ZodTuple<[z.ZodType<ToolCall<string, Record<string, any>>, z.ZodTypeDef, ToolCall<string, Record<string, any>>>, z.ZodType<AgentBuiltInState, z.ZodTypeDef, AgentBuiltInState>, z.ZodType<Runtime<unknown>, z.ZodTypeDef, Runtime<unknown>>], z.ZodUnknown>, z.ZodUnion<[z.ZodString, z.ZodPromise<z.ZodString>]>>;\n/**\n * Function type that dynamically generates a description for a tool call approval request.\n *\n * @param toolCall - The tool call being reviewed\n * @param state - The current agent state\n * @param runtime - The agent runtime context\n * @returns A string description or Promise that resolves to a string description\n *\n * @example\n * ```typescript\n * import { type DescriptionFactory, type ToolCall } from \"langchain\";\n *\n * const descriptionFactory: DescriptionFactory = (toolCall, state, runtime) => {\n *   return `Please review: ${toolCall.name}(${JSON.stringify(toolCall.args)})`;\n * };\n * ```\n */\nexport type DescriptionFactory = z.infer<typeof DescriptionFunctionSchema>;\ndeclare const DecisionType: z.ZodEnum<[\"approve\", \"edit\", \"reject\"]>;\nexport type DecisionType = z.infer<typeof DecisionType>;\ndeclare const InterruptOnConfigSchema: z.ZodObject<{\n    /**\n     * The decisions that are allowed for this action.\n     */\n    allowedDecisions: z.ZodArray<z.ZodEnum<[\"approve\", \"edit\", \"reject\"]>, \"many\">;\n    /**\n     * The description attached to the request for human input.\n     * Can be either:\n     * - A static string describing the approval request\n     * - A callable that dynamically generates the description based on agent state,\n     *   runtime, and tool call information\n     *\n     * @example\n     * Static string description\n     * ```typescript\n     * import type { InterruptOnConfig } from \"langchain\";\n     *\n     * const config: InterruptOnConfig = {\n     *   allowedDecisions: [\"approve\", \"reject\"],\n     *   description: \"Please review this tool execution\"\n     * };\n     * ```\n     *\n     * @example\n     * Dynamic callable description\n     * ```typescript\n     * import type {\n     *   AgentBuiltInState,\n     *   Runtime,\n     *   DescriptionFactory,\n     *   ToolCall,\n     *   InterruptOnConfig\n     * } from \"langchain\";\n     *\n     * const formatToolDescription: DescriptionFactory = (\n     *   toolCall: ToolCall,\n     *   state: AgentBuiltInState,\n     *   runtime: Runtime<unknown>\n     * ) => {\n     *   return `Tool: ${toolCall.name}\\nArguments:\\n${JSON.stringify(toolCall.args, null, 2)}`;\n     * };\n     *\n     * const config: InterruptOnConfig = {\n     *   allowedDecisions: [\"approve\", \"edit\"],\n     *   description: formatToolDescription\n     * };\n     * ```\n     */\n    description: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodFunction<z.ZodTuple<[z.ZodType<ToolCall<string, Record<string, any>>, z.ZodTypeDef, ToolCall<string, Record<string, any>>>, z.ZodType<AgentBuiltInState, z.ZodTypeDef, AgentBuiltInState>, z.ZodType<Runtime<unknown>, z.ZodTypeDef, Runtime<unknown>>], z.ZodUnknown>, z.ZodUnion<[z.ZodString, z.ZodPromise<z.ZodString>]>>]>>;\n    /**\n     * JSON schema for the arguments associated with the action, if edits are allowed.\n     */\n    argsSchema: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;\n}, \"strip\", z.ZodTypeAny, {\n    allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n    description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n    argsSchema?: Record<string, any> | undefined;\n}, {\n    allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n    description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n    argsSchema?: Record<string, any> | undefined;\n}>;\nexport type InterruptOnConfig = z.input<typeof InterruptOnConfigSchema>;\n/**\n * Represents an action with a name and arguments.\n */\nexport interface Action {\n    /**\n     * The type or name of action being requested (e.g., \"add_numbers\").\n     */\n    name: string;\n    /**\n     * Key-value pairs of arguments needed for the action (e.g., {\"a\": 1, \"b\": 2}).\n     */\n    args: Record<string, any>;\n}\n/**\n * Represents an action request with a name, arguments, and description.\n */\nexport interface ActionRequest {\n    /**\n     * The name of the action being requested.\n     */\n    name: string;\n    /**\n     * Key-value pairs of arguments needed for the action (e.g., {\"a\": 1, \"b\": 2}).\n     */\n    args: Record<string, any>;\n    /**\n     * The description of the action to be reviewed.\n     */\n    description?: string;\n}\n/**\n * Policy for reviewing a HITL request.\n */\nexport interface ReviewConfig {\n    /**\n     * Name of the action associated with this review configuration.\n     */\n    actionName: string;\n    /**\n     * The decisions that are allowed for this request.\n     */\n    allowedDecisions: DecisionType[];\n    /**\n     * JSON schema for the arguments associated with the action, if edits are allowed.\n     */\n    argsSchema?: Record<string, any>;\n}\n/**\n * Request for human feedback on a sequence of actions requested by a model.\n *\n * @example\n * ```ts\n * const hitlRequest: HITLRequest = {\n *   actionRequests: [\n *     { name: \"send_email\", args: { to: \"user@example.com\", subject: \"Hello\" } }\n *   ],\n *   reviewConfigs: [\n *     {\n *       actionName: \"send_email\",\n *       allowedDecisions: [\"approve\", \"edit\", \"reject\"],\n *       description: \"Please review the email before sending\"\n *     }\n *   ]\n * };\n * const response = interrupt(hitlRequest);\n * ```\n */\nexport interface HITLRequest {\n    /**\n     * A list of agent actions for human review.\n     */\n    actionRequests: ActionRequest[];\n    /**\n     * Review configuration for all possible actions.\n     */\n    reviewConfigs: ReviewConfig[];\n}\n/**\n * Response when a human approves the action.\n */\nexport interface ApproveDecision {\n    type: \"approve\";\n}\n/**\n * Response when a human edits the action.\n */\nexport interface EditDecision {\n    type: \"edit\";\n    /**\n     * Edited action for the agent to perform.\n     * Ex: for a tool call, a human reviewer can edit the tool name and args.\n     */\n    editedAction: Action;\n}\n/**\n * Response when a human rejects the action.\n */\nexport interface RejectDecision {\n    type: \"reject\";\n    /**\n     * The message sent to the model explaining why the action was rejected.\n     */\n    message?: string;\n}\n/**\n * Union of all possible decision types.\n */\nexport type Decision = ApproveDecision | EditDecision | RejectDecision;\n/**\n * Response payload for a HITLRequest.\n */\nexport interface HITLResponse {\n    /**\n     * The decisions made by the human.\n     */\n    decisions: Decision[];\n}\ndeclare const contextSchema: z.ZodObject<{\n    /**\n     * Mapping of tool name to allowed reviewer responses.\n     * If a tool doesn't have an entry, it's auto-approved by default.\n     *\n     * - `true` -> pause for approval and allow approve/edit/reject decisions\n     * - `false` -> auto-approve (no human review)\n     * - `InterruptOnConfig` -> explicitly specify which decisions are allowed for this tool\n     */\n    interruptOn: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodBoolean, z.ZodObject<{\n        /**\n         * The decisions that are allowed for this action.\n         */\n        allowedDecisions: z.ZodArray<z.ZodEnum<[\"approve\", \"edit\", \"reject\"]>, \"many\">;\n        /**\n         * The description attached to the request for human input.\n         * Can be either:\n         * - A static string describing the approval request\n         * - A callable that dynamically generates the description based on agent state,\n         *   runtime, and tool call information\n         *\n         * @example\n         * Static string description\n         * ```typescript\n         * import type { InterruptOnConfig } from \"langchain\";\n         *\n         * const config: InterruptOnConfig = {\n         *   allowedDecisions: [\"approve\", \"reject\"],\n         *   description: \"Please review this tool execution\"\n         * };\n         * ```\n         *\n         * @example\n         * Dynamic callable description\n         * ```typescript\n         * import type {\n         *   AgentBuiltInState,\n         *   Runtime,\n         *   DescriptionFactory,\n         *   ToolCall,\n         *   InterruptOnConfig\n         * } from \"langchain\";\n         *\n         * const formatToolDescription: DescriptionFactory = (\n         *   toolCall: ToolCall,\n         *   state: AgentBuiltInState,\n         *   runtime: Runtime<unknown>\n         * ) => {\n         *   return `Tool: ${toolCall.name}\\nArguments:\\n${JSON.stringify(toolCall.args, null, 2)}`;\n         * };\n         *\n         * const config: InterruptOnConfig = {\n         *   allowedDecisions: [\"approve\", \"edit\"],\n         *   description: formatToolDescription\n         * };\n         * ```\n         */\n        description: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodFunction<z.ZodTuple<[z.ZodType<ToolCall<string, Record<string, any>>, z.ZodTypeDef, ToolCall<string, Record<string, any>>>, z.ZodType<AgentBuiltInState, z.ZodTypeDef, AgentBuiltInState>, z.ZodType<Runtime<unknown>, z.ZodTypeDef, Runtime<unknown>>], z.ZodUnknown>, z.ZodUnion<[z.ZodString, z.ZodPromise<z.ZodString>]>>]>>;\n        /**\n         * JSON schema for the arguments associated with the action, if edits are allowed.\n         */\n        argsSchema: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;\n    }, \"strip\", z.ZodTypeAny, {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }, {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }>]>>>;\n    /**\n     * Prefix used when constructing human-facing approval messages.\n     * Provides context about the tool call being reviewed; does not change the underlying action.\n     *\n     * Note: This prefix is only applied for tools that do not provide a custom\n     * `description` via their {@link InterruptOnConfig}. If a tool specifies a custom\n     * `description`, that per-tool text is used and this prefix is ignored.\n     */\n    descriptionPrefix: z.ZodDefault<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    interruptOn?: Record<string, boolean | {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }> | undefined;\n    descriptionPrefix: string;\n}, {\n    interruptOn?: Record<string, boolean | {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }> | undefined;\n    descriptionPrefix?: string | undefined;\n}>;\nexport type HumanInTheLoopMiddlewareConfig = InferInteropZodInput<typeof contextSchema>;\n/**\n * Creates a Human-in-the-Loop (HITL) middleware for tool approval and oversight.\n *\n * This middleware intercepts tool calls made by an AI agent and provides human oversight\n * capabilities before execution. It enables selective approval workflows where certain tools\n * require human intervention while others can execute automatically.\n *\n * A invocation result that has been interrupted by the middleware will have a `__interrupt__`\n * property that contains the interrupt request.\n *\n * ```ts\n * import { type HITLRequest, type HITLResponse } from \"langchain\";\n * import { type Interrupt } from \"langchain\";\n *\n * const result = await agent.invoke(request);\n * const interruptRequest = result.__interrupt__?.[0] as Interrupt<HITLRequest>;\n *\n * // Examine the action requests and review configs\n * const actionRequests = interruptRequest.value.actionRequests;\n * const reviewConfigs = interruptRequest.value.reviewConfigs;\n *\n * // Create decisions for each action\n * const resume: HITLResponse = {\n *   decisions: actionRequests.map((action, i) => {\n *     if (action.name === \"calculator\") {\n *       return { type: \"approve\" };\n *     } else if (action.name === \"write_file\") {\n *       return {\n *         type: \"edit\",\n *         editedAction: { name: \"write_file\", args: { filename: \"safe.txt\", content: \"Safe content\" } }\n *       };\n *     }\n *     return { type: \"reject\", message: \"Action not allowed\" };\n *   })\n * };\n *\n * // Resume with decisions\n * await agent.invoke(new Command({ resume }), config);\n * ```\n *\n * ## Features\n *\n * - **Selective Tool Approval**: Configure which tools require human approval\n * - **Multiple Decision Types**: Approve, edit, or reject tool calls\n * - **Asynchronous Workflow**: Uses LangGraph's interrupt mechanism for non-blocking approval\n * - **Custom Approval Messages**: Provide context-specific descriptions for approval requests\n *\n * ## Decision Types\n *\n * When a tool requires approval, the human operator can respond with:\n * - `approve`: Execute the tool with original arguments\n * - `edit`: Modify the tool name and/or arguments before execution\n * - `reject`: Provide a manual response instead of executing the tool\n *\n * @param options - Configuration options for the middleware\n * @param options.interruptOn - Per-tool configuration mapping tool names to their settings\n * @param options.interruptOn[toolName].allowedDecisions - Array of decision types allowed for this tool (e.g., [\"approve\", \"edit\", \"reject\"])\n * @param options.interruptOn[toolName].description - Custom approval message for the tool. Can be either a static string or a callable that dynamically generates the description based on agent state, runtime, and tool call information\n * @param options.interruptOn[toolName].argsSchema - JSON schema for the arguments associated with the action, if edits are allowed\n * @param options.descriptionPrefix - Default prefix for approval messages (default: \"Tool execution requires approval\"). Only used for tools that do not define a custom `description` in their InterruptOnConfig.\n *\n * @returns A middleware instance that can be passed to `createAgent`\n *\n * @example\n * Basic usage with selective tool approval\n * ```typescript\n * import { humanInTheLoopMiddleware } from \"langchain\";\n * import { createAgent } from \"langchain\";\n *\n * const hitlMiddleware = humanInTheLoopMiddleware({\n *   interruptOn: {\n *     // Interrupt write_file tool and allow edits or approvals\n *     \"write_file\": {\n *       allowedDecisions: [\"approve\", \"edit\"],\n *       description: \"‚ö†Ô∏è File write operation requires approval\"\n *     },\n *     // Auto-approve read_file tool\n *     \"read_file\": false\n *   }\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4\",\n *   tools: [writeFileTool, readFileTool],\n *   middleware: [hitlMiddleware]\n * });\n * ```\n *\n * @example\n * Handling approval requests\n * ```typescript\n * import { type HITLRequest, type HITLResponse, type Interrupt } from \"langchain\";\n * import { Command } from \"@langchain/langgraph\";\n *\n * // Initial agent invocation\n * const result = await agent.invoke({\n *   messages: [new HumanMessage(\"Write 'Hello' to output.txt\")]\n * }, config);\n *\n * // Check if agent is paused for approval\n * if (result.__interrupt__) {\n *   const interruptRequest = result.__interrupt__?.[0] as Interrupt<HITLRequest>;\n *\n *   // Show tool call details to user\n *   console.log(\"Actions:\", interruptRequest.value.actionRequests);\n *   console.log(\"Review configs:\", interruptRequest.value.reviewConfigs);\n *\n *   // Resume with approval\n *   const resume: HITLResponse = {\n *     decisions: [{ type: \"approve\" }]\n *   };\n *   await agent.invoke(\n *     new Command({ resume }),\n *     config\n *   );\n * }\n * ```\n *\n * @example\n * Different decision types\n * ```typescript\n * import { type HITLResponse } from \"langchain\";\n *\n * // Approve the tool call as-is\n * const resume: HITLResponse = {\n *   decisions: [{ type: \"approve\" }]\n * };\n *\n * // Edit the tool arguments\n * const resume: HITLResponse = {\n *   decisions: [{\n *     type: \"edit\",\n *     editedAction: { name: \"write_file\", args: { filename: \"safe.txt\", content: \"Modified\" } }\n *   }]\n * };\n *\n * // Reject with feedback\n * const resume: HITLResponse = {\n *   decisions: [{\n *     type: \"reject\",\n *     message: \"File operation not allowed in demo mode\"\n *   }]\n * };\n * ```\n *\n * @example\n * Production use case with database operations\n * ```typescript\n * const hitlMiddleware = humanInTheLoopMiddleware({\n *   interruptOn: {\n *     \"execute_sql\": {\n *       allowedDecisions: [\"approve\", \"edit\", \"reject\"],\n *       description: \"üö® SQL query requires DBA approval\\nPlease review for safety and performance\"\n *     },\n *     \"read_schema\": false,  // Reading metadata is safe\n *     \"delete_records\": {\n *       allowedDecisions: [\"approve\", \"reject\"],\n *       description: \"‚õî DESTRUCTIVE OPERATION - Requires manager approval\"\n *     }\n *   },\n *   descriptionPrefix: \"Database operation pending approval\"\n * });\n * ```\n *\n * @example\n * Using dynamic callable descriptions\n * ```typescript\n * import { type DescriptionFactory, type ToolCall } from \"langchain\";\n * import type { AgentBuiltInState, Runtime } from \"langchain/agents\";\n *\n * // Define a dynamic description factory\n * const formatToolDescription: DescriptionFactory = (\n *   toolCall: ToolCall,\n *   state: AgentBuiltInState,\n *   runtime: Runtime<unknown>\n * ) => {\n *   return `Tool: ${toolCall.name}\\nArguments:\\n${JSON.stringify(toolCall.args, null, 2)}`;\n * };\n *\n * const hitlMiddleware = humanInTheLoopMiddleware({\n *   interruptOn: {\n *     \"write_file\": {\n *       allowedDecisions: [\"approve\", \"edit\"],\n *       // Use dynamic description that can access tool call, state, and runtime\n *       description: formatToolDescription\n *     },\n *     // Or use an inline function\n *     \"send_email\": {\n *       allowedDecisions: [\"approve\", \"reject\"],\n *       description: (toolCall, state, runtime) => {\n *         const { to, subject } = toolCall.args;\n *         return `Email to ${to}\\nSubject: ${subject}\\n\\nRequires approval before sending`;\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @remarks\n * - Tool calls are processed in the order they appear in the AI message\n * - Auto-approved tools execute immediately without interruption\n * - Multiple tools requiring approval are bundled into a single interrupt request\n * - The middleware operates in the `afterModel` phase, intercepting before tool execution\n * - Requires a checkpointer to maintain state across interruptions\n *\n * @see {@link createAgent} for agent creation\n * @see {@link Command} for resuming interrupted execution\n * @public\n */\nexport declare function humanInTheLoopMiddleware(options: NonNullable<HumanInTheLoopMiddlewareConfig>): import(\"./types.js\").AgentMiddleware<undefined, z.ZodObject<{\n    /**\n     * Mapping of tool name to allowed reviewer responses.\n     * If a tool doesn't have an entry, it's auto-approved by default.\n     *\n     * - `true` -> pause for approval and allow approve/edit/reject decisions\n     * - `false` -> auto-approve (no human review)\n     * - `InterruptOnConfig` -> explicitly specify which decisions are allowed for this tool\n     */\n    interruptOn: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodBoolean, z.ZodObject<{\n        /**\n         * The decisions that are allowed for this action.\n         */\n        allowedDecisions: z.ZodArray<z.ZodEnum<[\"approve\", \"edit\", \"reject\"]>, \"many\">;\n        /**\n         * The description attached to the request for human input.\n         * Can be either:\n         * - A static string describing the approval request\n         * - A callable that dynamically generates the description based on agent state,\n         *   runtime, and tool call information\n         *\n         * @example\n         * Static string description\n         * ```typescript\n         * import type { InterruptOnConfig } from \"langchain\";\n         *\n         * const config: InterruptOnConfig = {\n         *   allowedDecisions: [\"approve\", \"reject\"],\n         *   description: \"Please review this tool execution\"\n         * };\n         * ```\n         *\n         * @example\n         * Dynamic callable description\n         * ```typescript\n         * import type {\n         *   AgentBuiltInState,\n         *   Runtime,\n         *   DescriptionFactory,\n         *   ToolCall,\n         *   InterruptOnConfig\n         * } from \"langchain\";\n         *\n         * const formatToolDescription: DescriptionFactory = (\n         *   toolCall: ToolCall,\n         *   state: AgentBuiltInState,\n         *   runtime: Runtime<unknown>\n         * ) => {\n         *   return `Tool: ${toolCall.name}\\nArguments:\\n${JSON.stringify(toolCall.args, null, 2)}`;\n         * };\n         *\n         * const config: InterruptOnConfig = {\n         *   allowedDecisions: [\"approve\", \"edit\"],\n         *   description: formatToolDescription\n         * };\n         * ```\n         */\n        description: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodFunction<z.ZodTuple<[z.ZodType<ToolCall<string, Record<string, any>>, z.ZodTypeDef, ToolCall<string, Record<string, any>>>, z.ZodType<AgentBuiltInState, z.ZodTypeDef, AgentBuiltInState>, z.ZodType<Runtime<unknown>, z.ZodTypeDef, Runtime<unknown>>], z.ZodUnknown>, z.ZodUnion<[z.ZodString, z.ZodPromise<z.ZodString>]>>]>>;\n        /**\n         * JSON schema for the arguments associated with the action, if edits are allowed.\n         */\n        argsSchema: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;\n    }, \"strip\", z.ZodTypeAny, {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }, {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }>]>>>;\n    /**\n     * Prefix used when constructing human-facing approval messages.\n     * Provides context about the tool call being reviewed; does not change the underlying action.\n     *\n     * Note: This prefix is only applied for tools that do not provide a custom\n     * `description` via their {@link InterruptOnConfig}. If a tool specifies a custom\n     * `description`, that per-tool text is used and this prefix is ignored.\n     */\n    descriptionPrefix: z.ZodDefault<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    interruptOn?: Record<string, boolean | {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }> | undefined;\n    descriptionPrefix: string;\n}, {\n    interruptOn?: Record<string, boolean | {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }> | undefined;\n    descriptionPrefix?: string | undefined;\n}>, any>;\nexport {};\n//# sourceMappingURL=hitl.d.ts.map"],"mappings":"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"}