{"version":3,"file":"agent_executor.js","names":[],"sources":["../../src/prebuilt/agent_executor.ts"],"sourcesContent":["import { AgentAction, AgentFinish } from \"@langchain/core/agents\";\nimport { BaseMessage } from \"@langchain/core/messages\";\nimport { Runnable, type RunnableConfig } from \"@langchain/core/runnables\";\nimport { Tool } from \"@langchain/core/tools\";\nimport { ToolExecutor } from \"./tool_executor.js\";\nimport { StateGraph } from \"../graph/state.js\";\nimport { END, START } from \"../constants.js\";\nimport type { BaseChannel } from \"../channels/base.js\";\n\ninterface Step {\n  action: AgentAction | AgentFinish;\n  observation: unknown;\n}\n\n/** @ignore */\nexport interface AgentExecutorState {\n  agentOutcome?: AgentAction | AgentFinish;\n  steps: Array<Step>;\n  input: string;\n  chatHistory?: BaseMessage[];\n}\n\n/** @ignore */\nexport function createAgentExecutor({\n  agentRunnable,\n  tools,\n}: {\n  agentRunnable: Runnable;\n  tools: Array<Tool> | ToolExecutor;\n}) {\n  let toolExecutor: ToolExecutor;\n  if (!Array.isArray(tools)) {\n    toolExecutor = tools;\n  } else {\n    toolExecutor = new ToolExecutor({\n      tools,\n    });\n  }\n\n  // Define logic that will be used to determine which conditional edge to go down\n  const shouldContinue = (data: AgentExecutorState) => {\n    if (data.agentOutcome && \"returnValues\" in data.agentOutcome) {\n      return \"end\";\n    }\n    return \"continue\";\n  };\n\n  const runAgent = async (\n    data: AgentExecutorState,\n    config?: RunnableConfig\n  ) => {\n    const agentOutcome = await agentRunnable.invoke(data, config);\n    return {\n      agentOutcome,\n    };\n  };\n\n  const executeTools = async (\n    data: AgentExecutorState,\n    config?: RunnableConfig\n  ): Promise<Partial<AgentExecutorState>> => {\n    const agentAction = data.agentOutcome;\n    if (!agentAction || \"returnValues\" in agentAction) {\n      throw new Error(\"Agent has not been run yet\");\n    }\n    const output = await toolExecutor.invoke(agentAction, config);\n    return {\n      steps: [{ action: agentAction, observation: output }],\n    };\n  };\n\n  // Define a new graph\n  const workflow = new StateGraph<{\n    [K in keyof AgentExecutorState]: BaseChannel<\n      AgentExecutorState[K],\n      AgentExecutorState[K]\n    >;\n  }>({\n    channels: {\n      input: null,\n      agentOutcome: null,\n      steps: {\n        reducer: (x: Step[], y: Step[]) => x.concat(y),\n        default: () => [] as Step[],\n      },\n    },\n  })\n    // Define the two nodes we will cycle between\n    .addNode(\"agent\", runAgent)\n    .addNode(\"action\", executeTools)\n    // Set the entrypoint as `agent`\n    // This means that this node is the first one called\n    .addEdge(START, \"agent\")\n    // We now add a conditional edge\n    .addConditionalEdges(\n      // First, we define the start node. We use `agent`.\n      // This means these are the edges taken after the `agent` node is called.\n      \"agent\",\n      // Next, we pass in the function that will determine which node is called next.\n      shouldContinue,\n      // Finally we pass in a mapping.\n      // The keys are strings, and the values are other nodes.\n      // END is a special node marking that the graph should finish.\n      // What will happen is we will call `should_continue`, and then the output of that\n      // will be matched against the keys in this mapping.\n      // Based on which one it matches, that node will then be called.\n      {\n        // If `tools`, then we call the tool node.\n        continue: \"action\",\n        // Otherwise we finish.\n        end: END,\n      }\n    )\n    // We now add a normal edge from `tools` to `agent`.\n    // This means that after `tools` is called, `agent` node is called next.\n    .addEdge(\"action\", \"agent\");\n\n  return workflow.compile();\n}\n"],"mappings":";;;;;;AAuBA,SAAgB,oBAAoB,EAClC,eACA,SAIC;CACD,IAAI;AACJ,KAAI,CAAC,MAAM,QAAQ,MAAM,CACvB,gBAAe;KAEf,gBAAe,IAAI,aAAa,EAC9B,OACD,CAAC;CAIJ,MAAM,kBAAkB,SAA6B;AACnD,MAAI,KAAK,gBAAgB,kBAAkB,KAAK,aAC9C,QAAO;AAET,SAAO;;CAGT,MAAM,WAAW,OACf,MACA,WACG;AAEH,SAAO,EACL,cAFmB,MAAM,cAAc,OAAO,MAAM,OAAO,EAG5D;;CAGH,MAAM,eAAe,OACnB,MACA,WACyC;EACzC,MAAM,cAAc,KAAK;AACzB,MAAI,CAAC,eAAe,kBAAkB,YACpC,OAAM,IAAI,MAAM,6BAA6B;AAG/C,SAAO,EACL,OAAO,CAAC;GAAE,QAAQ;GAAa,aAFlB,MAAM,aAAa,OAAO,aAAa,OAAO;GAEP,CAAC,EACtD;;AAiDH,QA7CiB,IAAI,WAKlB,EACD,UAAU;EACR,OAAO;EACP,cAAc;EACd,OAAO;GACL,UAAU,GAAW,MAAc,EAAE,OAAO,EAAE;GAC9C,eAAe,EAAE;GAClB;EACF,EACF,CAAC,CAEC,QAAQ,SAAS,SAAS,CAC1B,QAAQ,UAAU,aAAa,CAG/B,QAAQ,OAAO,QAAQ,CAEvB,oBAGC,SAEA,gBAOA;EAEE,UAAU;EAEV,KAAK;EACN,CACF,CAGA,QAAQ,UAAU,QAAQ,CAEb,SAAS"}