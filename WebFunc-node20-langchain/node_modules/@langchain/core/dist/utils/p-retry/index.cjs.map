{"version":3,"file":"index.cjs","names":["isNetworkError"],"sources":["../../../src/utils/p-retry/index.js"],"sourcesContent":["/* eslint-disable */\nimport isNetworkError from \"../is-network-error/index.js\";\n\nfunction validateRetries(retries) {\n  if (typeof retries === \"number\") {\n    if (retries < 0) {\n      throw new TypeError(\"Expected `retries` to be a non-negative number.\");\n    }\n\n    if (Number.isNaN(retries)) {\n      throw new TypeError(\n        \"Expected `retries` to be a valid number or Infinity, got NaN.\"\n      );\n    }\n  } else if (retries !== undefined) {\n    throw new TypeError(\"Expected `retries` to be a number or Infinity.\");\n  }\n}\n\nfunction validateNumberOption(\n  name,\n  value,\n  { min = 0, allowInfinity = false } = {}\n) {\n  if (value === undefined) {\n    return;\n  }\n\n  if (typeof value !== \"number\" || Number.isNaN(value)) {\n    throw new TypeError(\n      `Expected \\`${name}\\` to be a number${\n        allowInfinity ? \" or Infinity\" : \"\"\n      }.`\n    );\n  }\n\n  if (!allowInfinity && !Number.isFinite(value)) {\n    throw new TypeError(`Expected \\`${name}\\` to be a finite number.`);\n  }\n\n  if (value < min) {\n    throw new TypeError(`Expected \\`${name}\\` to be \\u2265 ${min}.`);\n  }\n}\n\nexport class AbortError extends Error {\n  constructor(message) {\n    super();\n\n    if (message instanceof Error) {\n      this.originalError = message;\n      ({ message } = message);\n    } else {\n      this.originalError = new Error(message);\n      this.originalError.stack = this.stack;\n    }\n\n    this.name = \"AbortError\";\n    this.message = message;\n  }\n}\n\nfunction calculateDelay(retriesConsumed, options) {\n  const attempt = Math.max(1, retriesConsumed + 1);\n  const random = options.randomize ? Math.random() + 1 : 1;\n\n  let timeout = Math.round(\n    random * options.minTimeout * options.factor ** (attempt - 1)\n  );\n  timeout = Math.min(timeout, options.maxTimeout);\n\n  return timeout;\n}\n\nfunction calculateRemainingTime(start, max) {\n  if (!Number.isFinite(max)) {\n    return max;\n  }\n\n  return max - (performance.now() - start);\n}\n\nasync function onAttemptFailure({\n  error,\n  attemptNumber,\n  retriesConsumed,\n  startTime,\n  options,\n}) {\n  const normalizedError =\n    error instanceof Error\n      ? error\n      : new TypeError(\n          `Non-error was thrown: \"${error}\". You should only throw errors.`\n        );\n\n  if (normalizedError instanceof AbortError) {\n    throw normalizedError.originalError;\n  }\n\n  const retriesLeft = Number.isFinite(options.retries)\n    ? Math.max(0, options.retries - retriesConsumed)\n    : options.retries;\n\n  const maxRetryTime = options.maxRetryTime ?? Number.POSITIVE_INFINITY;\n\n  const context = Object.freeze({\n    error: normalizedError,\n    attemptNumber,\n    retriesLeft,\n    retriesConsumed,\n  });\n\n  await options.onFailedAttempt(context);\n\n  if (calculateRemainingTime(startTime, maxRetryTime) <= 0) {\n    throw normalizedError;\n  }\n\n  const consumeRetry = await options.shouldConsumeRetry(context);\n\n  const remainingTime = calculateRemainingTime(startTime, maxRetryTime);\n\n  if (remainingTime <= 0 || retriesLeft <= 0) {\n    throw normalizedError;\n  }\n\n  if (\n    normalizedError instanceof TypeError &&\n    !isNetworkError(normalizedError)\n  ) {\n    if (consumeRetry) {\n      throw normalizedError;\n    }\n\n    options.signal?.throwIfAborted();\n    return false;\n  }\n\n  if (!(await options.shouldRetry(context))) {\n    throw normalizedError;\n  }\n\n  if (!consumeRetry) {\n    options.signal?.throwIfAborted();\n    return false;\n  }\n\n  const delayTime = calculateDelay(retriesConsumed, options);\n  const finalDelay = Math.min(delayTime, remainingTime);\n\n  if (finalDelay > 0) {\n    await new Promise((resolve, reject) => {\n      const onAbort = () => {\n        clearTimeout(timeoutToken);\n        options.signal?.removeEventListener(\"abort\", onAbort);\n        reject(options.signal.reason);\n      };\n\n      const timeoutToken = setTimeout(() => {\n        options.signal?.removeEventListener(\"abort\", onAbort);\n        resolve();\n      }, finalDelay);\n\n      if (options.unref) {\n        timeoutToken.unref?.();\n      }\n\n      options.signal?.addEventListener(\"abort\", onAbort, { once: true });\n    });\n  }\n\n  options.signal?.throwIfAborted();\n\n  return true;\n}\n\nexport default async function pRetry(input, options = {}) {\n  options = { ...options };\n\n  validateRetries(options.retries);\n\n  if (Object.hasOwn(options, \"forever\")) {\n    throw new Error(\n      \"The `forever` option is no longer supported. For many use-cases, you can set `retries: Infinity` instead.\"\n    );\n  }\n\n  options.retries ??= 10;\n  options.factor ??= 2;\n  options.minTimeout ??= 1000;\n  options.maxTimeout ??= Number.POSITIVE_INFINITY;\n  options.maxRetryTime ??= Number.POSITIVE_INFINITY;\n  options.randomize ??= false;\n  options.onFailedAttempt ??= () => {};\n  options.shouldRetry ??= () => true;\n  options.shouldConsumeRetry ??= () => true;\n\n  // Validate numeric options and normalize edge cases\n  validateNumberOption(\"factor\", options.factor, {\n    min: 0,\n    allowInfinity: false,\n  });\n  validateNumberOption(\"minTimeout\", options.minTimeout, {\n    min: 0,\n    allowInfinity: false,\n  });\n  validateNumberOption(\"maxTimeout\", options.maxTimeout, {\n    min: 0,\n    allowInfinity: true,\n  });\n  validateNumberOption(\"maxRetryTime\", options.maxRetryTime, {\n    min: 0,\n    allowInfinity: true,\n  });\n\n  // Treat non-positive factor as 1 to avoid zero backoff or negative behavior\n  if (!(options.factor > 0)) {\n    options.factor = 1;\n  }\n\n  options.signal?.throwIfAborted();\n\n  let attemptNumber = 0;\n  let retriesConsumed = 0;\n  const startTime = performance.now();\n\n  while (\n    Number.isFinite(options.retries) ? retriesConsumed <= options.retries : true\n  ) {\n    attemptNumber++;\n\n    try {\n      options.signal?.throwIfAborted();\n\n      const result = await input(attemptNumber);\n\n      options.signal?.throwIfAborted();\n\n      return result;\n    } catch (error) {\n      if (\n        await onAttemptFailure({\n          error,\n          attemptNumber,\n          retriesConsumed,\n          startTime,\n          options,\n        })\n      ) {\n        retriesConsumed++;\n      }\n    }\n  }\n\n  // Should not reach here, but in case it does, throw an error\n  throw new Error(\"Retry attempts exhausted without throwing an error.\");\n}\n\nexport function makeRetriable(function_, options) {\n  return function (...arguments_) {\n    return pRetry(() => function_.apply(this, arguments_), options);\n  };\n}\n"],"mappings":"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"}