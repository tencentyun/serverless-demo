{"version":3,"file":"ReactAgent.d.cts","names":["InteropZodObject","StateGraph","Command","CompiledStateGraph","GetStateOptions","LangGraphRunnableConfig","StreamMode","StreamOutputMap","CheckpointListOptions","MessageStructure","IterableReadableStream","Runnable","RunnableConfig","StreamEvent","ClientTool","ServerTool","AgentTypeConfig","CreateAgentParams","ToolsToMessageToolSet","BuiltInState","UserInput","InvokeConfiguration","StreamConfiguration","AgentMiddleware","InferMiddlewareContextInputs","InferMiddlewareStates","InferMiddlewareInputStates","InferContextInput","AnyAnnotationRoot","InferSchemaInput","ToAnnotationRoot","ResponseFormatUndefined","MergedAgentState","Types","Omit","InvokeStateParameter","AgentGraph","ReactAgent","TStreamMode","TEncoding","Record","Promise","ArrayBuffer","Uint8Array","Parameters"],"sources":["../../src/agents/ReactAgent.d.ts"],"sourcesContent":["import { InteropZodObject } from \"@langchain/core/utils/types\";\nimport { StateGraph, Command, CompiledStateGraph, type GetStateOptions, type LangGraphRunnableConfig, type StreamMode, type StreamOutputMap } from \"@langchain/langgraph\";\nimport type { CheckpointListOptions } from \"@langchain/langgraph-checkpoint\";\nimport { MessageStructure } from \"@langchain/core/messages\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport { type Runnable, type RunnableConfig } from \"@langchain/core/runnables\";\nimport type { StreamEvent } from \"@langchain/core/tracers/log_stream\";\nimport type { ClientTool, ServerTool } from \"@langchain/core/tools\";\nimport type { AgentTypeConfig, CreateAgentParams, ToolsToMessageToolSet } from \"./types.js\";\nimport type { BuiltInState, UserInput } from \"./types.js\";\nimport type { InvokeConfiguration, StreamConfiguration } from \"./runtime.js\";\nimport type { AgentMiddleware, InferMiddlewareContextInputs, InferMiddlewareStates, InferMiddlewareInputStates, InferContextInput, AnyAnnotationRoot, InferSchemaInput, ToAnnotationRoot } from \"./middleware/types.js\";\nimport { type ResponseFormatUndefined } from \"./responses.js\";\ntype MergedAgentState<Types extends AgentTypeConfig> = InferSchemaInput<Types[\"State\"]> & (Types[\"Response\"] extends ResponseFormatUndefined ? Omit<BuiltInState<MessageStructure<ToolsToMessageToolSet<Types[\"Tools\"]>>>, \"jumpTo\"> : Omit<BuiltInState<MessageStructure<ToolsToMessageToolSet<Types[\"Tools\"]>>>, \"jumpTo\"> & {\n    structuredResponse: Types[\"Response\"];\n}) & InferMiddlewareStates<Types[\"Middleware\"]>;\ntype InvokeStateParameter<Types extends AgentTypeConfig> = (UserInput<Types[\"State\"]> & InferMiddlewareInputStates<Types[\"Middleware\"]>) | Command<any, any, any> | null;\ntype AgentGraph<Types extends AgentTypeConfig> = CompiledStateGraph<any, any, any, any, MergedAgentState<Types>, ToAnnotationRoot<Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject ? Types[\"Context\"] : AnyAnnotationRoot>[\"spec\"], unknown>;\n/**\n * ReactAgent is a production-ready ReAct (Reasoning + Acting) agent that combines\n * language models with tools and middleware.\n *\n * The agent is parameterized by a single type bag `Types` that encapsulates all\n * type information:\n *\n * @typeParam Types - An {@link AgentTypeConfig} that bundles:\n *   - `Response`: The structured response type\n *   - `State`: The custom state schema type\n *   - `Context`: The context schema type\n *   - `Middleware`: The middleware array type\n *   - `Tools`: The combined tools type from agent and middleware\n *\n * @example\n * ```typescript\n * // Using the type bag pattern\n * type MyTypes = AgentTypeConfig<\n *   { name: string },  // Response\n *   typeof myState,    // State\n *   typeof myContext,  // Context\n *   typeof middleware, // Middleware\n *   typeof tools       // Tools\n * >;\n *\n * const agent: ReactAgent<MyTypes> = createAgent({ ... });\n * ```\n */\nexport declare class ReactAgent<Types extends AgentTypeConfig = AgentTypeConfig<Record<string, any>, undefined, AnyAnnotationRoot, readonly AgentMiddleware[], readonly (ClientTool | ServerTool)[]>> {\n    #private;\n    options: CreateAgentParams<Types[\"Response\"], Types[\"State\"], Types[\"Context\"]>;\n    /**\n     * Type marker for extracting the AgentTypeConfig from a ReactAgent instance.\n     * This is a phantom property used only for type inference.\n     * @internal\n     */\n    readonly \"~agentTypes\": Types;\n    constructor(options: CreateAgentParams<Types[\"Response\"], Types[\"State\"], Types[\"Context\"]>, defaultConfig?: RunnableConfig);\n    /**\n     * Get the compiled {@link https://docs.langchain.com/oss/javascript/langgraph/use-graph-api | StateGraph}.\n     */\n    get graph(): AgentGraph<Types>;\n    /**\n     * Creates a new ReactAgent with the given config merged into the existing config.\n     * Follows the same pattern as LangGraph's Pregel.withConfig().\n     *\n     * The merged config is applied as a default that gets merged with any config\n     * passed at invocation time (invoke/stream). Invocation-time config takes precedence.\n     *\n     * @param config - Configuration to merge with existing config\n     * @returns A new ReactAgent instance with the merged configuration\n     *\n     * @example\n     * ```typescript\n     * const agent = createAgent({ model: \"gpt-4o\", tools: [...] });\n     *\n     * // Set a default recursion limit\n     * const configuredAgent = agent.withConfig({ recursionLimit: 1000 });\n     *\n     * // Chain multiple configs\n     * const debugAgent = agent\n     *   .withConfig({ recursionLimit: 1000 })\n     *   .withConfig({ tags: [\"debug\"] });\n     * ```\n     */\n    withConfig(config: Omit<RunnableConfig, \"store\" | \"writer\" | \"interrupt\">): ReactAgent<Types>;\n    /**\n     * Executes the agent with the given state and returns the final state after all processing.\n     *\n     * This method runs the agent's entire workflow synchronously, including:\n     * - Processing the input messages through any configured middleware\n     * - Calling the language model to generate responses\n     * - Executing any tool calls made by the model\n     * - Running all middleware hooks (beforeModel, afterModel, etc.)\n     *\n     * @param state - The initial state for the agent execution. Can be:\n     *   - An object containing `messages` array and any middleware-specific state properties\n     *   - A Command object for more advanced control flow\n     *\n     * @param config - Optional runtime configuration including:\n     * @param config.context - The context for the agent execution.\n     * @param config.configurable - LangGraph configuration options like `thread_id`, `run_id`, etc.\n     * @param config.store - The store for the agent execution for persisting state, see more in {@link https://docs.langchain.com/oss/javascript/langgraph/memory#memory-storage | Memory storage}.\n     * @param config.signal - An optional {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal | `AbortSignal`} for the agent execution.\n     * @param config.recursionLimit - The recursion limit for the agent execution.\n     *\n     * @returns A Promise that resolves to the final agent state after execution completes.\n     *          The returned state includes:\n     *          - a `messages` property containing an array with all messages (input, AI responses, tool calls/results)\n     *          - a `structuredResponse` property containing the structured response (if configured)\n     *          - all state values defined in the middleware\n     *\n     * @example\n     * ```typescript\n     * const agent = new ReactAgent({\n     *   llm: myModel,\n     *   tools: [calculator, webSearch],\n     *   responseFormat: z.object({\n     *     weather: z.string(),\n     *   }),\n     * });\n     *\n     * const result = await agent.invoke({\n     *   messages: [{ role: \"human\", content: \"What's the weather in Paris?\" }]\n     * });\n     *\n     * console.log(result.structuredResponse.weather); // outputs: \"It's sunny and 75Â°F.\"\n     * ```\n     */\n    invoke(state: InvokeStateParameter<Types>, config?: InvokeConfiguration<InferContextInput<Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject ? Types[\"Context\"] : AnyAnnotationRoot> & InferMiddlewareContextInputs<Types[\"Middleware\"]>>): Promise<MergedAgentState<Types>>;\n    /**\n     * Executes the agent with streaming, returning an async iterable of state updates as they occur.\n     *\n     * This method runs the agent's workflow similar to `invoke`, but instead of waiting for\n     * completion, it streams high-level state updates in real-time. This allows you to:\n     * - Display intermediate results to users as they're generated\n     * - Monitor the agent's progress through each step\n     * - React to state changes as nodes complete\n     *\n     * For more granular event-level streaming (like individual LLM tokens), use `streamEvents` instead.\n     *\n     * @param state - The initial state for the agent execution. Can be:\n     *   - An object containing `messages` array and any middleware-specific state properties\n     *   - A Command object for more advanced control flow\n     *\n     * @param config - Optional runtime configuration including:\n     * @param config.context - The context for the agent execution.\n     * @param config.configurable - LangGraph configuration options like `thread_id`, `run_id`, etc.\n     * @param config.store - The store for the agent execution for persisting state, see more in {@link https://docs.langchain.com/oss/javascript/langgraph/memory#memory-storage | Memory storage}.\n     * @param config.signal - An optional {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal | `AbortSignal`} for the agent execution.\n     * @param config.streamMode - The streaming mode for the agent execution, see more in {@link https://docs.langchain.com/oss/javascript/langgraph/streaming#supported-stream-modes | Supported stream modes}.\n     * @param config.recursionLimit - The recursion limit for the agent execution.\n     *\n     * @returns A Promise that resolves to an IterableReadableStream of state updates.\n     *          Each update contains the current state after a node completes.\n     *\n     * @example\n     * ```typescript\n     * const agent = new ReactAgent({\n     *   llm: myModel,\n     *   tools: [calculator, webSearch]\n     * });\n     *\n     * const stream = await agent.stream({\n     *   messages: [{ role: \"human\", content: \"What's 2+2 and the weather in NYC?\" }]\n     * });\n     *\n     * for await (const chunk of stream) {\n     *   console.log(chunk); // State update from each node\n     * }\n     * ```\n     */\n    stream<TStreamMode extends StreamMode | StreamMode[] | undefined, TEncoding extends \"text/event-stream\" | undefined>(state: InvokeStateParameter<Types>, config?: StreamConfiguration<InferContextInput<Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject ? Types[\"Context\"] : AnyAnnotationRoot> & InferMiddlewareContextInputs<Types[\"Middleware\"]>, TStreamMode, TEncoding>): Promise<IterableReadableStream<StreamOutputMap<TStreamMode, false, MergedAgentState<Types>, MergedAgentState<Types>, string, unknown, unknown, TEncoding>>>;\n    /**\n     * Visualize the graph as a PNG image.\n     * @param params - Parameters for the drawMermaidPng method.\n     * @param params.withStyles - Whether to include styles in the graph.\n     * @param params.curveStyle - The style of the graph's curves.\n     * @param params.nodeColors - The colors of the graph's nodes.\n     * @param params.wrapLabelNWords - The maximum number of words to wrap in a node's label.\n     * @param params.backgroundColor - The background color of the graph.\n     * @returns PNG image as a buffer\n     */\n    drawMermaidPng(params?: {\n        withStyles?: boolean;\n        curveStyle?: string;\n        nodeColors?: Record<string, string>;\n        wrapLabelNWords?: number;\n        backgroundColor?: string;\n    }): Promise<Uint8Array<ArrayBuffer>>;\n    /**\n     * Draw the graph as a Mermaid string.\n     * @param params - Parameters for the drawMermaid method.\n     * @param params.withStyles - Whether to include styles in the graph.\n     * @param params.curveStyle - The style of the graph's curves.\n     * @param params.nodeColors - The colors of the graph's nodes.\n     * @param params.wrapLabelNWords - The maximum number of words to wrap in a node's label.\n     * @param params.backgroundColor - The background color of the graph.\n     * @returns Mermaid string\n     */\n    drawMermaid(params?: {\n        withStyles?: boolean;\n        curveStyle?: string;\n        nodeColors?: Record<string, string>;\n        wrapLabelNWords?: number;\n        backgroundColor?: string;\n    }): Promise<string>;\n    /**\n     * The following are internal methods to enable support for LangGraph Platform.\n     * They are not part of the createAgent public API.\n     *\n     * Note: we intentionally return as `never` to avoid type errors due to type inference.\n     */\n    /**\n     * @internal\n     */\n    streamEvents(state: InvokeStateParameter<Types>, config?: StreamConfiguration<InferContextInput<Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject ? Types[\"Context\"] : AnyAnnotationRoot> & InferMiddlewareContextInputs<Types[\"Middleware\"]>, StreamMode | StreamMode[] | undefined, \"text/event-stream\" | undefined> & {\n        version?: \"v1\" | \"v2\";\n    }, streamOptions?: Parameters<Runnable[\"streamEvents\"]>[2]): IterableReadableStream<StreamEvent>;\n    /**\n     * @internal\n     */\n    getGraphAsync(config?: RunnableConfig): never;\n    /**\n     * @internal\n     */\n    getState(config: RunnableConfig, options?: GetStateOptions): never;\n    /**\n     * @internal\n     */\n    getStateHistory(config: RunnableConfig, options?: CheckpointListOptions): never;\n    /**\n     * @internal\n     */\n    getSubgraphs(namespace?: string, recurse?: boolean): never;\n    /**\n     * @internal\n     */\n    getSubgraphAsync(namespace?: string, recurse?: boolean): never;\n    /**\n     * @internal\n     */\n    updateState(inputConfig: LangGraphRunnableConfig, values: Record<string, unknown> | unknown, asNode?: string): never;\n    /**\n     * @internal\n     */\n    get builder(): StateGraph<unknown, any, any, any, any, MergedAgentState<Types>, ToAnnotationRoot<Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject ? Types[\"Context\"] : AnyAnnotationRoot>[\"spec\"], unknown, unknown, unknown>;\n}\nexport {};\n//# sourceMappingURL=ReactAgent.d.ts.map"],"mappings":"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"}