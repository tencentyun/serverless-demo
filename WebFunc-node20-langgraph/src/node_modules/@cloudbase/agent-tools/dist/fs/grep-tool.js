"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGrepTool = createGrepTool;
const v4_1 = require("zod/v4");
const path = __importStar(require("path"));
const utils_1 = require("./utils");
const utils_2 = require("../utils");
const grepParametersSchema = v4_1.z.object({
    pattern: v4_1.z
        .string()
        .describe('Regular expression pattern to search for (e.g., "function\\s+\\w+", "import.*from")'),
    path: v4_1.z
        .string()
        .optional()
        .describe("File or directory to search in (relative to workspace root, or absolute path within workspace). Defaults to workspace root."),
    include: v4_1.z
        .string()
        .optional()
        .describe('File pattern to include (e.g., "*.js", "*.{ts,tsx}", "src/**/*.ts")'),
    case_sensitive: v4_1.z
        .boolean()
        .optional()
        .describe("Whether the search should be case-sensitive (default: false)"),
    max_files: v4_1.z
        .number()
        .min(1)
        .optional()
        .describe("Maximum number of files to search (default: 1000)"),
    max_matches: v4_1.z
        .number()
        .min(1)
        .optional()
        .describe("Maximum number of matches to return (default: 100)"),
});
// Path validation is now handled by validateWorkspacePath in tool-utils
/**
 * Check if a file path matches the include pattern
 */
function matchesIncludePattern(filePath, includePattern) {
    if (!includePattern) {
        return true;
    }
    // Convert glob pattern to regex (simplified)
    const regexPattern = includePattern
        .replace(/[.+^${}()|[\]\\]/g, "\\$&") // Escape special regex chars
        .replace(/\*\*/g, "###DOUBLESTAR###") // Temporarily replace **
        .replace(/\*/g, "[^/]*") // * becomes [^/]* (no directory separators)
        .replace(/###DOUBLESTAR###/g, ".*") // ** becomes .* (any characters)
        .replace(/\?/g, "[^/]"); // ? becomes [^/] (single char, no dir sep)
    const regex = new RegExp(`^${regexPattern}$`);
    return regex.test(filePath);
}
/**
 * Check if a file should be skipped based on common patterns
 */
function shouldSkipFile(filePath) {
    const skipPatterns = [
        /node_modules/,
        /\.git/,
        /\.vscode/,
        /dist/,
        /build/,
        /coverage/,
        /\.nyc_output/,
        /\.next/,
        /\.cache/,
        /\.DS_Store/,
        /Thumbs\.db/,
        /\.log$/,
        /\.tmp$/,
        /\.temp$/,
    ];
    return skipPatterns.some((pattern) => pattern.test(filePath));
}
/**
 * Simple check if file is likely a text file
 */
function isTextFile(filePath) {
    const textExtensions = [
        ".js",
        ".ts",
        ".jsx",
        ".tsx",
        ".json",
        ".html",
        ".htm",
        ".css",
        ".scss",
        ".sass",
        ".py",
        ".java",
        ".cpp",
        ".c",
        ".h",
        ".hpp",
        ".cs",
        ".php",
        ".rb",
        ".go",
        ".rs",
        ".swift",
        ".kt",
        ".scala",
        ".clj",
        ".hs",
        ".elm",
        ".ml",
        ".f",
        ".txt",
        ".md",
        ".rst",
        ".asciidoc",
        ".xml",
        ".yaml",
        ".yml",
        ".toml",
        ".ini",
        ".cfg",
        ".conf",
        ".properties",
        ".env",
        ".gitignore",
        ".gitattributes",
        ".dockerfile",
        ".makefile",
        ".sh",
        ".bat",
        ".ps1",
        ".sql",
        ".graphql",
        ".vue",
        ".svelte",
        ".astro",
        ".prisma",
        ".proto",
    ];
    const ext = path.extname(filePath).toLowerCase();
    return textExtensions.includes(ext) || !ext; // Include extensionless files
}
/**
 * Recursively find files to search
 */
async function findFilesToSearch(context, dirPath, includePattern, maxFiles = 1000) {
    const files = [];
    const scanDirectory = async (currentPath) => {
        if (files.length >= maxFiles) {
            return;
        }
        try {
            const entries = (await context.fsOperator.readdir(currentPath, {
                withFileTypes: true,
            }));
            for (const entry of entries) {
                if (files.length >= maxFiles) {
                    break;
                }
                const fullPath = path.join(currentPath, entry.name.toString());
                const relativePath = path.relative(dirPath, fullPath);
                // Skip common directories and files
                if (shouldSkipFile(relativePath)) {
                    continue;
                }
                if (entry.isDirectory()) {
                    await scanDirectory(fullPath);
                }
                else if (entry.isFile()) {
                    // Check if file matches include pattern
                    if (matchesIncludePattern(relativePath, includePattern)) {
                        // Only include text files (basic check)
                        if (isTextFile(fullPath)) {
                            files.push(fullPath);
                        }
                    }
                }
            }
        }
        catch (error) {
            // Ignore permission errors and continue
        }
    };
    await scanDirectory(dirPath);
    return files;
}
/**
 * Search for pattern in a single file
 */
async function searchInFile(context, filePath, regex, maxMatches) {
    const matches = [];
    try {
        const content = (await context.fsOperator.readFile(filePath, "utf8")).toString();
        const lines = content.split(/\r?\n/);
        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
            if (matches.length >= maxMatches) {
                break;
            }
            const line = lines[lineIndex];
            let match;
            regex.lastIndex = 0; // Reset regex state
            while ((match = regex.exec(line)) !== null) {
                matches.push({
                    filePath,
                    lineNumber: lineIndex + 1,
                    line: line,
                    matchStart: match.index,
                    matchEnd: match.index + match[0].length,
                });
                if (matches.length >= maxMatches) {
                    break;
                }
                // Prevent infinite loop on zero-length matches
                if (match.index === regex.lastIndex) {
                    regex.lastIndex++;
                }
            }
        }
    }
    catch (error) {
        // Ignore files that can't be read (binary files, permission issues, etc.)
    }
    return matches;
}
function createGrepTool(context) {
    return (0, utils_2.tool)(async (params) => {
        try {
            const { pattern, path: searchPath = ".", include, case_sensitive = false, max_files = 1000, max_matches = 100, } = params;
            // Pattern validation (test if it's a valid regex)
            try {
                new RegExp(pattern);
            }
            catch (error) {
                return (0, utils_2.handleToolError)(`Invalid regular expression pattern: ${error instanceof Error ? error.message : String(error)}`, "Pattern validation", "validation");
            }
            // Validate workspace path (handles both absolute and relative paths)
            const pathError = (0, utils_1.validateWorkspacePath)(searchPath, context);
            if (pathError) {
                return pathError;
            }
            // Resolve search path
            const absolutePath = (0, utils_1.resolveWorkspacePath)(searchPath, context);
            // Check if path exists
            try {
                await context.fsOperator.stat(absolutePath);
            }
            catch (error) {
                return (0, utils_2.handleToolError)(`Path does not exist: ${searchPath}`, "Path validation", "validation");
            }
            // Create regex pattern
            const regexFlags = case_sensitive ? "g" : "gi";
            const regex = new RegExp(pattern, regexFlags);
            // Check if path is a file or directory
            const stats = await context.fsOperator.stat(absolutePath);
            const isFile = stats.isFile();
            const isDirectory = stats.isDirectory();
            let filesToSearch = [];
            if (isFile) {
                // Single file search
                if (shouldSkipFile(absolutePath)) {
                    return (0, utils_1.createSuccessResponse)({
                        pattern,
                        search_path: searchPath,
                        include_pattern: include,
                        files_searched: 0,
                        matches: [],
                        total_matches: 0,
                        message: `File ${searchPath} is in skip list (e.g., node_modules, .git, etc.)`,
                    });
                }
                if (!isTextFile(absolutePath)) {
                    return (0, utils_1.createSuccessResponse)({
                        pattern,
                        search_path: searchPath,
                        include_pattern: include,
                        files_searched: 0,
                        matches: [],
                        total_matches: 0,
                        message: `File ${searchPath} is not a text file`,
                    });
                }
                // Check if file matches include pattern (if specified)
                if (include && !matchesIncludePattern(searchPath, include)) {
                    return (0, utils_1.createSuccessResponse)({
                        pattern,
                        search_path: searchPath,
                        include_pattern: include,
                        files_searched: 0,
                        matches: [],
                        total_matches: 0,
                        message: `File ${searchPath} does not match include pattern ${include}`,
                    });
                }
                filesToSearch = [absolutePath];
            }
            else if (isDirectory) {
                // Directory search (existing logic)
                filesToSearch = await findFilesToSearch(context, absolutePath, include, max_files);
                if (filesToSearch.length === 0) {
                    const message = `No files found to search in ${searchPath}${include ? ` matching ${include}` : ""}`;
                    return (0, utils_1.createSuccessResponse)({
                        pattern,
                        search_path: searchPath,
                        include_pattern: include,
                        files_searched: 0,
                        matches: [],
                        total_matches: 0,
                        message,
                    });
                }
            }
            else {
                return (0, utils_2.handleToolError)(`Path is neither a file nor a directory: ${searchPath}`, "Path validation", "validation");
            }
            // Search in files
            const allMatches = [];
            let filesSearched = 0;
            let filesWithMatches = 0;
            for (const file of filesToSearch) {
                if (allMatches.length >= max_matches) {
                    break;
                }
                const fileMatches = await searchInFile(context, file, regex, max_matches - allMatches.length);
                if (fileMatches.length > 0) {
                    // Convert absolute paths to relative paths for output
                    let relativePath;
                    if (isFile) {
                        // For single file search, use the original search path
                        relativePath = searchPath;
                    }
                    else {
                        // For directory search, use relative path from the search directory
                        relativePath = path.relative(absolutePath, file);
                    }
                    fileMatches.forEach((match) => {
                        match.filePath = relativePath;
                    });
                    allMatches.push(...fileMatches);
                    filesWithMatches++;
                }
                filesSearched++;
            }
            // Format results
            let summary = `Found ${allMatches.length} match(es) for "${pattern}" in ${filesWithMatches} file(s)`;
            if (filesSearched < filesToSearch.length) {
                summary += ` (searched ${filesSearched}/${filesToSearch.length} files)`;
            }
            // Group matches by file for better readability
            const matchesByFile = {};
            allMatches.forEach((match) => {
                if (!matchesByFile[match.filePath]) {
                    matchesByFile[match.filePath] = [];
                }
                matchesByFile[match.filePath].push(match);
            });
            return (0, utils_1.createSuccessResponse)({
                pattern,
                search_path: searchPath,
                include_pattern: include,
                files_searched: filesSearched,
                files_with_matches: filesWithMatches,
                matches: allMatches,
                matches_by_file: matchesByFile,
                total_matches: allMatches.length,
                summary,
                truncated: allMatches.length >= max_matches,
            });
        }
        catch (error) {
            return (0, utils_2.handleToolError)(error, "Grep tool execution", "execution");
        }
    }, {
        name: "Grep",
        description: '\n- Fast content search tool that works with any codebase size\n- Searches file or directory contents using regular expressions\n- Supports both single file and directory (recursive) search\n- Supports full regex syntax (eg. "log.*Error", "function\\s+\\w+", etc.)\n- Filter files by pattern with the include parameter (eg. "*.js", "*.{ts,tsx}")\n- Returns file paths with at least one match sorted by modification time\n- Use this tool when you need to find files containing specific patterns\n',
        schema: grepParametersSchema,
        getDisplay: ({ name, input }) => {
            return `Using ${name} for tool call: ${input.pattern || ""}`;
        },
    });
}
//# sourceMappingURL=grep-tool.js.map