{"version":3,"sources":["../src/store/tdai.ts","../src/tool.ts","../src/agent.ts","../src/chat_history.ts"],"sourcesContent":["import { MemoryClient } from \"@cloudbase/agent-agents\";\nimport { BaseStore } from \"@langchain/core/stores\";\n\n/**\n * Configuration options for TDAIStore\n */\nexport interface TDAIStoreInput {\n  /**\n   * The TDAI Memory Client instance\n   */\n  client: MemoryClient;\n\n  /**\n   * The amount of keys to retrieve per batch when yielding keys.\n   * @default 1000\n   */\n  yieldKeysScanBatchSize?: number;\n\n  /**\n   * The namespace to use for the keys in the database.\n   */\n  namespace?: string;\n\n  /**\n   * Default session ID for storing records\n   */\n  defaultSessionId?: string;\n\n  /**\n   * Default strategy for storing records\n   */\n  defaultStrategy?: string;\n\n  /**\n   * TTL for records in seconds\n   */\n  ttlSeconds?: number;\n}\n\n/**\n * TDAI implementation of the BaseStore for key-value caching.\n * Uses TDAI Memory Client for persistent storage.\n *\n * @example\n * ```typescript\n * const client = new MemoryClient({\n *   endpoint: \"https://memory.tdai.tencentyun.com\",\n *   apiKey: \"your-api-key\",\n *   memoryId: \"your-memory-id\",\n * });\n *\n * const store = new TDAIStore({\n *   client,\n *   namespace: \"cache\",\n * });\n *\n * const encoder = new TextEncoder();\n * await store.mset([\n *   [\"key1\", encoder.encode(\"value1\")],\n *   [\"key2\", encoder.encode(\"value2\")],\n * ]);\n *\n * const values = await store.mget([\"key1\", \"key2\"]);\n * ```\n */\nexport class TDAIStore extends BaseStore<string, Uint8Array> {\n  lc_namespace = [\"langchain\", \"storage\", \"tdai\"];\n\n  protected client: MemoryClient;\n  protected namespace?: string;\n  protected yieldKeysScanBatchSize = 1000;\n  protected defaultSessionId: string;\n  protected defaultStrategy: string;\n  protected ttlSeconds?: number;\n  private sessionCache?: string;\n\n  constructor(fields: TDAIStoreInput) {\n    super();\n    this.client = fields.client;\n    this.namespace = fields.namespace;\n    this.yieldKeysScanBatchSize =\n      fields.yieldKeysScanBatchSize ?? this.yieldKeysScanBatchSize;\n    this.defaultSessionId =\n      fields.defaultSessionId ?? \"langchain_store_session\";\n    this.defaultStrategy = fields.defaultStrategy ?? \"kv_cache\";\n    this.ttlSeconds = fields.ttlSeconds;\n  }\n\n  /**\n   * Get prefixed key with namespace\n   */\n  private _getPrefixedKey(key: string): string {\n    if (this.namespace) {\n      const delimiter = \"/\";\n      return `${this.namespace}${delimiter}${key}`;\n    }\n    return key;\n  }\n\n  /**\n   * Remove prefix from key\n   */\n  private _getDeprefixedKey(key: string): string {\n    if (this.namespace) {\n      const delimiter = \"/\";\n      return key.slice(this.namespace.length + delimiter.length);\n    }\n    return key;\n  }\n\n  /**\n   * Get or create session for the store\n   */\n  private async _getSession(): Promise<string> {\n    if (this.sessionCache) {\n      return this.sessionCache;\n    }\n\n    try {\n      // Try to find existing session\n      const sessions = await this.client.querySessions({\n        limit: 1,\n      });\n\n      if (sessions.sessions && sessions.sessions.length > 0) {\n        this.sessionCache = sessions.sessions[0].sessionId;\n      } else {\n        // Create new session\n        const result = await this.client.createSession({\n          name: `langchain_store_${this.namespace || \"default\"}`,\n        });\n        this.sessionCache = result.sessionId;\n      }\n\n      return this.sessionCache!;\n    } catch (error) {\n      // Fallback to default session\n      return this.defaultSessionId;\n    }\n  }\n\n  /**\n   * Create record content for storage\n   */\n  private _createRecordContent(key: string, value: Uint8Array): string {\n    const decoder = new TextDecoder();\n    const content = {\n      key: this._getPrefixedKey(key),\n      value: decoder.decode(value),\n      timestamp: Date.now(),\n      ttl: this.ttlSeconds,\n    };\n    return JSON.stringify(content);\n  }\n\n  /**\n   * Parse record content from storage\n   */\n  private _parseRecordContent(\n    content: string\n  ): {\n    key: string;\n    value: Uint8Array;\n    timestamp: number;\n    ttl?: number;\n  } | null {\n    try {\n      const data = JSON.parse(content);\n      const encoder = new TextEncoder();\n\n      // Check TTL if present\n      if (data.ttl && data.timestamp) {\n        const now = Date.now();\n        if (now > data.timestamp + data.ttl * 1000) {\n          return null; // Expired\n        }\n      }\n\n      return {\n        key: data.key,\n        value: encoder.encode(data.value),\n        timestamp: data.timestamp,\n        ttl: data.ttl,\n      };\n    } catch (error) {\n      return null;\n    }\n  }\n\n  /**\n   * Gets multiple keys from the TDAI store.\n   * @param keys Array of keys to be retrieved.\n   * @returns An array of retrieved values.\n   */\n  async mget(keys: string[]): Promise<(Uint8Array | undefined)[]> {\n    if (keys.length === 0) {\n      return [];\n    }\n\n    try {\n      const sessionId = await this._getSession();\n      const results: (Uint8Array | undefined)[] = new Array(keys.length);\n\n      // Search for each key individually due to TDAI API limitations\n      for (let i = 0; i < keys.length; i++) {\n        const prefixedKey = this._getPrefixedKey(keys[i]);\n\n        try {\n          const searchResult = await this.client.searchRecords({\n            content: prefixedKey,\n            sessionId,\n            strategies: [this.defaultStrategy],\n            limit: 1,\n          });\n\n          if (searchResult.records && searchResult.records.length > 0) {\n            const record = searchResult.records[0];\n            const parsed = this._parseRecordContent(record.record_content);\n\n            if (parsed && parsed.key === prefixedKey) {\n              results[i] = parsed.value;\n            } else {\n              results[i] = undefined;\n            }\n          } else {\n            results[i] = undefined;\n          }\n        } catch (error) {\n          results[i] = undefined;\n        }\n      }\n\n      return results;\n    } catch (error) {\n      // Return array of undefined values on error\n      return new Array(keys.length).fill(undefined);\n    }\n  }\n\n  /**\n   * Sets multiple keys in the TDAI store.\n   * @param keyValuePairs Array of key-value pairs to be set.\n   * @returns Promise that resolves when all keys have been set.\n   */\n  async mset(keyValuePairs: [string, Uint8Array][]): Promise<void> {\n    if (keyValuePairs.length === 0) {\n      return;\n    }\n\n    try {\n      const sessionId = await this._getSession();\n\n      // Set each key-value pair\n      for (const [key, value] of keyValuePairs) {\n        const content = this._createRecordContent(key, value);\n\n        try {\n          await this.client.appendRecord({\n            sessionId,\n            content,\n            strategy: this.defaultStrategy,\n          });\n        } catch (error) {\n          console.warn(`Failed to set key ${key}:`, error);\n        }\n      }\n    } catch (error) {\n      throw new Error(`Failed to set keys: ${error}`);\n    }\n  }\n\n  /**\n   * Deletes multiple keys from the TDAI store.\n   * @param keys Array of keys to be deleted.\n   * @returns Promise that resolves when all keys have been deleted.\n   */\n  async mdelete(keys: string[]): Promise<void> {\n    if (keys.length === 0) {\n      return;\n    }\n\n    try {\n      const sessionId = await this._getSession();\n\n      // Delete each key individually\n      for (const key of keys) {\n        const prefixedKey = this._getPrefixedKey(key);\n\n        try {\n          // First find the record\n          const searchResult = await this.client.searchRecords({\n            content: prefixedKey,\n            sessionId,\n            strategies: [this.defaultStrategy],\n            limit: 1,\n          });\n\n          if (searchResult.records && searchResult.records.length > 0) {\n            const record = searchResult.records[0];\n            await this.client.deleteRecord({\n              sessionId,\n              recordId: record.record_id,\n            });\n          }\n        } catch (error) {\n          console.warn(`Failed to delete key ${key}:`, error);\n        }\n      }\n    } catch (error) {\n      throw new Error(`Failed to delete keys: ${error}`);\n    }\n  }\n\n  /**\n   * Yields keys from the TDAI store.\n   * @param prefix Optional prefix to filter the keys.\n   * @returns An AsyncGenerator that yields keys from the TDAI store.\n   */\n  async *yieldKeys(prefix?: string): AsyncGenerator<string> {\n    try {\n      const sessionId = await this._getSession();\n      let offset = 0;\n      let hasMore = true;\n\n      while (hasMore) {\n        try {\n          const result = await this.client.queryRecords({\n            sessionId,\n            strategies: [this.defaultStrategy],\n            limit: this.yieldKeysScanBatchSize,\n            offset,\n          });\n\n          if (!result.records || result.records.length === 0) {\n            hasMore = false;\n            break;\n          }\n\n          for (const record of result.records) {\n            const parsed = this._parseRecordContent(record.record_content);\n            if (parsed) {\n              const deprefixedKey = this._getDeprefixedKey(parsed.key);\n\n              if (!prefix || deprefixedKey.startsWith(prefix)) {\n                yield deprefixedKey;\n              }\n            }\n          }\n\n          offset += result.records.length;\n\n          // If we got fewer records than requested, we've reached the end\n          if (result.records.length < this.yieldKeysScanBatchSize) {\n            hasMore = false;\n          }\n        } catch (error) {\n          console.warn(`Error yielding keys at offset ${offset}:`, error);\n          hasMore = false;\n        }\n      }\n    } catch (error) {\n      console.warn(\"Error yielding keys:\", error);\n    }\n  }\n\n  /**\n   * Close the TDAI client connection\n   */\n  close(): void {\n    this.client.close();\n  }\n}\n\n","/**\n * AG-Kit BaseTool to LangChain Tool Converter and Vice Versa\n */\nimport { tool as langChainTool, StructuredTool } from \"@langchain/core/tools\";\nimport {\n  BaseTool,\n  tool as agKitTool,\n  ToolResult,\n  ToolExecutionContext,\n} from \"@cloudbase/agent-tools\";\nimport { z } from \"zod/v4\";\n\n/**\n * Convert AG-Kit BaseTool to LangChain DynamicStructuredTool\n *\n * @param agkitTool - AG-Kit BaseTool instance\n * @param implFunc - Optional custom implementation function\n * @returns LangChain DynamicStructuredTool instance\n */\nexport function convert2LangChain(\n  agkitTool: BaseTool,\n  implFunc?: (tool: BaseTool) => Function\n) {\n  const func =\n    implFunc ||\n    (async (input: any) => {\n      const result = await agkitTool.invoke(input);\n      return result;\n    });\n\n  return langChainTool(func as any, {\n    name: agkitTool.name,\n    description: agkitTool.description || agkitTool.name,\n    schema: (agkitTool as any).schema || z.object({}),\n  });\n}\n\n/**\n * Convert LangChain Tool to AG-Kit DynamicTool\n *\n * @param langchainTool - LangChain tool instance (DynamicStructuredTool or StructuredTool)\n * @returns AG-Kit DynamicTool instance\n */\nexport function convertLangChain2AGKit(langchainTool: StructuredTool) {\n  const func: any = async (\n    input: Record<string, any>,\n    context?: ToolExecutionContext\n  ) => {\n    try {\n      // Call the LangChain tool\n      const result = await langchainTool.invoke(input);\n\n      // Return successful result\n      return new ToolResult({\n        success: true,\n        data: result,\n      });\n    } catch (error) {\n      // Handle errors and return ToolResult with error\n      return new ToolResult({\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        error_type: \"execution\",\n      });\n    }\n  };\n\n  return agKitTool(func, {\n    name: langchainTool.name,\n    description: langchainTool.description || langchainTool.name,\n    schema: (langchainTool as any).schema || (z.object({}) as z.ZodObject<any>),\n  });\n}\n\n","import { z } from \"zod/v3\";\nimport { AgentConfig } from \"@ag-ui/client\";\nimport { LanggraphAgent } from \"@cloudbase/agent-adapter-langgraph\";\nimport { createAgent, createMiddleware, DynamicTool } from \"langchain\";\nimport { AIMessage } from \"@langchain/core/messages\";\nimport { END } from \"@langchain/langgraph\";\n\nexport class LangchainAgent extends LanggraphAgent {\n  constructor(\n    config: AgentConfig & {\n      agent: ReturnType<typeof createAgent>;\n    }\n  ) {\n    super({\n      ...config,\n      compiledWorkflow: config.agent,\n      adapterName: \"LangChain\",\n    } as any);\n  }\n}\n\nexport function clientTools() {\n  // @ts-expect-error - TypeScript type instantiation too deep with createMiddleware generics\n  return createMiddleware({\n    name: \"ClientTools\",\n    stateSchema: z.object({\n      client: z.object({\n        tools: z.array(\n          z.object({\n            name: z.string(),\n            description: z.string(),\n            schema: z.any(),\n          })\n        ),\n      }),\n    }),\n\n    // Add frontend tools to LLM's tool list\n    wrapModelCall: (request, handler) => {\n      const clientToolsList = (\n        (request.state.client?.tools || []) as DynamicTool[]\n      ).map((tool) => {\n        const { name, description, schema } = tool;\n        return { name, description, schema };\n      });\n\n      return handler({\n        ...request,\n        tools: [...(request.tools || []), ...clientToolsList],\n      });\n    },\n\n    // After model: check if all tool calls are frontend actions\n    // If so, skip ToolNode by jumping to END\n    // Note: #createAfterModelRouter does direct comparison (jumpTo === END),\n    // NOT using parseJumpToTarget(), so we must use the actual END constant.\n    // Using \"as any\" to bypass TypeScript type mismatch (bug in langchain types).\n    afterModel: {\n      canJumpTo: [END as any],\n      hook: (state) => {\n        const messages = state.messages || [];\n        const lastMessage = messages.at(-1);\n\n        // Check if last message is AIMessage with tool calls\n        if (!AIMessage.isInstance(lastMessage)) return;\n        if (!lastMessage.tool_calls || lastMessage.tool_calls.length === 0)\n          return;\n\n        // Get frontend tool names\n        const clientToolNames = new Set(\n          ((state.client?.tools || []) as DynamicTool[]).map((t) => t.name)\n        );\n\n        // If no frontend tools defined, let it go to ToolNode normally\n        if (clientToolNames.size === 0) return;\n\n        // Check if ANY tool call is a frontend action\n        const anyClientTool = lastMessage.tool_calls.some((call) =>\n          clientToolNames.has(call.name)\n        );\n\n        if (anyClientTool) {\n          // Has frontend action, skip ToolNode and let frontend handle it\n          return { jumpTo: END as any };\n        }\n\n        // All are server-side tools, let ToolNode handle them\n        return;\n      },\n    },\n  });\n}\n","import { BaseListChatMessageHistory } from \"@langchain/core/chat_history\";\nimport {\n  BaseMessage,\n  mapStoredMessagesToChatMessages,\n  mapChatMessagesToStoredMessages,\n  StoredMessage,\n} from \"@langchain/core/messages\";\nimport { IMemoryClientOptions, MemoryClient } from \"@cloudbase/agent-agents\";\n\nexport class TDAIChatHistory extends BaseListChatMessageHistory {\n  lc_namespace = [\"langchain\", \"stores\", \"message\", \"tdai\"];\n\n  public client: MemoryClient;\n\n  private sessionId: string;\n\n  constructor(options: IMemoryClientOptions & { sessionId: string }) {\n    super();\n    const { sessionId, ...clientOptions } = options;\n    this.client = new MemoryClient({\n      ...clientOptions,\n    });\n    this.sessionId = options.sessionId;\n  }\n\n  async getMessages(): Promise<BaseMessage[]> {\n    const { events = [] } = await this.client.queryEvents({\n      sessionId: this.sessionId,\n    });\n\n    return mapStoredMessagesToChatMessages(\n      events.map((event) => {\n        return {\n          type: event.type,\n          data: event.data,\n        };\n      })\n    );\n  }\n\n  /**\n   * Method to add a new message to the Firestore collection. The message is\n   * passed as a BaseMessage object.\n   * @param message The message to be added as a BaseMessage object.\n   */\n  public async addMessage(message: BaseMessage) {\n    const messages = mapChatMessagesToStoredMessages([message]);\n    await this.appendMessage(messages[0]);\n  }\n\n  private async appendMessage(message: StoredMessage): Promise<void> {\n    await this.client.appendEvent({\n      sessionId: this.sessionId,\n      messages: message,\n    });\n  }\n\n  /**\n   * Method to delete all messages from the Firestore collection associated\n   * with the current session.\n   */\n  public async clear(): Promise<void> {\n    const eventIds = await this.client\n      .queryEvents({\n        sessionId: this.sessionId,\n      })\n      .then(({ events = [] }) => events.map((event: any) => event.event_id));\n\n    await Promise.all(\n      eventIds.map((id: string) => {\n        return this.client.deleteEvent({\n          sessionId: this.sessionId,\n          eventId: id,\n        });\n      })\n    );\n\n    await this.client.deleteSession({\n      sessionId: this.sessionId,\n    });\n  }\n}\n\n"],"mappings":"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","names":["z"]}