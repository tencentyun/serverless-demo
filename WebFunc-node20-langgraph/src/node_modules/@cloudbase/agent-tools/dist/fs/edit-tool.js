"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.editParametersSchema = void 0;
exports.editFile = editFile;
exports.createEditTool = createEditTool;
const v4_1 = require("zod/v4");
const path = __importStar(require("path"));
const utils_1 = require("./utils");
const utils_2 = require("../utils");
exports.editParametersSchema = v4_1.z.object({
    file_path: v4_1.z.string().describe("The absolute path to the file to modify"),
    old_string: v4_1.z
        .string()
        .describe("The exact text to find and replace. Must match exactly including whitespace, indentation, and context. For single replacements, include 2+ lines of context before and after the target text."),
    new_string: v4_1.z
        .string()
        .describe("The text to replace it with (must be different from old_string)"),
    expected_replacements: v4_1.z
        .number()
        .min(1)
        .optional()
        .describe("The expected number of replacements to perform. Defaults to 1 if not specified."),
});
// Path validation is now handled by validateWorkspacePath in tool-utils
/**
 * Escape special regex characters
 */
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
/**
 * Calculate the edit operation without executing it
 */
async function calculateEdit(file_path, old_string, new_string, expected_replacements, context) {
    // Use the utility function to resolve paths
    const absolutePath = (0, utils_1.resolveWorkspacePath)(file_path, context);
    try {
        await context.fsOperator.access(absolutePath);
    }
    catch (e) {
        if (old_string === "") {
            // Creating a new file
            return {
                currentContent: "",
                newContent: new_string,
                occurrences: 1,
                isNewFile: true,
            };
        }
        else {
            return {
                currentContent: "",
                newContent: "",
                occurrences: 0,
                isNewFile: false,
                error: `File not found: ${file_path}. Cannot apply edit. Use empty old_string to create a new file.`,
            };
        }
    }
    // Read current content
    let currentContent;
    try {
        currentContent = await context.fsOperator.readFile(absolutePath, "utf8");
        // Normalize line endings to LF
        currentContent = currentContent.replace(/\r\n/g, "\n");
    }
    catch (error) {
        return {
            currentContent: "",
            newContent: "",
            occurrences: 0,
            isNewFile: false,
            error: `Failed to read file: ${error instanceof Error ? error.message : String(error)}`,
        };
    }
    // Handle creating file that already exists
    if (old_string === "") {
        return {
            currentContent,
            newContent: "",
            occurrences: 0,
            isNewFile: false,
            error: `File already exists, cannot create: ${file_path}`,
        };
    }
    // Count occurrences
    const occurrences = (currentContent.match(new RegExp(escapeRegExp(old_string), "g")) || []).length;
    // Validate occurrence count
    if (occurrences === 0) {
        return {
            currentContent,
            newContent: currentContent,
            occurrences: 0,
            isNewFile: false,
            error: `Text not found in file. 0 occurrences of old_string found. Ensure exact text match including whitespace and indentation.`,
        };
    }
    if (occurrences !== expected_replacements) {
        return {
            currentContent,
            newContent: currentContent,
            occurrences,
            isNewFile: false,
            error: `Expected ${expected_replacements} replacement(s) but found ${occurrences} occurrence(s).`,
        };
    }
    // Apply replacement
    const newContent = currentContent.split(old_string).join(new_string);
    return {
        currentContent,
        newContent,
        occurrences,
        isNewFile: false,
    };
}
async function editFile(context, params) {
    try {
        const { file_path, old_string, new_string, expected_replacements = 1, } = params;
        // Validate workspace path (handles both absolute and relative paths)
        const pathError = (0, utils_1.validateWorkspacePath)(file_path, context);
        if (pathError) {
            return pathError;
        }
        // Calculate the edit
        const editResult = await calculateEdit(file_path, old_string, new_string, expected_replacements, context);
        if (editResult.error) {
            return (0, utils_2.handleToolError)(editResult.error, "Edit operation", "execution");
        }
        const absolutePath = (0, utils_1.resolveWorkspacePath)(file_path, context);
        // Create parent directories if needed (for new files)
        if (editResult.isNewFile) {
            const dirName = path.dirname(absolutePath);
            try {
                await context.fsOperator.access(dirName);
            }
            catch (e) {
                await context.fsOperator.mkdir(dirName, { recursive: true });
                console.log(`Created parent directories for: ${file_path}`);
            }
        }
        // Write the updated content
        await context.fsOperator.writeFile(absolutePath, editResult.newContent);
        const newLines = editResult.newContent.split("\n").length;
        const newSize = Buffer.byteLength(editResult.newContent, "utf8");
        return (0, utils_1.createSuccessResponse)({
            file_path,
            absolute_path: absolutePath,
            is_new_file: editResult.isNewFile,
            replacements_made: editResult.occurrences,
            lines_total: newLines,
            bytes_total: newSize,
            old_string_length: old_string.length,
            new_string_length: new_string.length,
        });
    }
    catch (error) {
        return (0, utils_2.handleToolError)(error, "Edit tool execution", "execution");
    }
}
function createEditTool(context) {
    return (0, utils_2.tool)((params) => editFile(context, params), {
        name: "Edit",
        description: "Performs exact string replacements in files with strict occurrence count validation.\n\nUsage:\n- When editing text from Read tool output, ensure you preserve the exact indentation (tabs/spaces) as it appears AFTER the line number prefix. The line number prefix format is: spaces + line number + tab. Everything after that tab is the actual file content to match. Never include any part of the line number prefix in the old_string or new_string.\n- ALWAYS prefer editing existing files in the codebase. NEVER write new files unless explicitly required.",
        schema: exports.editParametersSchema,
        getDisplay: ({ name, input }) => {
            return `Using ${name} for tool call: ${input.file_path || ""}`;
        },
    });
}
//# sourceMappingURL=edit-tool.js.map