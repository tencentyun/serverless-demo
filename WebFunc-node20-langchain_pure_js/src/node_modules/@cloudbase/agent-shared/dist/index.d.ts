import * as z from 'zod/v4';
import * as z3 from 'zod/v3';
import * as z4 from 'zod/v4/core';

/**
 * Logger interface
 *
 * This follows the "Bring Your Own Logger" (BYOL) pattern:
 * - Users can inject their own logger (Pino, Winston, console, etc.)
 * - All methods are optional - if a method exists, we use it; if not, we skip it
 * - The interface is a "slot" for users to plug in their logger
 *
 * The signature supports two common calling conventions:
 * 1. Printf style (Winston/Console): logger.info("Port %d", 8080)
 * 2. Structured style (Pino): logger.info({ port: 8080 }, "Server started")
 */
/**
 * Log method signature supporting both structured and printf-style logging.
 *
 * @example
 * // Printf style
 * logger.info("Hello %s", "world");
 *
 * // Structured style (Pino-compatible)
 * logger.info({ userId: 123 }, "User logged in");
 *
 * // Simple message
 * logger.info("Server started");
 */
interface LogFn {
    (msg: string, ...args: unknown[]): void;
    (obj: object, msg?: string, ...args: unknown[]): void;
}
/**
 * Logger interface - a minimal "slot" for users to plug in their logger.
 *
 * All methods are optional. If a method exists on the user's logger, we use it;
 * if not, we simply skip it. This allows maximum compatibility with any logger.
 *
 * Compatible with: Pino, Winston, Bunyan, console, or any custom logger.
 *
 * @example
 * // Inject Pino
 * import pino from 'pino';
 * createExpressServer({ createAgent, logger: pino() });
 *
 * // Inject Winston
 * import winston from 'winston';
 * createExpressServer({ createAgent, logger: winston.createLogger() });
 *
 * // Inject console (for development)
 * createExpressServer({ createAgent, logger: console });
 */
interface Logger {
    /**
     * Fatal level - system is unusable, immediate action required.
     * Use for: unrecoverable errors, process about to crash.
     */
    fatal?: LogFn;
    /**
     * Error level - failures requiring attention.
     * Use for: 5xx errors, unhandled exceptions, critical failures.
     */
    error?: LogFn;
    /**
     * Warn level - recoverable issues, deprecation notices.
     * Use for: 4xx errors, missing config with fallback, retry attempts.
     */
    warn?: LogFn;
    /**
     * Info level - key lifecycle events (production default).
     * Use for: server started, client connected, request completed.
     */
    info?: LogFn;
    /**
     * Debug level - diagnostic information for logic flow.
     * Use for: request received, state changes, configuration loaded.
     */
    debug?: LogFn;
    /**
     * Trace level - extremely verbose, for library internals debugging.
     * Use for: raw bytes, loop iterations, function entry/exit.
     */
    trace?: LogFn;
    /**
     * Creates a child logger with additional context.
     * The child inherits all parent context and adds its own.
     *
     * @example
     * const requestLogger = logger.child({ requestId: 'req-123' });
     * requestLogger.info("Processing request"); // includes requestId in output
     */
    child?(bindings: Record<string, unknown>): Logger;
}
/**
 * No-op logger implementation (Abstract Logging pattern).
 *
 * This is the default logger - it does nothing.
 * This ensures:
 * 1. The library is silent by default (respects user's console)
 * 2. No performance overhead from console.log in production
 * 3. No need for `if (logger)` checks throughout the code
 *
 * @example
 * // Default: silent
 * createExpressServer({ createAgent });
 *
 * // Development: see logs
 * createExpressServer({ createAgent, logger: console });
 *
 * // Production: structured JSON logs
 * import pino from 'pino';
 * createExpressServer({ createAgent, logger: pino() });
 */
declare const noopLogger: Logger;
/**
 * Creates a console-based logger that wraps console methods.
 * Useful for development when you want simple console output.
 *
 * Note: console.log is synchronous and blocking - avoid in high-throughput production.
 *
 * @example
 * createExpressServer({ createAgent, logger: createConsoleLogger() });
 */
declare function createConsoleLogger(): Logger;

/**
 * Type guard to check if an error has a code property.
 */
declare function isErrorWithCode(error: unknown): error is Error & {
    code: string;
};

type Schema = z3.ZodTypeAny | z4.$ZodType;
type ZodInfer<T> = T extends z3.ZodTypeAny ? z3.infer<T> : z4.infer<T>;
declare function isV4Schema(schema: Schema): schema is z4.$ZodType;
declare const systemMessageSchema: z.ZodObject<{
    role: z.ZodLiteral<"system">;
    content: z.ZodString;
}, z.core.$strip>;
declare const userMessageSchema: z.ZodObject<{
    role: z.ZodLiteral<"user">;
    content: z.ZodString;
}, z.core.$strip>;
declare const toolMessageSchema: z.ZodObject<{
    role: z.ZodLiteral<"tool">;
    content: z.ZodString;
    toolCallId: z.ZodString;
}, z.core.$strip>;
declare const assistantMessageSchema: z.ZodObject<{
    role: z.ZodLiteral<"assistant">;
    content: z.ZodOptional<z.ZodString>;
    toolCalls: z.ZodOptional<z.ZodArray<z.ZodObject<{
        id: z.ZodString;
        type: z.ZodLiteral<"function">;
        function: z.ZodObject<{
            name: z.ZodString;
            arguments: z.ZodString;
        }, z.core.$strip>;
    }, z.core.$strip>>>;
}, z.core.$strip>;
declare const clientMessageSchema: z.ZodUnion<readonly [z.ZodObject<{
    role: z.ZodLiteral<"system">;
    content: z.ZodString;
}, z.core.$strip>, z.ZodObject<{
    role: z.ZodLiteral<"user">;
    content: z.ZodString;
}, z.core.$strip>, z.ZodObject<{
    role: z.ZodLiteral<"tool">;
    content: z.ZodString;
    toolCallId: z.ZodString;
}, z.core.$strip>, z.ZodObject<{
    role: z.ZodLiteral<"assistant">;
    content: z.ZodOptional<z.ZodString>;
    toolCalls: z.ZodOptional<z.ZodArray<z.ZodObject<{
        id: z.ZodString;
        type: z.ZodLiteral<"function">;
        function: z.ZodObject<{
            name: z.ZodString;
            arguments: z.ZodString;
        }, z.core.$strip>;
    }, z.core.$strip>>>;
}, z.core.$strip>]>;
declare const toolSchema: z.ZodObject<{
    name: z.ZodString;
    description: z.ZodString;
    parameters: z.ZodAny;
}, z.core.$strip>;
declare const sendMessageInputSchema: z.ZodObject<{
    conversationId: z.ZodString;
    messages: z.ZodOptional<z.ZodArray<z.ZodUnion<readonly [z.ZodObject<{
        role: z.ZodLiteral<"system">;
        content: z.ZodString;
    }, z.core.$strip>, z.ZodObject<{
        role: z.ZodLiteral<"user">;
        content: z.ZodString;
    }, z.core.$strip>, z.ZodObject<{
        role: z.ZodLiteral<"tool">;
        content: z.ZodString;
        toolCallId: z.ZodString;
    }, z.core.$strip>, z.ZodObject<{
        role: z.ZodLiteral<"assistant">;
        content: z.ZodOptional<z.ZodString>;
        toolCalls: z.ZodOptional<z.ZodArray<z.ZodObject<{
            id: z.ZodString;
            type: z.ZodLiteral<"function">;
            function: z.ZodObject<{
                name: z.ZodString;
                arguments: z.ZodString;
            }, z.core.$strip>;
        }, z.core.$strip>>>;
    }, z.core.$strip>]>>>;
    resume: z.ZodOptional<z.ZodObject<{
        interruptId: z.ZodString;
        payload: z.ZodAny;
    }, z.core.$strip>>;
    tools: z.ZodOptional<z.ZodArray<z.ZodObject<{
        name: z.ZodString;
        description: z.ZodString;
        parameters: z.ZodAny;
    }, z.core.$strip>>>;
}, z.core.$strip>;
declare const sendMessageEventSchema: z.ZodUnion<readonly [z.ZodObject<{
    type: z.ZodLiteral<"text">;
    content: z.ZodString;
}, z.core.$strip>, z.ZodObject<{
    type: z.ZodLiteral<"tool-call-start">;
    toolCallId: z.ZodString;
    toolCallName: z.ZodString;
}, z.core.$strip>, z.ZodObject<{
    type: z.ZodLiteral<"tool-call-args">;
    toolCallId: z.ZodString;
    delta: z.ZodString;
}, z.core.$strip>, z.ZodObject<{
    type: z.ZodLiteral<"tool-call-end">;
    toolCallId: z.ZodString;
}, z.core.$strip>, z.ZodObject<{
    type: z.ZodLiteral<"tool-result">;
    toolCallId: z.ZodString;
    result: z.ZodString;
}, z.core.$strip>, z.ZodObject<{
    type: z.ZodLiteral<"interrupt">;
    id: z.ZodString;
    reason: z.ZodString;
    payload: z.ZodAny;
}, z.core.$strip>]>;
type SendMessageInput = z.infer<typeof sendMessageInputSchema>;
type ClientMessage = z.infer<typeof clientMessageSchema>;
type SystemMessage = z.infer<typeof systemMessageSchema>;
type UserMessage = z.infer<typeof userMessageSchema>;
type ToolMessage = z.infer<typeof toolMessageSchema>;
type AssistantMessage = z.infer<typeof assistantMessageSchema>;
type Tool = z.infer<typeof toolSchema>;
type SendMessageEvent = z.infer<typeof sendMessageEventSchema>;

export { type AssistantMessage, type ClientMessage, type LogFn, type Logger, type Schema, type SendMessageEvent, type SendMessageInput, type SystemMessage, type Tool, type ToolMessage, type UserMessage, type ZodInfer, assistantMessageSchema, clientMessageSchema, createConsoleLogger, isErrorWithCode, isV4Schema, noopLogger, sendMessageEventSchema, sendMessageInputSchema, systemMessageSchema, toolMessageSchema, toolSchema, userMessageSchema };
