{"version":3,"file":"zod.js","names":["schema: unknown","schema: z3.ZodType<RunOutput> | Record<string, unknown>","input: unknown","obj: unknown","schema: InteropZodType<T>","schema: InteropZodType<unknown> | Record<string, unknown>","schema: T","extension: InteropZodObjectShape","outputShape: Mutable<z4.$ZodShape>","meta","schema: InteropZodType","recursive: boolean","cache: WeakMap<InteropZodType, InteropZodType>","outputSchema: InteropZodType","predicate: (key: string, value: InteropZodType) => boolean","modifiedShape: Record<string, z3.ZodTypeAny>","e: unknown"],"sources":["../../../src/utils/types/zod.ts"],"sourcesContent":["import type * as z3 from \"zod/v3\";\nimport type * as z4 from \"zod/v4/core\";\nimport {\n  parse,\n  parseAsync,\n  globalRegistry,\n  util,\n  clone,\n  _unknown,\n  _never,\n  $ZodUnknown,\n  $ZodNever,\n  $ZodOptional,\n} from \"zod/v4/core\";\n\nexport type ZodStringV3 = z3.ZodString;\n\nexport type ZodStringV4 = z4.$ZodType<string, unknown>;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type ZodObjectV3 = z3.ZodObject<any, any, any, any>;\n\nexport type ZodObjectV4 = z4.$ZodObject;\n\nexport type ZodDefaultV3<T extends z3.ZodTypeAny> = z3.ZodDefault<T>;\nexport type ZodDefaultV4<T extends z4.SomeType> = z4.$ZodDefault<T>;\nexport type ZodOptionalV3<T extends z3.ZodTypeAny> = z3.ZodOptional<T>;\nexport type ZodOptionalV4<T extends z4.SomeType> = z4.$ZodOptional<T>;\nexport type ZodNullableV4<T extends z4.SomeType> = z4.$ZodNullable<T>;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type InteropZodType<Output = any, Input = Output> =\n  | z3.ZodType<Output, z3.ZodTypeDef, Input>\n  | z4.$ZodType<Output, Input>;\n\nexport type InteropZodObject = ZodObjectV3 | ZodObjectV4;\nexport type InteropZodDefault<T = InteropZodObjectShape> =\n  T extends z3.ZodTypeAny\n    ? ZodDefaultV3<T>\n    : T extends z4.SomeType\n    ? ZodDefaultV4<T>\n    : never;\nexport type InteropZodOptional<T = InteropZodObjectShape> =\n  T extends z3.ZodTypeAny\n    ? ZodOptionalV3<T>\n    : T extends z4.SomeType\n    ? ZodOptionalV4<T>\n    : never;\n\nexport type InteropZodObjectShape<\n  T extends InteropZodObject = InteropZodObject\n> = T extends z3.ZodObject<infer Shape>\n  ? { [K in keyof Shape]: Shape[K] }\n  : T extends z4.$ZodObject<infer Shape>\n  ? { [K in keyof Shape]: Shape[K] }\n  : never;\n\nexport type InteropZodIssue = z3.ZodIssue | z4.$ZodIssue;\n\n// Simplified type inference to avoid circular dependencies\nexport type InferInteropZodInput<T> = T extends z3.ZodType<\n  unknown,\n  z3.ZodTypeDef,\n  infer Input\n>\n  ? Input\n  : T extends z4.$ZodType<unknown, infer Input>\n  ? Input\n  : T extends { _zod: { input: infer Input } }\n  ? Input\n  : never;\n\nexport type InferInteropZodOutput<T> = T extends z3.ZodType<\n  infer Output,\n  z3.ZodTypeDef,\n  unknown\n>\n  ? Output\n  : T extends z4.$ZodType<infer Output, unknown>\n  ? Output\n  : T extends { _zod: { output: infer Output } }\n  ? Output\n  : never;\n\nexport type Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\nexport function isZodSchemaV4(\n  schema: unknown\n): schema is z4.$ZodType<unknown, unknown> {\n  if (typeof schema !== \"object\" || schema === null) {\n    return false;\n  }\n\n  const obj = schema as Record<string, unknown>;\n  if (!(\"_zod\" in obj)) {\n    return false;\n  }\n\n  const zod = obj._zod;\n  return (\n    typeof zod === \"object\" &&\n    zod !== null &&\n    \"def\" in (zod as Record<string, unknown>)\n  );\n}\n\nexport function isZodSchemaV3(\n  schema: unknown\n): schema is z3.ZodType<unknown, z3.ZodTypeDef, unknown> {\n  if (typeof schema !== \"object\" || schema === null) {\n    return false;\n  }\n\n  const obj = schema as Record<string, unknown>;\n  if (!(\"_def\" in obj) || \"_zod\" in obj) {\n    return false;\n  }\n\n  const def = obj._def;\n  return (\n    typeof def === \"object\" &&\n    def != null &&\n    \"typeName\" in (def as Record<string, unknown>)\n  );\n}\n\n/** Backward compatible isZodSchema for Zod 3 */\nexport function isZodSchema<\n  RunOutput extends Record<string, unknown> = Record<string, unknown>\n>(\n  schema: z3.ZodType<RunOutput> | Record<string, unknown>\n): schema is z3.ZodType<RunOutput> {\n  if (isZodSchemaV4(schema)) {\n    console.warn(\n      \"[WARNING] Attempting to use Zod 4 schema in a context where Zod 3 schema is expected. This may cause unexpected behavior.\"\n    );\n  }\n  return isZodSchemaV3(schema);\n}\n\n/**\n * Given either a Zod schema, or plain object, determine if the input is a Zod schema.\n *\n * @param {unknown} input\n * @returns {boolean} Whether or not the provided input is a Zod schema.\n */\nexport function isInteropZodSchema(input: unknown): input is InteropZodType {\n  if (!input) {\n    return false;\n  }\n  if (typeof input !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(input)) {\n    return false;\n  }\n  if (\n    isZodSchemaV4(input) ||\n    isZodSchemaV3(input as z3.ZodType<Record<string, unknown>>)\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport type InteropZodLiteral = z3.ZodLiteral<unknown> | z4.$ZodLiteral;\n\nexport function isZodLiteralV3(obj: unknown): obj is z3.ZodLiteral<unknown> {\n  // Zod v3 literal schemas have _def.typeName === \"ZodLiteral\"\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"_def\" in obj &&\n    typeof obj._def === \"object\" &&\n    obj._def !== null &&\n    \"typeName\" in obj._def &&\n    obj._def.typeName === \"ZodLiteral\"\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isZodLiteralV4(obj: unknown): obj is z4.$ZodLiteral {\n  if (!isZodSchemaV4(obj)) return false;\n  // Zod v4 literal schemas have _zod.def.type === \"literal\"\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"_zod\" in obj &&\n    typeof obj._zod === \"object\" &&\n    obj._zod !== null &&\n    \"def\" in obj._zod &&\n    typeof obj._zod.def === \"object\" &&\n    obj._zod.def !== null &&\n    \"type\" in obj._zod.def &&\n    obj._zod.def.type === \"literal\"\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Determines if the provided value is an InteropZodLiteral (Zod v3 or v4 literal schema).\n *\n * @param obj The value to check.\n * @returns {boolean} True if the value is a Zod v3 or v4 literal schema, false otherwise.\n */\nexport function isInteropZodLiteral(obj: unknown): obj is InteropZodLiteral {\n  if (isZodLiteralV3(obj)) return true;\n  if (isZodLiteralV4(obj)) return true;\n  return false;\n}\n\ntype InteropZodSafeParseResult<T> = z3.SafeParseReturnType<T, T>;\n\n/**\n * Asynchronously parses the input using the provided Zod schema (v3 or v4) and returns a safe parse result.\n * This function handles both Zod v3 and v4 schemas, returning a result object indicating success or failure.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {Promise<InteropZodSafeParseResult<T>>} A promise that resolves to a safe parse result object.\n * @throws {Error} If the schema is not a recognized Zod v3 or v4 schema.\n */\nexport async function interopSafeParseAsync<T>(\n  schema: InteropZodType<T>,\n  input: unknown\n): Promise<InteropZodSafeParseResult<T>> {\n  if (isZodSchemaV4(schema)) {\n    try {\n      const data = await parseAsync(schema, input);\n      return {\n        success: true,\n        data,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error as z3.ZodError<T>,\n      };\n    }\n  }\n  if (isZodSchemaV3(schema as z3.ZodType<Record<string, unknown>>)) {\n    return await schema.safeParseAsync(input);\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n\n/**\n * Asynchronously parses the input using the provided Zod schema (v3 or v4) and returns the parsed value.\n * Throws an error if parsing fails or if the schema is not a recognized Zod v3 or v4 schema.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {Promise<T>} A promise that resolves to the parsed value.\n * @throws {Error} If parsing fails or the schema is not a recognized Zod v3 or v4 schema.\n */\nexport async function interopParseAsync<T>(\n  schema: InteropZodType<T>,\n  input: unknown\n): Promise<T> {\n  if (isZodSchemaV4(schema)) {\n    return await parseAsync(schema, input);\n  }\n  if (isZodSchemaV3(schema as z3.ZodType<Record<string, unknown>>)) {\n    return await schema.parseAsync(input);\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n\n/**\n * Safely parses the input using the provided Zod schema (v3 or v4) and returns a result object\n * indicating success or failure. This function is compatible with both Zod v3 and v4 schemas.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {InteropZodSafeParseResult<T>} An object with either the parsed data (on success)\n *   or the error (on failure).\n * @throws {Error} If the schema is not a recognized Zod v3 or v4 schema.\n */\nexport function interopSafeParse<T>(\n  schema: InteropZodType<T>,\n  input: unknown\n): InteropZodSafeParseResult<T> {\n  if (isZodSchemaV4(schema)) {\n    try {\n      const data = parse(schema, input);\n      return {\n        success: true,\n        data,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error as z3.ZodError<T>,\n      };\n    }\n  }\n  if (isZodSchemaV3(schema as z3.ZodType<Record<string, unknown>>)) {\n    return schema.safeParse(input);\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n\n/**\n * Parses the input using the provided Zod schema (v3 or v4) and returns the parsed value.\n * Throws an error if parsing fails or if the schema is not a recognized Zod v3 or v4 schema.\n *\n * @template T - The expected output type of the schema.\n * @param {InteropZodType<T>} schema - The Zod schema (v3 or v4) to use for parsing.\n * @param {unknown} input - The input value to parse.\n * @returns {T} The parsed value.\n * @throws {Error} If parsing fails or the schema is not a recognized Zod v3 or v4 schema.\n */\nexport function interopParse<T>(schema: InteropZodType<T>, input: unknown): T {\n  if (isZodSchemaV4(schema)) {\n    return parse(schema, input);\n  }\n  if (isZodSchemaV3(schema as z3.ZodType<Record<string, unknown>>)) {\n    return schema.parse(input);\n  }\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n\n/**\n * Retrieves the description from a schema definition (v3, v4, or plain object), if available.\n *\n * @param {unknown} schema - The schema to extract the description from.\n * @returns {string | undefined} The description of the schema, or undefined if not present.\n */\nexport function getSchemaDescription(\n  schema: InteropZodType<unknown> | Record<string, unknown>\n): string | undefined {\n  if (isZodSchemaV4(schema)) {\n    return globalRegistry.get(schema)?.description;\n  }\n  if (isZodSchemaV3(schema as z3.ZodType<Record<string, unknown>>)) {\n    return schema.description as string | undefined;\n  }\n  if (\"description\" in schema && typeof schema.description === \"string\") {\n    return schema.description;\n  }\n  return undefined;\n}\n\n/**\n * Determines if the provided Zod schema is \"shapeless\".\n * A shapeless schema is one that does not define any object shape,\n * such as ZodString, ZodNumber, ZodBoolean, ZodAny, etc.\n * For ZodObject, it must have no shape keys to be considered shapeless.\n * ZodRecord schemas are considered shapeless since they define dynamic\n * key-value mappings without fixed keys.\n *\n * @param schema The Zod schema to check.\n * @returns {boolean} True if the schema is shapeless, false otherwise.\n */\nexport function isShapelessZodSchema(schema: unknown): boolean {\n  if (!isInteropZodSchema(schema)) {\n    return false;\n  }\n\n  // Check for v3 schemas\n  if (isZodSchemaV3(schema as z3.ZodType<Record<string, unknown>>)) {\n    // @ts-expect-error - zod v3 types are not compatible with zod v4 types\n    const def = schema._def as { typeName?: string };\n\n    // ZodObject is only shaped if it has actual shape keys\n    if (def.typeName === \"ZodObject\") {\n      const obj = schema as { shape?: Record<string, unknown> };\n      return !obj.shape || Object.keys(obj.shape).length === 0;\n    }\n\n    // ZodRecord is shapeless (dynamic key-value mapping)\n    if (def.typeName === \"ZodRecord\") {\n      return true;\n    }\n  }\n\n  // Check for v4 schemas\n  if (isZodSchemaV4(schema)) {\n    const def = schema._zod.def;\n\n    // Object type is only shaped if it has actual shape keys\n    if (def.type === \"object\") {\n      const obj = schema as { shape?: Record<string, unknown> };\n      return !obj.shape || Object.keys(obj.shape).length === 0;\n    }\n\n    // Record type is shapeless (dynamic key-value mapping)\n    if (def.type === \"record\") {\n      return true;\n    }\n  }\n\n  // For other schemas, check if they have a `shape` property\n  // If they don't have shape, they're likely shapeless\n  if (typeof schema === \"object\" && schema !== null && !(\"shape\" in schema)) {\n    return true;\n  }\n\n  return false;\n}\n\n/**\n * Determines if the provided Zod schema should be treated as a simple string schema\n * that maps to DynamicTool. This aligns with the type-level constraint of\n * InteropZodType<string | undefined> which only matches basic string schemas.\n * If the provided schema is just z.string(), we can make the determination that\n * the tool is just a generic string tool that doesn't require any input validation.\n *\n * This function only returns true for basic ZodString schemas, including:\n * - Basic string schemas (z.string())\n * - String schemas with validations (z.string().min(1), z.string().email(), etc.)\n *\n * This function returns false for everything else, including:\n * - String schemas with defaults (z.string().default(\"value\"))\n * - Branded string schemas (z.string().brand<\"UserId\">())\n * - String schemas with catch operations (z.string().catch(\"default\"))\n * - Optional/nullable string schemas (z.string().optional())\n * - Transformed schemas (z.string().transform() or z.object().transform())\n * - Object or record schemas, even if they're empty\n * - Any other schema type\n *\n * @param schema The Zod schema to check.\n * @returns {boolean} True if the schema is a basic ZodString, false otherwise.\n */\nexport function isSimpleStringZodSchema(\n  schema: unknown\n): schema is InteropZodType<string | undefined> {\n  if (!isInteropZodSchema(schema)) {\n    return false;\n  }\n\n  // For v3 schemas\n  if (isZodSchemaV3(schema as z3.ZodType<Record<string, unknown>>)) {\n    // @ts-expect-error - zod v3 types are not compatible with zod v4 types\n    const def = schema._def as { typeName?: string };\n\n    // Only accept basic ZodString\n    return def.typeName === \"ZodString\";\n  }\n\n  // For v4 schemas\n  if (isZodSchemaV4(schema)) {\n    const def = schema._zod.def;\n\n    // Only accept basic string type\n    return def.type === \"string\";\n  }\n\n  return false;\n}\n\nexport function isZodObjectV3(obj: unknown): obj is ZodObjectV3 {\n  // Zod v3 object schemas have _def.typeName === \"ZodObject\"\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"_def\" in obj &&\n    typeof obj._def === \"object\" &&\n    obj._def !== null &&\n    \"typeName\" in obj._def &&\n    obj._def.typeName === \"ZodObject\"\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isZodObjectV4(obj: unknown): obj is z4.$ZodObject {\n  if (!isZodSchemaV4(obj)) return false;\n  // Zod v4 object schemas have _zod.def.type === \"object\"\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"_zod\" in obj &&\n    typeof obj._zod === \"object\" &&\n    obj._zod !== null &&\n    \"def\" in obj._zod &&\n    typeof obj._zod.def === \"object\" &&\n    obj._zod.def !== null &&\n    \"type\" in obj._zod.def &&\n    obj._zod.def.type === \"object\"\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isZodArrayV4(obj: unknown): obj is z4.$ZodArray {\n  if (!isZodSchemaV4(obj)) return false;\n  // Zod v4 array schemas have _zod.def.type === \"array\"\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"_zod\" in obj &&\n    typeof obj._zod === \"object\" &&\n    obj._zod !== null &&\n    \"def\" in obj._zod &&\n    typeof obj._zod.def === \"object\" &&\n    obj._zod.def !== null &&\n    \"type\" in obj._zod.def &&\n    obj._zod.def.type === \"array\"\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isZodOptionalV4(obj: unknown): obj is z4.$ZodOptional {\n  if (!isZodSchemaV4(obj)) return false;\n  // Zod v4 optional schemas have _zod.def.type === \"optional\"\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"_zod\" in obj &&\n    typeof obj._zod === \"object\" &&\n    obj._zod !== null &&\n    \"def\" in obj._zod &&\n    typeof obj._zod.def === \"object\" &&\n    obj._zod.def !== null &&\n    \"type\" in obj._zod.def &&\n    obj._zod.def.type === \"optional\"\n  ) {\n    return true;\n  }\n  return false;\n}\n\nexport function isZodNullableV4(obj: unknown): obj is z4.$ZodNullable {\n  if (!isZodSchemaV4(obj)) return false;\n  // Zod v4 nullable schemas have _zod.def.type === \"nullable\"\n  if (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    \"_zod\" in obj &&\n    typeof obj._zod === \"object\" &&\n    obj._zod !== null &&\n    \"def\" in obj._zod &&\n    typeof obj._zod.def === \"object\" &&\n    obj._zod.def !== null &&\n    \"type\" in obj._zod.def &&\n    obj._zod.def.type === \"nullable\"\n  ) {\n    return true;\n  }\n  return false;\n}\n\n/**\n * Determines if the provided value is an InteropZodObject (Zod v3 or v4 object schema).\n *\n * @param obj The value to check.\n * @returns {boolean} True if the value is a Zod v3 or v4 object schema, false otherwise.\n */\nexport function isInteropZodObject(obj: unknown): obj is InteropZodObject {\n  if (isZodObjectV3(obj)) return true;\n  if (isZodObjectV4(obj)) return true;\n  return false;\n}\n\n/**\n * Retrieves the shape (fields) of a Zod object schema, supporting both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @returns {InteropZodObjectShape<T>} The shape of the object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function getInteropZodObjectShape<T extends InteropZodObject>(\n  schema: T\n): InteropZodObjectShape<T> {\n  if (isZodSchemaV3(schema)) {\n    return schema.shape;\n  }\n  if (isZodSchemaV4(schema)) {\n    return schema._zod.def.shape as InteropZodObjectShape<T>;\n  }\n  throw new Error(\n    \"Schema must be an instance of z3.ZodObject or z4.$ZodObject\"\n  );\n}\n\n/**\n * Extends a Zod object schema with additional fields, supporting both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {InteropZodObjectShape} extension - The fields to add to the schema.\n * @returns {InteropZodObject} The extended Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function extendInteropZodObject<T extends InteropZodObject>(\n  schema: T,\n  extension: InteropZodObjectShape\n): InteropZodObject {\n  if (isZodSchemaV3(schema)) {\n    return schema.extend(extension as z3.ZodRawShape);\n  }\n  if (isZodSchemaV4(schema)) {\n    return util.extend(schema, extension);\n  }\n  throw new Error(\n    \"Schema must be an instance of z3.ZodObject or z4.$ZodObject\"\n  );\n}\n\n/**\n * Returns a partial version of a Zod object schema, making all fields optional.\n * Supports both Zod v3 and v4.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @returns {InteropZodObject} The partial Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function interopZodObjectPartial<T extends InteropZodObject>(\n  schema: T\n): InteropZodObject {\n  if (isZodSchemaV3(schema)) {\n    // z3: .partial() exists and works as expected\n    return schema.partial();\n  }\n  if (isZodSchemaV4(schema)) {\n    // z4: util.partial exists and works as expected\n    return util.partial($ZodOptional, schema, undefined);\n  }\n  throw new Error(\n    \"Schema must be an instance of z3.ZodObject or z4.$ZodObject\"\n  );\n}\n\n/**\n * Returns a strict version of a Zod object schema, disallowing unknown keys.\n * Supports both Zod v3 and v4 object schemas. If `recursive` is true, applies strictness\n * recursively to all nested object schemas and arrays of object schemas.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {boolean} [recursive=false] - Whether to apply strictness recursively to nested objects/arrays.\n * @returns {InteropZodObject} The strict Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function interopZodObjectStrict<T extends InteropZodObject>(\n  schema: T,\n  recursive = false\n): InteropZodObject {\n  if (isZodSchemaV3(schema)) {\n    // TODO: v3 schemas aren't recursively handled here\n    // (currently not necessary since zodToJsonSchema handles this)\n    return schema.strict();\n  }\n  if (isZodObjectV4(schema)) {\n    const outputShape: Mutable<z4.$ZodShape> = schema._zod.def.shape;\n    if (recursive) {\n      for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {\n        // If the shape key is a v4 object schema, we need to make it strict\n        if (isZodObjectV4(keySchema)) {\n          const outputSchema = interopZodObjectStrict(keySchema, recursive);\n          outputShape[key] = outputSchema as ZodObjectV4;\n        }\n        // If the shape key is a v4 array schema, we need to make the element\n        // schema strict if it's an object schema\n        else if (isZodArrayV4(keySchema)) {\n          let elementSchema = keySchema._zod.def.element;\n          if (isZodObjectV4(elementSchema)) {\n            elementSchema = interopZodObjectStrict(\n              elementSchema,\n              recursive\n            ) as ZodObjectV4;\n          }\n          outputShape[key] = clone(keySchema, {\n            ...keySchema._zod.def,\n            element: elementSchema,\n          });\n        }\n        // Otherwise, just use the keySchema\n        else {\n          outputShape[key] = keySchema;\n        }\n        // Assign meta fields to the keySchema\n        const meta = globalRegistry.get(keySchema);\n        if (meta) globalRegistry.add(outputShape[key], meta);\n      }\n    }\n    const modifiedSchema = clone<ZodObjectV4>(schema, {\n      ...schema._zod.def,\n      shape: outputShape,\n      catchall: _never($ZodNever),\n    });\n    const meta = globalRegistry.get(schema);\n    if (meta) globalRegistry.add(modifiedSchema, meta);\n    return modifiedSchema;\n  }\n  throw new Error(\n    \"Schema must be an instance of z3.ZodObject or z4.$ZodObject\"\n  );\n}\n\n/**\n * Returns a passthrough version of a Zod object schema, allowing unknown keys.\n * Supports both Zod v3 and v4 object schemas. If `recursive` is true, applies passthrough\n * recursively to all nested object schemas and arrays of object schemas.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {boolean} [recursive=false] - Whether to apply passthrough recursively to nested objects/arrays.\n * @returns {InteropZodObject} The passthrough Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function interopZodObjectPassthrough<T extends InteropZodObject>(\n  schema: T,\n  recursive = false\n): InteropZodObject {\n  if (isZodObjectV3(schema)) {\n    // TODO: v3 schemas aren't recursively handled here\n    // (currently not necessary since zodToJsonSchema handles this)\n    return schema.passthrough();\n  }\n  if (isZodObjectV4(schema)) {\n    const outputShape: Mutable<z4.$ZodShape> = schema._zod.def.shape;\n    if (recursive) {\n      for (const [key, keySchema] of Object.entries(schema._zod.def.shape)) {\n        // If the shape key is a v4 object schema, we need to make it passthrough\n        if (isZodObjectV4(keySchema)) {\n          const outputSchema = interopZodObjectPassthrough(\n            keySchema,\n            recursive\n          );\n          outputShape[key] = outputSchema as ZodObjectV4;\n        }\n        // If the shape key is a v4 array schema, we need to make the element\n        // schema passthrough if it's an object schema\n        else if (isZodArrayV4(keySchema)) {\n          let elementSchema = keySchema._zod.def.element;\n          if (isZodObjectV4(elementSchema)) {\n            elementSchema = interopZodObjectPassthrough(\n              elementSchema,\n              recursive\n            ) as ZodObjectV4;\n          }\n          outputShape[key] = clone(keySchema, {\n            ...keySchema._zod.def,\n            element: elementSchema,\n          });\n        }\n        // Otherwise, just use the keySchema\n        else {\n          outputShape[key] = keySchema;\n        }\n        // Assign meta fields to the keySchema\n        const meta = globalRegistry.get(keySchema);\n        if (meta) globalRegistry.add(outputShape[key], meta);\n      }\n    }\n    const modifiedSchema = clone<ZodObjectV4>(schema, {\n      ...schema._zod.def,\n      shape: outputShape,\n      catchall: _unknown($ZodUnknown),\n    });\n    const meta = globalRegistry.get(schema);\n    if (meta) globalRegistry.add(modifiedSchema, meta);\n    return modifiedSchema;\n  }\n  throw new Error(\n    \"Schema must be an instance of z3.ZodObject or z4.$ZodObject\"\n  );\n}\n\n/**\n * Returns a getter function for the default value of a Zod schema, if one is defined.\n * Supports both Zod v3 and v4 schemas. If the schema has a default value,\n * the returned function will return that value when called. If no default is defined,\n * returns undefined.\n *\n * @template T - The type of the Zod schema.\n * @param {T} schema - The Zod schema instance (either v3 or v4).\n * @returns {(() => InferInteropZodOutput<T>) | undefined} A function that returns the default value, or undefined if no default is set.\n */\nexport function getInteropZodDefaultGetter<T extends InteropZodType>(\n  schema: T\n): (() => InferInteropZodOutput<T>) | undefined {\n  if (isZodSchemaV3(schema)) {\n    try {\n      const defaultValue = schema.parse(undefined);\n      return () => defaultValue as InferInteropZodOutput<T>;\n    } catch {\n      return undefined;\n    }\n  }\n  if (isZodSchemaV4(schema)) {\n    try {\n      const defaultValue = parse(schema, undefined);\n      return () => defaultValue as InferInteropZodOutput<T>;\n    } catch {\n      return undefined;\n    }\n  }\n  return undefined;\n}\n\nfunction isZodTransformV3(\n  schema: InteropZodType\n): schema is z3.ZodEffects<z3.ZodTypeAny> {\n  return (\n    isZodSchemaV3(schema) &&\n    \"typeName\" in schema._def &&\n    schema._def.typeName === \"ZodEffects\"\n  );\n}\n\nfunction isZodTransformV4(schema: InteropZodType): schema is z4.$ZodPipe {\n  return isZodSchemaV4(schema) && schema._zod.def.type === \"pipe\";\n}\n\nfunction interopZodTransformInputSchemaImpl(\n  schema: InteropZodType,\n  recursive: boolean,\n  cache: WeakMap<InteropZodType, InteropZodType>\n): InteropZodType {\n  const cached = cache.get(schema);\n  if (cached !== undefined) {\n    return cached;\n  }\n\n  // Zod v3: ._def.schema is the input schema for ZodEffects (transform)\n  if (isZodSchemaV3(schema)) {\n    if (isZodTransformV3(schema)) {\n      return interopZodTransformInputSchemaImpl(\n        schema._def.schema,\n        recursive,\n        cache\n      );\n    }\n    // TODO: v3 schemas aren't recursively handled here\n    // (currently not necessary since zodToJsonSchema handles this)\n    return schema;\n  }\n\n  // Zod v4: _def.type is the input schema for ZodEffects (transform)\n  if (isZodSchemaV4(schema)) {\n    let outputSchema: InteropZodType = schema;\n    if (isZodTransformV4(schema)) {\n      outputSchema = interopZodTransformInputSchemaImpl(\n        schema._zod.def.in,\n        recursive,\n        cache\n      );\n    }\n    if (recursive) {\n      // Handle nested object schemas\n      if (isZodObjectV4(outputSchema)) {\n        const outputShape: Mutable<z4.$ZodShape> = {};\n        for (const [key, keySchema] of Object.entries(\n          outputSchema._zod.def.shape\n        )) {\n          outputShape[key] = interopZodTransformInputSchemaImpl(\n            keySchema,\n            recursive,\n            cache\n          ) as z4.$ZodType;\n        }\n        outputSchema = clone<ZodObjectV4>(outputSchema, {\n          ...outputSchema._zod.def,\n          shape: outputShape,\n        });\n      }\n      // Handle nested array schemas\n      else if (isZodArrayV4(outputSchema)) {\n        const elementSchema = interopZodTransformInputSchemaImpl(\n          outputSchema._zod.def.element,\n          recursive,\n          cache\n        );\n        outputSchema = clone<z4.$ZodArray>(outputSchema, {\n          ...outputSchema._zod.def,\n          element: elementSchema as z4.$ZodType,\n        });\n      }\n      // Handle optional schemas\n      else if (isZodOptionalV4(outputSchema)) {\n        const innerSchema = interopZodTransformInputSchemaImpl(\n          outputSchema._zod.def.innerType as InteropZodType,\n          recursive,\n          cache\n        );\n        outputSchema = clone<z4.$ZodOptional>(outputSchema, {\n          ...outputSchema._zod.def,\n          innerType: innerSchema as z4.$ZodType,\n        });\n      }\n      // Handle nullable schemas\n      else if (isZodNullableV4(outputSchema)) {\n        const innerSchema = interopZodTransformInputSchemaImpl(\n          outputSchema._zod.def.innerType as InteropZodType,\n          recursive,\n          cache\n        );\n        outputSchema = clone<z4.$ZodNullable>(outputSchema, {\n          ...outputSchema._zod.def,\n          innerType: innerSchema as z4.$ZodType,\n        });\n      }\n    }\n    const meta = globalRegistry.get(schema);\n    if (meta) globalRegistry.add(outputSchema as z4.$ZodType, meta);\n    cache.set(schema, outputSchema);\n    return outputSchema;\n  }\n\n  throw new Error(\"Schema must be an instance of z3.ZodType or z4.$ZodType\");\n}\n\n/**\n * Returns the input type of a Zod transform schema, for both v3 and v4.\n * If the schema is not a transform, returns undefined. If `recursive` is true,\n * recursively processes nested object schemas and arrays of object schemas.\n *\n * @param schema - The Zod schema instance (v3 or v4)\n * @param {boolean} [recursive=false] - Whether to recursively process nested objects/arrays.\n * @returns The input Zod schema of the transform, or undefined if not a transform\n */\nexport function interopZodTransformInputSchema(\n  schema: InteropZodType,\n  recursive = false\n): InteropZodType {\n  const cache = new WeakMap<InteropZodType, InteropZodType>();\n  return interopZodTransformInputSchemaImpl(schema, recursive, cache);\n}\n\n/**\n * Creates a modified version of a Zod object schema where fields matching a predicate are made optional.\n * Supports both Zod v3 and v4 schemas and preserves the original schema version.\n *\n * @template T - The type of the Zod object schema.\n * @param {T} schema - The Zod object schema instance (either v3 or v4).\n * @param {(key: string, value: InteropZodType) => boolean} predicate - Function to determine which fields should be optional.\n * @returns {InteropZodObject} The modified Zod object schema.\n * @throws {Error} If the schema is not a Zod v3 or v4 object.\n */\nexport function interopZodObjectMakeFieldsOptional<T extends InteropZodObject>(\n  schema: T,\n  predicate: (key: string, value: InteropZodType) => boolean\n): InteropZodObject {\n  if (isZodSchemaV3(schema)) {\n    const shape = getInteropZodObjectShape(schema);\n    const modifiedShape: Record<string, z3.ZodTypeAny> = {};\n\n    for (const [key, value] of Object.entries(shape)) {\n      if (predicate(key, value)) {\n        // Make this field optional using v3 methods\n        modifiedShape[key] = (value as z3.ZodTypeAny).optional();\n      } else {\n        // Keep field as-is\n        modifiedShape[key] = value;\n      }\n    }\n\n    // Use v3's extend method to create a new schema with the modified shape\n    return schema.extend(modifiedShape as z3.ZodRawShape);\n  }\n\n  if (isZodSchemaV4(schema)) {\n    const shape = getInteropZodObjectShape(schema);\n    const outputShape: Mutable<z4.$ZodShape> = { ...schema._zod.def.shape };\n\n    for (const [key, value] of Object.entries(shape)) {\n      if (predicate(key, value)) {\n        // Make this field optional using v4 methods\n        outputShape[key] = new $ZodOptional({\n          type: \"optional\" as const,\n          innerType: value as z4.$ZodType,\n        });\n      }\n      // Otherwise keep the field as-is (already in outputShape)\n    }\n\n    const modifiedSchema = clone<ZodObjectV4>(schema, {\n      ...schema._zod.def,\n      shape: outputShape,\n    });\n\n    // Preserve metadata\n    const meta = globalRegistry.get(schema);\n    if (meta) globalRegistry.add(modifiedSchema, meta);\n\n    return modifiedSchema;\n  }\n\n  throw new Error(\n    \"Schema must be an instance of z3.ZodObject or z4.$ZodObject\"\n  );\n}\n\nexport function isInteropZodError(e: unknown) {\n  return (\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    e instanceof Error &&\n    (e.constructor.name === \"ZodError\" || e.constructor.name === \"$ZodError\")\n  );\n}\n"],"mappings":";;;AAwFA,SAAgB,cACdA,QACyC;AACzC,KAAI,OAAO,WAAW,YAAY,WAAW,KAC3C,QAAO;CAGT,MAAM,MAAM;AACZ,KAAI,EAAE,UAAU,KACd,QAAO;CAGT,MAAM,MAAM,IAAI;AAChB,QACE,OAAO,QAAQ,YACf,QAAQ,QACR,SAAU;AAEb;AAED,SAAgB,cACdA,QACuD;AACvD,KAAI,OAAO,WAAW,YAAY,WAAW,KAC3C,QAAO;CAGT,MAAM,MAAM;AACZ,KAAI,EAAE,UAAU,QAAQ,UAAU,IAChC,QAAO;CAGT,MAAM,MAAM,IAAI;AAChB,QACE,OAAO,QAAQ,YACf,OAAO,QACP,cAAe;AAElB;;AAGD,SAAgB,YAGdC,QACiC;AACjC,KAAI,cAAc,OAAO,EACvB,QAAQ,KACN,4HACD;AAEH,QAAO,cAAc,OAAO;AAC7B;;;;;;;AAQD,SAAgB,mBAAmBC,OAAyC;AAC1E,KAAI,CAAC,MACH,QAAO;AAET,KAAI,OAAO,UAAU,SACnB,QAAO;AAET,KAAI,MAAM,QAAQ,MAAM,CACtB,QAAO;AAET,KACE,cAAc,MAAM,IACpB,cAAc,MAA6C,CAE3D,QAAO;AAET,QAAO;AACR;AAID,SAAgB,eAAeC,KAA6C;AAE1E,KACE,OAAO,QAAQ,YACf,QAAQ,QACR,UAAU,OACV,OAAO,IAAI,SAAS,YACpB,IAAI,SAAS,QACb,cAAc,IAAI,QAClB,IAAI,KAAK,aAAa,aAEtB,QAAO;AAET,QAAO;AACR;AAED,SAAgB,eAAeA,KAAqC;AAClE,KAAI,CAAC,cAAc,IAAI,CAAE,QAAO;AAEhC,KACE,OAAO,QAAQ,YACf,QAAQ,QACR,UAAU,OACV,OAAO,IAAI,SAAS,YACpB,IAAI,SAAS,QACb,SAAS,IAAI,QACb,OAAO,IAAI,KAAK,QAAQ,YACxB,IAAI,KAAK,QAAQ,QACjB,UAAU,IAAI,KAAK,OACnB,IAAI,KAAK,IAAI,SAAS,UAEtB,QAAO;AAET,QAAO;AACR;;;;;;;AAQD,SAAgB,oBAAoBA,KAAwC;AAC1E,KAAI,eAAe,IAAI,CAAE,QAAO;AAChC,KAAI,eAAe,IAAI,CAAE,QAAO;AAChC,QAAO;AACR;;;;;;;;;;;AAcD,eAAsB,sBACpBC,QACAF,OACuC;AACvC,KAAI,cAAc,OAAO,CACvB,KAAI;EACF,MAAM,OAAO,MAAM,WAAW,QAAQ,MAAM;AAC5C,SAAO;GACL,SAAS;GACT;EACD;CACF,SAAQ,OAAO;AACd,SAAO;GACL,SAAS;GACF;EACR;CACF;AAEH,KAAI,cAAc,OAA8C,CAC9D,QAAO,MAAM,OAAO,eAAe,MAAM;AAE3C,OAAM,IAAI,MAAM;AACjB;;;;;;;;;;;AAYD,eAAsB,kBACpBE,QACAF,OACY;AACZ,KAAI,cAAc,OAAO,CACvB,QAAO,MAAM,WAAW,QAAQ,MAAM;AAExC,KAAI,cAAc,OAA8C,CAC9D,QAAO,MAAM,OAAO,WAAW,MAAM;AAEvC,OAAM,IAAI,MAAM;AACjB;;;;;;;;;;;;AAaD,SAAgB,iBACdE,QACAF,OAC8B;AAC9B,KAAI,cAAc,OAAO,CACvB,KAAI;EACF,MAAM,OAAO,MAAM,QAAQ,MAAM;AACjC,SAAO;GACL,SAAS;GACT;EACD;CACF,SAAQ,OAAO;AACd,SAAO;GACL,SAAS;GACF;EACR;CACF;AAEH,KAAI,cAAc,OAA8C,CAC9D,QAAO,OAAO,UAAU,MAAM;AAEhC,OAAM,IAAI,MAAM;AACjB;;;;;;;;;;;AAYD,SAAgB,aAAgBE,QAA2BF,OAAmB;AAC5E,KAAI,cAAc,OAAO,CACvB,QAAO,MAAM,QAAQ,MAAM;AAE7B,KAAI,cAAc,OAA8C,CAC9D,QAAO,OAAO,MAAM,MAAM;AAE5B,OAAM,IAAI,MAAM;AACjB;;;;;;;AAQD,SAAgB,qBACdG,QACoB;AACpB,KAAI,cAAc,OAAO,CACvB,QAAO,eAAe,IAAI,OAAO,EAAE;AAErC,KAAI,cAAc,OAA8C,CAC9D,QAAO,OAAO;AAEhB,KAAI,iBAAiB,UAAU,OAAO,OAAO,gBAAgB,SAC3D,QAAO,OAAO;AAEhB,QAAO;AACR;;;;;;;;;;;;AAaD,SAAgB,qBAAqBL,QAA0B;AAC7D,KAAI,CAAC,mBAAmB,OAAO,CAC7B,QAAO;AAIT,KAAI,cAAc,OAA8C,EAAE;EAEhE,MAAM,MAAM,OAAO;AAGnB,MAAI,IAAI,aAAa,aAAa;GAChC,MAAM,MAAM;AACZ,UAAO,CAAC,IAAI,SAAS,OAAO,KAAK,IAAI,MAAM,CAAC,WAAW;EACxD;AAGD,MAAI,IAAI,aAAa,YACnB,QAAO;CAEV;AAGD,KAAI,cAAc,OAAO,EAAE;EACzB,MAAM,MAAM,OAAO,KAAK;AAGxB,MAAI,IAAI,SAAS,UAAU;GACzB,MAAM,MAAM;AACZ,UAAO,CAAC,IAAI,SAAS,OAAO,KAAK,IAAI,MAAM,CAAC,WAAW;EACxD;AAGD,MAAI,IAAI,SAAS,SACf,QAAO;CAEV;AAID,KAAI,OAAO,WAAW,YAAY,WAAW,QAAQ,EAAE,WAAW,QAChE,QAAO;AAGT,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;;;;AAyBD,SAAgB,wBACdA,QAC8C;AAC9C,KAAI,CAAC,mBAAmB,OAAO,CAC7B,QAAO;AAIT,KAAI,cAAc,OAA8C,EAAE;EAEhE,MAAM,MAAM,OAAO;AAGnB,SAAO,IAAI,aAAa;CACzB;AAGD,KAAI,cAAc,OAAO,EAAE;EACzB,MAAM,MAAM,OAAO,KAAK;AAGxB,SAAO,IAAI,SAAS;CACrB;AAED,QAAO;AACR;AAED,SAAgB,cAAcG,KAAkC;AAE9D,KACE,OAAO,QAAQ,YACf,QAAQ,QACR,UAAU,OACV,OAAO,IAAI,SAAS,YACpB,IAAI,SAAS,QACb,cAAc,IAAI,QAClB,IAAI,KAAK,aAAa,YAEtB,QAAO;AAET,QAAO;AACR;AAED,SAAgB,cAAcA,KAAoC;AAChE,KAAI,CAAC,cAAc,IAAI,CAAE,QAAO;AAEhC,KACE,OAAO,QAAQ,YACf,QAAQ,QACR,UAAU,OACV,OAAO,IAAI,SAAS,YACpB,IAAI,SAAS,QACb,SAAS,IAAI,QACb,OAAO,IAAI,KAAK,QAAQ,YACxB,IAAI,KAAK,QAAQ,QACjB,UAAU,IAAI,KAAK,OACnB,IAAI,KAAK,IAAI,SAAS,SAEtB,QAAO;AAET,QAAO;AACR;AAED,SAAgB,aAAaA,KAAmC;AAC9D,KAAI,CAAC,cAAc,IAAI,CAAE,QAAO;AAEhC,KACE,OAAO,QAAQ,YACf,QAAQ,QACR,UAAU,OACV,OAAO,IAAI,SAAS,YACpB,IAAI,SAAS,QACb,SAAS,IAAI,QACb,OAAO,IAAI,KAAK,QAAQ,YACxB,IAAI,KAAK,QAAQ,QACjB,UAAU,IAAI,KAAK,OACnB,IAAI,KAAK,IAAI,SAAS,QAEtB,QAAO;AAET,QAAO;AACR;AAED,SAAgB,gBAAgBA,KAAsC;AACpE,KAAI,CAAC,cAAc,IAAI,CAAE,QAAO;AAEhC,KACE,OAAO,QAAQ,YACf,QAAQ,QACR,UAAU,OACV,OAAO,IAAI,SAAS,YACpB,IAAI,SAAS,QACb,SAAS,IAAI,QACb,OAAO,IAAI,KAAK,QAAQ,YACxB,IAAI,KAAK,QAAQ,QACjB,UAAU,IAAI,KAAK,OACnB,IAAI,KAAK,IAAI,SAAS,WAEtB,QAAO;AAET,QAAO;AACR;AAED,SAAgB,gBAAgBA,KAAsC;AACpE,KAAI,CAAC,cAAc,IAAI,CAAE,QAAO;AAEhC,KACE,OAAO,QAAQ,YACf,QAAQ,QACR,UAAU,OACV,OAAO,IAAI,SAAS,YACpB,IAAI,SAAS,QACb,SAAS,IAAI,QACb,OAAO,IAAI,KAAK,QAAQ,YACxB,IAAI,KAAK,QAAQ,QACjB,UAAU,IAAI,KAAK,OACnB,IAAI,KAAK,IAAI,SAAS,WAEtB,QAAO;AAET,QAAO;AACR;;;;;;;AAQD,SAAgB,mBAAmBA,KAAuC;AACxE,KAAI,cAAc,IAAI,CAAE,QAAO;AAC/B,KAAI,cAAc,IAAI,CAAE,QAAO;AAC/B,QAAO;AACR;;;;;;;;;AAUD,SAAgB,yBACdG,QAC0B;AAC1B,KAAI,cAAc,OAAO,CACvB,QAAO,OAAO;AAEhB,KAAI,cAAc,OAAO,CACvB,QAAO,OAAO,KAAK,IAAI;AAEzB,OAAM,IAAI,MACR;AAEH;;;;;;;;;;AAWD,SAAgB,uBACdA,QACAC,WACkB;AAClB,KAAI,cAAc,OAAO,CACvB,QAAO,OAAO,OAAO,UAA4B;AAEnD,KAAI,cAAc,OAAO,CACvB,QAAO,KAAK,OAAO,QAAQ,UAAU;AAEvC,OAAM,IAAI,MACR;AAEH;;;;;;;;;;AAWD,SAAgB,wBACdD,QACkB;AAClB,KAAI,cAAc,OAAO,CAEvB,QAAO,OAAO,SAAS;AAEzB,KAAI,cAAc,OAAO,CAEvB,QAAO,KAAK,QAAQ,cAAc,QAAQ,OAAU;AAEtD,OAAM,IAAI,MACR;AAEH;;;;;;;;;;;;AAaD,SAAgB,uBACdA,QACA,YAAY,OACM;AAClB,KAAI,cAAc,OAAO,CAGvB,QAAO,OAAO,QAAQ;AAExB,KAAI,cAAc,OAAO,EAAE;EACzB,MAAME,cAAqC,OAAO,KAAK,IAAI;AAC3D,MAAI,UACF,MAAK,MAAM,CAAC,KAAK,UAAU,IAAI,OAAO,QAAQ,OAAO,KAAK,IAAI,MAAM,EAAE;AAEpE,OAAI,cAAc,UAAU,EAAE;IAC5B,MAAM,eAAe,uBAAuB,WAAW,UAAU;IACjE,YAAY,OAAO;GACpB,WAGQ,aAAa,UAAU,EAAE;IAChC,IAAI,gBAAgB,UAAU,KAAK,IAAI;AACvC,QAAI,cAAc,cAAc,EAC9B,gBAAgB,uBACd,eACA,UACD;IAEH,YAAY,OAAO,MAAM,WAAW;KAClC,GAAG,UAAU,KAAK;KAClB,SAAS;IACV,EAAC;GACH,OAGC,YAAY,OAAO;GAGrB,MAAMC,SAAO,eAAe,IAAI,UAAU;AAC1C,OAAIA,QAAM,eAAe,IAAI,YAAY,MAAMA,OAAK;EACrD;EAEH,MAAM,iBAAiB,MAAmB,QAAQ;GAChD,GAAG,OAAO,KAAK;GACf,OAAO;GACP,UAAU,OAAO,UAAU;EAC5B,EAAC;EACF,MAAM,OAAO,eAAe,IAAI,OAAO;AACvC,MAAI,MAAM,eAAe,IAAI,gBAAgB,KAAK;AAClD,SAAO;CACR;AACD,OAAM,IAAI,MACR;AAEH;;;;;;;;;;;;AAaD,SAAgB,4BACdH,QACA,YAAY,OACM;AAClB,KAAI,cAAc,OAAO,CAGvB,QAAO,OAAO,aAAa;AAE7B,KAAI,cAAc,OAAO,EAAE;EACzB,MAAME,cAAqC,OAAO,KAAK,IAAI;AAC3D,MAAI,UACF,MAAK,MAAM,CAAC,KAAK,UAAU,IAAI,OAAO,QAAQ,OAAO,KAAK,IAAI,MAAM,EAAE;AAEpE,OAAI,cAAc,UAAU,EAAE;IAC5B,MAAM,eAAe,4BACnB,WACA,UACD;IACD,YAAY,OAAO;GACpB,WAGQ,aAAa,UAAU,EAAE;IAChC,IAAI,gBAAgB,UAAU,KAAK,IAAI;AACvC,QAAI,cAAc,cAAc,EAC9B,gBAAgB,4BACd,eACA,UACD;IAEH,YAAY,OAAO,MAAM,WAAW;KAClC,GAAG,UAAU,KAAK;KAClB,SAAS;IACV,EAAC;GACH,OAGC,YAAY,OAAO;GAGrB,MAAMC,SAAO,eAAe,IAAI,UAAU;AAC1C,OAAIA,QAAM,eAAe,IAAI,YAAY,MAAMA,OAAK;EACrD;EAEH,MAAM,iBAAiB,MAAmB,QAAQ;GAChD,GAAG,OAAO,KAAK;GACf,OAAO;GACP,UAAU,SAAS,YAAY;EAChC,EAAC;EACF,MAAM,OAAO,eAAe,IAAI,OAAO;AACvC,MAAI,MAAM,eAAe,IAAI,gBAAgB,KAAK;AAClD,SAAO;CACR;AACD,OAAM,IAAI,MACR;AAEH;;;;;;;;;;;AAYD,SAAgB,2BACdH,QAC8C;AAC9C,KAAI,cAAc,OAAO,CACvB,KAAI;EACF,MAAM,eAAe,OAAO,MAAM,OAAU;AAC5C,SAAO,MAAM;CACd,QAAO;AACN,SAAO;CACR;AAEH,KAAI,cAAc,OAAO,CACvB,KAAI;EACF,MAAM,eAAe,MAAM,QAAQ,OAAU;AAC7C,SAAO,MAAM;CACd,QAAO;AACN,SAAO;CACR;AAEH,QAAO;AACR;AAED,SAAS,iBACPI,QACwC;AACxC,QACE,cAAc,OAAO,IACrB,cAAc,OAAO,QACrB,OAAO,KAAK,aAAa;AAE5B;AAED,SAAS,iBAAiBA,QAA+C;AACvE,QAAO,cAAc,OAAO,IAAI,OAAO,KAAK,IAAI,SAAS;AAC1D;AAED,SAAS,mCACPA,QACAC,WACAC,OACgB;CAChB,MAAM,SAAS,MAAM,IAAI,OAAO;AAChC,KAAI,WAAW,OACb,QAAO;AAIT,KAAI,cAAc,OAAO,EAAE;AACzB,MAAI,iBAAiB,OAAO,CAC1B,QAAO,mCACL,OAAO,KAAK,QACZ,WACA,MACD;AAIH,SAAO;CACR;AAGD,KAAI,cAAc,OAAO,EAAE;EACzB,IAAIC,eAA+B;AACnC,MAAI,iBAAiB,OAAO,EAC1B,eAAe,mCACb,OAAO,KAAK,IAAI,IAChB,WACA,MACD;AAEH,MAAI,WAEF;OAAI,cAAc,aAAa,EAAE;IAC/B,MAAML,cAAqC,CAAE;AAC7C,SAAK,MAAM,CAAC,KAAK,UAAU,IAAI,OAAO,QACpC,aAAa,KAAK,IAAI,MACvB,EACC,YAAY,OAAO,mCACjB,WACA,WACA,MACD;IAEH,eAAe,MAAmB,cAAc;KAC9C,GAAG,aAAa,KAAK;KACrB,OAAO;IACR,EAAC;GACH,WAEQ,aAAa,aAAa,EAAE;IACnC,MAAM,gBAAgB,mCACpB,aAAa,KAAK,IAAI,SACtB,WACA,MACD;IACD,eAAe,MAAoB,cAAc;KAC/C,GAAG,aAAa,KAAK;KACrB,SAAS;IACV,EAAC;GACH,WAEQ,gBAAgB,aAAa,EAAE;IACtC,MAAM,cAAc,mCAClB,aAAa,KAAK,IAAI,WACtB,WACA,MACD;IACD,eAAe,MAAuB,cAAc;KAClD,GAAG,aAAa,KAAK;KACrB,WAAW;IACZ,EAAC;GACH,WAEQ,gBAAgB,aAAa,EAAE;IACtC,MAAM,cAAc,mCAClB,aAAa,KAAK,IAAI,WACtB,WACA,MACD;IACD,eAAe,MAAuB,cAAc;KAClD,GAAG,aAAa,KAAK;KACrB,WAAW;IACZ,EAAC;GACH;;EAEH,MAAM,OAAO,eAAe,IAAI,OAAO;AACvC,MAAI,MAAM,eAAe,IAAI,cAA6B,KAAK;EAC/D,MAAM,IAAI,QAAQ,aAAa;AAC/B,SAAO;CACR;AAED,OAAM,IAAI,MAAM;AACjB;;;;;;;;;;AAWD,SAAgB,+BACdE,QACA,YAAY,OACI;CAChB,MAAM,wBAAQ,IAAI;AAClB,QAAO,mCAAmC,QAAQ,WAAW,MAAM;AACpE;;;;;;;;;;;AAYD,SAAgB,mCACdJ,QACAQ,WACkB;AAClB,KAAI,cAAc,OAAO,EAAE;EACzB,MAAM,QAAQ,yBAAyB,OAAO;EAC9C,MAAMC,gBAA+C,CAAE;AAEvD,OAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,QAAQ,MAAM,CAC9C,KAAI,UAAU,KAAK,MAAM,EAEvB,cAAc,OAAQ,MAAwB,UAAU;OAGxD,cAAc,OAAO;AAKzB,SAAO,OAAO,OAAO,cAAgC;CACtD;AAED,KAAI,cAAc,OAAO,EAAE;EACzB,MAAM,QAAQ,yBAAyB,OAAO;EAC9C,MAAMP,cAAqC,EAAE,GAAG,OAAO,KAAK,IAAI,MAAO;AAEvE,OAAK,MAAM,CAAC,KAAK,MAAM,IAAI,OAAO,QAAQ,MAAM,CAC9C,KAAI,UAAU,KAAK,MAAM,EAEvB,YAAY,OAAO,IAAI,aAAa;GAClC,MAAM;GACN,WAAW;EACZ;EAKL,MAAM,iBAAiB,MAAmB,QAAQ;GAChD,GAAG,OAAO,KAAK;GACf,OAAO;EACR,EAAC;EAGF,MAAM,OAAO,eAAe,IAAI,OAAO;AACvC,MAAI,MAAM,eAAe,IAAI,gBAAgB,KAAK;AAElD,SAAO;CACR;AAED,OAAM,IAAI,MACR;AAEH;AAED,SAAgB,kBAAkBQ,GAAY;AAC5C,QAEE,aAAa,UACZ,EAAE,YAAY,SAAS,cAAc,EAAE,YAAY,SAAS;AAEhE"}