{"version":3,"file":"types.d.cts","names":["z","z3","CallbackManagerForToolRun","BaseLangChainParams","ToolDefinition","RunnableConfig","RunnableToolLike","RunnableInterface","DirectToolOutput","ToolCall","ToolMessage","MessageContent","InferInteropZodInput","InferInteropZodOutput","InteropZodType","InteropZodObject","JSONSchema","BaseStore","ResponseFormat","ToolOutputType","ContentAndArtifact","ToolReturnType","TInput","TConfig","TOutput","ToolInputSchemaBase","ZodTypeAny","ToolParams","ToolRunnableConfig","Record","ConfigurableFieldType","ContextSchema","StructuredToolParams","StructuredToolInterface","Pick","ToolInputSchemaOutputType","T","ToolInputSchemaInputType","StructuredToolCallInput","SchemaT","SchemaInputT","StringInputToolSchema","ZodTypeDef","ZodType","ToolCallInput","TArg","ToolOutputT","Promise","ToolInterface","NonNullable","BaseDynamicToolInput","DynamicToolInput","DynamicStructuredToolInput","SchemaOutputT","isStructuredTool","isRunnableToolLike","isStructuredToolParams","isLangChainTool","ToolRuntime","TState","TContext"],"sources":["../../src/tools/types.d.ts"],"sourcesContent":["import type { z as z3 } from \"zod/v3\";\nimport { CallbackManagerForToolRun } from \"../callbacks/manager.js\";\nimport type { BaseLangChainParams, ToolDefinition } from \"../language_models/base.js\";\nimport type { RunnableConfig } from \"../runnables/config.js\";\nimport { RunnableToolLike, type RunnableInterface } from \"../runnables/base.js\";\nimport { type DirectToolOutput, type ToolCall, type ToolMessage } from \"../messages/tool.js\";\nimport type { MessageContent } from \"../messages/base.js\";\nimport { type InferInteropZodInput, type InferInteropZodOutput, type InteropZodType, type InteropZodObject } from \"../utils/types/zod.js\";\nimport { JSONSchema } from \"../utils/json_schema.js\";\nimport type { BaseStore } from \"../stores.js\";\nexport type ResponseFormat = \"content\" | \"content_and_artifact\" | string;\nexport type ToolOutputType = any;\nexport type ContentAndArtifact = [MessageContent, any];\n/**\n * Conditional type that determines the return type of the {@link StructuredTool.invoke} method.\n * - If the input is a ToolCall, it returns a ToolMessage\n * - If the config is a runnable config and contains a toolCall property, it returns a ToolMessage\n * - Otherwise, it returns the original output type\n */\nexport type ToolReturnType<TInput, TConfig, TOutput> = TOutput extends DirectToolOutput ? TOutput : TConfig extends {\n    toolCall: {\n        id: string;\n    };\n} ? ToolMessage : TConfig extends {\n    toolCall: {\n        id: undefined;\n    };\n} ? TOutput : TConfig extends {\n    toolCall: {\n        id?: string;\n    };\n} ? TOutput | ToolMessage : TInput extends ToolCall ? ToolMessage : TOutput;\n/**\n * Base type that establishes the types of input schemas that can be used for LangChain tool\n * definitions.\n */\nexport type ToolInputSchemaBase = z3.ZodTypeAny | JSONSchema;\n/**\n * Parameters for the Tool classes.\n */\nexport interface ToolParams extends BaseLangChainParams {\n    /**\n     * The tool response format.\n     *\n     * If \"content\" then the output of the tool is interpreted as the contents of a\n     * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n     * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n     *\n     * @default \"content\"\n     */\n    responseFormat?: ResponseFormat;\n    /**\n     * Default config object for the tool runnable.\n     */\n    defaultConfig?: ToolRunnableConfig;\n    /**\n     * Whether to show full details in the thrown parsing errors.\n     *\n     * @default false\n     */\n    verboseParsingErrors?: boolean;\n    /**\n     * Metadata for the tool.\n     */\n    metadata?: Record<string, unknown>;\n    /**\n     * Optional provider-specific extra fields for the tool.\n     *\n     * This is used to pass provider-specific configuration that doesn't fit into\n     * standard tool fields.\n     */\n    extras?: Record<string, unknown>;\n}\nexport type ToolRunnableConfig<ConfigurableFieldType extends Record<string, any> = Record<string, any>, ContextSchema = any> = RunnableConfig<ConfigurableFieldType> & {\n    toolCall?: ToolCall;\n    context?: ContextSchema;\n};\n/**\n * Schema for defining tools.\n *\n * @version 0.2.19\n */\nexport interface StructuredToolParams extends Pick<StructuredToolInterface, \"name\" | \"schema\" | \"extras\"> {\n    /**\n     * An optional description of the tool to pass to the model.\n     */\n    description?: string;\n}\n/**\n * Utility type that resolves the output type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\nexport type ToolInputSchemaOutputType<T> = T extends InteropZodType ? InferInteropZodOutput<T> : T extends JSONSchema ? unknown : never;\n/**\n * Utility type that resolves the input type of a tool input schema.\n *\n * Input & Output types are a concept used with Zod schema, as Zod allows for transforms to occur\n * during parsing. When using JSONSchema, input and output types are the same.\n *\n * The input type for a given schema should match the structure of the arguments that the LLM\n * generates as part of its {@link ToolCall}. The output type will be the type that results from\n * applying any transforms defined in your schema. If there are no transforms, the input and output\n * types will be the same.\n */\nexport type ToolInputSchemaInputType<T> = T extends InteropZodType ? InferInteropZodInput<T> : T extends JSONSchema ? unknown : never;\n/**\n * Defines the type that will be passed into a tool handler function as a result of a tool call.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport type StructuredToolCallInput<SchemaT = ToolInputSchemaBase, SchemaInputT = ToolInputSchemaInputType<SchemaT>> = (ToolInputSchemaOutputType<SchemaT> extends string ? string : never) | SchemaInputT | ToolCall;\n/**\n * An input schema type for tools that accept a single string input.\n *\n * This schema defines a tool that takes an optional string parameter named \"input\".\n * It uses Zod's effects to transform the input and strip any extra properties.\n *\n * This is primarily used for creating simple string-based tools where the LLM\n * only needs to provide a single text value as input to the tool.\n */\nexport type StringInputToolSchema = z3.ZodType<string | undefined, z3.ZodTypeDef, any>;\n/**\n * Defines the type for input to a tool's call method.\n *\n * This type is a convenience alias for StructuredToolCallInput with the input type\n * derived from the schema. It represents the possible inputs that can be passed to a tool,\n * which can be either:\n * - A string (if the tool accepts string input)\n * - A structured input matching the tool's schema\n * - A ToolCall object (typically from an LLM)\n *\n * @param SchemaT - The schema type for the tool input, defaults to StringInputToolSchema\n */\nexport type ToolCallInput<SchemaT = StringInputToolSchema> = StructuredToolCallInput<SchemaT, ToolInputSchemaInputType<SchemaT>>;\n/**\n * Interface that defines the shape of a LangChain structured tool.\n *\n * A structured tool is a tool that uses a schema to define the structure of the arguments that the\n * LLM generates as part of its {@link ToolCall}.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface StructuredToolInterface<SchemaT = ToolInputSchemaBase, SchemaInputT = ToolInputSchemaInputType<SchemaT>, ToolOutputT = ToolOutputType> extends RunnableInterface<StructuredToolCallInput<SchemaT, SchemaInputT>, ToolOutputT | ToolMessage> {\n    lc_namespace: string[];\n    /**\n     * A Zod schema representing the parameters of the tool.\n     */\n    schema: SchemaT;\n    /**\n     * Invokes the tool with the provided argument and configuration.\n     * @param arg The input argument for the tool.\n     * @param configArg Optional configuration for the tool call.\n     * @returns A Promise that resolves with the tool's output.\n     */\n    invoke<TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>, TConfig extends ToolRunnableConfig | undefined>(arg: TArg, configArg?: TConfig): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument, configuration, and tags. It\n     * parses the input according to the schema, handles any errors, and\n     * manages callbacks.\n     * @param arg The input argument for the tool.\n     * @param configArg Optional configuration or callbacks for the tool.\n     * @param tags Optional tags for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    call<TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>, TConfig extends ToolRunnableConfig | undefined>(arg: TArg, configArg?: TConfig, \n    /** @deprecated */\n    tags?: string[]): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>>;\n    /**\n     * The name of the tool.\n     */\n    name: string;\n    /**\n     * A description of the tool.\n     */\n    description: string;\n    /**\n     * Whether to return the tool's output directly.\n     *\n     * Setting this to true means that after the tool is called,\n     * an agent should stop looping.\n     */\n    returnDirect: boolean;\n    /**\n     * Optional provider-specific extra fields for the tool.\n     *\n     * This is used to pass provider-specific configuration that doesn't fit into\n     * standard tool fields.\n     */\n    extras?: Record<string, unknown>;\n}\n/**\n * A special interface for tools that accept a string input, usually defined with the {@link Tool} class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaInputT - The TypeScript type representing the structure of the tool arguments generated by the LLM. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface ToolInterface<SchemaT = StringInputToolSchema, SchemaInputT = ToolInputSchemaInputType<SchemaT>, ToolOutputT = ToolOutputType> extends StructuredToolInterface<SchemaT, SchemaInputT, ToolOutputT> {\n    /**\n     * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n     *\n     * Calls the tool with the provided argument and callbacks. It handles\n     * string inputs specifically.\n     * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n     * @param callbacks Optional callbacks for the tool.\n     * @returns A Promise that resolves with a string.\n     */\n    call<TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>, TConfig extends ToolRunnableConfig | undefined>(arg: TArg, callbacks?: TConfig): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>>;\n}\n/**\n * Base interface for the input parameters of the {@link DynamicTool} and\n * {@link DynamicStructuredTool} classes.\n */\nexport interface BaseDynamicToolInput extends ToolParams {\n    name: string;\n    description: string;\n    /**\n     * Whether to return the tool's output directly.\n     *\n     * Setting this to true means that after the tool is called,\n     * an agent should stop looping.\n     */\n    returnDirect?: boolean;\n}\n/**\n * Interface for the input parameters of the DynamicTool class.\n */\nexport interface DynamicToolInput<ToolOutputT = ToolOutputType> extends BaseDynamicToolInput {\n    func: (input: string, runManager?: CallbackManagerForToolRun, config?: ToolRunnableConfig) => Promise<ToolOutputT>;\n}\n/**\n * Interface for the input parameters of the DynamicStructuredTool class.\n *\n * @param SchemaT - The type of the tool input schema. Usually you don't need to specify this.\n * @param SchemaOutputT - The TypeScript type representing the result of applying the schema to the tool arguments. Useful for type checking tool handler functions when using JSONSchema.\n */\nexport interface DynamicStructuredToolInput<SchemaT = ToolInputSchemaBase, SchemaOutputT = ToolInputSchemaOutputType<SchemaT>, ToolOutputT = ToolOutputType> extends BaseDynamicToolInput {\n    /**\n     * Tool handler function - the function that will be called when the tool is invoked.\n     *\n     * @param input - The input to the tool.\n     * @param runManager - The run manager for the tool.\n     * @param config - The configuration for the tool.\n     * @returns The result of the tool.\n     */\n    func: (input: SchemaOutputT, runManager?: CallbackManagerForToolRun, config?: RunnableConfig) => Promise<ToolOutputT>;\n    schema: SchemaT;\n}\n/**\n * Confirm whether the inputted tool is an instance of `StructuredToolInterface`.\n *\n * @param {StructuredToolInterface | JSONSchema | undefined} tool The tool to check if it is an instance of `StructuredToolInterface`.\n * @returns {tool is StructuredToolInterface} Whether the inputted tool is an instance of `StructuredToolInterface`.\n */\nexport declare function isStructuredTool(tool?: StructuredToolInterface | ToolDefinition | JSONSchema): tool is StructuredToolInterface;\n/**\n * Confirm whether the inputted tool is an instance of `RunnableToolLike`.\n *\n * @param {unknown | undefined} tool The tool to check if it is an instance of `RunnableToolLike`.\n * @returns {tool is RunnableToolLike} Whether the inputted tool is an instance of `RunnableToolLike`.\n */\nexport declare function isRunnableToolLike(tool?: unknown): tool is RunnableToolLike;\n/**\n * Confirm whether or not the tool contains the necessary properties to be considered a `StructuredToolParams`.\n *\n * @param {unknown | undefined} tool The object to check if it is a `StructuredToolParams`.\n * @returns {tool is StructuredToolParams} Whether the inputted object is a `StructuredToolParams`.\n */\nexport declare function isStructuredToolParams(tool?: unknown): tool is StructuredToolParams;\n/**\n * Whether or not the tool is one of StructuredTool, RunnableTool or StructuredToolParams.\n * It returns `is StructuredToolParams` since that is the most minimal interface of the three,\n * while still containing the necessary properties to be passed to a LLM for tool calling.\n *\n * @param {unknown | undefined} tool The tool to check if it is a LangChain tool.\n * @returns {tool is StructuredToolParams} Whether the inputted tool is a LangChain tool.\n */\nexport declare function isLangChainTool(tool?: unknown): tool is StructuredToolParams;\n/**\n * Runtime context automatically injected into tools.\n *\n * When a tool function has a parameter named `tool_runtime` with type hint\n * `ToolRuntime`, the tool execution system will automatically inject an instance\n * containing:\n *\n * - `state`: The current graph state\n * - `toolCallId`: The ID of the current tool call\n * - `config`: `RunnableConfig` for the current execution\n * - `context`: Runtime context\n * - `store`: `BaseStore` instance for persistent storage\n * - `writer`: Stream writer for streaming output\n *\n * No `Annotated` wrapper is needed - just use `runtime: ToolRuntime`\n * as a parameter.\n *\n * @example\n * ```typescript\n * import { tool, ToolRuntime } from \"@langchain/core/tools\";\n * import { z } from \"zod\";\n *\n * const stateSchema = z.object({\n *   messages: z.array(z.any()),\n *   userId: z.string().optional(),\n * });\n *\n * const greet = tool(\n *   async ({ name }, runtime) => {\n *     // Access state\n *     const messages = runtime.state.messages;\n *\n *     // Access tool_call_id\n *     console.log(`Tool call ID: ${runtime.toolCallId}`);\n *\n *     // Access config\n *     console.log(`Run ID: ${runtime.config.runId}`);\n *\n *     // Access runtime context\n *     const userId = runtime.context?.userId;\n *\n *     // Access store\n *     await runtime.store?.mset([[\"key\", \"value\"]]);\n *\n *     // Stream output\n *     runtime.writer?.(\"Processing...\");\n *\n *     return `Hello! User ID: ${runtime.state.userId || \"unknown\"} ${name}`;\n *   },\n *   {\n *     name: \"greet\",\n *     description: \"Use this to greet the user once you found their info.\",\n *     schema: z.object({ name: z.string() }),\n *     stateSchema,\n *   }\n * );\n * ```\n *\n * @template StateT - The type of the state schema (inferred from stateSchema)\n * @template ContextT - The type of the context schema (inferred from contextSchema)\n */\nexport type ToolRuntime<TState = unknown, TContext = unknown> = RunnableConfig & {\n    /**\n     * The current graph state.\n     */\n    state: TState extends InteropZodObject ? InferInteropZodOutput<TState> : TState extends Record<string, unknown> ? TState : unknown;\n    /**\n     * The ID of the current tool call.\n     */\n    toolCallId: string;\n    /**\n     * The current tool call.\n     */\n    toolCall?: ToolCall;\n    /**\n     * RunnableConfig for the current execution.\n     */\n    config: ToolRunnableConfig;\n    /**\n     * Runtime context (from langgraph `Runtime`).\n     */\n    context: TContext extends InteropZodObject ? InferInteropZodOutput<TContext> : TContext extends Record<string, unknown> ? TContext : unknown;\n    /**\n     * BaseStore instance for persistent storage (from langgraph `Runtime`).\n     */\n    store: BaseStore<string, unknown> | null;\n    /**\n     * Stream writer for streaming output (from langgraph `Runtime`).\n     */\n    writer: ((chunk: unknown) => void) | null;\n};\n//# sourceMappingURL=types.d.ts.map"],"mappings":"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"}