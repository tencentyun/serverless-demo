{"version":3,"file":"ai.cjs","names":["BaseMessage","fields: $InferMessageContent<TStructure, \"ai\"> | AIMessageFields<TStructure>","initParams: AIMessageFields<TStructure>","toolCalls","defaultToolCallParser","getTranslator","obj: unknown","x: BaseMessage","x: BaseMessageChunk","BaseMessageChunk","fields:\n      | $InferMessageContent<TStructure, \"ai\">\n      | AIMessageChunkFields<TStructure>","initParams: AIMessageChunkFields<TStructure>","collapseToolCallChunks","chunk: AIMessageChunk<TStructure>","combinedFields: AIMessageChunkFields","mergeContent","_mergeDicts","mergeResponseMetadata","_mergeLists","mergeUsageMetadata"],"sources":["../../src/messages/ai.ts"],"sourcesContent":["import {\n  BaseMessage,\n  BaseMessageChunk,\n  mergeContent,\n  _mergeDicts,\n  _mergeLists,\n  BaseMessageFields,\n} from \"./base.js\";\nimport { getTranslator } from \"./block_translators/index.js\";\nimport { ContentBlock } from \"./content/index.js\";\nimport {\n  $InferMessageContent,\n  $InferMessageProperty,\n  MessageStructure,\n} from \"./message.js\";\nimport { mergeResponseMetadata, mergeUsageMetadata } from \"./metadata.js\";\nimport {\n  InvalidToolCall,\n  ToolCall,\n  ToolCallChunk,\n  defaultToolCallParser,\n} from \"./tool.js\";\nimport { collapseToolCallChunks, Constructor } from \"./utils.js\";\n\nexport interface AIMessageFields<\n  TStructure extends MessageStructure = MessageStructure\n> extends BaseMessageFields<TStructure, \"ai\"> {\n  tool_calls?: ToolCall[];\n  invalid_tool_calls?: InvalidToolCall[];\n  usage_metadata?: $InferMessageProperty<TStructure, \"ai\", \"usage_metadata\">;\n}\n\nexport class AIMessage<TStructure extends MessageStructure = MessageStructure>\n  extends BaseMessage<TStructure, \"ai\">\n  implements AIMessageFields<TStructure>\n{\n  readonly type = \"ai\" as const;\n\n  tool_calls?: ToolCall[] = [];\n\n  invalid_tool_calls?: InvalidToolCall[] = [];\n\n  usage_metadata?: AIMessageFields<TStructure>[\"usage_metadata\"];\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      ...super.lc_aliases,\n      tool_calls: \"tool_calls\",\n      invalid_tool_calls: \"invalid_tool_calls\",\n    };\n  }\n\n  constructor(\n    fields: $InferMessageContent<TStructure, \"ai\"> | AIMessageFields<TStructure>\n  ) {\n    let initParams: AIMessageFields<TStructure>;\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      initParams = {\n        content: fields,\n        tool_calls: [],\n        invalid_tool_calls: [],\n        additional_kwargs: {},\n      };\n    } else {\n      initParams = fields;\n      const rawToolCalls = initParams.additional_kwargs?.tool_calls;\n      const toolCalls = initParams.tool_calls;\n      if (\n        !(rawToolCalls == null) &&\n        rawToolCalls.length > 0 &&\n        (toolCalls === undefined || toolCalls.length === 0)\n      ) {\n        console.warn(\n          [\n            \"New LangChain packages are available that more efficiently handle\",\n            \"tool calling.\\n\\nPlease upgrade your packages to versions that set\",\n            \"message tool calls. e.g., `pnpm install @langchain/anthropic`,\",\n            \"pnpm install @langchain/openai`, etc.\",\n          ].join(\" \")\n        );\n      }\n      try {\n        if (!(rawToolCalls == null) && toolCalls === undefined) {\n          const [toolCalls, invalidToolCalls] =\n            defaultToolCallParser(rawToolCalls);\n          initParams.tool_calls = toolCalls ?? [];\n          initParams.invalid_tool_calls = invalidToolCalls ?? [];\n        } else {\n          initParams.tool_calls = initParams.tool_calls ?? [];\n          initParams.invalid_tool_calls = initParams.invalid_tool_calls ?? [];\n        }\n      } catch {\n        // Do nothing if parsing fails\n        initParams.tool_calls = [];\n        initParams.invalid_tool_calls = [];\n      }\n\n      // Convert content to content blocks if output version is v1\n      if (\n        initParams.response_metadata !== undefined &&\n        \"output_version\" in initParams.response_metadata &&\n        initParams.response_metadata.output_version === \"v1\"\n      ) {\n        initParams.contentBlocks =\n          initParams.content as Array<ContentBlock.Standard>;\n        initParams.content = undefined;\n      }\n\n      if (initParams.contentBlocks !== undefined) {\n        // Add constructor tool calls as content blocks\n        initParams.contentBlocks.push(\n          ...initParams.tool_calls.map((toolCall) => ({\n            type: \"tool_call\" as const,\n            id: toolCall.id,\n            name: toolCall.name,\n            args: toolCall.args,\n          }))\n        );\n        // Add content block tool calls that aren't in the constructor tool calls\n        const missingToolCalls = initParams.contentBlocks\n          .filter<ContentBlock.Tools.ToolCall>(\n            (block): block is ContentBlock.Tools.ToolCall =>\n              block.type === \"tool_call\"\n          )\n          .filter(\n            (block) =>\n              !initParams.tool_calls?.some(\n                (toolCall) =>\n                  toolCall.id === block.id && toolCall.name === block.name\n              )\n          );\n        if (missingToolCalls.length > 0) {\n          initParams.tool_calls = missingToolCalls.map((block) => ({\n            type: \"tool_call\" as const,\n            id: block.id!,\n            name: block.name,\n            args: block.args as Record<string, unknown>,\n          }));\n        }\n      }\n    }\n    // Sadly, TypeScript only allows super() calls at root if the class has\n    // properties with initializers, so we have to check types twice.\n    super(initParams);\n    if (typeof initParams !== \"string\") {\n      this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n      this.invalid_tool_calls =\n        initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n    }\n    this.usage_metadata = initParams.usage_metadata;\n  }\n\n  static lc_name() {\n    return \"AIMessage\";\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    if (\n      this.response_metadata &&\n      \"output_version\" in this.response_metadata &&\n      this.response_metadata.output_version === \"v1\"\n    ) {\n      return this.content as Array<ContentBlock.Standard>;\n    }\n\n    if (\n      this.response_metadata &&\n      \"model_provider\" in this.response_metadata &&\n      typeof this.response_metadata.model_provider === \"string\"\n    ) {\n      const translator = getTranslator(this.response_metadata.model_provider);\n      if (translator) {\n        return translator.translateContent(this);\n      }\n    }\n\n    const blocks = super.contentBlocks;\n\n    if (this.tool_calls) {\n      const missingToolCalls = this.tool_calls.filter(\n        (block) =>\n          !blocks.some((b) => b.id === block.id && b.name === block.name)\n      );\n      blocks.push(\n        ...missingToolCalls.map((block) => ({\n          ...block,\n          type: \"tool_call\" as const,\n          id: block.id,\n          name: block.name,\n          args: block.args,\n        }))\n      );\n    }\n\n    return blocks;\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_calls: this.tool_calls,\n      invalid_tool_calls: this.invalid_tool_calls,\n      usage_metadata: this.usage_metadata,\n    };\n  }\n\n  static isInstance(obj: unknown): obj is AIMessage {\n    return super.isInstance(obj) && obj.type === \"ai\";\n  }\n}\n\n/**\n * @deprecated Use {@link AIMessage.isInstance} instead\n */\nexport function isAIMessage<TStructure extends MessageStructure>(\n  x: BaseMessage\n): x is AIMessage<TStructure> {\n  return x._getType() === \"ai\";\n}\n\n/**\n * @deprecated Use {@link AIMessageChunk.isInstance} instead\n */\nexport function isAIMessageChunk<TStructure extends MessageStructure>(\n  x: BaseMessageChunk\n): x is AIMessageChunk<TStructure> {\n  return x._getType() === \"ai\";\n}\n\nexport type AIMessageChunkFields<\n  TStructure extends MessageStructure = MessageStructure\n> = AIMessageFields<TStructure> & {\n  tool_call_chunks?: ToolCallChunk[];\n};\n\n/**\n * Represents a chunk of an AI message, which can be concatenated with\n * other AI message chunks.\n */\nexport class AIMessageChunk<\n    TStructure extends MessageStructure = MessageStructure\n  >\n  extends BaseMessageChunk<TStructure, \"ai\">\n  implements AIMessage<TStructure>, AIMessageChunkFields<TStructure>\n{\n  readonly type = \"ai\" as const;\n\n  tool_calls?: ToolCall[] = [];\n\n  invalid_tool_calls?: InvalidToolCall[] = [];\n\n  tool_call_chunks?: ToolCallChunk[] = [];\n\n  usage_metadata?: AIMessageChunkFields<TStructure>[\"usage_metadata\"];\n\n  constructor(\n    fields:\n      | $InferMessageContent<TStructure, \"ai\">\n      | AIMessageChunkFields<TStructure>\n  ) {\n    let initParams: AIMessageChunkFields<TStructure>;\n    if (typeof fields === \"string\" || Array.isArray(fields)) {\n      initParams = {\n        content: fields,\n        tool_calls: [],\n        invalid_tool_calls: [],\n        tool_call_chunks: [],\n      };\n    } else if (\n      fields.tool_call_chunks === undefined ||\n      fields.tool_call_chunks.length === 0\n    ) {\n      initParams = {\n        ...fields,\n        tool_calls: fields.tool_calls ?? [],\n        invalid_tool_calls: [],\n        tool_call_chunks: [],\n        usage_metadata:\n          fields.usage_metadata !== undefined\n            ? fields.usage_metadata\n            : undefined,\n      };\n    } else {\n      initParams = {\n        ...fields,\n        ...collapseToolCallChunks(fields.tool_call_chunks ?? []),\n        usage_metadata:\n          fields.usage_metadata !== undefined\n            ? fields.usage_metadata\n            : undefined,\n      };\n    }\n    // Sadly, TypeScript only allows super() calls at root if the class has\n    // properties with initializers, so we have to check types twice.\n    super(initParams);\n    this.tool_call_chunks =\n      initParams.tool_call_chunks ?? this.tool_call_chunks;\n    this.tool_calls = initParams.tool_calls ?? this.tool_calls;\n    this.invalid_tool_calls =\n      initParams.invalid_tool_calls ?? this.invalid_tool_calls;\n    this.usage_metadata = initParams.usage_metadata;\n  }\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      ...super.lc_aliases,\n      tool_calls: \"tool_calls\",\n      invalid_tool_calls: \"invalid_tool_calls\",\n      tool_call_chunks: \"tool_call_chunks\",\n    };\n  }\n\n  static lc_name() {\n    return \"AIMessageChunk\";\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    if (\n      this.response_metadata &&\n      \"output_version\" in this.response_metadata &&\n      this.response_metadata.output_version === \"v1\"\n    ) {\n      return this.content as Array<ContentBlock.Standard>;\n    }\n\n    if (\n      this.response_metadata &&\n      \"model_provider\" in this.response_metadata &&\n      typeof this.response_metadata.model_provider === \"string\"\n    ) {\n      const translator = getTranslator(this.response_metadata.model_provider);\n      if (translator) {\n        return translator.translateContent(this);\n      }\n    }\n\n    const blocks = super.contentBlocks;\n\n    if (this.tool_calls) {\n      if (typeof this.content !== \"string\") {\n        const contentToolCalls = this.content\n          .filter((block) => block.type === \"tool_call\")\n          .map((block) => block.id);\n        for (const toolCall of this.tool_calls) {\n          if (toolCall.id && !contentToolCalls.includes(toolCall.id)) {\n            blocks.push({\n              ...toolCall,\n              type: \"tool_call\",\n              id: toolCall.id,\n              name: toolCall.name,\n              args: toolCall.args,\n            });\n          }\n        }\n      }\n    }\n\n    return blocks;\n  }\n\n  override get _printableFields(): Record<string, unknown> {\n    return {\n      ...super._printableFields,\n      tool_calls: this.tool_calls,\n      tool_call_chunks: this.tool_call_chunks,\n      invalid_tool_calls: this.invalid_tool_calls,\n      usage_metadata: this.usage_metadata,\n    };\n  }\n\n  concat(chunk: AIMessageChunk<TStructure>) {\n    const combinedFields: AIMessageChunkFields = {\n      content: mergeContent(this.content, chunk.content),\n      additional_kwargs: _mergeDicts(\n        this.additional_kwargs,\n        chunk.additional_kwargs\n      ),\n      response_metadata: mergeResponseMetadata(\n        this.response_metadata,\n        chunk.response_metadata\n      ),\n      tool_call_chunks: [],\n      id: this.id ?? chunk.id,\n    };\n    if (\n      this.tool_call_chunks !== undefined ||\n      chunk.tool_call_chunks !== undefined\n    ) {\n      const rawToolCalls = _mergeLists(\n        this.tool_call_chunks as ContentBlock.Tools.ToolCallChunk[],\n        chunk.tool_call_chunks as ContentBlock.Tools.ToolCallChunk[]\n      );\n      if (rawToolCalls !== undefined && rawToolCalls.length > 0) {\n        combinedFields.tool_call_chunks = rawToolCalls;\n      }\n    }\n    if (\n      this.usage_metadata !== undefined ||\n      chunk.usage_metadata !== undefined\n    ) {\n      combinedFields.usage_metadata = mergeUsageMetadata(\n        this.usage_metadata,\n        chunk.usage_metadata\n      );\n    }\n    const Cls = this.constructor as Constructor<this>;\n    return new Cls(combinedFields);\n  }\n\n  static isInstance(obj: unknown): obj is AIMessageChunk {\n    return super.isInstance(obj) && obj.type === \"ai\";\n  }\n}\n"],"mappings":"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"}