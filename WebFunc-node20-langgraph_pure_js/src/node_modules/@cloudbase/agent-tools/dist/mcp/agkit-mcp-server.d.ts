/**
 * AG-Kit MCP Server
 *
 * A unified MCP server that directly exposes AG-Kit tools via the MCP protocol.
 * For HTTP transports, provides transport instances for integration with any HTTP server.
 */
import { z } from "zod/v4";
import { SSEServerTransport } from "@modelcontextprotocol/sdk/server/sse.js";
import { StreamableHTTPServerTransport } from "@modelcontextprotocol/sdk/server/streamableHttp.js";
import { BaseTool } from "../utils";
import { MCPToolMetadata, MCPEventListener } from "./types";
import type { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
export interface Transport {
    start?(): Promise<void>;
    close(): Promise<void>;
    onMessage?(handler: (message: any) => void): void;
    send?(message: any): Promise<void>;
}
export interface AGKitMCPServerConfig {
    name: string;
    version: string;
    description?: string;
    enableLogging?: boolean;
    includeMetadata?: boolean;
    errorHandling?: "throw" | "return_error";
    transformInput?: (input: any) => any;
    transformOutput?: (output: any) => any;
}
interface MCPToolConfig {
    name?: string;
    description?: string;
    namePrefix?: string;
}
export type MCPTransportType = "stdio" | "memory" | "sse" | "streamableHttp";
interface HTTPResponse {
    writeHead(statusCode: number, headers?: Record<string, string>): void;
    write(chunk: string): void;
    end(data?: string): void;
    flushHeaders?(): void;
    on?(event: string, listener: (...args: any[]) => void): void;
}
/**
 * Factory function for creating SSE transport instances
 */
export interface SSETransportFactory {
    (endpoint: string, response: HTTPResponse, options?: {
        enableDnsRebindingProtection?: boolean;
        allowedHosts?: string[];
        allowedOrigins?: string[];
    }): Promise<SSEServerTransport>;
}
/**
 * Factory function for creating StreamableHTTP transport instances
 */
export interface StreamableHTTPTransportFactory {
    (options?: {
        enableJsonResponse?: boolean;
        enableDnsRebindingProtection?: boolean;
        allowedHosts?: string[];
        allowedOrigins?: string[];
        sessionIdGenerator?: () => string;
    }): Promise<StreamableHTTPServerTransport>;
}
/**
 * Callback function for setting up SSE transport with user's HTTP server
 */
export interface SSETransportSetup {
    (server: AGKitMCPServer, createTransport: SSETransportFactory): Promise<void> | void;
}
/**
 * Callback function for setting up StreamableHTTP transport with user's HTTP server
 */
export interface StreamableHTTPTransportSetup {
    (server: AGKitMCPServer, createTransport: StreamableHTTPTransportFactory): Promise<void> | void;
}
export interface MCPTransportConfig {
    type: MCPTransportType;
    memoryId?: string;
    sseSetup?: SSETransportSetup;
    streamableHttpSetup?: StreamableHTTPTransportSetup;
}
export declare class MemoryTransportRegistry {
    private static instance;
    private transports;
    private servers;
    static getInstance(): MemoryTransportRegistry;
    registerServer(memoryId: string, server: AGKitMCPServer): void;
    unregisterServer(memoryId: string): void;
    getServer(memoryId: string): AGKitMCPServer | undefined;
    /**
     * Creates a pair of InMemory transports (server and client)
     * Uses official InMemoryTransport.createLinkedPair()
     */
    createTransportPair(memoryId: string): {
        server: any;
        client: any;
    };
    /**
     * Gets the client transport for client connections
     */
    getClientTransport(memoryId: string): any;
    /**
     * Gets the server-side transport
     */
    getServerTransport(memoryId: string): any;
    callTool(memoryId: string, toolName: string, args: Record<string, any>): Promise<CallToolResult>;
    listTools(memoryId: string): Promise<Array<{
        name: string;
        description: string;
        inputSchema: any;
    }>>;
}
/**
 * Converts a zod schema to MCP JSON schema format
 */
export declare function zodSchemaToMCPSchema(zodSchema: z.ZodSchema<any>): any;
/**
 * Converts AG-Kit BaseTool to MCP tool metadata
 */
export declare function convertAGKitToolToMCPMetadata(tool: BaseTool, config?: AGKitMCPServerConfig, toolConfig?: MCPToolConfig): MCPToolMetadata;
/**
 * AG-Kit MCP Server
 *
 * A unified server that directly handles AG-Kit tools and MCP protocol
 */
export declare class AGKitMCPServer {
    private server;
    private config;
    private tools;
    private toolConfigs;
    private eventListeners;
    private isRunning;
    private currentTransport;
    private transportType;
    private memoryId?;
    constructor(config?: AGKitMCPServerConfig);
    /**
     * Setup MCP server request handlers
     */
    private setupServerHandlers;
    /**
     * Register an AG-Kit tool with the server
     * @param tool - The AG-Kit tool instance to register
     * @param toolConfig - Optional configuration for the tool (name, description, etc.)
     * @returns The MCP metadata for the registered tool
     */
    registerTool(tool: BaseTool, toolConfig?: MCPToolConfig): MCPToolMetadata;
    /**
     * Register multiple AG-Kit tools
     */
    registerTools(tools: BaseTool[], toolConfig?: MCPToolConfig): MCPToolMetadata[];
    /**
     * Unregister a tool
     */
    unregisterTool(name: string): boolean;
    /**
     * Execute a tool via MCP call format
     */
    callTool(name: string, args: Record<string, any>): Promise<CallToolResult>;
    /**
     * Get all registered tool metadata
     */
    getToolsMetadata(): MCPToolMetadata[];
    /**
     * List all registered tools in MCP format
     */
    listTools(): Array<{
        name: string;
        description: string;
        inputSchema: any;
    }>;
    /**
     * Get specific tool metadata
     */
    getToolMetadata(name: string): MCPToolMetadata | null;
    /**
     * Check if a tool is registered
     */
    hasTool(name: string): boolean;
    /**
     * Get list of available tool names
     */
    getAvailableTools(): string[];
    /**
     * Get tool statistics
     */
    getStats(): {
        totalTools: number;
        toolNames: string[];
        toolTypes: Record<string, number>;
        isRunning: boolean;
        serverInfo: {
            name: string;
            version: string;
            description: string;
        };
    };
    /**
     * Start the MCP server with specified transport
     */
    run(transportConfig: MCPTransportConfig): Promise<void>;
    /**
     * Start the MCP server with stdio transport (backward compatibility)
     */
    runStdio(): Promise<void>;
    /**
     * Start the MCP server with memory transport
     */
    runMemory(memoryId?: string): Promise<void>;
    /**
     * Run with StreamableHTTP transport using user-provided setup callback
     * @param setup - Callback function to integrate with user's HTTP server
     * @param options - Optional transport configuration (deprecated - use factory function parameters)
     */
    runStreamableHttp(setup: StreamableHTTPTransportSetup, options?: {
        enableJsonResponse?: boolean;
        enableDnsRebindingProtection?: boolean;
        allowedHosts?: string[];
        allowedOrigins?: string[];
        sessionIdGenerator?: () => string;
    }): Promise<void>;
    /**
     * Run with SSE transport using user-provided setup callback
     * @param setup - Callback function to integrate with user's HTTP server
     * @param options - Optional transport configuration (deprecated - use factory function parameters)
     */
    runSSE(setup: SSETransportSetup, options?: {
        endpoint?: string;
        enableDnsRebindingProtection?: boolean;
        allowedHosts?: string[];
        allowedOrigins?: string[];
    }): Promise<void>;
    /**
     * Stop the server
     */
    stop(): Promise<void>;
    /**
     * Check if server is running
     */
    isServerRunning(): boolean;
    /**
     * Get current transport type
     */
    getTransportType(): MCPTransportType | null;
    /**
     * Get memory ID (for memory transport)
     */
    getMemoryId(): string | undefined;
    /**
     * Get server connection info
     */
    getConnectionInfo(): {
        isRunning: boolean;
        transportType: MCPTransportType | null;
        memoryId?: string;
    };
    /**
     * Add event listener
     */
    addEventListener(listener: MCPEventListener): void;
    /**
     * Remove event listener
     */
    removeEventListener(listener: MCPEventListener): boolean;
    /**
     * Emit event to all listeners
     */
    private emit;
    /**
     * Update server configuration
     */
    updateConfig(newConfig: Partial<AGKitMCPServerConfig>): void;
    /**
     * Get current configuration
     */
    getConfig(): AGKitMCPServerConfig;
    /**
     * Clear all registered tools
     */
    clearTools(): void;
}
/**
 * Utility function to create and start an AG-Kit MCP server
 */
export declare function createAGKitMCPServer(config: AGKitMCPServerConfig, tools?: BaseTool[]): Promise<AGKitMCPServer>;
/**
 * Global memory transport registry instance
 */
export declare const memoryTransportRegistry: MemoryTransportRegistry;
export {};
//# sourceMappingURL=agkit-mcp-server.d.ts.map