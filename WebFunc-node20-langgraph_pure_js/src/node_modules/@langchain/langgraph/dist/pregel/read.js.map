{"version":3,"file":"read.js","names":[],"sources":["../../src/pregel/read.ts"],"sourcesContent":["import {\n  Runnable,\n  RunnableBinding,\n  RunnableBindingArgs,\n  RunnableConfig,\n  RunnablePassthrough,\n  RunnableSequence,\n  _coerceToRunnable,\n  type RunnableLike,\n} from \"@langchain/core/runnables\";\nimport { CONFIG_KEY_READ } from \"../constants.js\";\nimport { ChannelWrite } from \"./write.js\";\nimport { RunnableCallable } from \"../utils.js\";\nimport type { CachePolicy, RetryPolicy } from \"./utils/index.js\";\n\nexport class ChannelRead<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any\n> extends RunnableCallable {\n  lc_graph_name = \"ChannelRead\";\n\n  channel: string | Array<string>;\n\n  fresh: boolean = false;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper?: (args: any) => any;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(\n    channel: string | Array<string>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    mapper?: (args: any) => any,\n    fresh: boolean = false\n  ) {\n    super({\n      func: (_: RunInput, config: RunnableConfig) =>\n        ChannelRead.doRead(config, this.channel, this.fresh, this.mapper),\n    });\n    this.fresh = fresh;\n    this.mapper = mapper;\n    this.channel = channel;\n    this.name = Array.isArray(channel)\n      ? `ChannelRead<${channel.join(\",\")}>`\n      : `ChannelRead<${channel}>`;\n  }\n\n  static doRead<T = unknown>(\n    config: RunnableConfig,\n    channel: string | Array<string>,\n    fresh: boolean,\n    mapper?: (args: unknown) => unknown\n  ): T {\n    const read: (arg: string | string[], fresh: boolean) => unknown =\n      config.configurable?.[CONFIG_KEY_READ];\n    if (!read) {\n      throw new Error(\n        \"Runnable is not configured with a read function. Make sure to call in the context of a Pregel process\"\n      );\n    }\n    if (mapper) {\n      return mapper(read(channel, fresh)) as T;\n    } else {\n      return read(channel, fresh) as T;\n    }\n  }\n}\n\nconst defaultRunnableBound =\n  /* #__PURE__ */ new RunnablePassthrough<PregelNodeInputType>();\n\ninterface PregelNodeArgs<RunInput, RunOutput>\n  extends Partial<RunnableBindingArgs<RunInput, RunOutput>> {\n  channels: Record<string, string> | string[];\n  triggers: Array<string>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper?: (args: any) => any;\n  writers?: Runnable<RunOutput, unknown>[];\n  tags?: string[];\n  bound?: Runnable<RunInput, RunOutput>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  kwargs?: Record<string, any>;\n  config?: RunnableConfig;\n  metadata?: Record<string, unknown>;\n  retryPolicy?: RetryPolicy;\n  cachePolicy?: CachePolicy;\n  subgraphs?: Runnable[];\n  ends?: string[];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelNodeInputType = any;\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport type PregelNodeOutputType = any;\n\nexport class PregelNode<\n  RunInput = PregelNodeInputType,\n  RunOutput = PregelNodeOutputType\n> extends RunnableBinding<RunInput, RunOutput, RunnableConfig> {\n  lc_graph_name = \"PregelNode\";\n\n  channels: Record<string, string> | string[];\n\n  triggers: string[] = [];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  mapper?: (args: any) => any;\n\n  writers: Runnable[] = [];\n\n  bound: Runnable<RunInput, RunOutput> = defaultRunnableBound;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  kwargs: Record<string, any> = {};\n\n  metadata: Record<string, unknown> = {};\n\n  tags: string[] = [];\n\n  retryPolicy?: RetryPolicy;\n\n  cachePolicy?: CachePolicy;\n\n  subgraphs?: Runnable[];\n\n  ends?: string[];\n\n  constructor(fields: PregelNodeArgs<RunInput, RunOutput>) {\n    const {\n      channels,\n      triggers,\n      mapper,\n      writers,\n      bound,\n      kwargs,\n      metadata,\n      retryPolicy,\n      cachePolicy,\n      tags,\n      subgraphs,\n      ends,\n    } = fields;\n    const mergedTags = [\n      ...(fields.config?.tags ? fields.config.tags : []),\n      ...(tags ?? []),\n    ];\n\n    super({\n      ...fields,\n      bound:\n        fields.bound ??\n        (defaultRunnableBound as unknown as Runnable<RunInput, RunOutput>),\n      config: {\n        ...(fields.config ? fields.config : {}),\n        tags: mergedTags,\n      },\n    });\n\n    this.channels = channels;\n    this.triggers = triggers;\n    this.mapper = mapper;\n    this.writers = writers ?? this.writers;\n    this.bound = bound ?? this.bound;\n    this.kwargs = kwargs ?? this.kwargs;\n    this.metadata = metadata ?? this.metadata;\n    this.tags = mergedTags;\n    this.retryPolicy = retryPolicy;\n    this.cachePolicy = cachePolicy;\n    this.subgraphs = subgraphs;\n    this.ends = ends;\n  }\n\n  getWriters(): Array<Runnable> {\n    const newWriters = [...this.writers];\n    while (\n      newWriters.length > 1 &&\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      newWriters[newWriters.length - 1] instanceof ChannelWrite &&\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      newWriters[newWriters.length - 2] instanceof ChannelWrite\n    ) {\n      // we can combine writes if they are consecutive\n      // careful to not modify the original writers list or ChannelWrite\n      const endWriters = newWriters.slice(-2) as ChannelWrite[];\n      const combinedWrites = endWriters[0].writes.concat(endWriters[1].writes);\n      newWriters[newWriters.length - 2] = new ChannelWrite(\n        combinedWrites,\n        endWriters[0].config?.tags\n      );\n      newWriters.pop();\n    }\n    return newWriters;\n  }\n\n  getNode(): Runnable<RunInput, RunOutput> | undefined {\n    const writers = this.getWriters();\n    if (this.bound === defaultRunnableBound && writers.length === 0) {\n      return undefined;\n    } else if (this.bound === defaultRunnableBound && writers.length === 1) {\n      return writers[0];\n    } else if (this.bound === defaultRunnableBound) {\n      return new RunnableSequence({\n        first: writers[0],\n        middle: writers.slice(1, writers.length - 1),\n        last: writers[writers.length - 1],\n        omitSequenceTags: true,\n      });\n    } else if (writers.length > 0) {\n      return new RunnableSequence({\n        first: this.bound,\n        middle: writers.slice(0, writers.length - 1),\n        last: writers[writers.length - 1],\n        omitSequenceTags: true,\n      });\n    } else {\n      return this.bound;\n    }\n  }\n\n  join(channels: Array<string>): PregelNode<RunInput, RunOutput> {\n    if (!Array.isArray(channels)) {\n      throw new Error(\"channels must be a list\");\n    }\n    if (typeof this.channels !== \"object\") {\n      throw new Error(\"all channels must be named when using .join()\");\n    }\n\n    return new PregelNode<RunInput, RunOutput>({\n      channels: {\n        ...this.channels,\n        ...Object.fromEntries(channels.map((chan) => [chan, chan])),\n      },\n      triggers: this.triggers,\n      mapper: this.mapper,\n      writers: this.writers,\n      bound: this.bound,\n      kwargs: this.kwargs,\n      config: this.config,\n      retryPolicy: this.retryPolicy,\n      cachePolicy: this.cachePolicy,\n    });\n  }\n\n  pipe<NewRunOutput>(\n    coerceable: RunnableLike\n  ): PregelNode<RunInput, Exclude<NewRunOutput, Error>> {\n    if (ChannelWrite.isWriter(coerceable)) {\n      return new PregelNode<RunInput, Exclude<NewRunOutput, Error>>({\n        channels: this.channels,\n        triggers: this.triggers,\n        mapper: this.mapper,\n        writers: [...this.writers, coerceable],\n        bound: this.bound as unknown as PregelNode<\n          RunInput,\n          Exclude<NewRunOutput, Error>\n        >,\n        config: this.config,\n        kwargs: this.kwargs,\n        retryPolicy: this.retryPolicy,\n        cachePolicy: this.cachePolicy,\n      });\n    } else if (this.bound === defaultRunnableBound) {\n      return new PregelNode<RunInput, Exclude<NewRunOutput, Error>>({\n        channels: this.channels,\n        triggers: this.triggers,\n        mapper: this.mapper,\n        writers: this.writers,\n        bound: _coerceToRunnable<RunInput, NewRunOutput>(coerceable),\n        config: this.config,\n        kwargs: this.kwargs,\n        retryPolicy: this.retryPolicy,\n        cachePolicy: this.cachePolicy,\n      });\n    } else {\n      return new PregelNode<RunInput, Exclude<NewRunOutput, Error>>({\n        channels: this.channels,\n        triggers: this.triggers,\n        mapper: this.mapper,\n        writers: this.writers,\n        bound: this.bound.pipe(coerceable),\n        config: this.config,\n        kwargs: this.kwargs,\n        retryPolicy: this.retryPolicy,\n        cachePolicy: this.cachePolicy,\n      });\n    }\n  }\n}\n"],"mappings":"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"}