"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/express.ts
var express_exports = {};
__export(express_exports, {
  createCopilotEndpointExpress: () => createCopilotEndpointExpress,
  createCopilotEndpointSingleRouteExpress: () => createCopilotEndpointSingleRouteExpress
});
module.exports = __toCommonJS(express_exports);

// src/endpoints/express.ts
var import_express = __toESM(require("express"));
var import_cors = __toESM(require("cors"));

// src/handlers/handle-run.ts
var import_client = require("@ag-ui/client");
var import_encoder = require("@ag-ui/encoder");

// src/handlers/header-utils.ts
function shouldForwardHeader(headerName) {
  const lower = headerName.toLowerCase();
  return lower === "authorization" || lower.startsWith("x-");
}
function extractForwardableHeaders(request) {
  const forwardableHeaders = {};
  request.headers.forEach((value, key) => {
    if (shouldForwardHeader(key)) {
      forwardableHeaders[key] = value;
    }
  });
  return forwardableHeaders;
}

// src/handlers/handle-run.ts
async function handleRunAgent({
  runtime,
  request,
  agentId
}) {
  try {
    const agents = await runtime.agents;
    if (!agents[agentId]) {
      return new Response(
        JSON.stringify({
          error: "Agent not found",
          message: `Agent '${agentId}' does not exist`
        }),
        {
          status: 404,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    const registeredAgent = agents[agentId];
    const agent = registeredAgent.clone();
    if (agent && "headers" in agent) {
      const forwardableHeaders = extractForwardableHeaders(request);
      agent.headers = {
        ...agent.headers,
        ...forwardableHeaders
      };
    }
    const stream = new TransformStream();
    const writer = stream.writable.getWriter();
    const encoder = new import_encoder.EventEncoder();
    let streamClosed = false;
    (async () => {
      let input;
      try {
        const requestBody = await request.json();
        input = import_client.RunAgentInputSchema.parse(requestBody);
      } catch {
        return new Response(
          JSON.stringify({
            error: "Invalid request body"
          }),
          { status: 400 }
        );
      }
      agent.setMessages(input.messages);
      agent.setState(input.state);
      agent.threadId = input.threadId;
      runtime.runner.run({
        threadId: input.threadId,
        agent,
        input
      }).subscribe({
        next: async (event) => {
          if (!request.signal.aborted && !streamClosed) {
            try {
              await writer.write(encoder.encode(event));
            } catch (error) {
              if (error instanceof Error && error.name === "AbortError") {
                streamClosed = true;
              }
            }
          }
        },
        error: async (error) => {
          console.error("Error running agent:", error);
          if (!streamClosed) {
            try {
              await writer.close();
              streamClosed = true;
            } catch {
            }
          }
        },
        complete: async () => {
          if (!streamClosed) {
            try {
              await writer.close();
              streamClosed = true;
            } catch {
            }
          }
        }
      });
    })().catch((error) => {
      console.error("Error running agent:", error);
      console.error(
        "Error stack:",
        error instanceof Error ? error.stack : "No stack trace"
      );
      console.error("Error details:", {
        name: error instanceof Error ? error.name : "Unknown",
        message: error instanceof Error ? error.message : String(error),
        cause: error instanceof Error ? error.cause : void 0
      });
      if (!streamClosed) {
        try {
          writer.close();
          streamClosed = true;
        } catch {
        }
      }
    });
    return new Response(stream.readable, {
      status: 200,
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive"
      }
    });
  } catch (error) {
    console.error("Error running agent:", error);
    console.error(
      "Error stack:",
      error instanceof Error ? error.stack : "No stack trace"
    );
    console.error("Error details:", {
      name: error instanceof Error ? error.name : "Unknown",
      message: error instanceof Error ? error.message : String(error),
      cause: error instanceof Error ? error.cause : void 0
    });
    return new Response(
      JSON.stringify({
        error: "Failed to run agent",
        message: error instanceof Error ? error.message : "Unknown error"
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}

// src/handlers/handle-connect.ts
var import_client2 = require("@ag-ui/client");
var import_encoder2 = require("@ag-ui/encoder");
async function handleConnectAgent({
  runtime,
  request,
  agentId
}) {
  try {
    const agents = await runtime.agents;
    if (!agents[agentId]) {
      return new Response(
        JSON.stringify({
          error: "Agent not found",
          message: `Agent '${agentId}' does not exist`
        }),
        {
          status: 404,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    const stream = new TransformStream();
    const writer = stream.writable.getWriter();
    const encoder = new import_encoder2.EventEncoder();
    let streamClosed = false;
    (async () => {
      let input;
      try {
        const requestBody = await request.json();
        input = import_client2.RunAgentInputSchema.parse(requestBody);
      } catch {
        return new Response(
          JSON.stringify({
            error: "Invalid request body"
          }),
          { status: 400 }
        );
      }
      const forwardableHeaders = extractForwardableHeaders(request);
      runtime.runner.connect({
        threadId: input.threadId,
        headers: forwardableHeaders
      }).subscribe({
        next: async (event) => {
          if (!request.signal.aborted && !streamClosed) {
            try {
              await writer.write(encoder.encode(event));
            } catch (error) {
              if (error instanceof Error && error.name === "AbortError") {
                streamClosed = true;
              }
            }
          }
        },
        error: async (error) => {
          console.error("Error running agent:", error);
          if (!streamClosed) {
            try {
              await writer.close();
              streamClosed = true;
            } catch {
            }
          }
        },
        complete: async () => {
          if (!streamClosed) {
            try {
              await writer.close();
              streamClosed = true;
            } catch {
            }
          }
        }
      });
    })().catch((error) => {
      console.error("Error running agent:", error);
      console.error(
        "Error stack:",
        error instanceof Error ? error.stack : "No stack trace"
      );
      console.error("Error details:", {
        name: error instanceof Error ? error.name : "Unknown",
        message: error instanceof Error ? error.message : String(error),
        cause: error instanceof Error ? error.cause : void 0
      });
      if (!streamClosed) {
        try {
          writer.close();
          streamClosed = true;
        } catch {
        }
      }
    });
    return new Response(stream.readable, {
      status: 200,
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive"
      }
    });
  } catch (error) {
    console.error("Error running agent:", error);
    console.error(
      "Error stack:",
      error instanceof Error ? error.stack : "No stack trace"
    );
    console.error("Error details:", {
      name: error instanceof Error ? error.name : "Unknown",
      message: error instanceof Error ? error.message : String(error),
      cause: error instanceof Error ? error.cause : void 0
    });
    return new Response(
      JSON.stringify({
        error: "Failed to run agent",
        message: error instanceof Error ? error.message : "Unknown error"
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}

// src/handlers/handle-stop.ts
var import_client3 = require("@ag-ui/client");
async function handleStopAgent({
  runtime,
  request,
  agentId,
  threadId
}) {
  try {
    const agents = await runtime.agents;
    if (!agents[agentId]) {
      return new Response(
        JSON.stringify({
          error: "Agent not found",
          message: `Agent '${agentId}' does not exist`
        }),
        {
          status: 404,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    const stopped = await runtime.runner.stop({ threadId });
    if (!stopped) {
      return new Response(
        JSON.stringify({
          stopped: false,
          message: `No active run for thread '${threadId}'.`
        }),
        {
          status: 200,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    return new Response(
      JSON.stringify({
        stopped: true,
        interrupt: {
          type: import_client3.EventType.RUN_ERROR,
          message: "Run stopped by user",
          code: "STOPPED"
        }
      }),
      {
        status: 200,
        headers: { "Content-Type": "application/json" }
      }
    );
  } catch (error) {
    console.error("Error stopping agent run:", error);
    return new Response(
      JSON.stringify({
        error: "Failed to stop agent",
        message: error instanceof Error ? error.message : "Unknown error"
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}

// package.json
var package_default = {
  name: "@copilotkitnext/runtime",
  version: "1.51.3",
  description: "Server-side runtime package for CopilotKit2",
  main: "dist/index.js",
  types: "dist/index.d.ts",
  exports: {
    ".": {
      types: "./dist/index.d.ts",
      import: "./dist/index.mjs",
      require: "./dist/index.js"
    },
    "./express": {
      types: "./dist/express.d.ts",
      import: "./dist/express.mjs",
      require: "./dist/express.js"
    }
  },
  publishConfig: {
    access: "public"
  },
  scripts: {
    build: "tsup",
    dev: "tsup --watch",
    lint: "eslint .",
    "check-types": "tsc --noEmit",
    clean: "rm -rf dist",
    test: "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  devDependencies: {
    "@copilotkitnext/eslint-config": "workspace:*",
    "@copilotkitnext/typescript-config": "workspace:*",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/node": "^22.15.3",
    eslint: "^9.30.0",
    supertest: "^7.1.1",
    tsup: "^8.5.0",
    typescript: "5.8.2",
    vitest: "^3.0.5"
  },
  dependencies: {
    "@ag-ui/client": "0.0.42",
    "@ag-ui/core": "0.0.42",
    "@ag-ui/encoder": "0.0.42",
    "@copilotkitnext/shared": "workspace:*",
    cors: "^2.8.5",
    express: "^4.21.2",
    hono: "^4.11.4",
    rxjs: "7.8.1"
  },
  peerDependencies: {
    "@ag-ui/client": "0.0.42",
    "@ag-ui/core": "0.0.42",
    "@ag-ui/encoder": "0.0.42",
    "@copilotkitnext/shared": "workspace:*"
  },
  peerDependenciesMeta: {},
  engines: {
    node: ">=18"
  }
};

// src/runner/in-memory.ts
var import_rxjs = require("rxjs");
var import_client4 = require("@ag-ui/client");
var import_shared = require("@copilotkitnext/shared");
var InMemoryEventStore = class {
  constructor(threadId) {
    this.threadId = threadId;
  }
  /** The subject that current consumers subscribe to. */
  subject = null;
  /** True while a run is actively producing events. */
  isRunning = false;
  /** Current run ID */
  currentRunId = null;
  /** Historic completed runs */
  historicRuns = [];
  /** Currently running agent instance (if any). */
  agent = null;
  /** Subject returned from run() while the run is active. */
  runSubject = null;
  /** True once stop() has been requested but the run has not yet finalized. */
  stopRequested = false;
  /** Reference to the events emitted in the current run. */
  currentEvents = null;
};
var GLOBAL_STORE_KEY = /* @__PURE__ */ Symbol.for("@copilotkitnext/runtime/in-memory-store");
function getGlobalStore() {
  const globalAny = globalThis;
  if (!globalAny[GLOBAL_STORE_KEY]) {
    globalAny[GLOBAL_STORE_KEY] = {
      stores: /* @__PURE__ */ new Map(),
      historicRunsBackup: /* @__PURE__ */ new Map()
    };
  }
  const data = globalAny[GLOBAL_STORE_KEY];
  if (data.stores.size === 0 && data.historicRunsBackup.size > 0) {
    for (const [threadId, historicRuns] of data.historicRunsBackup) {
      const store = new InMemoryEventStore(threadId);
      store.historicRuns = historicRuns;
      data.stores.set(threadId, store);
    }
  }
  return data.stores;
}
var GLOBAL_STORE = getGlobalStore();

// src/runtime.ts
var VERSION = package_default.version;

// src/handlers/get-runtime-info.ts
async function handleGetRuntimeInfo({
  runtime
}) {
  try {
    const agents = await runtime.agents;
    const agentsDict = Object.entries(agents).reduce(
      (acc, [name, agent]) => {
        acc[name] = {
          name,
          description: agent.description,
          className: agent.constructor.name
        };
        return acc;
      },
      {}
    );
    const runtimeInfo = {
      version: VERSION,
      agents: agentsDict,
      audioFileTranscriptionEnabled: !!runtime.transcriptionService
    };
    return new Response(JSON.stringify(runtimeInfo), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    return new Response(
      JSON.stringify({
        error: "Failed to retrieve runtime information",
        message: error instanceof Error ? error.message : "Unknown error"
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}

// src/handlers/handle-transcribe.ts
var import_shared2 = require("@copilotkitnext/shared");
var ERROR_STATUS_CODES = {
  [import_shared2.TranscriptionErrorCode.SERVICE_NOT_CONFIGURED]: 503,
  [import_shared2.TranscriptionErrorCode.INVALID_AUDIO_FORMAT]: 400,
  [import_shared2.TranscriptionErrorCode.AUDIO_TOO_LONG]: 400,
  [import_shared2.TranscriptionErrorCode.AUDIO_TOO_SHORT]: 400,
  [import_shared2.TranscriptionErrorCode.RATE_LIMITED]: 429,
  [import_shared2.TranscriptionErrorCode.AUTH_FAILED]: 401,
  [import_shared2.TranscriptionErrorCode.PROVIDER_ERROR]: 500,
  [import_shared2.TranscriptionErrorCode.NETWORK_ERROR]: 502,
  [import_shared2.TranscriptionErrorCode.INVALID_REQUEST]: 400
};
var VALID_AUDIO_TYPES = [
  "audio/mpeg",
  "audio/mp3",
  "audio/mp4",
  "audio/wav",
  "audio/webm",
  "audio/ogg",
  "audio/flac",
  "audio/aac"
];
function isValidAudioType(type) {
  const baseType = type.split(";")[0]?.trim() ?? "";
  return VALID_AUDIO_TYPES.includes(baseType) || baseType === "" || baseType === "application/octet-stream";
}
function createErrorResponse(errorResponse) {
  const status = ERROR_STATUS_CODES[errorResponse.error] ?? 500;
  return new Response(JSON.stringify(errorResponse), {
    status,
    headers: { "Content-Type": "application/json" }
  });
}
function base64ToFile(base64, mimeType, filename) {
  const base64Data = base64.includes(",") ? base64.split(",")[1] ?? base64 : base64;
  const binaryString = atob(base64Data);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return new File([bytes], filename, { type: mimeType });
}
async function extractAudioFromFormData(request) {
  const formData = await request.formData();
  const audioFile = formData.get("audio");
  if (!audioFile || !(audioFile instanceof File)) {
    const err = import_shared2.TranscriptionErrors.invalidRequest(
      "No audio file found in form data. Please include an 'audio' field."
    );
    return { error: createErrorResponse(err) };
  }
  if (!isValidAudioType(audioFile.type)) {
    const err = import_shared2.TranscriptionErrors.invalidAudioFormat(audioFile.type, VALID_AUDIO_TYPES);
    return { error: createErrorResponse(err) };
  }
  return { file: audioFile };
}
async function extractAudioFromJson(request) {
  let body;
  try {
    body = await request.json();
  } catch {
    const err = import_shared2.TranscriptionErrors.invalidRequest("Request body must be valid JSON");
    return { error: createErrorResponse(err) };
  }
  if (!body.audio || typeof body.audio !== "string") {
    const err = import_shared2.TranscriptionErrors.invalidRequest(
      "Request must include 'audio' field with base64-encoded audio data"
    );
    return { error: createErrorResponse(err) };
  }
  if (!body.mimeType || typeof body.mimeType !== "string") {
    const err = import_shared2.TranscriptionErrors.invalidRequest(
      "Request must include 'mimeType' field (e.g., 'audio/webm')"
    );
    return { error: createErrorResponse(err) };
  }
  if (!isValidAudioType(body.mimeType)) {
    const err = import_shared2.TranscriptionErrors.invalidAudioFormat(body.mimeType, VALID_AUDIO_TYPES);
    return { error: createErrorResponse(err) };
  }
  try {
    const filename = body.filename || "recording.webm";
    const file = base64ToFile(body.audio, body.mimeType, filename);
    return { file };
  } catch {
    const err = import_shared2.TranscriptionErrors.invalidRequest("Failed to decode base64 audio data");
    return { error: createErrorResponse(err) };
  }
}
function categorizeProviderError(error) {
  const message = error instanceof Error ? error.message : "Unknown error occurred";
  const errorStr = String(error).toLowerCase();
  if (errorStr.includes("rate") || errorStr.includes("429") || errorStr.includes("too many")) {
    return import_shared2.TranscriptionErrors.rateLimited();
  }
  if (errorStr.includes("auth") || errorStr.includes("401") || errorStr.includes("api key") || errorStr.includes("unauthorized")) {
    return import_shared2.TranscriptionErrors.authFailed();
  }
  if (errorStr.includes("too long") || errorStr.includes("duration") || errorStr.includes("length")) {
    return import_shared2.TranscriptionErrors.audioTooLong();
  }
  return import_shared2.TranscriptionErrors.providerError(message);
}
async function handleTranscribe({
  runtime,
  request
}) {
  try {
    if (!runtime.transcriptionService) {
      const err = import_shared2.TranscriptionErrors.serviceNotConfigured();
      return createErrorResponse(err);
    }
    const contentType = request.headers.get("content-type") || "";
    let extractResult;
    if (contentType.includes("multipart/form-data")) {
      extractResult = await extractAudioFromFormData(request);
    } else if (contentType.includes("application/json")) {
      extractResult = await extractAudioFromJson(request);
    } else {
      const err = import_shared2.TranscriptionErrors.invalidRequest(
        "Request must be multipart/form-data or application/json with base64 audio"
      );
      return createErrorResponse(err);
    }
    if ("error" in extractResult) {
      return extractResult.error;
    }
    const audioFile = extractResult.file;
    const transcription = await runtime.transcriptionService.transcribeFile({
      audioFile,
      mimeType: audioFile.type,
      size: audioFile.size
    });
    return new Response(
      JSON.stringify({
        text: transcription,
        size: audioFile.size,
        type: audioFile.type
      }),
      {
        status: 200,
        headers: { "Content-Type": "application/json" }
      }
    );
  } catch (error) {
    return createErrorResponse(categorizeProviderError(error));
  }
}

// src/endpoints/express.ts
var import_shared5 = require("@copilotkitnext/shared");

// src/middleware.ts
var import_shared3 = require("@copilotkitnext/shared");
async function callBeforeRequestMiddleware({
  runtime,
  request,
  path
}) {
  const mw = runtime.beforeRequestMiddleware;
  if (!mw) return;
  if (typeof mw === "function") {
    return mw({ runtime, request, path });
  }
  import_shared3.logger.warn({ mw }, "Unsupported beforeRequestMiddleware value \u2013 skipped");
  return;
}
async function callAfterRequestMiddleware({
  runtime,
  response,
  path
}) {
  const mw = runtime.afterRequestMiddleware;
  if (!mw) return;
  if (typeof mw === "function") {
    return mw({ runtime, response, path });
  }
  import_shared3.logger.warn({ mw }, "Unsupported afterRequestMiddleware value \u2013 skipped");
}

// src/endpoints/express-utils.ts
var import_node_stream = require("stream");
var import_node_stream2 = require("stream");
var import_node_util = require("util");
var import_shared4 = require("@copilotkitnext/shared");
var streamPipeline = (0, import_node_util.promisify)(import_node_stream2.pipeline);
var METHODS_WITHOUT_BODY = /* @__PURE__ */ new Set(["GET", "HEAD"]);
function createFetchRequestFromExpress(req) {
  const method = req.method?.toUpperCase() ?? "GET";
  const origin = buildOrigin(req);
  const url = `${origin}${req.originalUrl ?? req.url ?? ""}`;
  const headers = new Headers();
  for (const [key, value] of Object.entries(req.headers)) {
    if (value === void 0) continue;
    if (Array.isArray(value)) {
      value.forEach((v) => headers.append(key, v));
    } else {
      headers.set(key, value);
    }
  }
  const init = {
    method,
    headers
  };
  const hasParsedBody = req.body !== void 0 && req.body !== null;
  const streamConsumed = isStreamConsumed(req, hasParsedBody);
  if (!METHODS_WITHOUT_BODY.has(method)) {
    const canStreamBody = req.readable !== false && !streamConsumed;
    if (canStreamBody) {
      init.body = import_node_stream.Readable.toWeb(req);
      init.duplex = "half";
    } else if (hasParsedBody) {
      const { body, contentType } = synthesizeBody(req.body);
      if (contentType) {
        headers.set("content-type", contentType);
      }
      headers.delete("content-length");
      if (body !== void 0) {
        init.body = body;
      }
      import_shared4.logger.info(
        {
          url,
          method,
          readable: req.readable,
          readableEnded: req.readableEnded,
          complete: req.complete
        },
        "Express request stream already consumed; synthesized body from parsed content"
      );
    } else {
      headers.delete("content-length");
      import_shared4.logger.warn(
        { url, method },
        "Request stream already consumed but no body was available; sending empty body"
      );
    }
  }
  const controller = new AbortController();
  const abort = () => controller.abort();
  req.on("aborted", abort);
  req.on("error", abort);
  req.on("close", () => {
    if (req.aborted) {
      abort();
    }
  });
  init.signal = controller.signal;
  try {
    return new Request(url, init);
  } catch (error) {
    if (error instanceof TypeError && /disturbed|locked/i.test(error.message)) {
      headers.delete("content-length");
      delete init.duplex;
      if (hasParsedBody) {
        const { body, contentType } = synthesizeBody(req.body);
        if (contentType) {
          headers.set("content-type", contentType);
        }
        init.body = body;
        import_shared4.logger.info(
          { url, method },
          "Request stream disturbed while constructing Request; reused parsed body"
        );
      } else {
        init.body = void 0;
        import_shared4.logger.warn(
          { url, method },
          "Request stream was disturbed; falling back to empty body"
        );
      }
      return new Request(url, init);
    }
    throw error;
  }
}
async function sendFetchResponse(res, response) {
  res.status(response.status);
  response.headers.forEach((value, key) => {
    if (key.toLowerCase() === "content-length" && response.body !== null) {
      return;
    }
    res.setHeader(key, value);
  });
  if (!response.body) {
    res.end();
    return;
  }
  const nodeStream = import_node_stream.Readable.fromWeb(response.body);
  try {
    await streamPipeline(nodeStream, res);
  } catch (error) {
    res.destroy(error);
    throw error;
  }
}
function buildOrigin(req) {
  const protocol = req.protocol || (req.secure ? "https" : "http");
  const host = req.get("host") ?? "localhost";
  return `${protocol}://${host}`;
}
function isStreamConsumed(req, hasParsedBody) {
  const state = req._readableState;
  return Boolean(
    hasParsedBody || req.readableEnded || req.complete || state?.ended || state?.endEmitted
  );
}
function synthesizeBody(body) {
  if (Buffer.isBuffer(body) || body instanceof Uint8Array) {
    return { body };
  }
  if (typeof body === "string") {
    return { body };
  }
  if (typeof body === "object" && body !== void 0) {
    return { body: JSON.stringify(body), contentType: "application/json" };
  }
  return {};
}

// src/endpoints/express.ts
function createCopilotEndpointExpress({ runtime, basePath }) {
  const router = import_express.default.Router();
  const normalizedBase = normalizeBasePath(basePath);
  router.use((0, import_cors.default)({
    origin: "*",
    methods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH", "OPTIONS"],
    allowedHeaders: ["*"]
  }));
  router.post(joinPath(normalizedBase, "/agent/:agentId/run"), createRouteHandler(runtime, async ({ request, req }) => {
    const agentId = req.params.agentId;
    return handleRunAgent({ runtime, request, agentId });
  }));
  router.post(joinPath(normalizedBase, "/agent/:agentId/connect"), createRouteHandler(runtime, async ({ request, req }) => {
    const agentId = req.params.agentId;
    return handleConnectAgent({ runtime, request, agentId });
  }));
  router.post(joinPath(normalizedBase, "/agent/:agentId/stop/:threadId"), createRouteHandler(runtime, async ({ request, req }) => {
    const agentId = req.params.agentId;
    const threadId = req.params.threadId;
    return handleStopAgent({ runtime, request, agentId, threadId });
  }));
  router.get(joinPath(normalizedBase, "/info"), createRouteHandler(runtime, async ({ request }) => {
    return handleGetRuntimeInfo({ runtime, request });
  }));
  router.post(joinPath(normalizedBase, "/transcribe"), createRouteHandler(runtime, async ({ request }) => {
    return handleTranscribe({ runtime, request });
  }));
  router.use(joinPath(normalizedBase, "*"), (req, res) => {
    res.status(404).json({ error: "Not found" });
  });
  return router;
}
function createRouteHandler(runtime, factory) {
  return async (req, res, next) => {
    const path = req.originalUrl ?? req.path;
    let request = createFetchRequestFromExpress(req);
    try {
      const maybeModifiedRequest = await callBeforeRequestMiddleware({ runtime, request, path });
      if (maybeModifiedRequest) {
        request = maybeModifiedRequest;
      }
    } catch (error) {
      import_shared5.logger.error({ err: error, url: request.url, path }, "Error running before request middleware");
      if (error instanceof Response) {
        try {
          await sendFetchResponse(res, error);
        } catch (streamError) {
          next(streamError);
        }
        return;
      }
      next(error);
      return;
    }
    try {
      const response = await factory({ request, req });
      await sendFetchResponse(res, response);
      callAfterRequestMiddleware({ runtime, response, path }).catch((error) => {
        import_shared5.logger.error({ err: error, url: req.originalUrl ?? req.url, path }, "Error running after request middleware");
      });
    } catch (error) {
      if (error instanceof Response) {
        try {
          await sendFetchResponse(res, error);
        } catch (streamError) {
          next(streamError);
          return;
        }
        callAfterRequestMiddleware({ runtime, response: error, path }).catch((mwError) => {
          import_shared5.logger.error({ err: mwError, url: req.originalUrl ?? req.url, path }, "Error running after request middleware");
        });
        return;
      }
      import_shared5.logger.error({ err: error, url: request.url, path }, "Error running request handler");
      next(error);
    }
  };
}
function normalizeBasePath(path) {
  if (!path) {
    throw new Error("basePath must be provided for Express endpoint");
  }
  if (!path.startsWith("/")) {
    return `/${path}`;
  }
  if (path.length > 1 && path.endsWith("/")) {
    return path.slice(0, -1);
  }
  return path;
}
function joinPath(basePath, suffix) {
  if (basePath === "/") {
    return suffix.startsWith("/") ? suffix : `/${suffix}`;
  }
  if (!suffix) {
    return basePath;
  }
  if (suffix === "*") {
    return `${basePath}/*`;
  }
  return `${basePath}${suffix.startsWith("/") ? suffix : `/${suffix}`}`;
}

// src/endpoints/express-single.ts
var import_express2 = __toESM(require("express"));
var import_cors2 = __toESM(require("cors"));
var import_shared6 = require("@copilotkitnext/shared");

// src/endpoints/single-route-helpers.ts
var METHOD_NAMES = [
  "agent/run",
  "agent/connect",
  "agent/stop",
  "info",
  "transcribe"
];
async function parseMethodCall(request) {
  const contentType = request.headers.get("content-type") || "";
  if (!contentType.includes("application/json")) {
    throw createResponseError("Single-route endpoint expects JSON payloads", 415);
  }
  let jsonEnvelope;
  try {
    jsonEnvelope = await request.clone().json();
  } catch (error) {
    throw createResponseError("Invalid JSON payload", 400);
  }
  const method = validateMethod(jsonEnvelope.method);
  return {
    method,
    params: jsonEnvelope.params,
    body: jsonEnvelope.body
  };
}
function expectString(params, key) {
  const value = params?.[key];
  if (typeof value === "string" && value.trim().length > 0) {
    return value;
  }
  throw createResponseError(`Missing or invalid parameter '${key}'`, 400);
}
function createJsonRequest(base, body) {
  if (body === void 0 || body === null) {
    throw createResponseError("Missing request body for JSON handler", 400);
  }
  const headers = new Headers(base.headers);
  headers.set("content-type", "application/json");
  headers.delete("content-length");
  const serializedBody = serializeJsonBody(body);
  return new Request(base.url, {
    method: "POST",
    headers,
    body: serializedBody,
    signal: base.signal
  });
}
function createResponseError(message, status) {
  return new Response(
    JSON.stringify({
      error: "invalid_request",
      message
    }),
    {
      status,
      headers: {
        "Content-Type": "application/json"
      }
    }
  );
}
function validateMethod(method) {
  if (!method) {
    throw createResponseError("Missing method field", 400);
  }
  if (METHOD_NAMES.includes(method)) {
    return method;
  }
  throw createResponseError(`Unsupported method '${method}'`, 400);
}
function serializeJsonBody(body) {
  if (typeof body === "string") {
    return body;
  }
  if (body instanceof Blob || body instanceof ArrayBuffer || body instanceof Uint8Array) {
    return body;
  }
  if (body instanceof FormData || body instanceof URLSearchParams) {
    return body;
  }
  return JSON.stringify(body);
}

// src/endpoints/express-single.ts
function createCopilotEndpointSingleRouteExpress({
  runtime,
  basePath
}) {
  const router = import_express2.default.Router();
  const routePath = normalizeSingleRoutePath(basePath);
  router.use((0, import_cors2.default)({
    origin: "*",
    methods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH", "OPTIONS"],
    allowedHeaders: ["*"]
  }));
  router.post(routePath, createSingleRouteHandler(runtime));
  router.use((req, res) => {
    res.status(404).json({ error: "Not found" });
  });
  return router;
}
function createSingleRouteHandler(runtime) {
  return async (req, res, next) => {
    const path = req.originalUrl ?? req.path;
    let request = createFetchRequestFromExpress(req);
    try {
      const maybeModifiedRequest = await callBeforeRequestMiddleware({ runtime, request, path });
      if (maybeModifiedRequest) {
        request = maybeModifiedRequest;
      }
    } catch (error) {
      import_shared6.logger.error({ err: error, url: request.url, path }, "Error running before request middleware");
      if (error instanceof Response) {
        try {
          await sendFetchResponse(res, error);
        } catch (streamError) {
          next(streamError);
        }
        return;
      }
      next(error);
      return;
    }
    let methodCall;
    try {
      methodCall = await parseMethodCall(request);
    } catch (error) {
      if (error instanceof Response) {
        import_shared6.logger.warn({ url: request.url }, "Invalid single-route payload");
        try {
          await sendFetchResponse(res, error);
        } catch (streamError) {
          next(streamError);
        }
        return;
      }
      import_shared6.logger.warn({ err: error, url: request.url }, "Invalid single-route payload");
      res.status(400).json({
        error: "invalid_request",
        message: error instanceof Error ? error.message : "Invalid request payload"
      });
      return;
    }
    try {
      let response;
      switch (methodCall.method) {
        case "agent/run": {
          const agentId = expectString(methodCall.params, "agentId");
          const handlerRequest = createJsonRequest(request, methodCall.body);
          response = await handleRunAgent({ runtime, request: handlerRequest, agentId });
          break;
        }
        case "agent/connect": {
          const agentId = expectString(methodCall.params, "agentId");
          const handlerRequest = createJsonRequest(request, methodCall.body);
          response = await handleConnectAgent({ runtime, request: handlerRequest, agentId });
          break;
        }
        case "agent/stop": {
          const agentId = expectString(methodCall.params, "agentId");
          const threadId = expectString(methodCall.params, "threadId");
          response = await handleStopAgent({ runtime, request, agentId, threadId });
          break;
        }
        case "info": {
          response = await handleGetRuntimeInfo({ runtime, request });
          break;
        }
        case "transcribe": {
          const handlerRequest = createJsonRequest(request, methodCall.body);
          response = await handleTranscribe({ runtime, request: handlerRequest });
          break;
        }
        default: {
          const exhaustive = methodCall.method;
          return exhaustive;
        }
      }
      await sendFetchResponse(res, response);
      callAfterRequestMiddleware({ runtime, response, path }).catch((error) => {
        import_shared6.logger.error({ err: error, url: req.originalUrl ?? req.url, path }, "Error running after request middleware");
      });
    } catch (error) {
      if (error instanceof Response) {
        try {
          await sendFetchResponse(res, error);
        } catch (streamError) {
          next(streamError);
          return;
        }
        callAfterRequestMiddleware({ runtime, response: error, path }).catch((mwError) => {
          import_shared6.logger.error({ err: mwError, url: req.originalUrl ?? req.url, path }, "Error running after request middleware");
        });
        return;
      }
      import_shared6.logger.error({ err: error, url: request.url, path }, "Error running single-route handler");
      next(error);
    }
  };
}
function normalizeSingleRoutePath(path) {
  if (!path) {
    throw new Error("basePath must be provided for Express single-route endpoint");
  }
  if (!path.startsWith("/")) {
    return `/${path}`;
  }
  if (path.length > 1 && path.endsWith("/")) {
    return path.slice(0, -1);
  }
  return path;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  createCopilotEndpointExpress,
  createCopilotEndpointSingleRouteExpress
});
//# sourceMappingURL=express.js.map