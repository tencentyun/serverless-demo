{"version":3,"file":"stream.custom.cjs","names":["options: FetchStreamTransportOptions","requestInit: RequestInit","BytesLineDecoder","SSEDecoder","IterableReadableStream","MessageTupleManager","StreamManager","useControllableThreadId","callbackMeta: RunCallbackMeta | undefined"],"sources":["../../src/react/stream.custom.tsx"],"sourcesContent":["/* __LC_ALLOW_ENTRYPOINT_SIDE_EFFECTS__ */\n\n\"use client\";\n\nimport { useEffect, useRef, useState, useSyncExternalStore } from \"react\";\nimport { EventStreamEvent, StreamManager } from \"../ui/manager.js\";\nimport type {\n  BagTemplate,\n  GetUpdateType,\n  GetCustomEventType,\n  GetInterruptType,\n  RunCallbackMeta,\n  GetConfigurableType,\n  UseStreamCustomOptions,\n  UseStreamCustom,\n  UseStreamTransport,\n  CustomSubmitOptions,\n} from \"./types.js\";\nimport type { Message } from \"../types.messages.js\";\nimport { MessageTupleManager } from \"../ui/messages.js\";\nimport { Interrupt } from \"../schema.js\";\nimport { BytesLineDecoder, SSEDecoder } from \"../utils/sse.js\";\nimport { IterableReadableStream } from \"../utils/stream.js\";\nimport { useControllableThreadId } from \"./thread.js\";\nimport { Command } from \"../types.js\";\n\ninterface FetchStreamTransportOptions {\n  /**\n   * The URL of the API to use.\n   */\n  apiUrl: string;\n\n  /**\n   * Default headers to send with requests.\n   */\n  defaultHeaders?: HeadersInit;\n\n  /**\n   * Specify a custom fetch implementation.\n   */\n  fetch?: typeof fetch | ((...args: any[]) => any); // eslint-disable-line @typescript-eslint/no-explicit-any\n\n  /**\n   * Callback that is called before the request is made.\n   */\n  onRequest?: (\n    url: string,\n    init: RequestInit\n  ) => Promise<RequestInit> | RequestInit;\n}\n\nexport class FetchStreamTransport<\n  StateType extends Record<string, unknown> = Record<string, unknown>,\n  Bag extends BagTemplate = BagTemplate\n> implements UseStreamTransport<StateType, Bag>\n{\n  constructor(private readonly options: FetchStreamTransportOptions) {}\n\n  async stream(payload: {\n    input: GetUpdateType<Bag, StateType> | null | undefined;\n    context: GetConfigurableType<Bag> | undefined;\n    command: Command | undefined;\n    signal: AbortSignal;\n  }): Promise<AsyncGenerator<{ id?: string; event: string; data: unknown }>> {\n    const { signal, ...body } = payload;\n\n    let requestInit: RequestInit = {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...this.options.defaultHeaders,\n      },\n      body: JSON.stringify(body),\n      signal,\n    };\n\n    if (this.options.onRequest) {\n      requestInit = await this.options.onRequest(\n        this.options.apiUrl,\n        requestInit\n      );\n    }\n    const fetchFn = this.options.fetch ?? fetch;\n\n    const response = await fetchFn(this.options.apiUrl, requestInit);\n    if (!response.ok) {\n      throw new Error(`Failed to stream: ${response.statusText}`);\n    }\n\n    const stream = (\n      response.body || new ReadableStream({ start: (ctrl) => ctrl.close() })\n    )\n      .pipeThrough(BytesLineDecoder())\n      .pipeThrough(SSEDecoder());\n\n    return IterableReadableStream.fromReadableStream(stream);\n  }\n}\n\nexport function useStreamCustom<\n  StateType extends Record<string, unknown> = Record<string, unknown>,\n  Bag extends {\n    ConfigurableType?: Record<string, unknown>;\n    InterruptType?: unknown;\n    CustomEventType?: unknown;\n    UpdateType?: unknown;\n  } = BagTemplate\n>(\n  options: UseStreamCustomOptions<StateType, Bag>\n): UseStreamCustom<StateType, Bag> {\n  type UpdateType = GetUpdateType<Bag, StateType>;\n  type CustomType = GetCustomEventType<Bag>;\n  type InterruptType = GetInterruptType<Bag>;\n  type ConfigurableType = GetConfigurableType<Bag>;\n\n  const [messageManager] = useState(() => new MessageTupleManager());\n  const [stream] = useState(\n    () =>\n      new StreamManager<StateType, Bag>(messageManager, {\n        throttle: options.throttle ?? false,\n      })\n  );\n\n  useSyncExternalStore(\n    stream.subscribe,\n    stream.getSnapshot,\n    stream.getSnapshot\n  );\n\n  const [threadId, onThreadId] = useControllableThreadId(options);\n  const threadIdRef = useRef<string | null>(threadId);\n\n  // Cancel the stream if thread ID has changed\n  useEffect(() => {\n    if (threadIdRef.current !== threadId) {\n      threadIdRef.current = threadId;\n      stream.clear();\n    }\n  }, [threadId, stream]);\n\n  const getMessages = (value: StateType): Message[] => {\n    const messagesKey = options.messagesKey ?? \"messages\";\n    return Array.isArray(value[messagesKey]) ? value[messagesKey] : [];\n  };\n\n  const setMessages = (current: StateType, messages: Message[]): StateType => {\n    const messagesKey = options.messagesKey ?? \"messages\";\n    return { ...current, [messagesKey]: messages };\n  };\n\n  const historyValues = options.initialValues ?? ({} as StateType);\n\n  const stop = () => stream.stop(historyValues, { onStop: options.onStop });\n\n  const submit = async (\n    values: UpdateType | null | undefined,\n    submitOptions?: CustomSubmitOptions<StateType, ConfigurableType>\n  ) => {\n    let callbackMeta: RunCallbackMeta | undefined;\n    let usableThreadId = threadId;\n\n    stream.setStreamValues(() => {\n      if (submitOptions?.optimisticValues != null) {\n        return {\n          ...historyValues,\n          ...(typeof submitOptions.optimisticValues === \"function\"\n            ? submitOptions.optimisticValues(historyValues)\n            : submitOptions.optimisticValues),\n        };\n      }\n\n      return { ...historyValues };\n    });\n\n    await stream.start(\n      async (signal: AbortSignal) => {\n        if (!usableThreadId) {\n          // generate random thread id\n          usableThreadId = crypto.randomUUID();\n          threadIdRef.current = usableThreadId;\n          onThreadId(usableThreadId);\n        }\n\n        if (!usableThreadId) {\n          throw new Error(\"Failed to obtain valid thread ID.\");\n        }\n\n        return options.transport.stream({\n          input: values,\n          context: submitOptions?.context,\n          command: submitOptions?.command,\n          signal,\n          config: {\n            ...submitOptions?.config,\n            configurable: {\n              thread_id: usableThreadId,\n              ...submitOptions?.config?.configurable,\n            } as unknown as GetConfigurableType<Bag>,\n          },\n        }) as Promise<\n          AsyncGenerator<EventStreamEvent<StateType, UpdateType, CustomType>>\n        >;\n      },\n      {\n        getMessages,\n        setMessages,\n\n        initialValues: {} as StateType,\n        callbacks: options,\n\n        onSuccess: () => undefined,\n        onError(error) {\n          options.onError?.(error, callbackMeta);\n        },\n      }\n    );\n  };\n\n  return {\n    get values() {\n      return stream.values ?? ({} as StateType);\n    },\n\n    error: stream.error,\n    isLoading: stream.isLoading,\n\n    stop,\n    submit,\n\n    get interrupt(): Interrupt<InterruptType> | undefined {\n      if (\n        stream.values != null &&\n        \"__interrupt__\" in stream.values &&\n        Array.isArray(stream.values.__interrupt__)\n      ) {\n        const valueInterrupts = stream.values.__interrupt__;\n        if (valueInterrupts.length === 0) return { when: \"breakpoint\" };\n        if (valueInterrupts.length === 1) return valueInterrupts[0];\n\n        // TODO: fix the typing of interrupts if multiple interrupts are returned\n        return valueInterrupts as Interrupt<InterruptType>;\n      }\n\n      return undefined;\n    },\n\n    get messages() {\n      if (!stream.values) return [];\n      return getMessages(stream.values);\n    },\n  };\n}\n"],"mappings":";;;;;;;;;;;;AAmDA,IAAa,uBAAb,MAIA;CACE,YAAY,AAAiBA,SAAsC;EAAtC;;CAE7B,MAAM,OAAO,SAK8D;EACzE,MAAM,EAAE,OAAQ,GAAG,SAAS;EAE5B,IAAIC,cAA2B;GAC7B,QAAQ;GACR,SAAS;IACP,gBAAgB;IAChB,GAAG,KAAK,QAAQ;;GAElB,MAAM,KAAK,UAAU;GACrB;;AAGF,MAAI,KAAK,QAAQ,UACf,eAAc,MAAM,KAAK,QAAQ,UAC/B,KAAK,QAAQ,QACb;EAGJ,MAAM,UAAU,KAAK,QAAQ,SAAS;EAEtC,MAAM,WAAW,MAAM,QAAQ,KAAK,QAAQ,QAAQ;AACpD,MAAI,CAAC,SAAS,GACZ,OAAM,IAAI,MAAM,qBAAqB,SAAS;EAGhD,MAAM,UACJ,SAAS,QAAQ,IAAI,eAAe,EAAE,QAAQ,SAAS,KAAK,YAE3D,YAAYC,gCACZ,YAAYC;AAEf,SAAOC,sCAAuB,mBAAmB;;;AAIrD,SAAgB,gBASd,SACiC;CAMjC,MAAM,CAAC,4CAAiC,IAAIC;CAC5C,MAAM,CAAC,oCAEH,IAAIC,8BAA8B,gBAAgB,EAChD,UAAU,QAAQ,YAAY;AAIpC,iCACE,OAAO,WACP,OAAO,aACP,OAAO;CAGT,MAAM,CAAC,UAAU,cAAcC,uCAAwB;CACvD,MAAM,gCAAoC;AAG1C,4BAAgB;AACd,MAAI,YAAY,YAAY,UAAU;AACpC,eAAY,UAAU;AACtB,UAAO;;IAER,CAAC,UAAU;CAEd,MAAM,eAAe,UAAgC;EACnD,MAAM,cAAc,QAAQ,eAAe;AAC3C,SAAO,MAAM,QAAQ,MAAM,gBAAgB,MAAM,eAAe;;CAGlE,MAAM,eAAe,SAAoB,aAAmC;EAC1E,MAAM,cAAc,QAAQ,eAAe;AAC3C,SAAO;GAAE,GAAG;IAAU,cAAc;;;CAGtC,MAAM,gBAAgB,QAAQ,iBAAkB;CAEhD,MAAM,aAAa,OAAO,KAAK,eAAe,EAAE,QAAQ,QAAQ;CAEhE,MAAM,SAAS,OACb,QACA,kBACG;EACH,IAAIC;EACJ,IAAI,iBAAiB;AAErB,SAAO,sBAAsB;AAC3B,OAAI,eAAe,oBAAoB,KACrC,QAAO;IACL,GAAG;IACH,GAAI,OAAO,cAAc,qBAAqB,aAC1C,cAAc,iBAAiB,iBAC/B,cAAc;;AAItB,UAAO,EAAE,GAAG;;AAGd,QAAM,OAAO,MACX,OAAO,WAAwB;AAC7B,OAAI,CAAC,gBAAgB;AAEnB,qBAAiB,OAAO;AACxB,gBAAY,UAAU;AACtB,eAAW;;AAGb,OAAI,CAAC,eACH,OAAM,IAAI,MAAM;AAGlB,UAAO,QAAQ,UAAU,OAAO;IAC9B,OAAO;IACP,SAAS,eAAe;IACxB,SAAS,eAAe;IACxB;IACA,QAAQ;KACN,GAAG,eAAe;KAClB,cAAc;MACZ,WAAW;MACX,GAAG,eAAe,QAAQ;;;;KAOlC;GACE;GACA;GAEA,eAAe;GACf,WAAW;GAEX,iBAAiB;GACjB,QAAQ,OAAO;AACb,YAAQ,UAAU,OAAO;;;;AAMjC,QAAO;EACL,IAAI,SAAS;AACX,UAAO,OAAO,UAAW;;EAG3B,OAAO,OAAO;EACd,WAAW,OAAO;EAElB;EACA;EAEA,IAAI,YAAkD;AACpD,OACE,OAAO,UAAU,QACjB,mBAAmB,OAAO,UAC1B,MAAM,QAAQ,OAAO,OAAO,gBAC5B;IACA,MAAM,kBAAkB,OAAO,OAAO;AACtC,QAAI,gBAAgB,WAAW,EAAG,QAAO,EAAE,MAAM;AACjD,QAAI,gBAAgB,WAAW,EAAG,QAAO,gBAAgB;AAGzD,WAAO;;AAGT,UAAO;;EAGT,IAAI,WAAW;AACb,OAAI,CAAC,OAAO,OAAQ,QAAO;AAC3B,UAAO,YAAY,OAAO"}