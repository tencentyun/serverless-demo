"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnsafeLocalCodeExecutor = void 0;
const base_code_executor_1 = require("./base_code_executor");
const cross_spawn_1 = require("cross-spawn");
const utils_1 = require("../utils");
class ExecutionError {
    constructor(name, value, traceback) {
        this.name = name;
        this.value = value;
        this.traceback = traceback;
    }
}
class Result {
    constructor(rawData, isMainResult) {
        this.isMainResult = isMainResult;
        const data = { ...rawData };
        delete data["type"];
        delete data["is_main_result"];
        this.text = data["text"];
        this.html = data["html"];
        this.markdown = data["markdown"];
        this.svg = data["svg"];
        this.png = data["png"];
        this.jpeg = data["jpeg"];
        this.pdf = data["pdf"];
        this.latex = data["latex"];
        this.json = data["json"];
        this.javascript = data["javascript"];
        this.raw = data;
        this.data = data["data"];
        this.chart = data["chart"];
        this.extra = {};
        for (const key of Object.keys(data)) {
            if (![
                "text",
                "html",
                "markdown",
                "svg",
                "png",
                "jpeg",
                "pdf",
                "latex",
                "json",
                "javascript",
                "data",
                "chart",
            ].includes(key)) {
                this.extra[key] = data[key];
            }
        }
    }
    formats() {
        const formats = [];
        if (this.text)
            formats.push("text");
        if (this.html)
            formats.push("html");
        if (this.markdown)
            formats.push("markdown");
        if (this.svg)
            formats.push("svg");
        if (this.png)
            formats.push("png");
        if (this.jpeg)
            formats.push("jpeg");
        if (this.pdf)
            formats.push("pdf");
        if (this.latex)
            formats.push("latex");
        if (this.json)
            formats.push("json");
        if (this.javascript)
            formats.push("javascript");
        if (this.data)
            formats.push("data");
        if (this.chart)
            formats.push("chart");
        for (const key of Object.keys(this.extra || {})) {
            formats.push(key);
        }
        return formats;
    }
    toJSON() {
        return {
            text: this.text,
            html: this.html,
            markdown: this.markdown,
            svg: this.svg,
            png: this.png,
            jpeg: this.jpeg,
            pdf: this.pdf,
            latex: this.latex,
            json: this.json,
            javascript: this.javascript,
            ...(this.extra && Object.keys(this.extra).length > 0
                ? { extra: this.extra }
                : {}),
        };
    }
}
class Execution {
    constructor(results = [], logs = { stdout: [], stderr: [] }, error, executionCount) {
        this.results = results;
        this.logs = logs;
        this.error = error;
        this.executionCount = executionCount;
    }
    /**
     * Returns the text representation of the main result of the cell.
     */
    get text() {
        for (const data of this.results) {
            if (data.isMainResult) {
                return data.text;
            }
        }
    }
    /**
     * Returns the serializable representation of the execution result.
     */
    toJSON() {
        return {
            results: this.results,
            logs: this.logs,
            error: this.error,
        };
    }
}
class UnsafeLocalCodeExecutor extends base_code_executor_1.BaseCodeExecutor {
    constructor(options) {
        super();
        this.executor = new CodeExecutor();
        this.options = options;
    }
    async _invoke(input) {
        const { code, language = "python" } = input;
        const result = await this.executor.runCode(language, code, this.options);
        return result;
    }
}
exports.UnsafeLocalCodeExecutor = UnsafeLocalCodeExecutor;
class CodeExecutor {
    constructor() {
        this.executionCount = 0;
    }
    async runCode(language, code, options = {}) {
        this.executionCount++;
        const logs = {
            stdout: [],
            stderr: [],
        };
        const results = [];
        let error = undefined;
        try {
            const config = this.getLanguageConfig(language, code);
            if (!config) {
                error = new ExecutionError("UnsupportedLanguage", `Language '${language}' is not supported`, "");
                return new Execution(results, logs, error, this.executionCount);
            }
            const execResult = await this.executeCode(config, {
                ...options,
                onStdout: (data) => {
                    if (options.onStdout)
                        options.onStdout(data);
                    logs.stdout.push(data.line);
                },
                onStderr: (data) => {
                    if (options.onStderr)
                        options.onStderr(data);
                    logs.stderr.push(data.line);
                },
            });
            if (execResult.success) {
                const parsedResults = this.parseResults((0, utils_1.stripAnsi)(execResult.stdout), language, code);
                results.push(...parsedResults);
            }
            else {
                error = new ExecutionError("ExecutionError", execResult.stderr ||
                    `Process exited with code ${execResult.exitCode}`, this.parseTraceback(execResult.stderr, language).join("\n"));
            }
        }
        catch (err) {
            error = new ExecutionError("SystemError", err.message, err.stack);
        }
        return new Execution(results, logs, error, this.executionCount);
    }
    getLanguageConfig(language, code) {
        const configs = {
            python: { cmd: "python3", args: ["-c", code] },
            python3: { cmd: "python3", args: ["-c", code] },
            js: { cmd: "node", args: ["-p", "-e", code] },
            node: { cmd: "node", args: ["-p", "-e", code] },
            bash: { cmd: "bash", args: ["-c", code] },
        };
        return configs[language];
    }
    async executeCode(config, options = {}) {
        return new Promise((resolve) => {
            const child = (0, cross_spawn_1.spawn)(config.cmd, config.args, {
                timeout: options.timeoutMs || 30000,
                env: { ...process.env, ...options.envs },
            });
            let stdout = "";
            let stderr = "";
            child.stdout.on("data", (data) => {
                const text = data.toString();
                stdout += text;
                if (options.onStdout)
                    options.onStdout({
                        error: false,
                        line: text,
                        timestamp: new Date().getTime() * 1e3,
                    });
            });
            child.stderr.on("data", (data) => {
                const text = data.toString();
                stderr += text;
                if (options.onStderr)
                    options.onStderr({
                        error: true,
                        line: text,
                        timestamp: new Date().getTime() * 1e3,
                    });
            });
            child.on("close", (code) => {
                resolve({
                    success: code === 0,
                    exitCode: code,
                    stdout: stdout.trim(),
                    stderr: stderr.trim(),
                });
            });
            child.on("error", (err) => {
                resolve({
                    success: false,
                    exitCode: null,
                    stdout: stdout.trim(),
                    stderr: err.message,
                });
            });
        });
    }
    parseResults(stdout, language, code) {
        const results = [];
        if (!stdout.trim()) {
            return results;
        }
        if (language === "python" || language === "python3") {
            results.push(...this.parsePythonResults(stdout));
        }
        else if (language === "js" || language === "node") {
            results.push(...this.parseJavaScriptResults(stdout, code));
        }
        else {
            // Other languages, treat entire output as text result
            const resultData = {
                data: stdout,
                chart: null,
                text: stdout,
            };
            results.push(new Result(resultData, true));
        }
        return results;
    }
    parsePythonResults(stdout) {
        const results = [];
        const lines = stdout.trim().split("\n");
        let i = 0;
        while (i < lines.length) {
            const line = lines[i].trim();
            if (!line || line.startsWith(">>>") || line.startsWith("...")) {
                i++;
                continue;
            }
            // Check if it is JSON data
            if (this.isJsonLine(line)) {
                try {
                    const jsonData = JSON.parse(line);
                    const resultData = {
                        data: {
                            result: jsonData,
                            type: "json",
                            keys: Array.isArray(jsonData) ? [] : Object.keys(jsonData),
                            length: Array.isArray(jsonData)
                                ? jsonData.length
                                : Object.keys(jsonData).length,
                            is_array: Array.isArray(jsonData),
                            parsed_at: Date.now(),
                        },
                        chart: null,
                        text: line,
                        json: jsonData,
                    };
                    results.push(new Result(resultData, results.length === 0));
                    i++;
                    continue;
                }
                catch {
                    // JSON parsing failed, treat as regular text
                }
            }
            // Check if it is a number
            if (this.isNumber(line)) {
                const numValue = parseFloat(line);
                const resultData = {
                    data: {
                        value: numValue,
                        type: "number",
                        is_integer: Number.isInteger(numValue),
                        precision: this.getDecimalPlaces(line),
                        scientific_notation: line.includes("e") || line.includes("E"),
                    },
                    chart: null,
                    text: line,
                };
                results.push(new Result(resultData, results.length === 0));
                i++;
                continue;
            }
            // Check if it is DataFrame output
            if (this.isDataFrameLine(line)) {
                const tableResult = this.parseTableData(lines, i);
                if (tableResult) {
                    const resultData = {
                        data: {
                            table_data: tableResult.data,
                            type: "dataframe",
                            rows: tableResult.rows,
                            columns: tableResult.columns,
                            shape: [tableResult.rows.length, tableResult.columns.length],
                            preview: tableResult.text.split("\n").slice(0, 5).join("\n"),
                        },
                        chart: null,
                        text: tableResult.text,
                        html: this.convertTableToHtml(tableResult.text),
                    };
                    results.push(new Result(resultData, results.length === 0));
                    i = tableResult.nextIndex;
                    continue;
                }
            }
            // Check if it is array output
            if (line.startsWith("[") && line.endsWith("]")) {
                try {
                    const arrayData = JSON.parse(line);
                    if (Array.isArray(arrayData)) {
                        const resultData = {
                            data: {
                                values: arrayData,
                                type: "array",
                                length: arrayData.length,
                                dtype: this.inferArrayType(arrayData),
                                statistics: this.calculateArrayStats(arrayData),
                            },
                            chart: null,
                            text: line,
                            json: JSON.stringify(arrayData),
                        };
                        results.push(new Result(resultData, results.length === 0));
                        i++;
                        continue;
                    }
                }
                catch {
                    // Not a valid array, treat as text
                }
            }
            // Check if it is matplotlib chart output
            if (line.includes("matplotlib") ||
                line.includes(".png") ||
                line.includes("Figure")) {
                const resultData = {
                    data: {
                        plot_type: "matplotlib",
                        format: "png",
                        created_at: Date.now(),
                        library: "matplotlib",
                        file_path: line.includes(".png") ? line : null,
                    },
                    chart: "line", // Default to line chart, should analyze code for actual type
                    text: "[Chart generated]",
                    png: line.includes(".png") ? line : null,
                };
                results.push(new Result(resultData, results.length === 0));
                i++;
                continue;
            }
            // Regular text
            const resultData = {
                data: {
                    content: line,
                    type: "text",
                    length: line.length,
                    words: line.split(/\s+/).length,
                    encoding: "utf-8",
                },
                chart: null,
                text: line,
            };
            results.push(new Result(resultData, results.length === 0));
            i++;
        }
        if (results.length === 0) {
            const resultData = {
                data: {
                    content: stdout,
                    type: "text",
                    length: stdout.length,
                    lines: stdout.split("\n").length,
                    encoding: "utf-8",
                },
                chart: null,
                text: stdout,
            };
            results.push(new Result(resultData, true));
        }
        return results;
    }
    parseJavaScriptResults(stdout, code) {
        if (code) {
            // Check if the code is a simple assignment expression statement
            const isSimpleAssignment = /^\s*[a-zA-Z_$][\w$]*\s*=\s*[^=].*;?\s*$/.test(code);
            if (isSimpleAssignment) {
                // For simple assignments, e2b-like behavior is to produce no result
                return [];
            }
        }
        const results = [];
        const lines = stdout.trim().split("\n");
        for (const line of lines) {
            if (!line.trim() || line.trim() === "undefined") {
                continue;
            }
            const resultData = {
                data: undefined,
                chart: null,
                text: line,
                javascript: `"${line}"`,
            };
            results.push(new Result(resultData, results.length === 0));
        }
        if (results.length === 0 &&
            stdout.trim() &&
            stdout.trim() !== "undefined") {
            const resultData = {
                data: {
                    content: stdout,
                    type: "text",
                    javascript_type: "string",
                    length: stdout.length,
                    lines: stdout.split("\n").length,
                },
                chart: null,
                text: stdout,
            };
            results.push(new Result(resultData, true));
        }
        return results;
    }
    // Helper methods
    isDataFrameLine(line) {
        return (line.includes("|") ||
            line.match(/^\s*\d+\s+/) !== null ||
            line.includes("Name:") ||
            line.includes("dtype:"));
    }
    inferArrayType(arr) {
        if (arr.length === 0)
            return "unknown";
        const firstType = typeof arr[0];
        const allSameType = arr.every((item) => typeof item === firstType);
        return allSameType ? firstType : "mixed";
    }
    calculateArrayStats(arr) {
        if (arr.every((item) => typeof item === "number")) {
            const numbers = arr;
            return {
                mean: numbers.reduce((a, b) => a + b, 0) / numbers.length,
                sum: numbers.reduce((a, b) => a + b, 0),
                min: Math.min(...numbers),
                max: Math.max(...numbers),
                std: this.calculateStandardDeviation(numbers),
            };
        }
        return {
            unique_count: new Set(arr).size,
            most_common: this.getMostCommon(arr),
        };
    }
    calculateStandardDeviation(numbers) {
        const mean = numbers.reduce((a, b) => a + b, 0) / numbers.length;
        const variance = numbers.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / numbers.length;
        return Math.sqrt(variance);
    }
    getMostCommon(arr) {
        const counts = {};
        arr.forEach((item) => {
            const key = String(item);
            counts[key] = (counts[key] || 0) + 1;
        });
        return Object.keys(counts).reduce((a, b) => counts[a] > counts[b] ? a : b);
    }
    getDecimalPlaces(numStr) {
        const match = numStr.match(/\.(\d+)/);
        return match ? match[1].length : 0;
    }
    isJsonLine(line) {
        const trimmed = line.trim();
        return ((trimmed.startsWith("{") && trimmed.endsWith("}")) ||
            (trimmed.startsWith("[") && trimmed.endsWith("]")));
    }
    isNumber(line) {
        return /^-?\d+(\.\d+)?$/.test(line.trim());
    }
    parseTableData(lines, startIndex) {
        // Implement table parsing logic
        const line = lines[startIndex];
        if (!this.isDataFrameLine(line)) {
            return null;
        }
        let endIndex = startIndex;
        let tableText = line;
        const rows = [];
        let columns = [];
        // Simple table parsing implementation
        for (let i = startIndex; i < lines.length; i++) {
            const currentLine = lines[i];
            if (!currentLine.trim() ||
                (!this.isDataFrameLine(currentLine) && i > startIndex)) {
                break;
            }
            if (i === startIndex && currentLine.includes("|")) {
                // Parse column names
                columns = currentLine
                    .split("|")
                    .map((col) => col.trim())
                    .filter((col) => col);
            }
            else if (currentLine.includes("|")) {
                // Parse data rows
                const row = currentLine
                    .split("|")
                    .map((cell) => cell.trim())
                    .filter((cell) => cell);
                rows.push(row);
            }
            if (i > startIndex) {
                tableText += "\n" + currentLine;
            }
            endIndex = i;
        }
        return {
            text: tableText,
            data: tableText,
            rows,
            columns,
            nextIndex: endIndex + 1,
        };
    }
    convertTableToHtml(tableText) {
        const lines = tableText.split("\n");
        let html = '<table border="1">';
        for (const line of lines) {
            if (line.includes("|")) {
                const cells = line
                    .split("|")
                    .map((cell) => cell.trim())
                    .filter((cell) => cell);
                html += "<tr>";
                for (const cell of cells) {
                    html += `<td>${cell}</td>`;
                }
                html += "</tr>";
            }
        }
        html += "</table>";
        return html;
    }
    parseTraceback(stderr, language) {
        if (!stderr)
            return [];
        return stderr.split("\n").filter((line) => line.trim());
    }
}
//# sourceMappingURL=unsafe_local_code_executor.js.map