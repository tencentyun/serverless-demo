{"version":3,"file":"PeriodicExportingMetricReader.js","sourceRoot":"","sources":["../../../src/export/PeriodicExportingMetricReader.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport {\n  internal,\n  ExportResultCode,\n  globalErrorHandler,\n} from '@opentelemetry/core';\nimport { MetricReader } from './MetricReader';\nimport { PushMetricExporter } from './MetricExporter';\nimport { callWithTimeout, TimeoutError } from '../utils';\nimport { MetricProducer } from './MetricProducer';\n\nexport type PeriodicExportingMetricReaderOptions = {\n  /**\n   * The backing exporter for the metric reader.\n   */\n  exporter: PushMetricExporter;\n  /**\n   * An internal milliseconds for the metric reader to initiate metric\n   * collection.\n   */\n  exportIntervalMillis?: number;\n  /**\n   * Milliseconds for the async observable callback to timeout.\n   */\n  exportTimeoutMillis?: number;\n  /**\n   * **Note, this option is experimental**. Additional MetricProducers to use as a source of\n   * aggregated metric data in addition to the SDK's metric data. The resource returned by\n   * these MetricProducers is ignored; the SDK's resource will be used instead.\n   * @experimental\n   */\n  metricProducers?: MetricProducer[];\n};\n\n/**\n * {@link MetricReader} which collects metrics based on a user-configurable time interval, and passes the metrics to\n * the configured {@link PushMetricExporter}\n */\nexport class PeriodicExportingMetricReader extends MetricReader {\n  private _interval?: ReturnType<typeof setInterval>;\n  private _exporter: PushMetricExporter;\n  private readonly _exportInterval: number;\n  private readonly _exportTimeout: number;\n\n  constructor(options: PeriodicExportingMetricReaderOptions) {\n    const { exporter, exportIntervalMillis = 60000, metricProducers } = options;\n    let { exportTimeoutMillis = 30000 } = options;\n\n    super({\n      aggregationSelector: exporter.selectAggregation?.bind(exporter),\n      aggregationTemporalitySelector:\n        exporter.selectAggregationTemporality?.bind(exporter),\n      metricProducers,\n    });\n\n    if (exportIntervalMillis <= 0) {\n      throw Error('exportIntervalMillis must be greater than 0');\n    }\n\n    if (exportTimeoutMillis <= 0) {\n      throw Error('exportTimeoutMillis must be greater than 0');\n    }\n\n    if (exportIntervalMillis < exportTimeoutMillis) {\n      if (\n        'exportIntervalMillis' in options &&\n        'exportTimeoutMillis' in options\n      ) {\n        // An invalid combination of values was explicitly provided.\n        throw Error(\n          'exportIntervalMillis must be greater than or equal to exportTimeoutMillis'\n        );\n      } else {\n        // An invalid combination of value was implicitly provided.\n        api.diag.info(\n          `Timeout of ${exportTimeoutMillis} exceeds the interval of ${exportIntervalMillis}. Clamping timeout to interval duration.`\n        );\n        exportTimeoutMillis = exportIntervalMillis;\n      }\n    }\n\n    this._exportInterval = exportIntervalMillis;\n    this._exportTimeout = exportTimeoutMillis;\n    this._exporter = exporter;\n  }\n\n  private async _runOnce(): Promise<void> {\n    try {\n      await callWithTimeout(this._doRun(), this._exportTimeout);\n    } catch (err) {\n      if (err instanceof TimeoutError) {\n        api.diag.error(\n          'Export took longer than %s milliseconds and timed out.',\n          this._exportTimeout\n        );\n        return;\n      }\n\n      globalErrorHandler(err);\n    }\n  }\n\n  private async _doRun(): Promise<void> {\n    const { resourceMetrics, errors } = await this.collect({\n      timeoutMillis: this._exportTimeout,\n    });\n\n    if (errors.length > 0) {\n      api.diag.error(\n        'PeriodicExportingMetricReader: metrics collection errors',\n        ...errors\n      );\n    }\n\n    if (resourceMetrics.resource.asyncAttributesPending) {\n      try {\n        await resourceMetrics.resource.waitForAsyncAttributes?.();\n      } catch (e) {\n        api.diag.debug('Error while resolving async portion of resource: ', e);\n        globalErrorHandler(e);\n      }\n    }\n\n    if (resourceMetrics.scopeMetrics.length === 0) {\n      return;\n    }\n\n    const result = await internal._export(this._exporter, resourceMetrics);\n    if (result.code !== ExportResultCode.SUCCESS) {\n      throw new Error(\n        `PeriodicExportingMetricReader: metrics export failed (error ${result.error})`\n      );\n    }\n  }\n\n  protected override onInitialized(): void {\n    // start running the interval as soon as this reader is initialized and keep handle for shutdown.\n    this._interval = setInterval(() => {\n      // this._runOnce never rejects. Using void operator to suppress @typescript-eslint/no-floating-promises.\n      void this._runOnce();\n    }, this._exportInterval);\n\n    // depending on runtime, this may be a 'number' or NodeJS.Timeout\n    if (typeof this._interval !== 'number') {\n      this._interval.unref();\n    }\n  }\n\n  protected async onForceFlush(): Promise<void> {\n    await this._runOnce();\n    await this._exporter.forceFlush();\n  }\n\n  protected async onShutdown(): Promise<void> {\n    if (this._interval) {\n      clearInterval(this._interval);\n    }\n    await this.onForceFlush();\n    await this._exporter.shutdown();\n  }\n}\n"]}