"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserInstanceManager = void 0;
const events_1 = require("events");
const sandbox_connector_1 = require("./sandbox-connector");
/**
 * BrowserInstanceManager provides multi-instance isolation and lifecycle management
 * Supports concurrent users with isolated browser environments
 */
class BrowserInstanceManager extends events_1.EventEmitter {
    constructor(config) {
        super();
        this.instances = new Map();
        this.config = {
            maxInstances: 10,
            instanceTtl: 3600, // 1 hour
            cleanupInterval: 300, // 5 minutes
            ...config,
        };
        // Start cleanup timer
        this.startCleanupTimer();
    }
    /**
     * Create or get existing browser instance for session
     */
    async getInstance(sessionId) {
        // Check if instance already exists
        const existing = this.instances.get(sessionId);
        if (existing && existing.isActive) {
            // Update last used time
            existing.lastUsed = new Date();
            return existing;
        }
        // Check instance limit
        if (this.instances.size >= this.config.maxInstances) {
            await this.cleanupExpiredInstances();
            if (this.instances.size >= this.config.maxInstances) {
                throw new Error(`Maximum number of browser instances reached: ${this.config.maxInstances}`);
            }
        }
        // Create new instance
        const connector = new sandbox_connector_1.SandboxConnector({
            apiKey: this.config.apiKey,
            domain: this.config.domain,
            timeout: this.config.timeout,
            sessionId,
        });
        // Set up event handlers
        this.setupConnectorEvents(sessionId, connector);
        // Connect to sandbox
        await connector.connect();
        const connectionInfo = connector.getConnectionInfo();
        if (!connectionInfo) {
            throw new Error("Failed to get connection info from connector");
        }
        const instanceInfo = {
            sessionId,
            connector,
            connectionInfo,
            createdAt: new Date(),
            lastUsed: new Date(),
            isActive: true,
        };
        this.instances.set(sessionId, instanceInfo);
        this.emit('instance-created', instanceInfo);
        console.log(`✅ Created browser instance for session: ${sessionId}`);
        return instanceInfo;
    }
    /**
     * Get existing instance without creating new one
     */
    getExistingInstance(sessionId) {
        const instance = this.instances.get(sessionId);
        if (instance && instance.isActive) {
            instance.lastUsed = new Date();
            return instance;
        }
        return undefined;
    }
    /**
     * Remove and cleanup specific instance
     */
    async removeInstance(sessionId) {
        const instance = this.instances.get(sessionId);
        if (!instance) {
            console.warn(`Instance not found for session: ${sessionId}`);
            return;
        }
        try {
            // Disconnect and cleanup
            await instance.connector.disconnect();
            instance.isActive = false;
            this.instances.delete(sessionId);
            this.emit('instance-removed', sessionId);
            console.log(`✅ Removed browser instance for session: ${sessionId}`);
        }
        catch (error) {
            console.error(`Failed to remove instance for session ${sessionId}:`, error);
            throw error;
        }
    }
    /**
     * Get all active instances
     */
    getActiveInstances() {
        return Array.from(this.instances.values()).filter(instance => instance.isActive);
    }
    /**
     * Get instance count
     */
    getInstanceCount() {
        return this.instances.size;
    }
    /**
     * Health check for specific instance
     */
    async checkInstanceHealth(sessionId) {
        const instance = this.instances.get(sessionId);
        if (!instance || !instance.isActive) {
            return false;
        }
        try {
            return await instance.connector.healthCheck();
        }
        catch (error) {
            console.error(`Health check failed for session ${sessionId}:`, error);
            return false;
        }
    }
    /**
     * Cleanup expired instances
     */
    async cleanupExpiredInstances() {
        const now = new Date();
        const expiredSessions = [];
        for (const [sessionId, instance] of this.instances.entries()) {
            const ageInSeconds = (now.getTime() - instance.lastUsed.getTime()) / 1000;
            if (ageInSeconds > this.config.instanceTtl) {
                expiredSessions.push(sessionId);
            }
        }
        console.log(`Cleaning up ${expiredSessions.length} expired instances`);
        for (const sessionId of expiredSessions) {
            try {
                await this.removeInstance(sessionId);
            }
            catch (error) {
                console.error(`Failed to cleanup expired instance ${sessionId}:`, error);
            }
        }
        if (expiredSessions.length > 0) {
            this.emit('cleanup-completed', expiredSessions);
        }
    }
    /**
     * Cleanup all instances
     */
    async cleanup() {
        console.log(`Cleaning up all ${this.instances.size} browser instances`);
        const sessionIds = Array.from(this.instances.keys());
        for (const sessionId of sessionIds) {
            try {
                await this.removeInstance(sessionId);
            }
            catch (error) {
                console.error(`Failed to cleanup instance ${sessionId}:`, error);
            }
        }
        this.stopCleanupTimer();
        console.log("✅ All browser instances cleaned up");
    }
    /**
     * Setup event handlers for connector
     */
    setupConnectorEvents(sessionId, connector) {
        connector.on('error', (error) => {
            console.error(`Connector error for session ${sessionId}:`, error);
            this.emit('instance-error', sessionId, error);
        });
        connector.on('disconnected', () => {
            console.log(`Connector disconnected for session ${sessionId}`);
            const instance = this.instances.get(sessionId);
            if (instance) {
                instance.isActive = false;
            }
            this.emit('instance-disconnected', sessionId);
        });
        connector.on('reconnected', () => {
            console.log(`Connector reconnected for session ${sessionId}`);
            const instance = this.instances.get(sessionId);
            if (instance) {
                instance.isActive = true;
                instance.lastUsed = new Date();
            }
            this.emit('instance-reconnected', sessionId);
        });
    }
    /**
     * Start cleanup timer
     */
    startCleanupTimer() {
        if (this.cleanupTimer) {
            clearInterval(this.cleanupTimer);
        }
        this.cleanupTimer = setInterval(async () => {
            try {
                await this.cleanupExpiredInstances();
            }
            catch (error) {
                console.error("Error during scheduled cleanup:", error);
            }
        }, this.config.cleanupInterval * 1000);
        console.log(`Started cleanup timer with interval: ${this.config.cleanupInterval}s`);
    }
    /**
     * Stop cleanup timer
     */
    stopCleanupTimer() {
        if (this.cleanupTimer) {
            clearInterval(this.cleanupTimer);
            this.cleanupTimer = undefined;
        }
    }
    /**
     * Get statistics
     */
    getStatistics() {
        const instances = this.getActiveInstances();
        return {
            totalInstances: this.instances.size,
            activeInstances: instances.length,
            oldestInstance: instances.length > 0
                ? new Date(Math.min(...instances.map(i => i.createdAt.getTime())))
                : undefined,
            newestInstance: instances.length > 0
                ? new Date(Math.max(...instances.map(i => i.createdAt.getTime())))
                : undefined,
        };
    }
}
exports.BrowserInstanceManager = BrowserInstanceManager;
//# sourceMappingURL=browser-instance-manager.js.map