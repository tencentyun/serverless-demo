"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMultieditTool = createMultieditTool;
const v4_1 = require("zod/v4");
const utils_1 = require("./utils");
const utils_2 = require("../utils");
const singleEditSchema = v4_1.z.object({
    old_string: v4_1.z
        .string()
        .describe("The exact text to find and replace. Must match exactly including whitespace, indentation, and context. For single replacements, include 2+ lines of context before and after the target text."),
    new_string: v4_1.z
        .string()
        .describe("The text to replace it with (must be different from old_string)"),
    expected_replacements: v4_1.z
        .number()
        .min(1)
        .optional()
        .describe("The expected number of replacements to perform. Defaults to 1 if not specified."),
});
const multieditParametersSchema = v4_1.z.object({
    file_path: v4_1.z.string().describe("The absolute path to the file to modify"),
    edits: v4_1.z
        .array(singleEditSchema)
        .min(1)
        .describe("Array of edit operations to perform sequentially on the file"),
    // fail_fast: z
    //   .boolean()
    //   .optional()
    //   .describe(
    //     'Whether to stop on first error (true) or continue with remaining edits (false, default)'
    //   ),
});
// Path validation is now handled by validateWorkspacePath in tool-utils
/**
 * Escape special regex characters
 */
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
/**
 * Apply a single edit to content
 */
function applySingleEdit(content, edit) {
    const expectedReplacements = edit.expected_replacements ?? 1;
    // Count occurrences
    const regex = new RegExp(escapeRegExp(edit.old_string), "g");
    const matches = content.match(regex) || [];
    const occurrences = matches.length;
    // Validate occurrence count
    if (occurrences === 0) {
        return {
            edit,
            success: false,
            occurrences: 0,
            error: `Text not found: "${edit.old_string.substring(0, 50)}${edit.old_string.length > 50 ? "..." : ""}"`,
        };
    }
    if (occurrences !== expectedReplacements) {
        return {
            edit,
            success: false,
            occurrences,
            error: `Expected ${expectedReplacements} replacement(s) but found ${occurrences} occurrence(s)`,
        };
    }
    return {
        edit,
        success: true,
        occurrences,
    };
}
function createMultieditTool(context) {
    return (0, utils_2.tool)(async (params) => {
        try {
            const { file_path, edits } = params;
            const fail_fast = true;
            // Validate workspace path (handles both absolute and relative paths)
            const pathError = (0, utils_1.validateWorkspacePath)(file_path, context);
            if (pathError) {
                return pathError;
            }
            // Resolve path
            const absolutePath = (0, utils_1.resolveWorkspacePath)(file_path, context);
            // Check if file exists
            const fileError = await (0, utils_1.validateFileExists)(context, absolutePath, file_path);
            if (fileError) {
                return fileError;
            }
            console.log(`Performing ${edits.length} edit(s) on: ${file_path}`);
            // Read current content
            let currentContent;
            try {
                currentContent = (await context.fsOperator.readFile(absolutePath, "utf8")).toString();
                // Normalize line endings to LF
                currentContent = currentContent.replace(/\r\n/g, "\n");
            }
            catch (error) {
                return (0, utils_2.handleToolError)(error, "Failed to read file", "permission");
            }
            const originalContent = currentContent;
            const editResults = [];
            let successCount = 0;
            let totalReplacements = 0;
            // Apply edits sequentially
            for (let i = 0; i < edits.length; i++) {
                const edit = edits[i];
                console.log(`Applying edit ${i + 1}/${edits.length}: "${edit.old_string.substring(0, 30)}..." => "${edit.new_string.substring(0, 30)}..."`);
                const editResult = applySingleEdit(currentContent, edit);
                editResults.push(editResult);
                if (editResult.success) {
                    // Apply the edit
                    currentContent = currentContent
                        .split(edit.old_string)
                        .join(edit.new_string);
                    successCount++;
                    totalReplacements += editResult.occurrences;
                    console.log(`✓ Edit ${i + 1} successful: ${editResult.occurrences} replacement(s)`);
                }
                else {
                    console.log(`✗ Edit ${i + 1} failed: ${editResult.error}`);
                    if (fail_fast) {
                        return (0, utils_2.handleToolError)(`Edit operation failed at step ${i + 1}: ${editResult.error}`, "Edit sequence", "execution");
                    }
                }
            }
            // Write the updated content if any edits were successful
            if (successCount > 0) {
                await context.fsOperator.writeFile(absolutePath, currentContent);
            }
            const newLines = currentContent.split("\n").length;
            const newSize = Buffer.byteLength(currentContent, "utf8");
            console.log(`Multi-edit completed: ${successCount}/${edits.length} edits successful, ${totalReplacements} total replacements`);
            return (0, utils_1.createSuccessResponse)({
                file_path,
                absolute_path: absolutePath,
                edits_total: edits.length,
                edits_successful: successCount,
                edits_failed: edits.length - successCount,
                total_replacements: totalReplacements,
                lines_total: newLines,
                bytes_total: newSize,
                content_changed: currentContent !== originalContent,
                edit_results: editResults,
            });
        }
        catch (error) {
            return (0, utils_2.handleToolError)(error, "Multiedit tool execution", "execution");
        }
    }, {
        name: "MultiEdit",
        description: "Perform multiple find-and-replace operations on a single file in sequence. Each edit is applied to the result of the previous edit. Accepts both relative and absolute file paths within the workspace.",
        schema: multieditParametersSchema,
        getDisplay: ({ name, input }) => {
            return `> Using ${name} for tool call: ${input.file_path || ""}`;
        },
    });
}
//# sourceMappingURL=multiedit-tool.js.map