// src/agent.ts
import {
  EventType,
  AbstractAgent
} from "@ag-ui/client";
import { Observable } from "rxjs";
import {
  Annotation,
  MessagesAnnotation,
  Command
} from "@langchain/langgraph";

// src/util.ts
import { DynamicStructuredTool } from "@langchain/core/tools";
import z from "zod/v4";
function convertActionsToDynamicStructuredTools(tools) {
  return tools.map(convertActionToDynamicStructuredTool);
}
function convertActionToDynamicStructuredTool(actionInput) {
  return new DynamicStructuredTool({
    name: actionInput.name,
    description: actionInput.description,
    schema: convertJsonSchemaToZodSchema(actionInput.parameters, true),
    func: async () => {
      return "";
    }
  });
}
function convertJsonSchemaToZodSchema(jsonSchema, required) {
  if (jsonSchema.type === "object") {
    const spec = {};
    if (!jsonSchema.properties || !Object.keys(jsonSchema.properties).length) {
      return !required ? z.object(spec).optional() : z.object(spec);
    }
    for (const [key, value] of Object.entries(jsonSchema.properties)) {
      spec[key] = convertJsonSchemaToZodSchema(
        value,
        jsonSchema.required ? jsonSchema.required.includes(key) : false
      );
    }
    let schema = z.object(spec).describe(jsonSchema.description);
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "string") {
    let schema = z.string().describe(jsonSchema.description);
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "number") {
    let schema = z.number().describe(jsonSchema.description);
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "boolean") {
    let schema = z.boolean().describe(jsonSchema.description);
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "array") {
    let itemSchema = convertJsonSchemaToZodSchema(jsonSchema.items, true);
    let schema = z.array(itemSchema).describe(jsonSchema.description);
    return required ? schema : schema.optional();
  }
  throw new Error("Invalid JSON schema");
}

// src/agent.ts
var ClientPropertiesAnnotation = Annotation.Root({
  tools: Annotation
});
var ClientStateAnnotation = Annotation.Root({
  client: Annotation,
  ...MessagesAnnotation.spec
});
var LanggraphAgent = class extends AbstractAgent {
  constructor(agentConfig) {
    super(agentConfig);
    this.compiledWorkflow = agentConfig.compiledWorkflow;
  }
  run(input) {
    return new Observable((subscriber) => {
      this._run(subscriber, input);
    });
  }
  async _run(subscriber, input) {
    const { messages, runId, threadId } = input;
    subscriber.next({
      type: EventType.RUN_STARTED,
      threadId,
      runId
    });
    const streamEventInput = input.forwardedProps?.resume ? new Command({
      resume: JSON.stringify(input.forwardedProps?.resume?.payload)
    }) : {
      messages: aguiMessagesToLangChain(messages),
      client: {
        tools: convertActionsToDynamicStructuredTools(
          input.tools.map((x) => ({
            ...x,
            parameters: typeof x.parameters === "string" ? JSON.parse(x.parameters) : x.parameters
          }))
        )
      }
    };
    const stream = this.compiledWorkflow.streamEvents(streamEventInput, {
      version: "v2",
      runId,
      configurable: {
        thread_id: threadId
      }
    });
    const chatModelRuns = [];
    const handledToolCallIds = /* @__PURE__ */ new Set();
    for (const msg of messages) {
      if (msg.role === "tool" && msg.toolCallId) {
        handledToolCallIds.add(msg.toolCallId);
      }
    }
    let interrupt;
    let currentToolCall = null;
    for await (const event of stream) {
      if (event.event.startsWith("ChannelWrite<")) {
        continue;
      }
      if (event.event === "on_chat_model_start") {
        chatModelRuns.push({ runId: event.run_id });
        continue;
      }
      if (event.event === "on_chat_model_stream") {
        let chatModelRun = chatModelRuns.find(
          (run) => run.runId === event.run_id
        );
        if (!chatModelRun) {
          subscriber.next({
            type: EventType.RUN_ERROR,
            message: `Received a message from an unknown chat model run. Run Id: ${event.run_id}`
          });
          continue;
        }
        const chunkId = event.data.chunk.id;
        if (!chatModelRun.messageId) {
          chatModelRun.messageId = chunkId;
          subscriber.next({
            messageId: chunkId,
            type: EventType.TEXT_MESSAGE_START,
            role: "assistant"
          });
        } else if (chatModelRun.messageId !== chunkId) {
          subscriber.next({
            type: EventType.RUN_ERROR,
            message: `Received a message of unknown message id from current run. Run Id: ${event.run_id} Message Id from current run: ${chatModelRun.messageId} Message Id from received message: ${chunkId}`
          });
          continue;
        }
        if (Array.isArray(event.data.chunk?.tool_call_chunks) && event.data.chunk?.tool_call_chunks?.length > 0) {
          const parentMessageId = chatModelRun.messageId;
          event.data.chunk.tool_call_chunks.map((x) => ({
            ...x,
            args: typeof x.args === "string" ? x.args : x.args ? JSON.stringify(x.args) : ""
          })).forEach((toolCall) => {
            if (currentToolCall) {
              if (toolCall.id && currentToolCall.id !== toolCall.id) {
                subscriber.next({
                  toolCallId: currentToolCall.id,
                  type: EventType.TOOL_CALL_END
                });
                if (toolCall.name && toolCall.id) {
                  currentToolCall = toolCall;
                  subscriber.next({
                    toolCallId: currentToolCall.id,
                    toolCallName: currentToolCall.name,
                    parentMessageId,
                    type: EventType.TOOL_CALL_START
                  });
                  if (currentToolCall.args) {
                    subscriber.next({
                      toolCallId: currentToolCall.id,
                      delta: currentToolCall.args,
                      type: EventType.TOOL_CALL_ARGS
                    });
                    if (isValidJson(currentToolCall.args)) {
                      subscriber.next({
                        toolCallId: currentToolCall.id,
                        type: EventType.TOOL_CALL_END
                      });
                      currentToolCall = null;
                    }
                  }
                }
              } else {
                if (toolCall.args) {
                  currentToolCall.args += toolCall.args;
                  subscriber.next({
                    toolCallId: currentToolCall.id,
                    delta: toolCall.args,
                    type: EventType.TOOL_CALL_ARGS
                  });
                  if (isValidJson(currentToolCall.args)) {
                    subscriber.next({
                      toolCallId: currentToolCall.id,
                      type: EventType.TOOL_CALL_END
                    });
                    currentToolCall = null;
                  }
                }
              }
            } else {
              if (toolCall.name && toolCall.id) {
                currentToolCall = toolCall;
                subscriber.next({
                  toolCallId: toolCall.id,
                  toolCallName: toolCall.name,
                  parentMessageId,
                  type: EventType.TOOL_CALL_START
                });
                if (toolCall.args) {
                  subscriber.next({
                    toolCallId: toolCall.id,
                    delta: toolCall.args,
                    type: EventType.TOOL_CALL_ARGS
                  });
                  if (isValidJson(toolCall.args)) {
                    subscriber.next({
                      toolCallId: toolCall.id,
                      type: EventType.TOOL_CALL_END
                    });
                    currentToolCall = null;
                  }
                }
              }
            }
          });
        }
        const delta = event.data.chunk.content;
        if (typeof delta === "string" && delta) {
          subscriber.next({
            messageId: chatModelRun.messageId,
            type: EventType.TEXT_MESSAGE_CONTENT,
            delta
          });
        }
        continue;
      }
      if (event.event === "on_chat_model_end") {
        const chatModelRun = chatModelRuns.find(
          (run) => run.runId === event.run_id
        );
        if (!chatModelRun) {
          subscriber.next({
            type: EventType.RUN_ERROR,
            message: `Received a on_chat_model_end event from an unknown chat model run. Run Id: ${event.run_id}`
          });
          continue;
        }
        subscriber.next({
          type: EventType.TEXT_MESSAGE_END,
          messageId: chatModelRun.messageId
        });
        continue;
      }
      if (event.event === "on_tool_end") {
        const toolMessage = event.data.output;
        if (toolMessage && toolMessage.tool_call_id) {
          if (!handledToolCallIds.has(toolMessage.tool_call_id)) {
            if (!toolMessage.id) {
              toolMessage.id = crypto.randomUUID();
              if (toolMessage.lc_kwargs) {
                toolMessage.lc_kwargs.id = toolMessage.id;
              }
            }
            subscriber.next({
              toolCallId: toolMessage.tool_call_id,
              type: EventType.TOOL_CALL_RESULT,
              content: typeof toolMessage.content === "string" ? toolMessage.content : JSON.stringify(toolMessage.content),
              messageId: toolMessage.id
            });
            handledToolCallIds.add(toolMessage.tool_call_id);
          }
        }
        continue;
      }
      if (event.event === "on_chain_stream" && event.data.chunk?.__interrupt__ && Array.isArray(event.data.chunk.__interrupt__) && event.data.chunk.__interrupt__.length > 0) {
        const rawInterrupt = event.data.chunk.__interrupt__[0];
        interrupt = {
          id: rawInterrupt.id,
          // TODO: replace with actual reason
          reason: "agent requested interrupt",
          payload: rawInterrupt.value
        };
      }
    }
    if (interrupt) {
      subscriber.next({
        type: EventType.RUN_FINISHED,
        threadId,
        runId,
        outcome: "interrupt",
        interrupt
      });
    } else {
      subscriber.next({
        type: EventType.RUN_FINISHED,
        threadId,
        runId
      });
    }
    subscriber.complete();
  }
  clone() {
    const workflow = this.compiledWorkflow;
    this.compiledWorkflow = void 0;
    const cloned = super.clone();
    this.compiledWorkflow = workflow;
    cloned.compiledWorkflow = workflow;
    return cloned;
  }
};
function aguiMessagesToLangChain(messages) {
  return messages.map((message, index) => {
    switch (message.role) {
      case "user":
        if (typeof message.content === "string") {
          return {
            id: message.id,
            role: message.role,
            content: message.content,
            type: "human"
          };
        } else {
          return {
            id: message.id,
            role: message.role,
            content: message.content.filter((m) => m.type === "text"),
            type: "human"
          };
        }
      case "assistant":
        return {
          id: message.id,
          type: "ai",
          role: message.role,
          content: message.content ?? "",
          tool_calls: (message.toolCalls ?? []).map((tc) => ({
            id: tc.id,
            name: tc.function.name,
            args: JSON.parse(tc.function.arguments),
            type: "tool_call"
          }))
        };
      case "system":
        return {
          id: message.id,
          role: message.role,
          content: message.content,
          type: "system"
        };
      case "tool":
        return {
          content: message.content,
          role: message.role,
          type: message.role,
          tool_call_id: message.toolCallId,
          id: message.id
        };
      default:
        console.error(`Message role ${message.role} is not implemented`);
        throw new Error("message role is not supported.");
    }
  });
}
function isValidJson(json) {
  try {
    JSON.parse(json);
    return true;
  } catch (e) {
    return false;
  }
}

// src/checkpoint.ts
import {
  BaseCheckpointSaver
} from "@langchain/langgraph";
import {
  MemoryClient,
  Order
} from "@cloudbase/agent-agents";
var TDAISaver = class extends BaseCheckpointSaver {
  constructor(config) {
    super();
    const {
      checkpointType = "checkpoints",
      checkpointWritesType = "checkpoint_writes",
      ...clientConfig
    } = config;
    this.memoryClient = new MemoryClient(clientConfig);
    this.checkpointType = checkpointType;
    this.checkpointWritesType = checkpointWritesType;
  }
  /**
   * Retrieves a checkpoint from TDAI Memory based on the provided config.
   * If the config contains a "checkpoint_id" key, the checkpoint with the matching
   * thread ID and checkpoint ID is retrieved. Otherwise, the latest checkpoint
   * for the given thread ID is retrieved.
   */
  async getTuple(config) {
    try {
      const {
        thread_id,
        checkpoint_ns = "",
        checkpoint_id
      } = config.configurable ?? {};
      if (!thread_id) {
        return void 0;
      }
      const query = {
        collection: this.checkpointType,
        checkpoint_ns
      };
      if (checkpoint_id) {
        query.checkpoint_id = checkpoint_id;
      }
      const { events = [] } = await this.memoryClient.queryEvents({
        sessionId: thread_id,
        where: query,
        orderBy: { checkpoint_id: Order.DESCENDING },
        limit: 1
      });
      if (events.length === 0) {
        return void 0;
      }
      const doc = events[0];
      const configurableValues = {
        checkpoint_ns,
        checkpoint_id: doc.checkpoint_id
      };
      const checkpoint = doc.checkpoint;
      const { events: serializedWrites = [] } = await this.memoryClient.queryEvents({
        sessionId: thread_id,
        where: {
          collection: this.checkpointWritesType,
          ...configurableValues
        }
      });
      const pendingWrites = serializedWrites.map(
        (serializedWrite) => {
          return [
            serializedWrite.task_id,
            serializedWrite.channel,
            serializedWrite.value
          ];
        }
      );
      const metadata = doc.metadata || {};
      return {
        config: { configurable: configurableValues },
        checkpoint,
        pendingWrites,
        metadata,
        parentConfig: doc.parent_checkpoint_id != null ? {
          configurable: {
            thread_id,
            checkpoint_ns,
            checkpoint_id: doc.parent_checkpoint_id
          }
        } : void 0
      };
    } catch (error) {
      console.error("Error getting checkpoint:", error);
      return void 0;
    }
  }
  /**
   * Retrieve a list of checkpoint tuples from TDAI Memory based on the provided config.
   * The checkpoints are ordered by checkpoint ID in descending order (newest first).
   */
  async *list(config, options) {
    const { limit, before, filter } = options ?? {};
    if (!config?.configurable?.thread_id) {
      throw new Error("Thread ID is required");
    }
    const query = {
      collection: this.checkpointType
    };
    if (config?.configurable?.checkpoint_ns !== void 0 && config?.configurable?.checkpoint_ns !== null) {
      query.checkpoint_ns = config.configurable.checkpoint_ns;
    }
    if (filter) {
      Object.entries(filter).forEach(([key, value]) => {
        query[`metadata.${key}`] = value;
      });
    }
    if (before) {
      query.checkpoint_id = { $lt: before.configurable?.checkpoint_id };
    }
    const { events = [] } = await this.memoryClient.queryEvents({
      sessionId: config?.configurable?.thread_id || "default",
      where: query,
      orderBy: { checkpoint_id: Order.DESCENDING },
      limit
    });
    for (const doc of events) {
      const checkpoint = doc.checkpoint;
      const metadata = doc.metadata || {};
      yield {
        config: {
          configurable: {
            thread_id: doc.thread_id,
            checkpoint_ns: doc.checkpoint_ns,
            checkpoint_id: doc.checkpoint_id
          }
        },
        checkpoint,
        metadata,
        parentConfig: doc.parent_checkpoint_id ? {
          configurable: {
            thread_id: doc.thread_id,
            checkpoint_ns: doc.checkpoint_ns,
            checkpoint_id: doc.parent_checkpoint_id
          }
        } : void 0
      };
    }
  }
  /**
   * Saves a checkpoint to TDAI Memory. The checkpoint is associated with the
   * provided config and its parent config (if any).
   */
  async put(config, checkpoint, metadata) {
    try {
      const thread_id = config.configurable?.thread_id;
      const checkpoint_ns = config.configurable?.checkpoint_ns ?? "";
      const checkpoint_id = checkpoint.id;
      if (thread_id === void 0) {
        throw new Error(
          `The provided config must contain a configurable field with a "thread_id" field.`
        );
      }
      const doc = {
        collection: this.checkpointType,
        checkpoint_ns,
        checkpoint_id,
        parent_checkpoint_id: config.configurable?.checkpoint_id,
        checkpoint,
        metadata
      };
      const { events = [] } = await this.memoryClient.queryEvents({
        sessionId: thread_id,
        where: {
          collection: this.checkpointType,
          checkpoint_ns,
          checkpoint_id
        }
      });
      if (events[0]) {
        this.memoryClient.deleteEvent({
          sessionId: thread_id,
          eventId: events[0].id
          //   messages: doc,
        });
      } else {
        await this.memoryClient.appendEvent({
          sessionId: thread_id,
          messages: doc
        });
      }
      return {
        configurable: {
          thread_id,
          checkpoint_ns,
          checkpoint_id
        }
      };
    } catch (error) {
      console.error("Error saving checkpoint:", error);
      throw error;
    }
  }
  /**
   * Saves intermediate writes associated with a checkpoint to TDAI Memory.
   */
  async putWrites(config, writes, taskId) {
    try {
      const thread_id = config.configurable?.thread_id;
      const checkpoint_ns = config.configurable?.checkpoint_ns;
      const checkpoint_id = config.configurable?.checkpoint_id;
      if (thread_id === void 0 || checkpoint_ns === void 0 || checkpoint_id === void 0) {
        throw new Error(
          `The provided config must contain a configurable field with "thread_id", "checkpoint_ns" and "checkpoint_id" fields.`
        );
      }
      const writePromises = writes.map(async ([channel, value], idx) => {
        const writeDoc = {
          collection: this.checkpointWritesType,
          checkpoint_ns,
          checkpoint_id,
          task_id: taskId,
          idx,
          channel,
          value
          // Store directly as JSON
        };
        return this.memoryClient.appendEvent({
          sessionId: thread_id,
          messages: writeDoc
        });
      });
      await Promise.all(writePromises);
    } catch (error) {
      console.error("Error storing writes:", error);
      throw error;
    }
  }
  /**
   * Delete all checkpoints and writes for a thread from TDAI Memory.
   */
  async deleteThread(threadId) {
    try {
      await this.memoryClient.deleteSession({
        sessionId: threadId
      });
    } catch (error) {
      console.error("Error deleting thread:", error);
      throw error;
    }
  }
  /**
   * Close the memory client connection
   */
  close() {
    this.memoryClient.close();
  }
};

// src/store/tdai-store.ts
import {
  BaseStore
} from "@langchain/langgraph";
var TDAIStore = class extends BaseStore {
  constructor(config) {
    super();
    this.isSetup = false;
    this.isClosed = false;
    this.client = config.memoryClient;
    this.namespacePrefix = config.namespacePrefix || [];
    this.ttlConfig = config.ttl;
    this.ensureTables = config.ensureTables ?? true;
    this.sessionId = config.sessionId || "default_session";
    this.defaultStrategy = config.defaultStrategy || "store";
  }
  /**
   * Create a storage key from namespace and key
   */
  createStorageKey(namespace, key) {
    const fullNamespace = [...this.namespacePrefix, ...namespace];
    return `${fullNamespace.join(":")}:${key}`;
  }
  /**
   * Parse a storage key back to namespace and key
   */
  parseStorageKey(storageKey) {
    const parts = storageKey.split(":");
    const prefixLength = this.namespacePrefix.length;
    const namespace = parts.slice(prefixLength, -1);
    const key = parts[parts.length - 1];
    return { namespace, key };
  }
  /**
   * Put an item with optional TTL.
   */
  async put(namespace, key, value, index, options) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const storageKey = this.createStorageKey(namespace, key);
    const content = JSON.stringify({
      storageKey,
      namespace,
      key,
      value,
      index,
      ttl: options?.ttl || this.ttlConfig?.defaultTtlSeconds
    });
    await this.client.appendRecord({
      sessionId: this.sessionId,
      content,
      strategy: this.defaultStrategy
    });
  }
  /**
   * Get an item by namespace and key.
   */
  async get(namespace, key) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const storageKey = this.createStorageKey(namespace, key);
    try {
      const { records = [] } = await this.client.searchRecords({
        content: storageKey,
        sessionId: this.sessionId,
        limit: 1
      });
      if (!records.length) {
        return null;
      }
      const record = records[0];
      const data = JSON.parse(record.record_content);
      if (data.ttl && record.created_at) {
        const createdTime = new Date(record.created_at).getTime();
        const now = Date.now();
        if (now > createdTime + data.ttl * 1e3) {
          await this.delete(namespace, key);
          return null;
        }
      }
      return {
        namespace,
        key,
        value: data.value,
        createdAt: new Date(record.created_at || Date.now()),
        updatedAt: new Date(record.updated_at || Date.now())
      };
    } catch (error) {
      return null;
    }
  }
  /**
   * Delete an item by namespace and key.
   */
  async delete(namespace, key) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const storageKey = this.createStorageKey(namespace, key);
    try {
      const { records = [] } = await this.client.searchRecords({
        content: storageKey,
        sessionId: this.sessionId,
        limit: 1
      });
      const record = records[0];
      if (record) {
        await this.client.deleteRecord({
          sessionId: this.sessionId,
          recordId: record.record_id
        });
      }
    } catch (error) {
    }
  }
  /**
   * List namespaces with optional filtering.
   */
  async listNamespaces(options = {}) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const { prefix, suffix, maxDepth, limit = 100, offset = 0 } = options;
    try {
      const { records = [] } = await this.client.queryRecords({
        limit: 1e3
        // Large limit to get all records
      });
      const namespaceSet = /* @__PURE__ */ new Set();
      for (const record of records) {
        try {
          const data = JSON.parse(record.record_content);
          if (data.namespace) {
            const namespace = data.namespace;
            if (prefix && prefix.length > 0) {
              const hasPrefix = prefix.every((p, i) => namespace[i] === p);
              if (!hasPrefix) continue;
            }
            if (suffix && suffix.length > 0) {
              const namespaceSuffix = namespace.slice(-suffix.length);
              if (JSON.stringify(namespaceSuffix) !== JSON.stringify(suffix)) {
                continue;
              }
            }
            if (maxDepth !== void 0 && namespace.length > maxDepth) {
              continue;
            }
            namespaceSet.add(JSON.stringify(namespace));
          }
        } catch (error) {
        }
      }
      const namespaces = Array.from(namespaceSet).map((ns) => JSON.parse(ns)).sort().slice(offset, offset + limit);
      return namespaces;
    } catch (error) {
      return [];
    }
  }
  /**
   * Execute multiple operations in a single batch.
   */
  async batch(operations) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const results = [];
    for (const operation of operations) {
      if ("namespacePrefix" in operation) {
        results.push(await this.executeSearch(operation));
      } else if ("key" in operation && !("value" in operation)) {
        const getOp = operation;
        results.push(await this.get(getOp.namespace, getOp.key));
      } else if ("value" in operation) {
        const putOp = operation;
        if (putOp.value !== null) {
          await this.put(
            putOp.namespace,
            putOp.key,
            putOp.value,
            putOp.index,
            putOp.options
          );
        }
        results.push(void 0);
      } else if ("matchConditions" in operation) {
        const listOp = operation;
        results.push(await this.executeListNamespaces(listOp));
      } else {
        throw new Error(
          `Unsupported operation type: ${JSON.stringify(operation)}`
        );
      }
    }
    return results;
  }
  /**
   * Execute search operation
   */
  async executeSearch(operation) {
    const { namespacePrefix, ...searchOptions } = operation;
    return this.search(namespacePrefix, searchOptions);
  }
  /**
   * Execute list namespaces operation
   */
  async executeListNamespaces(operation) {
    const { matchConditions, maxDepth, limit = 100, offset = 0 } = operation;
    let prefix;
    let suffix;
    if (matchConditions && matchConditions.length > 0) {
      for (const condition of matchConditions) {
        if (condition.matchType === "prefix") {
          prefix = condition.path;
        } else if (condition.matchType === "suffix") {
          suffix = condition.path;
        }
      }
    }
    return this.listNamespaces({
      prefix,
      suffix,
      maxDepth,
      limit,
      offset
    });
  }
  /**
   * Initialize the store.
   */
  async setup() {
    if (this.isSetup) return;
    if (this.ttlConfig?.sweepIntervalMinutes) {
      const intervalMs = this.ttlConfig.sweepIntervalMinutes * 60 * 1e3;
      this.sweepInterval = setInterval(async () => {
        try {
          await this.sweepExpiredItems();
        } catch (error) {
          console.error("Error during TTL sweep:", error);
        }
      }, intervalMs);
    }
    this.isSetup = true;
  }
  /**
   * Start the store.
   */
  async start() {
    if (this.ensureTables && !this.isSetup) {
      await this.setup();
    }
  }
  /**
   * Stop the store and close all connections.
   */
  async stop() {
    if (this.isClosed) return;
    if (this.sweepInterval) {
      clearInterval(this.sweepInterval);
      this.sweepInterval = void 0;
    }
    this.client.close();
    this.isClosed = true;
  }
  /**
   * Manually sweep expired items from the store.
   */
  async sweepExpiredItems() {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    try {
      const { records = [] } = await this.client.queryRecords({
        limit: 1e3
      });
      let cleanedCount = 0;
      const now = Date.now();
      for (const record of records) {
        try {
          const data = JSON.parse(record.record_content);
          if (data.ttl && data.createdAt) {
            const createdTime = new Date(data.createdAt).getTime();
            if (now > createdTime + data.ttl * 1e3) {
              await this.client.deleteRecord({
                sessionId: this.sessionId,
                recordId: record.record_id
              });
              cleanedCount++;
            }
          }
        } catch (error) {
        }
      }
      return cleanedCount;
    } catch (error) {
      return 0;
    }
  }
  /**
   * Get statistics about the store.
   */
  async getStats() {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    try {
      const { records = [] } = await this.client.queryRecords({
        limit: 1e3
      });
      let totalItems = 0;
      let expiredItems = 0;
      const namespaces = /* @__PURE__ */ new Set();
      const dates = [];
      const now = Date.now();
      for (const record of records) {
        try {
          const data = JSON.parse(record.record_content);
          totalItems++;
          if (data.namespace) {
            namespaces.add(data.namespace.join(":"));
          }
          if (data.createdAt) {
            dates.push(new Date(data.createdAt));
          }
          if (data.ttl && data.createdAt) {
            const createdTime = new Date(data.createdAt).getTime();
            if (now > createdTime + data.ttl * 1e3) {
              expiredItems++;
            }
          }
        } catch (error) {
        }
      }
      const oldestItem = dates.length > 0 ? new Date(Math.min(...dates.map((d) => d.getTime()))) : null;
      const newestItem = dates.length > 0 ? new Date(Math.max(...dates.map((d) => d.getTime()))) : null;
      return {
        totalItems,
        expiredItems,
        namespaceCount: namespaces.size,
        oldestItem,
        newestItem
      };
    } catch (error) {
      return {
        totalItems: 0,
        expiredItems: 0,
        namespaceCount: 0,
        oldestItem: null,
        newestItem: null
      };
    }
  }
  /**
   * Search for items in the store with support for text search and filtering.
   */
  async search(namespacePrefix, options = {}) {
    if (!this.isSetup && this.ensureTables) {
      await this.setup();
    }
    const { filter, query, limit = 10, offset = 0, refreshTtl } = options;
    try {
      const namespaceKey = [...this.namespacePrefix, ...namespacePrefix].join(
        ":"
      );
      let searchResult;
      if (query) {
        searchResult = await this.client.searchRecords({
          content: query,
          limit: limit + offset
        });
      } else {
        searchResult = await this.client.queryRecords({
          limit: limit + offset
        });
      }
      const items = [];
      const now = Date.now();
      if (searchResult.records) {
        for (const record of searchResult.records.slice(
          offset,
          offset + limit
        )) {
          try {
            const data = JSON.parse(record.record_content);
            if (namespaceKey && !data.storageKey?.startsWith(namespaceKey)) {
              continue;
            }
            if (data.ttl && data.createdAt) {
              const createdTime = new Date(data.createdAt).getTime();
              if (now > createdTime + data.ttl * 1e3) {
                continue;
              }
            }
            if (filter) {
              let matches = true;
              for (const [key, value] of Object.entries(filter)) {
                if (data.value[key] !== value) {
                  matches = false;
                  break;
                }
              }
              if (!matches) continue;
            }
            const item = {
              namespace: data.namespace,
              key: data.key,
              value: data.value,
              createdAt: new Date(record.created_at || Date.now()),
              updatedAt: new Date(record.updated_at || Date.now())
            };
            items.push(item);
            if (refreshTtl && this.ttlConfig?.defaultTtlSeconds) {
              await this.put(data.namespace, data.key, data.value, void 0, {
                ttl: this.ttlConfig.defaultTtlSeconds
              });
            }
          } catch (error) {
          }
        }
      }
      return items;
    } catch (error) {
      return [];
    }
  }
};
export {
  ClientPropertiesAnnotation,
  ClientStateAnnotation,
  LanggraphAgent,
  TDAISaver,
  TDAIStore
};
//# sourceMappingURL=index.mjs.map