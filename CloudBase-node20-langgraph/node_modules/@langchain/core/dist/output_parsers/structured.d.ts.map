{"version":3,"file":"structured.d.ts","names":["z","BaseOutputParser","FormatInstructionsOptions","InteropZodType","InferInteropZodOutput","JsonMarkdownStructuredOutputParserInput","JsonMarkdownFormatInstructionsOptions","StructuredOutputParser","T","S","___load_serializable_js0","SerializedNotImplemented","ZodString","ZodTypeAny","ZodObject","Promise","JsonMarkdownStructuredOutputParser","AsymmetricStructuredOutputParserFields","AsymmetricStructuredOutputParser","Y","inputSchema"],"sources":["../../src/output_parsers/structured.d.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport { BaseOutputParser, FormatInstructionsOptions } from \"./base.js\";\nimport { type InteropZodType, type InferInteropZodOutput } from \"../utils/types/zod.js\";\nexport type JsonMarkdownStructuredOutputParserInput = {\n    interpolationDepth?: number;\n};\nexport interface JsonMarkdownFormatInstructionsOptions extends FormatInstructionsOptions {\n    interpolationDepth?: number;\n}\nexport declare class StructuredOutputParser<T extends InteropZodType> extends BaseOutputParser<InferInteropZodOutput<T>> {\n    schema: T;\n    static lc_name(): string;\n    lc_namespace: string[];\n    toJSON(): import(\"../load/serializable.js\").SerializedNotImplemented;\n    constructor(schema: T);\n    /**\n     * Creates a new StructuredOutputParser from a Zod schema.\n     * @param schema The Zod schema which the output should match\n     * @returns A new instance of StructuredOutputParser.\n     */\n    static fromZodSchema<T extends InteropZodType>(schema: T): StructuredOutputParser<T>;\n    /**\n     * Creates a new StructuredOutputParser from a set of names and\n     * descriptions.\n     * @param schemas An object where each key is a name and each value is a description\n     * @returns A new instance of StructuredOutputParser.\n     */\n    static fromNamesAndDescriptions<S extends {\n        [key: string]: string;\n    }>(schemas: S): StructuredOutputParser<z.ZodObject<{\n        [k: string]: z.ZodString;\n    }, \"strip\", z.ZodTypeAny, {\n        [x: string]: string;\n    }, {\n        [x: string]: string;\n    }>>;\n    /**\n     * Returns a markdown code snippet with a JSON object formatted according\n     * to the schema.\n     * @param options Optional. The options for formatting the instructions\n     * @returns A markdown code snippet with a JSON object formatted according to the schema.\n     */\n    getFormatInstructions(): string;\n    /**\n     * Parses the given text according to the schema.\n     * @param text The text to parse\n     * @returns The parsed output.\n     */\n    parse(text: string): Promise<InferInteropZodOutput<T>>;\n}\n/**\n * A specific type of `StructuredOutputParser` that parses JSON data\n * formatted as a markdown code snippet.\n */\nexport declare class JsonMarkdownStructuredOutputParser<T extends InteropZodType> extends StructuredOutputParser<T> {\n    static lc_name(): string;\n    getFormatInstructions(options?: JsonMarkdownFormatInstructionsOptions): string;\n    private _schemaToInstruction;\n    static fromZodSchema<T extends InteropZodType>(schema: T): JsonMarkdownStructuredOutputParser<T>;\n    static fromNamesAndDescriptions<S extends {\n        [key: string]: string;\n    }>(schemas: S): JsonMarkdownStructuredOutputParser<z.ZodObject<{\n        [k: string]: z.ZodString;\n    }, \"strip\", z.ZodTypeAny, {\n        [x: string]: string;\n    }, {\n        [x: string]: string;\n    }>>;\n}\nexport interface AsymmetricStructuredOutputParserFields<T extends InteropZodType> {\n    inputSchema: T;\n}\n/**\n * A type of `StructuredOutputParser` that handles asymmetric input and\n * output schemas.\n */\nexport declare abstract class AsymmetricStructuredOutputParser<T extends InteropZodType, Y = unknown> extends BaseOutputParser<Y> {\n    private structuredInputParser;\n    constructor({ inputSchema }: AsymmetricStructuredOutputParserFields<T>);\n    /**\n     * Processes the parsed input into the desired output format. Must be\n     * implemented by subclasses.\n     * @param input The parsed input\n     * @returns The processed output.\n     */\n    abstract outputProcessor(input: InferInteropZodOutput<T>): Promise<Y>;\n    parse(text: string): Promise<Y>;\n    getFormatInstructions(): string;\n}\n//# sourceMappingURL=structured.d.ts.map"],"mappings":";;;;;;KAGYK,uCAAAA;;;AAAAA,UAGKC,qCAAAA,SAA8CJ,yBAHZ,CAAA;EAGlCI,kBAAAA,CAAAA,EAAAA,MAAAA;AAGjB;AAAsDH,cAAjCI,sBAAiCJ,CAAAA,UAAAA,cAAAA,CAAAA,SAAwBF,gBAAxBE,CAAyCC,qBAAzCD,CAA+DK,CAA/DL,CAAAA,CAAAA,CAAAA;EAA+DK,MAAAA,EACzGA,CADyGA;EAAtBJ,OAAAA,OAAAA,CAAAA,CAAAA,EAAAA,MAAAA;EACnFI,YAAAA,EAAAA,MAAAA,EAAAA;;EAIYA,WAAAA,CAAAA,MAAAA,EAAAA,CAAAA;EAMWL;;;;;EAUZS,OAAAA,aAAAA,CAAAA,UAVYT,cAUZS,CAAAA,CAAAA,MAAAA,EAVoCJ,CAUpCI,CAAAA,EAVwCL,sBAUxCK,CAV+DJ,CAU/DI,CAAAA;EACLC;;;;;;EAtB4DZ,OAAAA,wBAAAA,CAAAA,UAAAA;IAAgB,CAAA,GAAA,EAAA,MAAA,CAAA,EAAA,MAAA;EA6CzEe,CAAAA,CAAAA,CAAAA,OAAAA,EAzBLP,CAyBKO,CAAAA,EAzBDT,sBAyBmC,CAzBZP,CAAAA,CAAEc,SAyBUL,CAAAA;IAAWN,CAAAA,CAAAA,EAAAA,MAAAA,CAAAA,EAxB7CH,CAAAA,CAAEY,SAwB2CT;EAA+CK,CAAAA,EAAAA,OAAAA,EAvBjGR,CAAAA,CAAEa,UAuB+FL,EAAAA;IAE7EF,CAAAA,CAAAA,EAAAA,MAAAA,CAAAA,EAAAA,MAAAA;EAEDH,CAAAA,EAAAA;IAAwBK,CAAAA,CAAAA,EAAAA,MAAAA,CAAAA,EAAAA,MAAAA;EAAuCA,CAAAA,CAAAA,CAAAA;EAAnCQ;;;;;;EAJ2BT,qBAAAA,CAAAA,CAAAA,EAAAA,MAAAA;EAAsB;AAehH;AAOA;;;EAEkBa,KAAAA,CAAAA,IAAAA,EAAAA,MAAAA,CAAAA,EA9BOL,OA8BPK,CA9BehB,qBA8BfgB,CA9BqCZ,CA8BrCY,CAAAA,CAAAA;;;;;;AAO6CL,cA/B1CC,kCA+B0CD,CAAAA,UA/BGZ,cA+BHY,CAAAA,SA/B2BR,sBA+B3BQ,CA/BkDP,CA+BlDO,CAAAA,CAAAA;EAC9BI,OAAAA,OAAAA,CAAAA,CAAAA,EAAAA,MAAAA;EAARJ,qBAAAA,CAAAA,OAAAA,CAAAA,EA9BWT,qCA8BXS,CAAAA,EAAAA,MAAAA;EAVqFd,QAAAA,oBAAAA;EAAgB,OAAA,aAAA,CAAA,UAlB3FE,cAkB2F,CAAA,CAAA,MAAA,EAlBnEK,CAkBmE,CAAA,EAlB/DQ,kCAkB+D,CAlB5BR,CAkB4B,CAAA;;;cAf9GC,IAAIO,mCAAmChB,CAAAA,CAAEc;iBACpCd,CAAAA,CAAEY;cACPZ,CAAAA,CAAEa;;;;;;UAMDI,iDAAiDd;eACjDK;;;;;;uBAMaU,2CAA2Cf,qCAAqCF,iBAAiBkB;;;;KAE9FF,uCAAuCT;;;;;;;kCAOpCJ,sBAAsBI,KAAKO,QAAQI;uBAC9CJ,QAAQI"}