{"version":3,"file":"types.d.ts","names":["Client","ThreadState","Interrupt","Message","AIMessage","ToolCallWithResult","StreamMode","Sequence","GetUpdateType","GetConfigurableType","GetInterruptType","GetToolCallsType","MessageMetadata","UseStreamThread","UseStreamOptions","UseStreamTransport","UseStreamCustomOptions","SubmitOptions","CustomSubmitOptions","RunCallbackMeta","BagTemplate","UseStream","Record","StateType","Promise","Bag","UseStreamCustom","Pick"],"sources":["../../src/react/types.d.ts"],"sourcesContent":["import type { Client } from \"../client.js\";\nimport type { ThreadState, Interrupt } from \"../schema.js\";\nimport type { Message, AIMessage, ToolCallWithResult } from \"../types.messages.js\";\nimport type { StreamMode } from \"../types.stream.js\";\nimport type { Sequence } from \"../ui/branching.js\";\nimport type { GetUpdateType, GetConfigurableType, GetInterruptType, GetToolCallsType, MessageMetadata, UseStreamThread, UseStreamOptions, UseStreamTransport, UseStreamCustomOptions, SubmitOptions, CustomSubmitOptions, RunCallbackMeta } from \"../ui/types.js\";\nimport type { BagTemplate } from \"../types.template.js\";\nexport type { GetUpdateType, GetConfigurableType, GetInterruptType, GetToolCallsType, MessageMetadata, UseStreamThread, UseStreamOptions, UseStreamTransport, UseStreamCustomOptions, SubmitOptions, CustomSubmitOptions, RunCallbackMeta, };\nexport interface UseStream<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> {\n    /**\n     * The current values of the thread.\n     */\n    values: StateType;\n    /**\n     * Last seen error from the thread or during streaming.\n     */\n    error: unknown;\n    /**\n     * Whether the stream is currently running.\n     */\n    isLoading: boolean;\n    /**\n     * Whether the thread is currently being loaded.\n     */\n    isThreadLoading: boolean;\n    /**\n     * Stops the stream.\n     */\n    stop: () => Promise<void>;\n    /**\n     * Create and stream a run to the thread.\n     */\n    submit: (values: GetUpdateType<Bag, StateType> | null | undefined, options?: SubmitOptions<StateType, GetConfigurableType<Bag>>) => Promise<void>;\n    /**\n     * The current branch of the thread.\n     */\n    branch: string;\n    /**\n     * Set the branch of the thread.\n     */\n    setBranch: (branch: string) => void;\n    /**\n     * Flattened history of thread states of a thread.\n     */\n    history: ThreadState<StateType>[];\n    /**\n     * Tree of all branches for the thread.\n     * @experimental\n     */\n    experimental_branchTree: Sequence<StateType>;\n    /**\n     * Get the interrupt value for the stream if interrupted.\n     */\n    interrupt: Interrupt<GetInterruptType<Bag>> | undefined;\n    /**\n     * Messages inferred from the thread.\n     * Will automatically update with incoming message chunks.\n     * Includes all message types including ToolMessage.\n     */\n    messages: Message<GetToolCallsType<StateType>>[];\n    /**\n     * Tool calls paired with their results.\n     * Useful for rendering tool invocations and their outputs together.\n     *\n     * Each item contains the tool call from an AI message paired with its\n     * corresponding ToolMessage result (if available), along with lifecycle state.\n     *\n     * @example\n     * ```tsx\n     * // With type-safe tool calls - embed the type in your messages\n     * type MyToolCalls =\n     *   | { name: \"get_weather\"; args: { location: string }; id?: string }\n     *   | { name: \"search\"; args: { query: string }; id?: string };\n     *\n     * interface MyState {\n     *   messages: Message<MyToolCalls>[];\n     * }\n     *\n     * const stream = useStream<MyState>({ ... });\n     *\n     * {stream.toolCalls.map(({ id, call, result, state }) => {\n     *   if (call.name === \"get_weather\") {\n     *     // call.args is { location: string }\n     *     return (\n     *       <WeatherCard\n     *         key={id}\n     *         location={call.args.location}\n     *         result={result?.content}\n     *         isLoading={state === \"pending\"}\n     *       />\n     *     );\n     *   }\n     * })}\n     * ```\n     */\n    toolCalls: ToolCallWithResult<GetToolCallsType<StateType>>[];\n    /**\n     * Get tool calls for a specific AI message.\n     * Useful when rendering messages and their associated tool calls together.\n     *\n     * @param message - The AI message to get tool calls for.\n     * @returns Array of tool calls initiated by the message.\n     *\n     * @example\n     * ```tsx\n     * {stream.uiMessages.map((message) => {\n     *   if (message.type === \"ai\") {\n     *     const toolCalls = stream.getToolCalls(message);\n     *     if (toolCalls.length > 0) {\n     *       return (\n     *         <div key={message.id}>\n     *           {toolCalls.map(tc => <ToolCard key={tc.id} toolCall={tc} />)}\n     *         </div>\n     *       );\n     *     }\n     *   }\n     *   return <MessageBubble key={message.id} message={message} />;\n     * })}\n     * ```\n     */\n    getToolCalls: (message: AIMessage<GetToolCallsType<StateType>>) => ToolCallWithResult<GetToolCallsType<StateType>>[];\n    /**\n     * Get the metadata for a message, such as first thread state the message\n     * was seen in and branch information.\n     *\n     * @param message - The message to get the metadata for.\n     * @param index - The index of the message in the thread.\n     * @returns The metadata for the message.\n     */\n    getMessagesMetadata: (message: Message<GetToolCallsType<StateType>>, index?: number) => MessageMetadata<StateType> | undefined;\n    /**\n     * LangGraph SDK client used to send request and receive responses.\n     */\n    client: Client;\n    /**\n     * The ID of the assistant to use.\n     */\n    assistantId: string;\n    /**\n     * Join an active stream.\n     */\n    joinStream: (runId: string, lastEventId?: string, options?: {\n        streamMode?: StreamMode | StreamMode[];\n    }) => Promise<void>;\n}\nexport type UseStreamCustom<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> = Pick<UseStream<StateType, Bag>, \"values\" | \"error\" | \"isLoading\" | \"stop\" | \"interrupt\" | \"messages\" | \"toolCalls\" | \"getToolCalls\"> & {\n    submit: (values: GetUpdateType<Bag, StateType> | null | undefined, options?: CustomSubmitOptions<StateType, GetConfigurableType<Bag>>) => Promise<void>;\n};\n"],"mappings":";;;;;;;;;UAQiBqB,4BAA4BC,0BAA0BA,qCAAqCF,cAAcA;EAAzGC;;;QAAsDC,EAI3DC,SAJ2DD;;;;OAoBvDE,EAAAA,OAAAA;;;;WAI+ED,EAAAA,OAAAA;;;;iBAAyCC,EAAAA,OAAAA;;;;MAiB3GjB,EAAAA,GAAAA,GArBbiB,OAqBajB,CAAAA,IAAAA,CAAAA;;;;QAUUgB,EAAAA,CAAAA,MAAAA,EA3BlBf,aA2BkBe,CA3BJE,GA2BIF,EA3BCA,SA2BDA,CAAAA,GAAAA,IAAAA,GAAAA,SAAAA,EAAAA,OAAAA,CAAAA,EA3B0CN,aA2B1CM,CA3BwDA,SA2BxDA,EA3BmEd,mBA2BnEc,CA3BuFE,GA2BvFF,CAAAA,CAAAA,EAAAA,GA3BiGC,OA2BjGD,CAAAA,IAAAA,CAAAA;;;;QAoCLZ,EAAAA,MAAAA;;;;WAyBNP,EAAAA,CAAAA,MAAAA,EAAAA,MAAAA,EAAAA,GAAAA,IAAAA;;;;SASgCmB,EArF/CtB,WAqF+CsB,CArFnCA,SAqFmCA,CAAAA,EAAAA;;;;;yBAIhDvB,EApFiBO,QAoFjBP,CApF0BuB,SAoF1BvB,CAAAA;;;;EAUK,SAAA,EA1FFE,SA0FE,CA1FQQ,gBA0FR,CA1FyBe,GA0FzB,CAAA,CAAA,GAAA,SAAA;EAELC;;;;;UAA+GN,EAtF7GjB,OAsF6GiB,CAtFrGT,gBAsFqGS,CAtFpFG,SAsFoFH,CAAAA,CAAAA,EAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;aAlD5Gf,mBAAmBM,iBAAiBY;;;;;;;;;;;;;;;;;;;;;;;;;0BAyBvBnB,UAAUO,iBAAiBY,gBAAgBlB,mBAAmBM,iBAAiBY;;;;;;;;;iCASxEpB,QAAQQ,iBAAiBY,gCAAgCX,gBAAgBW;;;;UAIhGvB;;;;;;;;;iBASSM,aAAaA;QACxBkB;;KAEEE,kCAAkCJ,0BAA0BA,qCAAqCF,cAAcA,eAAeO,KAAKN,UAAUE,WAAWE;mBAC/IjB,cAAciB,KAAKF,yCAAyCL,oBAAoBK,WAAWd,oBAAoBgB,UAAUD"}