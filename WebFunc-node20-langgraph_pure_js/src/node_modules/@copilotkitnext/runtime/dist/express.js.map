{"version":3,"sources":["../src/express.ts","../src/endpoints/express.ts","../src/handlers/handle-run.ts","../src/handlers/header-utils.ts","../src/handlers/handle-connect.ts","../src/handlers/handle-stop.ts","../package.json","../src/runner/in-memory.ts","../src/runtime.ts","../src/handlers/get-runtime-info.ts","../src/handlers/handle-transcribe.ts","../src/middleware.ts","../src/endpoints/express-utils.ts","../src/endpoints/express-single.ts","../src/endpoints/single-route-helpers.ts"],"sourcesContent":["export * from \"./endpoints/express\";\nexport * from \"./endpoints/express-single\";\n\n","import express from \"express\";\nimport type { Request as ExpressRequest, Response as ExpressResponse, NextFunction, Router } from \"express\";\nimport cors from \"cors\";\n\nimport { CopilotRuntime } from \"../runtime\";\nimport { handleRunAgent } from \"../handlers/handle-run\";\nimport { handleConnectAgent } from \"../handlers/handle-connect\";\nimport { handleStopAgent } from \"../handlers/handle-stop\";\nimport { handleGetRuntimeInfo } from \"../handlers/get-runtime-info\";\nimport { handleTranscribe } from \"../handlers/handle-transcribe\";\nimport { logger } from \"@copilotkitnext/shared\";\nimport { callBeforeRequestMiddleware, callAfterRequestMiddleware } from \"../middleware\";\nimport { createFetchRequestFromExpress, sendFetchResponse } from \"./express-utils\";\n\ninterface CopilotExpressEndpointParams {\n  runtime: CopilotRuntime;\n  basePath: string;\n}\n\nexport function createCopilotEndpointExpress({ runtime, basePath }: CopilotExpressEndpointParams): Router {\n  const router = express.Router();\n  const normalizedBase = normalizeBasePath(basePath);\n\n  router.use(cors({\n    origin: \"*\",\n    methods: [\"GET\", \"HEAD\", \"PUT\", \"POST\", \"DELETE\", \"PATCH\", \"OPTIONS\"],\n    allowedHeaders: [\"*\"],\n  }));\n\n  router.post(joinPath(normalizedBase, \"/agent/:agentId/run\"), createRouteHandler(runtime, async ({ request, req }) => {\n    const agentId = req.params.agentId as string;\n    return handleRunAgent({ runtime, request, agentId });\n  }));\n\n  router.post(joinPath(normalizedBase, \"/agent/:agentId/connect\"), createRouteHandler(runtime, async ({ request, req }) => {\n    const agentId = req.params.agentId as string;\n    return handleConnectAgent({ runtime, request, agentId });\n  }));\n\n  router.post(joinPath(normalizedBase, \"/agent/:agentId/stop/:threadId\"), createRouteHandler(runtime, async ({ request, req }) => {\n    const agentId = req.params.agentId as string;\n    const threadId = req.params.threadId as string;\n    return handleStopAgent({ runtime, request, agentId, threadId });\n  }));\n\n  router.get(joinPath(normalizedBase, \"/info\"), createRouteHandler(runtime, async ({ request }) => {\n    return handleGetRuntimeInfo({ runtime, request });\n  }));\n\n  router.post(joinPath(normalizedBase, \"/transcribe\"), createRouteHandler(runtime, async ({ request }) => {\n    return handleTranscribe({ runtime, request });\n  }));\n\n  router.use(joinPath(normalizedBase, \"*\"), (req, res) => {\n    res.status(404).json({ error: \"Not found\" });\n  });\n\n  return router;\n}\n\ntype RouteHandlerContext = {\n  request: Request;\n  req: ExpressRequest;\n};\n\ntype RouteHandlerFactory = (ctx: RouteHandlerContext) => Promise<Response>;\n\nfunction createRouteHandler(runtime: CopilotRuntime, factory: RouteHandlerFactory) {\n  return async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {\n    const path = req.originalUrl ?? req.path;\n    let request = createFetchRequestFromExpress(req);\n    try {\n      const maybeModifiedRequest = await callBeforeRequestMiddleware({ runtime, request, path });\n      if (maybeModifiedRequest) {\n        request = maybeModifiedRequest;\n      }\n    } catch (error) {\n      logger.error({ err: error, url: request.url, path }, \"Error running before request middleware\");\n      if (error instanceof Response) {\n        try {\n          await sendFetchResponse(res, error);\n        } catch (streamError) {\n          next(streamError);\n        }\n        return;\n      }\n      next(error);\n      return;\n    }\n\n    try {\n      const response = await factory({ request, req });\n      await sendFetchResponse(res, response);\n      callAfterRequestMiddleware({ runtime, response, path }).catch((error) => {\n        logger.error({ err: error, url: req.originalUrl ?? req.url, path }, \"Error running after request middleware\");\n      });\n    } catch (error) {\n      if (error instanceof Response) {\n        try {\n          await sendFetchResponse(res, error);\n        } catch (streamError) {\n          next(streamError);\n          return;\n        }\n        callAfterRequestMiddleware({ runtime, response: error, path }).catch((mwError) => {\n          logger.error({ err: mwError, url: req.originalUrl ?? req.url, path }, \"Error running after request middleware\");\n        });\n        return;\n      }\n      logger.error({ err: error, url: request.url, path }, \"Error running request handler\");\n      next(error);\n    }\n  };\n}\n\nfunction normalizeBasePath(path: string): string {\n  if (!path) {\n    throw new Error(\"basePath must be provided for Express endpoint\");\n  }\n\n  if (!path.startsWith(\"/\")) {\n    return `/${path}`;\n  }\n\n  if (path.length > 1 && path.endsWith(\"/\")) {\n    return path.slice(0, -1);\n  }\n\n  return path;\n}\n\nfunction joinPath(basePath: string, suffix: string): string {\n  if (basePath === \"/\") {\n    return suffix.startsWith(\"/\") ? suffix : `/${suffix}`;\n  }\n\n  if (!suffix) {\n    return basePath;\n  }\n\n  if (suffix === \"*\") {\n    return `${basePath}/*`;\n  }\n\n  return `${basePath}${suffix.startsWith(\"/\") ? suffix : `/${suffix}`}`;\n}\n","import {\n  AbstractAgent,\n  HttpAgent,\n  RunAgentInput,\n  RunAgentInputSchema,\n} from \"@ag-ui/client\";\nimport { EventEncoder } from \"@ag-ui/encoder\";\nimport { CopilotRuntime } from \"../runtime\";\nimport { extractForwardableHeaders } from \"./header-utils\";\n\ninterface RunAgentParameters {\n  request: Request;\n  runtime: CopilotRuntime;\n  agentId: string;\n}\n\nexport async function handleRunAgent({\n  runtime,\n  request,\n  agentId,\n}: RunAgentParameters) {\n  try {\n    const agents = await runtime.agents;\n\n    // Check if the requested agent exists\n    if (!agents[agentId]) {\n      return new Response(\n        JSON.stringify({\n          error: \"Agent not found\",\n          message: `Agent '${agentId}' does not exist`,\n        }),\n        {\n          status: 404,\n          headers: { \"Content-Type\": \"application/json\" },\n        }\n      );\n    }\n\n    const registeredAgent = agents[agentId] as AbstractAgent;\n    const agent = registeredAgent.clone() as AbstractAgent;\n\n    if (agent && \"headers\" in agent) {\n      const forwardableHeaders = extractForwardableHeaders(request);\n      agent.headers = {\n        ...agent.headers as Record<string, string>,\n        ...forwardableHeaders\n      };\n    }\n\n    const stream = new TransformStream();\n    const writer = stream.writable.getWriter();\n    const encoder = new EventEncoder();\n    let streamClosed = false;\n\n    // Process the request in the background\n    (async () => {\n      let input: RunAgentInput;\n      try {\n        const requestBody = await request.json();\n        input = RunAgentInputSchema.parse(requestBody);\n      } catch {\n        return new Response(\n          JSON.stringify({\n            error: \"Invalid request body\",\n          }),\n          { status: 400 }\n        );\n      }\n\n      agent.setMessages(input.messages);\n      agent.setState(input.state);\n      agent.threadId = input.threadId;\n\n      runtime.runner\n        .run({\n          threadId: input.threadId,\n          agent,\n          input,\n        })\n        .subscribe({\n          next: async (event) => {\n            if (!request.signal.aborted && !streamClosed) {\n              try {\n                await writer.write(encoder.encode(event));\n              } catch (error) {\n                if (error instanceof Error && error.name === 'AbortError') {\n                  streamClosed = true;\n                }\n              }\n            }\n          },\n          error: async (error) => {\n            console.error(\"Error running agent:\", error);\n            if (!streamClosed) {\n              try {\n                await writer.close();\n                streamClosed = true;\n              } catch {\n                // Stream already closed\n              }\n            }\n          },\n          complete: async () => {\n            if (!streamClosed) {\n              try {\n                await writer.close();\n                streamClosed = true;\n              } catch {\n                // Stream already closed\n              }\n            }\n          },\n        });\n    })().catch((error) => {\n      console.error(\"Error running agent:\", error);\n      console.error(\n        \"Error stack:\",\n        error instanceof Error ? error.stack : \"No stack trace\"\n      );\n      console.error(\"Error details:\", {\n        name: error instanceof Error ? error.name : \"Unknown\",\n        message: error instanceof Error ? error.message : String(error),\n        cause: error instanceof Error ? error.cause : undefined,\n      });\n      if (!streamClosed) {\n        try {\n          writer.close();\n          streamClosed = true;\n        } catch {\n          // Stream already closed\n        }\n      }\n    });\n\n    // Return the SSE response\n    return new Response(stream.readable, {\n      status: 200,\n      headers: {\n        \"Content-Type\": \"text/event-stream\",\n        \"Cache-Control\": \"no-cache\",\n        Connection: \"keep-alive\",\n      },\n    });\n  } catch (error) {\n    console.error(\"Error running agent:\", error);\n    console.error(\n      \"Error stack:\",\n      error instanceof Error ? error.stack : \"No stack trace\"\n    );\n    console.error(\"Error details:\", {\n      name: error instanceof Error ? error.name : \"Unknown\",\n      message: error instanceof Error ? error.message : String(error),\n      cause: error instanceof Error ? error.cause : undefined,\n    });\n\n    return new Response(\n      JSON.stringify({\n        error: \"Failed to run agent\",\n        message: error instanceof Error ? error.message : \"Unknown error\",\n      }),\n      {\n        status: 500,\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n}\n","/**\n * Determines if a header should be forwarded based on the allowlist.\n * Forwards: authorization header and all x-* custom headers.\n */\nexport function shouldForwardHeader(headerName: string): boolean {\n  const lower = headerName.toLowerCase();\n  return lower === \"authorization\" || lower.startsWith(\"x-\");\n}\n\n/**\n * Extracts headers that should be forwarded from a Request object.\n * Forwards only authorization and x-* headers.\n */\nexport function extractForwardableHeaders(request: Request): Record<string, string> {\n  const forwardableHeaders: Record<string, string> = {};\n  request.headers.forEach((value, key) => {\n    if (shouldForwardHeader(key)) {\n      forwardableHeaders[key] = value;\n    }\n  });\n  return forwardableHeaders;\n}\n","import { RunAgentInput, RunAgentInputSchema } from \"@ag-ui/client\";\nimport { EventEncoder } from \"@ag-ui/encoder\";\nimport { CopilotRuntime } from \"../runtime\";\nimport { extractForwardableHeaders } from \"./header-utils\";\n\ninterface ConnectAgentParameters {\n  request: Request;\n  runtime: CopilotRuntime;\n  agentId: string;\n}\n\nexport async function handleConnectAgent({\n  runtime,\n  request,\n  agentId,\n}: ConnectAgentParameters) {\n  try {\n    const agents = await runtime.agents;\n\n    // Check if the requested agent exists\n    if (!agents[agentId]) {\n      return new Response(\n        JSON.stringify({\n          error: \"Agent not found\",\n          message: `Agent '${agentId}' does not exist`,\n        }),\n        {\n          status: 404,\n          headers: { \"Content-Type\": \"application/json\" },\n        }\n      );\n    }\n\n    const stream = new TransformStream();\n    const writer = stream.writable.getWriter();\n    const encoder = new EventEncoder();\n    let streamClosed = false;\n\n    // Process the request in the background\n    (async () => {\n      let input: RunAgentInput;\n      try {\n        const requestBody = await request.json();\n        input = RunAgentInputSchema.parse(requestBody);\n      } catch {\n        return new Response(\n          JSON.stringify({\n            error: \"Invalid request body\",\n          }),\n          { status: 400 }\n        );\n      }\n\n      const forwardableHeaders = extractForwardableHeaders(request);\n\n      runtime.runner\n        .connect({\n          threadId: input.threadId,\n          headers: forwardableHeaders,\n        })\n        .subscribe({\n          next: async (event) => {\n            if (!request.signal.aborted && !streamClosed) {\n              try {\n                await writer.write(encoder.encode(event));\n              } catch (error) {\n                if (error instanceof Error && error.name === \"AbortError\") {\n                  streamClosed = true;\n                }\n              }\n            }\n          },\n          error: async (error) => {\n            console.error(\"Error running agent:\", error);\n            if (!streamClosed) {\n              try {\n                await writer.close();\n                streamClosed = true;\n              } catch {\n                // Stream already closed\n              }\n            }\n          },\n          complete: async () => {\n            if (!streamClosed) {\n              try {\n                await writer.close();\n                streamClosed = true;\n              } catch {\n                // Stream already closed\n              }\n            }\n          },\n        });\n    })().catch((error) => {\n      console.error(\"Error running agent:\", error);\n      console.error(\n        \"Error stack:\",\n        error instanceof Error ? error.stack : \"No stack trace\"\n      );\n      console.error(\"Error details:\", {\n        name: error instanceof Error ? error.name : \"Unknown\",\n        message: error instanceof Error ? error.message : String(error),\n        cause: error instanceof Error ? error.cause : undefined,\n      });\n      if (!streamClosed) {\n        try {\n          writer.close();\n          streamClosed = true;\n        } catch {\n          // Stream already closed\n        }\n      }\n    });\n\n    // Return the SSE response\n    return new Response(stream.readable, {\n      status: 200,\n      headers: {\n        \"Content-Type\": \"text/event-stream\",\n        \"Cache-Control\": \"no-cache\",\n        Connection: \"keep-alive\",\n      },\n    });\n  } catch (error) {\n    console.error(\"Error running agent:\", error);\n    console.error(\n      \"Error stack:\",\n      error instanceof Error ? error.stack : \"No stack trace\"\n    );\n    console.error(\"Error details:\", {\n      name: error instanceof Error ? error.name : \"Unknown\",\n      message: error instanceof Error ? error.message : String(error),\n      cause: error instanceof Error ? error.cause : undefined,\n    });\n\n    return new Response(\n      JSON.stringify({\n        error: \"Failed to run agent\",\n        message: error instanceof Error ? error.message : \"Unknown error\",\n      }),\n      {\n        status: 500,\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n}\n","import { CopilotRuntime } from \"../runtime\";\nimport { EventType } from \"@ag-ui/client\";\n\ninterface StopAgentParameters {\n  request: Request;\n  runtime: CopilotRuntime;\n  agentId: string;\n  threadId: string;\n}\n\nexport async function handleStopAgent({\n  runtime,\n  request,\n  agentId,\n  threadId,\n}: StopAgentParameters) {\n  try {\n    const agents = await runtime.agents;\n\n    if (!agents[agentId]) {\n      return new Response(\n        JSON.stringify({\n          error: \"Agent not found\",\n          message: `Agent '${agentId}' does not exist`,\n        }),\n        {\n          status: 404,\n          headers: { \"Content-Type\": \"application/json\" },\n        }\n      );\n    }\n\n    const stopped = await runtime.runner.stop({ threadId });\n\n    if (!stopped) {\n      return new Response(\n        JSON.stringify({\n          stopped: false,\n          message: `No active run for thread '${threadId}'.`,\n        }),\n        {\n          status: 200,\n          headers: { \"Content-Type\": \"application/json\" },\n        }\n      );\n    }\n\n    return new Response(\n      JSON.stringify({\n        stopped: true,\n        interrupt: {\n          type: EventType.RUN_ERROR,\n          message: \"Run stopped by user\",\n          code: \"STOPPED\",\n        },\n      }),\n      {\n        status: 200,\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n  } catch (error) {\n    console.error(\"Error stopping agent run:\", error);\n\n    return new Response(\n      JSON.stringify({\n        error: \"Failed to stop agent\",\n        message: error instanceof Error ? error.message : \"Unknown error\",\n      }),\n      {\n        status: 500,\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n}\n","{\n  \"name\": \"@copilotkitnext/runtime\",\n  \"version\": \"1.51.3\",\n  \"description\": \"Server-side runtime package for CopilotKit2\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.mjs\",\n      \"require\": \"./dist/index.js\"\n    },\n    \"./express\": {\n      \"types\": \"./dist/express.d.ts\",\n      \"import\": \"./dist/express.mjs\",\n      \"require\": \"./dist/express.js\"\n    }\n  },\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch\",\n    \"lint\": \"eslint .\",\n    \"check-types\": \"tsc --noEmit\",\n    \"clean\": \"rm -rf dist\",\n    \"test\": \"vitest run\",\n    \"test:watch\": \"vitest\",\n    \"test:coverage\": \"vitest run --coverage\"\n  },\n  \"devDependencies\": {\n    \"@copilotkitnext/eslint-config\": \"workspace:*\",\n    \"@copilotkitnext/typescript-config\": \"workspace:*\",\n    \"@types/cors\": \"^2.8.17\",\n    \"@types/express\": \"^4.17.21\",\n    \"@types/node\": \"^22.15.3\",\n    \"eslint\": \"^9.30.0\",\n    \"supertest\": \"^7.1.1\",\n    \"tsup\": \"^8.5.0\",\n    \"typescript\": \"5.8.2\",\n    \"vitest\": \"^3.0.5\"\n  },\n  \"dependencies\": {\n    \"@ag-ui/client\": \"0.0.42\",\n    \"@ag-ui/core\": \"0.0.42\",\n    \"@ag-ui/encoder\": \"0.0.42\",\n    \"@copilotkitnext/shared\": \"workspace:*\",\n    \"cors\": \"^2.8.5\",\n    \"express\": \"^4.21.2\",\n    \"hono\": \"^4.11.4\",\n    \"rxjs\": \"7.8.1\"\n  },\n  \"peerDependencies\": {\n    \"@ag-ui/client\": \"0.0.42\",\n    \"@ag-ui/core\": \"0.0.42\",\n    \"@ag-ui/encoder\": \"0.0.42\",\n    \"@copilotkitnext/shared\": \"workspace:*\"\n  },\n  \"peerDependenciesMeta\": {},\n  \"engines\": {\n    \"node\": \">=18\"\n  }\n}\n","import {\n  AgentRunner,\n  AgentRunnerConnectRequest,\n  AgentRunnerIsRunningRequest,\n  AgentRunnerRunRequest,\n  type AgentRunnerStopRequest,\n} from \"./agent-runner\";\nimport { Observable, ReplaySubject } from \"rxjs\";\nimport {\n  AbstractAgent,\n  BaseEvent,\n  EventType,\n  MessagesSnapshotEvent,\n  RunStartedEvent,\n  compactEvents,\n} from \"@ag-ui/client\";\nimport { finalizeRunEvents } from \"@copilotkitnext/shared\";\n\ninterface HistoricRun {\n  threadId: string;\n  runId: string;\n  parentRunId: string | null;\n  events: BaseEvent[];\n  createdAt: number;\n}\n\nclass InMemoryEventStore {\n  constructor(public threadId: string) {}\n\n  /** The subject that current consumers subscribe to. */\n  subject: ReplaySubject<BaseEvent> | null = null;\n\n  /** True while a run is actively producing events. */\n  isRunning = false;\n\n  /** Current run ID */\n  currentRunId: string | null = null;\n\n  /** Historic completed runs */\n  historicRuns: HistoricRun[] = [];\n\n  /** Currently running agent instance (if any). */\n  agent: AbstractAgent | null = null;\n\n  /** Subject returned from run() while the run is active. */\n  runSubject: ReplaySubject<BaseEvent> | null = null;\n\n  /** True once stop() has been requested but the run has not yet finalized. */\n  stopRequested = false;\n\n  /** Reference to the events emitted in the current run. */\n  currentEvents: BaseEvent[] | null = null;\n}\n\n// Use a symbol key on globalThis to survive hot reloads in development\nconst GLOBAL_STORE_KEY = Symbol.for(\"@copilotkitnext/runtime/in-memory-store\");\n\ninterface GlobalStoreData {\n  stores: Map<string, InMemoryEventStore>;\n  historicRunsBackup: Map<string, HistoricRun[]>;\n}\n\nfunction getGlobalStore(): Map<string, InMemoryEventStore> {\n  const globalAny = globalThis as unknown as Record<symbol, GlobalStoreData>;\n\n  if (!globalAny[GLOBAL_STORE_KEY]) {\n    globalAny[GLOBAL_STORE_KEY] = {\n      stores: new Map<string, InMemoryEventStore>(),\n      historicRunsBackup: new Map<string, HistoricRun[]>(),\n    };\n  }\n\n  const data = globalAny[GLOBAL_STORE_KEY];\n\n  // Restore historic runs from backup after hot reload\n  // (when stores map is empty but backup has data)\n  if (data.stores.size === 0 && data.historicRunsBackup.size > 0) {\n    for (const [threadId, historicRuns] of data.historicRunsBackup) {\n      const store = new InMemoryEventStore(threadId);\n      store.historicRuns = historicRuns;\n      data.stores.set(threadId, store);\n    }\n  }\n\n  return data.stores;\n}\n\nfunction backupHistoricRuns(threadId: string, historicRuns: HistoricRun[]): void {\n  const globalAny = globalThis as unknown as Record<symbol, GlobalStoreData>;\n  if (globalAny[GLOBAL_STORE_KEY]) {\n    globalAny[GLOBAL_STORE_KEY].historicRunsBackup.set(threadId, historicRuns);\n  }\n}\n\nconst GLOBAL_STORE = getGlobalStore();\n\nexport class InMemoryAgentRunner extends AgentRunner {\n  run(request: AgentRunnerRunRequest): Observable<BaseEvent> {\n    let existingStore = GLOBAL_STORE.get(request.threadId);\n    if (!existingStore) {\n      existingStore = new InMemoryEventStore(request.threadId);\n      GLOBAL_STORE.set(request.threadId, existingStore);\n    }\n    const store = existingStore; // Now store is const and non-null\n\n    if (store.isRunning) {\n      throw new Error(\"Thread already running\");\n    }\n    store.isRunning = true;\n    store.currentRunId = request.input.runId;\n    store.agent = request.agent;\n    store.stopRequested = false;\n\n    // Track seen message IDs and current run events for this run\n    const seenMessageIds = new Set<string>();\n    const currentRunEvents: BaseEvent[] = [];\n    store.currentEvents = currentRunEvents;\n\n    // Get all previously seen message IDs from historic runs\n    const historicMessageIds = new Set<string>();\n    for (const run of store.historicRuns) {\n      for (const event of run.events) {\n        if (\"messageId\" in event && typeof event.messageId === \"string\") {\n          historicMessageIds.add(event.messageId);\n        }\n        if (event.type === EventType.RUN_STARTED) {\n          const runStarted = event as RunStartedEvent;\n          const messages = runStarted.input?.messages ?? [];\n          for (const message of messages) {\n            historicMessageIds.add(message.id);\n          }\n        }\n      }\n    }\n\n    const nextSubject = new ReplaySubject<BaseEvent>(Infinity);\n    const prevSubject = store.subject;\n\n    // Update the store's subject immediately\n    store.subject = nextSubject;\n\n    // Create a subject for run() return value\n    const runSubject = new ReplaySubject<BaseEvent>(Infinity);\n    store.runSubject = runSubject;\n\n    // Helper function to run the agent and handle errors\n    const runAgent = async () => {\n      // Get parent run ID for chaining\n      const lastRun = store.historicRuns[store.historicRuns.length - 1];\n      const parentRunId = lastRun?.runId ?? null;\n\n      try {\n        await request.agent.runAgent(request.input, {\n          onEvent: ({ event }) => {\n            let processedEvent: BaseEvent = event;\n            if (event.type === EventType.RUN_STARTED) {\n              const runStartedEvent = event as RunStartedEvent;\n              if (!runStartedEvent.input) {\n                const sanitizedMessages = request.input.messages\n                  ? request.input.messages.filter(\n                      (message) => !historicMessageIds.has(message.id),\n                    )\n                  : undefined;\n                const updatedInput = {\n                  ...request.input,\n                  ...(sanitizedMessages !== undefined\n                    ? { messages: sanitizedMessages }\n                    : {}),\n                };\n                processedEvent = {\n                  ...runStartedEvent,\n                  input: updatedInput,\n                } as RunStartedEvent;\n              }\n            }\n\n            runSubject.next(processedEvent); // For run() return - only agent events\n            nextSubject.next(processedEvent); // For connect() / store - all events\n            currentRunEvents.push(processedEvent); // Accumulate for storage\n          },\n          onNewMessage: ({ message }) => {\n            // Called for each new message\n            if (!seenMessageIds.has(message.id)) {\n              seenMessageIds.add(message.id);\n            }\n          },\n          onRunStartedEvent: () => {\n            // Mark any messages from the input as seen so they aren't emitted twice\n            if (request.input.messages) {\n              for (const message of request.input.messages) {\n                if (!seenMessageIds.has(message.id)) {\n                  seenMessageIds.add(message.id);\n                }\n              }\n            }\n          },\n        });\n\n        const appendedEvents = finalizeRunEvents(currentRunEvents, {\n          stopRequested: store.stopRequested,\n        });\n        for (const event of appendedEvents) {\n          runSubject.next(event);\n          nextSubject.next(event);\n        }\n\n        // Store the completed run in memory with ONLY its events\n        if (store.currentRunId) {\n          // Compact the events before storing (like SQLite does)\n          const compactedEvents = compactEvents(currentRunEvents);\n\n          store.historicRuns.push({\n            threadId: request.threadId,\n            runId: store.currentRunId,\n            parentRunId,\n            events: compactedEvents,\n            createdAt: Date.now(),\n          });\n\n          // Backup for hot reload survival\n          backupHistoricRuns(request.threadId, store.historicRuns);\n        }\n\n        // Complete the run\n        store.currentEvents = null;\n        store.currentRunId = null;\n        store.agent = null;\n        store.runSubject = null;\n        store.stopRequested = false;\n        store.isRunning = false;\n        runSubject.complete();\n        nextSubject.complete();\n      } catch {\n        const appendedEvents = finalizeRunEvents(currentRunEvents, {\n          stopRequested: store.stopRequested,\n        });\n        for (const event of appendedEvents) {\n          runSubject.next(event);\n          nextSubject.next(event);\n        }\n\n        // Store the run even if it failed (partial events)\n        if (store.currentRunId && currentRunEvents.length > 0) {\n          // Compact the events before storing (like SQLite does)\n          const compactedEvents = compactEvents(currentRunEvents);\n          store.historicRuns.push({\n            threadId: request.threadId,\n            runId: store.currentRunId,\n            parentRunId,\n            events: compactedEvents,\n            createdAt: Date.now(),\n          });\n\n          // Backup for hot reload survival\n          backupHistoricRuns(request.threadId, store.historicRuns);\n        }\n\n        // Complete the run\n        store.currentEvents = null;\n        store.currentRunId = null;\n        store.agent = null;\n        store.runSubject = null;\n        store.stopRequested = false;\n        store.isRunning = false;\n        runSubject.complete();\n        nextSubject.complete();\n      }\n    };\n\n    // Bridge previous events if they exist\n    if (prevSubject) {\n      prevSubject.subscribe({\n        next: (e) => nextSubject.next(e),\n        error: (err) => nextSubject.error(err),\n        complete: () => {\n          // Don't complete nextSubject here - it needs to stay open for new events\n        },\n      });\n    }\n\n    // Start the agent execution immediately (not lazily)\n    runAgent();\n\n    // Return the run subject (only agent events, no injected messages)\n    return runSubject.asObservable();\n  }\n\n  connect(request: AgentRunnerConnectRequest): Observable<BaseEvent> {\n    const store = GLOBAL_STORE.get(request.threadId);\n    const connectionSubject = new ReplaySubject<BaseEvent>(Infinity);\n\n    if (!store) {\n      // No store means no events\n      connectionSubject.complete();\n      return connectionSubject.asObservable();\n    }\n\n    // Collect all historic events from memory\n    const allHistoricEvents: BaseEvent[] = [];\n    for (const run of store.historicRuns) {\n      allHistoricEvents.push(...run.events);\n    }\n\n    // Apply compaction to all historic events together (like SQLite)\n    const compactedEvents = compactEvents(allHistoricEvents);\n\n    // Emit compacted events and track message IDs\n    const emittedMessageIds = new Set<string>();\n    for (const event of compactedEvents) {\n      connectionSubject.next(event);\n      if (\"messageId\" in event && typeof event.messageId === \"string\") {\n        emittedMessageIds.add(event.messageId);\n      }\n    }\n\n    // Bridge active run to connection if exists\n    if (store.subject && (store.isRunning || store.stopRequested)) {\n      store.subject.subscribe({\n        next: (event) => {\n          // Skip message events that we've already emitted from historic\n          if (\n            \"messageId\" in event &&\n            typeof event.messageId === \"string\" &&\n            emittedMessageIds.has(event.messageId)\n          ) {\n            return;\n          }\n          connectionSubject.next(event);\n        },\n        complete: () => connectionSubject.complete(),\n        error: (err) => connectionSubject.error(err),\n      });\n    } else {\n      // No active run, complete after historic events\n      connectionSubject.complete();\n    }\n\n    return connectionSubject.asObservable();\n  }\n\n  isRunning(request: AgentRunnerIsRunningRequest): Promise<boolean> {\n    const store = GLOBAL_STORE.get(request.threadId);\n    return Promise.resolve(store?.isRunning ?? false);\n  }\n\n  stop(request: AgentRunnerStopRequest): Promise<boolean | undefined> {\n    const store = GLOBAL_STORE.get(request.threadId);\n    if (!store || !store.isRunning) {\n      return Promise.resolve(false);\n    }\n    if (store.stopRequested) {\n      return Promise.resolve(false);\n    }\n\n    store.stopRequested = true;\n    store.isRunning = false;\n\n    const agent = store.agent;\n    if (!agent) {\n      store.stopRequested = false;\n      store.isRunning = false;\n      return Promise.resolve(false);\n    }\n\n    try {\n      agent.abortRun();\n      return Promise.resolve(true);\n    } catch (error) {\n      console.error(\"Failed to abort agent run\", error);\n      store.stopRequested = false;\n      store.isRunning = true;\n      return Promise.resolve(false);\n    }\n  }\n}\n","import { MaybePromise, NonEmptyRecord } from \"@copilotkitnext/shared\";\nimport { AbstractAgent } from \"@ag-ui/client\";\nimport pkg from \"../package.json\";\nimport type {\n  BeforeRequestMiddleware,\n  AfterRequestMiddleware,\n} from \"./middleware\";\nimport { TranscriptionService } from \"./transcription-service/transcription-service\";\nimport { AgentRunner } from \"./runner/agent-runner\";\nimport { InMemoryAgentRunner } from \"./runner/in-memory\";\n\nexport const VERSION = pkg.version;\n\n/**\n * Options used to construct a `CopilotRuntime` instance.\n */\nexport interface CopilotRuntimeOptions {\n  /** Map of available agents (loaded lazily is fine). */\n  agents: MaybePromise<NonEmptyRecord<Record<string, AbstractAgent>>>;\n  /** The runner to use for running agents. */\n  runner?: AgentRunner;\n  /** Optional transcription service for audio processing. */\n  transcriptionService?: TranscriptionService;\n  /** Optional *before* middleware – callback function or webhook URL. */\n  beforeRequestMiddleware?: BeforeRequestMiddleware;\n  /** Optional *after* middleware – callback function or webhook URL. */\n  afterRequestMiddleware?: AfterRequestMiddleware;\n}\n\n/**\n * Central runtime object passed to all request handlers.\n */\nexport class CopilotRuntime {\n  public agents: CopilotRuntimeOptions[\"agents\"];\n  public transcriptionService: CopilotRuntimeOptions[\"transcriptionService\"];\n  public beforeRequestMiddleware: CopilotRuntimeOptions[\"beforeRequestMiddleware\"];\n  public afterRequestMiddleware: CopilotRuntimeOptions[\"afterRequestMiddleware\"];\n  public runner: AgentRunner;\n\n  constructor({\n    agents,\n    transcriptionService,\n    beforeRequestMiddleware,\n    afterRequestMiddleware,\n    runner,\n  }: CopilotRuntimeOptions) {\n    this.agents = agents;\n    this.transcriptionService = transcriptionService;\n    this.beforeRequestMiddleware = beforeRequestMiddleware;\n    this.afterRequestMiddleware = afterRequestMiddleware;\n    this.runner = runner ?? new InMemoryAgentRunner();\n  }\n}\n","import { CopilotRuntime } from \"../runtime\";\nimport { AgentDescription, RuntimeInfo } from \"@copilotkitnext/shared\";\nimport { VERSION } from \"../runtime\";\n\ninterface HandleGetRuntimeInfoParameters {\n  runtime: CopilotRuntime;\n  request: Request;\n}\n\nexport async function handleGetRuntimeInfo({\n  runtime,\n}: HandleGetRuntimeInfoParameters) {\n  try {\n    const agents = await runtime.agents;\n\n    const agentsDict = Object.entries(agents).reduce(\n      (acc, [name, agent]) => {\n        acc[name] = {\n          name,\n          description: agent.description,\n          className: agent.constructor.name,\n        };\n        return acc;\n      },\n      {} as Record<string, AgentDescription>\n    );\n\n    const runtimeInfo: RuntimeInfo = {\n      version: VERSION,\n      agents: agentsDict,\n      audioFileTranscriptionEnabled: !!runtime.transcriptionService,\n    };\n\n    return new Response(JSON.stringify(runtimeInfo), {\n      status: 200,\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n  } catch (error) {\n    return new Response(\n      JSON.stringify({\n        error: \"Failed to retrieve runtime information\",\n        message: error instanceof Error ? error.message : \"Unknown error\",\n      }),\n      {\n        status: 500,\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n}\n","import { CopilotRuntime } from \"../runtime\";\nimport {\n  TranscriptionErrorCode,\n  TranscriptionErrors,\n  type TranscriptionErrorResponse,\n} from \"@copilotkitnext/shared\";\n\n/**\n * HTTP status codes for transcription error codes\n */\nconst ERROR_STATUS_CODES: Record<TranscriptionErrorCode, number> = {\n  [TranscriptionErrorCode.SERVICE_NOT_CONFIGURED]: 503,\n  [TranscriptionErrorCode.INVALID_AUDIO_FORMAT]: 400,\n  [TranscriptionErrorCode.AUDIO_TOO_LONG]: 400,\n  [TranscriptionErrorCode.AUDIO_TOO_SHORT]: 400,\n  [TranscriptionErrorCode.RATE_LIMITED]: 429,\n  [TranscriptionErrorCode.AUTH_FAILED]: 401,\n  [TranscriptionErrorCode.PROVIDER_ERROR]: 500,\n  [TranscriptionErrorCode.NETWORK_ERROR]: 502,\n  [TranscriptionErrorCode.INVALID_REQUEST]: 400,\n};\n\ninterface HandleTranscribeParameters {\n  runtime: CopilotRuntime;\n  request: Request;\n}\n\ninterface Base64AudioInput {\n  audio: string; // base64-encoded audio data\n  mimeType: string;\n  filename?: string;\n}\n\nconst VALID_AUDIO_TYPES = [\n  \"audio/mpeg\",\n  \"audio/mp3\",\n  \"audio/mp4\",\n  \"audio/wav\",\n  \"audio/webm\",\n  \"audio/ogg\",\n  \"audio/flac\",\n  \"audio/aac\",\n];\n\nfunction isValidAudioType(type: string): boolean {\n  // Extract base MIME type (before semicolon) to handle types like \"audio/webm; codecs=opus\"\n  const baseType = type.split(\";\")[0]?.trim() ?? \"\";\n  return (\n    VALID_AUDIO_TYPES.includes(baseType) ||\n    baseType === \"\" ||\n    baseType === \"application/octet-stream\"\n  );\n}\n\nfunction createErrorResponse(errorResponse: TranscriptionErrorResponse): Response {\n  const status = ERROR_STATUS_CODES[errorResponse.error] ?? 500;\n  return new Response(JSON.stringify(errorResponse), {\n    status,\n    headers: { \"Content-Type\": \"application/json\" },\n  });\n}\n\nfunction base64ToFile(base64: string, mimeType: string, filename: string): File {\n  // Remove data URL prefix if present (e.g., \"data:audio/webm;base64,\")\n  const base64Data = base64.includes(\",\") ? base64.split(\",\")[1] ?? base64 : base64;\n\n  // Decode base64 to binary\n  const binaryString = atob(base64Data);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n\n  // Create File object\n  return new File([bytes], filename, { type: mimeType });\n}\n\nasync function extractAudioFromFormData(\n  request: Request\n): Promise<{ file: File } | { error: Response }> {\n  const formData = await request.formData();\n  const audioFile = formData.get(\"audio\") as File | null;\n\n  if (!audioFile || !(audioFile instanceof File)) {\n    const err = TranscriptionErrors.invalidRequest(\n      \"No audio file found in form data. Please include an 'audio' field.\"\n    );\n    return { error: createErrorResponse(err) };\n  }\n\n  if (!isValidAudioType(audioFile.type)) {\n    const err = TranscriptionErrors.invalidAudioFormat(audioFile.type, VALID_AUDIO_TYPES);\n    return { error: createErrorResponse(err) };\n  }\n\n  return { file: audioFile };\n}\n\nasync function extractAudioFromJson(\n  request: Request\n): Promise<{ file: File } | { error: Response }> {\n  let body: Base64AudioInput;\n\n  try {\n    body = await request.json();\n  } catch {\n    const err = TranscriptionErrors.invalidRequest(\"Request body must be valid JSON\");\n    return { error: createErrorResponse(err) };\n  }\n\n  if (!body.audio || typeof body.audio !== \"string\") {\n    const err = TranscriptionErrors.invalidRequest(\n      \"Request must include 'audio' field with base64-encoded audio data\"\n    );\n    return { error: createErrorResponse(err) };\n  }\n\n  if (!body.mimeType || typeof body.mimeType !== \"string\") {\n    const err = TranscriptionErrors.invalidRequest(\n      \"Request must include 'mimeType' field (e.g., 'audio/webm')\"\n    );\n    return { error: createErrorResponse(err) };\n  }\n\n  if (!isValidAudioType(body.mimeType)) {\n    const err = TranscriptionErrors.invalidAudioFormat(body.mimeType, VALID_AUDIO_TYPES);\n    return { error: createErrorResponse(err) };\n  }\n\n  try {\n    const filename = body.filename || \"recording.webm\";\n    const file = base64ToFile(body.audio, body.mimeType, filename);\n    return { file };\n  } catch {\n    const err = TranscriptionErrors.invalidRequest(\"Failed to decode base64 audio data\");\n    return { error: createErrorResponse(err) };\n  }\n}\n\n/**\n * Categorize provider errors into appropriate transcription error responses.\n */\nfunction categorizeProviderError(error: unknown): TranscriptionErrorResponse {\n  const message = error instanceof Error ? error.message : \"Unknown error occurred\";\n  const errorStr = String(error).toLowerCase();\n\n  // Check for rate limiting\n  if (errorStr.includes(\"rate\") || errorStr.includes(\"429\") || errorStr.includes(\"too many\")) {\n    return TranscriptionErrors.rateLimited();\n  }\n\n  // Check for auth errors\n  if (\n    errorStr.includes(\"auth\") ||\n    errorStr.includes(\"401\") ||\n    errorStr.includes(\"api key\") ||\n    errorStr.includes(\"unauthorized\")\n  ) {\n    return TranscriptionErrors.authFailed();\n  }\n\n  // Check for audio too long\n  if (errorStr.includes(\"too long\") || errorStr.includes(\"duration\") || errorStr.includes(\"length\")) {\n    return TranscriptionErrors.audioTooLong();\n  }\n\n  // Default to provider error\n  return TranscriptionErrors.providerError(message);\n}\n\nexport async function handleTranscribe({\n  runtime,\n  request,\n}: HandleTranscribeParameters) {\n  try {\n    // Check if transcription service is configured\n    if (!runtime.transcriptionService) {\n      const err = TranscriptionErrors.serviceNotConfigured();\n      return createErrorResponse(err);\n    }\n\n    // Determine input type based on content-type header\n    const contentType = request.headers.get(\"content-type\") || \"\";\n\n    let extractResult: { file: File } | { error: Response };\n\n    if (contentType.includes(\"multipart/form-data\")) {\n      // Handle multipart/form-data (REST mode)\n      extractResult = await extractAudioFromFormData(request);\n    } else if (contentType.includes(\"application/json\")) {\n      // Handle JSON with base64 audio (single-endpoint mode)\n      extractResult = await extractAudioFromJson(request);\n    } else {\n      const err = TranscriptionErrors.invalidRequest(\n        \"Request must be multipart/form-data or application/json with base64 audio\"\n      );\n      return createErrorResponse(err);\n    }\n\n    // Check for extraction errors\n    if (\"error\" in extractResult) {\n      return extractResult.error;\n    }\n\n    const audioFile = extractResult.file;\n\n    // Transcribe the audio file\n    const transcription = await runtime.transcriptionService.transcribeFile({\n      audioFile,\n      mimeType: audioFile.type,\n      size: audioFile.size,\n    });\n\n    return new Response(\n      JSON.stringify({\n        text: transcription,\n        size: audioFile.size,\n        type: audioFile.type,\n      }),\n      {\n        status: 200,\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n  } catch (error) {\n    // Categorize the error for better client-side handling\n    return createErrorResponse(categorizeProviderError(error));\n  }\n}\n","/**\n * Middleware support for CopilotKit Runtime.\n *\n * A middleware hook can be provided as either:\n *   1. A **callback function** executed in-process.\n *   2. A **webhook URL** (http/https).  The runtime will `POST` a JSON payload\n *      to the URL and, for *before* hooks, accept an optional modified\n *      `Request` object in the response body.\n *\n * Two lifecycle hooks are available:\n *   • `BEFORE_REQUEST` – runs *before* the request handler.\n *   • `AFTER_REQUEST`  – runs *after* the handler returns a `Response`.\n */\n\nimport type { CopilotRuntime } from \"./runtime\";\nimport type { MaybePromise } from \"@copilotkitnext/shared\";\nimport { logger } from \"@copilotkitnext/shared\";\n\n/* ------------------------------------------------------------------------------------------------\n * Public types\n * --------------------------------------------------------------------------------------------- */\n\nexport interface BeforeRequestMiddlewareParameters {\n  runtime: CopilotRuntime;\n  request: Request;\n  path: string;\n}\nexport interface AfterRequestMiddlewareParameters {\n  runtime: CopilotRuntime;\n  response: Response;\n  path: string;\n}\n\nexport type BeforeRequestMiddlewareFn = (\n  params: BeforeRequestMiddlewareParameters\n) => MaybePromise<Request | void>;\nexport type AfterRequestMiddlewareFn = (\n  params: AfterRequestMiddlewareParameters\n) => MaybePromise<void>;\n\n/**\n * A middleware value can be either a callback function or a webhook URL.\n */\nexport type BeforeRequestMiddleware = BeforeRequestMiddlewareFn;\nexport type AfterRequestMiddleware = AfterRequestMiddlewareFn;\n\n/** Lifecycle events emitted to webhook middleware. */\nexport enum CopilotKitMiddlewareEvent {\n  BeforeRequest = \"BEFORE_REQUEST\",\n  AfterRequest = \"AFTER_REQUEST\",\n}\n\n/** Stages used by the Middleware Webhook Protocol */\n/** Stages used by the CopilotKit webhook protocol */\nexport enum WebhookStage {\n  BeforeRequest = \"before_request\",\n  AfterRequest = \"after_request\",\n}\n\n/* ------------------------------------------------------------------------------------------------\n * Internal helpers – (de)serialisation\n * --------------------------------------------------------------------------------------------- */\n\nexport async function callBeforeRequestMiddleware({\n  runtime,\n  request,\n  path,\n}: BeforeRequestMiddlewareParameters): Promise<Request | void> {\n  const mw = runtime.beforeRequestMiddleware;\n  if (!mw) return;\n\n  // Function-based middleware (in-process)\n  if (typeof mw === \"function\") {\n    return (mw as BeforeRequestMiddlewareFn)({ runtime, request, path });\n  }\n\n  logger.warn({ mw }, \"Unsupported beforeRequestMiddleware value – skipped\");\n  return;\n}\n\nexport async function callAfterRequestMiddleware({\n  runtime,\n  response,\n  path,\n}: AfterRequestMiddlewareParameters): Promise<void> {\n  const mw = runtime.afterRequestMiddleware;\n  if (!mw) return;\n\n  if (typeof mw === \"function\") {\n    return (mw as AfterRequestMiddlewareFn)({ runtime, response, path });\n  }\n\n  logger.warn({ mw }, \"Unsupported afterRequestMiddleware value – skipped\");\n}\n","import type { Request as ExpressRequest, Response as ExpressResponse } from \"express\";\nimport { Readable } from \"node:stream\";\nimport { pipeline } from \"node:stream\";\nimport { promisify } from \"node:util\";\nimport { logger } from \"@copilotkitnext/shared\";\n\nconst streamPipeline = promisify(pipeline);\n\nconst METHODS_WITHOUT_BODY = new Set([\"GET\", \"HEAD\"]);\n\nexport function createFetchRequestFromExpress(req: ExpressRequest): Request {\n  const method = req.method?.toUpperCase() ?? \"GET\";\n  const origin = buildOrigin(req);\n  const url = `${origin}${req.originalUrl ?? req.url ?? \"\"}`;\n\n  const headers = new Headers();\n  for (const [key, value] of Object.entries(req.headers)) {\n    if (value === undefined) continue;\n    if (Array.isArray(value)) {\n      value.forEach((v) => headers.append(key, v));\n    } else {\n      headers.set(key, value);\n    }\n  }\n\n  const init: RequestInit & { duplex?: \"half\" } = {\n    method,\n    headers,\n  };\n\n  const hasParsedBody = req.body !== undefined && req.body !== null;\n  const streamConsumed = isStreamConsumed(req, hasParsedBody);\n\n  if (!METHODS_WITHOUT_BODY.has(method)) {\n    const canStreamBody = req.readable !== false && !streamConsumed;\n\n    if (canStreamBody) {\n      init.body = Readable.toWeb(req) as unknown as BodyInit;\n      init.duplex = \"half\";\n    } else if (hasParsedBody) {\n      const { body, contentType } = synthesizeBody(req.body);\n      if (contentType) {\n        headers.set(\"content-type\", contentType);\n      }\n      headers.delete(\"content-length\");\n      if (body !== undefined) {\n        init.body = body;\n      }\n      logger.info(\n        {\n          url,\n          method,\n          readable: req.readable,\n          readableEnded: req.readableEnded,\n          complete: req.complete,\n        },\n        \"Express request stream already consumed; synthesized body from parsed content\",\n      );\n    } else {\n      headers.delete(\"content-length\");\n      logger.warn(\n        { url, method },\n        \"Request stream already consumed but no body was available; sending empty body\",\n      );\n    }\n  }\n\n  const controller = new AbortController();\n  const abort = () => controller.abort();\n  req.on(\"aborted\", abort);\n  req.on(\"error\", abort);\n  req.on(\"close\", () => {\n    if (req.aborted) {\n      abort();\n    }\n  });\n  init.signal = controller.signal;\n\n  try {\n    return new Request(url, init);\n  } catch (error) {\n    if (error instanceof TypeError && /disturbed|locked/i.test(error.message)) {\n      // Fallback to synthesized/empty body when the stream was already consumed.\n      headers.delete(\"content-length\");\n      delete init.duplex;\n\n      if (hasParsedBody) {\n        const { body, contentType } = synthesizeBody(req.body);\n        if (contentType) {\n          headers.set(\"content-type\", contentType);\n        }\n        init.body = body;\n        logger.info(\n          { url, method },\n          \"Request stream disturbed while constructing Request; reused parsed body\",\n        );\n      } else {\n        init.body = undefined;\n        logger.warn(\n          { url, method },\n          \"Request stream was disturbed; falling back to empty body\",\n        );\n      }\n\n      return new Request(url, init);\n    }\n    throw error;\n  }\n}\n\nexport async function sendFetchResponse(res: ExpressResponse, response: Response): Promise<void> {\n  res.status(response.status);\n\n  response.headers.forEach((value, key) => {\n    if (key.toLowerCase() === \"content-length\" && response.body !== null) {\n      return;\n    }\n    res.setHeader(key, value);\n  });\n\n  if (!response.body) {\n    res.end();\n    return;\n  }\n\n  const nodeStream = Readable.fromWeb(response.body as any);\n  try {\n    await streamPipeline(nodeStream, res);\n  } catch (error) {\n    res.destroy(error as Error);\n    throw error;\n  }\n}\n\nfunction buildOrigin(req: ExpressRequest): string {\n  const protocol = req.protocol || (req.secure ? \"https\" : \"http\");\n  const host = req.get(\"host\") ?? \"localhost\";\n  return `${protocol}://${host}`;\n}\n\nfunction isStreamConsumed(req: ExpressRequest, hasParsedBody: boolean): boolean {\n  const state = (req as unknown as { _readableState?: { ended?: boolean; endEmitted?: boolean } })\n    ._readableState;\n  return Boolean(\n    hasParsedBody ||\n      req.readableEnded ||\n      req.complete ||\n      state?.ended ||\n      state?.endEmitted,\n  );\n}\n\nfunction synthesizeBody(body: unknown): { body?: BodyInit; contentType?: string } {\n  if (Buffer.isBuffer(body) || body instanceof Uint8Array) {\n    return { body };\n  }\n\n  if (typeof body === \"string\") {\n    return { body };\n  }\n\n  if (typeof body === \"object\" && body !== undefined) {\n    return { body: JSON.stringify(body), contentType: \"application/json\" };\n  }\n\n  return {};\n}\n","import express from \"express\";\nimport type { Request as ExpressRequest, Response as ExpressResponse, NextFunction, Router } from \"express\";\nimport cors from \"cors\";\n\nimport { CopilotRuntime } from \"../runtime\";\nimport { handleRunAgent } from \"../handlers/handle-run\";\nimport { handleConnectAgent } from \"../handlers/handle-connect\";\nimport { handleStopAgent } from \"../handlers/handle-stop\";\nimport { handleGetRuntimeInfo } from \"../handlers/get-runtime-info\";\nimport { handleTranscribe } from \"../handlers/handle-transcribe\";\nimport { logger } from \"@copilotkitnext/shared\";\nimport { callBeforeRequestMiddleware, callAfterRequestMiddleware } from \"../middleware\";\nimport { createFetchRequestFromExpress, sendFetchResponse } from \"./express-utils\";\nimport { createJsonRequest, expectString, MethodCall, parseMethodCall } from \"./single-route-helpers\";\n\ninterface CopilotSingleRouteExpressParams {\n  runtime: CopilotRuntime;\n  basePath: string;\n}\n\nexport function createCopilotEndpointSingleRouteExpress({\n  runtime,\n  basePath,\n}: CopilotSingleRouteExpressParams): Router {\n  const router = express.Router();\n  const routePath = normalizeSingleRoutePath(basePath);\n\n  router.use(cors({\n    origin: \"*\",\n    methods: [\"GET\", \"HEAD\", \"PUT\", \"POST\", \"DELETE\", \"PATCH\", \"OPTIONS\"],\n    allowedHeaders: [\"*\"],\n  }));\n\n  router.post(routePath, createSingleRouteHandler(runtime));\n\n  router.use((req, res) => {\n    res.status(404).json({ error: \"Not found\" });\n  });\n\n  return router;\n}\n\nfunction createSingleRouteHandler(runtime: CopilotRuntime) {\n  return async (req: ExpressRequest, res: ExpressResponse, next: NextFunction) => {\n    const path = req.originalUrl ?? req.path;\n    let request = createFetchRequestFromExpress(req);\n\n    try {\n      const maybeModifiedRequest = await callBeforeRequestMiddleware({ runtime, request, path });\n      if (maybeModifiedRequest) {\n        request = maybeModifiedRequest;\n      }\n    } catch (error) {\n      logger.error({ err: error, url: request.url, path }, \"Error running before request middleware\");\n      if (error instanceof Response) {\n        try {\n          await sendFetchResponse(res, error);\n        } catch (streamError) {\n          next(streamError);\n        }\n        return;\n      }\n      next(error);\n      return;\n    }\n\n    let methodCall: MethodCall;\n    try {\n      methodCall = await parseMethodCall(request);\n    } catch (error) {\n      if (error instanceof Response) {\n        logger.warn({ url: request.url }, \"Invalid single-route payload\");\n        try {\n          await sendFetchResponse(res, error);\n        } catch (streamError) {\n          next(streamError);\n        }\n        return;\n      }\n      logger.warn({ err: error, url: request.url }, \"Invalid single-route payload\");\n      res.status(400).json({\n        error: \"invalid_request\",\n        message: error instanceof Error ? error.message : \"Invalid request payload\",\n      });\n      return;\n    }\n\n    try {\n      let response: Response;\n      switch (methodCall.method) {\n        case \"agent/run\": {\n          const agentId = expectString(methodCall.params, \"agentId\");\n          const handlerRequest = createJsonRequest(request, methodCall.body);\n          response = await handleRunAgent({ runtime, request: handlerRequest, agentId });\n          break;\n        }\n        case \"agent/connect\": {\n          const agentId = expectString(methodCall.params, \"agentId\");\n          const handlerRequest = createJsonRequest(request, methodCall.body);\n          response = await handleConnectAgent({ runtime, request: handlerRequest, agentId });\n          break;\n        }\n        case \"agent/stop\": {\n          const agentId = expectString(methodCall.params, \"agentId\");\n          const threadId = expectString(methodCall.params, \"threadId\");\n          response = await handleStopAgent({ runtime, request, agentId, threadId });\n          break;\n        }\n        case \"info\": {\n          response = await handleGetRuntimeInfo({ runtime, request });\n          break;\n        }\n        case \"transcribe\": {\n          const handlerRequest = createJsonRequest(request, methodCall.body);\n          response = await handleTranscribe({ runtime, request: handlerRequest });\n          break;\n        }\n        default: {\n          const exhaustive: never = methodCall.method;\n          return exhaustive;\n        }\n      }\n\n      await sendFetchResponse(res, response);\n      callAfterRequestMiddleware({ runtime, response, path }).catch((error) => {\n        logger.error({ err: error, url: req.originalUrl ?? req.url, path }, \"Error running after request middleware\");\n      });\n    } catch (error) {\n      if (error instanceof Response) {\n        try {\n          await sendFetchResponse(res, error);\n        } catch (streamError) {\n          next(streamError);\n          return;\n        }\n        callAfterRequestMiddleware({ runtime, response: error, path }).catch((mwError) => {\n          logger.error({ err: mwError, url: req.originalUrl ?? req.url, path }, \"Error running after request middleware\");\n        });\n        return;\n      }\n      logger.error({ err: error, url: request.url, path }, \"Error running single-route handler\");\n      next(error);\n    }\n  };\n}\n\nfunction normalizeSingleRoutePath(path: string): string {\n  if (!path) {\n    throw new Error(\"basePath must be provided for Express single-route endpoint\");\n  }\n\n  if (!path.startsWith(\"/\")) {\n    return `/${path}`;\n  }\n\n  if (path.length > 1 && path.endsWith(\"/\")) {\n    return path.slice(0, -1);\n  }\n\n  return path;\n}\n","const METHOD_NAMES = [\n  \"agent/run\",\n  \"agent/connect\",\n  \"agent/stop\",\n  \"info\",\n  \"transcribe\",\n] as const;\n\nexport type EndpointMethod = (typeof METHOD_NAMES)[number];\n\ninterface JsonEnvelope {\n  method?: string;\n  params?: Record<string, unknown>;\n  body?: unknown;\n}\n\nexport interface MethodCall {\n  method: EndpointMethod;\n  params?: Record<string, unknown>;\n  body?: unknown;\n}\n\nexport async function parseMethodCall(request: Request): Promise<MethodCall> {\n  const contentType = request.headers.get(\"content-type\") || \"\";\n\n  if (!contentType.includes(\"application/json\")) {\n    throw createResponseError(\"Single-route endpoint expects JSON payloads\", 415);\n  }\n\n  let jsonEnvelope: JsonEnvelope;\n  try {\n    jsonEnvelope = (await request.clone().json()) as JsonEnvelope;\n  } catch (error) {\n    throw createResponseError(\"Invalid JSON payload\", 400);\n  }\n\n  const method = validateMethod(jsonEnvelope.method);\n\n  return {\n    method,\n    params: jsonEnvelope.params,\n    body: jsonEnvelope.body,\n  };\n}\n\nexport function expectString(params: Record<string, unknown> | undefined, key: string): string {\n  const value = params?.[key];\n  if (typeof value === \"string\" && value.trim().length > 0) {\n    return value;\n  }\n\n  throw createResponseError(`Missing or invalid parameter '${key}'`, 400);\n}\n\nexport function createJsonRequest(base: Request, body: unknown): Request {\n  if (body === undefined || body === null) {\n    throw createResponseError(\"Missing request body for JSON handler\", 400);\n  }\n\n  const headers = new Headers(base.headers);\n  headers.set(\"content-type\", \"application/json\");\n  headers.delete(\"content-length\");\n\n  const serializedBody = serializeJsonBody(body);\n\n  return new Request(base.url, {\n    method: \"POST\",\n    headers,\n    body: serializedBody,\n    signal: base.signal,\n  });\n}\n\nexport function createResponseError(message: string, status: number): Response {\n  return new Response(\n    JSON.stringify({\n      error: \"invalid_request\",\n      message,\n    }),\n    {\n      status,\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    },\n  );\n}\n\nfunction validateMethod(method: string | undefined): EndpointMethod {\n  if (!method) {\n    throw createResponseError(\"Missing method field\", 400);\n  }\n\n  if ((METHOD_NAMES as readonly string[]).includes(method)) {\n    return method as EndpointMethod;\n  }\n\n  throw createResponseError(`Unsupported method '${method}'`, 400);\n}\n\nfunction serializeJsonBody(body: unknown): BodyInit {\n  if (typeof body === \"string\") {\n    return body;\n  }\n\n  if (body instanceof Blob || body instanceof ArrayBuffer || body instanceof Uint8Array) {\n    return body;\n  }\n\n  if (body instanceof FormData || body instanceof URLSearchParams) {\n    return body;\n  }\n\n  return JSON.stringify(body);\n}\n"],"mappings":"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","names":["import_client","import_encoder","import_client","import_client","import_shared","import_shared","import_shared","import_node_stream","import_shared","express","cors","import_express","import_cors","import_shared","express","cors"]}