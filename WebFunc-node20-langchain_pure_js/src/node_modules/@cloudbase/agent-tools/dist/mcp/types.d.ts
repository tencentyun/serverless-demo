/**
 * Type definitions for MCP integration with AG-Kit
 */
import { z } from "zod/v4";
import { ToolResult } from "../utils";
import { CallToolResult } from "@modelcontextprotocol/sdk/types.js";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
/**
 * MCP Client Configuration
 */
export interface MCPClientConfig {
    name?: string;
    version?: string;
    transport?: MCPTransportConfig;
    client?: Client;
    onReconnectNeeded?: (serverId: string, config: MCPClientConfig) => Promise<Client>;
}
interface IBaseMCPClientTransportConfig {
    type?: string;
    timeout?: number;
}
/**
 * MCP Transport Configuration
 */
export type MCPTransportConfig = MCPStdioTransportConfig | MCPSSETransportConfig | MCPStreamableHTTPTransportConfig | MCPInMemoryTransportConfig | MCPCustomTransportConfig;
/**
 * Stdio Transport Configuration
 */
export interface MCPStdioTransportConfig extends IBaseMCPClientTransportConfig {
    type?: "stdio";
    command: string;
    args?: string[];
}
/**
 * SSE Transport Configuration
 */
export interface MCPSSETransportConfig extends IBaseMCPClientTransportConfig {
    type?: "sse";
    url: string;
}
/**
 * StreamableHTTP Transport Configuration
 */
export interface MCPStreamableHTTPTransportConfig extends IBaseMCPClientTransportConfig {
    type?: "streamableHttp";
    url: string;
}
/**
 * InMemory Transport Configuration
 */
export interface MCPInMemoryTransportConfig extends IBaseMCPClientTransportConfig {
    type?: "memory";
    memoryId: string;
}
/**
 * Custom Transport Configuration
 */
export interface MCPCustomTransportConfig extends IBaseMCPClientTransportConfig {
    type?: "custom";
    transport: any;
}
/**
 * Detect transport type from configuration
 * Priority: memory > stdio > streamableHttp > sse
 */
export declare function detectTransportType(config: MCPTransportConfig): "memory" | "stdio" | "streamableHttp" | "sse" | "custom";
/**
 * MCP Tool Configuration
 */
export interface MCPToolConfig {
    name?: string;
    description?: string;
    inputSchema?: z.ZodSchema<any>;
    outputSchema?: z.ZodSchema<any>;
    timeout?: number;
    retries?: number;
}
/**
 * MCP Adapter Configuration
 */
export interface MCPAdapterConfig {
    includeMetadata?: boolean;
    transformInput?: (input: any) => any;
    transformOutput?: (output: any) => any;
    errorHandler?: (error: Error) => ToolResult;
}
/**
 * MCP Connection Options
 */
export interface MCPConnectionOptions {
    autoReconnect?: boolean;
    reconnectDelay?: number;
    maxReconnectAttempts?: number;
    heartbeatInterval?: number;
}
/**
 * MCP Tool Metadata (from MCP server)
 */
export interface MCPToolMetadata {
    name: string;
    description?: string;
    inputSchema?: any;
}
/**
 * MCP Event Types
 */
export type MCPEvent = {
    type: "connected";
    clientName: string;
} | {
    type: "disconnected";
    clientName: string;
    reason?: string;
} | {
    type: "tool_discovered";
    tool: MCPToolMetadata;
} | {
    type: "tool_called";
    toolName: string;
    arguments: any;
} | {
    type: "tool_result";
    toolName: string;
    result: CallToolResult;
} | {
    type: "error";
    error: Error;
    context?: string;
};
/**
 * MCP Event Listener
 */
export type MCPEventListener = (event: MCPEvent) => void;
/**
 * MCP Client Status
 */
export interface MCPClientStatus {
    connected: boolean;
    sessionId?: string;
    serverInfo?: {
        name: string;
        version: string;
    };
    capabilities?: Record<string, any>;
    toolCount: number;
    resourceCount: number;
    promptCount: number;
    lastActivity?: Date;
    reconnectAttempts?: number;
    errors: Array<{
        timestamp: Date;
        error: Error;
        context?: string;
    }>;
}
export {};
//# sourceMappingURL=types.d.ts.map