{"version":3,"sources":["../src/index.ts","../src/tool/mcp-client.ts","../src/error/mcp-client-error.ts","../src/tool/mcp-sse-transport.ts","../src/tool/json-rpc-message.ts","../src/tool/types.ts","../src/version.ts","../src/tool/oauth.ts","../src/tool/oauth-types.ts","../src/error/oauth-error.ts","../src/util/oauth-util.ts","../src/tool/mcp-http-transport.ts","../src/tool/mcp-transport.ts"],"sourcesContent":["export type {\n  JSONRPCError,\n  JSONRPCMessage,\n  JSONRPCNotification,\n  JSONRPCRequest,\n  JSONRPCResponse,\n} from './tool/json-rpc-message';\nexport {\n  createMCPClient as experimental_createMCPClient,\n  type MCPClientConfig as experimental_MCPClientConfig,\n  type MCPClient as experimental_MCPClient,\n} from './tool/mcp-client';\nexport { auth, UnauthorizedError } from './tool/oauth';\nexport type { OAuthClientProvider } from './tool/oauth';\nexport type {\n  OAuthClientInformation,\n  OAuthClientMetadata,\n  OAuthTokens,\n} from './tool/oauth-types';\nexport type { MCPTransport } from './tool/mcp-transport';\n","import { JSONSchema7 } from '@ai-sdk/provider';\nimport {\n  dynamicTool,\n  jsonSchema,\n  Tool,\n  tool,\n  ToolCallOptions,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport { MCPClientError } from '../error/mcp-client-error';\nimport {\n  JSONRPCError,\n  JSONRPCNotification,\n  JSONRPCRequest,\n  JSONRPCResponse,\n} from './json-rpc-message';\nimport {\n  createMcpTransport,\n  isCustomMcpTransport,\n  MCPTransport,\n  MCPTransportConfig,\n} from './mcp-transport';\nimport {\n  CallToolResult,\n  CallToolResultSchema,\n  Configuration as ClientConfiguration,\n  InitializeResultSchema,\n  LATEST_PROTOCOL_VERSION,\n  ListResourceTemplatesResult,\n  ListResourceTemplatesResultSchema,\n  ListResourcesResult,\n  ListResourcesResultSchema,\n  ListPromptsResult,\n  ListPromptsResultSchema,\n  ListToolsResult,\n  ListToolsResultSchema,\n  McpToolSet,\n  Notification,\n  PaginatedRequest,\n  ReadResourceResult,\n  ReadResourceResultSchema,\n  GetPromptResult,\n  GetPromptResultSchema,\n  Request,\n  RequestOptions,\n  ServerCapabilities,\n  SUPPORTED_PROTOCOL_VERSIONS,\n  ToolSchemas,\n} from './types';\n\nconst CLIENT_VERSION = '1.0.0';\n\nexport interface MCPClientConfig {\n  /** Transport configuration for connecting to the MCP server */\n  transport: MCPTransportConfig | MCPTransport;\n  /** Optional callback for uncaught errors */\n  onUncaughtError?: (error: unknown) => void;\n  /** Optional client name, defaults to 'ai-sdk-mcp-client' */\n  name?: string;\n}\n\nexport async function createMCPClient(\n  config: MCPClientConfig,\n): Promise<MCPClient> {\n  const client = new DefaultMCPClient(config);\n  await client.init();\n  return client;\n}\n\nexport interface MCPClient {\n  tools<TOOL_SCHEMAS extends ToolSchemas = 'automatic'>(options?: {\n    schemas?: TOOL_SCHEMAS;\n  }): Promise<McpToolSet<TOOL_SCHEMAS>>;\n\n  listResources(options?: {\n    params?: PaginatedRequest['params'];\n    options?: RequestOptions;\n  }): Promise<ListResourcesResult>;\n\n  readResource(args: {\n    uri: string;\n    options?: RequestOptions;\n  }): Promise<ReadResourceResult>;\n\n  listResourceTemplates(options?: {\n    options?: RequestOptions;\n  }): Promise<ListResourceTemplatesResult>;\n\n  listPrompts(options?: {\n    params?: PaginatedRequest['params'];\n    options?: RequestOptions;\n  }): Promise<ListPromptsResult>;\n\n  getPrompt(args: {\n    name: string;\n    arguments?: Record<string, unknown>;\n    options?: RequestOptions;\n  }): Promise<GetPromptResult>;\n\n  close: () => Promise<void>;\n}\n\n/**\n * A lightweight MCP Client implementation\n *\n * The primary purpose of this client is tool conversion between MCP<>AI SDK\n * but can later be extended to support other MCP features\n *\n * Tool parameters are automatically inferred from the server's JSON schema\n * if not explicitly provided in the tools configuration\n *\n * This client is meant to be used to communicate with a single server. To communicate and fetch tools across multiple servers, it's recommended to create a new client instance per server.\n *\n * Not supported:\n * - Client options (e.g. sampling, roots) as they are not needed for tool conversion\n * - Accepting notifications\n * - Session management (when passing a sessionId to an instance of the Streamable HTTP transport)\n * - Resumable SSE streams\n */\nclass DefaultMCPClient implements MCPClient {\n  private transport: MCPTransport;\n  private onUncaughtError?: (error: unknown) => void;\n  private clientInfo: ClientConfiguration;\n  private requestMessageId = 0;\n  private responseHandlers: Map<\n    number,\n    (response: JSONRPCResponse | Error) => void\n  > = new Map();\n  private serverCapabilities: ServerCapabilities = {};\n  private isClosed = true;\n\n  constructor({\n    transport: transportConfig,\n    name = 'ai-sdk-mcp-client',\n    onUncaughtError,\n  }: MCPClientConfig) {\n    this.onUncaughtError = onUncaughtError;\n\n    if (isCustomMcpTransport(transportConfig)) {\n      this.transport = transportConfig;\n    } else {\n      this.transport = createMcpTransport(transportConfig);\n    }\n\n    this.transport.onclose = () => this.onClose();\n    this.transport.onerror = (error: Error) => this.onError(error);\n    this.transport.onmessage = message => {\n      if ('method' in message) {\n        // This lightweight client implementation does not support\n        // receiving notifications or requests from server.\n        // If we get an unsupported message, we can safely ignore it and pass to the onError handler:\n        this.onError(\n          new MCPClientError({\n            message: 'Unsupported message type',\n          }),\n        );\n        return;\n      }\n\n      this.onResponse(message);\n    };\n\n    this.clientInfo = {\n      name,\n      version: CLIENT_VERSION,\n    };\n  }\n\n  async init(): Promise<this> {\n    try {\n      await this.transport.start();\n      this.isClosed = false;\n\n      const result = await this.request({\n        request: {\n          method: 'initialize',\n          params: {\n            protocolVersion: LATEST_PROTOCOL_VERSION,\n            capabilities: {},\n            clientInfo: this.clientInfo,\n          },\n        },\n        resultSchema: InitializeResultSchema,\n      });\n\n      if (result === undefined) {\n        throw new MCPClientError({\n          message: 'Server sent invalid initialize result',\n        });\n      }\n\n      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {\n        throw new MCPClientError({\n          message: `Server's protocol version is not supported: ${result.protocolVersion}`,\n        });\n      }\n\n      this.serverCapabilities = result.capabilities;\n\n      // Complete initialization handshake:\n      await this.notification({\n        method: 'notifications/initialized',\n      });\n\n      return this;\n    } catch (error) {\n      await this.close();\n      throw error;\n    }\n  }\n\n  async close(): Promise<void> {\n    if (this.isClosed) return;\n    await this.transport?.close();\n    this.onClose();\n  }\n\n  private assertCapability(method: string): void {\n    switch (method) {\n      case 'initialize':\n        break;\n      case 'tools/list':\n      case 'tools/call':\n        if (!this.serverCapabilities.tools) {\n          throw new MCPClientError({\n            message: `Server does not support tools`,\n          });\n        }\n        break;\n      case 'resources/list':\n      case 'resources/read':\n      case 'resources/templates/list':\n        if (!this.serverCapabilities.resources) {\n          throw new MCPClientError({\n            message: `Server does not support resources`,\n          });\n        }\n        break;\n      case 'prompts/list':\n      case 'prompts/get':\n        if (!this.serverCapabilities.prompts) {\n          throw new MCPClientError({\n            message: `Server does not support prompts`,\n          });\n        }\n        break;\n      default:\n        throw new MCPClientError({\n          message: `Unsupported method: ${method}`,\n        });\n    }\n  }\n\n  private async request<T extends z.ZodType<object>>({\n    request,\n    resultSchema,\n    options,\n  }: {\n    request: Request;\n    resultSchema: T;\n    options?: RequestOptions;\n  }): Promise<z.infer<T>> {\n    return new Promise((resolve, reject) => {\n      if (this.isClosed) {\n        return reject(\n          new MCPClientError({\n            message: 'Attempted to send a request from a closed client',\n          }),\n        );\n      }\n\n      this.assertCapability(request.method);\n\n      const signal = options?.signal;\n      signal?.throwIfAborted();\n\n      const messageId = this.requestMessageId++;\n      const jsonrpcRequest: JSONRPCRequest = {\n        ...request,\n        jsonrpc: '2.0',\n        id: messageId,\n      };\n\n      const cleanup = () => {\n        this.responseHandlers.delete(messageId);\n      };\n\n      this.responseHandlers.set(messageId, response => {\n        if (signal?.aborted) {\n          return reject(\n            new MCPClientError({\n              message: 'Request was aborted',\n              cause: signal.reason,\n            }),\n          );\n        }\n\n        if (response instanceof Error) {\n          return reject(response);\n        }\n\n        try {\n          const result = resultSchema.parse(response.result);\n          resolve(result);\n        } catch (error) {\n          const parseError = new MCPClientError({\n            message: 'Failed to parse server response',\n            cause: error,\n          });\n          reject(parseError);\n        }\n      });\n\n      this.transport.send(jsonrpcRequest).catch(error => {\n        cleanup();\n        reject(error);\n      });\n    });\n  }\n\n  private async listTools({\n    params,\n    options,\n  }: {\n    params?: PaginatedRequest['params'];\n    options?: RequestOptions;\n  } = {}): Promise<ListToolsResult> {\n    try {\n      return this.request({\n        request: { method: 'tools/list', params },\n        resultSchema: ListToolsResultSchema,\n        options,\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async callTool({\n    name,\n    args,\n    options,\n  }: {\n    name: string;\n    args: Record<string, unknown>;\n    options?: ToolCallOptions;\n  }): Promise<CallToolResult> {\n    try {\n      return this.request({\n        request: { method: 'tools/call', params: { name, arguments: args } },\n        resultSchema: CallToolResultSchema,\n        options: {\n          signal: options?.abortSignal,\n        },\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async listResourcesInternal({\n    params,\n    options,\n  }: {\n    params?: PaginatedRequest['params'];\n    options?: RequestOptions;\n  } = {}): Promise<ListResourcesResult> {\n    try {\n      return this.request({\n        request: { method: 'resources/list', params },\n        resultSchema: ListResourcesResultSchema,\n        options,\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async readResourceInternal({\n    uri,\n    options,\n  }: {\n    uri: string;\n    options?: RequestOptions;\n  }): Promise<ReadResourceResult> {\n    try {\n      return this.request({\n        request: { method: 'resources/read', params: { uri } },\n        resultSchema: ReadResourceResultSchema,\n        options,\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async listResourceTemplatesInternal({\n    options,\n  }: {\n    options?: RequestOptions;\n  } = {}): Promise<ListResourceTemplatesResult> {\n    try {\n      return this.request({\n        request: { method: 'resources/templates/list' },\n        resultSchema: ListResourceTemplatesResultSchema,\n        options,\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async listPromptsInternal({\n    params,\n    options,\n  }: {\n    params?: PaginatedRequest['params'];\n    options?: RequestOptions;\n  } = {}): Promise<ListPromptsResult> {\n    try {\n      return this.request({\n        request: { method: 'prompts/list', params },\n        resultSchema: ListPromptsResultSchema,\n        options,\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async getPromptInternal({\n    name,\n    args,\n    options,\n  }: {\n    name: string;\n    args?: Record<string, unknown>;\n    options?: RequestOptions;\n  }): Promise<GetPromptResult> {\n    try {\n      return this.request({\n        request: { method: 'prompts/get', params: { name, arguments: args } },\n        resultSchema: GetPromptResultSchema,\n        options,\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  private async notification(notification: Notification): Promise<void> {\n    const jsonrpcNotification: JSONRPCNotification = {\n      ...notification,\n      jsonrpc: '2.0',\n    };\n    await this.transport.send(jsonrpcNotification);\n  }\n\n  /**\n   * Returns a set of AI SDK tools from the MCP server\n   * @returns A record of tool names to their implementations\n   */\n  async tools<TOOL_SCHEMAS extends ToolSchemas = 'automatic'>({\n    schemas = 'automatic',\n  }: {\n    schemas?: TOOL_SCHEMAS;\n  } = {}): Promise<McpToolSet<TOOL_SCHEMAS>> {\n    const tools: Record<string, Tool> = {};\n\n    try {\n      const listToolsResult = await this.listTools();\n\n      for (const { name, description, inputSchema } of listToolsResult.tools) {\n        if (schemas !== 'automatic' && !(name in schemas)) {\n          continue;\n        }\n\n        const self = this;\n\n        const execute = async (\n          args: any,\n          options: ToolCallOptions,\n        ): Promise<CallToolResult> => {\n          options?.abortSignal?.throwIfAborted();\n          return self.callTool({ name, args, options });\n        };\n\n        const toolWithExecute =\n          schemas === 'automatic'\n            ? dynamicTool({\n                description,\n                inputSchema: jsonSchema({\n                  ...inputSchema,\n                  properties: inputSchema.properties ?? {},\n                  additionalProperties: false,\n                } as JSONSchema7),\n                execute,\n              })\n            : tool({\n                description,\n                inputSchema: schemas[name].inputSchema,\n                execute,\n              });\n\n        tools[name] = toolWithExecute;\n      }\n\n      return tools as McpToolSet<TOOL_SCHEMAS>;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  listResources({\n    params,\n    options,\n  }: {\n    params?: PaginatedRequest['params'];\n    options?: RequestOptions;\n  } = {}): Promise<ListResourcesResult> {\n    return this.listResourcesInternal({ params, options });\n  }\n\n  readResource({\n    uri,\n    options,\n  }: {\n    uri: string;\n    options?: RequestOptions;\n  }): Promise<ReadResourceResult> {\n    return this.readResourceInternal({ uri, options });\n  }\n\n  listResourceTemplates({\n    options,\n  }: {\n    options?: RequestOptions;\n  } = {}): Promise<ListResourceTemplatesResult> {\n    return this.listResourceTemplatesInternal({ options });\n  }\n\n  listPrompts({\n    params,\n    options,\n  }: {\n    params?: PaginatedRequest['params'];\n    options?: RequestOptions;\n  } = {}): Promise<ListPromptsResult> {\n    return this.listPromptsInternal({ params, options });\n  }\n\n  getPrompt({\n    name,\n    arguments: args,\n    options,\n  }: {\n    name: string;\n    arguments?: Record<string, unknown>;\n    options?: RequestOptions;\n  }): Promise<GetPromptResult> {\n    return this.getPromptInternal({ name, args, options });\n  }\n\n  private onClose(): void {\n    if (this.isClosed) return;\n\n    this.isClosed = true;\n    const error = new MCPClientError({\n      message: 'Connection closed',\n    });\n\n    for (const handler of this.responseHandlers.values()) {\n      handler(error);\n    }\n\n    this.responseHandlers.clear();\n  }\n\n  private onError(error: unknown): void {\n    if (this.onUncaughtError) {\n      this.onUncaughtError(error);\n    }\n  }\n\n  private onResponse(response: JSONRPCResponse | JSONRPCError): void {\n    const messageId = Number(response.id);\n    const handler = this.responseHandlers.get(messageId);\n\n    if (handler === undefined) {\n      throw new MCPClientError({\n        message: `Protocol error: Received a response for an unknown message ID: ${JSON.stringify(\n          response,\n        )}`,\n      });\n    }\n\n    this.responseHandlers.delete(messageId);\n\n    handler(\n      'result' in response\n        ? response\n        : new MCPClientError({\n            message: response.error.message,\n            code: response.error.code,\n            data: response.error.data,\n            cause: response.error,\n          }),\n    );\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_MCPClientError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * An error occurred with the MCP client.\n */\nexport class MCPClientError extends AISDKError {\n  private readonly [symbol] = true;\n  readonly data?: unknown;\n  readonly code?: number;\n\n  constructor({\n    name = 'MCPClientError',\n    message,\n    cause,\n    data,\n    code,\n  }: {\n    name?: string;\n    message: string;\n    cause?: unknown;\n    data?: unknown;\n    code?: number;\n  }) {\n    super({ name, message, cause });\n    this.data = data;\n    this.code = code;\n  }\n\n  static isInstance(error: unknown): error is MCPClientError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import {\n  EventSourceParserStream,\n  withUserAgentSuffix,\n  getRuntimeEnvironmentUserAgent,\n} from '@ai-sdk/provider-utils';\nimport { MCPClientError } from '../error/mcp-client-error';\nimport { JSONRPCMessage, JSONRPCMessageSchema } from './json-rpc-message';\nimport { MCPTransport } from './mcp-transport';\nimport { VERSION } from '../version';\nimport {\n  OAuthClientProvider,\n  extractResourceMetadataUrl,\n  UnauthorizedError,\n  auth,\n} from './oauth';\nimport { LATEST_PROTOCOL_VERSION } from './types';\n\nexport class SseMCPTransport implements MCPTransport {\n  private endpoint?: URL;\n  private abortController?: AbortController;\n  private url: URL;\n  private connected = false;\n  private sseConnection?: {\n    close: () => void;\n  };\n  private headers?: Record<string, string>;\n  private authProvider?: OAuthClientProvider;\n  private resourceMetadataUrl?: URL;\n\n  onclose?: () => void;\n  onerror?: (error: unknown) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor({\n    url,\n    headers,\n    authProvider,\n  }: {\n    url: string;\n    headers?: Record<string, string>;\n    authProvider?: OAuthClientProvider;\n  }) {\n    this.url = new URL(url);\n    this.headers = headers;\n    this.authProvider = authProvider;\n  }\n\n  private async commonHeaders(\n    base: Record<string, string>,\n  ): Promise<Record<string, string>> {\n    const headers: Record<string, string> = {\n      ...this.headers,\n      ...base,\n      'mcp-protocol-version': LATEST_PROTOCOL_VERSION,\n    };\n\n    if (this.authProvider) {\n      const tokens = await this.authProvider.tokens();\n      if (tokens?.access_token) {\n        headers['Authorization'] = `Bearer ${tokens.access_token}`;\n      }\n    }\n\n    return withUserAgentSuffix(\n      headers,\n      `ai-sdk/${VERSION}`,\n      getRuntimeEnvironmentUserAgent(),\n    );\n  }\n\n  async start(): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      if (this.connected) {\n        return resolve();\n      }\n\n      this.abortController = new AbortController();\n\n      const establishConnection = async (triedAuth: boolean = false) => {\n        try {\n          const headers = await this.commonHeaders({\n            Accept: 'text/event-stream',\n          });\n          const response = await fetch(this.url.href, {\n            headers,\n            signal: this.abortController?.signal,\n          });\n\n          if (response.status === 401 && this.authProvider && !triedAuth) {\n            this.resourceMetadataUrl = extractResourceMetadataUrl(response);\n            try {\n              const result = await auth(this.authProvider, {\n                serverUrl: this.url,\n                resourceMetadataUrl: this.resourceMetadataUrl,\n              });\n              if (result !== 'AUTHORIZED') {\n                const error = new UnauthorizedError();\n                this.onerror?.(error);\n                return reject(error);\n              }\n            } catch (error) {\n              this.onerror?.(error);\n              return reject(error);\n            }\n            return establishConnection(true);\n          }\n\n          if (!response.ok || !response.body) {\n            let errorMessage = `MCP SSE Transport Error: ${response.status} ${response.statusText}`;\n\n            if (response.status === 405) {\n              errorMessage +=\n                '. This server does not support SSE transport. Try using `http` transport instead';\n            }\n\n            const error = new MCPClientError({\n              message: errorMessage,\n            });\n            this.onerror?.(error);\n            return reject(error);\n          }\n\n          const stream = response.body\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(new EventSourceParserStream());\n\n          const reader = stream.getReader();\n\n          const processEvents = async () => {\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n\n                if (done) {\n                  if (this.connected) {\n                    this.connected = false;\n                    throw new MCPClientError({\n                      message:\n                        'MCP SSE Transport Error: Connection closed unexpectedly',\n                    });\n                  }\n                  return;\n                }\n\n                const { event, data } = value;\n\n                if (event === 'endpoint') {\n                  this.endpoint = new URL(data, this.url);\n\n                  if (this.endpoint.origin !== this.url.origin) {\n                    throw new MCPClientError({\n                      message: `MCP SSE Transport Error: Endpoint origin does not match connection origin: ${this.endpoint.origin}`,\n                    });\n                  }\n\n                  this.connected = true;\n                  resolve();\n                } else if (event === 'message') {\n                  try {\n                    const message = JSONRPCMessageSchema.parse(\n                      JSON.parse(data),\n                    );\n                    this.onmessage?.(message);\n                  } catch (error) {\n                    const e = new MCPClientError({\n                      message:\n                        'MCP SSE Transport Error: Failed to parse message',\n                      cause: error,\n                    });\n                    this.onerror?.(e);\n                    // We do not throw here so we continue processing events after reporting the error\n                  }\n                }\n              }\n            } catch (error) {\n              if (error instanceof Error && error.name === 'AbortError') {\n                return;\n              }\n\n              this.onerror?.(error);\n              reject(error);\n            }\n          };\n\n          this.sseConnection = {\n            close: () => reader.cancel(),\n          };\n\n          processEvents();\n        } catch (error) {\n          if (error instanceof Error && error.name === 'AbortError') {\n            return;\n          }\n\n          this.onerror?.(error);\n          reject(error);\n        }\n      };\n\n      void establishConnection();\n    });\n  }\n\n  async close(): Promise<void> {\n    this.connected = false;\n    this.sseConnection?.close();\n    this.abortController?.abort();\n    this.onclose?.();\n  }\n\n  async send(message: JSONRPCMessage): Promise<void> {\n    if (!this.endpoint || !this.connected) {\n      throw new MCPClientError({\n        message: 'MCP SSE Transport Error: Not connected',\n      });\n    }\n\n    const endpoint = this.endpoint as URL;\n\n    const attempt = async (triedAuth: boolean = false): Promise<void> => {\n      try {\n        const headers = await this.commonHeaders({\n          'Content-Type': 'application/json',\n        });\n        const init = {\n          method: 'POST',\n          headers,\n          body: JSON.stringify(message),\n          signal: this.abortController?.signal,\n        };\n\n        const response = await fetch(endpoint, init);\n\n        if (response.status === 401 && this.authProvider && !triedAuth) {\n          this.resourceMetadataUrl = extractResourceMetadataUrl(response);\n          try {\n            const result = await auth(this.authProvider, {\n              serverUrl: this.url,\n              resourceMetadataUrl: this.resourceMetadataUrl,\n            });\n            if (result !== 'AUTHORIZED') {\n              const error = new UnauthorizedError();\n              this.onerror?.(error);\n              return;\n            }\n          } catch (error) {\n            this.onerror?.(error);\n            return;\n          }\n          return attempt(true);\n        }\n\n        if (!response.ok) {\n          const text = await response.text().catch(() => null);\n          const error = new MCPClientError({\n            message: `MCP SSE Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text}`,\n          });\n          this.onerror?.(error);\n          return;\n        }\n      } catch (error) {\n        this.onerror?.(error);\n        return;\n      }\n    };\n    await attempt();\n  }\n}\n\nexport function deserializeMessage(line: string): JSONRPCMessage {\n  return JSONRPCMessageSchema.parse(JSON.parse(line));\n}\n","import { z } from 'zod/v4';\nimport { BaseParamsSchema, RequestSchema, ResultSchema } from './types';\n\nconst JSONRPC_VERSION = '2.0';\n\nconst JSONRPCRequestSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n  })\n  .merge(RequestSchema)\n  .strict();\n\nexport type JSONRPCRequest = z.infer<typeof JSONRPCRequestSchema>;\n\nconst JSONRPCResponseSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n    result: ResultSchema,\n  })\n  .strict();\n\nexport type JSONRPCResponse = z.infer<typeof JSONRPCResponseSchema>;\n\nconst JSONRPCErrorSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n    id: z.union([z.string(), z.number().int()]),\n    error: z.object({\n      code: z.number().int(),\n      message: z.string(),\n      data: z.optional(z.unknown()),\n    }),\n  })\n  .strict();\n\nexport type JSONRPCError = z.infer<typeof JSONRPCErrorSchema>;\n\nconst JSONRPCNotificationSchema = z\n  .object({\n    jsonrpc: z.literal(JSONRPC_VERSION),\n  })\n  .merge(\n    z.object({\n      method: z.string(),\n      params: z.optional(BaseParamsSchema),\n    }),\n  )\n  .strict();\n\nexport type JSONRPCNotification = z.infer<typeof JSONRPCNotificationSchema>;\n\nexport const JSONRPCMessageSchema = z.union([\n  JSONRPCRequestSchema,\n  JSONRPCNotificationSchema,\n  JSONRPCResponseSchema,\n  JSONRPCErrorSchema,\n]);\n\nexport type JSONRPCMessage = z.infer<typeof JSONRPCMessageSchema>;\n","import { z } from 'zod/v4';\nimport { JSONObject } from '@ai-sdk/provider';\nimport { FlexibleSchema, Tool } from '@ai-sdk/provider-utils';\n\nexport const LATEST_PROTOCOL_VERSION = '2025-06-18';\nexport const SUPPORTED_PROTOCOL_VERSIONS = [\n  LATEST_PROTOCOL_VERSION,\n  '2025-03-26',\n  '2024-11-05',\n];\n\nexport type ToolSchemas =\n  | Record<string, { inputSchema: FlexibleSchema<JSONObject | unknown> }>\n  | 'automatic'\n  | undefined;\n\nexport type McpToolSet<TOOL_SCHEMAS extends ToolSchemas = 'automatic'> =\n  TOOL_SCHEMAS extends Record<string, { inputSchema: FlexibleSchema<any> }>\n    ? {\n        [K in keyof TOOL_SCHEMAS]: TOOL_SCHEMAS[K] extends {\n          inputSchema: FlexibleSchema<infer INPUT>;\n        }\n          ? Tool<INPUT, CallToolResult> &\n              Required<Pick<Tool<INPUT, CallToolResult>, 'execute'>>\n          : never;\n      }\n    : McpToolSet<Record<string, { inputSchema: FlexibleSchema<unknown> }>>;\n\nconst ClientOrServerImplementationSchema = z.looseObject({\n  name: z.string(),\n  version: z.string(),\n});\n\nexport type Configuration = z.infer<typeof ClientOrServerImplementationSchema>;\n\nexport const BaseParamsSchema = z.looseObject({\n  _meta: z.optional(z.object({}).loose()),\n});\ntype BaseParams = z.infer<typeof BaseParamsSchema>;\nexport const ResultSchema = BaseParamsSchema;\n\nexport const RequestSchema = z.object({\n  method: z.string(),\n  params: z.optional(BaseParamsSchema),\n});\nexport type Request = z.infer<typeof RequestSchema>;\nexport type RequestOptions = {\n  signal?: AbortSignal;\n  timeout?: number;\n  maxTotalTimeout?: number;\n};\n\nexport type Notification = z.infer<typeof RequestSchema>;\n\nconst ServerCapabilitiesSchema = z.looseObject({\n  experimental: z.optional(z.object({}).loose()),\n  logging: z.optional(z.object({}).loose()),\n  prompts: z.optional(\n    z.looseObject({\n      listChanged: z.optional(z.boolean()),\n    }),\n  ),\n  resources: z.optional(\n    z.looseObject({\n      subscribe: z.optional(z.boolean()),\n      listChanged: z.optional(z.boolean()),\n    }),\n  ),\n  tools: z.optional(\n    z.looseObject({\n      listChanged: z.optional(z.boolean()),\n    }),\n  ),\n});\n\nexport type ServerCapabilities = z.infer<typeof ServerCapabilitiesSchema>;\n\nexport const InitializeResultSchema = ResultSchema.extend({\n  protocolVersion: z.string(),\n  capabilities: ServerCapabilitiesSchema,\n  serverInfo: ClientOrServerImplementationSchema,\n  instructions: z.optional(z.string()),\n});\nexport type InitializeResult = z.infer<typeof InitializeResultSchema>;\n\nexport type PaginatedRequest = Request & {\n  params?: BaseParams & {\n    cursor?: string;\n  };\n};\n\nconst PaginatedResultSchema = ResultSchema.extend({\n  nextCursor: z.optional(z.string()),\n});\n\nconst ToolSchema = z\n  .object({\n    name: z.string(),\n    description: z.optional(z.string()),\n    inputSchema: z\n      .object({\n        type: z.literal('object'),\n        properties: z.optional(z.object({}).loose()),\n      })\n      .loose(),\n  })\n  .loose();\nexport type MCPTool = z.infer<typeof ToolSchema>;\nexport const ListToolsResultSchema = PaginatedResultSchema.extend({\n  tools: z.array(ToolSchema),\n});\nexport type ListToolsResult = z.infer<typeof ListToolsResultSchema>;\n\nconst TextContentSchema = z\n  .object({\n    type: z.literal('text'),\n    text: z.string(),\n  })\n  .loose();\nconst ImageContentSchema = z\n  .object({\n    type: z.literal('image'),\n    data: z.base64(),\n    mimeType: z.string(),\n  })\n  .loose();\nexport const ResourceSchema = z\n  .object({\n    uri: z.string(),\n    name: z.string(),\n    title: z.optional(z.string()),\n    description: z.optional(z.string()),\n    mimeType: z.optional(z.string()),\n    size: z.optional(z.number()),\n  })\n  .loose();\nexport type MCPResource = z.infer<typeof ResourceSchema>;\n\nexport const ListResourcesResultSchema = PaginatedResultSchema.extend({\n  resources: z.array(ResourceSchema),\n});\nexport type ListResourcesResult = z.infer<typeof ListResourcesResultSchema>;\n\nconst ResourceContentsSchema = z\n  .object({\n    /**\n     * The URI of this resource.\n     */\n    uri: z.string(),\n    /**\n     * Optional display name of the resource content.\n     */\n    name: z.optional(z.string()),\n    /**\n     * Optional human readable title.\n     */\n    title: z.optional(z.string()),\n    /**\n     * The MIME type of this resource, if known.\n     */\n    mimeType: z.optional(z.string()),\n  })\n  .loose();\nconst TextResourceContentsSchema = ResourceContentsSchema.extend({\n  text: z.string(),\n});\nconst BlobResourceContentsSchema = ResourceContentsSchema.extend({\n  blob: z.base64(),\n});\nconst EmbeddedResourceSchema = z\n  .object({\n    type: z.literal('resource'),\n    resource: z.union([TextResourceContentsSchema, BlobResourceContentsSchema]),\n  })\n  .loose();\n\nexport const CallToolResultSchema = ResultSchema.extend({\n  content: z.array(\n    z.union([TextContentSchema, ImageContentSchema, EmbeddedResourceSchema]),\n  ),\n  isError: z.boolean().default(false).optional(),\n}).or(\n  ResultSchema.extend({\n    toolResult: z.unknown(),\n  }),\n);\nexport type CallToolResult = z.infer<typeof CallToolResultSchema>;\n\nconst ResourceTemplateSchema = z\n  .object({\n    uriTemplate: z.string(),\n    name: z.string(),\n    title: z.optional(z.string()),\n    description: z.optional(z.string()),\n    mimeType: z.optional(z.string()),\n  })\n  .loose();\n\nexport const ListResourceTemplatesResultSchema = ResultSchema.extend({\n  resourceTemplates: z.array(ResourceTemplateSchema),\n});\nexport type ListResourceTemplatesResult = z.infer<\n  typeof ListResourceTemplatesResultSchema\n>;\n\nexport const ReadResourceResultSchema = ResultSchema.extend({\n  contents: z.array(\n    z.union([TextResourceContentsSchema, BlobResourceContentsSchema]),\n  ),\n});\nexport type ReadResourceResult = z.infer<typeof ReadResourceResultSchema>;\n\n// Prompts\nconst PromptArgumentSchema = z\n  .object({\n    name: z.string(),\n    description: z.optional(z.string()),\n    required: z.optional(z.boolean()),\n  })\n  .loose();\n\nexport const PromptSchema = z\n  .object({\n    name: z.string(),\n    title: z.optional(z.string()),\n    description: z.optional(z.string()),\n    arguments: z.optional(z.array(PromptArgumentSchema)),\n  })\n  .loose();\nexport type MCPPrompt = z.infer<typeof PromptSchema>;\n\nexport const ListPromptsResultSchema = PaginatedResultSchema.extend({\n  prompts: z.array(PromptSchema),\n});\nexport type ListPromptsResult = z.infer<typeof ListPromptsResultSchema>;\n\nconst PromptMessageSchema = z\n  .object({\n    role: z.union([z.literal('user'), z.literal('assistant')]),\n    content: z.union([\n      TextContentSchema,\n      ImageContentSchema,\n      EmbeddedResourceSchema,\n    ]),\n  })\n  .loose();\nexport type MCPPromptMessage = z.infer<typeof PromptMessageSchema>;\n\nexport const GetPromptResultSchema = ResultSchema.extend({\n  description: z.optional(z.string()),\n  messages: z.array(PromptMessageSchema),\n});\nexport type GetPromptResult = z.infer<typeof GetPromptResultSchema>;\n","declare const __PACKAGE_VERSION__: string | undefined;\nexport const VERSION: string =\n  typeof __PACKAGE_VERSION__ !== 'undefined'\n    ? __PACKAGE_VERSION__\n    : '0.0.0-test';\n","import pkceChallenge from 'pkce-challenge';\nimport {\n  OAuthTokens,\n  OAuthProtectedResourceMetadata,\n  OAuthProtectedResourceMetadataSchema,\n  OAuthMetadataSchema,\n  OpenIdProviderDiscoveryMetadataSchema,\n  AuthorizationServerMetadata,\n  OAuthClientInformation,\n  OAuthTokensSchema,\n  OAuthErrorResponseSchema,\n  OAuthClientMetadata,\n  OAuthClientInformationFull,\n  OAuthClientInformationFullSchema,\n} from './oauth-types';\nimport {\n  MCPClientOAuthError,\n  ServerError,\n  OAUTH_ERRORS,\n  InvalidClientError,\n  InvalidGrantError,\n  UnauthorizedClientError,\n} from '../error/oauth-error';\nimport {\n  resourceUrlFromServerUrl,\n  checkResourceAllowed,\n} from '../util/oauth-util';\nimport { LATEST_PROTOCOL_VERSION } from './types';\nimport { FetchFunction } from '@ai-sdk/provider-utils';\n\nexport type AuthResult = 'AUTHORIZED' | 'REDIRECT';\n\nexport interface OAuthClientProvider {\n  /**\n   * Returns current access token if present; undefined otherwise.\n   */\n  tokens(): OAuthTokens | undefined | Promise<OAuthTokens | undefined>;\n  saveTokens(tokens: OAuthTokens): void | Promise<void>;\n  redirectToAuthorization(authorizationUrl: URL): void | Promise<void>;\n  saveCodeVerifier(codeVerifier: string): void | Promise<void>;\n  codeVerifier(): string | Promise<string>;\n\n  /**\n   * Adds custom client authentication to OAuth token requests.\n   *\n   * This optional method allows implementations to customize how client credentials\n   * are included in token exchange and refresh requests. When provided, this method\n   * is called instead of the default authentication logic, giving full control over\n   * the authentication mechanism.\n   *\n   * Common use cases include:\n   * - Supporting authentication methods beyond the standard OAuth 2.0 methods\n   * - Adding custom headers for proprietary authentication schemes\n   * - Implementing client assertion-based authentication (e.g., JWT bearer tokens)\n   *\n   * @param headers - The request headers (can be modified to add authentication)\n   * @param params - The request body parameters (can be modified to add credentials)\n   * @param url - The token endpoint URL being called\n   * @param metadata - Optional OAuth metadata for the server, which may include supported authentication methods\n   */\n  addClientAuthentication?(\n    headers: Headers,\n    params: URLSearchParams,\n    url: string | URL,\n    metadata?: AuthorizationServerMetadata,\n  ): void | Promise<void>;\n\n  /**\n   * If implemented, provides a way for the client to invalidate (e.g. delete) the specified\n   * credentials, in the case where the server has indicated that they are no longer valid.\n   * This avoids requiring the user to intervene manually.\n   */\n  invalidateCredentials?(\n    scope: 'all' | 'client' | 'tokens' | 'verifier',\n  ): void | Promise<void>;\n  get redirectUrl(): string | URL;\n  get clientMetadata(): OAuthClientMetadata;\n  clientInformation():\n    | OAuthClientInformation\n    | undefined\n    | Promise<OAuthClientInformation | undefined>;\n  saveClientInformation?(\n    clientInformation: OAuthClientInformation,\n  ): void | Promise<void>;\n  state?(): string | Promise<string>;\n  validateResourceURL?(\n    serverUrl: string | URL,\n    resource?: string,\n  ): Promise<URL | undefined>;\n}\n\nexport class UnauthorizedError extends Error {\n  constructor(message = 'Unauthorized') {\n    super(message);\n    this.name = 'UnauthorizedError';\n  }\n}\n\n/**\n * Extracts the OAuth 2.0 Protected Resource Metadata URL from a WWW-Authenticate header (RFC9728).\n * Looks for a resource=\"...\" parameter.\n */\nexport function extractResourceMetadataUrl(\n  response: Response,\n): URL | undefined {\n  const header =\n    response.headers.get('www-authenticate') ??\n    response.headers.get('WWW-Authenticate');\n  if (!header) {\n    return undefined;\n  }\n\n  const [type, scheme] = header.split(' ');\n  if (type.toLowerCase() !== 'bearer' || !scheme) {\n    return undefined;\n  }\n\n  // regex taken from MCP spec\n  const regex = /resource_metadata=\"([^\"]*)\"/;\n  const match = header.match(regex);\n  if (!match) {\n    return undefined;\n  }\n\n  try {\n    return new URL(match[1]);\n  } catch {\n    return undefined;\n  }\n}\n\n/**\n * Constructs the well-known path for auth-related metadata discovery\n */\nfunction buildWellKnownPath(\n  wellKnownPrefix:\n    | 'oauth-authorization-server'\n    | 'oauth-protected-resource'\n    | 'openid-configuration',\n  pathname: string = '',\n  options: { prependPathname?: boolean } = {},\n): string {\n  if (pathname.endsWith('/')) {\n    pathname = pathname.slice(0, -1);\n  }\n\n  return options.prependPathname\n    ? `${pathname}/.well-known/${wellKnownPrefix}`\n    : `/.well-known/${wellKnownPrefix}${pathname}`;\n}\n\nasync function fetchWithCorsRetry(\n  url: URL,\n  headers?: Record<string, string>,\n  fetchFn: FetchFunction = fetch,\n): Promise<Response | undefined> {\n  try {\n    return await fetchFn(url, { headers });\n  } catch (error) {\n    if (error instanceof TypeError) {\n      if (headers) {\n        return fetchWithCorsRetry(url, undefined, fetchFn);\n      } else {\n        return undefined;\n      }\n    }\n    throw error;\n  }\n}\n\n/**\n * Tries to discover OAuth metadata at a specific URL\n */\nasync function tryMetadataDiscovery(\n  url: URL,\n  protocolVersion: string,\n  fetchFn: FetchFunction = fetch,\n): Promise<Response | undefined> {\n  const headers = {\n    'MCP-Protocol-Version': protocolVersion,\n  };\n  return await fetchWithCorsRetry(url, headers, fetchFn);\n}\n\n/**\n * Determines if fallback to root discovery should be attempted\n */\nfunction shouldAttemptFallback(\n  response: Response | undefined,\n  pathname: string,\n): boolean {\n  return (\n    !response ||\n    (response.status >= 400 && response.status < 500 && pathname !== '/')\n  );\n}\n\n/**\n * Generic function for discovering OAuth metadata with fallback support\n */\nasync function discoverMetadataWithFallback(\n  serverUrl: string | URL,\n  wellKnownType: 'oauth-authorization-server' | 'oauth-protected-resource',\n  fetchFn: FetchFunction,\n  opts?: {\n    protocolVersion?: string;\n    metadataUrl?: string | URL;\n    metadataServerUrl?: string | URL;\n  },\n): Promise<Response | undefined> {\n  const issuer = new URL(serverUrl);\n  const protocolVersion = opts?.protocolVersion ?? LATEST_PROTOCOL_VERSION;\n\n  let url: URL;\n  if (opts?.metadataUrl) {\n    url = new URL(opts.metadataUrl);\n  } else {\n    const wellKnownPath = buildWellKnownPath(wellKnownType, issuer.pathname);\n    url = new URL(wellKnownPath, opts?.metadataServerUrl ?? issuer);\n    url.search = issuer.search;\n  }\n\n  let response = await tryMetadataDiscovery(url, protocolVersion, fetchFn);\n\n  if (!opts?.metadataUrl && shouldAttemptFallback(response, issuer.pathname)) {\n    const rootUrl = new URL(`/.well-known/${wellKnownType}`, issuer);\n    response = await tryMetadataDiscovery(rootUrl, protocolVersion, fetchFn);\n  }\n\n  return response;\n}\n\nexport async function discoverOAuthProtectedResourceMetadata(\n  serverUrl: string | URL,\n  opts?: { protocolVersion?: string; resourceMetadataUrl?: string | URL },\n  fetchFn: FetchFunction = fetch,\n): Promise<OAuthProtectedResourceMetadata> {\n  const response = await discoverMetadataWithFallback(\n    serverUrl,\n    'oauth-protected-resource',\n    fetchFn,\n    {\n      protocolVersion: opts?.protocolVersion,\n      metadataUrl: opts?.resourceMetadataUrl,\n    },\n  );\n\n  if (!response || response.status === 404) {\n    throw new Error(\n      `Resource server does not implement OAuth 2.0 Protected Resource Metadata.`,\n    );\n  }\n\n  if (!response.ok) {\n    throw new Error(\n      `HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`,\n    );\n  }\n  return OAuthProtectedResourceMetadataSchema.parse(await response.json());\n}\n\n/**\n * Builds a list of discovery URLs to try for authorization server metadata.\n * URLs are returned in priority order:\n * 1. OAuth metadata at the given URL\n * 2. OAuth metadata at root (if URL has path)\n * 3. OIDC metadata endpoints\n */\nexport function buildDiscoveryUrls(\n  authorizationServerUrl: string | URL,\n): { url: URL; type: 'oauth' | 'oidc' }[] {\n  const url =\n    typeof authorizationServerUrl === 'string'\n      ? new URL(authorizationServerUrl)\n      : authorizationServerUrl;\n  const hasPath = url.pathname !== '/';\n  const urlsToTry: { url: URL; type: 'oauth' | 'oidc' }[] = [];\n\n  if (!hasPath) {\n    urlsToTry.push({\n      url: new URL('/.well-known/oauth-authorization-server', url.origin),\n      type: 'oauth',\n    });\n\n    urlsToTry.push({\n      url: new URL('/.well-known/openid-configuration', url.origin),\n      type: 'oidc',\n    });\n\n    return urlsToTry;\n  }\n\n  let pathname = url.pathname;\n  if (pathname.endsWith('/')) {\n    pathname = pathname.slice(0, -1);\n  }\n\n  urlsToTry.push({\n    url: new URL(\n      `/.well-known/oauth-authorization-server${pathname}`,\n      url.origin,\n    ),\n    type: 'oauth',\n  });\n\n  urlsToTry.push({\n    url: new URL('/.well-known/oauth-authorization-server', url.origin),\n    type: 'oauth',\n  });\n\n  urlsToTry.push({\n    url: new URL(`/.well-known/openid-configuration${pathname}`, url.origin),\n    type: 'oidc',\n  });\n\n  urlsToTry.push({\n    url: new URL(`${pathname}/.well-known/openid-configuration`, url.origin),\n    type: 'oidc',\n  });\n\n  return urlsToTry;\n}\n\nexport async function discoverAuthorizationServerMetadata(\n  authorizationServerUrl: string | URL,\n  {\n    fetchFn = fetch,\n    protocolVersion = LATEST_PROTOCOL_VERSION,\n  }: {\n    fetchFn?: FetchFunction;\n    protocolVersion?: string;\n  } = {},\n): Promise<AuthorizationServerMetadata | undefined> {\n  const headers = { 'MCP-Protocol-Version': protocolVersion };\n\n  const urlsToTry = buildDiscoveryUrls(authorizationServerUrl);\n\n  for (const { url: endpointUrl, type } of urlsToTry) {\n    const response = await fetchWithCorsRetry(endpointUrl, headers, fetchFn);\n\n    if (!response) {\n      /**\n       * CORS error occurred - don't throw as the endpoint may not allow CORS,\n       * continue trying other possible endpoints\n       */\n      continue;\n    }\n\n    if (!response.ok) {\n      // Continue looking for any 4xx response code.\n      if (response.status >= 400 && response.status < 500) {\n        continue;\n      }\n      throw new Error(\n        `HTTP ${response.status} trying to load ${type === 'oauth' ? 'OAuth' : 'OpenID provider'} metadata from ${endpointUrl}`,\n      );\n    }\n\n    if (type === 'oauth') {\n      return OAuthMetadataSchema.parse(await response.json());\n    } else {\n      const metadata = OpenIdProviderDiscoveryMetadataSchema.parse(\n        await response.json(),\n      );\n\n      // MCP spec requires OIDC providers to support S256 PKCE\n      if (!metadata.code_challenge_methods_supported?.includes('S256')) {\n        throw new Error(\n          `Incompatible OIDC provider at ${endpointUrl}: does not support S256 code challenge method required by MCP specification`,\n        );\n      }\n\n      return metadata;\n    }\n  }\n\n  return undefined;\n}\n\nexport async function startAuthorization(\n  authorizationServerUrl: string | URL,\n  {\n    metadata,\n    clientInformation,\n    redirectUrl,\n    scope,\n    state,\n    resource,\n  }: {\n    metadata?: AuthorizationServerMetadata;\n    clientInformation: OAuthClientInformation;\n    redirectUrl: string | URL;\n    scope?: string;\n    state?: string;\n    resource?: URL;\n  },\n): Promise<{ authorizationUrl: URL; codeVerifier: string }> {\n  const responseType = 'code';\n  const codeChallengeMethod = 'S256';\n\n  let authorizationUrl: URL;\n  if (metadata) {\n    authorizationUrl = new URL(metadata.authorization_endpoint);\n\n    if (!metadata.response_types_supported.includes(responseType)) {\n      throw new Error(\n        `Incompatible auth server: does not support response type ${responseType}`,\n      );\n    }\n\n    if (\n      !metadata.code_challenge_methods_supported ||\n      !metadata.code_challenge_methods_supported.includes(codeChallengeMethod)\n    ) {\n      throw new Error(\n        `Incompatible auth server: does not support code challenge method ${codeChallengeMethod}`,\n      );\n    }\n  } else {\n    authorizationUrl = new URL('/authorize', authorizationServerUrl);\n  }\n\n  const challenge = await pkceChallenge();\n  const codeVerifier = challenge.code_verifier;\n  const codeChallenge = challenge.code_challenge;\n\n  authorizationUrl.searchParams.set('response_type', responseType);\n  authorizationUrl.searchParams.set('client_id', clientInformation.client_id);\n  authorizationUrl.searchParams.set('code_challenge', codeChallenge);\n  authorizationUrl.searchParams.set(\n    'code_challenge_method',\n    codeChallengeMethod,\n  );\n  authorizationUrl.searchParams.set('redirect_uri', String(redirectUrl));\n\n  if (state) {\n    authorizationUrl.searchParams.set('state', state);\n  }\n\n  if (scope) {\n    authorizationUrl.searchParams.set('scope', scope);\n  }\n\n  if (scope?.includes('offline_access')) {\n    // if the request includes the OIDC-only \"offline_access\" scope,\n    // we need to set the prompt to \"consent\" to ensure the user is prompted to grant offline access\n    // https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess\n    authorizationUrl.searchParams.append('prompt', 'consent');\n  }\n\n  if (resource) {\n    authorizationUrl.searchParams.set('resource', resource.href);\n  }\n\n  return { authorizationUrl, codeVerifier };\n}\n\ntype ClientAuthMethod = 'client_secret_basic' | 'client_secret_post' | 'none';\n\n/**\n * Determines the best client authentication method to use based on server support and client configuration.\n *\n * Priority order (highest to lowest):\n * 1. client_secret_basic (if client secret is available)\n * 2. client_secret_post (if client secret is available)\n * 3. none (for public clients)\n *\n * @param clientInformation - OAuth client information containing credentials\n * @param supportedMethods - Authentication methods supported by the authorization server\n * @returns The selected authentication method\n */\nfunction selectClientAuthMethod(\n  clientInformation: OAuthClientInformation,\n  supportedMethods: string[],\n): ClientAuthMethod {\n  const hasClientSecret = clientInformation.client_secret !== undefined;\n\n  if (supportedMethods.length === 0) {\n    return hasClientSecret ? 'client_secret_post' : 'none';\n  }\n\n  if (hasClientSecret && supportedMethods.includes('client_secret_basic')) {\n    return 'client_secret_basic';\n  }\n\n  if (hasClientSecret && supportedMethods.includes('client_secret_post')) {\n    return 'client_secret_post';\n  }\n\n  if (supportedMethods.includes('none')) {\n    return 'none';\n  }\n\n  return hasClientSecret ? 'client_secret_post' : 'none';\n}\n\n/**\n * Applies client authentication to the request based on the specified method.\n *\n * Implements OAuth 2.1 client authentication methods:\n * - client_secret_basic: HTTP Basic authentication (RFC 6749 Section 2.3.1)\n * - client_secret_post: Credentials in request body (RFC 6749 Section 2.3.1)\n * - none: Public client authentication (RFC 6749 Section 2.1)\n *\n * @param method - The authentication method to use\n * @param clientInformation - OAuth client information containing credentials\n * @param headers - HTTP headers object to modify\n * @param params - URL search parameters to modify\n * @throws {Error} When required credentials are missing\n */\nfunction applyClientAuthentication(\n  method: ClientAuthMethod,\n  clientInformation: OAuthClientInformation,\n  headers: Headers,\n  params: URLSearchParams,\n): void {\n  const { client_id, client_secret } = clientInformation;\n\n  switch (method) {\n    case 'client_secret_basic':\n      applyBasicAuth(client_id, client_secret, headers);\n      return;\n    case 'client_secret_post':\n      applyPostAuth(client_id, client_secret, params);\n      return;\n    case 'none':\n      applyPublicAuth(client_id, params);\n      return;\n    default:\n      throw new Error(`Unsupported client authentication method: ${method}`);\n  }\n}\n\nfunction applyBasicAuth(\n  clientId: string,\n  clientSecret: string | undefined,\n  headers: Headers,\n): void {\n  if (!clientSecret) {\n    throw new Error(\n      'client_secret_basic authentication requires a client_secret',\n    );\n  }\n\n  const credentials = btoa(`${clientId}:${clientSecret}`);\n  headers.set('Authorization', `Basic ${credentials}`);\n}\n\n/**\n * Applies POST body authentication (RFC 6749 Section 2.3.1)\n */\nfunction applyPostAuth(\n  clientId: string,\n  clientSecret: string | undefined,\n  params: URLSearchParams,\n): void {\n  params.set('client_id', clientId);\n  if (clientSecret) {\n    params.set('client_secret', clientSecret);\n  }\n}\n\n/**\n * Applies public client authentication (RFC 6749 Section 2.1)\n */\nfunction applyPublicAuth(clientId: string, params: URLSearchParams): void {\n  params.set('client_id', clientId);\n}\n\n/**\n * Parses an OAuth error response from a string or Response object.\n *\n * If the input is a standard OAuth2.0 error response, it will be parsed according to the spec\n * and an instance of the appropriate OAuthError subclass will be returned.\n * If parsing fails, it falls back to a generic ServerError that includes\n * the response status (if available) and original content.\n *\n * @param input - A Response object or string containing the error response\n * @returns A Promise that resolves to an OAuthError instance\n */\nexport async function parseErrorResponse(\n  input: Response | string,\n): Promise<MCPClientOAuthError> {\n  const statusCode = input instanceof Response ? input.status : undefined;\n  const body = input instanceof Response ? await input.text() : input;\n\n  try {\n    const result = OAuthErrorResponseSchema.parse(JSON.parse(body));\n    const { error, error_description, error_uri } = result;\n    const errorClass = OAUTH_ERRORS[error] || ServerError;\n    return new errorClass({\n      message: error_description || '',\n      cause: error_uri,\n    });\n  } catch (error) {\n    // Not a valid OAuth error response, but try to inform the user of the raw data anyway\n    const errorMessage = `${statusCode ? `HTTP ${statusCode}: ` : ''}Invalid OAuth error response: ${error}. Raw body: ${body}`;\n    return new ServerError({ message: errorMessage });\n  }\n}\n\n/**\n * Exchanges an authorization code for an access token with the given server.\n *\n * Supports multiple client authentication methods as specified in OAuth 2.1:\n * - Automatically selects the best authentication method based on server support\n * - Falls back to appropriate defaults when server metadata is unavailable\n *\n * @param authorizationServerUrl - The authorization server's base URL\n * @param options - Configuration object containing client info, auth code, etc.\n * @returns Promise resolving to OAuth tokens\n * @throws {Error} When token exchange fails or authentication is invalid\n */\nexport async function exchangeAuthorization(\n  authorizationServerUrl: string | URL,\n  {\n    metadata,\n    clientInformation,\n    authorizationCode,\n    codeVerifier,\n    redirectUri,\n    resource,\n    addClientAuthentication,\n    fetchFn,\n  }: {\n    metadata?: AuthorizationServerMetadata;\n    clientInformation: OAuthClientInformation;\n    authorizationCode: string;\n    codeVerifier: string;\n    redirectUri: string | URL;\n    resource?: URL;\n    addClientAuthentication?: OAuthClientProvider['addClientAuthentication'];\n    fetchFn?: FetchFunction;\n  },\n): Promise<OAuthTokens> {\n  const grantType = 'authorization_code';\n\n  const tokenUrl = metadata?.token_endpoint\n    ? new URL(metadata.token_endpoint)\n    : new URL('/token', authorizationServerUrl);\n\n  if (\n    metadata?.grant_types_supported &&\n    !metadata.grant_types_supported.includes(grantType)\n  ) {\n    throw new Error(\n      `Incompatible auth server: does not support grant type ${grantType}`,\n    );\n  }\n\n  const headers = new Headers({\n    'Content-Type': 'application/x-www-form-urlencoded',\n    Accept: 'application/json',\n  });\n  const params = new URLSearchParams({\n    grant_type: grantType,\n    code: authorizationCode,\n    code_verifier: codeVerifier,\n    redirect_uri: String(redirectUri),\n  });\n\n  if (addClientAuthentication) {\n    addClientAuthentication(headers, params, authorizationServerUrl, metadata);\n  } else {\n    const supportedMethods =\n      metadata?.token_endpoint_auth_methods_supported ?? [];\n    const authMethod = selectClientAuthMethod(\n      clientInformation,\n      supportedMethods,\n    );\n\n    applyClientAuthentication(authMethod, clientInformation, headers, params);\n  }\n\n  if (resource) {\n    params.set('resource', resource.href);\n  }\n\n  const response = await (fetchFn ?? fetch)(tokenUrl, {\n    method: 'POST',\n    headers,\n    body: params,\n  });\n\n  if (!response.ok) {\n    throw await parseErrorResponse(response);\n  }\n\n  return OAuthTokensSchema.parse(await response.json());\n}\n\n/**\n * Exchange a refresh token for an updated access token.\n *\n * Supports multiple client authentication methods as specified in OAuth 2.1:\n * - Automatically selects the best authentication method based on server support\n * - Preserves the original refresh token if a new one is not returned\n *\n * @param authorizationServerUrl - The authorization server's base URL\n * @param options - Configuration object containing client info, refresh token, etc.\n * @returns Promise resolving to OAuth tokens (preserves original refresh_token if not replaced)\n * @throws {Error} When token refresh fails or authentication is invalid\n */\nexport async function refreshAuthorization(\n  authorizationServerUrl: string | URL,\n  {\n    metadata,\n    clientInformation,\n    refreshToken,\n    resource,\n    addClientAuthentication,\n    fetchFn,\n  }: {\n    metadata?: AuthorizationServerMetadata;\n    clientInformation: OAuthClientInformation;\n    refreshToken: string;\n    resource?: URL;\n    addClientAuthentication?: OAuthClientProvider['addClientAuthentication'];\n    fetchFn?: FetchFunction;\n  },\n): Promise<OAuthTokens> {\n  const grantType = 'refresh_token';\n\n  let tokenUrl: URL;\n  if (metadata) {\n    tokenUrl = new URL(metadata.token_endpoint);\n\n    if (\n      metadata.grant_types_supported &&\n      !metadata.grant_types_supported.includes(grantType)\n    ) {\n      throw new Error(\n        `Incompatible auth server: does not support grant type ${grantType}`,\n      );\n    }\n  } else {\n    tokenUrl = new URL('/token', authorizationServerUrl);\n  }\n\n  const headers = new Headers({\n    'Content-Type': 'application/x-www-form-urlencoded',\n  });\n  const params = new URLSearchParams({\n    grant_type: grantType,\n    refresh_token: refreshToken,\n  });\n\n  if (addClientAuthentication) {\n    addClientAuthentication(headers, params, authorizationServerUrl, metadata);\n  } else {\n    const supportedMethods =\n      metadata?.token_endpoint_auth_methods_supported ?? [];\n    const authMethod = selectClientAuthMethod(\n      clientInformation,\n      supportedMethods,\n    );\n\n    applyClientAuthentication(authMethod, clientInformation, headers, params);\n  }\n\n  if (resource) {\n    params.set('resource', resource.href);\n  }\n\n  const response = await (fetchFn ?? fetch)(tokenUrl, {\n    method: 'POST',\n    headers,\n    body: params,\n  });\n  if (!response.ok) {\n    throw await parseErrorResponse(response);\n  }\n\n  return OAuthTokensSchema.parse({\n    refresh_token: refreshToken,\n    ...(await response.json()),\n  });\n}\n\n/**\n * Performs OAuth 2.0 Dynamic Client Registration according to RFC 7591.\n */\nexport async function registerClient(\n  authorizationServerUrl: string | URL,\n  {\n    metadata,\n    clientMetadata,\n    fetchFn,\n  }: {\n    metadata?: AuthorizationServerMetadata;\n    clientMetadata: OAuthClientMetadata;\n    fetchFn?: FetchFunction;\n  },\n): Promise<OAuthClientInformationFull> {\n  let registrationUrl: URL;\n\n  if (metadata) {\n    if (!metadata.registration_endpoint) {\n      throw new Error(\n        'Incompatible auth server: does not support dynamic client registration',\n      );\n    }\n\n    registrationUrl = new URL(metadata.registration_endpoint);\n  } else {\n    registrationUrl = new URL('/register', authorizationServerUrl);\n  }\n\n  const response = await (fetchFn ?? fetch)(registrationUrl, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n    },\n    body: JSON.stringify(clientMetadata),\n  });\n\n  if (!response.ok) {\n    throw await parseErrorResponse(response);\n  }\n\n  return OAuthClientInformationFullSchema.parse(await response.json());\n}\n\nexport async function auth(\n  provider: OAuthClientProvider,\n  options: {\n    serverUrl: string | URL;\n    authorizationCode?: string;\n    scope?: string;\n    resourceMetadataUrl?: URL;\n    fetchFn?: FetchFunction;\n  },\n): Promise<AuthResult> {\n  try {\n    return await authInternal(provider, options);\n  } catch (error) {\n    if (\n      error instanceof InvalidClientError ||\n      error instanceof UnauthorizedClientError\n    ) {\n      await provider.invalidateCredentials?.('all');\n      return await authInternal(provider, options);\n    } else if (error instanceof InvalidGrantError) {\n      await provider.invalidateCredentials?.('tokens');\n      return await authInternal(provider, options);\n    }\n\n    throw error;\n  }\n}\n\nexport async function selectResourceURL(\n  serverUrl: string | URL,\n  provider: OAuthClientProvider,\n  resourceMetadata?: OAuthProtectedResourceMetadata,\n): Promise<URL | undefined> {\n  const defaultResource = resourceUrlFromServerUrl(serverUrl);\n\n  if (provider.validateResourceURL) {\n    return await provider.validateResourceURL(\n      defaultResource,\n      resourceMetadata?.resource,\n    );\n  }\n\n  if (!resourceMetadata) {\n    return undefined;\n  }\n\n  if (\n    !checkResourceAllowed({\n      requestedResource: defaultResource,\n      configuredResource: resourceMetadata.resource,\n    })\n  ) {\n    throw new Error(\n      `Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`,\n    );\n  }\n  return new URL(resourceMetadata.resource);\n}\n\nasync function authInternal(\n  provider: OAuthClientProvider,\n  {\n    serverUrl,\n    authorizationCode,\n    scope,\n    resourceMetadataUrl,\n    fetchFn,\n  }: {\n    serverUrl: string | URL;\n    authorizationCode?: string;\n    scope?: string;\n    resourceMetadataUrl?: URL;\n    fetchFn?: FetchFunction;\n  },\n): Promise<AuthResult> {\n  let resourceMetadata: OAuthProtectedResourceMetadata | undefined;\n  let authorizationServerUrl: string | URL | undefined;\n  try {\n    resourceMetadata = await discoverOAuthProtectedResourceMetadata(\n      serverUrl,\n      { resourceMetadataUrl },\n      fetchFn,\n    );\n    if (\n      resourceMetadata.authorization_servers &&\n      resourceMetadata.authorization_servers.length > 0\n    ) {\n      authorizationServerUrl = resourceMetadata.authorization_servers[0];\n    }\n  } catch {}\n\n  /**\n   * If we don't get a valid authorization server metadata from protected resource metadata,\n   * fallback to the legacy MCP spec's implementation (version 2025-03-26): MCP server acts as the Authorization server.\n   */\n  if (!authorizationServerUrl) {\n    authorizationServerUrl = serverUrl;\n  }\n\n  const resource: URL | undefined = await selectResourceURL(\n    serverUrl,\n    provider,\n    resourceMetadata,\n  );\n\n  const metadata = await discoverAuthorizationServerMetadata(\n    authorizationServerUrl,\n    {\n      fetchFn,\n    },\n  );\n\n  let clientInformation = await Promise.resolve(provider.clientInformation());\n  if (!clientInformation) {\n    if (authorizationCode !== undefined) {\n      throw new Error(\n        'Existing OAuth client information is required when exchanging an authorization code',\n      );\n    }\n\n    if (!provider.saveClientInformation) {\n      throw new Error(\n        'OAuth client information must be saveable for dynamic registration',\n      );\n    }\n\n    const fullInformation = await registerClient(authorizationServerUrl, {\n      metadata,\n      clientMetadata: provider.clientMetadata,\n      fetchFn,\n    });\n\n    await provider.saveClientInformation(fullInformation);\n    clientInformation = fullInformation;\n  }\n\n  // Exchange authorization code for tokens\n  if (authorizationCode !== undefined) {\n    const codeVerifier = await provider.codeVerifier();\n    const tokens = await exchangeAuthorization(authorizationServerUrl, {\n      metadata,\n      clientInformation,\n      authorizationCode,\n      codeVerifier,\n      redirectUri: provider.redirectUrl,\n      resource,\n      addClientAuthentication: provider.addClientAuthentication,\n      fetchFn: fetchFn,\n    });\n\n    await provider.saveTokens(tokens);\n    return 'AUTHORIZED';\n  }\n\n  const tokens = await provider.tokens();\n\n  // Handle token refresh or new authorization\n  if (tokens?.refresh_token) {\n    try {\n      // Attempt to refresh the token\n      const newTokens = await refreshAuthorization(authorizationServerUrl, {\n        metadata,\n        clientInformation,\n        refreshToken: tokens.refresh_token,\n        resource,\n        addClientAuthentication: provider.addClientAuthentication,\n        fetchFn,\n      });\n\n      await provider.saveTokens(newTokens);\n      return 'AUTHORIZED';\n    } catch (error) {\n      if (\n        // If this is a ServerError, or an unknown type, log it out and try to continue. Otherwise, escalate so we can fix things and retry.\n        !(error instanceof MCPClientOAuthError) ||\n        error instanceof ServerError\n      ) {\n        // Could not refresh OAuth tokens\n      } else {\n        // Refresh failed for another reason, re-throw\n        throw error;\n      }\n    }\n  }\n\n  const state = provider.state ? await provider.state() : undefined;\n\n  // Start new authorization flow\n  const { authorizationUrl, codeVerifier } = await startAuthorization(\n    authorizationServerUrl,\n    {\n      metadata,\n      clientInformation,\n      state,\n      redirectUrl: provider.redirectUrl,\n      scope: scope || provider.clientMetadata.scope,\n      resource,\n    },\n  );\n\n  await provider.saveCodeVerifier(codeVerifier);\n  await provider.redirectToAuthorization(authorizationUrl);\n  return 'REDIRECT';\n}\n","import { z } from 'zod/v4';\n/**\n * OAuth 2.1 token response\n */\nexport const OAuthTokensSchema = z\n  .object({\n    access_token: z.string(),\n    id_token: z.string().optional(), // Optional for OAuth 2.1, but necessary in OpenID Connect\n    token_type: z.string(),\n    expires_in: z.number().optional(),\n    scope: z.string().optional(),\n    refresh_token: z.string().optional(),\n  })\n  .strip();\n\n/**\n * Reusable URL validation that disallows javascript: scheme\n */\nexport const SafeUrlSchema = z\n  .string()\n  .url()\n  .superRefine((val, ctx) => {\n    if (!URL.canParse(val)) {\n      ctx.addIssue({\n        code: z.ZodIssueCode.custom,\n        message: 'URL must be parseable',\n        fatal: true,\n      });\n\n      return z.NEVER;\n    }\n  })\n  .refine(\n    url => {\n      const u = new URL(url);\n      return (\n        u.protocol !== 'javascript:' &&\n        u.protocol !== 'data:' &&\n        u.protocol !== 'vbscript:'\n      );\n    },\n    { message: 'URL cannot use javascript:, data:, or vbscript: scheme' },\n  );\n\nexport const OAuthProtectedResourceMetadataSchema = z\n  .object({\n    resource: z.string().url(),\n    authorization_servers: z.array(SafeUrlSchema).optional(),\n    jwks_uri: z.string().url().optional(),\n    scopes_supported: z.array(z.string()).optional(),\n    bearer_methods_supported: z.array(z.string()).optional(),\n    resource_signing_alg_values_supported: z.array(z.string()).optional(),\n    resource_name: z.string().optional(),\n    resource_documentation: z.string().optional(),\n    resource_policy_uri: z.string().url().optional(),\n    resource_tos_uri: z.string().url().optional(),\n    tls_client_certificate_bound_access_tokens: z.boolean().optional(),\n    authorization_details_types_supported: z.array(z.string()).optional(),\n    dpop_signing_alg_values_supported: z.array(z.string()).optional(),\n    dpop_bound_access_tokens_required: z.boolean().optional(),\n  })\n  .passthrough();\n\nexport const OAuthMetadataSchema = z\n  .object({\n    issuer: z.string(),\n    authorization_endpoint: SafeUrlSchema,\n    token_endpoint: SafeUrlSchema,\n    registration_endpoint: SafeUrlSchema.optional(),\n    scopes_supported: z.array(z.string()).optional(),\n    response_types_supported: z.array(z.string()),\n    grant_types_supported: z.array(z.string()).optional(),\n    code_challenge_methods_supported: z.array(z.string()),\n    token_endpoint_auth_methods_supported: z.array(z.string()).optional(),\n    token_endpoint_auth_signing_alg_values_supported: z\n      .array(z.string())\n      .optional(),\n  })\n  .passthrough();\n\n/**\n * OpenID Connect Discovery 1.0 Provider Metadata\n * see: https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata\n */\nexport const OpenIdProviderMetadataSchema = z\n  .object({\n    issuer: z.string(),\n    authorization_endpoint: SafeUrlSchema,\n    token_endpoint: SafeUrlSchema,\n    userinfo_endpoint: SafeUrlSchema.optional(),\n    jwks_uri: SafeUrlSchema,\n    registration_endpoint: SafeUrlSchema.optional(),\n    scopes_supported: z.array(z.string()).optional(),\n    response_types_supported: z.array(z.string()),\n    grant_types_supported: z.array(z.string()).optional(),\n    subject_types_supported: z.array(z.string()),\n    id_token_signing_alg_values_supported: z.array(z.string()),\n    claims_supported: z.array(z.string()).optional(),\n    token_endpoint_auth_methods_supported: z.array(z.string()).optional(),\n  })\n  .passthrough();\n\n/**\n * OpenID Connect Discovery metadata that may include OAuth 2.0 fields\n * This schema represents the real-world scenario where OIDC providers\n * return a mix of OpenID Connect and OAuth 2.0 metadata fields\n */\nexport const OpenIdProviderDiscoveryMetadataSchema =\n  OpenIdProviderMetadataSchema.merge(\n    OAuthMetadataSchema.pick({\n      code_challenge_methods_supported: true,\n    }),\n  );\n\nexport const OAuthClientInformationSchema = z\n  .object({\n    client_id: z.string(),\n    client_secret: z.string().optional(),\n    client_id_issued_at: z.number().optional(),\n    client_secret_expires_at: z.number().optional(),\n  })\n  .strip();\n\nexport const OAuthClientMetadataSchema = z\n  .object({\n    redirect_uris: z.array(SafeUrlSchema),\n    token_endpoint_auth_method: z.string().optional(),\n    grant_types: z.array(z.string()).optional(),\n    response_types: z.array(z.string()).optional(),\n    client_name: z.string().optional(),\n    client_uri: SafeUrlSchema.optional(),\n    logo_uri: SafeUrlSchema.optional(),\n    scope: z.string().optional(),\n    contacts: z.array(z.string()).optional(),\n    tos_uri: SafeUrlSchema.optional(),\n    policy_uri: z.string().optional(),\n    jwks_uri: SafeUrlSchema.optional(),\n    jwks: z.any().optional(),\n    software_id: z.string().optional(),\n    software_version: z.string().optional(),\n    software_statement: z.string().optional(),\n  })\n  .strip();\n\nexport type OAuthMetadata = z.infer<typeof OAuthMetadataSchema>;\nexport type OpenIdProviderDiscoveryMetadata = z.infer<\n  typeof OpenIdProviderDiscoveryMetadataSchema\n>;\nexport type OAuthTokens = z.infer<typeof OAuthTokensSchema>;\nexport type OAuthProtectedResourceMetadata = z.infer<\n  typeof OAuthProtectedResourceMetadataSchema\n>;\nexport type OAuthClientInformation = z.infer<\n  typeof OAuthClientInformationSchema\n>;\nexport type AuthorizationServerMetadata =\n  | OAuthMetadata\n  | OpenIdProviderDiscoveryMetadata;\n\nexport const OAuthErrorResponseSchema = z.object({\n  error: z.string(),\n  error_description: z.string().optional(),\n  error_uri: z.string().optional(),\n});\nexport const OAuthClientInformationFullSchema = OAuthClientMetadataSchema.merge(\n  OAuthClientInformationSchema,\n);\nexport type OAuthClientMetadata = z.infer<typeof OAuthClientMetadataSchema>;\nexport type OAuthClientInformationFull = z.infer<\n  typeof OAuthClientInformationFullSchema\n>;\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_MCPClientOAuthError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\n * An error occurred with the MCP client within the OAuth flow.\n */\nexport class MCPClientOAuthError extends AISDKError {\n  private readonly [symbol] = true;\n\n  constructor({\n    name = 'MCPClientOAuthError',\n    message,\n    cause,\n  }: {\n    name?: string;\n    message: string;\n    cause?: unknown;\n  }) {\n    super({ name, message, cause });\n  }\n\n  static isInstance(error: unknown): error is MCPClientOAuthError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\nexport class ServerError extends MCPClientOAuthError {\n  static errorCode = 'server_error';\n}\n\nexport class InvalidClientError extends MCPClientOAuthError {\n  static errorCode = 'invalid_client';\n}\n\nexport class InvalidGrantError extends MCPClientOAuthError {\n  static errorCode = 'invalid_grant';\n}\n\nexport class UnauthorizedClientError extends MCPClientOAuthError {\n  static errorCode = 'unauthorized_client';\n}\n\nexport const OAUTH_ERRORS = {\n  [ServerError.errorCode]: ServerError,\n  [InvalidClientError.errorCode]: InvalidClientError,\n  [InvalidGrantError.errorCode]: InvalidGrantError,\n  [UnauthorizedClientError.errorCode]: UnauthorizedClientError,\n};\n","/**\n * Utilities for handling OAuth resource URIs.\n */\n\n/**\n * Converts a server URL to a resource URL by removing the fragment.\n * RFC 8707 section 2 states that resource URIs \"MUST NOT include a fragment component\".\n * Keeps everything else unchanged (scheme, domain, port, path, query).\n */\nexport function resourceUrlFromServerUrl(url: URL | string): URL {\n  const resourceURL =\n    typeof url === 'string' ? new URL(url) : new URL(url.href);\n  resourceURL.hash = ''; // Remove fragment\n  return resourceURL;\n}\n\n/**\n * Checks if a requested resource URL matches a configured resource URL.\n * A requested resource matches if it has the same scheme, domain, port,\n * and its path starts with the configured resource's path.\n *\n * @param requestedResource The resource URL being requested\n * @param configuredResource The resource URL that has been configured\n * @returns true if the requested resource matches the configured resource, false otherwise\n */\nexport function checkResourceAllowed({\n  requestedResource,\n  configuredResource,\n}: {\n  requestedResource: URL | string;\n  configuredResource: URL | string;\n}): boolean {\n  const requested =\n    typeof requestedResource === 'string'\n      ? new URL(requestedResource)\n      : new URL(requestedResource.href);\n  const configured =\n    typeof configuredResource === 'string'\n      ? new URL(configuredResource)\n      : new URL(configuredResource.href);\n\n  // Compare the origin (scheme, domain, and port)\n  if (requested.origin !== configured.origin) {\n    return false;\n  }\n\n  // Handle cases like requested=/foo and configured=/foo/\n  if (requested.pathname.length < configured.pathname.length) {\n    return false;\n  }\n\n  // Check if the requested path starts with the configured path\n  // Ensure both paths end with / for proper comparison\n  // This ensures that if we have paths like \"/api\" and \"/api/users\",\n  // we properly detect that \"/api/users\" is a subpath of \"/api\"\n  // By adding a trailing slash if missing, we avoid false positives\n  // where paths like \"/api123\" would incorrectly match \"/api\"\n  const requestedPath = requested.pathname.endsWith('/')\n    ? requested.pathname\n    : requested.pathname + '/';\n  const configuredPath = configured.pathname.endsWith('/')\n    ? configured.pathname\n    : configured.pathname + '/';\n\n  return requestedPath.startsWith(configuredPath);\n}\n","import {\n  EventSourceParserStream,\n  withUserAgentSuffix,\n  getRuntimeEnvironmentUserAgent,\n} from '@ai-sdk/provider-utils';\nimport { MCPClientError } from '../error/mcp-client-error';\nimport { JSONRPCMessage, JSONRPCMessageSchema } from './json-rpc-message';\nimport { MCPTransport } from './mcp-transport';\nimport { VERSION } from '../version';\nimport {\n  OAuthClientProvider,\n  extractResourceMetadataUrl,\n  UnauthorizedError,\n  auth,\n} from './oauth';\nimport { LATEST_PROTOCOL_VERSION } from './types';\n\n/**\n * HTTP MCP transport implementing the Streamable HTTP style.\n *\n * Client transport for Streamable HTTP: this implements the MCP Streamable HTTP transport specification.\n * It will connect to a server using HTTP POST for sending messages and HTTP GET with Server-Sent Events\n * for receiving messages.\n */\nexport class HttpMCPTransport implements MCPTransport {\n  private url: URL;\n  private abortController?: AbortController;\n  private headers?: Record<string, string>;\n  private authProvider?: OAuthClientProvider;\n  private resourceMetadataUrl?: URL;\n  private sessionId?: string;\n  private inboundSseConnection?: { close: () => void };\n\n  // Inbound SSE resumption and reconnection state\n  private lastInboundEventId?: string;\n  private inboundReconnectAttempts = 0;\n  private readonly reconnectionOptions = {\n    initialReconnectionDelay: 1000,\n    maxReconnectionDelay: 30000,\n    reconnectionDelayGrowFactor: 1.5,\n    maxRetries: 2,\n  } as const;\n\n  onclose?: () => void;\n  onerror?: (error: unknown) => void;\n  onmessage?: (message: JSONRPCMessage) => void;\n\n  constructor({\n    url,\n    headers,\n    authProvider,\n  }: {\n    url: string;\n    headers?: Record<string, string>;\n    authProvider?: OAuthClientProvider;\n  }) {\n    this.url = new URL(url);\n    this.headers = headers;\n    this.authProvider = authProvider;\n  }\n\n  private async commonHeaders(\n    base: Record<string, string>,\n  ): Promise<Record<string, string>> {\n    const headers: Record<string, string> = {\n      ...this.headers,\n      ...base,\n      'mcp-protocol-version': LATEST_PROTOCOL_VERSION,\n    };\n\n    if (this.sessionId) {\n      headers['mcp-session-id'] = this.sessionId;\n    }\n\n    if (this.authProvider) {\n      const tokens = await this.authProvider.tokens();\n      if (tokens?.access_token) {\n        headers['Authorization'] = `Bearer ${tokens.access_token}`;\n      }\n    }\n\n    return withUserAgentSuffix(\n      headers,\n      `ai-sdk/${VERSION}`,\n      getRuntimeEnvironmentUserAgent(),\n    );\n  }\n\n  async start(): Promise<void> {\n    if (this.abortController) {\n      throw new MCPClientError({\n        message:\n          'MCP HTTP Transport Error: Transport already started. Note: client.connect() calls start() automatically.',\n      });\n    }\n    this.abortController = new AbortController();\n\n    void this.openInboundSse();\n  }\n\n  async close(): Promise<void> {\n    this.inboundSseConnection?.close();\n    try {\n      if (\n        this.sessionId &&\n        this.abortController &&\n        !this.abortController.signal.aborted\n      ) {\n        const headers = await this.commonHeaders({});\n        await fetch(this.url, {\n          method: 'DELETE',\n          headers,\n          signal: this.abortController.signal,\n        }).catch(() => undefined);\n      }\n    } catch {}\n\n    this.abortController?.abort();\n    this.onclose?.();\n  }\n\n  async send(message: JSONRPCMessage): Promise<void> {\n    const attempt = async (triedAuth: boolean = false): Promise<void> => {\n      try {\n        const headers = await this.commonHeaders({\n          'Content-Type': 'application/json',\n          Accept: 'application/json, text/event-stream',\n        });\n\n        const init = {\n          method: 'POST',\n          headers,\n          body: JSON.stringify(message),\n          signal: this.abortController?.signal,\n        } satisfies RequestInit;\n\n        const response = await fetch(this.url, init);\n\n        const sessionId = response.headers.get('mcp-session-id');\n        if (sessionId) {\n          this.sessionId = sessionId;\n        }\n\n        if (response.status === 401 && this.authProvider && !triedAuth) {\n          this.resourceMetadataUrl = extractResourceMetadataUrl(response);\n          try {\n            const result = await auth(this.authProvider, {\n              serverUrl: this.url,\n              resourceMetadataUrl: this.resourceMetadataUrl,\n            });\n            if (result !== 'AUTHORIZED') {\n              const error = new UnauthorizedError();\n              throw error;\n            }\n          } catch (error) {\n            this.onerror?.(error);\n            throw error;\n          }\n          return attempt(true);\n        }\n\n        // If server accepted the message (e.g. initialized notification), optionally (re)start inbound SSE\n        if (response.status === 202) {\n          // If inbound SSE was not available earlier (e.g. 405 before init), try again now\n          // Do not await to avoid blocking send()\n          if (!this.inboundSseConnection) {\n            void this.openInboundSse();\n          }\n          return;\n        }\n\n        if (!response.ok) {\n          const text = await response.text().catch(() => null);\n          let errorMessage = `MCP HTTP Transport Error: POSTing to endpoint (HTTP ${response.status}): ${text}`;\n\n          // 404 since this is a GET request which the server does not support\n          if (response.status === 404) {\n            errorMessage +=\n              '. This server does not support HTTP transport. Try using `sse` transport instead';\n          }\n\n          const error = new MCPClientError({\n            message: errorMessage,\n          });\n          this.onerror?.(error);\n          throw error;\n        }\n\n        const contentType = response.headers.get('content-type') || '';\n        if (contentType.includes('application/json')) {\n          const data = await response.json();\n          const messages: JSONRPCMessage[] = Array.isArray(data)\n            ? data.map((m: unknown) => JSONRPCMessageSchema.parse(m))\n            : [JSONRPCMessageSchema.parse(data)];\n          for (const m of messages) this.onmessage?.(m);\n          return;\n        }\n\n        if (contentType.includes('text/event-stream')) {\n          if (!response.body) {\n            const error = new MCPClientError({\n              message:\n                'MCP HTTP Transport Error: text/event-stream response without body',\n            });\n            this.onerror?.(error);\n            throw error;\n          }\n\n          const stream = response.body\n            .pipeThrough(new TextDecoderStream())\n            .pipeThrough(new EventSourceParserStream());\n          const reader = stream.getReader();\n\n          const processEvents = async () => {\n            try {\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done) return;\n                const { event, data } = value;\n                if (event === 'message') {\n                  try {\n                    const msg = JSONRPCMessageSchema.parse(JSON.parse(data));\n                    this.onmessage?.(msg);\n                  } catch (error) {\n                    const e = new MCPClientError({\n                      message:\n                        'MCP HTTP Transport Error: Failed to parse message',\n                      cause: error,\n                    });\n                    this.onerror?.(e);\n                  }\n                }\n              }\n            } catch (error) {\n              if (error instanceof Error && error.name === 'AbortError') {\n                return;\n              }\n              this.onerror?.(error);\n            }\n          };\n\n          processEvents();\n          return;\n        }\n\n        const error = new MCPClientError({\n          message: `MCP HTTP Transport Error: Unexpected content type: ${contentType}`,\n        });\n        this.onerror?.(error);\n        throw error;\n      } catch (error) {\n        this.onerror?.(error);\n        throw error;\n      }\n    };\n\n    await attempt();\n  }\n\n  private getNextReconnectionDelay(attempt: number): number {\n    const {\n      initialReconnectionDelay,\n      reconnectionDelayGrowFactor,\n      maxReconnectionDelay,\n    } = this.reconnectionOptions;\n    return Math.min(\n      initialReconnectionDelay * Math.pow(reconnectionDelayGrowFactor, attempt),\n      maxReconnectionDelay,\n    );\n  }\n\n  private scheduleInboundSseReconnection(): void {\n    const { maxRetries } = this.reconnectionOptions;\n    if (maxRetries > 0 && this.inboundReconnectAttempts >= maxRetries) {\n      this.onerror?.(\n        new MCPClientError({\n          message: `MCP HTTP Transport Error: Maximum reconnection attempts (${maxRetries}) exceeded.`,\n        }),\n      );\n      return;\n    }\n\n    const delay = this.getNextReconnectionDelay(this.inboundReconnectAttempts);\n    this.inboundReconnectAttempts += 1;\n    setTimeout(async () => {\n      if (this.abortController?.signal.aborted) return;\n      await this.openInboundSse(false, this.lastInboundEventId);\n    }, delay);\n  }\n\n  // Open optional inbound SSE stream; best-effort and resumable\n  private async openInboundSse(\n    triedAuth: boolean = false,\n    resumeToken?: string,\n  ): Promise<void> {\n    try {\n      const headers = await this.commonHeaders({\n        Accept: 'text/event-stream',\n      });\n      if (resumeToken) {\n        headers['last-event-id'] = resumeToken;\n      }\n\n      const response = await fetch(this.url.href, {\n        method: 'GET',\n        headers,\n        signal: this.abortController?.signal,\n      });\n\n      const sessionId = response.headers.get('mcp-session-id');\n      if (sessionId) {\n        this.sessionId = sessionId;\n      }\n\n      if (response.status === 401 && this.authProvider && !triedAuth) {\n        this.resourceMetadataUrl = extractResourceMetadataUrl(response);\n        try {\n          const result = await auth(this.authProvider, {\n            serverUrl: this.url,\n            resourceMetadataUrl: this.resourceMetadataUrl,\n          });\n          if (result !== 'AUTHORIZED') {\n            const error = new UnauthorizedError();\n            this.onerror?.(error);\n            return;\n          }\n        } catch (error) {\n          this.onerror?.(error);\n          return;\n        }\n        return this.openInboundSse(true, resumeToken);\n      }\n\n      if (response.status === 405) {\n        return;\n      }\n\n      if (!response.ok || !response.body) {\n        const error = new MCPClientError({\n          message: `MCP HTTP Transport Error: GET SSE failed: ${response.status} ${response.statusText}`,\n        });\n        this.onerror?.(error);\n        return;\n      }\n\n      const stream = response.body\n        .pipeThrough(new TextDecoderStream())\n        .pipeThrough(new EventSourceParserStream());\n      const reader = stream.getReader();\n\n      const processEvents = async () => {\n        try {\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) return;\n            const { event, data, id } = value as {\n              event?: string;\n              data: string;\n              id?: string;\n            };\n\n            if (id) {\n              this.lastInboundEventId = id;\n            }\n\n            if (event === 'message') {\n              try {\n                const msg = JSONRPCMessageSchema.parse(JSON.parse(data));\n                this.onmessage?.(msg);\n              } catch (error) {\n                const e = new MCPClientError({\n                  message: 'MCP HTTP Transport Error: Failed to parse message',\n                  cause: error,\n                });\n                this.onerror?.(e);\n              }\n            }\n          }\n        } catch (error) {\n          if (error instanceof Error && error.name === 'AbortError') {\n            return;\n          }\n          this.onerror?.(error);\n          if (!this.abortController?.signal.aborted) {\n            this.scheduleInboundSseReconnection();\n          }\n        }\n      };\n\n      this.inboundSseConnection = {\n        close: () => reader.cancel(),\n      };\n      this.inboundReconnectAttempts = 0;\n      processEvents();\n    } catch (error) {\n      if (error instanceof Error && error.name === 'AbortError') {\n        return;\n      }\n      this.onerror?.(error);\n      if (!this.abortController?.signal.aborted) {\n        this.scheduleInboundSseReconnection();\n      }\n    }\n  }\n}\n","import { MCPClientError } from '../error/mcp-client-error';\nimport { JSONRPCMessage } from './json-rpc-message';\nimport { SseMCPTransport } from './mcp-sse-transport';\nimport { HttpMCPTransport } from './mcp-http-transport';\nimport { OAuthClientProvider } from './oauth';\n\n/**\n * Transport interface for MCP (Model Context Protocol) communication.\n * Maps to the `Transport` interface in the MCP spec.\n */\nexport interface MCPTransport {\n  /**\n   * Initialize and start the transport\n   */\n  start(): Promise<void>;\n\n  /**\n   * Send a JSON-RPC message through the transport\n   * @param message The JSON-RPC message to send\n   */\n  send(message: JSONRPCMessage): Promise<void>;\n\n  /**\n   * Clean up and close the transport\n   */\n  close(): Promise<void>;\n\n  /**\n   * Event handler for transport closure\n   */\n  onclose?: () => void;\n\n  /**\n   * Event handler for transport errors\n   */\n  onerror?: (error: Error) => void;\n\n  /**\n   * Event handler for received messages\n   */\n  onmessage?: (message: JSONRPCMessage) => void;\n}\n\nexport type MCPTransportConfig = {\n  type: 'sse' | 'http';\n\n  /**\n   * The URL of the MCP server.\n   */\n  url: string;\n\n  /**\n   * Additional HTTP headers to be sent with requests.\n   */\n  headers?: Record<string, string>;\n\n  /**\n   * An optional OAuth client provider to use for authentication for MCP servers.\n   */\n  authProvider?: OAuthClientProvider;\n};\n\nexport function createMcpTransport(config: MCPTransportConfig): MCPTransport {\n  switch (config.type) {\n    case 'sse':\n      return new SseMCPTransport(config);\n    case 'http':\n      return new HttpMCPTransport(config);\n    default:\n      throw new MCPClientError({\n        message:\n          'Unsupported or invalid transport configuration. If you are using a custom transport, make sure it implements the MCPTransport interface.',\n      });\n  }\n}\n\nexport function isCustomMcpTransport(\n  transport: MCPTransportConfig | MCPTransport,\n): transport is MCPTransport {\n  return (\n    'start' in transport &&\n    typeof transport.start === 'function' &&\n    'send' in transport &&\n    typeof transport.send === 'function' &&\n    'close' in transport &&\n    typeof transport.close === 'function'\n  );\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACCA,IAAAA,yBAMO;;;ACPP,sBAA2B;AAE3B,IAAM,OAAO;AACb,IAAM,SAAS,mBAAmB,IAAI;AACtC,IAAM,SAAS,OAAO,IAAI,MAAM;AAJhC;AASO,IAAM,iBAAN,eAA6B,iCAChB,aADgB,IAAW;AAAA,EAK7C,YAAY;AAAA,IACV,MAAAC,QAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAMG;AACD,UAAM,EAAE,MAAAA,OAAM,SAAS,MAAM,CAAC;AAjBhC,SAAkB,MAAU;AAkB1B,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA,EACd;AAAA,EAEA,OAAO,WAAW,OAAyC;AACzD,WAAO,2BAAW,UAAU,OAAO,MAAM;AAAA,EAC3C;AACF;;;ACnCA,4BAIO;;;ACJP,IAAAC,aAAkB;;;ACAlB,gBAAkB;AAIX,IAAM,0BAA0B;AAChC,IAAM,8BAA8B;AAAA,EACzC;AAAA,EACA;AAAA,EACA;AACF;AAmBA,IAAM,qCAAqC,YAAE,YAAY;AAAA,EACvD,MAAM,YAAE,OAAO;AAAA,EACf,SAAS,YAAE,OAAO;AACpB,CAAC;AAIM,IAAM,mBAAmB,YAAE,YAAY;AAAA,EAC5C,OAAO,YAAE,SAAS,YAAE,OAAO,CAAC,CAAC,EAAE,MAAM,CAAC;AACxC,CAAC;AAEM,IAAM,eAAe;AAErB,IAAM,gBAAgB,YAAE,OAAO;AAAA,EACpC,QAAQ,YAAE,OAAO;AAAA,EACjB,QAAQ,YAAE,SAAS,gBAAgB;AACrC,CAAC;AAUD,IAAM,2BAA2B,YAAE,YAAY;AAAA,EAC7C,cAAc,YAAE,SAAS,YAAE,OAAO,CAAC,CAAC,EAAE,MAAM,CAAC;AAAA,EAC7C,SAAS,YAAE,SAAS,YAAE,OAAO,CAAC,CAAC,EAAE,MAAM,CAAC;AAAA,EACxC,SAAS,YAAE;AAAA,IACT,YAAE,YAAY;AAAA,MACZ,aAAa,YAAE,SAAS,YAAE,QAAQ,CAAC;AAAA,IACrC,CAAC;AAAA,EACH;AAAA,EACA,WAAW,YAAE;AAAA,IACX,YAAE,YAAY;AAAA,MACZ,WAAW,YAAE,SAAS,YAAE,QAAQ,CAAC;AAAA,MACjC,aAAa,YAAE,SAAS,YAAE,QAAQ,CAAC;AAAA,IACrC,CAAC;AAAA,EACH;AAAA,EACA,OAAO,YAAE;AAAA,IACP,YAAE,YAAY;AAAA,MACZ,aAAa,YAAE,SAAS,YAAE,QAAQ,CAAC;AAAA,IACrC,CAAC;AAAA,EACH;AACF,CAAC;AAIM,IAAM,yBAAyB,aAAa,OAAO;AAAA,EACxD,iBAAiB,YAAE,OAAO;AAAA,EAC1B,cAAc;AAAA,EACd,YAAY;AAAA,EACZ,cAAc,YAAE,SAAS,YAAE,OAAO,CAAC;AACrC,CAAC;AASD,IAAM,wBAAwB,aAAa,OAAO;AAAA,EAChD,YAAY,YAAE,SAAS,YAAE,OAAO,CAAC;AACnC,CAAC;AAED,IAAM,aAAa,YAChB,OAAO;AAAA,EACN,MAAM,YAAE,OAAO;AAAA,EACf,aAAa,YAAE,SAAS,YAAE,OAAO,CAAC;AAAA,EAClC,aAAa,YACV,OAAO;AAAA,IACN,MAAM,YAAE,QAAQ,QAAQ;AAAA,IACxB,YAAY,YAAE,SAAS,YAAE,OAAO,CAAC,CAAC,EAAE,MAAM,CAAC;AAAA,EAC7C,CAAC,EACA,MAAM;AACX,CAAC,EACA,MAAM;AAEF,IAAM,wBAAwB,sBAAsB,OAAO;AAAA,EAChE,OAAO,YAAE,MAAM,UAAU;AAC3B,CAAC;AAGD,IAAM,oBAAoB,YACvB,OAAO;AAAA,EACN,MAAM,YAAE,QAAQ,MAAM;AAAA,EACtB,MAAM,YAAE,OAAO;AACjB,CAAC,EACA,MAAM;AACT,IAAM,qBAAqB,YACxB,OAAO;AAAA,EACN,MAAM,YAAE,QAAQ,OAAO;AAAA,EACvB,MAAM,YAAE,OAAO;AAAA,EACf,UAAU,YAAE,OAAO;AACrB,CAAC,EACA,MAAM;AACF,IAAM,iBAAiB,YAC3B,OAAO;AAAA,EACN,KAAK,YAAE,OAAO;AAAA,EACd,MAAM,YAAE,OAAO;AAAA,EACf,OAAO,YAAE,SAAS,YAAE,OAAO,CAAC;AAAA,EAC5B,aAAa,YAAE,SAAS,YAAE,OAAO,CAAC;AAAA,EAClC,UAAU,YAAE,SAAS,YAAE,OAAO,CAAC;AAAA,EAC/B,MAAM,YAAE,SAAS,YAAE,OAAO,CAAC;AAC7B,CAAC,EACA,MAAM;AAGF,IAAM,4BAA4B,sBAAsB,OAAO;AAAA,EACpE,WAAW,YAAE,MAAM,cAAc;AACnC,CAAC;AAGD,IAAM,yBAAyB,YAC5B,OAAO;AAAA;AAAA;AAAA;AAAA,EAIN,KAAK,YAAE,OAAO;AAAA;AAAA;AAAA;AAAA,EAId,MAAM,YAAE,SAAS,YAAE,OAAO,CAAC;AAAA;AAAA;AAAA;AAAA,EAI3B,OAAO,YAAE,SAAS,YAAE,OAAO,CAAC;AAAA;AAAA;AAAA;AAAA,EAI5B,UAAU,YAAE,SAAS,YAAE,OAAO,CAAC;AACjC,CAAC,EACA,MAAM;AACT,IAAM,6BAA6B,uBAAuB,OAAO;AAAA,EAC/D,MAAM,YAAE,OAAO;AACjB,CAAC;AACD,IAAM,6BAA6B,uBAAuB,OAAO;AAAA,EAC/D,MAAM,YAAE,OAAO;AACjB,CAAC;AACD,IAAM,yBAAyB,YAC5B,OAAO;AAAA,EACN,MAAM,YAAE,QAAQ,UAAU;AAAA,EAC1B,UAAU,YAAE,MAAM,CAAC,4BAA4B,0BAA0B,CAAC;AAC5E,CAAC,EACA,MAAM;AAEF,IAAM,uBAAuB,aAAa,OAAO;AAAA,EACtD,SAAS,YAAE;AAAA,IACT,YAAE,MAAM,CAAC,mBAAmB,oBAAoB,sBAAsB,CAAC;AAAA,EACzE;AAAA,EACA,SAAS,YAAE,QAAQ,EAAE,QAAQ,KAAK,EAAE,SAAS;AAC/C,CAAC,EAAE;AAAA,EACD,aAAa,OAAO;AAAA,IAClB,YAAY,YAAE,QAAQ;AAAA,EACxB,CAAC;AACH;AAGA,IAAM,yBAAyB,YAC5B,OAAO;AAAA,EACN,aAAa,YAAE,OAAO;AAAA,EACtB,MAAM,YAAE,OAAO;AAAA,EACf,OAAO,YAAE,SAAS,YAAE,OAAO,CAAC;AAAA,EAC5B,aAAa,YAAE,SAAS,YAAE,OAAO,CAAC;AAAA,EAClC,UAAU,YAAE,SAAS,YAAE,OAAO,CAAC;AACjC,CAAC,EACA,MAAM;AAEF,IAAM,oCAAoC,aAAa,OAAO;AAAA,EACnE,mBAAmB,YAAE,MAAM,sBAAsB;AACnD,CAAC;AAKM,IAAM,2BAA2B,aAAa,OAAO;AAAA,EAC1D,UAAU,YAAE;AAAA,IACV,YAAE,MAAM,CAAC,4BAA4B,0BAA0B,CAAC;AAAA,EAClE;AACF,CAAC;AAID,IAAM,uBAAuB,YAC1B,OAAO;AAAA,EACN,MAAM,YAAE,OAAO;AAAA,EACf,aAAa,YAAE,SAAS,YAAE,OAAO,CAAC;AAAA,EAClC,UAAU,YAAE,SAAS,YAAE,QAAQ,CAAC;AAClC,CAAC,EACA,MAAM;AAEF,IAAM,eAAe,YACzB,OAAO;AAAA,EACN,MAAM,YAAE,OAAO;AAAA,EACf,OAAO,YAAE,SAAS,YAAE,OAAO,CAAC;AAAA,EAC5B,aAAa,YAAE,SAAS,YAAE,OAAO,CAAC;AAAA,EAClC,WAAW,YAAE,SAAS,YAAE,MAAM,oBAAoB,CAAC;AACrD,CAAC,EACA,MAAM;AAGF,IAAM,0BAA0B,sBAAsB,OAAO;AAAA,EAClE,SAAS,YAAE,MAAM,YAAY;AAC/B,CAAC;AAGD,IAAM,sBAAsB,YACzB,OAAO;AAAA,EACN,MAAM,YAAE,MAAM,CAAC,YAAE,QAAQ,MAAM,GAAG,YAAE,QAAQ,WAAW,CAAC,CAAC;AAAA,EACzD,SAAS,YAAE,MAAM;AAAA,IACf;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACH,CAAC,EACA,MAAM;AAGF,IAAM,wBAAwB,aAAa,OAAO;AAAA,EACvD,aAAa,YAAE,SAAS,YAAE,OAAO,CAAC;AAAA,EAClC,UAAU,YAAE,MAAM,mBAAmB;AACvC,CAAC;;;ADxPD,IAAM,kBAAkB;AAExB,IAAM,uBAAuB,aAC1B,OAAO;AAAA,EACN,SAAS,aAAE,QAAQ,eAAe;AAAA,EAClC,IAAI,aAAE,MAAM,CAAC,aAAE,OAAO,GAAG,aAAE,OAAO,EAAE,IAAI,CAAC,CAAC;AAC5C,CAAC,EACA,MAAM,aAAa,EACnB,OAAO;AAIV,IAAM,wBAAwB,aAC3B,OAAO;AAAA,EACN,SAAS,aAAE,QAAQ,eAAe;AAAA,EAClC,IAAI,aAAE,MAAM,CAAC,aAAE,OAAO,GAAG,aAAE,OAAO,EAAE,IAAI,CAAC,CAAC;AAAA,EAC1C,QAAQ;AACV,CAAC,EACA,OAAO;AAIV,IAAM,qBAAqB,aACxB,OAAO;AAAA,EACN,SAAS,aAAE,QAAQ,eAAe;AAAA,EAClC,IAAI,aAAE,MAAM,CAAC,aAAE,OAAO,GAAG,aAAE,OAAO,EAAE,IAAI,CAAC,CAAC;AAAA,EAC1C,OAAO,aAAE,OAAO;AAAA,IACd,MAAM,aAAE,OAAO,EAAE,IAAI;AAAA,IACrB,SAAS,aAAE,OAAO;AAAA,IAClB,MAAM,aAAE,SAAS,aAAE,QAAQ,CAAC;AAAA,EAC9B,CAAC;AACH,CAAC,EACA,OAAO;AAIV,IAAM,4BAA4B,aAC/B,OAAO;AAAA,EACN,SAAS,aAAE,QAAQ,eAAe;AACpC,CAAC,EACA;AAAA,EACC,aAAE,OAAO;AAAA,IACP,QAAQ,aAAE,OAAO;AAAA,IACjB,QAAQ,aAAE,SAAS,gBAAgB;AAAA,EACrC,CAAC;AACH,EACC,OAAO;AAIH,IAAM,uBAAuB,aAAE,MAAM;AAAA,EAC1C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;;;AEzDM,IAAM,UACX,OAAO,wBAAwB,cAC3B,sBACA;;;ACJN,4BAA0B;;;ACA1B,IAAAC,aAAkB;AAIX,IAAM,oBAAoB,aAC9B,OAAO;AAAA,EACN,cAAc,aAAE,OAAO;AAAA,EACvB,UAAU,aAAE,OAAO,EAAE,SAAS;AAAA;AAAA,EAC9B,YAAY,aAAE,OAAO;AAAA,EACrB,YAAY,aAAE,OAAO,EAAE,SAAS;AAAA,EAChC,OAAO,aAAE,OAAO,EAAE,SAAS;AAAA,EAC3B,eAAe,aAAE,OAAO,EAAE,SAAS;AACrC,CAAC,EACA,MAAM;AAKF,IAAM,gBAAgB,aAC1B,OAAO,EACP,IAAI,EACJ,YAAY,CAAC,KAAK,QAAQ;AACzB,MAAI,CAAC,IAAI,SAAS,GAAG,GAAG;AACtB,QAAI,SAAS;AAAA,MACX,MAAM,aAAE,aAAa;AAAA,MACrB,SAAS;AAAA,MACT,OAAO;AAAA,IACT,CAAC;AAED,WAAO,aAAE;AAAA,EACX;AACF,CAAC,EACA;AAAA,EACC,SAAO;AACL,UAAM,IAAI,IAAI,IAAI,GAAG;AACrB,WACE,EAAE,aAAa,iBACf,EAAE,aAAa,WACf,EAAE,aAAa;AAAA,EAEnB;AAAA,EACA,EAAE,SAAS,yDAAyD;AACtE;AAEK,IAAM,uCAAuC,aACjD,OAAO;AAAA,EACN,UAAU,aAAE,OAAO,EAAE,IAAI;AAAA,EACzB,uBAAuB,aAAE,MAAM,aAAa,EAAE,SAAS;AAAA,EACvD,UAAU,aAAE,OAAO,EAAE,IAAI,EAAE,SAAS;AAAA,EACpC,kBAAkB,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EAC/C,0BAA0B,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EACvD,uCAAuC,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EACpE,eAAe,aAAE,OAAO,EAAE,SAAS;AAAA,EACnC,wBAAwB,aAAE,OAAO,EAAE,SAAS;AAAA,EAC5C,qBAAqB,aAAE,OAAO,EAAE,IAAI,EAAE,SAAS;AAAA,EAC/C,kBAAkB,aAAE,OAAO,EAAE,IAAI,EAAE,SAAS;AAAA,EAC5C,4CAA4C,aAAE,QAAQ,EAAE,SAAS;AAAA,EACjE,uCAAuC,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EACpE,mCAAmC,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EAChE,mCAAmC,aAAE,QAAQ,EAAE,SAAS;AAC1D,CAAC,EACA,YAAY;AAER,IAAM,sBAAsB,aAChC,OAAO;AAAA,EACN,QAAQ,aAAE,OAAO;AAAA,EACjB,wBAAwB;AAAA,EACxB,gBAAgB;AAAA,EAChB,uBAAuB,cAAc,SAAS;AAAA,EAC9C,kBAAkB,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EAC/C,0BAA0B,aAAE,MAAM,aAAE,OAAO,CAAC;AAAA,EAC5C,uBAAuB,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EACpD,kCAAkC,aAAE,MAAM,aAAE,OAAO,CAAC;AAAA,EACpD,uCAAuC,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EACpE,kDAAkD,aAC/C,MAAM,aAAE,OAAO,CAAC,EAChB,SAAS;AACd,CAAC,EACA,YAAY;AAMR,IAAM,+BAA+B,aACzC,OAAO;AAAA,EACN,QAAQ,aAAE,OAAO;AAAA,EACjB,wBAAwB;AAAA,EACxB,gBAAgB;AAAA,EAChB,mBAAmB,cAAc,SAAS;AAAA,EAC1C,UAAU;AAAA,EACV,uBAAuB,cAAc,SAAS;AAAA,EAC9C,kBAAkB,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EAC/C,0BAA0B,aAAE,MAAM,aAAE,OAAO,CAAC;AAAA,EAC5C,uBAAuB,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EACpD,yBAAyB,aAAE,MAAM,aAAE,OAAO,CAAC;AAAA,EAC3C,uCAAuC,aAAE,MAAM,aAAE,OAAO,CAAC;AAAA,EACzD,kBAAkB,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EAC/C,uCAAuC,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AACtE,CAAC,EACA,YAAY;AAOR,IAAM,wCACX,6BAA6B;AAAA,EAC3B,oBAAoB,KAAK;AAAA,IACvB,kCAAkC;AAAA,EACpC,CAAC;AACH;AAEK,IAAM,+BAA+B,aACzC,OAAO;AAAA,EACN,WAAW,aAAE,OAAO;AAAA,EACpB,eAAe,aAAE,OAAO,EAAE,SAAS;AAAA,EACnC,qBAAqB,aAAE,OAAO,EAAE,SAAS;AAAA,EACzC,0BAA0B,aAAE,OAAO,EAAE,SAAS;AAChD,CAAC,EACA,MAAM;AAEF,IAAM,4BAA4B,aACtC,OAAO;AAAA,EACN,eAAe,aAAE,MAAM,aAAa;AAAA,EACpC,4BAA4B,aAAE,OAAO,EAAE,SAAS;AAAA,EAChD,aAAa,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EAC1C,gBAAgB,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EAC7C,aAAa,aAAE,OAAO,EAAE,SAAS;AAAA,EACjC,YAAY,cAAc,SAAS;AAAA,EACnC,UAAU,cAAc,SAAS;AAAA,EACjC,OAAO,aAAE,OAAO,EAAE,SAAS;AAAA,EAC3B,UAAU,aAAE,MAAM,aAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EACvC,SAAS,cAAc,SAAS;AAAA,EAChC,YAAY,aAAE,OAAO,EAAE,SAAS;AAAA,EAChC,UAAU,cAAc,SAAS;AAAA,EACjC,MAAM,aAAE,IAAI,EAAE,SAAS;AAAA,EACvB,aAAa,aAAE,OAAO,EAAE,SAAS;AAAA,EACjC,kBAAkB,aAAE,OAAO,EAAE,SAAS;AAAA,EACtC,oBAAoB,aAAE,OAAO,EAAE,SAAS;AAC1C,CAAC,EACA,MAAM;AAiBF,IAAM,2BAA2B,aAAE,OAAO;AAAA,EAC/C,OAAO,aAAE,OAAO;AAAA,EAChB,mBAAmB,aAAE,OAAO,EAAE,SAAS;AAAA,EACvC,WAAW,aAAE,OAAO,EAAE,SAAS;AACjC,CAAC;AACM,IAAM,mCAAmC,0BAA0B;AAAA,EACxE;AACF;;;ACtKA,IAAAC,mBAA2B;AAE3B,IAAMC,QAAO;AACb,IAAMC,UAAS,mBAAmBD,KAAI;AACtC,IAAME,UAAS,OAAO,IAAID,OAAM;AAJhC,IAAAE,KAAAC;AASO,IAAM,sBAAN,eAAkCA,MAAA,6BACrBD,MAAAD,SADqBE,KAAW;AAAA,EAGlD,YAAY;AAAA,IACV,MAAAJ,QAAO;AAAA,IACP;AAAA,IACA;AAAA,EACF,GAIG;AACD,UAAM,EAAE,MAAAA,OAAM,SAAS,MAAM,CAAC;AAXhC,SAAkBG,OAAU;AAAA,EAY5B;AAAA,EAEA,OAAO,WAAW,OAA8C;AAC9D,WAAO,4BAAW,UAAU,OAAOF,OAAM;AAAA,EAC3C;AACF;AACO,IAAM,cAAN,cAA0B,oBAAoB;AAErD;AAFa,YACJ,YAAY;AAGd,IAAM,qBAAN,cAAiC,oBAAoB;AAE5D;AAFa,mBACJ,YAAY;AAGd,IAAM,oBAAN,cAAgC,oBAAoB;AAE3D;AAFa,kBACJ,YAAY;AAGd,IAAM,0BAAN,cAAsC,oBAAoB;AAEjE;AAFa,wBACJ,YAAY;AAGd,IAAM,eAAe;AAAA,EAC1B,CAAC,YAAY,SAAS,GAAG;AAAA,EACzB,CAAC,mBAAmB,SAAS,GAAG;AAAA,EAChC,CAAC,kBAAkB,SAAS,GAAG;AAAA,EAC/B,CAAC,wBAAwB,SAAS,GAAG;AACvC;;;ACxCO,SAAS,yBAAyB,KAAwB;AAC/D,QAAM,cACJ,OAAO,QAAQ,WAAW,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI,IAAI,IAAI;AAC3D,cAAY,OAAO;AACnB,SAAO;AACT;AAWO,SAAS,qBAAqB;AAAA,EACnC;AAAA,EACA;AACF,GAGY;AACV,QAAM,YACJ,OAAO,sBAAsB,WACzB,IAAI,IAAI,iBAAiB,IACzB,IAAI,IAAI,kBAAkB,IAAI;AACpC,QAAM,aACJ,OAAO,uBAAuB,WAC1B,IAAI,IAAI,kBAAkB,IAC1B,IAAI,IAAI,mBAAmB,IAAI;AAGrC,MAAI,UAAU,WAAW,WAAW,QAAQ;AAC1C,WAAO;AAAA,EACT;AAGA,MAAI,UAAU,SAAS,SAAS,WAAW,SAAS,QAAQ;AAC1D,WAAO;AAAA,EACT;AAQA,QAAM,gBAAgB,UAAU,SAAS,SAAS,GAAG,IACjD,UAAU,WACV,UAAU,WAAW;AACzB,QAAM,iBAAiB,WAAW,SAAS,SAAS,GAAG,IACnD,WAAW,WACX,WAAW,WAAW;AAE1B,SAAO,cAAc,WAAW,cAAc;AAChD;;;AH0BO,IAAM,oBAAN,cAAgC,MAAM;AAAA,EAC3C,YAAY,UAAU,gBAAgB;AACpC,UAAM,OAAO;AACb,SAAK,OAAO;AAAA,EACd;AACF;AAMO,SAAS,2BACd,UACiB;AAxGnB,MAAAI;AAyGE,QAAM,UACJA,MAAA,SAAS,QAAQ,IAAI,kBAAkB,MAAvC,OAAAA,MACA,SAAS,QAAQ,IAAI,kBAAkB;AACzC,MAAI,CAAC,QAAQ;AACX,WAAO;AAAA,EACT;AAEA,QAAM,CAAC,MAAM,MAAM,IAAI,OAAO,MAAM,GAAG;AACvC,MAAI,KAAK,YAAY,MAAM,YAAY,CAAC,QAAQ;AAC9C,WAAO;AAAA,EACT;AAGA,QAAM,QAAQ;AACd,QAAM,QAAQ,OAAO,MAAM,KAAK;AAChC,MAAI,CAAC,OAAO;AACV,WAAO;AAAA,EACT;AAEA,MAAI;AACF,WAAO,IAAI,IAAI,MAAM,CAAC,CAAC;AAAA,EACzB,SAAQ;AACN,WAAO;AAAA,EACT;AACF;AAKA,SAAS,mBACP,iBAIA,WAAmB,IACnB,UAAyC,CAAC,GAClC;AACR,MAAI,SAAS,SAAS,GAAG,GAAG;AAC1B,eAAW,SAAS,MAAM,GAAG,EAAE;AAAA,EACjC;AAEA,SAAO,QAAQ,kBACX,GAAG,QAAQ,gBAAgB,eAAe,KAC1C,gBAAgB,eAAe,GAAG,QAAQ;AAChD;AAEA,eAAe,mBACb,KACA,SACA,UAAyB,OACM;AAC/B,MAAI;AACF,WAAO,MAAM,QAAQ,KAAK,EAAE,QAAQ,CAAC;AAAA,EACvC,SAAS,OAAO;AACd,QAAI,iBAAiB,WAAW;AAC9B,UAAI,SAAS;AACX,eAAO,mBAAmB,KAAK,QAAW,OAAO;AAAA,MACnD,OAAO;AACL,eAAO;AAAA,MACT;AAAA,IACF;AACA,UAAM;AAAA,EACR;AACF;AAKA,eAAe,qBACb,KACA,iBACA,UAAyB,OACM;AAC/B,QAAM,UAAU;AAAA,IACd,wBAAwB;AAAA,EAC1B;AACA,SAAO,MAAM,mBAAmB,KAAK,SAAS,OAAO;AACvD;AAKA,SAAS,sBACP,UACA,UACS;AACT,SACE,CAAC,YACA,SAAS,UAAU,OAAO,SAAS,SAAS,OAAO,aAAa;AAErE;AAKA,eAAe,6BACb,WACA,eACA,SACA,MAK+B;AAjNjC,MAAAA,KAAAC;AAkNE,QAAM,SAAS,IAAI,IAAI,SAAS;AAChC,QAAM,mBAAkBD,MAAA,6BAAM,oBAAN,OAAAA,MAAyB;AAEjD,MAAI;AACJ,MAAI,6BAAM,aAAa;AACrB,UAAM,IAAI,IAAI,KAAK,WAAW;AAAA,EAChC,OAAO;AACL,UAAM,gBAAgB,mBAAmB,eAAe,OAAO,QAAQ;AACvE,UAAM,IAAI,IAAI,gBAAeC,MAAA,6BAAM,sBAAN,OAAAA,MAA2B,MAAM;AAC9D,QAAI,SAAS,OAAO;AAAA,EACtB;AAEA,MAAI,WAAW,MAAM,qBAAqB,KAAK,iBAAiB,OAAO;AAEvE,MAAI,EAAC,6BAAM,gBAAe,sBAAsB,UAAU,OAAO,QAAQ,GAAG;AAC1E,UAAM,UAAU,IAAI,IAAI,gBAAgB,aAAa,IAAI,MAAM;AAC/D,eAAW,MAAM,qBAAqB,SAAS,iBAAiB,OAAO;AAAA,EACzE;AAEA,SAAO;AACT;AAEA,eAAsB,uCACpB,WACA,MACA,UAAyB,OACgB;AACzC,QAAM,WAAW,MAAM;AAAA,IACrB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,MACE,iBAAiB,6BAAM;AAAA,MACvB,aAAa,6BAAM;AAAA,IACrB;AAAA,EACF;AAEA,MAAI,CAAC,YAAY,SAAS,WAAW,KAAK;AACxC,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,MAAI,CAAC,SAAS,IAAI;AAChB,UAAM,IAAI;AAAA,MACR,QAAQ,SAAS,MAAM;AAAA,IACzB;AAAA,EACF;AACA,SAAO,qCAAqC,MAAM,MAAM,SAAS,KAAK,CAAC;AACzE;AASO,SAAS,mBACd,wBACwC;AACxC,QAAM,MACJ,OAAO,2BAA2B,WAC9B,IAAI,IAAI,sBAAsB,IAC9B;AACN,QAAM,UAAU,IAAI,aAAa;AACjC,QAAM,YAAoD,CAAC;AAE3D,MAAI,CAAC,SAAS;AACZ,cAAU,KAAK;AAAA,MACb,KAAK,IAAI,IAAI,2CAA2C,IAAI,MAAM;AAAA,MAClE,MAAM;AAAA,IACR,CAAC;AAED,cAAU,KAAK;AAAA,MACb,KAAK,IAAI,IAAI,qCAAqC,IAAI,MAAM;AAAA,MAC5D,MAAM;AAAA,IACR,CAAC;AAED,WAAO;AAAA,EACT;AAEA,MAAI,WAAW,IAAI;AACnB,MAAI,SAAS,SAAS,GAAG,GAAG;AAC1B,eAAW,SAAS,MAAM,GAAG,EAAE;AAAA,EACjC;AAEA,YAAU,KAAK;AAAA,IACb,KAAK,IAAI;AAAA,MACP,0CAA0C,QAAQ;AAAA,MAClD,IAAI;AAAA,IACN;AAAA,IACA,MAAM;AAAA,EACR,CAAC;AAED,YAAU,KAAK;AAAA,IACb,KAAK,IAAI,IAAI,2CAA2C,IAAI,MAAM;AAAA,IAClE,MAAM;AAAA,EACR,CAAC;AAED,YAAU,KAAK;AAAA,IACb,KAAK,IAAI,IAAI,oCAAoC,QAAQ,IAAI,IAAI,MAAM;AAAA,IACvE,MAAM;AAAA,EACR,CAAC;AAED,YAAU,KAAK;AAAA,IACb,KAAK,IAAI,IAAI,GAAG,QAAQ,qCAAqC,IAAI,MAAM;AAAA,IACvE,MAAM;AAAA,EACR,CAAC;AAED,SAAO;AACT;AAEA,eAAsB,oCACpB,wBACA;AAAA,EACE,UAAU;AAAA,EACV,kBAAkB;AACpB,IAGI,CAAC,GAC6C;AA5UpD,MAAAD;AA6UE,QAAM,UAAU,EAAE,wBAAwB,gBAAgB;AAE1D,QAAM,YAAY,mBAAmB,sBAAsB;AAE3D,aAAW,EAAE,KAAK,aAAa,KAAK,KAAK,WAAW;AAClD,UAAM,WAAW,MAAM,mBAAmB,aAAa,SAAS,OAAO;AAEvE,QAAI,CAAC,UAAU;AAKb;AAAA,IACF;AAEA,QAAI,CAAC,SAAS,IAAI;AAEhB,UAAI,SAAS,UAAU,OAAO,SAAS,SAAS,KAAK;AACnD;AAAA,MACF;AACA,YAAM,IAAI;AAAA,QACR,QAAQ,SAAS,MAAM,mBAAmB,SAAS,UAAU,UAAU,iBAAiB,kBAAkB,WAAW;AAAA,MACvH;AAAA,IACF;AAEA,QAAI,SAAS,SAAS;AACpB,aAAO,oBAAoB,MAAM,MAAM,SAAS,KAAK,CAAC;AAAA,IACxD,OAAO;AACL,YAAM,WAAW,sCAAsC;AAAA,QACrD,MAAM,SAAS,KAAK;AAAA,MACtB;AAGA,UAAI,GAACA,MAAA,SAAS,qCAAT,gBAAAA,IAA2C,SAAS,UAAS;AAChE,cAAM,IAAI;AAAA,UACR,iCAAiC,WAAW;AAAA,QAC9C;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAAA,EACF;AAEA,SAAO;AACT;AAEA,eAAsB,mBACpB,wBACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAQ0D;AAC1D,QAAM,eAAe;AACrB,QAAM,sBAAsB;AAE5B,MAAI;AACJ,MAAI,UAAU;AACZ,uBAAmB,IAAI,IAAI,SAAS,sBAAsB;AAE1D,QAAI,CAAC,SAAS,yBAAyB,SAAS,YAAY,GAAG;AAC7D,YAAM,IAAI;AAAA,QACR,4DAA4D,YAAY;AAAA,MAC1E;AAAA,IACF;AAEA,QACE,CAAC,SAAS,oCACV,CAAC,SAAS,iCAAiC,SAAS,mBAAmB,GACvE;AACA,YAAM,IAAI;AAAA,QACR,oEAAoE,mBAAmB;AAAA,MACzF;AAAA,IACF;AAAA,EACF,OAAO;AACL,uBAAmB,IAAI,IAAI,cAAc,sBAAsB;AAAA,EACjE;AAEA,QAAM,YAAY,UAAM,sBAAAE,SAAc;AACtC,QAAM,eAAe,UAAU;AAC/B,QAAM,gBAAgB,UAAU;AAEhC,mBAAiB,aAAa,IAAI,iBAAiB,YAAY;AAC/D,mBAAiB,aAAa,IAAI,aAAa,kBAAkB,SAAS;AAC1E,mBAAiB,aAAa,IAAI,kBAAkB,aAAa;AACjE,mBAAiB,aAAa;AAAA,IAC5B;AAAA,IACA;AAAA,EACF;AACA,mBAAiB,aAAa,IAAI,gBAAgB,OAAO,WAAW,CAAC;AAErE,MAAI,OAAO;AACT,qBAAiB,aAAa,IAAI,SAAS,KAAK;AAAA,EAClD;AAEA,MAAI,OAAO;AACT,qBAAiB,aAAa,IAAI,SAAS,KAAK;AAAA,EAClD;AAEA,MAAI,+BAAO,SAAS,mBAAmB;AAIrC,qBAAiB,aAAa,OAAO,UAAU,SAAS;AAAA,EAC1D;AAEA,MAAI,UAAU;AACZ,qBAAiB,aAAa,IAAI,YAAY,SAAS,IAAI;AAAA,EAC7D;AAEA,SAAO,EAAE,kBAAkB,aAAa;AAC1C;AAgBA,SAAS,uBACP,mBACA,kBACkB;AAClB,QAAM,kBAAkB,kBAAkB,kBAAkB;AAE5D,MAAI,iBAAiB,WAAW,GAAG;AACjC,WAAO,kBAAkB,uBAAuB;AAAA,EAClD;AAEA,MAAI,mBAAmB,iBAAiB,SAAS,qBAAqB,GAAG;AACvE,WAAO;AAAA,EACT;AAEA,MAAI,mBAAmB,iBAAiB,SAAS,oBAAoB,GAAG;AACtE,WAAO;AAAA,EACT;AAEA,MAAI,iBAAiB,SAAS,MAAM,GAAG;AACrC,WAAO;AAAA,EACT;AAEA,SAAO,kBAAkB,uBAAuB;AAClD;AAgBA,SAAS,0BACP,QACA,mBACA,SACA,QACM;AACN,QAAM,EAAE,WAAW,cAAc,IAAI;AAErC,UAAQ,QAAQ;AAAA,IACd,KAAK;AACH,qBAAe,WAAW,eAAe,OAAO;AAChD;AAAA,IACF,KAAK;AACH,oBAAc,WAAW,eAAe,MAAM;AAC9C;AAAA,IACF,KAAK;AACH,sBAAgB,WAAW,MAAM;AACjC;AAAA,IACF;AACE,YAAM,IAAI,MAAM,6CAA6C,MAAM,EAAE;AAAA,EACzE;AACF;AAEA,SAAS,eACP,UACA,cACA,SACM;AACN,MAAI,CAAC,cAAc;AACjB,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,QAAM,cAAc,KAAK,GAAG,QAAQ,IAAI,YAAY,EAAE;AACtD,UAAQ,IAAI,iBAAiB,SAAS,WAAW,EAAE;AACrD;AAKA,SAAS,cACP,UACA,cACA,QACM;AACN,SAAO,IAAI,aAAa,QAAQ;AAChC,MAAI,cAAc;AAChB,WAAO,IAAI,iBAAiB,YAAY;AAAA,EAC1C;AACF;AAKA,SAAS,gBAAgB,UAAkB,QAA+B;AACxE,SAAO,IAAI,aAAa,QAAQ;AAClC;AAaA,eAAsB,mBACpB,OAC8B;AAC9B,QAAM,aAAa,iBAAiB,WAAW,MAAM,SAAS;AAC9D,QAAM,OAAO,iBAAiB,WAAW,MAAM,MAAM,KAAK,IAAI;AAE9D,MAAI;AACF,UAAM,SAAS,yBAAyB,MAAM,KAAK,MAAM,IAAI,CAAC;AAC9D,UAAM,EAAE,OAAO,mBAAmB,UAAU,IAAI;AAChD,UAAM,aAAa,aAAa,KAAK,KAAK;AAC1C,WAAO,IAAI,WAAW;AAAA,MACpB,SAAS,qBAAqB;AAAA,MAC9B,OAAO;AAAA,IACT,CAAC;AAAA,EACH,SAAS,OAAO;AAEd,UAAM,eAAe,GAAG,aAAa,QAAQ,UAAU,OAAO,EAAE,iCAAiC,KAAK,eAAe,IAAI;AACzH,WAAO,IAAI,YAAY,EAAE,SAAS,aAAa,CAAC;AAAA,EAClD;AACF;AAcA,eAAsB,sBACpB,wBACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAUsB;AA1nBxB,MAAAF;AA2nBE,QAAM,YAAY;AAElB,QAAM,YAAW,qCAAU,kBACvB,IAAI,IAAI,SAAS,cAAc,IAC/B,IAAI,IAAI,UAAU,sBAAsB;AAE5C,OACE,qCAAU,0BACV,CAAC,SAAS,sBAAsB,SAAS,SAAS,GAClD;AACA,UAAM,IAAI;AAAA,MACR,yDAAyD,SAAS;AAAA,IACpE;AAAA,EACF;AAEA,QAAM,UAAU,IAAI,QAAQ;AAAA,IAC1B,gBAAgB;AAAA,IAChB,QAAQ;AAAA,EACV,CAAC;AACD,QAAM,SAAS,IAAI,gBAAgB;AAAA,IACjC,YAAY;AAAA,IACZ,MAAM;AAAA,IACN,eAAe;AAAA,IACf,cAAc,OAAO,WAAW;AAAA,EAClC,CAAC;AAED,MAAI,yBAAyB;AAC3B,4BAAwB,SAAS,QAAQ,wBAAwB,QAAQ;AAAA,EAC3E,OAAO;AACL,UAAM,oBACJA,MAAA,qCAAU,0CAAV,OAAAA,MAAmD,CAAC;AACtD,UAAM,aAAa;AAAA,MACjB;AAAA,MACA;AAAA,IACF;AAEA,8BAA0B,YAAY,mBAAmB,SAAS,MAAM;AAAA,EAC1E;AAEA,MAAI,UAAU;AACZ,WAAO,IAAI,YAAY,SAAS,IAAI;AAAA,EACtC;AAEA,QAAM,WAAW,OAAO,4BAAW,OAAO,UAAU;AAAA,IAClD,QAAQ;AAAA,IACR;AAAA,IACA,MAAM;AAAA,EACR,CAAC;AAED,MAAI,CAAC,SAAS,IAAI;AAChB,UAAM,MAAM,mBAAmB,QAAQ;AAAA,EACzC;AAEA,SAAO,kBAAkB,MAAM,MAAM,SAAS,KAAK,CAAC;AACtD;AAcA,eAAsB,qBACpB,wBACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAQsB;AAhtBxB,MAAAA;AAitBE,QAAM,YAAY;AAElB,MAAI;AACJ,MAAI,UAAU;AACZ,eAAW,IAAI,IAAI,SAAS,cAAc;AAE1C,QACE,SAAS,yBACT,CAAC,SAAS,sBAAsB,SAAS,SAAS,GAClD;AACA,YAAM,IAAI;AAAA,QACR,yDAAyD,SAAS;AAAA,MACpE;AAAA,IACF;AAAA,EACF,OAAO;AACL,eAAW,IAAI,IAAI,UAAU,sBAAsB;AAAA,EACrD;AAEA,QAAM,UAAU,IAAI,QAAQ;AAAA,IAC1B,gBAAgB;AAAA,EAClB,CAAC;AACD,QAAM,SAAS,IAAI,gBAAgB;AAAA,IACjC,YAAY;AAAA,IACZ,eAAe;AAAA,EACjB,CAAC;AAED,MAAI,yBAAyB;AAC3B,4BAAwB,SAAS,QAAQ,wBAAwB,QAAQ;AAAA,EAC3E,OAAO;AACL,UAAM,oBACJA,MAAA,qCAAU,0CAAV,OAAAA,MAAmD,CAAC;AACtD,UAAM,aAAa;AAAA,MACjB;AAAA,MACA;AAAA,IACF;AAEA,8BAA0B,YAAY,mBAAmB,SAAS,MAAM;AAAA,EAC1E;AAEA,MAAI,UAAU;AACZ,WAAO,IAAI,YAAY,SAAS,IAAI;AAAA,EACtC;AAEA,QAAM,WAAW,OAAO,4BAAW,OAAO,UAAU;AAAA,IAClD,QAAQ;AAAA,IACR;AAAA,IACA,MAAM;AAAA,EACR,CAAC;AACD,MAAI,CAAC,SAAS,IAAI;AAChB,UAAM,MAAM,mBAAmB,QAAQ;AAAA,EACzC;AAEA,SAAO,kBAAkB,MAAM;AAAA,IAC7B,eAAe;AAAA,IACf,GAAI,MAAM,SAAS,KAAK;AAAA,EAC1B,CAAC;AACH;AAKA,eAAsB,eACpB,wBACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AACF,GAKqC;AACrC,MAAI;AAEJ,MAAI,UAAU;AACZ,QAAI,CAAC,SAAS,uBAAuB;AACnC,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,sBAAkB,IAAI,IAAI,SAAS,qBAAqB;AAAA,EAC1D,OAAO;AACL,sBAAkB,IAAI,IAAI,aAAa,sBAAsB;AAAA,EAC/D;AAEA,QAAM,WAAW,OAAO,4BAAW,OAAO,iBAAiB;AAAA,IACzD,QAAQ;AAAA,IACR,SAAS;AAAA,MACP,gBAAgB;AAAA,IAClB;AAAA,IACA,MAAM,KAAK,UAAU,cAAc;AAAA,EACrC,CAAC;AAED,MAAI,CAAC,SAAS,IAAI;AAChB,UAAM,MAAM,mBAAmB,QAAQ;AAAA,EACzC;AAEA,SAAO,iCAAiC,MAAM,MAAM,SAAS,KAAK,CAAC;AACrE;AAEA,eAAsB,KACpB,UACA,SAOqB;AAh0BvB,MAAAA,KAAAC;AAi0BE,MAAI;AACF,WAAO,MAAM,aAAa,UAAU,OAAO;AAAA,EAC7C,SAAS,OAAO;AACd,QACE,iBAAiB,sBACjB,iBAAiB,yBACjB;AACA,cAAMD,MAAA,SAAS,0BAAT,gBAAAA,IAAA,eAAiC;AACvC,aAAO,MAAM,aAAa,UAAU,OAAO;AAAA,IAC7C,WAAW,iBAAiB,mBAAmB;AAC7C,cAAMC,MAAA,SAAS,0BAAT,gBAAAA,IAAA,eAAiC;AACvC,aAAO,MAAM,aAAa,UAAU,OAAO;AAAA,IAC7C;AAEA,UAAM;AAAA,EACR;AACF;AAEA,eAAsB,kBACpB,WACA,UACA,kBAC0B;AAC1B,QAAM,kBAAkB,yBAAyB,SAAS;AAE1D,MAAI,SAAS,qBAAqB;AAChC,WAAO,MAAM,SAAS;AAAA,MACpB;AAAA,MACA,qDAAkB;AAAA,IACpB;AAAA,EACF;AAEA,MAAI,CAAC,kBAAkB;AACrB,WAAO;AAAA,EACT;AAEA,MACE,CAAC,qBAAqB;AAAA,IACpB,mBAAmB;AAAA,IACnB,oBAAoB,iBAAiB;AAAA,EACvC,CAAC,GACD;AACA,UAAM,IAAI;AAAA,MACR,sBAAsB,iBAAiB,QAAQ,4BAA4B,eAAe;AAAA,IAC5F;AAAA,EACF;AACA,SAAO,IAAI,IAAI,iBAAiB,QAAQ;AAC1C;AAEA,eAAe,aACb,UACA;AAAA,EACE;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAOqB;AACrB,MAAI;AACJ,MAAI;AACJ,MAAI;AACF,uBAAmB,MAAM;AAAA,MACvB;AAAA,MACA,EAAE,oBAAoB;AAAA,MACtB;AAAA,IACF;AACA,QACE,iBAAiB,yBACjB,iBAAiB,sBAAsB,SAAS,GAChD;AACA,+BAAyB,iBAAiB,sBAAsB,CAAC;AAAA,IACnE;AAAA,EACF,SAAQ;AAAA,EAAC;AAMT,MAAI,CAAC,wBAAwB;AAC3B,6BAAyB;AAAA,EAC3B;AAEA,QAAM,WAA4B,MAAM;AAAA,IACtC;AAAA,IACA;AAAA,IACA;AAAA,EACF;AAEA,QAAM,WAAW,MAAM;AAAA,IACrB;AAAA,IACA;AAAA,MACE;AAAA,IACF;AAAA,EACF;AAEA,MAAI,oBAAoB,MAAM,QAAQ,QAAQ,SAAS,kBAAkB,CAAC;AAC1E,MAAI,CAAC,mBAAmB;AACtB,QAAI,sBAAsB,QAAW;AACnC,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,QAAI,CAAC,SAAS,uBAAuB;AACnC,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,UAAM,kBAAkB,MAAM,eAAe,wBAAwB;AAAA,MACnE;AAAA,MACA,gBAAgB,SAAS;AAAA,MACzB;AAAA,IACF,CAAC;AAED,UAAM,SAAS,sBAAsB,eAAe;AACpD,wBAAoB;AAAA,EACtB;AAGA,MAAI,sBAAsB,QAAW;AACnC,UAAME,gBAAe,MAAM,SAAS,aAAa;AACjD,UAAMC,UAAS,MAAM,sBAAsB,wBAAwB;AAAA,MACjE;AAAA,MACA;AAAA,MACA;AAAA,MACA,cAAAD;AAAA,MACA,aAAa,SAAS;AAAA,MACtB;AAAA,MACA,yBAAyB,SAAS;AAAA,MAClC;AAAA,IACF,CAAC;AAED,UAAM,SAAS,WAAWC,OAAM;AAChC,WAAO;AAAA,EACT;AAEA,QAAM,SAAS,MAAM,SAAS,OAAO;AAGrC,MAAI,iCAAQ,eAAe;AACzB,QAAI;AAEF,YAAM,YAAY,MAAM,qBAAqB,wBAAwB;AAAA,QACnE;AAAA,QACA;AAAA,QACA,cAAc,OAAO;AAAA,QACrB;AAAA,QACA,yBAAyB,SAAS;AAAA,QAClC;AAAA,MACF,CAAC;AAED,YAAM,SAAS,WAAW,SAAS;AACnC,aAAO;AAAA,IACT,SAAS,OAAO;AACd;AAAA;AAAA,QAEE,EAAE,iBAAiB,wBACnB,iBAAiB;AAAA,QACjB;AAAA,MAEF,OAAO;AAEL,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,QAAM,QAAQ,SAAS,QAAQ,MAAM,SAAS,MAAM,IAAI;AAGxD,QAAM,EAAE,kBAAkB,aAAa,IAAI,MAAM;AAAA,IAC/C;AAAA,IACA;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,MACA,aAAa,SAAS;AAAA,MACtB,OAAO,SAAS,SAAS,eAAe;AAAA,MACxC;AAAA,IACF;AAAA,EACF;AAEA,QAAM,SAAS,iBAAiB,YAAY;AAC5C,QAAM,SAAS,wBAAwB,gBAAgB;AACvD,SAAO;AACT;;;AJj/BO,IAAM,kBAAN,MAA8C;AAAA,EAgBnD,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAIG;AApBH,SAAQ,YAAY;AAqBlB,SAAK,MAAM,IAAI,IAAI,GAAG;AACtB,SAAK,UAAU;AACf,SAAK,eAAe;AAAA,EACtB;AAAA,EAEA,MAAc,cACZ,MACiC;AACjC,UAAM,UAAkC;AAAA,MACtC,GAAG,KAAK;AAAA,MACR,GAAG;AAAA,MACH,wBAAwB;AAAA,IAC1B;AAEA,QAAI,KAAK,cAAc;AACrB,YAAM,SAAS,MAAM,KAAK,aAAa,OAAO;AAC9C,UAAI,iCAAQ,cAAc;AACxB,gBAAQ,eAAe,IAAI,UAAU,OAAO,YAAY;AAAA,MAC1D;AAAA,IACF;AAEA,eAAO;AAAA,MACL;AAAA,MACA,UAAU,OAAO;AAAA,UACjB,sDAA+B;AAAA,IACjC;AAAA,EACF;AAAA,EAEA,MAAM,QAAuB;AAC3B,WAAO,IAAI,QAAc,CAAC,SAAS,WAAW;AAC5C,UAAI,KAAK,WAAW;AAClB,eAAO,QAAQ;AAAA,MACjB;AAEA,WAAK,kBAAkB,IAAI,gBAAgB;AAE3C,YAAM,sBAAsB,OAAO,YAAqB,UAAU;AA9ExE,YAAAC,KAAAC,KAAA;AA+EQ,YAAI;AACF,gBAAM,UAAU,MAAM,KAAK,cAAc;AAAA,YACvC,QAAQ;AAAA,UACV,CAAC;AACD,gBAAM,WAAW,MAAM,MAAM,KAAK,IAAI,MAAM;AAAA,YAC1C;AAAA,YACA,SAAQD,MAAA,KAAK,oBAAL,gBAAAA,IAAsB;AAAA,UAChC,CAAC;AAED,cAAI,SAAS,WAAW,OAAO,KAAK,gBAAgB,CAAC,WAAW;AAC9D,iBAAK,sBAAsB,2BAA2B,QAAQ;AAC9D,gBAAI;AACF,oBAAM,SAAS,MAAM,KAAK,KAAK,cAAc;AAAA,gBAC3C,WAAW,KAAK;AAAA,gBAChB,qBAAqB,KAAK;AAAA,cAC5B,CAAC;AACD,kBAAI,WAAW,cAAc;AAC3B,sBAAM,QAAQ,IAAI,kBAAkB;AACpC,iBAAAC,MAAA,KAAK,YAAL,gBAAAA,IAAA,WAAe;AACf,uBAAO,OAAO,KAAK;AAAA,cACrB;AAAA,YACF,SAAS,OAAO;AACd,yBAAK,YAAL,8BAAe;AACf,qBAAO,OAAO,KAAK;AAAA,YACrB;AACA,mBAAO,oBAAoB,IAAI;AAAA,UACjC;AAEA,cAAI,CAAC,SAAS,MAAM,CAAC,SAAS,MAAM;AAClC,gBAAI,eAAe,4BAA4B,SAAS,MAAM,IAAI,SAAS,UAAU;AAErF,gBAAI,SAAS,WAAW,KAAK;AAC3B,8BACE;AAAA,YACJ;AAEA,kBAAM,QAAQ,IAAI,eAAe;AAAA,cAC/B,SAAS;AAAA,YACX,CAAC;AACD,uBAAK,YAAL,8BAAe;AACf,mBAAO,OAAO,KAAK;AAAA,UACrB;AAEA,gBAAM,SAAS,SAAS,KACrB,YAAY,IAAI,kBAAkB,CAAC,EACnC,YAAY,IAAI,8CAAwB,CAAC;AAE5C,gBAAM,SAAS,OAAO,UAAU;AAEhC,gBAAM,gBAAgB,YAAY;AAhI5C,gBAAAD,KAAAC,KAAAC;AAiIY,gBAAI;AACF,qBAAO,MAAM;AACX,sBAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAE1C,oBAAI,MAAM;AACR,sBAAI,KAAK,WAAW;AAClB,yBAAK,YAAY;AACjB,0BAAM,IAAI,eAAe;AAAA,sBACvB,SACE;AAAA,oBACJ,CAAC;AAAA,kBACH;AACA;AAAA,gBACF;AAEA,sBAAM,EAAE,OAAO,KAAK,IAAI;AAExB,oBAAI,UAAU,YAAY;AACxB,uBAAK,WAAW,IAAI,IAAI,MAAM,KAAK,GAAG;AAEtC,sBAAI,KAAK,SAAS,WAAW,KAAK,IAAI,QAAQ;AAC5C,0BAAM,IAAI,eAAe;AAAA,sBACvB,SAAS,8EAA8E,KAAK,SAAS,MAAM;AAAA,oBAC7G,CAAC;AAAA,kBACH;AAEA,uBAAK,YAAY;AACjB,0BAAQ;AAAA,gBACV,WAAW,UAAU,WAAW;AAC9B,sBAAI;AACF,0BAAM,UAAU,qBAAqB;AAAA,sBACnC,KAAK,MAAM,IAAI;AAAA,oBACjB;AACA,qBAAAF,MAAA,KAAK,cAAL,gBAAAA,IAAA,WAAiB;AAAA,kBACnB,SAAS,OAAO;AACd,0BAAM,IAAI,IAAI,eAAe;AAAA,sBAC3B,SACE;AAAA,sBACF,OAAO;AAAA,oBACT,CAAC;AACD,qBAAAC,MAAA,KAAK,YAAL,gBAAAA,IAAA,WAAe;AAAA,kBAEjB;AAAA,gBACF;AAAA,cACF;AAAA,YACF,SAAS,OAAO;AACd,kBAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AACzD;AAAA,cACF;AAEA,eAAAC,MAAA,KAAK,YAAL,gBAAAA,IAAA,WAAe;AACf,qBAAO,KAAK;AAAA,YACd;AAAA,UACF;AAEA,eAAK,gBAAgB;AAAA,YACnB,OAAO,MAAM,OAAO,OAAO;AAAA,UAC7B;AAEA,wBAAc;AAAA,QAChB,SAAS,OAAO;AACd,cAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AACzD;AAAA,UACF;AAEA,qBAAK,YAAL,8BAAe;AACf,iBAAO,KAAK;AAAA,QACd;AAAA,MACF;AAEA,WAAK,oBAAoB;AAAA,IAC3B,CAAC;AAAA,EACH;AAAA,EAEA,MAAM,QAAuB;AA3M/B,QAAAF,KAAAC,KAAA;AA4MI,SAAK,YAAY;AACjB,KAAAD,MAAA,KAAK,kBAAL,gBAAAA,IAAoB;AACpB,KAAAC,MAAA,KAAK,oBAAL,gBAAAA,IAAsB;AACtB,eAAK,YAAL;AAAA,EACF;AAAA,EAEA,MAAM,KAAK,SAAwC;AACjD,QAAI,CAAC,KAAK,YAAY,CAAC,KAAK,WAAW;AACrC,YAAM,IAAI,eAAe;AAAA,QACvB,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAEA,UAAM,WAAW,KAAK;AAEtB,UAAM,UAAU,OAAO,YAAqB,UAAyB;AA3NzE,UAAAD,KAAAC,KAAA;AA4NM,UAAI;AACF,cAAM,UAAU,MAAM,KAAK,cAAc;AAAA,UACvC,gBAAgB;AAAA,QAClB,CAAC;AACD,cAAM,OAAO;AAAA,UACX,QAAQ;AAAA,UACR;AAAA,UACA,MAAM,KAAK,UAAU,OAAO;AAAA,UAC5B,SAAQD,MAAA,KAAK,oBAAL,gBAAAA,IAAsB;AAAA,QAChC;AAEA,cAAM,WAAW,MAAM,MAAM,UAAU,IAAI;AAE3C,YAAI,SAAS,WAAW,OAAO,KAAK,gBAAgB,CAAC,WAAW;AAC9D,eAAK,sBAAsB,2BAA2B,QAAQ;AAC9D,cAAI;AACF,kBAAM,SAAS,MAAM,KAAK,KAAK,cAAc;AAAA,cAC3C,WAAW,KAAK;AAAA,cAChB,qBAAqB,KAAK;AAAA,YAC5B,CAAC;AACD,gBAAI,WAAW,cAAc;AAC3B,oBAAM,QAAQ,IAAI,kBAAkB;AACpC,eAAAC,MAAA,KAAK,YAAL,gBAAAA,IAAA,WAAe;AACf;AAAA,YACF;AAAA,UACF,SAAS,OAAO;AACd,uBAAK,YAAL,8BAAe;AACf;AAAA,UACF;AACA,iBAAO,QAAQ,IAAI;AAAA,QACrB;AAEA,YAAI,CAAC,SAAS,IAAI;AAChB,gBAAM,OAAO,MAAM,SAAS,KAAK,EAAE,MAAM,MAAM,IAAI;AACnD,gBAAM,QAAQ,IAAI,eAAe;AAAA,YAC/B,SAAS,sDAAsD,SAAS,MAAM,MAAM,IAAI;AAAA,UAC1F,CAAC;AACD,qBAAK,YAAL,8BAAe;AACf;AAAA,QACF;AAAA,MACF,SAAS,OAAO;AACd,mBAAK,YAAL,8BAAe;AACf;AAAA,MACF;AAAA,IACF;AACA,UAAM,QAAQ;AAAA,EAChB;AACF;;;AQ3QA,IAAAE,yBAIO;AAoBA,IAAM,mBAAN,MAA+C;AAAA,EAuBpD,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAIG;AApBH,SAAQ,2BAA2B;AACnC,SAAiB,sBAAsB;AAAA,MACrC,0BAA0B;AAAA,MAC1B,sBAAsB;AAAA,MACtB,6BAA6B;AAAA,MAC7B,YAAY;AAAA,IACd;AAeE,SAAK,MAAM,IAAI,IAAI,GAAG;AACtB,SAAK,UAAU;AACf,SAAK,eAAe;AAAA,EACtB;AAAA,EAEA,MAAc,cACZ,MACiC;AACjC,UAAM,UAAkC;AAAA,MACtC,GAAG,KAAK;AAAA,MACR,GAAG;AAAA,MACH,wBAAwB;AAAA,IAC1B;AAEA,QAAI,KAAK,WAAW;AAClB,cAAQ,gBAAgB,IAAI,KAAK;AAAA,IACnC;AAEA,QAAI,KAAK,cAAc;AACrB,YAAM,SAAS,MAAM,KAAK,aAAa,OAAO;AAC9C,UAAI,iCAAQ,cAAc;AACxB,gBAAQ,eAAe,IAAI,UAAU,OAAO,YAAY;AAAA,MAC1D;AAAA,IACF;AAEA,eAAO;AAAA,MACL;AAAA,MACA,UAAU,OAAO;AAAA,UACjB,uDAA+B;AAAA,IACjC;AAAA,EACF;AAAA,EAEA,MAAM,QAAuB;AAC3B,QAAI,KAAK,iBAAiB;AACxB,YAAM,IAAI,eAAe;AAAA,QACvB,SACE;AAAA,MACJ,CAAC;AAAA,IACH;AACA,SAAK,kBAAkB,IAAI,gBAAgB;AAE3C,SAAK,KAAK,eAAe;AAAA,EAC3B;AAAA,EAEA,MAAM,QAAuB;AApG/B,QAAAC,KAAAC,KAAA;AAqGI,KAAAD,MAAA,KAAK,yBAAL,gBAAAA,IAA2B;AAC3B,QAAI;AACF,UACE,KAAK,aACL,KAAK,mBACL,CAAC,KAAK,gBAAgB,OAAO,SAC7B;AACA,cAAM,UAAU,MAAM,KAAK,cAAc,CAAC,CAAC;AAC3C,cAAM,MAAM,KAAK,KAAK;AAAA,UACpB,QAAQ;AAAA,UACR;AAAA,UACA,QAAQ,KAAK,gBAAgB;AAAA,QAC/B,CAAC,EAAE,MAAM,MAAM,MAAS;AAAA,MAC1B;AAAA,IACF,SAAQ;AAAA,IAAC;AAET,KAAAC,MAAA,KAAK,oBAAL,gBAAAA,IAAsB;AACtB,eAAK,YAAL;AAAA,EACF;AAAA,EAEA,MAAM,KAAK,SAAwC;AACjD,UAAM,UAAU,OAAO,YAAqB,UAAyB;AA1HzE,UAAAD,KAAAC,KAAA;AA2HM,UAAI;AACF,cAAM,UAAU,MAAM,KAAK,cAAc;AAAA,UACvC,gBAAgB;AAAA,UAChB,QAAQ;AAAA,QACV,CAAC;AAED,cAAM,OAAO;AAAA,UACX,QAAQ;AAAA,UACR;AAAA,UACA,MAAM,KAAK,UAAU,OAAO;AAAA,UAC5B,SAAQD,MAAA,KAAK,oBAAL,gBAAAA,IAAsB;AAAA,QAChC;AAEA,cAAM,WAAW,MAAM,MAAM,KAAK,KAAK,IAAI;AAE3C,cAAM,YAAY,SAAS,QAAQ,IAAI,gBAAgB;AACvD,YAAI,WAAW;AACb,eAAK,YAAY;AAAA,QACnB;AAEA,YAAI,SAAS,WAAW,OAAO,KAAK,gBAAgB,CAAC,WAAW;AAC9D,eAAK,sBAAsB,2BAA2B,QAAQ;AAC9D,cAAI;AACF,kBAAM,SAAS,MAAM,KAAK,KAAK,cAAc;AAAA,cAC3C,WAAW,KAAK;AAAA,cAChB,qBAAqB,KAAK;AAAA,YAC5B,CAAC;AACD,gBAAI,WAAW,cAAc;AAC3B,oBAAME,SAAQ,IAAI,kBAAkB;AACpC,oBAAMA;AAAA,YACR;AAAA,UACF,SAASA,QAAO;AACd,aAAAD,MAAA,KAAK,YAAL,gBAAAA,IAAA,WAAeC;AACf,kBAAMA;AAAA,UACR;AACA,iBAAO,QAAQ,IAAI;AAAA,QACrB;AAGA,YAAI,SAAS,WAAW,KAAK;AAG3B,cAAI,CAAC,KAAK,sBAAsB;AAC9B,iBAAK,KAAK,eAAe;AAAA,UAC3B;AACA;AAAA,QACF;AAEA,YAAI,CAAC,SAAS,IAAI;AAChB,gBAAM,OAAO,MAAM,SAAS,KAAK,EAAE,MAAM,MAAM,IAAI;AACnD,cAAI,eAAe,uDAAuD,SAAS,MAAM,MAAM,IAAI;AAGnG,cAAI,SAAS,WAAW,KAAK;AAC3B,4BACE;AAAA,UACJ;AAEA,gBAAMA,SAAQ,IAAI,eAAe;AAAA,YAC/B,SAAS;AAAA,UACX,CAAC;AACD,qBAAK,YAAL,8BAAeA;AACf,gBAAMA;AAAA,QACR;AAEA,cAAM,cAAc,SAAS,QAAQ,IAAI,cAAc,KAAK;AAC5D,YAAI,YAAY,SAAS,kBAAkB,GAAG;AAC5C,gBAAM,OAAO,MAAM,SAAS,KAAK;AACjC,gBAAM,WAA6B,MAAM,QAAQ,IAAI,IACjD,KAAK,IAAI,CAAC,MAAe,qBAAqB,MAAM,CAAC,CAAC,IACtD,CAAC,qBAAqB,MAAM,IAAI,CAAC;AACrC,qBAAW,KAAK,SAAU,YAAK,cAAL,8BAAiB;AAC3C;AAAA,QACF;AAEA,YAAI,YAAY,SAAS,mBAAmB,GAAG;AAC7C,cAAI,CAAC,SAAS,MAAM;AAClB,kBAAMA,SAAQ,IAAI,eAAe;AAAA,cAC/B,SACE;AAAA,YACJ,CAAC;AACD,uBAAK,YAAL,8BAAeA;AACf,kBAAMA;AAAA,UACR;AAEA,gBAAM,SAAS,SAAS,KACrB,YAAY,IAAI,kBAAkB,CAAC,EACnC,YAAY,IAAI,+CAAwB,CAAC;AAC5C,gBAAM,SAAS,OAAO,UAAU;AAEhC,gBAAM,gBAAgB,YAAY;AArN5C,gBAAAF,KAAAC,KAAAE;AAsNY,gBAAI;AACF,qBAAO,MAAM;AACX,sBAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,oBAAI,KAAM;AACV,sBAAM,EAAE,OAAO,KAAK,IAAI;AACxB,oBAAI,UAAU,WAAW;AACvB,sBAAI;AACF,0BAAM,MAAM,qBAAqB,MAAM,KAAK,MAAM,IAAI,CAAC;AACvD,qBAAAH,MAAA,KAAK,cAAL,gBAAAA,IAAA,WAAiB;AAAA,kBACnB,SAASE,QAAO;AACd,0BAAM,IAAI,IAAI,eAAe;AAAA,sBAC3B,SACE;AAAA,sBACF,OAAOA;AAAA,oBACT,CAAC;AACD,qBAAAD,MAAA,KAAK,YAAL,gBAAAA,IAAA,WAAe;AAAA,kBACjB;AAAA,gBACF;AAAA,cACF;AAAA,YACF,SAASC,QAAO;AACd,kBAAIA,kBAAiB,SAASA,OAAM,SAAS,cAAc;AACzD;AAAA,cACF;AACA,eAAAC,MAAA,KAAK,YAAL,gBAAAA,IAAA,WAAeD;AAAA,YACjB;AAAA,UACF;AAEA,wBAAc;AACd;AAAA,QACF;AAEA,cAAM,QAAQ,IAAI,eAAe;AAAA,UAC/B,SAAS,sDAAsD,WAAW;AAAA,QAC5E,CAAC;AACD,mBAAK,YAAL,8BAAe;AACf,cAAM;AAAA,MACR,SAAS,OAAO;AACd,mBAAK,YAAL,8BAAe;AACf,cAAM;AAAA,MACR;AAAA,IACF;AAEA,UAAM,QAAQ;AAAA,EAChB;AAAA,EAEQ,yBAAyB,SAAyB;AACxD,UAAM;AAAA,MACJ;AAAA,MACA;AAAA,MACA;AAAA,IACF,IAAI,KAAK;AACT,WAAO,KAAK;AAAA,MACV,2BAA2B,KAAK,IAAI,6BAA6B,OAAO;AAAA,MACxE;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,iCAAuC;AA/QjD,QAAAF;AAgRI,UAAM,EAAE,WAAW,IAAI,KAAK;AAC5B,QAAI,aAAa,KAAK,KAAK,4BAA4B,YAAY;AACjE,OAAAA,MAAA,KAAK,YAAL,gBAAAA,IAAA;AAAA;AAAA,QACE,IAAI,eAAe;AAAA,UACjB,SAAS,4DAA4D,UAAU;AAAA,QACjF,CAAC;AAAA;AAEH;AAAA,IACF;AAEA,UAAM,QAAQ,KAAK,yBAAyB,KAAK,wBAAwB;AACzE,SAAK,4BAA4B;AACjC,eAAW,YAAY;AA5R3B,UAAAA;AA6RM,WAAIA,MAAA,KAAK,oBAAL,gBAAAA,IAAsB,OAAO,QAAS;AAC1C,YAAM,KAAK,eAAe,OAAO,KAAK,kBAAkB;AAAA,IAC1D,GAAG,KAAK;AAAA,EACV;AAAA;AAAA,EAGA,MAAc,eACZ,YAAqB,OACrB,aACe;AAtSnB,QAAAA,KAAAC,KAAA;AAuSI,QAAI;AACF,YAAM,UAAU,MAAM,KAAK,cAAc;AAAA,QACvC,QAAQ;AAAA,MACV,CAAC;AACD,UAAI,aAAa;AACf,gBAAQ,eAAe,IAAI;AAAA,MAC7B;AAEA,YAAM,WAAW,MAAM,MAAM,KAAK,IAAI,MAAM;AAAA,QAC1C,QAAQ;AAAA,QACR;AAAA,QACA,SAAQD,MAAA,KAAK,oBAAL,gBAAAA,IAAsB;AAAA,MAChC,CAAC;AAED,YAAM,YAAY,SAAS,QAAQ,IAAI,gBAAgB;AACvD,UAAI,WAAW;AACb,aAAK,YAAY;AAAA,MACnB;AAEA,UAAI,SAAS,WAAW,OAAO,KAAK,gBAAgB,CAAC,WAAW;AAC9D,aAAK,sBAAsB,2BAA2B,QAAQ;AAC9D,YAAI;AACF,gBAAM,SAAS,MAAM,KAAK,KAAK,cAAc;AAAA,YAC3C,WAAW,KAAK;AAAA,YAChB,qBAAqB,KAAK;AAAA,UAC5B,CAAC;AACD,cAAI,WAAW,cAAc;AAC3B,kBAAM,QAAQ,IAAI,kBAAkB;AACpC,aAAAC,MAAA,KAAK,YAAL,gBAAAA,IAAA,WAAe;AACf;AAAA,UACF;AAAA,QACF,SAAS,OAAO;AACd,qBAAK,YAAL,8BAAe;AACf;AAAA,QACF;AACA,eAAO,KAAK,eAAe,MAAM,WAAW;AAAA,MAC9C;AAEA,UAAI,SAAS,WAAW,KAAK;AAC3B;AAAA,MACF;AAEA,UAAI,CAAC,SAAS,MAAM,CAAC,SAAS,MAAM;AAClC,cAAM,QAAQ,IAAI,eAAe;AAAA,UAC/B,SAAS,6CAA6C,SAAS,MAAM,IAAI,SAAS,UAAU;AAAA,QAC9F,CAAC;AACD,mBAAK,YAAL,8BAAe;AACf;AAAA,MACF;AAEA,YAAM,SAAS,SAAS,KACrB,YAAY,IAAI,kBAAkB,CAAC,EACnC,YAAY,IAAI,+CAAwB,CAAC;AAC5C,YAAM,SAAS,OAAO,UAAU;AAEhC,YAAM,gBAAgB,YAAY;AA9VxC,YAAAD,KAAAC,KAAAE,KAAAC;AA+VQ,YAAI;AACF,iBAAO,MAAM;AACX,kBAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,gBAAI,KAAM;AACV,kBAAM,EAAE,OAAO,MAAM,GAAG,IAAI;AAM5B,gBAAI,IAAI;AACN,mBAAK,qBAAqB;AAAA,YAC5B;AAEA,gBAAI,UAAU,WAAW;AACvB,kBAAI;AACF,sBAAM,MAAM,qBAAqB,MAAM,KAAK,MAAM,IAAI,CAAC;AACvD,iBAAAJ,MAAA,KAAK,cAAL,gBAAAA,IAAA,WAAiB;AAAA,cACnB,SAAS,OAAO;AACd,sBAAM,IAAI,IAAI,eAAe;AAAA,kBAC3B,SAAS;AAAA,kBACT,OAAO;AAAA,gBACT,CAAC;AACD,iBAAAC,MAAA,KAAK,YAAL,gBAAAA,IAAA,WAAe;AAAA,cACjB;AAAA,YACF;AAAA,UACF;AAAA,QACF,SAAS,OAAO;AACd,cAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AACzD;AAAA,UACF;AACA,WAAAE,MAAA,KAAK,YAAL,gBAAAA,IAAA,WAAe;AACf,cAAI,GAACC,MAAA,KAAK,oBAAL,gBAAAA,IAAsB,OAAO,UAAS;AACzC,iBAAK,+BAA+B;AAAA,UACtC;AAAA,QACF;AAAA,MACF;AAEA,WAAK,uBAAuB;AAAA,QAC1B,OAAO,MAAM,OAAO,OAAO;AAAA,MAC7B;AACA,WAAK,2BAA2B;AAChC,oBAAc;AAAA,IAChB,SAAS,OAAO;AACd,UAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AACzD;AAAA,MACF;AACA,iBAAK,YAAL,8BAAe;AACf,UAAI,GAAC,UAAK,oBAAL,mBAAsB,OAAO,UAAS;AACzC,aAAK,+BAA+B;AAAA,MACtC;AAAA,IACF;AAAA,EACF;AACF;;;ACtVO,SAAS,mBAAmB,QAA0C;AAC3E,UAAQ,OAAO,MAAM;AAAA,IACnB,KAAK;AACH,aAAO,IAAI,gBAAgB,MAAM;AAAA,IACnC,KAAK;AACH,aAAO,IAAI,iBAAiB,MAAM;AAAA,IACpC;AACE,YAAM,IAAI,eAAe;AAAA,QACvB,SACE;AAAA,MACJ,CAAC;AAAA,EACL;AACF;AAEO,SAAS,qBACd,WAC2B;AAC3B,SACE,WAAW,aACX,OAAO,UAAU,UAAU,cAC3B,UAAU,aACV,OAAO,UAAU,SAAS,cAC1B,WAAW,aACX,OAAO,UAAU,UAAU;AAE/B;;;AXrCA,IAAM,iBAAiB;AAWvB,eAAsB,gBACpB,QACoB;AACpB,QAAM,SAAS,IAAI,iBAAiB,MAAM;AAC1C,QAAM,OAAO,KAAK;AAClB,SAAO;AACT;AAoDA,IAAM,mBAAN,MAA4C;AAAA,EAY1C,YAAY;AAAA,IACV,WAAW;AAAA,IACX,MAAAC,QAAO;AAAA,IACP;AAAA,EACF,GAAoB;AAZpB,SAAQ,mBAAmB;AAC3B,SAAQ,mBAGJ,oBAAI,IAAI;AACZ,SAAQ,qBAAyC,CAAC;AAClD,SAAQ,WAAW;AAOjB,SAAK,kBAAkB;AAEvB,QAAI,qBAAqB,eAAe,GAAG;AACzC,WAAK,YAAY;AAAA,IACnB,OAAO;AACL,WAAK,YAAY,mBAAmB,eAAe;AAAA,IACrD;AAEA,SAAK,UAAU,UAAU,MAAM,KAAK,QAAQ;AAC5C,SAAK,UAAU,UAAU,CAAC,UAAiB,KAAK,QAAQ,KAAK;AAC7D,SAAK,UAAU,YAAY,aAAW;AACpC,UAAI,YAAY,SAAS;AAIvB,aAAK;AAAA,UACH,IAAI,eAAe;AAAA,YACjB,SAAS;AAAA,UACX,CAAC;AAAA,QACH;AACA;AAAA,MACF;AAEA,WAAK,WAAW,OAAO;AAAA,IACzB;AAEA,SAAK,aAAa;AAAA,MAChB,MAAAA;AAAA,MACA,SAAS;AAAA,IACX;AAAA,EACF;AAAA,EAEA,MAAM,OAAsB;AAC1B,QAAI;AACF,YAAM,KAAK,UAAU,MAAM;AAC3B,WAAK,WAAW;AAEhB,YAAM,SAAS,MAAM,KAAK,QAAQ;AAAA,QAChC,SAAS;AAAA,UACP,QAAQ;AAAA,UACR,QAAQ;AAAA,YACN,iBAAiB;AAAA,YACjB,cAAc,CAAC;AAAA,YACf,YAAY,KAAK;AAAA,UACnB;AAAA,QACF;AAAA,QACA,cAAc;AAAA,MAChB,CAAC;AAED,UAAI,WAAW,QAAW;AACxB,cAAM,IAAI,eAAe;AAAA,UACvB,SAAS;AAAA,QACX,CAAC;AAAA,MACH;AAEA,UAAI,CAAC,4BAA4B,SAAS,OAAO,eAAe,GAAG;AACjE,cAAM,IAAI,eAAe;AAAA,UACvB,SAAS,+CAA+C,OAAO,eAAe;AAAA,QAChF,CAAC;AAAA,MACH;AAEA,WAAK,qBAAqB,OAAO;AAGjC,YAAM,KAAK,aAAa;AAAA,QACtB,QAAQ;AAAA,MACV,CAAC;AAED,aAAO;AAAA,IACT,SAAS,OAAO;AACd,YAAM,KAAK,MAAM;AACjB,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAM,QAAuB;AAnN/B,QAAAC;AAoNI,QAAI,KAAK,SAAU;AACnB,YAAMA,MAAA,KAAK,cAAL,gBAAAA,IAAgB;AACtB,SAAK,QAAQ;AAAA,EACf;AAAA,EAEQ,iBAAiB,QAAsB;AAC7C,YAAQ,QAAQ;AAAA,MACd,KAAK;AACH;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AACH,YAAI,CAAC,KAAK,mBAAmB,OAAO;AAClC,gBAAM,IAAI,eAAe;AAAA,YACvB,SAAS;AAAA,UACX,CAAC;AAAA,QACH;AACA;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AACH,YAAI,CAAC,KAAK,mBAAmB,WAAW;AACtC,gBAAM,IAAI,eAAe;AAAA,YACvB,SAAS;AAAA,UACX,CAAC;AAAA,QACH;AACA;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AACH,YAAI,CAAC,KAAK,mBAAmB,SAAS;AACpC,gBAAM,IAAI,eAAe;AAAA,YACvB,SAAS;AAAA,UACX,CAAC;AAAA,QACH;AACA;AAAA,MACF;AACE,cAAM,IAAI,eAAe;AAAA,UACvB,SAAS,uBAAuB,MAAM;AAAA,QACxC,CAAC;AAAA,IACL;AAAA,EACF;AAAA,EAEA,MAAc,QAAqC;AAAA,IACjD;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAIwB;AACtB,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,UAAI,KAAK,UAAU;AACjB,eAAO;AAAA,UACL,IAAI,eAAe;AAAA,YACjB,SAAS;AAAA,UACX,CAAC;AAAA,QACH;AAAA,MACF;AAEA,WAAK,iBAAiB,QAAQ,MAAM;AAEpC,YAAM,SAAS,mCAAS;AACxB,uCAAQ;AAER,YAAM,YAAY,KAAK;AACvB,YAAM,iBAAiC;AAAA,QACrC,GAAG;AAAA,QACH,SAAS;AAAA,QACT,IAAI;AAAA,MACN;AAEA,YAAM,UAAU,MAAM;AACpB,aAAK,iBAAiB,OAAO,SAAS;AAAA,MACxC;AAEA,WAAK,iBAAiB,IAAI,WAAW,cAAY;AAC/C,YAAI,iCAAQ,SAAS;AACnB,iBAAO;AAAA,YACL,IAAI,eAAe;AAAA,cACjB,SAAS;AAAA,cACT,OAAO,OAAO;AAAA,YAChB,CAAC;AAAA,UACH;AAAA,QACF;AAEA,YAAI,oBAAoB,OAAO;AAC7B,iBAAO,OAAO,QAAQ;AAAA,QACxB;AAEA,YAAI;AACF,gBAAM,SAAS,aAAa,MAAM,SAAS,MAAM;AACjD,kBAAQ,MAAM;AAAA,QAChB,SAAS,OAAO;AACd,gBAAM,aAAa,IAAI,eAAe;AAAA,YACpC,SAAS;AAAA,YACT,OAAO;AAAA,UACT,CAAC;AACD,iBAAO,UAAU;AAAA,QACnB;AAAA,MACF,CAAC;AAED,WAAK,UAAU,KAAK,cAAc,EAAE,MAAM,WAAS;AACjD,gBAAQ;AACR,eAAO,KAAK;AAAA,MACd,CAAC;AAAA,IACH,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,UAAU;AAAA,IACtB;AAAA,IACA;AAAA,EACF,IAGI,CAAC,GAA6B;AAChC,QAAI;AACF,aAAO,KAAK,QAAQ;AAAA,QAClB,SAAS,EAAE,QAAQ,cAAc,OAAO;AAAA,QACxC,cAAc;AAAA,QACd;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAc,SAAS;AAAA,IACrB,MAAAD;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAI4B;AAC1B,QAAI;AACF,aAAO,KAAK,QAAQ;AAAA,QAClB,SAAS,EAAE,QAAQ,cAAc,QAAQ,EAAE,MAAAA,OAAM,WAAW,KAAK,EAAE;AAAA,QACnE,cAAc;AAAA,QACd,SAAS;AAAA,UACP,QAAQ,mCAAS;AAAA,QACnB;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAc,sBAAsB;AAAA,IAClC;AAAA,IACA;AAAA,EACF,IAGI,CAAC,GAAiC;AACpC,QAAI;AACF,aAAO,KAAK,QAAQ;AAAA,QAClB,SAAS,EAAE,QAAQ,kBAAkB,OAAO;AAAA,QAC5C,cAAc;AAAA,QACd;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAc,qBAAqB;AAAA,IACjC;AAAA,IACA;AAAA,EACF,GAGgC;AAC9B,QAAI;AACF,aAAO,KAAK,QAAQ;AAAA,QAClB,SAAS,EAAE,QAAQ,kBAAkB,QAAQ,EAAE,IAAI,EAAE;AAAA,QACrD,cAAc;AAAA,QACd;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAc,8BAA8B;AAAA,IAC1C;AAAA,EACF,IAEI,CAAC,GAAyC;AAC5C,QAAI;AACF,aAAO,KAAK,QAAQ;AAAA,QAClB,SAAS,EAAE,QAAQ,2BAA2B;AAAA,QAC9C,cAAc;AAAA,QACd;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAc,oBAAoB;AAAA,IAChC;AAAA,IACA;AAAA,EACF,IAGI,CAAC,GAA+B;AAClC,QAAI;AACF,aAAO,KAAK,QAAQ;AAAA,QAClB,SAAS,EAAE,QAAQ,gBAAgB,OAAO;AAAA,QAC1C,cAAc;AAAA,QACd;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAc,kBAAkB;AAAA,IAC9B,MAAAA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAI6B;AAC3B,QAAI;AACF,aAAO,KAAK,QAAQ;AAAA,QAClB,SAAS,EAAE,QAAQ,eAAe,QAAQ,EAAE,MAAAA,OAAM,WAAW,KAAK,EAAE;AAAA,QACpE,cAAc;AAAA,QACd;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,MAAc,aAAa,cAA2C;AACpE,UAAM,sBAA2C;AAAA,MAC/C,GAAG;AAAA,MACH,SAAS;AAAA,IACX;AACA,UAAM,KAAK,UAAU,KAAK,mBAAmB;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,MAAsD;AAAA,IAC1D,UAAU;AAAA,EACZ,IAEI,CAAC,GAAsC;AAld7C,QAAAC;AAmdI,UAAM,QAA8B,CAAC;AAErC,QAAI;AACF,YAAM,kBAAkB,MAAM,KAAK,UAAU;AAE7C,iBAAW,EAAE,MAAAD,OAAM,aAAa,YAAY,KAAK,gBAAgB,OAAO;AACtE,YAAI,YAAY,eAAe,EAAEA,SAAQ,UAAU;AACjD;AAAA,QACF;AAEA,cAAM,OAAO;AAEb,cAAM,UAAU,OACd,MACA,YAC4B;AAletC,cAAAC;AAmeU,WAAAA,MAAA,mCAAS,gBAAT,gBAAAA,IAAsB;AACtB,iBAAO,KAAK,SAAS,EAAE,MAAAD,OAAM,MAAM,QAAQ,CAAC;AAAA,QAC9C;AAEA,cAAM,kBACJ,YAAY,kBACR,oCAAY;AAAA,UACV;AAAA,UACA,iBAAa,mCAAW;AAAA,YACtB,GAAG;AAAA,YACH,aAAYC,MAAA,YAAY,eAAZ,OAAAA,MAA0B,CAAC;AAAA,YACvC,sBAAsB;AAAA,UACxB,CAAgB;AAAA,UAChB;AAAA,QACF,CAAC,QACD,6BAAK;AAAA,UACH;AAAA,UACA,aAAa,QAAQD,KAAI,EAAE;AAAA,UAC3B;AAAA,QACF,CAAC;AAEP,cAAMA,KAAI,IAAI;AAAA,MAChB;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,YAAM;AAAA,IACR;AAAA,EACF;AAAA,EAEA,cAAc;AAAA,IACZ;AAAA,IACA;AAAA,EACF,IAGI,CAAC,GAAiC;AACpC,WAAO,KAAK,sBAAsB,EAAE,QAAQ,QAAQ,CAAC;AAAA,EACvD;AAAA,EAEA,aAAa;AAAA,IACX;AAAA,IACA;AAAA,EACF,GAGgC;AAC9B,WAAO,KAAK,qBAAqB,EAAE,KAAK,QAAQ,CAAC;AAAA,EACnD;AAAA,EAEA,sBAAsB;AAAA,IACpB;AAAA,EACF,IAEI,CAAC,GAAyC;AAC5C,WAAO,KAAK,8BAA8B,EAAE,QAAQ,CAAC;AAAA,EACvD;AAAA,EAEA,YAAY;AAAA,IACV;AAAA,IACA;AAAA,EACF,IAGI,CAAC,GAA+B;AAClC,WAAO,KAAK,oBAAoB,EAAE,QAAQ,QAAQ,CAAC;AAAA,EACrD;AAAA,EAEA,UAAU;AAAA,IACR,MAAAA;AAAA,IACA,WAAW;AAAA,IACX;AAAA,EACF,GAI6B;AAC3B,WAAO,KAAK,kBAAkB,EAAE,MAAAA,OAAM,MAAM,QAAQ,CAAC;AAAA,EACvD;AAAA,EAEQ,UAAgB;AACtB,QAAI,KAAK,SAAU;AAEnB,SAAK,WAAW;AAChB,UAAM,QAAQ,IAAI,eAAe;AAAA,MAC/B,SAAS;AAAA,IACX,CAAC;AAED,eAAW,WAAW,KAAK,iBAAiB,OAAO,GAAG;AACpD,cAAQ,KAAK;AAAA,IACf;AAEA,SAAK,iBAAiB,MAAM;AAAA,EAC9B;AAAA,EAEQ,QAAQ,OAAsB;AACpC,QAAI,KAAK,iBAAiB;AACxB,WAAK,gBAAgB,KAAK;AAAA,IAC5B;AAAA,EACF;AAAA,EAEQ,WAAW,UAAgD;AACjE,UAAM,YAAY,OAAO,SAAS,EAAE;AACpC,UAAM,UAAU,KAAK,iBAAiB,IAAI,SAAS;AAEnD,QAAI,YAAY,QAAW;AACzB,YAAM,IAAI,eAAe;AAAA,QACvB,SAAS,kEAAkE,KAAK;AAAA,UAC9E;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAEA,SAAK,iBAAiB,OAAO,SAAS;AAEtC;AAAA,MACE,YAAY,WACR,WACA,IAAI,eAAe;AAAA,QACjB,SAAS,SAAS,MAAM;AAAA,QACxB,MAAM,SAAS,MAAM;AAAA,QACrB,MAAM,SAAS,MAAM;AAAA,QACrB,OAAO,SAAS;AAAA,MAClB,CAAC;AAAA,IACP;AAAA,EACF;AACF;","names":["import_provider_utils","name","import_v4","import_v4","import_provider","name","marker","symbol","_a","_b","_a","_b","pkceChallenge","codeVerifier","tokens","_a","_b","_c","import_provider_utils","_a","_b","error","_c","_d","name","_a"]}