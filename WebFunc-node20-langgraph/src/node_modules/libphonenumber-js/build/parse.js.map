{"version":3,"file":"parse.js","names":["_constants","require","_ParseError","_interopRequireDefault","_metadata","_isViablePhoneNumber","_interopRequireWildcard","_extractExtension","_parseIncompletePhoneNumber","_getCountryCallingCode","_isPossible","_PhoneNumber","_matchesEntirely","_extractCountryCallingCode","_extractNationalNumber","_getCountryByCallingCode","_extractFormattedPhoneNumberFromPossibleRfc3966NumberUri","e","t","WeakMap","r","n","__esModule","o","i","f","__proto__","_typeof","has","get","set","_t","hasOwnProperty","call","Object","defineProperty","getOwnPropertyDescriptor","MAX_INPUT_STRING_LENGTH","PHONE_NUMBER_START_PATTERN","RegExp","PLUS_CHARS","VALID_DIGITS","AFTER_PHONE_NUMBER_END_PATTERN","USE_NON_GEOGRAPHIC_COUNTRY_CODE","parse","text","options","metadata","Metadata","defaultCountry","hasCountry","v2","ParseError","Error","concat","_parseInput","parseInput","extract","formattedPhoneNumber","number","ext","error","_parsePhoneNumber","parsePhoneNumber","defaultCallingCode","country","nationalNumber","countryCallingCode","countryCallingCodeSource","carrierCode","hasSelectedNumberingPlan","length","MIN_LENGTH_FOR_NSN","MAX_LENGTH_FOR_NSN","phoneNumber","PhoneNumber","__countryCallingCodeSource","valid","extended","matchesEntirely","nationalNumberPattern","result","possible","possibleLengths","isPossibleNumber","phone","extractFormattedPhoneNumber","throwOnError","startsAt","search","slice","replace","extractFormattedPhoneNumberFromPossibleRfc3966NumberUri","isViablePhoneNumber","isViablePhoneNumberStart","withExtensionStripped","extractExtension","_extractCountryCallin","extractCountryCallingCode","parseIncompletePhoneNumber","undefined","selectNumberingPlan","isNonGeographicCallingCode","getCountryCallingCode","_extractNationalNumbe","extractNationalNumber","exactCountry","getCountryByCallingCode"],"sources":["../source/parse.js"],"sourcesContent":["// This is a port of Google Android `libphonenumber`'s\r\n// `phonenumberutil.js` of December 31th, 2018.\r\n//\r\n// https://github.com/googlei18n/libphonenumber/commits/master/javascript/i18n/phonenumbers/phonenumberutil.js\r\n\r\nimport {\r\n\tVALID_DIGITS,\r\n\tPLUS_CHARS,\r\n\tMIN_LENGTH_FOR_NSN,\r\n\tMAX_LENGTH_FOR_NSN\r\n} from './constants.js'\r\n\r\nimport ParseError from './ParseError.js'\r\nimport Metadata from './metadata.js'\r\nimport isViablePhoneNumber, { isViablePhoneNumberStart } from './helpers/isViablePhoneNumber.js'\r\nimport extractExtension from './helpers/extension/extractExtension.js'\r\nimport parseIncompletePhoneNumber from './parseIncompletePhoneNumber.js'\r\nimport getCountryCallingCode from './getCountryCallingCode.js'\r\nimport { isPossibleNumber } from './isPossible.js'\r\n// import { parseRFC3966 } from './helpers/RFC3966.js'\r\nimport PhoneNumber from './PhoneNumber.js'\r\nimport matchesEntirely from './helpers/matchesEntirely.js'\r\nimport extractCountryCallingCode from './helpers/extractCountryCallingCode.js'\r\nimport extractNationalNumber from './helpers/extractNationalNumber.js'\r\n// import stripIddPrefix from './helpers/stripIddPrefix.js'\r\nimport getCountryByCallingCode from './helpers/getCountryByCallingCode.js'\r\nimport extractFormattedPhoneNumberFromPossibleRfc3966NumberUri from './helpers/extractFormattedPhoneNumberFromPossibleRfc3966NumberUri.js'\r\n\r\n// We don't allow input strings for parsing to be longer than 250 chars.\r\n// This prevents malicious input from consuming CPU.\r\nconst MAX_INPUT_STRING_LENGTH = 250\r\n\r\n// This consists of the plus symbol, digits, and arabic-indic digits.\r\nconst PHONE_NUMBER_START_PATTERN = new RegExp('[' + PLUS_CHARS + VALID_DIGITS + ']')\r\n\r\n// Regular expression of trailing characters that we want to remove.\r\n// A trailing `#` is sometimes used when writing phone numbers with extensions in US.\r\n// Example: \"+1 (645) 123 1234-910#\" number has extension \"910\".\r\nconst AFTER_PHONE_NUMBER_END_PATTERN = new RegExp('[^' + VALID_DIGITS + '#' + ']+$')\r\n\r\nconst USE_NON_GEOGRAPHIC_COUNTRY_CODE = false\r\n\r\n// Examples:\r\n//\r\n// ```js\r\n// parse('8 (800) 555-35-35', 'RU')\r\n// parse('8 (800) 555-35-35', 'RU', metadata)\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } })\r\n// parse('8 (800) 555-35-35', { country: { default: 'RU' } }, metadata)\r\n// parse('+7 800 555 35 35')\r\n// parse('+7 800 555 35 35', metadata)\r\n// ```\r\n//\r\n\r\n/**\r\n * Parses a phone number.\r\n *\r\n * parse('123456789', { defaultCountry: 'RU', v2: true }, metadata)\r\n * parse('123456789', { defaultCountry: 'RU' }, metadata)\r\n * parse('123456789', undefined, metadata)\r\n *\r\n * @param  {string} input\r\n * @param  {object} [options]\r\n * @param  {object} metadata\r\n * @return {object|PhoneNumber?} If `options.v2: true` flag is passed, it returns a `PhoneNumber?` instance. Otherwise, returns an object of shape `{ phone: '...', country: '...' }` (or just `{}` if no phone number was parsed).\r\n */\r\nexport default function parse(text, options, metadata) {\r\n\t// If assigning the `{}` default value is moved to the arguments above,\r\n\t// code coverage would decrease for some weird reason.\r\n\toptions = options || {}\r\n\r\n\tmetadata = new Metadata(metadata)\r\n\r\n\t// Validate `defaultCountry`.\r\n\tif (options.defaultCountry && !metadata.hasCountry(options.defaultCountry)) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\tthrow new Error(`Unknown country: ${options.defaultCountry}`)\r\n\t}\r\n\r\n\t// Parse the phone number.\r\n\tconst { number: formattedPhoneNumber, ext, error } = parseInput(text, options.v2, options.extract)\r\n\r\n\t// If the phone number is not viable then return nothing.\r\n\tif (!formattedPhoneNumber) {\r\n\t\tif (options.v2) {\r\n\t\t\tif (error === 'TOO_SHORT') {\r\n\t\t\t\tthrow new ParseError('TOO_SHORT')\r\n\t\t\t}\r\n\t\t\tthrow new ParseError('NOT_A_NUMBER')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\tconst {\r\n\t\tcountry,\r\n\t\tnationalNumber,\r\n\t\tcountryCallingCode,\r\n\t\tcountryCallingCodeSource,\r\n\t\tcarrierCode\r\n\t} = parsePhoneNumber(\r\n\t\tformattedPhoneNumber,\r\n\t\toptions.defaultCountry,\r\n\t\toptions.defaultCallingCode,\r\n\t\tmetadata\r\n\t)\r\n\r\n\tif (!metadata.hasSelectedNumberingPlan()) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('INVALID_COUNTRY')\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\tif (!nationalNumber || nationalNumber.length < MIN_LENGTH_FOR_NSN) {\r\n\t\t// Won't throw here because the regexp already demands length > 1.\r\n\t\t/* istanbul ignore if */\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_SHORT')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\t// Validate national (significant) number length.\r\n\t//\r\n\t// A sidenote:\r\n\t//\r\n\t// They say that sometimes national (significant) numbers\r\n\t// can be longer than `MAX_LENGTH_FOR_NSN` (e.g. in Germany).\r\n\t// https://github.com/googlei18n/libphonenumber/blob/7e1748645552da39c4e1ba731e47969d97bdb539/resources/phonenumber.proto#L36\r\n\t// Such numbers will just be discarded.\r\n\t//\r\n\tif (nationalNumber.length > MAX_LENGTH_FOR_NSN) {\r\n\t\tif (options.v2) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\t// Google's demo just throws an error in this case.\r\n\t\treturn {}\r\n\t}\r\n\r\n\tif (options.v2) {\r\n\t\tconst phoneNumber = new PhoneNumber(\r\n\t\t\tcountryCallingCode,\r\n\t\t\tnationalNumber,\r\n\t\t\tmetadata.metadata\r\n\t\t)\r\n\t\tif (country) {\r\n\t\t\tphoneNumber.country = country\r\n\t\t}\r\n\t\tif (carrierCode) {\r\n\t\t\tphoneNumber.carrierCode = carrierCode\r\n\t\t}\r\n\t\tif (ext) {\r\n\t\t\tphoneNumber.ext = ext\r\n\t\t}\r\n\t\tphoneNumber.__countryCallingCodeSource = countryCallingCodeSource\r\n\t\treturn phoneNumber\r\n\t}\r\n\r\n\t// Check if national phone number pattern matches the number.\r\n\t// National number pattern is different for each country,\r\n\t// even for those ones which are part of the \"NANPA\" group.\r\n\tconst valid = (options.extended ? metadata.hasSelectedNumberingPlan() : country) ?\r\n\t\tmatchesEntirely(nationalNumber, metadata.nationalNumberPattern()) :\r\n\t\tfalse\r\n\r\n\tif (!options.extended) {\r\n\t\treturn valid ? result(country, nationalNumber, ext) : {}\r\n\t}\r\n\r\n\t// isInternational: countryCallingCode !== undefined\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tcarrierCode,\r\n\t\tvalid,\r\n\t\tpossible: valid ? true : (\r\n\t\t\toptions.extended === true &&\r\n\t\t\tmetadata.possibleLengths() &&\r\n\t\t\tisPossibleNumber(nationalNumber, country, metadata) ? true : false\r\n\t\t),\r\n\t\tphone: nationalNumber,\r\n\t\text\r\n\t}\r\n}\r\n\r\n/**\r\n * Extracts a formatted phone number from text.\r\n * Doesn't guarantee that the extracted phone number\r\n * is a valid phone number (for example, doesn't validate its length).\r\n * @param  {string} text\r\n * @param  {boolean} [extract] — If `false`, then will parse the entire `text` as a phone number.\r\n * @param  {boolean} [throwOnError] — By default, it won't throw if the text is too long.\r\n * @return {string}\r\n * @example\r\n * // Returns \"(213) 373-4253\".\r\n * extractFormattedPhoneNumber(\"Call (213) 373-4253 for assistance.\")\r\n */\r\nfunction extractFormattedPhoneNumber(text, extract, throwOnError) {\r\n\tif (!text) {\r\n\t\treturn\r\n\t}\r\n\tif (text.length > MAX_INPUT_STRING_LENGTH) {\r\n\t\tif (throwOnError) {\r\n\t\t\tthrow new ParseError('TOO_LONG')\r\n\t\t}\r\n\t\treturn\r\n\t}\r\n\tif (extract === false) {\r\n\t\treturn text\r\n\t}\r\n\t// Attempt to extract a possible number from the string passed in\r\n\tconst startsAt = text.search(PHONE_NUMBER_START_PATTERN)\r\n\tif (startsAt < 0) {\r\n\t\treturn\r\n\t}\r\n\treturn text\r\n\t\t// Trim everything to the left of the phone number\r\n\t\t.slice(startsAt)\r\n\t\t// Remove trailing non-numerical characters\r\n\t\t.replace(AFTER_PHONE_NUMBER_END_PATTERN, '')\r\n}\r\n\r\n/**\r\n * @param  {string} text - Input.\r\n * @param  {boolean} v2 - Legacy API functions don't pass `v2: true` flag.\r\n * @param  {boolean} [extract] - Whether to extract a phone number from `text`, or attempt to parse the entire text as a phone number.\r\n * @return {object} `{ ?number, ?ext }`.\r\n */\r\nfunction parseInput(text, v2, extract) {\r\n\t// // Parse RFC 3966 phone number URI.\r\n\t// if (text && text.indexOf('tel:') === 0) {\r\n\t// \treturn parseRFC3966(text)\r\n\t// }\r\n\t// let number = extractFormattedPhoneNumber(text, extract, v2)\r\n\tlet number = extractFormattedPhoneNumberFromPossibleRfc3966NumberUri(text, {\r\n\t\textractFormattedPhoneNumber: (text) => extractFormattedPhoneNumber(text, extract, v2)\r\n\t})\r\n\t// If the phone number is not viable, then abort.\r\n\tif (!number) {\r\n\t\treturn {}\r\n\t}\r\n\tif (!isViablePhoneNumber(number)) {\r\n\t\tif (isViablePhoneNumberStart(number)) {\r\n\t\t\treturn { error: 'TOO_SHORT' }\r\n\t\t}\r\n\t\treturn {}\r\n\t}\r\n\t// Attempt to parse extension first, since it doesn't require region-specific\r\n\t// data and we want to have the non-normalised number here.\r\n\tconst withExtensionStripped = extractExtension(number)\r\n\tif (withExtensionStripped.ext) {\r\n\t\treturn withExtensionStripped\r\n\t}\r\n\treturn { number }\r\n}\r\n\r\n/**\r\n * Creates `parse()` result object.\r\n */\r\nfunction result(country, nationalNumber, ext) {\r\n\tconst result = {\r\n\t\tcountry,\r\n\t\tphone: nationalNumber\r\n\t}\r\n\tif (ext) {\r\n\t\tresult.ext = ext\r\n\t}\r\n\treturn result\r\n}\r\n\r\n/**\r\n * Parses a viable phone number.\r\n * @param {string} formattedPhoneNumber — Example: \"(213) 373-4253\".\r\n * @param {string} [defaultCountry]\r\n * @param {string} [defaultCallingCode]\r\n * @param {Metadata} metadata\r\n * @return {object} Returns `{ country: string?, countryCallingCode: string?, nationalNumber: string? }`.\r\n */\r\nfunction parsePhoneNumber(\r\n\tformattedPhoneNumber,\r\n\tdefaultCountry,\r\n\tdefaultCallingCode,\r\n\tmetadata\r\n) {\r\n\t// Extract calling code from phone number.\r\n\tlet { countryCallingCodeSource, countryCallingCode, number } = extractCountryCallingCode(\r\n\t\tparseIncompletePhoneNumber(formattedPhoneNumber),\r\n\t\tundefined,\r\n\t\tdefaultCountry,\r\n\t\tdefaultCallingCode,\r\n\t\tmetadata.metadata\r\n\t)\r\n\r\n\t// The exact country of the phone number\r\n\tlet country\r\n\r\n\t// If `formattedPhoneNumber` is passed in \"international\" format,\r\n\t// choose a country by `countryCallingCode`.\r\n\tif (countryCallingCode) {\r\n\t\tmetadata.selectNumberingPlan(countryCallingCode)\r\n\t}\r\n\t// Else, if `formattedPhoneNumber` is passed in \"national\" format,\r\n\t// then `number` is defined and `countryCallingCode` is `undefined`.\r\n\telse if (number && (defaultCountry || defaultCallingCode)) {\r\n\t\tmetadata.selectNumberingPlan(defaultCountry, defaultCallingCode)\r\n\t\tif (defaultCountry) {\r\n\t\t\tcountry = defaultCountry\r\n\t\t} else {\r\n\t\t\t/* istanbul ignore if */\r\n\t\t\tif (USE_NON_GEOGRAPHIC_COUNTRY_CODE) {\r\n\t\t\t\tif (metadata.isNonGeographicCallingCode(defaultCallingCode)) {\r\n\t\t\t\t\tcountry = '001'\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tcountryCallingCode = defaultCallingCode || getCountryCallingCode(defaultCountry, metadata.metadata)\r\n\t}\r\n\telse return {}\r\n\r\n\tif (!number) {\r\n\t\treturn {\r\n\t\t\tcountryCallingCodeSource,\r\n\t\t\tcountryCallingCode\r\n\t\t}\r\n\t}\r\n\r\n\tconst {\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t} = extractNationalNumber(\r\n\t\tparseIncompletePhoneNumber(number),\r\n\t\tcountry,\r\n\t\tmetadata\r\n\t)\r\n\r\n\t// Sometimes there are several countries\r\n\t// corresponding to the same country phone code\r\n\t// (e.g. NANPA countries all having `1` country phone code).\r\n\t// Therefore, to reliably determine the exact country,\r\n\t// national (significant) number should have been parsed first.\r\n\t//\r\n\t// When `metadata.json` is generated, all \"ambiguous\" country phone codes\r\n\t// get their countries populated with the full set of\r\n\t// \"phone number type\" regular expressions.\r\n\t//\r\n\tconst exactCountry = getCountryByCallingCode(countryCallingCode, {\r\n\t\tnationalNumber,\r\n\t\tmetadata\r\n\t})\r\n\tif (exactCountry) {\r\n\t\tcountry = exactCountry\r\n\t\t/* istanbul ignore if */\r\n\t\tif (exactCountry === '001') {\r\n\t\t\t// Can't happen with `USE_NON_GEOGRAPHIC_COUNTRY_CODE` being `false`.\r\n\t\t\t// If `USE_NON_GEOGRAPHIC_COUNTRY_CODE` is set to `true` for some reason,\r\n\t\t\t// then remove the \"istanbul ignore if\".\r\n\t\t} else {\r\n\t\t\tmetadata.selectNumberingPlan(country)\r\n\t\t}\r\n\t}\r\n\r\n\treturn {\r\n\t\tcountry,\r\n\t\tcountryCallingCode,\r\n\t\tcountryCallingCodeSource,\r\n\t\tnationalNumber,\r\n\t\tcarrierCode\r\n\t}\r\n}"],"mappings":";;;;;;;AAKA,IAAAA,UAAA,GAAAC,OAAA;AAOA,IAAAC,WAAA,GAAAC,sBAAA,CAAAF,OAAA;AACA,IAAAG,SAAA,GAAAD,sBAAA,CAAAF,OAAA;AACA,IAAAI,oBAAA,GAAAC,uBAAA,CAAAL,OAAA;AACA,IAAAM,iBAAA,GAAAJ,sBAAA,CAAAF,OAAA;AACA,IAAAO,2BAAA,GAAAL,sBAAA,CAAAF,OAAA;AACA,IAAAQ,sBAAA,GAAAN,sBAAA,CAAAF,OAAA;AACA,IAAAS,WAAA,GAAAT,OAAA;AAEA,IAAAU,YAAA,GAAAR,sBAAA,CAAAF,OAAA;AACA,IAAAW,gBAAA,GAAAT,sBAAA,CAAAF,OAAA;AACA,IAAAY,0BAAA,GAAAV,sBAAA,CAAAF,OAAA;AACA,IAAAa,sBAAA,GAAAX,sBAAA,CAAAF,OAAA;AAEA,IAAAc,wBAAA,GAAAZ,sBAAA,CAAAF,OAAA;AACA,IAAAe,wDAAA,GAAAb,sBAAA,CAAAF,OAAA;AAA0I,SAAAK,wBAAAW,CAAA,EAAAC,CAAA,6BAAAC,OAAA,MAAAC,CAAA,OAAAD,OAAA,IAAAE,CAAA,OAAAF,OAAA,YAAAb,uBAAA,YAAAA,wBAAAW,CAAA,EAAAC,CAAA,SAAAA,CAAA,IAAAD,CAAA,IAAAA,CAAA,CAAAK,UAAA,SAAAL,CAAA,MAAAM,CAAA,EAAAC,CAAA,EAAAC,CAAA,KAAAC,SAAA,mBAAAT,CAAA,iBAAAA,CAAA,gBAAAU,OAAA,CAAAV,CAAA,0BAAAA,CAAA,SAAAQ,CAAA,MAAAF,CAAA,GAAAL,CAAA,GAAAG,CAAA,GAAAD,CAAA,QAAAG,CAAA,CAAAK,GAAA,CAAAX,CAAA,UAAAM,CAAA,CAAAM,GAAA,CAAAZ,CAAA,GAAAM,CAAA,CAAAO,GAAA,CAAAb,CAAA,EAAAQ,CAAA,cAAAM,EAAA,IAAAd,CAAA,gBAAAc,EAAA,OAAAC,cAAA,CAAAC,IAAA,CAAAhB,CAAA,EAAAc,EAAA,OAAAP,CAAA,IAAAD,CAAA,GAAAW,MAAA,CAAAC,cAAA,KAAAD,MAAA,CAAAE,wBAAA,CAAAnB,CAAA,EAAAc,EAAA,OAAAP,CAAA,CAAAK,GAAA,IAAAL,CAAA,CAAAM,GAAA,IAAAP,CAAA,CAAAE,CAAA,EAAAM,EAAA,EAAAP,CAAA,IAAAC,CAAA,CAAAM,EAAA,IAAAd,CAAA,CAAAc,EAAA,WAAAN,CAAA,KAAAR,CAAA,EAAAC,CAAA;AAAA,SAAAf,uBAAAc,CAAA,WAAAA,CAAA,IAAAA,CAAA,CAAAK,UAAA,GAAAL,CAAA,gBAAAA,CAAA;AA1B1I;AACA;AACA;AACA;;AAgBA;;AAKA;;AAIA;AACA;AACA,IAAMoB,uBAAuB,GAAG,GAAG;;AAEnC;AACA,IAAMC,0BAA0B,GAAG,IAAIC,MAAM,CAAC,GAAG,GAAGC,qBAAU,GAAGC,uBAAY,GAAG,GAAG,CAAC;;AAEpF;AACA;AACA;AACA,IAAMC,8BAA8B,GAAG,IAAIH,MAAM,CAAC,IAAI,GAAGE,uBAAY,GAAG,GAAG,GAAG,KAAK,CAAC;AAEpF,IAAME,+BAA+B,GAAG,KAAK;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASC,KAAKA,CAACC,IAAI,EAAEC,OAAO,EAAEC,QAAQ,EAAE;EACtD;EACA;EACAD,OAAO,GAAGA,OAAO,IAAI,CAAC,CAAC;EAEvBC,QAAQ,GAAG,IAAIC,oBAAQ,CAACD,QAAQ,CAAC;;EAEjC;EACA,IAAID,OAAO,CAACG,cAAc,IAAI,CAACF,QAAQ,CAACG,UAAU,CAACJ,OAAO,CAACG,cAAc,CAAC,EAAE;IAC3E,IAAIH,OAAO,CAACK,EAAE,EAAE;MACf,MAAM,IAAIC,sBAAU,CAAC,iBAAiB,CAAC;IACxC;IACA,MAAM,IAAIC,KAAK,qBAAAC,MAAA,CAAqBR,OAAO,CAACG,cAAc,CAAE,CAAC;EAC9D;;EAEA;EACA,IAAAM,WAAA,GAAqDC,UAAU,CAACX,IAAI,EAAEC,OAAO,CAACK,EAAE,EAAEL,OAAO,CAACW,OAAO,CAAC;IAAlFC,oBAAoB,GAAAH,WAAA,CAA5BI,MAAM;IAAwBC,GAAG,GAAAL,WAAA,CAAHK,GAAG;IAAEC,KAAK,GAAAN,WAAA,CAALM,KAAK;;EAEhD;EACA,IAAI,CAACH,oBAAoB,EAAE;IAC1B,IAAIZ,OAAO,CAACK,EAAE,EAAE;MACf,IAAIU,KAAK,KAAK,WAAW,EAAE;QAC1B,MAAM,IAAIT,sBAAU,CAAC,WAAW,CAAC;MAClC;MACA,MAAM,IAAIA,sBAAU,CAAC,cAAc,CAAC;IACrC;IACA,OAAO,CAAC,CAAC;EACV;EAEA,IAAAU,iBAAA,GAMIC,gBAAgB,CACnBL,oBAAoB,EACpBZ,OAAO,CAACG,cAAc,EACtBH,OAAO,CAACkB,kBAAkB,EAC1BjB,QACD,CAAC;IAVAkB,OAAO,GAAAH,iBAAA,CAAPG,OAAO;IACPC,cAAc,GAAAJ,iBAAA,CAAdI,cAAc;IACdC,kBAAkB,GAAAL,iBAAA,CAAlBK,kBAAkB;IAClBC,wBAAwB,GAAAN,iBAAA,CAAxBM,wBAAwB;IACxBC,WAAW,GAAAP,iBAAA,CAAXO,WAAW;EAQZ,IAAI,CAACtB,QAAQ,CAACuB,wBAAwB,CAAC,CAAC,EAAE;IACzC,IAAIxB,OAAO,CAACK,EAAE,EAAE;MACf,MAAM,IAAIC,sBAAU,CAAC,iBAAiB,CAAC;IACxC;IACA,OAAO,CAAC,CAAC;EACV;;EAEA;EACA,IAAI,CAACc,cAAc,IAAIA,cAAc,CAACK,MAAM,GAAGC,6BAAkB,EAAE;IAClE;IACA;IACA,IAAI1B,OAAO,CAACK,EAAE,EAAE;MACf,MAAM,IAAIC,sBAAU,CAAC,WAAW,CAAC;IAClC;IACA;IACA,OAAO,CAAC,CAAC;EACV;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAIc,cAAc,CAACK,MAAM,GAAGE,6BAAkB,EAAE;IAC/C,IAAI3B,OAAO,CAACK,EAAE,EAAE;MACf,MAAM,IAAIC,sBAAU,CAAC,UAAU,CAAC;IACjC;IACA;IACA,OAAO,CAAC,CAAC;EACV;EAEA,IAAIN,OAAO,CAACK,EAAE,EAAE;IACf,IAAMuB,WAAW,GAAG,IAAIC,uBAAW,CAClCR,kBAAkB,EAClBD,cAAc,EACdnB,QAAQ,CAACA,QACV,CAAC;IACD,IAAIkB,OAAO,EAAE;MACZS,WAAW,CAACT,OAAO,GAAGA,OAAO;IAC9B;IACA,IAAII,WAAW,EAAE;MAChBK,WAAW,CAACL,WAAW,GAAGA,WAAW;IACtC;IACA,IAAIT,GAAG,EAAE;MACRc,WAAW,CAACd,GAAG,GAAGA,GAAG;IACtB;IACAc,WAAW,CAACE,0BAA0B,GAAGR,wBAAwB;IACjE,OAAOM,WAAW;EACnB;;EAEA;EACA;EACA;EACA,IAAMG,KAAK,GAAG,CAAC/B,OAAO,CAACgC,QAAQ,GAAG/B,QAAQ,CAACuB,wBAAwB,CAAC,CAAC,GAAGL,OAAO,IAC9E,IAAAc,2BAAe,EAACb,cAAc,EAAEnB,QAAQ,CAACiC,qBAAqB,CAAC,CAAC,CAAC,GACjE,KAAK;EAEN,IAAI,CAAClC,OAAO,CAACgC,QAAQ,EAAE;IACtB,OAAOD,KAAK,GAAGI,MAAM,CAAChB,OAAO,EAAEC,cAAc,EAAEN,GAAG,CAAC,GAAG,CAAC,CAAC;EACzD;;EAEA;;EAEA,OAAO;IACNK,OAAO,EAAPA,OAAO;IACPE,kBAAkB,EAAlBA,kBAAkB;IAClBE,WAAW,EAAXA,WAAW;IACXQ,KAAK,EAALA,KAAK;IACLK,QAAQ,EAAEL,KAAK,GAAG,IAAI,GACrB/B,OAAO,CAACgC,QAAQ,KAAK,IAAI,IACzB/B,QAAQ,CAACoC,eAAe,CAAC,CAAC,IAC1B,IAAAC,4BAAgB,EAAClB,cAAc,EAAED,OAAO,EAAElB,QAAQ,CAAC,GAAG,IAAI,GAAG,KAC7D;IACDsC,KAAK,EAAEnB,cAAc;IACrBN,GAAG,EAAHA;EACD,CAAC;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS0B,4BAA2BA,CAACzC,IAAI,EAAEY,OAAO,EAAE8B,YAAY,EAAE;EACjE,IAAI,CAAC1C,IAAI,EAAE;IACV;EACD;EACA,IAAIA,IAAI,CAAC0B,MAAM,GAAGlC,uBAAuB,EAAE;IAC1C,IAAIkD,YAAY,EAAE;MACjB,MAAM,IAAInC,sBAAU,CAAC,UAAU,CAAC;IACjC;IACA;EACD;EACA,IAAIK,OAAO,KAAK,KAAK,EAAE;IACtB,OAAOZ,IAAI;EACZ;EACA;EACA,IAAM2C,QAAQ,GAAG3C,IAAI,CAAC4C,MAAM,CAACnD,0BAA0B,CAAC;EACxD,IAAIkD,QAAQ,GAAG,CAAC,EAAE;IACjB;EACD;EACA,OAAO3C;EACN;EAAA,CACC6C,KAAK,CAACF,QAAQ;EACf;EAAA,CACCG,OAAO,CAACjD,8BAA8B,EAAE,EAAE,CAAC;AAC9C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAASc,UAAUA,CAACX,IAAI,EAAEM,EAAE,EAAEM,OAAO,EAAE;EACtC;EACA;EACA;EACA;EACA;EACA,IAAIE,MAAM,GAAG,IAAAiC,mEAAuD,EAAC/C,IAAI,EAAE;IAC1EyC,2BAA2B,EAAE,SAA7BA,2BAA2BA,CAAGzC,IAAI;MAAA,OAAKyC,4BAA2B,CAACzC,IAAI,EAAEY,OAAO,EAAEN,EAAE,CAAC;IAAA;EACtF,CAAC,CAAC;EACF;EACA,IAAI,CAACQ,MAAM,EAAE;IACZ,OAAO,CAAC,CAAC;EACV;EACA,IAAI,CAAC,IAAAkC,+BAAmB,EAAClC,MAAM,CAAC,EAAE;IACjC,IAAI,IAAAmC,6CAAwB,EAACnC,MAAM,CAAC,EAAE;MACrC,OAAO;QAAEE,KAAK,EAAE;MAAY,CAAC;IAC9B;IACA,OAAO,CAAC,CAAC;EACV;EACA;EACA;EACA,IAAMkC,qBAAqB,GAAG,IAAAC,4BAAgB,EAACrC,MAAM,CAAC;EACtD,IAAIoC,qBAAqB,CAACnC,GAAG,EAAE;IAC9B,OAAOmC,qBAAqB;EAC7B;EACA,OAAO;IAAEpC,MAAM,EAANA;EAAO,CAAC;AAClB;;AAEA;AACA;AACA;AACA,SAASsB,MAAMA,CAAChB,OAAO,EAAEC,cAAc,EAAEN,GAAG,EAAE;EAC7C,IAAMqB,MAAM,GAAG;IACdhB,OAAO,EAAPA,OAAO;IACPoB,KAAK,EAAEnB;EACR,CAAC;EACD,IAAIN,GAAG,EAAE;IACRqB,MAAM,CAACrB,GAAG,GAAGA,GAAG;EACjB;EACA,OAAOqB,MAAM;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASlB,gBAAgBA,CACxBL,oBAAoB,EACpBT,cAAc,EACde,kBAAkB,EAClBjB,QAAQ,EACP;EACD;EACA,IAAAkD,qBAAA,GAA+D,IAAAC,qCAAyB,EACvF,IAAAC,sCAA0B,EAACzC,oBAAoB,CAAC,EAChD0C,SAAS,EACTnD,cAAc,EACde,kBAAkB,EAClBjB,QAAQ,CAACA,QACV,CAAC;IANKqB,wBAAwB,GAAA6B,qBAAA,CAAxB7B,wBAAwB;IAAED,kBAAkB,GAAA8B,qBAAA,CAAlB9B,kBAAkB;IAAER,MAAM,GAAAsC,qBAAA,CAANtC,MAAM;;EAQ1D;EACA,IAAIM,OAAO;;EAEX;EACA;EACA,IAAIE,kBAAkB,EAAE;IACvBpB,QAAQ,CAACsD,mBAAmB,CAAClC,kBAAkB,CAAC;EACjD;EACA;EACA;EAAA,KACK,IAAIR,MAAM,KAAKV,cAAc,IAAIe,kBAAkB,CAAC,EAAE;IAC1DjB,QAAQ,CAACsD,mBAAmB,CAACpD,cAAc,EAAEe,kBAAkB,CAAC;IAChE,IAAIf,cAAc,EAAE;MACnBgB,OAAO,GAAGhB,cAAc;IACzB,CAAC,MAAM;MACN;MACA,IAAIN,+BAA+B,EAAE;QACpC,IAAII,QAAQ,CAACuD,0BAA0B,CAACtC,kBAAkB,CAAC,EAAE;UAC5DC,OAAO,GAAG,KAAK;QAChB;MACD;IACD;IACAE,kBAAkB,GAAGH,kBAAkB,IAAI,IAAAuC,iCAAqB,EAACtD,cAAc,EAAEF,QAAQ,CAACA,QAAQ,CAAC;EACpG,CAAC,MACI,OAAO,CAAC,CAAC;EAEd,IAAI,CAACY,MAAM,EAAE;IACZ,OAAO;MACNS,wBAAwB,EAAxBA,wBAAwB;MACxBD,kBAAkB,EAAlBA;IACD,CAAC;EACF;EAEA,IAAAqC,qBAAA,GAGI,IAAAC,iCAAqB,EACxB,IAAAN,sCAA0B,EAACxC,MAAM,CAAC,EAClCM,OAAO,EACPlB,QACD,CAAC;IANAmB,cAAc,GAAAsC,qBAAA,CAAdtC,cAAc;IACdG,WAAW,GAAAmC,qBAAA,CAAXnC,WAAW;;EAOZ;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAMqC,YAAY,GAAG,IAAAC,mCAAuB,EAACxC,kBAAkB,EAAE;IAChED,cAAc,EAAdA,cAAc;IACdnB,QAAQ,EAARA;EACD,CAAC,CAAC;EACF,IAAI2D,YAAY,EAAE;IACjBzC,OAAO,GAAGyC,YAAY;IACtB;IACA,IAAIA,YAAY,KAAK,KAAK,EAAE;MAC3B;MACA;MACA;IAAA,CACA,MAAM;MACN3D,QAAQ,CAACsD,mBAAmB,CAACpC,OAAO,CAAC;IACtC;EACD;EAEA,OAAO;IACNA,OAAO,EAAPA,OAAO;IACPE,kBAAkB,EAAlBA,kBAAkB;IAClBC,wBAAwB,EAAxBA,wBAAwB;IACxBF,cAAc,EAAdA,cAAc;IACdG,WAAW,EAAXA;EACD,CAAC;AACF","ignoreList":[]}