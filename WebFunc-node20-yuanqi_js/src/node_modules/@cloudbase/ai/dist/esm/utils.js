var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
import { TransformStream as _TransformStream, ReadableStream as _ReadableStream } from 'web-streams-polyfill';
import { createReadableStreamWrapper } from '@mattiasbuelens/web-streams-adapter';
import { createParser } from './eventsource_parser';
import { TextDecoder } from 'text-encoding-shim';
export var ReadableStream = _ReadableStream;
export var TransformStream = _TransformStream;
export var createEventSourceParserTransformStream = function () {
    var parser;
    return new TransformStream({
        start: function (controller) {
            parser = createParser(function (event) {
                if (event.type === 'event') {
                    controller.enqueue(event);
                }
            });
        },
        transform: function (chunk) {
            parser.feed(chunk);
        },
    });
};
export var toPolyfillReadable = createReadableStreamWrapper(ReadableStream);
var TextDecoderStream = (function () {
    function TextDecoderStream(encoding, options) {
        if (encoding === void 0) { encoding = 'utf-8'; }
        if (options === void 0) { options = {}; }
        var _this = this;
        this.transform = new TransformStream({
            transform: function (chunk, controller) {
                var value = _this.handle.decode(new Uint8Array(chunk), { stream: true });
                if (value) {
                    controller.enqueue(value);
                }
            },
            flush: function (controller) {
                var value = _this.handle.decode();
                if (value) {
                    controller.enqueue(value);
                }
                controller.terminate();
            },
        });
        this.handle = new TextDecoder(encoding, options);
    }
    Object.defineProperty(TextDecoderStream.prototype, "encoding", {
        get: function () {
            return this.handle.encoding;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextDecoderStream.prototype, "fatal", {
        get: function () {
            return this.handle.fatal;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextDecoderStream.prototype, "ignoreBOM", {
        get: function () {
            return this.handle.ignoreBOM;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextDecoderStream.prototype, "readable", {
        get: function () {
            return this.transform.readable;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextDecoderStream.prototype, "writable", {
        get: function () {
            return this.transform.writable;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextDecoderStream.prototype, Symbol.toStringTag, {
        get: function () {
            return 'TextDecoderStream';
        },
        enumerable: false,
        configurable: true
    });
    return TextDecoderStream;
}());
export { TextDecoderStream };
export function createAsyncIterable(stream) {
    var _stream = stream;
    _stream[Symbol.asyncIterator] = function () {
        var reader = stream.getReader();
        return {
            next: function () {
                return __awaiter(this, void 0, void 0, function () {
                    var _a, done, value;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0: return [4, reader.read()];
                            case 1:
                                _a = _b.sent(), done = _a.done, value = _a.value;
                                return [2, done ? { done: true, value: undefined } : { done: false, value: value }];
                        }
                    });
                });
            },
        };
    };
    return _stream;
}
export function intoStandardStream(stream) {
    return createAsyncIterable(stream
        .pipeThrough(new TextDecoderStream())
        .pipeThrough(createEventSourceParserTransformStream())
        .pipeThrough(new TransformStream({
        transform: function (chunk, controller) {
            try {
                var data = JSON.parse(chunk.data);
                controller.enqueue(data);
            }
            catch (e) {
                if (chunk.data !== '[DONE]') {
                    console.warn('Error when transforming event source data to json', e, chunk);
                }
                else {
                    controller.terminate();
                }
            }
        },
    })));
}
export function intoTextStream(stream) {
    return createAsyncIterable(toPolyfillReadable(stream).pipeThrough(new TextDecoderStream()));
}
export function readableStream2JsonObject(stream) {
    var _a, e_1, _b, _c;
    return __awaiter(this, void 0, void 0, function () {
        var s, total, _d, s_1, s_1_1, chunk, e_1_1;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    s = intoTextStream(stream);
                    total = '';
                    _e.label = 1;
                case 1:
                    _e.trys.push([1, 6, 7, 12]);
                    _d = true, s_1 = __asyncValues(s);
                    _e.label = 2;
                case 2: return [4, s_1.next()];
                case 3:
                    if (!(s_1_1 = _e.sent(), _a = s_1_1.done, !_a)) return [3, 5];
                    _c = s_1_1.value;
                    _d = false;
                    try {
                        chunk = _c;
                        total += chunk;
                    }
                    finally {
                        _d = true;
                    }
                    _e.label = 4;
                case 4: return [3, 2];
                case 5: return [3, 12];
                case 6:
                    e_1_1 = _e.sent();
                    e_1 = { error: e_1_1 };
                    return [3, 12];
                case 7:
                    _e.trys.push([7, , 10, 11]);
                    if (!(!_d && !_a && (_b = s_1.return))) return [3, 9];
                    return [4, _b.call(s_1)];
                case 8:
                    _e.sent();
                    _e.label = 9;
                case 9: return [3, 11];
                case 10:
                    if (e_1) throw e_1.error;
                    return [7];
                case 11: return [7];
                case 12: return [2, JSON.parse(total)];
            }
        });
    });
}
export function createPromise() {
    var res;
    var rej;
    var promise = new Promise(function (resolve, reject) {
        res = resolve;
        rej = reject;
    });
    return { promise: promise, res: res, rej: rej };
}
export function isToolCallAssistantMessage(message) {
    var _a;
    return message.role === 'assistant' && 'tool_calls' in message && ((_a = message.tool_calls) === null || _a === void 0 ? void 0 : _a[0]) != null;
}
export function functionToolToModelTool(tool) {
    return {
        type: 'function',
        function: {
            description: tool.description,
            name: tool.name,
            parameters: tool.parameters,
        },
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLE9BQU8sRUFBRSxlQUFlLElBQUksZ0JBQWdCLEVBQUUsY0FBYyxJQUFJLGVBQWUsRUFBRSxNQUFNLHNCQUFzQixDQUFBO0FBQzdHLE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxNQUFNLHFDQUFxQyxDQUFBO0FBQ2pGLE9BQU8sRUFBRSxZQUFZLEVBQTRDLE1BQU0sc0JBQXNCLENBQUE7QUFRN0YsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLG9CQUFvQixDQUFBO0FBRWhELE1BQU0sQ0FBQyxJQUFNLGNBQWMsR0FBRyxlQVc3QixDQUFBO0FBRUQsTUFBTSxDQUFDLElBQU0sZUFBZSxHQUFHLGdCQVE5QixDQUFBO0FBRUQsTUFBTSxDQUFDLElBQU0sc0NBQXNDLEdBQUc7SUFDcEQsSUFBSSxNQUEwQixDQUFBO0lBRTlCLE9BQU8sSUFBSSxlQUFlLENBQXNCO1FBQzlDLEtBQUssWUFBQyxVQUFVO1lBQ2QsTUFBTSxHQUFHLFlBQVksQ0FBQyxVQUFDLEtBQUs7Z0JBQzFCLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxPQUFPLEVBQUU7b0JBQzFCLFVBQVUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUE7aUJBQzFCO1lBQ0gsQ0FBQyxDQUFDLENBQUE7UUFDSixDQUFDO1FBQ0QsU0FBUyxZQUFDLEtBQUs7WUFDYixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBO1FBQ3BCLENBQUM7S0FDRixDQUFDLENBQUE7QUFDSixDQUFDLENBQUE7QUFFRCxNQUFNLENBQUMsSUFBTSxrQkFBa0IsR0FBRywyQkFBMkIsQ0FBQyxjQUFjLENBQUMsQ0FBQTtBQUU3RTtJQXFCRSwyQkFBWSxRQUFrQixFQUFFLE9BQWdDO1FBQXBELHlCQUFB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R0FBRyxHQUFHLE1BQU0sQ0FBQTtJQUNkLENBQUMsQ0FBQyxDQUFBO0lBQ0YsT0FBTyxFQUFFLE9BQU8sU0FBQSxFQUFFLEdBQUcsS0FBQSxFQUFFLEdBQUcsS0FBQSxFQUFFLENBQUE7QUFDOUIsQ0FBQztBQUVELE1BQU0sVUFBVSwwQkFBMEIsQ0FBQyxPQUF5Qjs7SUFFbEUsT0FBTyxPQUFPLENBQUMsSUFBSSxLQUFLLFdBQVcsSUFBSSxZQUFZLElBQUksT0FBTyxJQUFJLENBQUEsTUFBQSxPQUFPLENBQUMsVUFBVSwwQ0FBRyxDQUFDLENBQUMsS0FBSSxJQUFJLENBQUE7QUFDbkcsQ0FBQztBQUVELE1BQU0sVUFBVSx1QkFBdUIsQ0FBQyxJQUFrQjtJQUN4RCxPQUFPO1FBQ0wsSUFBSSxFQUFFLFVBQVU7UUFDaEIsUUFBUSxFQUFFO1lBQ1IsV0FBVyxFQUFFLElBQUksQ0FBQyxXQUFXO1lBQzdCLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSTtZQUNmLFVBQVUsRUFBRSxJQUFJLENBQUMsVUFBVTtTQUM1QjtLQUNGLENBQUE7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJhbnNmb3JtU3RyZWFtIGFzIF9UcmFuc2Zvcm1TdHJlYW0sIFJlYWRhYmxlU3RyZWFtIGFzIF9SZWFkYWJsZVN0cmVhbSB9IGZyb20gJ3dlYi1zdHJlYW1zLXBvbHlmaWxsJ1xuaW1wb3J0IHsgY3JlYXRlUmVhZGFibGVTdHJlYW1XcmFwcGVyIH0gZnJvbSAnQG1hdHRpYXNidWVsZW5zL3dlYi1zdHJlYW1zLWFkYXB0ZXInXG5pbXBvcnQgeyBjcmVhdGVQYXJzZXIsIHR5cGUgRXZlbnRTb3VyY2VQYXJzZXIsIHR5cGUgUGFyc2VkRXZlbnQgfSBmcm9tICcuL2V2ZW50c291cmNlX3BhcnNlcidcbmltcG9ydCB0eXBlIHtcbiAgQXN5bmNJdGVyYWJsZVJlYWRhYmxlU3RyZWFtLFxuICBDaGF0TW9kZWxNZXNzYWdlLFxuICBUb29sQ2FsbEFzc2lzdGFudE1lc3NhZ2UsXG4gIE1vZGVsVG9vbCxcbiAgRnVuY3Rpb25Ub29sLFxufSBmcm9tICcuL3R5cGUnXG5pbXBvcnQgeyBUZXh0RGVjb2RlciB9IGZyb20gJ3RleHQtZW5jb2Rpbmctc2hpbSdcblxuZXhwb3J0IGNvbnN0IFJlYWRhYmxlU3RyZWFtID0gX1JlYWRhYmxlU3RyZWFtIGFzIHtcbiAgcHJvdG90eXBlOiBSZWFkYWJsZVN0cmVhbVxuXG4gIG5ldyAoXG4gICAgdW5kZXJseWluZ1NvdXJjZTogVW5kZXJseWluZ0J5dGVTb3VyY2UsXG4gICAgc3RyYXRlZ3k/OiB7XG4gICAgICBoaWdoV2F0ZXJNYXJrPzogbnVtYmVyXG4gICAgfSxcbiAgKTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT5cbiAgbmV3IDxSID0gYW55Pih1bmRlcmx5aW5nU291cmNlOiBVbmRlcmx5aW5nRGVmYXVsdFNvdXJjZTxSPiwgc3RyYXRlZ3k/OiBRdWV1aW5nU3RyYXRlZ3k8Uj4pOiBSZWFkYWJsZVN0cmVhbTxSPlxuICBuZXcgPFIgPSBhbnk+KHVuZGVybHlpbmdTb3VyY2U/OiBVbmRlcmx5aW5nU291cmNlPFI+LCBzdHJhdGVneT86IFF1ZXVpbmdTdHJhdGVneTxSPik6IFJlYWRhYmxlU3RyZWFtPFI+XG59XG5cbmV4cG9ydCBjb25zdCBUcmFuc2Zvcm1TdHJlYW0gPSBfVHJhbnNmb3JtU3RyZWFtIGFzIHtcbiAgcHJvdG90eXBlOiBUcmFuc2Zvcm1TdHJlYW1cblxuICBuZXcgPEkgPSBhbnksIE8gPSBhbnk+KFxuICAgIHRyYW5zZm9ybWVyPzogVHJhbnNmb3JtZXI8SSwgTz4sXG4gICAgd3JpdGFibGVTdHJhdGVneT86IFF1ZXVpbmdTdHJhdGVneTxJPixcbiAgICByZWFkYWJsZVN0cmF0ZWd5PzogUXVldWluZ1N0cmF0ZWd5PE8+LFxuICApOiBUcmFuc2Zvcm1TdHJlYW08SSwgTz5cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZUV2ZW50U291cmNlUGFyc2VyVHJhbnNmb3JtU3RyZWFtID0gKCkgPT4ge1xuICBsZXQgcGFyc2VyITogRXZlbnRTb3VyY2VQYXJzZXJcblxuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbTxzdHJpbmcsIFBhcnNlZEV2ZW50Pih7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgcGFyc2VyID0gY3JlYXRlUGFyc2VyKChldmVudCkgPT4ge1xuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2V2ZW50Jykge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShldmVudClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9LFxuICAgIHRyYW5zZm9ybShjaHVuaykge1xuICAgICAgcGFyc2VyLmZlZWQoY2h1bmspXG4gICAgfSxcbiAgfSlcbn1cblxuZXhwb3J0IGNvbnN0IHRvUG9seWZpbGxSZWFkYWJsZSA9IGNyZWF0ZVJlYWRhYmxlU3RyZWFtV3JhcHBlcihSZWFkYWJsZVN0cmVhbSlcblxuZXhwb3J0IGNsYXNzIFRleHREZWNvZGVyU3RyZWFtIHtcbiAgcHJpdmF0ZSBoYW5kbGU6IFRleHREZWNvZGVyXG5cbiAgcHJpdmF0ZSB0cmFuc2Zvcm0gPSBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm06IChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmhhbmRsZS5kZWNvZGUobmV3IFVpbnQ4QXJyYXkoY2h1bmspLCB7IHN0cmVhbTogdHJ1ZSB9KVxuXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKVxuICAgICAgfVxuICAgIH0sXG4gICAgZmx1c2g6IChjb250cm9sbGVyKSA9PiB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuaGFuZGxlLmRlY29kZSgpXG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKVxuICAgICAgfVxuXG4gICAgICBjb250cm9sbGVyLnRlcm1pbmF0ZSgpXG4gICAgfSxcbiAgfSlcblxuICBjb25zdHJ1Y3RvcihlbmNvZGluZyA9ICd1dGYtOCcsIG9wdGlvbnM6IFRleHREZWNvZGVyT3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5oYW5kbGUgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcsIG9wdGlvbnMpXG4gIH1cblxuICBnZXQgZW5jb2RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlLmVuY29kaW5nXG4gIH1cblxuICBnZXQgZmF0YWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlLmZhdGFsXG4gIH1cblxuICBnZXQgaWdub3JlQk9NKCkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZS5pZ25vcmVCT01cbiAgfVxuXG4gIGdldCByZWFkYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ucmVhZGFibGVcbiAgfVxuXG4gIGdldCB3cml0YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ud3JpdGFibGVcbiAgfVxuXG4gIGdldCBbU3ltYm9sLnRvU3RyaW5nVGFnXSgpIHtcbiAgICByZXR1cm4gJ1RleHREZWNvZGVyU3RyZWFtJ1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBc3luY0l0ZXJhYmxlPFQ+KHN0cmVhbTogUmVhZGFibGVTdHJlYW08VD4pIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uYW1pbmctY29udmVudGlvblxuICBjb25zdCBfc3RyZWFtID0gc3RyZWFtIGFzIEFzeW5jSXRlcmFibGVSZWFkYWJsZVN0cmVhbTxUPlxuICAoX3N0cmVhbSBhcyBhbnkpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9ICgpID0+IHtcbiAgICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKClcbiAgICByZXR1cm4ge1xuICAgICAgYXN5bmMgbmV4dCgpOiBQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PFQ+PiB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKClcbiAgICAgICAgcmV0dXJuIGRvbmUgPyB7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSA6IHsgZG9uZTogZmFsc2UsIHZhbHVlIH1cbiAgICAgIH0sXG4gICAgfVxuICB9XG4gIHJldHVybiBfc3RyZWFtXG59XG5cbi8qKlxuICog5bCGIFNTRSDkuozov5vliLbmtYHovazmjaLkuLogVCDnsbvlnovnmoTmtYFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludG9TdGFuZGFyZFN0cmVhbTxUPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+KTogUmVhZGFibGVTdHJlYW08VD4ge1xuICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZShzdHJlYW1cbiAgICAucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpXG4gICAgLnBpcGVUaHJvdWdoKGNyZWF0ZUV2ZW50U291cmNlUGFyc2VyVHJhbnNmb3JtU3RyZWFtKCkpXG4gICAgLnBpcGVUaHJvdWdoKG5ldyBUcmFuc2Zvcm1TdHJlYW08UGFyc2VkRXZlbnQsIFQ+KHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKGNodW5rLmRhdGEpIGFzIFRcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZGF0YSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChjaHVuay5kYXRhICE9PSAnW0RPTkVdJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdFcnJvciB3aGVuIHRyYW5zZm9ybWluZyBldmVudCBzb3VyY2UgZGF0YSB0byBqc29uJywgZSwgY2h1bmspXG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIudGVybWluYXRlKClcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgfSksKSwpXG59XG5cbi8qKlxuICog5bCGIFNTRSDkuozov5vliLbmtYHovazmjaLkuLrlrZfnrKbkuLLmtYFcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludG9UZXh0U3RyZWFtKHN0cmVhbTogUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4pOiBBc3luY0l0ZXJhYmxlUmVhZGFibGVTdHJlYW08c3RyaW5nPiB7XG4gIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlKCh0b1BvbHlmaWxsUmVhZGFibGUoc3RyZWFtKSBhcyB0eXBlb2Ygc3RyZWFtKS5waXBlVGhyb3VnaChuZXcgVGV4dERlY29kZXJTdHJlYW0oKSkpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiByZWFkYWJsZVN0cmVhbTJKc29uT2JqZWN0KHN0cmVhbTogUmVhZGFibGVTdHJlYW0pIHtcbiAgY29uc3QgcyA9IGludG9UZXh0U3RyZWFtKHN0cmVhbSlcbiAgbGV0IHRvdGFsID0gJydcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzKSB7XG4gICAgdG90YWwgKz0gY2h1bmtcbiAgfVxuICByZXR1cm4gSlNPTi5wYXJzZSh0b3RhbClcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVByb21pc2U8VCA9IHVua25vd24+KCkge1xuICBsZXQgcmVzOiAodmFsdWU6IFQgfCBQcm9taXNlTGlrZTxUPikgPT4gdm9pZFxuICBsZXQgcmVqOiAocmVhc29uPzogYW55KSA9PiB2b2lkXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZTxUPigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgcmVzID0gcmVzb2x2ZVxuICAgIHJlaiA9IHJlamVjdFxuICB9KVxuICByZXR1cm4geyBwcm9taXNlLCByZXMsIHJlaiB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1Rvb2xDYWxsQXNzaXN0YW50TWVzc2FnZShtZXNzYWdlOiBDaGF0TW9kZWxNZXNzYWdlKTogbWVzc2FnZSBpcyBUb29sQ2FsbEFzc2lzdGFudE1lc3NhZ2Uge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG4gIHJldHVybiBtZXNzYWdlLnJvbGUgPT09ICdhc3Npc3RhbnQnICYmICd0b29sX2NhbGxzJyBpbiBtZXNzYWdlICYmIG1lc3NhZ2UudG9vbF9jYWxscz8uWzBdICE9IG51bGxcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZ1bmN0aW9uVG9vbFRvTW9kZWxUb29sKHRvb2w6IEZ1bmN0aW9uVG9vbCk6IE1vZGVsVG9vbCB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ2Z1bmN0aW9uJyxcbiAgICBmdW5jdGlvbjoge1xuICAgICAgZGVzY3JpcHRpb246IHRvb2wuZGVzY3JpcHRpb24sXG4gICAgICBuYW1lOiB0b29sLm5hbWUsXG4gICAgICBwYXJhbWV0ZXJzOiB0b29sLnBhcmFtZXRlcnMsXG4gICAgfSxcbiAgfVxufVxuIl19