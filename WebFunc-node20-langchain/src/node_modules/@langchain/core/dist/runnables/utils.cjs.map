{"version":3,"file":"utils.cjs","names":["thing: any","fields: {\n    includeNames?: string[];\n    includeTypes?: string[];\n    includeTags?: string[];\n    excludeNames?: string[];\n    excludeTypes?: string[];\n    excludeTags?: string[];\n  }","event: StreamEvent","rootType: string","str: string"],"sources":["../../src/runnables/utils.ts"],"sourcesContent":["import { StreamEvent } from \"../tracers/event_stream.js\";\nimport type { RunnableInterface } from \"./types.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function isRunnableInterface(thing: any): thing is RunnableInterface {\n  return thing ? thing.lc_runnable : false;\n}\n\n/**\n * Utility to filter the root event in the streamEvents implementation.\n * This is simply binding the arguments to the namespace to make save on\n * a bit of typing in the streamEvents implementation.\n *\n * TODO: Refactor and remove.\n */\nexport class _RootEventFilter {\n  includeNames?: string[];\n\n  includeTypes?: string[];\n\n  includeTags?: string[];\n\n  excludeNames?: string[];\n\n  excludeTypes?: string[];\n\n  excludeTags?: string[];\n\n  constructor(fields: {\n    includeNames?: string[];\n    includeTypes?: string[];\n    includeTags?: string[];\n    excludeNames?: string[];\n    excludeTypes?: string[];\n    excludeTags?: string[];\n  }) {\n    this.includeNames = fields.includeNames;\n    this.includeTypes = fields.includeTypes;\n    this.includeTags = fields.includeTags;\n    this.excludeNames = fields.excludeNames;\n    this.excludeTypes = fields.excludeTypes;\n    this.excludeTags = fields.excludeTags;\n  }\n\n  includeEvent(event: StreamEvent, rootType: string): boolean {\n    let include =\n      this.includeNames === undefined &&\n      this.includeTypes === undefined &&\n      this.includeTags === undefined;\n    const eventTags = event.tags ?? [];\n\n    if (this.includeNames !== undefined) {\n      include = include || this.includeNames.includes(event.name);\n    }\n    if (this.includeTypes !== undefined) {\n      include = include || this.includeTypes.includes(rootType);\n    }\n    if (this.includeTags !== undefined) {\n      include =\n        include || eventTags.some((tag) => this.includeTags?.includes(tag));\n    }\n\n    if (this.excludeNames !== undefined) {\n      include = include && !this.excludeNames.includes(event.name);\n    }\n    if (this.excludeTypes !== undefined) {\n      include = include && !this.excludeTypes.includes(rootType);\n    }\n    if (this.excludeTags !== undefined) {\n      include =\n        include && eventTags.every((tag) => !this.excludeTags?.includes(tag));\n    }\n\n    return include;\n  }\n}\n\nexport const toBase64Url = (str: string): string => {\n  // Use btoa for compatibility, assume ASCII\n  const encoded = btoa(str);\n  return encoded.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n};\n"],"mappings":";;AAIA,SAAgB,oBAAoBA,OAAwC;AAC1E,QAAO,QAAQ,MAAM,cAAc;AACpC;;;;;;;;AASD,IAAa,mBAAb,MAA8B;CAC5B;CAEA;CAEA;CAEA;CAEA;CAEA;CAEA,YAAYC,QAOT;EACD,KAAK,eAAe,OAAO;EAC3B,KAAK,eAAe,OAAO;EAC3B,KAAK,cAAc,OAAO;EAC1B,KAAK,eAAe,OAAO;EAC3B,KAAK,eAAe,OAAO;EAC3B,KAAK,cAAc,OAAO;CAC3B;CAED,aAAaC,OAAoBC,UAA2B;EAC1D,IAAI,UACF,KAAK,iBAAiB,UACtB,KAAK,iBAAiB,UACtB,KAAK,gBAAgB;EACvB,MAAM,YAAY,MAAM,QAAQ,CAAE;AAElC,MAAI,KAAK,iBAAiB,QACxB,UAAU,WAAW,KAAK,aAAa,SAAS,MAAM,KAAK;AAE7D,MAAI,KAAK,iBAAiB,QACxB,UAAU,WAAW,KAAK,aAAa,SAAS,SAAS;AAE3D,MAAI,KAAK,gBAAgB,QACvB,UACE,WAAW,UAAU,KAAK,CAAC,QAAQ,KAAK,aAAa,SAAS,IAAI,CAAC;AAGvE,MAAI,KAAK,iBAAiB,QACxB,UAAU,WAAW,CAAC,KAAK,aAAa,SAAS,MAAM,KAAK;AAE9D,MAAI,KAAK,iBAAiB,QACxB,UAAU,WAAW,CAAC,KAAK,aAAa,SAAS,SAAS;AAE5D,MAAI,KAAK,gBAAgB,QACvB,UACE,WAAW,UAAU,MAAM,CAAC,QAAQ,CAAC,KAAK,aAAa,SAAS,IAAI,CAAC;AAGzE,SAAO;CACR;AACF;AAED,MAAa,cAAc,CAACC,QAAwB;CAElD,MAAM,UAAU,KAAK,IAAI;AACzB,QAAO,QAAQ,QAAQ,OAAO,IAAI,CAAC,QAAQ,OAAO,IAAI,CAAC,QAAQ,OAAO,GAAG;AAC1E"}