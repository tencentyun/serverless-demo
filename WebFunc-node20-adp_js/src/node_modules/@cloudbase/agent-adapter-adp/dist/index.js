"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AdpAgent: () => AdpAgent,
  AdpAgentError: () => AdpAgentError,
  CurrentNodeStatus: () => CurrentNodeStatus,
  ReplyMethod: () => ReplyMethod
});
module.exports = __toCommonJS(index_exports);

// src/agent.ts
var import_client = require("@ag-ui/client");
var import_rxjs = require("rxjs");
var import_axios = __toESM(require("axios"));

// src/utils.ts
function camelToSnake(str) {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}
function camelToSnakeKeys(obj) {
  if (obj === null || obj === void 0) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => camelToSnakeKeys(item));
  }
  if (typeof obj === "object") {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
      const snakeKey = camelToSnake(key);
      result[snakeKey] = camelToSnakeKeys(value);
    }
    return result;
  }
  return obj;
}

// src/constant.ts
var MIME_TYPES = {
  "text/plain": "txt",
  "application/msword": "doc",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
  "application/pdf": "pdf",
  "application/vnd.ms-powerpoint": "ppt",
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": "pptx"
};

// src/types.ts
var ReplyMethod = /* @__PURE__ */ ((ReplyMethod2) => {
  ReplyMethod2[ReplyMethod2["LLM_REPLY"] = 1] = "LLM_REPLY";
  ReplyMethod2[ReplyMethod2["UNKNOWN_QUESTION_REPLY"] = 2] = "UNKNOWN_QUESTION_REPLY";
  ReplyMethod2[ReplyMethod2["REJECT_QUESTION_REPLY"] = 3] = "REJECT_QUESTION_REPLY";
  ReplyMethod2[ReplyMethod2["SENSITIVE_REPLY"] = 4] = "SENSITIVE_REPLY";
  ReplyMethod2[ReplyMethod2["ADOPTED_QA_PRIORITY_REPLY"] = 5] = "ADOPTED_QA_PRIORITY_REPLY";
  ReplyMethod2[ReplyMethod2["WELCOME_REPLY"] = 6] = "WELCOME_REPLY";
  ReplyMethod2[ReplyMethod2["CONCURRENCY_LIMIT_REPLY"] = 7] = "CONCURRENCY_LIMIT_REPLY";
  ReplyMethod2[ReplyMethod2["GLOBAL_INTERVENTION_KNOWLEDGE"] = 8] = "GLOBAL_INTERVENTION_KNOWLEDGE";
  ReplyMethod2[ReplyMethod2["TASK_FLOW_REPLY"] = 9] = "TASK_FLOW_REPLY";
  ReplyMethod2[ReplyMethod2["TASK_FLOW_ANSWER"] = 10] = "TASK_FLOW_ANSWER";
  ReplyMethod2[ReplyMethod2["SEARCH_ENGINE_REPLY"] = 11] = "SEARCH_ENGINE_REPLY";
  ReplyMethod2[ReplyMethod2["KNOWLEDGE_POLISHED_REPLY"] = 12] = "KNOWLEDGE_POLISHED_REPLY";
  ReplyMethod2[ReplyMethod2["IMAGE_UNDERSTANDING_REPLY"] = 13] = "IMAGE_UNDERSTANDING_REPLY";
  ReplyMethod2[ReplyMethod2["REALTIME_DOCUMENT_REPLY"] = 14] = "REALTIME_DOCUMENT_REPLY";
  ReplyMethod2[ReplyMethod2["CLARIFICATION_CONFIRMATION_REPLY"] = 15] = "CLARIFICATION_CONFIRMATION_REPLY";
  ReplyMethod2[ReplyMethod2["WORKFLOW_REPLY"] = 16] = "WORKFLOW_REPLY";
  ReplyMethod2[ReplyMethod2["WORKFLOW_EXECUTION_END"] = 17] = "WORKFLOW_EXECUTION_END";
  ReplyMethod2[ReplyMethod2["AGENT_REPLY"] = 18] = "AGENT_REPLY";
  ReplyMethod2[ReplyMethod2["MULTI_INTENT_REPLY"] = 19] = "MULTI_INTENT_REPLY";
  return ReplyMethod2;
})(ReplyMethod || {});
var CurrentNodeStatus = /* @__PURE__ */ ((CurrentNodeStatus2) => {
  CurrentNodeStatus2[CurrentNodeStatus2["Pending"] = 0] = "Pending";
  CurrentNodeStatus2[CurrentNodeStatus2["Running"] = 1] = "Running";
  CurrentNodeStatus2[CurrentNodeStatus2["Succeeded"] = 2] = "Succeeded";
  CurrentNodeStatus2[CurrentNodeStatus2["Failed"] = 3] = "Failed";
  return CurrentNodeStatus2;
})(CurrentNodeStatus || {});

// src/agent.ts
var import_crypto = require("crypto");
var import_tencentcloud_sdk_nodejs_lke = require("tencentcloud-sdk-nodejs-lke");
var AdpAgentError = class extends Error {
  constructor(message, code) {
    super(message);
    this.name = "AdpAgentError";
    if (code) this.code = code;
  }
};
var AdpAgent = class extends import_client.AbstractAgent {
  constructor(config) {
    super(config);
    this.adpConfig = config.adpConfig;
    this.reqAppClient = import_axios.default.create({
      baseURL: this.adpConfig.request?.baseUrl || "https://wss.lke.cloud.tencent.com"
    });
    const LkeClient = import_tencentcloud_sdk_nodejs_lke.lke.v20231130.Client;
    this.reqLkeClient = new LkeClient({
      credential: {
        secretId: this.adpConfig.credential?.secretId || process.env.TENCENTCLOUD_SECRETID,
        secretKey: this.adpConfig.credential?.secretKey || process.env.TENCENTCLOUD_SECRETKEY,
        token: this.adpConfig.credential?.token || process.env.TENCENTCLOUD_SESSIONTOKEN
      }
    });
  }
  generateRequestBody({
    message,
    fileInfos,
    runId,
    threadId,
    forwardedProps
  }) {
    const requestBody = {
      incremental: true,
      stream: "enable",
      ...this.adpConfig.request?.body || {},
      ...forwardedProps || {},
      botAppKey: this.adpConfig.appKey || this.adpConfig.request?.body?.botAppKey || process.env.ADP_APP_KEY,
      visitorBizId: forwardedProps?.visitorBizId || (0, import_crypto.randomUUID)(),
      requestId: runId,
      sessionId: threadId || (0, import_crypto.randomUUID)(),
      content: message,
      fileInfos
    };
    return requestBody;
  }
  // @ts-ignore
  run(input) {
    return new import_rxjs.Observable((subscriber) => {
      this._run(subscriber, input);
    });
  }
  async _run(subscriber, input) {
    try {
      const { messages, runId, threadId, forwardedProps } = input;
      subscriber.next({
        type: import_client.EventType.RUN_STARTED,
        runId,
        threadId
      });
      if (!this.adpConfig.appKey && !process.env.ADP_APP_KEY) {
        throw new AdpAgentError(
          "ADP app key is required, check your env variables or config passed with the adapter",
          "MISSING_APP_KEY"
        );
      }
      const { messages: docExtractedMessages, fileInfos } = await extractDocuments(messages, this.adpConfig, this.reqLkeClient);
      const { message, trimmed } = convertAGUIMessagesToAdpMessages(docExtractedMessages);
      if (!message) {
        throw new AdpAgentError(
          "Message content format error, or empty content",
          "INVALID_MESSAGE_CONTENT"
        );
      }
      if (trimmed > 0) {
        subscriber.next({
          type: import_client.EventType.RAW,
          rawEvent: {
            message: `ADP handles message history itself, so that a total of ${trimmed} messages before and including last assistant message will be trimmed.`,
            type: "warn"
          }
        });
      }
      const requestBody = this.generateRequestBody({
        message,
        fileInfos,
        runId,
        threadId,
        forwardedProps
      });
      const response = await this.reqAppClient.post(
        this.adpConfig.request?.endpoint || "/v1/qbot/chat/sse",
        camelToSnakeKeys(requestBody),
        { responseType: "stream" }
      );
      const sseStream = response.data;
      let buffer = "";
      let interruptRequested = false;
      let thinkingStart = false;
      let thinkingMessageSet = /* @__PURE__ */ new Set();
      for await (const chunk of sseStream) {
        buffer += chunk.toString();
        const parts = buffer.split("\n\n");
        buffer = parts.pop() || "";
        for (const part of parts) {
          if (!part.trim()) continue;
          const event = { data: "", event: "" };
          for (const line of part.split("\n")) {
            if (line.startsWith("data:")) {
              event.data += line.slice(5);
            } else if (line.startsWith("event:")) {
              event.event = line.slice(6);
            }
          }
          if (event.data) {
            let data;
            try {
              data = JSON.parse(event.data);
            } catch (e) {
              throw new AdpAgentError(
                `ADP returned invalid data: ${event.data}`,
                "INVALID_DATA"
              );
            }
            switch (data.type) {
              case "reply": {
                if (data.payload.is_from_self) {
                  if (data.payload.is_evil) {
                    throw new AdpAgentError(
                      "Message filtered by ADP",
                      "FILTERED_MESSAGE"
                    );
                  } else {
                    continue;
                  }
                }
                const messageId = data.payload.record_id;
                const isFinal = data.payload.is_final;
                data.payload.content = data.payload.content.replace(
                  /\\n/g,
                  "\n\n"
                );
                switch (data.payload.reply_method) {
                  case 1 /* LLM_REPLY */: {
                    subscriber.next({
                      type: import_client.EventType.TEXT_MESSAGE_CHUNK,
                      messageId,
                      delta: data.payload.content
                    });
                    break;
                  }
                  case 16 /* WORKFLOW_REPLY */: {
                    subscriber.next({
                      type: import_client.EventType.TEXT_MESSAGE_CHUNK,
                      messageId,
                      delta: data.payload.content
                    });
                    if (isFinal && data.payload.work_flow && [
                      0 /* Pending */,
                      1 /* Running */
                    ].includes(data.payload.work_flow.current_node.Status)) {
                      subscriber.next({
                        type: import_client.EventType.TOOL_CALL_START,
                        toolCallId: data.payload.work_flow.current_node.NodeID,
                        toolCallName: `${data.payload.work_flow.workflow_name}-${data.payload.work_flow.current_node.NodeName}`,
                        parentMessageId: messageId
                      });
                      subscriber.next({
                        type: import_client.EventType.TOOL_CALL_ARGS,
                        toolCallId: data.payload.work_flow.current_node.NodeID,
                        delta: data.payload.work_flow.current_node.Input || "{}"
                      });
                      subscriber.next({
                        type: import_client.EventType.TOOL_CALL_END,
                        toolCallId: data.payload.work_flow.current_node.NodeID
                      });
                      interruptRequested = true;
                    }
                    break;
                  }
                  case 17 /* WORKFLOW_EXECUTION_END */: {
                    subscriber.next({
                      type: import_client.EventType.TOOL_CALL_RESULT,
                      messageId,
                      toolCallId: data.payload.work_flow.current_node.NodeID,
                      content: (data.payload.work_flow?.outputs || []).join(
                        "\n\n"
                      )
                    });
                    subscriber.next({
                      type: import_client.EventType.TEXT_MESSAGE_CHUNK,
                      messageId,
                      delta: data.payload.content
                    });
                    break;
                  }
                  default: {
                    subscriber.next({
                      type: import_client.EventType.TEXT_MESSAGE_CHUNK,
                      messageId,
                      delta: data.payload.content
                    });
                    break;
                  }
                }
                break;
              }
              case "thought": {
                const messageId = data.payload.record_id;
                if (!thinkingStart) {
                  thinkingStart = true;
                  subscriber.next({
                    type: import_client.EventType.THINKING_START,
                    messageId
                  });
                }
                data.payload.procedures.forEach((procedure) => {
                  if (!thinkingMessageSet.has(messageId)) {
                    thinkingMessageSet.add(messageId);
                    subscriber.next({
                      type: import_client.EventType.THINKING_TEXT_MESSAGE_START,
                      messageId,
                      delta: procedure.debugging.content
                    });
                  } else {
                    if (procedure.status === "processing") {
                      subscriber.next({
                        type: import_client.EventType.THINKING_TEXT_MESSAGE_CONTENT,
                        messageId,
                        delta: procedure.debugging.content
                      });
                    } else {
                      thinkingMessageSet.delete(messageId);
                      subscriber.next({
                        type: import_client.EventType.THINKING_TEXT_MESSAGE_END,
                        messageId
                      });
                    }
                  }
                });
                const allFinished = data.payload.procedures.every(
                  (procedure) => procedure.status !== "processing"
                );
                if (allFinished) {
                  thinkingStart = false;
                  thinkingMessageSet.clear();
                  subscriber.next({
                    type: import_client.EventType.THINKING_END,
                    messageId
                  });
                }
                break;
              }
              case "error": {
                console.error(JSON.stringify(data));
                throw new AdpAgentError(
                  data.error.message,
                  `ADP_ERROR_${data.error.code}` || "ADP_ERROR_0"
                );
              }
              case "token_stat": {
                console.debug(JSON.stringify(data));
                break;
              }
              case "reference": {
                break;
              }
              default: {
                break;
              }
            }
          }
        }
      }
      if (interruptRequested) {
        subscriber.next({
          type: import_client.EventType.RUN_FINISHED,
          runId,
          threadId,
          outcome: "interrupt",
          interrupt: {}
        });
      } else {
        subscriber.next({
          type: import_client.EventType.RUN_FINISHED,
          threadId,
          runId
        });
      }
      subscriber.complete();
    } catch (e) {
      console.error(JSON.stringify(e));
      let code = "UNKNOWN_ERROR";
      let message = JSON.stringify(e);
      if (e instanceof import_axios.AxiosError) {
        code = e.code || "REQUEST_ERROR";
        message = e.message;
      } else if (e instanceof AdpAgentError) {
        code = e.code || "AGENT_ERROR";
        message = e.message;
      }
      subscriber.next({
        type: import_client.EventType.RUN_ERROR,
        code,
        message: `Sorry, an error occurred while running the agent: Error code ${code}, ${message}`
      });
      subscriber.complete();
    }
  }
};
function convertAGUIMessagesToAdpMessages(messages) {
  let result = "";
  let trimmed = messages.length;
  for (const message of messages.reverse()) {
    if (message.role === "assistant") {
      break;
    }
    if (message.role === "user") {
      trimmed--;
      let content = "";
      if (typeof message.content === "string") {
        content = message.content;
      } else {
        content = message.content.reduce((acc, cur) => {
          if (cur.type === "text") {
            return acc + `${cur.text} `;
          } else if (cur.type === "binary") {
            return acc + `![${cur.filename}](${cur.url}) `;
          } else {
            return acc;
          }
        }, "").trim();
      }
      result = `${message.role}: ${content}
${result}`;
    } else {
      result = `${message.role}: ${message.content}
${result}`;
    }
  }
  return { message: result.trim(), trimmed };
}
async function extractDocuments(messages, config, reqLkeClient) {
  const documentFiles = [];
  const newMessages = messages.map((msg) => {
    if (msg.role === "user" && Array.isArray(msg.content)) {
      let newContent = [];
      msg.content.forEach((item) => {
        if (item.type === "text") {
          newContent.push(item);
        } else if (item.type === "binary") {
          if (Object.keys(MIME_TYPES).includes(item.mimeType)) {
            documentFiles.push(item);
          }
        }
      });
      return {
        ...msg,
        content: newContent
      };
    } else return msg;
  });
  const documentAddresses = [];
  const fileInfos = [];
  return {
    messages: newMessages,
    fileInfos
  };
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AdpAgent,
  AdpAgentError,
  CurrentNodeStatus,
  ReplyMethod
});
//# sourceMappingURL=index.js.map