{"version":3,"file":"responses.js","names":["schema: Record<string, unknown>","tool: {\n      type: \"function\";\n      function: FunctionDefinition;\n    }","options?: ToolStrategyOptions","schema: InteropZodObject | Record<string, unknown>","outputOptions?: ToolStrategyOptions","name?: string","asJsonSchema","tool","functionDefinition: FunctionDefinition","toolArgs: Record<string, unknown>","schemaOrOptions:\n      | Record<string, unknown>\n      | { schema: Record<string, unknown>; strict?: boolean }","strict?: boolean","schema: InteropZodType<T> | Record<string, unknown>","response: AIMessage","textContent: string | undefined","responseFormat?:\n    | InteropZodType<any>\n    | InteropZodType<any>[]\n    | JsonSchemaFormat\n    | JsonSchemaFormat[]\n    | ResponseFormat\n    | ToolStrategy<any>[]\n    | ResponseFormatUndefined","model?: LanguageModelLike | string","responseFormat:\n    | InteropZodType<any>\n    | InteropZodType<any>[]\n    | JsonSchemaFormat\n    | JsonSchemaFormat[]","responseFormat:\n    | InteropZodType<unknown>\n    | JsonSchemaFormat\n    | { schema: InteropZodType<unknown> | JsonSchemaFormat; strict?: boolean }"],"sources":["../../src/agents/responses.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-instanceof/no-instanceof */\nimport {\n  InteropZodObject,\n  isInteropZodSchema,\n  InteropZodType,\n  isInteropZodObject,\n} from \"@langchain/core/utils/types\";\nimport { type AIMessage } from \"@langchain/core/messages\";\nimport { type LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport { toJsonSchema, Validator } from \"@langchain/core/utils/json_schema\";\nimport { type FunctionDefinition } from \"@langchain/core/language_models/base\";\n\nimport {\n  StructuredOutputParsingError,\n  MultipleStructuredOutputsError,\n} from \"./errors.js\";\nimport { isConfigurableModel, isBaseChatModel } from \"./model.js\";\n\n/**\n * Special type to indicate that no response format is provided.\n * When this type is used, the structuredResponse property should not be present in the result.\n */\nexport type ResponseFormatUndefined = {\n  __responseFormatUndefined: true;\n};\n\n/**\n * Default value for strict mode in providerStrategy.\n *\n * When using providerStrategy with json_schema response format, OpenAI's parse() method\n * requires all function tools to have strict: true. This ensures the model's output\n * exactly matches the provided JSON schema.\n *\n * @see https://platform.openai.com/docs/guides/structured-outputs\n */\nconst PROVIDER_STRATEGY_DEFAULT_STRICT = true;\n\n/**\n * This is a global counter for generating unique names for tools.\n */\nlet bindingIdentifier = 0;\n\n/**\n * Information for tracking structured output tool metadata.\n * This contains all necessary information to handle structured responses generated\n * via tool calls, including the original schema, its type classification, and the\n * corresponding tool implementation used by the tools strategy.\n */\nexport class ToolStrategy<_T = unknown> {\n  private constructor(\n    /**\n     * The original JSON Schema provided for structured output\n     */\n    public readonly schema: Record<string, unknown>,\n\n    /**\n     * The tool that will be used to parse the tool call arguments.\n     */\n    public readonly tool: {\n      type: \"function\";\n      function: FunctionDefinition;\n    },\n\n    /**\n     * The options to use for the tool output.\n     */\n    public readonly options?: ToolStrategyOptions\n  ) {}\n\n  get name() {\n    return this.tool.function.name;\n  }\n\n  static fromSchema<S extends InteropZodObject>(\n    schema: S,\n    outputOptions?: ToolStrategyOptions\n  ): ToolStrategy<S extends InteropZodType<infer U> ? U : unknown>;\n\n  static fromSchema(\n    schema: Record<string, unknown>,\n    outputOptions?: ToolStrategyOptions\n  ): ToolStrategy<Record<string, unknown>>;\n\n  static fromSchema(\n    schema: InteropZodObject | Record<string, unknown>,\n    outputOptions?: ToolStrategyOptions\n  ): ToolStrategy<any> {\n    /**\n     * It is required for tools to have a name so we can map the tool call to the correct tool\n     * when parsing the response.\n     */\n    function getFunctionName(name?: string) {\n      return name ?? `extract-${++bindingIdentifier}`;\n    }\n\n    if (isInteropZodSchema(schema)) {\n      const asJsonSchema = toJsonSchema(schema);\n      const tool = {\n        type: \"function\" as const,\n        function: {\n          name: getFunctionName(asJsonSchema.title),\n          strict: false,\n          description:\n            asJsonSchema.description ??\n            \"Tool for extracting structured output from the model's response.\",\n          parameters: asJsonSchema,\n        },\n      };\n      return new ToolStrategy(asJsonSchema, tool, outputOptions);\n    }\n\n    let functionDefinition: FunctionDefinition;\n    if (\n      typeof schema.name === \"string\" &&\n      typeof schema.parameters === \"object\" &&\n      schema.parameters != null\n    ) {\n      functionDefinition = schema as unknown as FunctionDefinition;\n    } else {\n      functionDefinition = {\n        name: getFunctionName(schema.title as string),\n        description: (schema.description as string) ?? \"\",\n        parameters: schema.schema || (schema as Record<string, unknown>),\n      };\n    }\n    const asJsonSchema = toJsonSchema(schema);\n    const tool = {\n      type: \"function\" as const,\n      function: functionDefinition,\n    };\n    return new ToolStrategy(asJsonSchema, tool, outputOptions);\n  }\n\n  /**\n   * Parse tool arguments according to the schema.\n   *\n   * @throws {StructuredOutputParsingError} if the response is not valid\n   * @param toolArgs - The arguments from the tool call\n   * @returns The parsed response according to the schema type\n   */\n  parse(toolArgs: Record<string, unknown>): Record<string, unknown> {\n    const validator = new Validator(this.schema);\n    const result = validator.validate(toolArgs);\n    if (!result.valid) {\n      throw new StructuredOutputParsingError(\n        this.name,\n        result.errors.map((e) => e.error)\n      );\n    }\n    return toolArgs;\n  }\n}\n\nexport class ProviderStrategy<T = unknown> {\n  // @ts-expect-error - _schemaType is used only for type inference\n  private _schemaType?: T;\n\n  /**\n   * The schema to use for the provider strategy\n   */\n  public readonly schema: Record<string, unknown>;\n\n  /**\n   * Whether to use strict mode for the provider strategy\n   */\n  public readonly strict: boolean;\n\n  private constructor(options: {\n    schema: Record<string, unknown>;\n    strict?: boolean;\n  });\n  private constructor(schema: Record<string, unknown>, strict?: boolean);\n  private constructor(\n    schemaOrOptions:\n      | Record<string, unknown>\n      | { schema: Record<string, unknown>; strict?: boolean },\n    strict?: boolean\n  ) {\n    if (\n      \"schema\" in schemaOrOptions &&\n      typeof schemaOrOptions.schema === \"object\" &&\n      schemaOrOptions.schema !== null &&\n      !(\"type\" in schemaOrOptions)\n    ) {\n      const options = schemaOrOptions as {\n        schema: Record<string, unknown>;\n        strict?: boolean;\n      };\n      this.schema = options.schema;\n      this.strict = options.strict ?? PROVIDER_STRATEGY_DEFAULT_STRICT;\n    } else {\n      this.schema = schemaOrOptions as Record<string, unknown>;\n      this.strict = strict ?? PROVIDER_STRATEGY_DEFAULT_STRICT;\n    }\n  }\n\n  static fromSchema<T>(\n    schema: InteropZodType<T>,\n    strict?: boolean\n  ): ProviderStrategy<T>;\n\n  static fromSchema(\n    schema: Record<string, unknown>,\n    strict?: boolean\n  ): ProviderStrategy<Record<string, unknown>>;\n\n  static fromSchema<T = unknown>(\n    schema: InteropZodType<T> | Record<string, unknown>,\n    strict?: boolean\n  ): ProviderStrategy<T> | ProviderStrategy<Record<string, unknown>> {\n    const asJsonSchema = toJsonSchema(schema);\n    return new ProviderStrategy(asJsonSchema, strict) as\n      | ProviderStrategy<T>\n      | ProviderStrategy<Record<string, unknown>>;\n  }\n\n  /**\n   * Parse tool arguments according to the schema. If the response is not valid, return undefined.\n   *\n   * @param response - The AI message response to parse\n   * @returns The parsed response according to the schema type\n   */\n  parse(response: AIMessage) {\n    /**\n     * Extract text content from the response.\n     * Handles both string content and array content (e.g., from thinking models).\n     */\n    let textContent: string | undefined;\n\n    if (typeof response.content === \"string\") {\n      textContent = response.content;\n    } else if (Array.isArray(response.content)) {\n      /**\n       * For thinking models, content is an array with thinking blocks and text blocks.\n       * Extract the text from text blocks.\n       */\n      for (const block of response.content) {\n        if (\n          typeof block === \"object\" &&\n          block !== null &&\n          \"type\" in block &&\n          block.type === \"text\" &&\n          \"text\" in block &&\n          typeof block.text === \"string\"\n        ) {\n          textContent = block.text;\n          break; // Use the first text block found\n        }\n      }\n    }\n\n    // Return if no valid text content found\n    if (!textContent || textContent === \"\") {\n      return;\n    }\n\n    try {\n      const content = JSON.parse(textContent);\n      const validator = new Validator(this.schema);\n      const result = validator.validate(content);\n      if (!result.valid) {\n        return;\n      }\n\n      return content;\n    } catch {\n      // no-op\n    }\n  }\n}\n\nexport type ResponseFormat = ToolStrategy<any> | ProviderStrategy<any>;\n\n/**\n * Handle user input for `responseFormat` parameter of `CreateAgentParams`.\n * This function defines the default behavior for the `responseFormat` parameter, which is:\n *\n * - if value is a Zod schema, default to structured output via tool calling\n * - if value is a JSON schema, default to structured output via tool calling\n * - if value is a custom response format, return it as is\n * - if value is an array, ensure all array elements are instance of `ToolStrategy`\n * @param responseFormat - The response format to transform, provided by the user\n * @param options - The response format options for tool strategy\n * @param model - The model to check if it supports JSON schema output\n * @returns\n */\nexport function transformResponseFormat(\n  responseFormat?:\n    | InteropZodType<any>\n    | InteropZodType<any>[]\n    | JsonSchemaFormat\n    | JsonSchemaFormat[]\n    | ResponseFormat\n    | ToolStrategy<any>[]\n    | ResponseFormatUndefined,\n  options?: ToolStrategyOptions,\n  model?: LanguageModelLike | string\n): ResponseFormat[] {\n  if (!responseFormat) {\n    return [];\n  }\n\n  // Handle ResponseFormatUndefined case\n  if (\n    typeof responseFormat === \"object\" &&\n    responseFormat !== null &&\n    \"__responseFormatUndefined\" in responseFormat\n  ) {\n    return [];\n  }\n\n  /**\n   * If users provide an array, it should only contain raw schemas (Zod or JSON schema),\n   * not ToolStrategy or ProviderStrategy instances.\n   */\n  if (Array.isArray(responseFormat)) {\n    /**\n     * if every entry is a ToolStrategy or ProviderStrategy instance, return the array as is\n     */\n    if (\n      responseFormat.every(\n        (item) =>\n          item instanceof ToolStrategy || item instanceof ProviderStrategy\n      )\n    ) {\n      return responseFormat as unknown as ResponseFormat[];\n    }\n\n    /**\n     * Check if all items are Zod schemas\n     */\n    if (responseFormat.every((item) => isInteropZodObject(item))) {\n      return responseFormat.map((item) =>\n        ToolStrategy.fromSchema(item as InteropZodObject, options)\n      );\n    }\n\n    /**\n     * Check if all items are plain objects (JSON schema)\n     */\n    if (\n      responseFormat.every(\n        (item) =>\n          typeof item === \"object\" && item !== null && !isInteropZodObject(item)\n      )\n    ) {\n      return responseFormat.map((item) =>\n        ToolStrategy.fromSchema(item as JsonSchemaFormat, options)\n      );\n    }\n\n    throw new Error(\n      `Invalid response format: list contains mixed types.\\n` +\n        `All items must be either InteropZodObject or plain JSON schema objects.`\n    );\n  }\n\n  if (\n    responseFormat instanceof ToolStrategy ||\n    responseFormat instanceof ProviderStrategy\n  ) {\n    return [responseFormat];\n  }\n\n  const useProviderStrategy = hasSupportForJsonSchemaOutput(model);\n\n  /**\n   * `responseFormat` is a Zod schema\n   */\n  if (isInteropZodObject(responseFormat)) {\n    return useProviderStrategy\n      ? [ProviderStrategy.fromSchema(responseFormat)]\n      : [ToolStrategy.fromSchema(responseFormat, options)];\n  }\n\n  /**\n   * Handle plain object (JSON schema)\n   */\n  if (\n    typeof responseFormat === \"object\" &&\n    responseFormat !== null &&\n    \"properties\" in responseFormat\n  ) {\n    return useProviderStrategy\n      ? [ProviderStrategy.fromSchema(responseFormat as JsonSchemaFormat)]\n      : [ToolStrategy.fromSchema(responseFormat as JsonSchemaFormat, options)];\n  }\n\n  throw new Error(`Invalid response format: ${String(responseFormat)}`);\n}\n\n/**\n * Branded type for ToolStrategy arrays that preserves type information\n */\nexport interface TypedToolStrategy<T = unknown>\n  extends Array<ToolStrategy<any>> {\n  _schemaType?: T;\n}\nexport type ToolStrategyError =\n  | StructuredOutputParsingError\n  | MultipleStructuredOutputsError;\nexport interface ToolStrategyOptions {\n  /**\n   * Allows you to customize the message that appears in the conversation history when structured\n   * output is generated.\n   */\n  toolMessageContent?: string;\n  /**\n   * Handle errors from the structured output tool call. Using tools to generate structured output\n   * can cause errors, e.g. if:\n   * - you provide multiple structured output schemas and the model calls multiple structured output tools\n   * - if the structured output generated by the tool call doesn't match provided schema\n   *\n   * This property allows to handle these errors in different ways:\n   * - `true` - retry the tool call\n   * - `false` - throw an error\n   * - `string` - retry the tool call with the provided message\n   * - `(error: ToolStrategyError) => Promise<string> | string` - retry with the provided message or throw the error\n   *\n   * @default true\n   */\n  handleError?:\n    | boolean\n    | string\n    | ((error: ToolStrategyError) => Promise<string> | string);\n}\n\nexport function toolStrategy<T extends InteropZodType<any>>(\n  responseFormat: T,\n  options?: ToolStrategyOptions\n): TypedToolStrategy<T extends InteropZodType<infer U> ? U : never>;\nexport function toolStrategy<T extends readonly InteropZodType<any>[]>(\n  responseFormat: T,\n  options?: ToolStrategyOptions\n): TypedToolStrategy<\n  { [K in keyof T]: T[K] extends InteropZodType<infer U> ? U : never }[number]\n>;\nexport function toolStrategy(\n  responseFormat: JsonSchemaFormat,\n  options?: ToolStrategyOptions\n): TypedToolStrategy<Record<string, unknown>>;\nexport function toolStrategy(\n  responseFormat: JsonSchemaFormat[],\n  options?: ToolStrategyOptions\n): TypedToolStrategy<Record<string, unknown>>;\n\n/**\n * Creates a tool strategy for structured output using function calling.\n *\n * This function configures structured output by converting schemas into function tools that\n * the model calls. Unlike `providerStrategy`, which uses native JSON schema support,\n * `toolStrategy` works with any model that supports function calling, making it more\n * widely compatible across providers and model versions.\n *\n * The model will call a function with arguments matching your schema, and the agent will\n * extract and validate the structured output from the tool call. This approach is automatically\n * used when your model doesn't support native JSON schema output.\n *\n * @param responseFormat - The schema(s) to enforce. Can be a single Zod schema, an array of Zod schemas,\n *   a JSON schema object, or an array of JSON schema objects.\n * @param options - Optional configuration for the tool strategy\n * @param options.handleError - How to handle errors when the model calls multiple structured output tools\n *   or when the output doesn't match the schema. Defaults to `true` (auto-retry). Can be `false` (throw),\n *   a `string` (retry with message), or a `function` (custom handler).\n * @param options.toolMessageContent - Custom message content to include in conversation history\n *   when structured output is generated via tool call\n * @returns A `TypedToolStrategy` instance that can be used as the `responseFormat` in `createAgent`\n *\n * @example\n * ```ts\n * import { toolStrategy, createAgent } from \"langchain\";\n * import { z } from \"zod\";\n *\n * const agent = createAgent({\n *   model: \"claude-haiku-4-5\",\n *   responseFormat: toolStrategy(\n *     z.object({\n *       answer: z.string(),\n *       confidence: z.number().min(0).max(1),\n *     })\n *   ),\n * });\n * ```\n *\n * @example\n * ```ts\n * // Multiple schemas - model can choose which one to use\n * const agent = createAgent({\n *   model: \"claude-haiku-4-5\",\n *   responseFormat: toolStrategy([\n *     z.object({ name: z.string(), age: z.number() }),\n *     z.object({ email: z.string(), phone: z.string() }),\n *   ]),\n * });\n * ```\n */\nexport function toolStrategy(\n  responseFormat:\n    | InteropZodType<any>\n    | InteropZodType<any>[]\n    | JsonSchemaFormat\n    | JsonSchemaFormat[],\n  options?: ToolStrategyOptions\n): TypedToolStrategy {\n  return transformResponseFormat(responseFormat, options) as TypedToolStrategy;\n}\n\n/**\n * Creates a provider strategy for structured output using native JSON schema support.\n *\n * This function is used to configure structured output for agents when the underlying model\n * supports native JSON schema output (e.g., OpenAI's `gpt-4o`, `gpt-4o-mini`, and newer models).\n * Unlike `toolStrategy`, which uses function calling to extract structured output, `providerStrategy`\n * leverages the provider's native structured output capabilities, resulting in more efficient\n * and reliable schema enforcement.\n *\n * When used with a model that supports JSON schema output, the model will return responses\n * that directly conform to the provided schema without requiring tool calls. This is the\n * recommended approach for structured output when your model supports it.\n *\n * @param responseFormat - The schema to enforce, either a Zod schema, a JSON schema object, or an options object with `schema` and optional `strict` flag\n * @returns A `ProviderStrategy` instance that can be used as the `responseFormat` in `createAgent`\n *\n * @example\n * ```ts\n * import { providerStrategy, createAgent } from \"langchain\";\n * import { z } from \"zod\";\n *\n * const agent = createAgent({\n *   model: \"claude-haiku-4-5\",\n *   responseFormat: providerStrategy(\n *     z.object({\n *       answer: z.string().describe(\"The answer to the question\"),\n *       confidence: z.number().min(0).max(1),\n *     })\n *   ),\n * });\n * ```\n *\n * @example\n * ```ts\n * // Using strict mode for stricter schema enforcement\n * const agent = createAgent({\n *   model: \"claude-haiku-4-5\",\n *   responseFormat: providerStrategy({\n *     schema: z.object({\n *       name: z.string(),\n *       age: z.number(),\n *     }),\n *     strict: true\n *   }),\n * });\n * ```\n */\nexport function providerStrategy<T extends InteropZodType<unknown>>(\n  responseFormat: T | { schema: T; strict?: boolean }\n): ProviderStrategy<T extends InteropZodType<infer U> ? U : never>;\nexport function providerStrategy(\n  responseFormat:\n    | JsonSchemaFormat\n    | { schema: JsonSchemaFormat; strict?: boolean }\n): ProviderStrategy<Record<string, unknown>>;\nexport function providerStrategy(\n  responseFormat:\n    | InteropZodType<unknown>\n    | JsonSchemaFormat\n    | { schema: InteropZodType<unknown> | JsonSchemaFormat; strict?: boolean }\n): ProviderStrategy<unknown> {\n  /**\n   * Handle options object format\n   */\n  if (\n    typeof responseFormat === \"object\" &&\n    responseFormat !== null &&\n    \"schema\" in responseFormat &&\n    !isInteropZodSchema(responseFormat) &&\n    !(\"type\" in responseFormat)\n  ) {\n    const { schema, strict: strictFlag } = responseFormat as {\n      schema: InteropZodType<unknown> | JsonSchemaFormat;\n      strict?: boolean;\n    };\n    return ProviderStrategy.fromSchema(\n      schema as InteropZodType<unknown>,\n      strictFlag\n    ) as ProviderStrategy<unknown>;\n  }\n\n  /**\n   * Handle direct schema format\n   */\n  return ProviderStrategy.fromSchema(\n    responseFormat as InteropZodType<unknown>\n  ) as ProviderStrategy<unknown>;\n}\n\n/**\n * Type representing a JSON Schema object format.\n * This is a strict type that excludes ToolStrategy and ProviderStrategy instances.\n */\nexport type JsonSchemaFormat = {\n  type:\n    | \"null\"\n    | \"boolean\"\n    | \"object\"\n    | \"array\"\n    | \"number\"\n    | \"string\"\n    | \"integer\";\n  properties?: Record<string, unknown>;\n  required?: string[];\n  additionalProperties?: boolean;\n  [key: string]: unknown;\n} & {\n  // Brand to ensure this is not a ToolStrategy or ProviderStrategy\n  __brand?: never;\n};\n\nconst CHAT_MODELS_THAT_SUPPORT_JSON_SCHEMA_OUTPUT = [\"ChatOpenAI\", \"ChatXAI\"];\nconst MODEL_NAMES_THAT_SUPPORT_JSON_SCHEMA_OUTPUT = [\n  \"grok\",\n  \"gpt-5\",\n  \"gpt-4.1\",\n  \"gpt-4o\",\n  \"gpt-oss\",\n  \"o3-pro\",\n  \"o3-mini\",\n];\n\n/**\n * Identifies the models that support JSON schema output\n * @param model - The model to check\n * @returns True if the model supports JSON schema output, false otherwise\n */\nexport function hasSupportForJsonSchemaOutput(\n  model?: LanguageModelLike | string\n): boolean {\n  if (!model) {\n    return false;\n  }\n\n  if (typeof model === \"string\") {\n    const modelName = model.split(\":\").pop() as string;\n    return MODEL_NAMES_THAT_SUPPORT_JSON_SCHEMA_OUTPUT.some(\n      (modelNameSnippet) => modelName.includes(modelNameSnippet)\n    );\n  }\n\n  if (isConfigurableModel(model)) {\n    const configurableModel = model as unknown as {\n      _defaultConfig: { model: string };\n    };\n    return hasSupportForJsonSchemaOutput(\n      configurableModel._defaultConfig.model\n    );\n  }\n\n  if (!isBaseChatModel(model)) {\n    return false;\n  }\n\n  const chatModelClass = model.getName();\n\n  /**\n   * for testing purposes only\n   */\n  if (chatModelClass === \"FakeToolCallingChatModel\") {\n    return true;\n  }\n\n  if (\n    CHAT_MODELS_THAT_SUPPORT_JSON_SCHEMA_OUTPUT.includes(chatModelClass) &&\n    /**\n     * OpenAI models\n     */ ((\"model\" in model &&\n      MODEL_NAMES_THAT_SUPPORT_JSON_SCHEMA_OUTPUT.some(\n        (modelNameSnippet) =>\n          typeof model.model === \"string\" &&\n          model.model.includes(modelNameSnippet)\n      )) ||\n      /**\n       * for testing purposes only\n       */\n      (chatModelClass === \"FakeToolCallingModel\" &&\n        \"structuredResponse\" in model))\n  ) {\n    return true;\n  }\n\n  return false;\n}\n"],"mappings":";;;;;;;;;;;;;;;AAoCA,MAAM,mCAAmC;;;;AAKzC,IAAI,oBAAoB;;;;;;;AAQxB,IAAa,eAAb,MAAa,aAA2B;CACtC,AAAQ,YAIUA,QAKAC,MAQAC,SAChB;EAdgB;EAKA;EAQA;CACd;CAEJ,IAAI,OAAO;AACT,SAAO,KAAK,KAAK,SAAS;CAC3B;CAYD,OAAO,WACLC,QACAC,eACmB;;;;;EAKnB,SAAS,gBAAgBC,MAAe;AACtC,UAAO,QAAQ,CAAC,QAAQ,EAAE,EAAE,mBAAmB;EAChD;AAED,MAAI,mBAAmB,OAAO,EAAE;GAC9B,MAAMC,iBAAe,aAAa,OAAO;GACzC,MAAMC,SAAO;IACX,MAAM;IACN,UAAU;KACR,MAAM,gBAAgBD,eAAa,MAAM;KACzC,QAAQ;KACR,aACEA,eAAa,eACb;KACF,YAAYA;IACb;GACF;AACD,UAAO,IAAI,aAAaA,gBAAcC,QAAM;EAC7C;EAED,IAAIC;AACJ,MACE,OAAO,OAAO,SAAS,YACvB,OAAO,OAAO,eAAe,YAC7B,OAAO,cAAc,MAErB,qBAAqB;OAErB,qBAAqB;GACnB,MAAM,gBAAgB,OAAO,MAAgB;GAC7C,aAAc,OAAO,eAA0B;GAC/C,YAAY,OAAO,UAAW;EAC/B;EAEH,MAAM,eAAe,aAAa,OAAO;EACzC,MAAM,OAAO;GACX,MAAM;GACN,UAAU;EACX;AACD,SAAO,IAAI,aAAa,cAAc,MAAM;CAC7C;;;;;;;;CASD,MAAMC,UAA4D;EAChE,MAAM,YAAY,IAAI,UAAU,KAAK;EACrC,MAAM,SAAS,UAAU,SAAS,SAAS;AAC3C,MAAI,CAAC,OAAO,MACV,OAAM,IAAI,6BACR,KAAK,MACL,OAAO,OAAO,IAAI,CAAC,MAAM,EAAE,MAAM;AAGrC,SAAO;CACR;AACF;AAED,IAAa,mBAAb,MAAa,iBAA8B;CAEzC,AAAQ;;;;CAKR,AAAgB;;;;CAKhB,AAAgB;CAOhB,AAAQ,YACNC,iBAGAC,QACA;AACA,MACE,YAAY,mBACZ,OAAO,gBAAgB,WAAW,YAClC,gBAAgB,WAAW,QAC3B,EAAE,UAAU,kBACZ;GACA,MAAM,UAAU;GAIhB,KAAK,SAAS,QAAQ;GACtB,KAAK,SAAS,QAAQ,UAAU;EACjC,OAAM;GACL,KAAK,SAAS;GACd,KAAK,SAAS,UAAU;EACzB;CACF;CAYD,OAAO,WACLC,QACAD,QACiE;EACjE,MAAM,eAAe,aAAa,OAAO;AACzC,SAAO,IAAI,iBAAiB,cAAc;CAG3C;;;;;;;CAQD,MAAME,UAAqB;;;;;EAKzB,IAAIC;AAEJ,MAAI,OAAO,SAAS,YAAY,UAC9B,cAAc,SAAS;WACd,MAAM,QAAQ,SAAS,QAAQ,EAKxC;;;;;QAAK,MAAM,SAAS,SAAS,QAC3B,KACE,OAAO,UAAU,YACjB,UAAU,QACV,UAAU,SACV,MAAM,SAAS,UACf,UAAU,SACV,OAAO,MAAM,SAAS,UACtB;IACA,cAAc,MAAM;AACpB;GACD;EACF;AAIH,MAAI,CAAC,eAAe,gBAAgB,GAClC;AAGF,MAAI;GACF,MAAM,UAAU,KAAK,MAAM,YAAY;GACvC,MAAM,YAAY,IAAI,UAAU,KAAK;GACrC,MAAM,SAAS,UAAU,SAAS,QAAQ;AAC1C,OAAI,CAAC,OAAO,MACV;AAGF,UAAO;EACR,QAAO,CAEP;CACF;AACF;;;;;;;;;;;;;;AAiBD,SAAgB,wBACdC,gBAQAb,SACAc,OACkB;AAClB,KAAI,CAAC,eACH,QAAO,CAAE;AAIX,KACE,OAAO,mBAAmB,YAC1B,mBAAmB,QACnB,+BAA+B,eAE/B,QAAO,CAAE;;;;;AAOX,KAAI,MAAM,QAAQ,eAAe,EAAE;;;;AAIjC,MACE,eAAe,MACb,CAAC,SACC,gBAAgB,gBAAgB,gBAAgB,iBACnD,CAED,QAAO;;;;AAMT,MAAI,eAAe,MAAM,CAAC,SAAS,mBAAmB,KAAK,CAAC,CAC1D,QAAO,eAAe,IAAI,CAAC,SACzB,aAAa,WAAW,MAA0B,QAAQ,CAC3D;;;;AAMH,MACE,eAAe,MACb,CAAC,SACC,OAAO,SAAS,YAAY,SAAS,QAAQ,CAAC,mBAAmB,KAAK,CACzE,CAED,QAAO,eAAe,IAAI,CAAC,SACzB,aAAa,WAAW,MAA0B,QAAQ,CAC3D;AAGH,QAAM,IAAI,MACR;CAGH;AAED,KACE,0BAA0B,gBAC1B,0BAA0B,iBAE1B,QAAO,CAAC,cAAe;CAGzB,MAAM,sBAAsB,8BAA8B,MAAM;;;;AAKhE,KAAI,mBAAmB,eAAe,CACpC,QAAO,sBACH,CAAC,iBAAiB,WAAW,eAAe,AAAC,IAC7C,CAAC,aAAa,WAAW,gBAAgB,QAAQ,AAAC;;;;AAMxD,KACE,OAAO,mBAAmB,YAC1B,mBAAmB,QACnB,gBAAgB,eAEhB,QAAO,sBACH,CAAC,iBAAiB,WAAW,eAAmC,AAAC,IACjE,CAAC,aAAa,WAAW,gBAAoC,QAAQ,AAAC;AAG5E,OAAM,IAAI,MAAM,CAAC,yBAAyB,EAAE,OAAO,eAAe,EAAE;AACrE;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2GD,SAAgB,aACdC,gBAKAf,SACmB;AACnB,QAAO,wBAAwB,gBAAgB,QAAQ;AACxD;AAyDD,SAAgB,iBACdgB,gBAI2B;;;;AAI3B,KACE,OAAO,mBAAmB,YAC1B,mBAAmB,QACnB,YAAY,kBACZ,CAAC,mBAAmB,eAAe,IACnC,EAAE,UAAU,iBACZ;EACA,MAAM,EAAE,QAAQ,QAAQ,YAAY,GAAG;AAIvC,SAAO,iBAAiB,WACtB,QACA,WACD;CACF;;;;AAKD,QAAO,iBAAiB,WACtB,eACD;AACF;AAwBD,MAAM,8CAA8C,CAAC,cAAc,SAAU;AAC7E,MAAM,8CAA8C;CAClD;CACA;CACA;CACA;CACA;CACA;CACA;AACD;;;;;;AAOD,SAAgB,8BACdF,OACS;AACT,KAAI,CAAC,MACH,QAAO;AAGT,KAAI,OAAO,UAAU,UAAU;EAC7B,MAAM,YAAY,MAAM,MAAM,IAAI,CAAC,KAAK;AACxC,SAAO,4CAA4C,KACjD,CAAC,qBAAqB,UAAU,SAAS,iBAAiB,CAC3D;CACF;AAED,KAAI,oBAAoB,MAAM,EAAE;EAC9B,MAAM,oBAAoB;AAG1B,SAAO,8BACL,kBAAkB,eAAe,MAClC;CACF;AAED,KAAI,CAAC,gBAAgB,MAAM,CACzB,QAAO;CAGT,MAAM,iBAAiB,MAAM,SAAS;;;;AAKtC,KAAI,mBAAmB,2BACrB,QAAO;AAGT,KACE,4CAA4C,SAAS,eAAe,KAG9D,WAAW,SACf,4CAA4C,KAC1C,CAAC,qBACC,OAAO,MAAM,UAAU,YACvB,MAAM,MAAM,SAAS,iBAAiB,CACzC,IAIA,mBAAmB,0BAClB,wBAAwB,OAE5B,QAAO;AAGT,QAAO;AACR"}