"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGlobTool = createGlobTool;
const v4_1 = require("zod/v4");
const path = __importStar(require("path"));
const utils_1 = require("./utils");
const utils_2 = require("../utils");
const globParametersSchema = v4_1.z.object({
    patterns: v4_1.z
        .array(v4_1.z.string())
        .describe('Glob patterns to match (e.g., ["*.js", "*.ts", "src/**/*.tsx"])'),
    pattern: v4_1.z
        .union([v4_1.z.string(), v4_1.z.array(v4_1.z.string())])
        .optional()
        .describe('Legacy parameter: Single pattern string or array of patterns (use patterns instead)'),
    path: v4_1.z
        .string()
        .optional()
        .describe("Directory to search in (relative to workspace root, or absolute path within workspace). Defaults to workspace root."),
    case_sensitive: v4_1.z
        .boolean()
        .optional()
        .describe("Whether the search should be case-sensitive (default: false)"),
    include_dirs: v4_1.z
        .boolean()
        .optional()
        .describe("Whether to include directories in results (default: false)"),
    show_hidden: v4_1.z
        .boolean()
        .optional()
        .describe("Whether to include hidden files/directories (starting with .)"),
    max_results: v4_1.z
        .number()
        .min(1)
        .optional()
        .describe("Maximum number of results to return (default: 500)"),
    sort_by_time: v4_1.z
        .boolean()
        .optional()
        .describe("Whether to sort results by modification time, newest first (default: false)"),
});
// Path validation is now handled by validateWorkspacePath in tool-utils
/**
 * Convert glob pattern to regex pattern
 */
function globToRegex(pattern, caseSensitive = false) {
    // Handle special cases for braces {js,ts}
    let regexPattern = pattern;
    // Handle brace expansion like {js,ts,jsx}
    const braceRegex = /\{([^}]+)\}/g;
    regexPattern = regexPattern.replace(braceRegex, (match, content) => {
        const options = content.split(",").map((s) => s.trim());
        return `(${options.join("|")})`;
    });
    // Escape regex special characters except glob chars
    regexPattern = regexPattern
        .replace(/[.+^${}()|[\]\\]/g, "\\$&") // Escape special regex chars except *, ?, and already handled {}
        .replace(/\\\{/g, "{") // Restore { that we want to keep
        .replace(/\\\}/g, "}") // Restore } that we want to keep
        .replace(/\\\|/g, "|") // Restore | that we want to keep
        .replace(/\\\(/g, "(") // Restore ( that we want to keep
        .replace(/\\\)/g, ")"); // Restore ) that we want to keep
    // Handle glob patterns
    regexPattern = regexPattern
        .replace(/\*\*/g, "###DOUBLESTAR###") // Temporarily replace **
        .replace(/\*/g, "[^/]*") // * becomes [^/]* (match any chars except path separator)
        .replace(/###DOUBLESTAR###/g, ".*") // ** becomes .* (match any chars including path separator)
        .replace(/\?/g, "[^/]"); // ? becomes [^/] (match single char except path separator)
    const flags = caseSensitive ? "" : "i";
    return new RegExp(`^${regexPattern}$`, flags);
}
/**
 * Check if a file should be skipped based on common patterns
 */
function shouldSkipPath(relativePath, showHidden) {
    // Skip hidden files unless requested
    if (!showHidden &&
        relativePath.split("/").some((part) => part.startsWith("."))) {
        return true;
    }
    // Skip common directories that should never be searched
    const skipPatterns = [
        /node_modules/,
        /\.git$/,
        /\.svn$/,
        /\.hg$/,
        /\.vscode$/,
        /dist$/,
        /build$/,
        /coverage$/,
        /\.nyc_output$/,
        /\.next$/,
        /\.cache$/,
    ];
    return skipPatterns.some((pattern) => pattern.test(relativePath));
}
/**
 * Recursively find files matching the pattern
 */
async function findMatches(context, searchDir, pattern, options) {
    const results = [];
    const scanDirectory = async (currentDir) => {
        if (results.length >= options.maxResults) {
            return;
        }
        try {
            const entries = (await context.fsOperator.readdir(currentDir, {
                withFileTypes: true,
            }));
            for (const entry of entries) {
                if (results.length >= options.maxResults) {
                    break;
                }
                const fullPath = path.join(currentDir, entry.name.toString());
                const relativePath = path.relative(searchDir, fullPath);
                // Skip paths that should be ignored
                if (shouldSkipPath(relativePath, options.showHidden)) {
                    continue;
                }
                const isDirectory = entry.isDirectory();
                // Check if this path matches the pattern
                const matches = pattern.test(relativePath);
                if (matches && (options.includeDirs || !isDirectory)) {
                    try {
                        const stats = await context.fsOperator.stat(fullPath);
                        results.push({
                            path: relativePath,
                            absolutePath: fullPath,
                            isDirectory,
                            size: isDirectory ? 0 : Number(stats.size),
                            modifiedTime: stats.mtime,
                            extension: isDirectory
                                ? undefined
                                : path.extname(entry.name.toString()).slice(1),
                        });
                    }
                    catch (error) {
                        // Ignore stat errors and continue
                    }
                }
                // Recursively scan subdirectories
                if (isDirectory) {
                    await scanDirectory(fullPath);
                }
            }
        }
        catch (error) {
            // Ignore permission errors and continue
        }
    };
    await scanDirectory(searchDir);
    return results;
}
/**
 * Sort results by modification time (newest first) or alphabetically
 */
function sortResults(results, sortByTime) {
    if (!sortByTime) {
        // Sort alphabetically with directories first
        return results.sort((a, b) => {
            if (a.isDirectory && !b.isDirectory) {
                return -1;
            }
            if (!a.isDirectory && b.isDirectory) {
                return 1;
            }
            return a.path.localeCompare(b.path);
        });
    }
    // Sort by modification time (newest first) with recent files prioritized
    const oneDayAgo = new Date().getTime() - 24 * 60 * 60 * 1000;
    return results.sort((a, b) => {
        const aTime = a.modifiedTime.getTime();
        const bTime = b.modifiedTime.getTime();
        const aIsRecent = aTime > oneDayAgo;
        const bIsRecent = bTime > oneDayAgo;
        // Both recent: newest first
        if (aIsRecent && bIsRecent) {
            return bTime - aTime;
        }
        // One recent: recent first
        if (aIsRecent) {
            return -1;
        }
        if (bIsRecent) {
            return 1;
        }
        // Both old: alphabetical
        return a.path.localeCompare(b.path);
    });
}
function createGlobTool(context) {
    return (0, utils_2.tool)(async (params) => {
        try {
            const { patterns, pattern, path: searchPath = ".", case_sensitive = false, include_dirs = false, show_hidden = false, max_results = 500, sort_by_time = false, } = params;
            // Parameter normalization: prioritize patterns, fallback to pattern
            let normalizedPatterns;
            if (patterns) {
                normalizedPatterns = patterns;
            }
            else if (pattern) {
                normalizedPatterns = Array.isArray(pattern) ? pattern : [pattern];
            }
            else {
                return (0, utils_2.handleToolError)(new Error("Either patterns or pattern must be provided"), "Glob tool execution", "validation");
            }
            // Validate workspace path (handles both absolute and relative paths)
            const pathError = (0, utils_1.validateWorkspacePath)(searchPath, context);
            if (pathError) {
                return pathError;
            }
            // Resolve search directory
            const absolutePath = (0, utils_1.resolveWorkspacePath)(searchPath, context);
            // Check if path exists and is a directory
            const dirError = await (0, utils_1.validateDirectoryExists)(context, absolutePath, searchPath);
            if (dirError) {
                return dirError;
            }
            // Process all patterns and collect unique matches
            const allMatches = [];
            const seenPaths = new Set();
            for (const patternStr of normalizedPatterns) {
                const regex = globToRegex(patternStr, case_sensitive);
                const matches = await findMatches(context, absolutePath, regex, {
                    includeDirs: include_dirs,
                    showHidden: show_hidden,
                    maxResults: max_results,
                });
                // Add unique matches to combined results
                for (const match of matches) {
                    if (!seenPaths.has(match.absolutePath)) {
                        seenPaths.add(match.absolutePath);
                        allMatches.push(match);
                    }
                }
                // Stop if we've reached max results
                if (allMatches.length >= max_results) {
                    break;
                }
            }
            // Sort combined results
            const sortedMatches = sortResults(allMatches, sort_by_time);
            // Calculate totals
            const fileCount = sortedMatches.filter((m) => !m.isDirectory).length;
            const directoryCount = sortedMatches.filter((m) => m.isDirectory).length;
            // Create summary
            let summary = `Found ${sortedMatches.length} unique match(es) across ${normalizedPatterns.length} pattern(s)`;
            if (fileCount > 0 && directoryCount > 0) {
                summary += ` (${fileCount} files, ${directoryCount} directories)`;
            }
            else if (fileCount > 0) {
                summary += ` (${fileCount} files)`;
            }
            else if (directoryCount > 0) {
                summary += ` (${directoryCount} directories)`;
            }
            if (sortedMatches.length >= max_results) {
                summary += ` - results truncated at ${max_results}`;
            }
            return (0, utils_1.createSuccessResponse)({
                patterns: normalizedPatterns,
                search_path: path.relative(context.workingDirectory, absolutePath) || ".",
                matches: sortedMatches,
                total_matches: sortedMatches.length,
                file_count: fileCount,
                directory_count: directoryCount,
                summary,
                truncated: sortedMatches.length >= max_results,
                sorted_by_time: sort_by_time,
            });
        }
        catch (error) {
            return (0, utils_2.handleToolError)(error, "Glob tool execution", "execution");
        }
    }, {
        name: "Glob",
        description: 'Find files and directories matching glob patterns. Use patterns parameter for multiple patterns (e.g., patterns: ["*.js", "*.ts"]). Legacy pattern parameter also supported. Efficient for locating files by name or path structure. Can be combined with read tool for batch file operations.',
        schema: globParametersSchema,
        getDisplay: ({ name, input }) => {
            const patternDisplay = input.patterns
                ? `[${input.patterns.join(", ")}]`
                : (Array.isArray(input.pattern)
                    ? `[${input.pattern.join(", ")}]`
                    : input.pattern || "");
            return `Using ${name} for tool call: ${patternDisplay}`;
        },
    });
}
//# sourceMappingURL=glob-tool.js.map