{"version":3,"file":"manager.cjs","names":["timeoutId: NodeJS.Timeout | number | undefined","streamError: StreamError | undefined","StreamError","values","toMessageDict"],"sources":["../../src/ui/manager.ts"],"sourcesContent":["import type {\n  CheckpointsStreamEvent,\n  CustomStreamEvent,\n  DebugStreamEvent,\n  ErrorStreamEvent,\n  EventsStreamEvent,\n  FeedbackStreamEvent,\n  MessagesTupleStreamEvent,\n  MetadataStreamEvent,\n  TasksStreamEvent,\n  UpdatesStreamEvent,\n  ValuesStreamEvent,\n} from \"../types.stream.js\";\nimport { MessageTupleManager, toMessageDict } from \"./messages.js\";\nimport { StreamError } from \"./errors.js\";\nimport type { Message } from \"../types.messages.js\";\n\ntype BagTemplate = {\n  ConfigurableType?: Record<string, unknown>;\n  InterruptType?: unknown;\n  CustomEventType?: unknown;\n  UpdateType?: unknown;\n};\n\ntype GetUpdateType<\n  Bag extends BagTemplate,\n  StateType extends Record<string, unknown>\n> = Bag extends { UpdateType: unknown }\n  ? Bag[\"UpdateType\"]\n  : Partial<StateType>;\n\ntype GetCustomEventType<Bag extends BagTemplate> = Bag extends {\n  CustomEventType: unknown;\n}\n  ? Bag[\"CustomEventType\"]\n  : unknown;\n\ntype EventStreamMap<StateType, UpdateType, CustomType> = {\n  values: ValuesStreamEvent<StateType>;\n  updates: UpdatesStreamEvent<UpdateType>;\n  custom: CustomStreamEvent<CustomType>;\n  debug: DebugStreamEvent;\n  messages: MessagesTupleStreamEvent;\n  events: EventsStreamEvent;\n  metadata: MetadataStreamEvent;\n  checkpoints: CheckpointsStreamEvent<StateType>;\n  tasks: TasksStreamEvent<StateType, UpdateType>;\n  error: ErrorStreamEvent;\n  feedback: FeedbackStreamEvent;\n};\n\nexport type EventStreamEvent<StateType, UpdateType, CustomType> =\n  EventStreamMap<StateType, UpdateType, CustomType>[keyof EventStreamMap<\n    StateType,\n    UpdateType,\n    CustomType\n  >];\n\ninterface StreamManagerEventCallbacks<\n  StateType extends Record<string, unknown>,\n  Bag extends BagTemplate = BagTemplate\n> {\n  onUpdateEvent?: (\n    data: UpdatesStreamEvent<GetUpdateType<Bag, StateType>>[\"data\"],\n    options: {\n      namespace: string[] | undefined;\n      mutate: (\n        update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)\n      ) => void;\n    }\n  ) => void;\n  onCustomEvent?: (\n    data: GetCustomEventType<Bag>,\n    options: {\n      namespace: string[] | undefined;\n      mutate: (\n        update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)\n      ) => void;\n    }\n  ) => void;\n  onMetadataEvent?: (data: MetadataStreamEvent[\"data\"]) => void;\n  onLangChainEvent?: (data: EventsStreamEvent[\"data\"]) => void;\n  onDebugEvent?: (\n    data: DebugStreamEvent[\"data\"],\n    options: { namespace: string[] | undefined }\n  ) => void;\n  onCheckpointEvent?: (\n    data: CheckpointsStreamEvent<StateType>[\"data\"],\n    options: { namespace: string[] | undefined }\n  ) => void;\n  onTaskEvent?: (\n    data: TasksStreamEvent<StateType, GetUpdateType<Bag, StateType>>[\"data\"],\n    options: { namespace: string[] | undefined }\n  ) => void;\n}\n\nexport class StreamManager<\n  StateType extends Record<string, unknown>,\n  Bag extends BagTemplate = BagTemplate\n> {\n  private abortRef = new AbortController();\n\n  private messages: MessageTupleManager;\n\n  private listeners = new Set<() => void>();\n\n  private throttle: number | boolean;\n\n  private queue: Promise<unknown> = Promise.resolve();\n\n  private queueSize: number = 0;\n\n  private state: {\n    isLoading: boolean;\n    values: [values: StateType, kind: \"stream\" | \"stop\"] | null;\n    error: unknown;\n  };\n\n  constructor(\n    messages: MessageTupleManager,\n    options: { throttle: number | boolean }\n  ) {\n    this.messages = messages;\n    this.state = { isLoading: false, values: null, error: undefined };\n    this.throttle = options.throttle;\n  }\n\n  private setState = (newState: Partial<typeof this.state>) => {\n    this.state = { ...this.state, ...newState };\n    this.notifyListeners();\n  };\n\n  private notifyListeners = () => {\n    this.listeners.forEach((listener) => listener());\n  };\n\n  subscribe = (listener: () => void): (() => void) => {\n    if (this.throttle === false) {\n      this.listeners.add(listener);\n      return () => this.listeners.delete(listener);\n    }\n\n    const timeoutMs = this.throttle === true ? 0 : this.throttle;\n    let timeoutId: NodeJS.Timeout | number | undefined;\n\n    const throttledListener = () => {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        clearTimeout(timeoutId);\n        listener();\n      }, timeoutMs);\n    };\n\n    this.listeners.add(throttledListener);\n    return () => {\n      clearTimeout(timeoutId);\n      this.listeners.delete(throttledListener);\n    };\n  };\n\n  getSnapshot = () => this.state;\n\n  get isLoading() {\n    return this.state.isLoading;\n  }\n\n  get values() {\n    return this.state.values?.[0] ?? null;\n  }\n\n  get error() {\n    return this.state.error;\n  }\n\n  setStreamValues = (\n    values:\n      | (StateType | null)\n      | ((prev: StateType | null, kind: \"stream\" | \"stop\") => StateType | null),\n    kind: \"stream\" | \"stop\" = \"stream\"\n  ) => {\n    if (typeof values === \"function\") {\n      const [prevValues, prevKind] = this.state.values ?? [null, \"stream\"];\n      const nextValues = values(prevValues, prevKind);\n      this.setState({ values: nextValues != null ? [nextValues, kind] : null });\n    } else {\n      const nextValues = values != null ? [values, kind] : null;\n      this.setState({ values: nextValues as [StateType, \"stream\" | \"stop\"] });\n    }\n  };\n\n  private getMutateFn = (kind: \"stream\" | \"stop\", historyValues: StateType) => {\n    return (\n      update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)\n    ) => {\n      const prev = {\n        ...historyValues,\n        ...(this.state.values ?? [null, \"stream\"])[0],\n      };\n      const next = typeof update === \"function\" ? update(prev) : update;\n      this.setStreamValues({ ...prev, ...next }, kind);\n    };\n  };\n\n  private matchEventType = <\n    T extends keyof EventStreamMap<\n      StateType,\n      GetUpdateType<Bag, StateType>,\n      GetCustomEventType<Bag>\n    >\n  >(\n    expected: T,\n    actual: EventStreamEvent<\n      StateType,\n      GetUpdateType<Bag, StateType>,\n      GetCustomEventType<Bag>\n    >[\"event\"],\n    _data: EventStreamEvent<\n      StateType,\n      GetUpdateType<Bag, StateType>,\n      GetCustomEventType<Bag>\n    >[\"data\"]\n  ): _data is EventStreamMap<\n    StateType,\n    GetUpdateType<Bag, StateType>,\n    GetCustomEventType<Bag>\n  >[T][\"data\"] => {\n    return expected === actual || actual.startsWith(`${expected}|`);\n  };\n\n  protected enqueue = async (\n    action: (\n      signal: AbortSignal\n    ) => Promise<\n      AsyncGenerator<\n        EventStreamEvent<\n          StateType,\n          GetUpdateType<Bag, StateType>,\n          GetCustomEventType<Bag>\n        >\n      >\n    >,\n    options: {\n      getMessages: (values: StateType) => Message[];\n\n      setMessages: (current: StateType, messages: Message[]) => StateType;\n\n      initialValues: StateType;\n\n      callbacks: StreamManagerEventCallbacks<StateType, Bag>;\n\n      onSuccess: () =>\n        | StateType\n        | null\n        | undefined\n        | void\n        | Promise<StateType | null | undefined | void>;\n\n      onError: (error: unknown) => void | Promise<void>;\n\n      onFinish?: () => void;\n    }\n  ) => {\n    try {\n      this.queueSize = Math.max(0, this.queueSize - 1);\n      this.setState({ isLoading: true, error: undefined });\n      this.abortRef = new AbortController();\n\n      const run = await action(this.abortRef.signal);\n\n      let streamError: StreamError | undefined;\n      for await (const { event, data } of run) {\n        if (event === \"error\") {\n          streamError = new StreamError(data);\n          break;\n        }\n\n        const namespace = event.includes(\"|\")\n          ? event.split(\"|\").slice(1)\n          : undefined;\n\n        const mutate = this.getMutateFn(\"stream\", options.initialValues);\n\n        if (event === \"metadata\") options.callbacks.onMetadataEvent?.(data);\n        if (event === \"events\") options.callbacks.onLangChainEvent?.(data);\n\n        if (this.matchEventType(\"updates\", event, data)) {\n          options.callbacks.onUpdateEvent?.(data, { namespace, mutate });\n        }\n\n        if (this.matchEventType(\"custom\", event, data)) {\n          options.callbacks.onCustomEvent?.(data, { namespace, mutate });\n        }\n\n        if (this.matchEventType(\"checkpoints\", event, data)) {\n          options.callbacks.onCheckpointEvent?.(data, { namespace });\n        }\n\n        if (this.matchEventType(\"tasks\", event, data)) {\n          options.callbacks.onTaskEvent?.(data, { namespace });\n        }\n\n        if (this.matchEventType(\"debug\", event, data)) {\n          options.callbacks.onDebugEvent?.(data, { namespace });\n        }\n\n        if (event === \"values\") {\n          if (\"__interrupt__\" in data) {\n            this.setStreamValues((prev) => ({ ...prev, ...data }));\n          } else {\n            this.setStreamValues(data);\n          }\n        }\n\n        if (this.matchEventType(\"messages\", event, data)) {\n          const [serialized, metadata] = data;\n\n          const messageId = this.messages.add(serialized, metadata);\n          if (!messageId) {\n            console.warn(\n              \"Failed to add message to manager, no message ID found\"\n            );\n            continue;\n          }\n\n          this.setStreamValues((streamValues) => {\n            const values = { ...options.initialValues, ...streamValues };\n\n            // Assumption: we're concatenating the message\n            const messages = options.getMessages(values).slice();\n            const { chunk, index } =\n              this.messages.get(messageId, messages.length) ?? {};\n\n            if (!chunk || index == null) return values;\n            if (chunk.getType() === \"remove\") {\n              messages.splice(index, 1);\n            } else {\n              messages[index] = toMessageDict(chunk);\n            }\n\n            return options.setMessages(values, messages);\n          });\n        }\n      }\n\n      if (streamError != null) throw streamError;\n\n      const values = await options.onSuccess?.();\n      if (typeof values !== \"undefined\" && this.queueSize === 0) {\n        this.setStreamValues(values);\n      }\n    } catch (error) {\n      if (\n        !(\n          error instanceof Error && // eslint-disable-line no-instanceof/no-instanceof\n          (error.name === \"AbortError\" || error.name === \"TimeoutError\")\n        )\n      ) {\n        console.error(error);\n        this.setState({ error });\n        await options.onError?.(error);\n      }\n    } finally {\n      this.setState({ isLoading: false });\n      this.abortRef = new AbortController();\n      options.onFinish?.();\n    }\n  };\n\n  start = async (\n    action: (\n      signal: AbortSignal\n    ) => Promise<\n      AsyncGenerator<\n        EventStreamEvent<\n          StateType,\n          GetUpdateType<Bag, StateType>,\n          GetCustomEventType<Bag>\n        >\n      >\n    >,\n    options: {\n      getMessages: (values: StateType) => Message[];\n\n      setMessages: (current: StateType, messages: Message[]) => StateType;\n\n      initialValues: StateType;\n\n      callbacks: StreamManagerEventCallbacks<StateType, Bag>;\n\n      onSuccess: () =>\n        | StateType\n        | null\n        | undefined\n        | void\n        | Promise<StateType | null | undefined | void>;\n\n      onError: (error: unknown) => void | Promise<void>;\n\n      onFinish?: () => void;\n    }\n  ): Promise<void> => {\n    this.queueSize += 1;\n    this.queue = this.queue.then(() => this.enqueue(action, options));\n  };\n\n  stop = async (\n    historyValues: StateType,\n    options: {\n      onStop?: (options: {\n        mutate: (\n          update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)\n        ) => void;\n      }) => void;\n    }\n  ): Promise<void> => {\n    this.abortRef.abort();\n    this.abortRef = new AbortController();\n\n    options.onStop?.({ mutate: this.getMutateFn(\"stop\", historyValues) });\n  };\n\n  clear = () => {\n    // Cancel any running streams\n    this.abortRef.abort();\n    this.abortRef = new AbortController();\n\n    // Set the stream state to null\n    this.setState({ error: undefined, values: null, isLoading: false });\n\n    // Clear any pending messages\n    this.messages.clear();\n  };\n}\n"],"mappings":"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"}