"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.LocalBashOperator = void 0;
const cross_spawn_1 = require("cross-spawn");
const base_operator_1 = require("./base-operator");
const os = __importStar(require("os"));
const utils_1 = require("../../utils");
const pty = __importStar(require("@lydell/node-pty"));
const SIGKILL_TIMEOUT_MS = 200;
const BASH_SHOPT_OPTIONS = 'promptvars nullglob extglob nocaseglob dotglob';
const BASH_SHOPT_GUARD = `shopt -u ${BASH_SHOPT_OPTIONS};`;
function ensurePromptvarsDisabled(command) {
    const trimmed = command.trimStart();
    if (trimmed.startsWith(BASH_SHOPT_GUARD)) {
        return command;
    }
    return `${BASH_SHOPT_GUARD} ${command}`;
}
function getShellConfiguration() {
    const isWindows = os.platform() === "win32";
    if (isWindows) {
        return {
            executable: "powershell.exe",
            argsPrefix: ["-NoProfile", "-Command"],
            shell: "powershell",
        };
    }
    return {
        executable: "bash",
        argsPrefix: ["-c"],
        shell: "bash",
    };
}
class LocalBashOperator extends base_operator_1.BaseBashOperator {
    constructor(options) {
        super();
        this.currentWorkingDirectory = options?.cwd || process.cwd();
        this.environmentVariables = {
            ...process.env,
            ...options?.env,
        };
        this.enableInteractiveShell = options?.enableInteractiveShell;
    }
    async executeCommand(command, options = {}) {
        const startTime = Date.now();
        // Google-style 模式选择：PTY用于交互，child_process用于后台命令
        const originalCommand = options.originalCommand || command;
        const isBackgroundCommand = originalCommand.includes('&') || originalCommand.includes('nohup');
        const shouldUsePty = (this.enableInteractiveShell || options.enableInteractiveShell) &&
            pty &&
            !isBackgroundCommand;
        if (shouldUsePty) {
            try {
                return await this.executeWithPty(command, options, startTime);
            }
            catch (error) {
                console.warn("PTY execution failed, falling back to child_process:", error);
                // 降级到 child_process
            }
        }
        return await this.executeWithChildProcess(command, options, startTime);
    }
    // Google-style PTY execution: 每次创建新PTY，完成后清理
    async executeWithPty(command, options, startTime) {
        const { executable, argsPrefix, shell } = getShellConfiguration();
        const guardedCommand = shell === 'bash' ? ensurePromptvarsDisabled(command) : command;
        const args = [...argsPrefix, guardedCommand];
        const cols = options.terminalWidth ?? 80;
        const rows = options.terminalHeight ?? 30;
        const ptyProcess = pty.spawn(executable, args, {
            cwd: this.currentWorkingDirectory,
            name: 'xterm',
            cols,
            rows,
            env: {
                ...this.environmentVariables,
                ...options.env,
                TERM: 'xterm-256color',
                PAGER: 'cat',
            },
        });
        // 添加到活跃PTY映射中
        LocalBashOperator.activePtys.set(ptyProcess.pid, { ptyProcess });
        return new Promise((resolve) => {
            let stdout = '';
            let stderr = '';
            let exited = false;
            const cleanup = () => {
                exited = true;
                LocalBashOperator.activePtys.delete(ptyProcess.pid);
            };
            ptyProcess.onData((data) => {
                stdout += data;
                if (options.onStdout) {
                    options.onStdout(data);
                }
            });
            ptyProcess.onExit(({ exitCode, signal }) => {
                cleanup();
                const executionTime = Date.now() - startTime;
                resolve({
                    success: exitCode === 0,
                    exitCode,
                    stdout: (0, utils_1.stripAnsi)(stdout).trim(),
                    stderr: (0, utils_1.stripAnsi)(stderr).trim(),
                    executionTime,
                    signal: String(signal) || null,
                    processGroupPid: ptyProcess.pid,
                    executionMethod: "pty",
                });
            });
            // Handle timeout
            if (options.timeout && options.timeout > 0) {
                setTimeout(() => {
                    if (!exited) {
                        this.killPtyProcess(ptyProcess.pid);
                    }
                }, options.timeout);
            }
        });
    }
    // Google-style PTY进程终止
    async killPtyProcess(pid) {
        const activePty = LocalBashOperator.activePtys.get(pid);
        if (!activePty)
            return;
        const isWindows = os.platform() === 'win32';
        if (isWindows) {
            activePty.ptyProcess.kill();
        }
        else {
            try {
                // 杀死整个进程组 - 这是Google解决后台进程的关键
                process.kill(-pid, 'SIGTERM');
                await new Promise((res) => setTimeout(res, SIGKILL_TIMEOUT_MS));
                // 如果还没退出，使用SIGKILL
                if (LocalBashOperator.activePtys.has(pid)) {
                    process.kill(-pid, 'SIGKILL');
                }
            }
            catch (_e) {
                // 降级到直接杀死PTY进程
                activePty.ptyProcess.kill('SIGTERM');
                await new Promise((res) => setTimeout(res, SIGKILL_TIMEOUT_MS));
                if (LocalBashOperator.activePtys.has(pid)) {
                    activePty.ptyProcess.kill('SIGKILL');
                }
            }
        }
    }
    async executeWithChildProcess(command, options, startTime) {
        return new Promise((resolve) => {
            const { executable, argsPrefix, shell } = getShellConfiguration();
            const guardedCommand = shell === 'bash' ? ensurePromptvarsDisabled(command) : command;
            const isWindows = os.platform() === "win32";
            const child = (0, cross_spawn_1.spawn)(executable, [...argsPrefix, guardedCommand], {
                cwd: options.cwd || this.currentWorkingDirectory,
                stdio: ["ignore", "pipe", "pipe"],
                windowsVerbatimArguments: isWindows ? false : undefined,
                shell: false,
                detached: !isWindows, // Google-style: 创建独立进程组
                env: {
                    ...this.environmentVariables,
                    ...options.env,
                    TERM: "xterm-256color",
                    PAGER: "cat",
                    // 禁用命令回显和提示符相关的环境变量
                    PS1: "",
                    PS2: "",
                    BASH_XTRACEFD: "",
                },
            });
            let stdout = "";
            let stderr = "";
            // Handle stdout
            if (child.stdout) {
                child.stdout.on("data", (data) => {
                    const text = data.toString();
                    stdout += text;
                    if (options.onStdout) {
                        options.onStdout(text);
                    }
                });
            }
            // Handle stderr
            if (child.stderr) {
                child.stderr.on("data", (data) => {
                    const text = data.toString();
                    stderr += text;
                    if (options.onStderr) {
                        options.onStderr(text);
                    }
                });
            }
            // Handle stdin if input is provided
            if (options.input && child.stdin) {
                child.stdin.write(options.input);
                child.stdin.end();
            }
            // 清理输出：移除 ANSI 码、命令回显和控制字符
            stdout = (0, utils_1.stripAnsi)(stdout);
            // Handle process completion
            child.on("exit", (code, signal) => {
                const executionTime = Date.now() - startTime;
                resolve({
                    success: code === 0,
                    exitCode: code,
                    stdout: (0, utils_1.stripAnsi)(stdout).trim(),
                    stderr: (0, utils_1.stripAnsi)(stderr).trim(),
                    executionTime,
                    signal: signal || null,
                    processGroupPid: child.pid,
                    executionMethod: "child_process",
                });
            });
            child.on("error", (error) => {
                const executionTime = Date.now() - startTime;
                resolve({
                    success: false,
                    exitCode: null,
                    stdout: (0, utils_1.stripAnsi)(stdout).trim(),
                    stderr: (0, utils_1.stripAnsi)(stderr).trim() + "\\n" + error.message,
                    executionTime,
                    signal: null,
                    processGroupPid: child.pid,
                    executionMethod: "child_process",
                });
            });
            // Google-style timeout handling with process group termination
            if (options.timeout && options.timeout > 0) {
                setTimeout(() => {
                    if (!child.killed && child.pid) {
                        this.killChildProcess(child);
                    }
                }, options.timeout);
            }
        });
    }
    // Google-style child process termination
    async killChildProcess(child) {
        if (!child.pid)
            return;
        const isWindows = os.platform() === 'win32';
        if (isWindows) {
            // Windows: 使用taskkill终止进程树
            (0, cross_spawn_1.spawn)('taskkill', ['/pid', child.pid.toString(), '/f', '/t']);
        }
        else {
            try {
                // Unix: 杀死整个进程组 - 关键的后台进程解决方案
                process.kill(-child.pid, 'SIGTERM');
                await new Promise((res) => setTimeout(res, SIGKILL_TIMEOUT_MS));
                if (!child.killed) {
                    process.kill(-child.pid, 'SIGKILL');
                }
            }
            catch (_e) {
                // 降级到直接杀死进程
                if (!child.killed)
                    child.kill('SIGKILL');
            }
        }
    }
    // Google-style PTY utility methods
    static writeToPty(pid, input) {
        const activePty = this.activePtys.get(pid);
        if (activePty) {
            activePty.ptyProcess.write(input);
        }
    }
    static isPtyActive(pid) {
        try {
            return process.kill(pid, 0);
        }
        catch (_) {
            return false;
        }
    }
    static resizePty(pid, cols, rows) {
        const activePty = this.activePtys.get(pid);
        if (activePty) {
            try {
                activePty.ptyProcess.resize(cols, rows);
            }
            catch (e) {
                // 忽略已退出PTY的错误
                if (e instanceof Error &&
                    (e.message.includes('ESRCH') ||
                        e.message.includes('Cannot resize a pty that has already exited'))) {
                    return;
                }
                throw e;
            }
        }
    }
    async getCurrentDirectory() {
        return this.currentWorkingDirectory;
    }
    async getEnvironmentVariables() {
        return { ...this.environmentVariables };
    }
    async setEnvironmentVariable(key, value) {
        this.environmentVariables[key] = value;
    }
}
exports.LocalBashOperator = LocalBashOperator;
// Google-style static PTY management
LocalBashOperator.activePtys = new Map();
//# sourceMappingURL=local-operator.js.map