import { OBSERVABILITY_TRACER_NAME, OtelSpanAttributes } from "./constants.js";
import { SemanticConventions } from "@arizeai/openinference-semantic-conventions";
import { ObservationAttributes, TraceAttributes, ObservationType } from "../types.js";
import { type Attributes } from "@opentelemetry/api";

/**
 * Creates OpenTelemetry attributes from trace attributes.
 *
 * Converts user-friendly trace attributes into OpenTelemetry attribute format
 * using OpenInference semantic conventions where applicable.
 *
 * @param attributes - Trace attributes to convert
 * @returns OpenTelemetry attributes object
 *
 * @example
 * ```typescript
 * const otelAttributes = createTraceAttributes({
 *   name: 'user-workflow',
 *   userId: 'user-123',
 *   sessionId: 'session-456',
 *   tags: ['checkout', 'payment']
 * });
 * ```
 *
 * @public
 */
export function createTraceAttributes({
  name,
  userId,
  sessionId,
  version,
  release,
  input,
  output,
  metadata,
  tags,
  environment,
  public: isPublic,
}: TraceAttributes = {}): Attributes {
  const attributes = {
    [OtelSpanAttributes.TRACE_NAME]: name,
    // Use OpenInference standard attributes for user and session
    [OtelSpanAttributes.USER_ID]: userId,
    [OtelSpanAttributes.SESSION_ID]: sessionId,
    [OtelSpanAttributes.VERSION]: version,
    [OtelSpanAttributes.RELEASE]: release,
    [OtelSpanAttributes.TRACE_INPUT]: _serialize(input),
    [OtelSpanAttributes.TRACE_OUTPUT]: _serialize(output),
    [OtelSpanAttributes.TRACE_TAGS]: tags,
    [OtelSpanAttributes.ENVIRONMENT]: environment,
    [OtelSpanAttributes.TRACE_PUBLIC]: isPublic,
    ..._flattenAndSerializeMetadata(metadata, OtelSpanAttributes.TRACE_METADATA),
  };

  return Object.fromEntries(
    Object.entries(attributes).filter(([_, v]) => v != null),
  );
}

/**
 * Creates OpenTelemetry attributes from observation attributes.
 *
 * Maps observation attributes to OpenInference semantic conventions:
 * - Uses `openinference.span.kind` for span type
 * - Uses `llm.*` for LLM-specific attributes
 * - Uses `tool.*` for tool-specific attributes
 * - Falls back to `agkit.observation.*` for non-standard attributes
 *
 * @param type - Observation type (llm, tool, chain, etc.)
 * @param attributes - Observation attributes to convert
 * @returns OpenTelemetry attributes object
 *
 * @public
 */
export function createObservationAttributes(
  type: ObservationType,
  attributes: ObservationAttributes,
): Attributes {
  const {
    metadata,
    input,
    output,
    level,
    statusMessage,
    version,
    completionStartTime,
    model,
    modelParameters,
    usageDetails,
  } = attributes;

  // Base attributes for all observation types
  const otelAttributes: Attributes = {
    [SemanticConventions.OPENINFERENCE_SPAN_KIND]: type.toUpperCase(),
    [OtelSpanAttributes.OBSERVATION_TYPE]: type,
    [OtelSpanAttributes.OBSERVATION_LEVEL]: level,
    [OtelSpanAttributes.OBSERVATION_STATUS_MESSAGE]: statusMessage,
    [OtelSpanAttributes.VERSION]: version,
    // Use OpenInference input.value convention
    [SemanticConventions.INPUT_VALUE]: _serialize(input),
    // Also set legacy agkit.observation.input for compatibility
    [OtelSpanAttributes.OBSERVATION_INPUT]: _serialize(input),
    // Use OpenInference output.value convention
    [SemanticConventions.OUTPUT_VALUE]: _serialize(output),
    // Also set legacy agkit.observation.output for compatibility
    [OtelSpanAttributes.OBSERVATION_OUTPUT]: _serialize(output),
  };

  // LLM-specific attributes
  if (type === "llm") {
    if (model) {
      otelAttributes[SemanticConventions.LLM_MODEL_NAME] = model;
    }
    if (modelParameters) {
      otelAttributes[SemanticConventions.LLM_INVOCATION_PARAMETERS] =
        _serialize(modelParameters);
      // Also set agkit.llm.model_parameters for compatibility
      otelAttributes[OtelSpanAttributes.LLM_MODEL_PARAMETERS] =
        _serialize(modelParameters);
    }
    if (usageDetails) {
      // Map to OpenInference llm.token_count.* attributes
      if (typeof usageDetails === "object") {
        const usage = usageDetails as Record<string, number>;
        if (usage.promptTokens !== undefined) {
          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_PROMPT] =
            usage.promptTokens;
        }
        if (usage.completionTokens !== undefined) {
          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_COMPLETION] =
            usage.completionTokens;
        }
        if (usage.totalTokens !== undefined) {
          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_TOTAL] =
            usage.totalTokens;
        }
      }
      // Also set legacy agkit.llm.usage_details for compatibility
      otelAttributes[OtelSpanAttributes.LLM_USAGE_DETAILS] =
        _serialize(usageDetails);
    }
    if (completionStartTime) {
      otelAttributes[OtelSpanAttributes.LLM_COMPLETION_START_TIME] =
        _serialize(completionStartTime);
    }
  }

  // Embedding-specific attributes
  if (type === "embedding") {
    if (model) {
      otelAttributes[SemanticConventions.EMBEDDING_MODEL_NAME] = model;
    }
    if (modelParameters) {
      otelAttributes[SemanticConventions.LLM_INVOCATION_PARAMETERS] =
        _serialize(modelParameters);
    }
  }

  // Add metadata (use OpenInference metadata convention)
  const metadataAttrs = _flattenAndSerializeMetadata(
    metadata,
    SemanticConventions.METADATA,
  );
  Object.assign(otelAttributes, metadataAttrs);

  // Also add agkit.observation.metadata for compatibility
  const obsetvabilityMetadataAttrs = _flattenAndSerializeMetadata(
    metadata,
    OtelSpanAttributes.OBSERVATION_METADATA
  );
  Object.assign(otelAttributes, obsetvabilityMetadataAttrs);

  // Filter out null/undefined values
  return Object.fromEntries(
    Object.entries(otelAttributes).filter(([_, v]) => v != null),
  );
}

/**
 * Safely serializes an object to JSON string.
 *
 * @param obj - Object to serialize
 * @returns JSON string or undefined if null/undefined
 * @internal
 */
function _serialize(obj: unknown): string | undefined {
  try {
    if (typeof obj === "string") return obj;
    if (obj instanceof Date) return obj.toISOString();
    return obj != null ? JSON.stringify(obj) : undefined;
  } catch {
    return "<failed to serialize>";
  }
}

/**
 * Flattens and serializes metadata into OpenTelemetry attribute format.
 *
 * Converts nested metadata objects into dot-notation attribute keys.
 * For example, `{ database: { host: 'localhost' } }` becomes
 * `{ 'metadata.database.host': 'localhost' }` (or 'agkit.observation.metadata.database.host').
 *
 * @param metadata - Metadata object to flatten
 * @param prefix - Attribute prefix (e.g., 'metadata' or 'agkit.observation.metadata')
 * @returns Flattened metadata attributes
 * @internal
 */
function _flattenAndSerializeMetadata(
  metadata: unknown,
  prefix: string,
): Record<string, string> {
  const metadataAttributes: Record<string, string> = {};

  if (metadata === undefined || metadata === null) {
    return metadataAttributes;
  }

  if (typeof metadata !== "object" || Array.isArray(metadata)) {
    const serialized = _serialize(metadata);
    if (serialized) {
      metadataAttributes[prefix] = serialized;
    }
  } else {
    for (const [key, value] of Object.entries(metadata)) {
      const serialized = typeof value === "string" ? value : _serialize(value);
      if (serialized) {
        metadataAttributes[`${prefix}.${key}`] = serialized;
      }
    }
  }

  return metadataAttributes;
}
