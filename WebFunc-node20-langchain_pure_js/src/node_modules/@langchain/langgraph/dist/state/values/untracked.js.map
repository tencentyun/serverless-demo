{"version":3,"file":"untracked.js","names":[],"sources":["../../../src/state/values/untracked.ts"],"sourcesContent":["import type { SerializableSchema } from \"../types.js\";\n\n/**\n * Symbol for runtime identification of UntrackedValue instances.\n */\nexport const UNTRACKED_VALUE_SYMBOL = Symbol.for(\n  \"langgraph.state.untracked_value\"\n);\n\n/**\n * Initialization options for {@link UntrackedValue}.\n */\nexport interface UntrackedValueInit {\n  /**\n   * If true (default), throws an error if multiple updates are made in a single step.\n   * If false, only the last value is kept per step.\n   */\n  guard?: boolean;\n}\n\n/**\n * Represents a state field whose value is transient and never checkpointed.\n *\n * Use {@link UntrackedValue} for state fields that should be tracked for the lifetime\n * of the process, but should not participate in durable checkpoints or recovery.\n *\n * @typeParam Value - The type of value stored in this field.\n *\n * @example\n * // Create an untracked in-memory cache\n * const cache = new UntrackedValue<Record<string, number>>();\n *\n * // Use with a type schema for basic runtime validation\n * import { z } from \"zod\";\n * const tempSession = new UntrackedValue(z.object({ token: z.string() }), { guard: false });\n *\n * // You can customize whether to throw on multiple updates per step:\n * const session = new UntrackedValue(undefined, { guard: false });\n */\nexport class UntrackedValue<Value = unknown> {\n  /**\n   * Instance marker for runtime identification.\n   * @internal\n   */\n  protected readonly [UNTRACKED_VALUE_SYMBOL] = true as const;\n\n  /**\n   * Optional schema describing the type and shape of the value stored in this field.\n   *\n   * If provided, this can be used for runtime validation or code generation.\n   */\n  readonly schema?: SerializableSchema<Value>;\n\n  /**\n   * Whether to guard against multiple updates to this untracked value in a single step.\n   *\n   * - If `true` (default), throws an error if multiple updates are received in one step.\n   * - If `false`, only the last value from that step is kept, others are ignored.\n   *\n   * This helps prevent accidental state replacement within a step.\n   */\n  readonly guard: boolean;\n\n  /**\n   * Represents the type of value stored in this untracked state field.\n   */\n  declare ValueType: Value;\n\n  /**\n   * Create a new untracked value state field.\n   *\n   * @param schema - Optional type schema describing the value (e.g. a Zod schema).\n   * @param init - Optional options for tracking updates or enabling multiple-writes-per-step.\n   */\n  constructor(schema?: SerializableSchema<Value>, init?: UntrackedValueInit) {\n    this.schema = schema;\n    this.guard = init?.guard ?? true;\n  }\n\n  /**\n   * Type guard to check if a value is an UntrackedValue instance.\n   */\n  static isInstance<Value = unknown>(\n    value: UntrackedValue<Value>\n  ): value is UntrackedValue<Value>;\n\n  static isInstance(value: unknown): value is UntrackedValue;\n\n  static isInstance<Value = unknown>(\n    value: UntrackedValue<Value> | unknown\n  ): value is UntrackedValue<Value> {\n    return (\n      typeof value === \"object\" &&\n      value !== null &&\n      UNTRACKED_VALUE_SYMBOL in value\n    );\n  }\n}\n"],"mappings":";;;;AAKA,MAAa,yBAAyB,OAAO,IAC3C,kCACD;;;;;;;;;;;;;;;;;;;;AAgCD,IAAa,iBAAb,MAA6C;;;;;CAK3C,CAAoB,0BAA0B;;;;;;CAO9C,AAAS;;;;;;;;;CAUT,AAAS;;;;;;;CAaT,YAAY,QAAoC,MAA2B;AACzE,OAAK,SAAS;AACd,OAAK,QAAQ,MAAM,SAAS;;CAY9B,OAAO,WACL,OACgC;AAChC,SACE,OAAO,UAAU,YACjB,UAAU,QACV,0BAA0B"}