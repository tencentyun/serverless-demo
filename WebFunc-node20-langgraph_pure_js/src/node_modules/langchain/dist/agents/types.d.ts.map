{"version":3,"file":"types.d.ts","names":["InteropZodObject","InteropZodType","START","END","StateGraph","LanguageModelLike","BaseMessage","SystemMessage","BaseCheckpointSaver","BaseStore","Messages","ClientTool","ServerTool","ResponseFormat","ToolStrategy","TypedToolStrategy","ProviderStrategy","JsonSchemaFormat","ResponseFormatUndefined","AgentMiddleware","AnyAnnotationRoot","InferSchemaInput","JumpToTarget","N","Interrupt","TValue","BuiltInState","UserInput","TStateSchema","ToolCall","Record","ToolResult","JumpTo","ExecutedToolCall","CreateAgentParams","StructuredResponseType","StateSchema","ContextSchema","ResponseFormatType","AbortSignal","ExtractZodArrayTypes","T","Rest","A","WithStateGraphNodes","K","Graph","SD","S","U","I","O","C"],"sources":["../../src/agents/types.d.ts"],"sourcesContent":["import type { InteropZodObject, InteropZodType } from \"@langchain/core/utils/types\";\nimport type { START, END, StateGraph } from \"@langchain/langgraph\";\nimport type { LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport type { BaseMessage, SystemMessage } from \"@langchain/core/messages\";\nimport type { BaseCheckpointSaver, BaseStore } from \"@langchain/langgraph-checkpoint\";\nimport type { Messages } from \"@langchain/langgraph/\";\nimport type { ClientTool, ServerTool } from \"@langchain/core/tools\";\nimport type { ResponseFormat, ToolStrategy, TypedToolStrategy, ProviderStrategy, JsonSchemaFormat, ResponseFormatUndefined } from \"./responses.js\";\nimport type { AgentMiddleware, AnyAnnotationRoot, InferSchemaInput } from \"./middleware/types.js\";\nimport type { JumpToTarget } from \"./constants.js\";\nexport type N = typeof START | \"model_request\" | \"tools\";\n/**\n * Represents information about an interrupt.\n */\nexport interface Interrupt<TValue = unknown> {\n    /**\n     * The ID of the interrupt.\n     */\n    id: string;\n    /**\n     * The requests for human input.\n     */\n    value: TValue;\n}\nexport interface BuiltInState {\n    messages: BaseMessage[];\n    __interrupt__?: Interrupt[];\n    /**\n     * Optional property to control routing after afterModel middleware execution.\n     * When set by middleware, the agent will jump to the specified node instead of\n     * following normal routing logic. The property is automatically cleared after use.\n     *\n     * - \"model_request\": Jump back to the model for another LLM call\n     * - \"tools\": Jump to tool execution (requires tools to be available)\n     */\n    jumpTo?: JumpToTarget;\n}\n/**\n * Base input type for `.invoke` and `.stream` methods.\n */\nexport type UserInput<TStateSchema extends AnyAnnotationRoot | InteropZodObject | undefined = undefined> = InferSchemaInput<TStateSchema> & {\n    messages: Messages;\n};\n/**\n * Information about a tool call that has been executed.\n */\nexport interface ToolCall {\n    /**\n     * The ID of the tool call.\n     */\n    id: string;\n    /**\n     * The name of the tool that was called.\n     */\n    name: string;\n    /**\n     * The arguments that were passed to the tool.\n     */\n    args: Record<string, any>;\n    /**\n     * The result of the tool call.\n     */\n    result?: unknown;\n    /**\n     * An optional error message if the tool call failed.\n     */\n    error?: string;\n}\n/**\n * Information about a tool result from a tool execution.\n */\nexport interface ToolResult {\n    /**\n     * The ID of the tool call.\n     */\n    id: string;\n    /**\n     * The result of the tool call.\n     */\n    result: any;\n    /**\n     * An optional error message if the tool call failed.\n     */\n    error?: string;\n}\n/**\n * jump targets (internal)\n */\nexport type JumpTo = \"model_request\" | \"tools\" | typeof END;\n/**\n * Information about a tool call that has been executed.\n */\nexport interface ExecutedToolCall {\n    /**\n     * The name of the tool that was called.\n     */\n    name: string;\n    /**\n     * The arguments that were passed to the tool.\n     */\n    args: Record<string, unknown>;\n    /**\n     * The ID of the tool call.\n     */\n    tool_id: string;\n    /**\n     * The result of the tool call (if available).\n     */\n    result?: unknown;\n}\nexport type CreateAgentParams<StructuredResponseType extends Record<string, any> = Record<string, any>, StateSchema extends AnyAnnotationRoot | InteropZodObject | undefined = undefined, ContextSchema extends AnyAnnotationRoot | InteropZodObject = AnyAnnotationRoot, ResponseFormatType = InteropZodType<StructuredResponseType> | InteropZodType<unknown>[] | JsonSchemaFormat | JsonSchemaFormat[] | ResponseFormat | TypedToolStrategy<StructuredResponseType> | ToolStrategy<StructuredResponseType> | ProviderStrategy<StructuredResponseType> | ResponseFormatUndefined> = {\n    /**\n     * Defines a model to use for the agent. You can either pass in an instance of a LangChain chat model\n     * or a string. If a string is provided the agent initializes a ChatModel based on the provided model name and provider.\n     * It supports various model providers and allows for runtime configuration of model parameters.\n     *\n     * @uses {@link initChatModel}\n     * @example\n     * ```ts\n     * const agent = createAgent({\n     *   model: \"anthropic:claude-3-7-sonnet-latest\",\n     *   // ...\n     * });\n     * ```\n     *\n     * @example\n     * ```ts\n     * import { ChatOpenAI } from \"@langchain/openai\";\n     * const agent = createAgent({\n     *   model: new ChatOpenAI({ model: \"gpt-4o\" }),\n     *   // ...\n     * });\n     * ```\n     */\n    model: string | LanguageModelLike;\n    /**\n     * A list of tools or a ToolNode.\n     *\n     * @example\n     * ```ts\n     * import { tool } from \"langchain\";\n     *\n     * const weatherTool = tool(() => \"Sunny!\", {\n     *   name: \"get_weather\",\n     *   description: \"Get the weather for a location\",\n     *   schema: z.object({\n     *     location: z.string().describe(\"The location to get weather for\"),\n     *   }),\n     * });\n     *\n     * const agent = createAgent({\n     *   tools: [weatherTool],\n     *   // ...\n     * });\n     * ```\n     */\n    tools?: (ServerTool | ClientTool)[];\n    /**\n     * An optional system message for the model.\n     *\n     * **Use a `string`** for simple, static system prompts. This is the most common use case\n     * and works well with template literals for dynamic content. When a string is provided,\n     * it's converted to a single text block internally.\n     *\n     * **Use a `SystemMessage`** when you need advanced features that require structured content:\n     * - **Anthropic cache control**: Use `SystemMessage` with array content to enable per-block\n     *   cache control settings (e.g., `cache_control: { type: \"ephemeral\" }`). This allows you\n     *   to have different cache settings for different parts of your system prompt.\n     * - **Multiple content blocks**: When you need multiple text blocks with different metadata\n     *   or formatting requirements.\n     * - **Integration with existing code**: When working with code that already produces\n     *   `SystemMessage` instances.\n     *\n     * @example Using a string (recommended for most cases)\n     * ```ts\n     * const agent = createAgent({\n     *   model: \"anthropic:claude-3-5-sonnet\",\n     *   systemPrompt: \"You are a helpful assistant.\",\n     *   // ...\n     * });\n     * ```\n     *\n     * @example Using a string with template literals\n     * ```ts\n     * const userRole = \"premium\";\n     * const agent = createAgent({\n     *   model: \"anthropic:claude-3-5-sonnet\",\n     *   systemPrompt: `You are a helpful assistant for ${userRole} users.`,\n     *   // ...\n     * });\n     * ```\n     *\n     * @example Using SystemMessage with cache control (Anthropic)\n     * ```ts\n     * import { SystemMessage } from \"@langchain/core/messages\";\n     *\n     * const agent = createAgent({\n     *   model: \"anthropic:claude-3-5-sonnet\",\n     *   systemPrompt: new SystemMessage({\n     *     content: [\n     *       {\n     *         type: \"text\",\n     *         text: \"You are a helpful assistant.\",\n     *       },\n     *       {\n     *         type: \"text\",\n     *         text: \"Today's date is 2024-06-01.\",\n     *         cache_control: { type: \"ephemeral\" },\n     *       },\n     *     ],\n     *   }),\n     *   // ...\n     * });\n     * ```\n     *\n     * @example Using SystemMessage (simple)\n     * ```ts\n     * import { SystemMessage } from \"@langchain/core/messages\";\n     *\n     * const agent = createAgent({\n     *   model: \"anthropic:claude-3-5-sonnet\",\n     *   systemPrompt: new SystemMessage(\"You are a helpful assistant.\"),\n     *   // ...\n     * });\n     * ```\n     */\n    systemPrompt?: string | SystemMessage;\n    /**\n     * An optional schema for the agent state. It allows you to define custom state properties that persist\n     * across agent invocations and can be accessed in hooks, middleware, and throughout the agent's execution.\n     * The state is persisted when using a checkpointer and can be updated by middleware or during execution.\n     *\n     * As opposed to the context (defined in `contextSchema`), the state is persisted between agent invocations\n     * when using a checkpointer, making it suitable for maintaining conversation history, user preferences,\n     * or any other data that should persist across multiple interactions.\n     *\n     * @example\n     * ```ts\n     * import { z } from \"zod\";\n     * import { createAgent } from \"@langchain/langgraph\";\n     *\n     * const agent = createAgent({\n     *   model: \"openai:gpt-4o\",\n     *   tools: [getWeather],\n     *   stateSchema: z.object({\n     *     userPreferences: z.object({\n     *       temperatureUnit: z.enum([\"celsius\", \"fahrenheit\"]).default(\"celsius\"),\n     *       location: z.string().optional(),\n     *     }).optional(),\n     *     conversationCount: z.number().default(0),\n     *   }),\n     *   prompt: (state, config) => {\n     *     const unit = state.userPreferences?.temperatureUnit || \"celsius\";\n     *     return [\n     *       new SystemMessage(`You are a helpful assistant. Use ${unit} for temperature.`),\n     *     ];\n     *   },\n     * });\n     *\n     * const result = await agent.invoke({\n     *   messages: [\n     *     new HumanMessage(\"What's the weather like?\"),\n     *   ],\n     *   userPreferences: {\n     *     temperatureUnit: \"fahrenheit\",\n     *     location: \"New York\",\n     *   },\n     *   conversationCount: 1,\n     * });\n     * ```\n     */\n    stateSchema?: StateSchema;\n    /**\n     * An optional schema for the context. It allows to pass in a typed context object into the agent\n     * invocation and allows to access it in hooks such as `prompt` and middleware.\n     * As opposed to the agent state, defined in `stateSchema`, the context is not persisted between\n     * agent invocations.\n     *\n     * @example\n     * ```ts\n     * const agent = createAgent({\n     *   llm: model,\n     *   tools: [getWeather],\n     *   contextSchema: z.object({\n     *     capital: z.string(),\n     *   }),\n     *   prompt: (state, config) => {\n     *     return [\n     *       new SystemMessage(`You are a helpful assistant. The capital of France is ${config.context.capital}.`),\n     *     ];\n     *   },\n     * });\n     *\n     * const result = await agent.invoke({\n     *   messages: [\n     *     new SystemMessage(\"You are a helpful assistant.\"),\n     *     new HumanMessage(\"What is the capital of France?\"),\n     *   ],\n     * }, {\n     *   context: {\n     *     capital: \"Paris\",\n     *   },\n     * });\n     * ```\n     */\n    contextSchema?: ContextSchema;\n    /**\n     * An optional checkpoint saver to persist the agent's state.\n     * @see {@link https://docs.langchain.com/oss/javascript/langgraph/persistence | Checkpointing}\n     */\n    checkpointer?: BaseCheckpointSaver | boolean;\n    /**\n     * An optional store to persist the agent's state.\n     * @see {@link https://docs.langchain.com/oss/javascript/langgraph/memory#memory-storage | Long-term memory}\n     */\n    store?: BaseStore;\n    /**\n     * An optional schema for the final agent output.\n     *\n     * If provided, output will be formatted to match the given schema and returned in the 'structuredResponse' state key.\n     * If not provided, `structuredResponse` will not be present in the output state.\n     *\n     * Can be passed in as:\n     *   - Zod schema\n     *     ```ts\n     *     const agent = createAgent({\n     *       responseFormat: z.object({\n     *         capital: z.string(),\n     *       }),\n     *       // ...\n     *     });\n     *     ```\n     *   - JSON schema\n     *     ```ts\n     *     const agent = createAgent({\n     *       responseFormat: {\n     *         type: \"json_schema\",\n     *         schema: {\n     *           type: \"object\",\n     *           properties: {\n     *             capital: { type: \"string\" },\n     *           },\n     *           required: [\"capital\"],\n     *         },\n     *       },\n     *       // ...\n     *     });\n     *     ```\n     *   - Create React Agent ResponseFormat\n     *     ```ts\n     *     import { providerStrategy, toolStrategy } from \"langchain\";\n     *     const agent = createAgent({\n     *       responseFormat: providerStrategy(\n     *         z.object({\n     *           capital: z.string(),\n     *         })\n     *       ),\n     *       // or\n     *       responseFormat: [\n     *         toolStrategy({ ... }),\n     *         toolStrategy({ ... }),\n     *       ]\n     *       // ...\n     *     });\n     *     ```\n     *\n     * **Note**: The graph will make a separate call to the LLM to generate the structured response after the agent loop is finished.\n     * This is not the only strategy to get structured responses, see more options in [this guide](https://langchain-ai.github.io/langgraph/how-tos/react-agent-structured-output/).\n     */\n    responseFormat?: ResponseFormatType;\n    /**\n     * Middleware instances to run during agent execution.\n     * Each middleware can define its own state schema and hook into the agent lifecycle.\n     *\n     * @see {@link https://docs.langchain.com/oss/javascript/langchain/middleware | Middleware}\n     */\n    middleware?: readonly AgentMiddleware<any, any, any>[];\n    /**\n     * An optional name for the agent.\n     */\n    name?: string;\n    /**\n     * An optional description for the agent.\n     * This can be used to describe the agent to the underlying supervisor LLM.\n     */\n    description?: string;\n    /**\n     * Use to specify how to expose the agent name to the underlying supervisor LLM.\n     *   - `undefined`: Relies on the LLM provider {@link AIMessage#name}. Currently, only OpenAI supports this.\n     *   - `\"inline\"`: Add the agent name directly into the content field of the {@link AIMessage} using XML-style tags.\n     *       Example: `\"How can I help you\"` -> `\"<name>agent_name</name><content>How can I help you?</content>\"`\n     */\n    includeAgentName?: \"inline\" | undefined;\n    /**\n     * An optional abort signal that indicates that the overall operation should be aborted.\n     */\n    signal?: AbortSignal;\n    /**\n     * Determines the version of the graph to create.\n     *\n     * Can be one of\n     * - `\"v1\"`: The tool node processes a single message. All tool calls in the message are\n     *           executed in parallel within the tool node.\n     * - `\"v2\"`: The tool node processes a single tool call. Tool calls are distributed across\n     *           multiple instances of the tool node using the Send API.\n     *\n     * @default `\"v2\"`\n     */\n    version?: \"v1\" | \"v2\";\n};\n/**\n * Type helper to extract union type from an array of Zod schemas\n */\nexport type ExtractZodArrayTypes<T extends readonly InteropZodType<any>[]> = T extends readonly [InteropZodType<infer A>, ...infer Rest] ? Rest extends readonly InteropZodType<any>[] ? A | ExtractZodArrayTypes<Rest> : A : never;\nexport type WithStateGraphNodes<K extends string, Graph> = Graph extends StateGraph<infer SD, infer S, infer U, infer N, infer I, infer O, infer C> ? StateGraph<SD, S, U, N | K, I, O, C> : never;\n//# sourceMappingURL=types.d.ts.map"],"mappings":";;;;;;;;;;;;KAUYuB,CAAAA,UAAWrB;;AAAvB;AAIA;AAUiBwB,UAVAF,SAUY,CAAA,SAAA,OAAA,CAAA,CAAA;EACflB;;;EAUW,EAAA,EAAA,MAAA;EAKbqB;;;EAAgHC,KAAAA,EAlBjHH,MAkBiHG;;AAC9GlB,UAjBGgB,YAAAA,CAiBHhB;EAAQ,QAAA,EAhBRJ,WAgBQ,EAAA;EAKLuB,aAAQ,CAAA,EApBLL,SAoBK,EAYfM;EAaOC;AAiBjB;AAIA;AAkBA;;;;;EAAgNX,MAAAA,CAAAA,EA3EnME,YA2EmMF;;;;;AAAwHnB,KAtE5T0B,SAsE4T1B,CAAAA,qBAtE7RmB,iBAsE6RnB,GAtEzQD,gBAsEyQC,GAAAA,SAAAA,GAAAA,SAAAA,CAAAA,GAtE7NoB,gBAsE6NpB,CAtE5M2B,YAsE4M3B,CAAAA,GAAAA;EAA4BgB,QAAAA,EArEtVP,QAqEsVO;CAAmBA;;;;AAA+FkB,UAhErcN,UAAAA,CAgEqcM;EAAbrB;;;EAAkFI,EAAAA,EAAAA,MAAAA;EAwBvgBb;;;EA4FQE,IAAAA,EAAAA,MAAAA;EA6CV6B;;;EA4CN3B,IAAAA,EAjQFqB,MAiQErB,CAAAA,MAAAA,EAAAA,GAAAA,CAAAA;EAsDS6B;;;EA2BG,MAAA,CAAA,EAAA,OAAA;EAiBZE;;;EAAqFvC,KAAAA,CAAAA,EAAAA,MAAAA;;;;;AAA4FuC,UAtV5KT,UAAAA,CAsV4KS;EAA6BG;AAAC;AAC3N;EAA2DG,EAAAA,EAAAA,MAAAA;EAAc1C;;;EAA+F6C,MAAAA,EAAAA,GAAAA;EAAG1B;;;EAAU4B,KAAAA,CAAAA,EAAAA,MAAAA;;;AAArB;;KAtUpJnB,MAAAA,sCAA4C7B;;;;UAIvC8B,gBAAAA;;;;;;;;QAQPH;;;;;;;;;;KAUEI,iDAAiDJ,sBAAsBA,yCAAyCV,oBAAoBpB,gEAAgEoB,oBAAoBpB,mBAAmBoB,wCAAwCnB,eAAekC,0BAA0BlC,4BAA4BgB,mBAAmBA,qBAAqBJ,iBAAiBE,kBAAkBoB,0BAA0BrB,aAAaqB,0BAA0BnB,iBAAiBmB,0BAA0BjB;;;;;;;;;;;;;;;;;;;;;;;;kBAwBvgBb;;;;;;;;;;;;;;;;;;;;;;WAsBPO,aAAaD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;0BAsEEJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;gBA6CV6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;kBAkCEC;;;;;iBAKD7B;;;;;UAKPC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;mBAsDS6B;;;;;;;wBAOKnB;;;;;;;;;;;;;;;;;;;;WAoBboB;;;;;;;;;;;;;;;;;KAiBDC,wCAAwCvC,yBAAyBwC,oBAAoBxC,0CAA0CyC,sBAAsBzC,wBAAwB0C,IAAIH,qBAAqBE,QAAQC;KAC9MC,+CAA+CE,cAAc1C,6EAA6EA,WAAW2C,IAAIC,GAAGC,GAAG1B,IAAIsB,GAAGK,GAAGC,GAAGC"}