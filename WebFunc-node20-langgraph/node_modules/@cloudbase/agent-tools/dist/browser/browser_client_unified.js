"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UnifiedBrowserClient = void 0;
const cross_spawn_1 = require("cross-spawn");
const events_1 = require("events");
const index_js_1 = require("@modelcontextprotocol/sdk/client/index.js");
const stdio_js_1 = require("@modelcontextprotocol/sdk/client/stdio.js");
const browser_instance_manager_1 = require("./browser-instance-manager");
const browser_tool_executor_1 = require("./browser-tool-executor");
/**
 * Abstract base class for browser clients
 */
class BaseBrowserClient extends events_1.EventEmitter {
    constructor(config) {
        super();
        this.isConnected = false;
        this.config = config;
    }
    isReady() {
        return this.isConnected;
    }
}
/**
 * Local Playwright MCP Client
 * Manages a local @playwright/mcp server process
 */
class LocalBrowserClient extends BaseBrowserClient {
    constructor() {
        super(...arguments);
        this.mcpProcess = null;
        this.client = null;
        this.transport = null;
    }
    async start() {
        if (this.isConnected)
            return;
        try {
            // Build command arguments
            const args = ['@playwright/mcp@latest'];
            if (this.config.browser) {
                args.push('--browser', this.config.browser);
            }
            if (this.config.caps?.length) {
                args.push('--caps', this.config.caps.join(','));
            }
            if (this.config.allowedHosts?.length) {
                args.push('--allowed-hosts', this.config.allowedHosts.join(','));
            }
            if (this.config.allowedOrigins?.length) {
                args.push('--allowed-origins', this.config.allowedOrigins.join(';'));
            }
            if (this.config.blockedOrigins?.length) {
                args.push('--blocked-origins', this.config.blockedOrigins.join(';'));
            }
            if (this.config.blockServiceWorkers) {
                args.push('--block-service-workers');
            }
            // Start MCP server process
            this.mcpProcess = (0, cross_spawn_1.spawn)('npx', args, {
                stdio: ['pipe', 'pipe', 'pipe']
            });
            this.mcpProcess.stderr?.on('data', (data) => {
                console.error('Playwright MCP Server Error:', data.toString());
            });
            this.mcpProcess.on('error', (error) => {
                console.error('Failed to start Playwright MCP server:', error);
                this.emit('error', error);
            });
            this.mcpProcess.on('exit', (code) => {
                console.log(`Playwright MCP server exited with code ${code}`);
                this.isConnected = false;
                this.emit('disconnected');
            });
            // Create MCP transport and client
            this.transport = new stdio_js_1.StdioClientTransport({
                command: 'npx',
                args: args
            });
            this.client = new index_js_1.Client({
                name: 'ag-kit-browser-tool',
                version: '1.0.0'
            }, {
                capabilities: {}
            });
            await this.client.connect(this.transport);
            this.isConnected = true;
            console.log('✅ Connected to local Playwright MCP server');
            this.emit('connected');
        }
        catch (error) {
            console.error('Failed to start local browser client:', error);
            throw error;
        }
    }
    async stop() {
        try {
            if (this.client) {
                await this.client.close();
                this.client = null;
            }
            if (this.transport) {
                await this.transport.close();
                this.transport = null;
            }
            if (this.mcpProcess) {
                this.mcpProcess.kill();
                this.mcpProcess = null;
            }
            this.isConnected = false;
            console.log('✅ Local browser client stopped');
        }
        catch (error) {
            console.error('Failed to stop local browser client:', error);
            throw error;
        }
    }
    async listTools() {
        if (!this.client || !this.isConnected) {
            throw new Error('MCP client not connected');
        }
        try {
            const response = await this.client.listTools();
            return response.tools;
        }
        catch (error) {
            console.error('Failed to list tools:', error);
            throw error;
        }
    }
    async callTool(toolCall) {
        if (!this.client || !this.isConnected) {
            throw new Error('MCP client not connected');
        }
        try {
            const response = await this.client.callTool({
                name: toolCall.name,
                arguments: toolCall.arguments || {}
            });
            return {
                content: Array.isArray(response.content) ? response.content : [],
                isError: Boolean(response.isError)
            };
        }
        catch (error) {
            console.error(`Failed to call tool ${toolCall.name}:`, error);
            return {
                content: [{
                        type: 'text',
                        text: `Error calling tool ${toolCall.name}: ${error.message}`
                    }],
                isError: true
            };
        }
    }
}
/**
 * Sandbox Browser Client with Direct CDP Connection
 * Uses SandboxConnector for direct connection without subprocess MCP server
 */
class SandboxBrowserClient extends BaseBrowserClient {
    constructor(config) {
        super(config);
        // Generate session ID if not provided
        this.currentSessionId = config.sessionId || `session-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        // Initialize instance manager
        this.instanceManager = new browser_instance_manager_1.BrowserInstanceManager({
            apiKey: config.apiKey,
            domain: config.domain,
            timeout: config.timeout,
            maxInstances: config.maxInstances || 10,
            instanceTtl: config.instanceTtl || 3600,
            cleanupInterval: config.cleanupInterval || 300,
        });
        // Initialize tool executor
        this.toolExecutor = new browser_tool_executor_1.BrowserToolExecutor(this);
        // Setup instance manager events
        this.setupInstanceManagerEvents();
    }
    async start() {
        if (this.isConnected)
            return;
        try {
            // Get or create browser instance
            const instanceInfo = await this.instanceManager.getInstance(this.currentSessionId);
            this.currentConnector = instanceInfo.connector;
            this.isConnected = true;
            console.log('✅ Connected to sandbox browser client via direct CDP');
            console.log(`Session ID: ${this.currentSessionId}`);
            console.log(`Sandbox ID: ${instanceInfo.connectionInfo.sandboxId}`);
            console.log(`VNC URL: ${instanceInfo.connectionInfo.vncUrl}`);
            console.log(`CDP URL: ${instanceInfo.connectionInfo.cdpUrl}`);
            this.emit('connected');
        }
        catch (error) {
            console.error('Failed to start sandbox browser client:', error);
            throw error;
        }
    }
    async stop() {
        try {
            if (this.currentSessionId) {
                await this.instanceManager.removeInstance(this.currentSessionId);
            }
            this.currentConnector = undefined;
            this.isConnected = false;
            console.log('✅ Sandbox browser client stopped');
            this.emit('disconnected');
        }
        catch (error) {
            console.error('Failed to stop sandbox browser client:', error);
            throw error;
        }
    }
    async listTools() {
        return this.toolExecutor.listTools();
    }
    async callTool(toolCall) {
        if (!this.currentConnector || !this.isConnected) {
            return {
                content: [{
                        type: 'text',
                        text: 'Browser client not connected'
                    }],
                isError: true
            };
        }
        return this.toolExecutor.executeTool(toolCall);
    }
    // BrowserPageProvider implementation
    getPage(pageIndex = 0) {
        if (!this.currentConnector) {
            throw new Error('No connector available');
        }
        return this.currentConnector.getPage(pageIndex);
    }
    getPages() {
        if (!this.currentConnector) {
            return [];
        }
        return this.currentConnector.getPages();
    }
    async createPage() {
        if (!this.currentConnector) {
            throw new Error('No connector available');
        }
        return this.currentConnector.createPage();
    }
    async closePage(pageIndex) {
        if (!this.currentConnector) {
            throw new Error('No connector available');
        }
        return this.currentConnector.closePage(pageIndex);
    }
    getBrowser() {
        return this.currentConnector?.getBrowser() || null;
    }
    getContext() {
        return this.currentConnector?.getContext() || null;
    }
    /**
     * Setup instance manager event handlers
     */
    setupInstanceManagerEvents() {
        this.instanceManager.on('instance-error', (sessionId, error) => {
            if (sessionId === this.currentSessionId) {
                console.error(`Instance error for current session:`, error);
                this.emit('error', error);
            }
        });
        this.instanceManager.on('instance-disconnected', (sessionId) => {
            if (sessionId === this.currentSessionId) {
                console.log(`Current session disconnected: ${sessionId}`);
                this.isConnected = false;
                this.emit('disconnected');
            }
        });
        this.instanceManager.on('instance-reconnected', (sessionId) => {
            if (sessionId === this.currentSessionId) {
                console.log(`Current session reconnected: ${sessionId}`);
                this.isConnected = true;
                this.emit('reconnected');
            }
        });
    }
    // Sandbox-specific methods
    getVncUrl() {
        return this.currentConnector?.getVncUrl();
    }
    getCdpUrl() {
        return this.currentConnector?.getCdpUrl();
    }
    getSessionId() {
        return this.currentSessionId;
    }
    getSandboxId() {
        return this.currentConnector?.getSandboxId();
    }
    async healthCheck() {
        if (!this.currentConnector || !this.isConnected) {
            return false;
        }
        return await this.currentConnector.healthCheck();
    }
    async reconnect() {
        if (!this.currentConnector) {
            throw new Error('No connector available for reconnection');
        }
        await this.currentConnector.reconnect();
    }
    getInstanceManager() {
        return this.instanceManager;
    }
    async cleanup() {
        await this.instanceManager.cleanup();
    }
}
/**
 * Unified Browser Client Factory
 * Creates the appropriate client based on configuration
 */
class UnifiedBrowserClient {
    constructor(config) {
        if (config.mode === 'sandbox') {
            this.client = new SandboxBrowserClient(config);
        }
        else {
            this.client = new LocalBrowserClient(config);
        }
    }
    async start() {
        return this.client.start();
    }
    async stop() {
        return this.client.stop();
    }
    async callTool(toolCall) {
        return this.client.callTool(toolCall);
    }
    async listTools() {
        return this.client.listTools();
    }
    isReady() {
        return this.client.isReady();
    }
    // Additional methods for sandbox mode
    getVncUrl() {
        if (this.client instanceof SandboxBrowserClient) {
            return this.client.getVncUrl();
        }
        return undefined;
    }
    getCdpUrl() {
        if (this.client instanceof SandboxBrowserClient) {
            return this.client.getCdpUrl();
        }
        return undefined;
    }
    getBrowser() {
        if (this.client instanceof SandboxBrowserClient) {
            return this.client.getBrowser();
        }
        return null;
    }
    getContext() {
        if (this.client instanceof SandboxBrowserClient) {
            return this.client.getContext();
        }
        return null;
    }
    // Event handling
    on(event, listener) {
        this.client.on(event, listener);
        return this;
    }
    off(event, listener) {
        this.client.off(event, listener);
        return this;
    }
}
exports.UnifiedBrowserClient = UnifiedBrowserClient;
//# sourceMappingURL=browser_client_unified.js.map