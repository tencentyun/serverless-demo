{"version":3,"file":"stream.lgp.cjs","names":["getClientConfigHash","client","key","threadId","limit","state","Client","MessageTupleManager","StreamManager","useControllableThreadId","getBranchContext","error","StreamError","findLast","idx","branch","values","unique","getToolCallsWithResults"],"sources":["../../src/react/stream.lgp.tsx"],"sourcesContent":["/* __LC_ALLOW_ENTRYPOINT_SIDE_EFFECTS__ */\n\n\"use client\";\n\nimport {\n  type RefObject,\n  useCallback,\n  useEffect,\n  useMemo,\n  useRef,\n  useState,\n  useSyncExternalStore,\n} from \"react\";\nimport { findLast, unique } from \"../ui/utils.js\";\nimport { StreamError } from \"../ui/errors.js\";\nimport { getBranchContext } from \"../ui/branching.js\";\nimport { EventStreamEvent, StreamManager } from \"../ui/manager.js\";\nimport type {\n  UseStreamOptions,\n  GetUpdateType,\n  GetCustomEventType,\n  GetInterruptType,\n  GetConfigurableType,\n  GetToolCallsType,\n  RunCallbackMeta,\n  MessageMetadata,\n  UseStreamThread,\n} from \"../ui/types.js\";\nimport type { UseStream, SubmitOptions } from \"./types.js\";\nimport { Client, getClientConfigHash } from \"../client.js\";\nimport { type Message } from \"../types.messages.js\";\nimport { getToolCallsWithResults } from \"../utils/tools.js\";\nimport type { Interrupt, ThreadState } from \"../schema.js\";\nimport type { StreamMode } from \"../types.stream.js\";\nimport { MessageTupleManager } from \"../ui/messages.js\";\nimport { useControllableThreadId } from \"./thread.js\";\nimport type { BagTemplate } from \"../types.template.js\";\n\nfunction getFetchHistoryKey(\n  client: Client,\n  threadId: string | undefined | null,\n  limit: boolean | number\n) {\n  return [getClientConfigHash(client), threadId, limit].join(\":\");\n}\n\nfunction fetchHistory<StateType extends Record<string, unknown>>(\n  client: Client,\n  threadId: string,\n  options?: { limit?: boolean | number }\n) {\n  if (options?.limit === false) {\n    return client.threads.getState<StateType>(threadId).then((state) => {\n      if (state.checkpoint == null) return [];\n      return [state];\n    });\n  }\n\n  const limit = typeof options?.limit === \"number\" ? options.limit : 10;\n  return client.threads.getHistory<StateType>(threadId, { limit });\n}\n\nfunction useThreadHistory<StateType extends Record<string, unknown>>(\n  client: Client,\n  threadId: string | undefined | null,\n  limit: boolean | number,\n  options: {\n    passthrough: boolean;\n    submittingRef: RefObject<string | null>;\n    onError?: (error: unknown, run?: RunCallbackMeta) => void;\n  }\n): UseStreamThread<StateType> {\n  const key = getFetchHistoryKey(client, threadId, limit);\n  const [state, setState] = useState<{\n    key: string | undefined;\n    data: ThreadState<StateType>[] | undefined;\n    error: unknown | undefined;\n    isLoading: boolean;\n  }>(() => ({\n    key: undefined,\n    data: undefined,\n    error: undefined,\n    isLoading: threadId != null,\n  }));\n\n  const clientRef = useRef(client);\n  clientRef.current = client;\n\n  const onErrorRef = useRef(options?.onError);\n  onErrorRef.current = options?.onError;\n\n  const fetcher = useCallback(\n    (\n      threadId: string | undefined | null,\n      limit: boolean | number\n    ): Promise<ThreadState<StateType>[]> => {\n      // If only passthrough is enabled, don't fetch history\n      if (options.passthrough) return Promise.resolve([]);\n\n      const client = clientRef.current;\n      const key = getFetchHistoryKey(client, threadId, limit);\n\n      if (threadId != null) {\n        setState((state) => {\n          if (state.key === key) return { ...state, isLoading: true };\n          return { key, data: undefined, error: undefined, isLoading: true };\n        });\n        return fetchHistory<StateType>(client, threadId, { limit }).then(\n          (data) => {\n            setState((state) => {\n              if (state.key !== key) return state;\n              return { key, data, error: undefined, isLoading: false };\n            });\n            return data;\n          },\n          (error) => {\n            setState((state) => {\n              if (state.key !== key) return state;\n              return { key, data: state.data, error, isLoading: false };\n            });\n            onErrorRef.current?.(error);\n            return Promise.reject(error);\n          }\n        );\n      }\n\n      setState({ key, data: undefined, error: undefined, isLoading: false });\n      return Promise.resolve([]);\n    },\n    [options.passthrough]\n  );\n\n  useEffect(() => {\n    // Skip if a stream is already in progress, no need to fetch history\n    if (\n      options.submittingRef.current != null &&\n      options.submittingRef.current === threadId\n    ) {\n      return;\n    }\n\n    void fetcher(threadId, limit);\n    // The `threadId` and `limit` arguments are already present in `key`\n    // Thus we don't need to include them in the dependency array\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [fetcher, key]);\n\n  return {\n    data: state.data,\n    error: state.error,\n    isLoading: state.isLoading,\n    mutate: (mutateId?: string) => fetcher(mutateId ?? threadId, limit),\n  };\n}\n\nexport function useStreamLGP<\n  StateType extends Record<string, unknown> = Record<string, unknown>,\n  Bag extends BagTemplate = BagTemplate\n>(options: UseStreamOptions<StateType, Bag>): UseStream<StateType, Bag> {\n  type UpdateType = GetUpdateType<Bag, StateType>;\n  type CustomType = GetCustomEventType<Bag>;\n  type InterruptType = GetInterruptType<Bag>;\n  type ConfigurableType = GetConfigurableType<Bag>;\n  type ToolCallType = GetToolCallsType<StateType>;\n\n  const reconnectOnMountRef = useRef(options.reconnectOnMount);\n  const runMetadataStorage = useMemo(() => {\n    if (typeof window === \"undefined\") return null;\n    const storage = reconnectOnMountRef.current;\n    if (storage === true) return window.sessionStorage;\n    if (typeof storage === \"function\") return storage();\n    return null;\n  }, []);\n\n  const client = useMemo(\n    () =>\n      options.client ??\n      new Client({\n        apiUrl: options.apiUrl,\n        apiKey: options.apiKey,\n        callerOptions: options.callerOptions,\n        defaultHeaders: options.defaultHeaders,\n      }),\n    [\n      options.client,\n      options.apiKey,\n      options.apiUrl,\n      options.callerOptions,\n      options.defaultHeaders,\n    ]\n  );\n\n  const [messageManager] = useState(() => new MessageTupleManager());\n  const [stream] = useState(\n    () =>\n      new StreamManager<StateType, Bag>(messageManager, {\n        throttle: options.throttle ?? false,\n      })\n  );\n\n  useSyncExternalStore(\n    stream.subscribe,\n    stream.getSnapshot,\n    stream.getSnapshot\n  );\n\n  const [threadId, onThreadId] = useControllableThreadId(options);\n  const trackStreamModeRef = useRef<Exclude<StreamMode, \"messages\">[]>([]);\n\n  const trackStreamMode = useCallback(\n    (...mode: Exclude<StreamMode, \"messages\">[]) => {\n      const ref = trackStreamModeRef.current;\n      for (const m of mode) {\n        if (!ref.includes(m)) ref.push(m);\n      }\n    },\n    []\n  );\n\n  const hasUpdateListener = options.onUpdateEvent != null;\n  const hasCustomListener = options.onCustomEvent != null;\n  const hasLangChainListener = options.onLangChainEvent != null;\n  const hasDebugListener = options.onDebugEvent != null;\n  const hasCheckpointListener = options.onCheckpointEvent != null;\n  const hasTaskListener = options.onTaskEvent != null;\n\n  const callbackStreamMode = useMemo(() => {\n    const modes: Exclude<StreamMode, \"messages\">[] = [];\n    if (hasUpdateListener) modes.push(\"updates\");\n    if (hasCustomListener) modes.push(\"custom\");\n    if (hasLangChainListener) modes.push(\"events\");\n    if (hasDebugListener) modes.push(\"debug\");\n    if (hasCheckpointListener) modes.push(\"checkpoints\");\n    if (hasTaskListener) modes.push(\"tasks\");\n    return modes;\n  }, [\n    hasUpdateListener,\n    hasCustomListener,\n    hasLangChainListener,\n    hasDebugListener,\n    hasCheckpointListener,\n    hasTaskListener,\n  ]);\n\n  const threadIdRef = useRef<string | null>(threadId);\n  const threadIdStreamingRef = useRef<string | null>(null);\n\n  // Cancel the stream if thread ID has changed\n  useEffect(() => {\n    if (threadIdRef.current !== threadId) {\n      threadIdRef.current = threadId;\n      stream.clear();\n    }\n  }, [threadId, stream]);\n\n  const historyLimit =\n    typeof options.fetchStateHistory === \"object\" &&\n    options.fetchStateHistory != null\n      ? options.fetchStateHistory.limit ?? false\n      : options.fetchStateHistory ?? false;\n\n  const builtInHistory = useThreadHistory<StateType>(\n    client,\n    threadId,\n    historyLimit,\n    {\n      passthrough: options.thread != null,\n      submittingRef: threadIdStreamingRef,\n      onError: options.onError,\n    }\n  );\n  const history = options.thread ?? builtInHistory;\n\n  const getMessages = (value: StateType): Message[] => {\n    const messagesKey = options.messagesKey ?? \"messages\";\n    return Array.isArray(value[messagesKey])\n      ? (value[messagesKey] as Message[])\n      : [];\n  };\n\n  const setMessages = (current: StateType, messages: Message[]): StateType => {\n    const messagesKey = options.messagesKey ?? \"messages\";\n    return { ...current, [messagesKey]: messages };\n  };\n\n  const [branch, setBranch] = useState<string>(\"\");\n  const branchContext = getBranchContext(branch, history.data ?? undefined);\n\n  const historyValues =\n    branchContext.threadHead?.values ??\n    options.initialValues ??\n    ({} as StateType);\n\n  const historyError = (() => {\n    const error = branchContext.threadHead?.tasks?.at(-1)?.error;\n    if (error == null) return undefined;\n    try {\n      const parsed = JSON.parse(error) as unknown;\n      if (StreamError.isStructuredError(parsed)) return new StreamError(parsed);\n      return parsed;\n    } catch {\n      // do nothing\n    }\n    return error;\n  })();\n\n  const messageMetadata = (() => {\n    const alreadyShown = new Set<string>();\n    return getMessages(historyValues).map(\n      (message, idx): Omit<MessageMetadata<StateType>, \"streamMetadata\"> => {\n        const messageId = message.id ?? idx;\n\n        // Find the first checkpoint where the message was seen\n        const firstSeenState = findLast(history.data ?? [], (state) =>\n          getMessages(state.values)\n            .map((m, idx) => m.id ?? idx)\n            .includes(messageId)\n        );\n\n        const checkpointId = firstSeenState?.checkpoint?.checkpoint_id;\n        let branch =\n          checkpointId != null\n            ? branchContext.branchByCheckpoint[checkpointId]\n            : undefined;\n        if (!branch?.branch?.length) branch = undefined;\n\n        // serialize branches\n        const optionsShown = branch?.branchOptions?.flat(2).join(\",\");\n        if (optionsShown) {\n          if (alreadyShown.has(optionsShown)) branch = undefined;\n          alreadyShown.add(optionsShown);\n        }\n\n        return {\n          messageId: messageId.toString(),\n          firstSeenState,\n\n          branch: branch?.branch,\n          branchOptions: branch?.branchOptions,\n        };\n      }\n    );\n  })();\n\n  const stop = () =>\n    stream.stop(historyValues, {\n      onStop: (args) => {\n        if (runMetadataStorage && threadId) {\n          const runId = runMetadataStorage.getItem(`lg:stream:${threadId}`);\n          if (runId) void client.runs.cancel(threadId, runId);\n          runMetadataStorage.removeItem(`lg:stream:${threadId}`);\n        }\n\n        options.onStop?.(args);\n      },\n    });\n\n  // --- TRANSPORT ---\n  const submit = async (\n    values: UpdateType | null | undefined,\n    submitOptions?: SubmitOptions<StateType, ConfigurableType>\n  ) => {\n    // Unbranch things\n    const checkpointId = submitOptions?.checkpoint?.checkpoint_id;\n    setBranch(\n      checkpointId != null\n        ? branchContext.branchByCheckpoint[checkpointId]?.branch ?? \"\"\n        : \"\"\n    );\n\n    // When `fetchStateHistory` is requested, thus we assume that branching\n    // is enabled. We then need to include the implicit branch.\n    const includeImplicitBranch =\n      historyLimit === true || typeof historyLimit === \"number\";\n\n    const shouldRefetch =\n      // We're expecting the whole thread state in onFinish\n      options.onFinish != null ||\n      // We're fetching history, thus we need the latest checkpoint\n      // to ensure we're not accidentally submitting to a wrong branch\n      includeImplicitBranch;\n\n    let callbackMeta: RunCallbackMeta | undefined;\n    let rejoinKey: `lg:stream:${string}` | undefined;\n    let usableThreadId = threadId;\n\n    await stream.start(\n      async (signal: AbortSignal) => {\n        stream.setStreamValues((values) => {\n          const prev = { ...historyValues, ...(values ?? {}) };\n          if (submitOptions?.optimisticValues != null) {\n            return {\n              ...prev,\n              ...(typeof submitOptions.optimisticValues === \"function\"\n                ? submitOptions.optimisticValues(prev)\n                : submitOptions.optimisticValues),\n            };\n          }\n\n          return { ...prev };\n        });\n\n        if (!usableThreadId) {\n          const thread = await client.threads.create({\n            threadId: submitOptions?.threadId,\n            metadata: submitOptions?.metadata,\n            signal,\n          });\n\n          usableThreadId = thread.thread_id;\n\n          // Pre-emptively update the thread ID before\n          // stream cancellation is kicked off and thread\n          // is being refetched\n          threadIdRef.current = usableThreadId;\n          threadIdStreamingRef.current = usableThreadId;\n\n          onThreadId(usableThreadId);\n        }\n\n        if (!usableThreadId) {\n          throw new Error(\"Failed to obtain valid thread ID.\");\n        }\n\n        threadIdStreamingRef.current = usableThreadId;\n\n        const streamMode = unique([\n          ...(submitOptions?.streamMode ?? []),\n          ...trackStreamModeRef.current,\n          ...callbackStreamMode,\n        ]);\n\n        let checkpoint =\n          submitOptions?.checkpoint ??\n          (includeImplicitBranch\n            ? branchContext.threadHead?.checkpoint\n            : undefined) ??\n          undefined;\n\n        // Avoid specifying a checkpoint if user explicitly set it to null\n        if (submitOptions?.checkpoint === null) checkpoint = undefined;\n\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-expect-error\n        if (checkpoint != null) delete checkpoint.thread_id;\n        const streamResumable =\n          submitOptions?.streamResumable ?? !!runMetadataStorage;\n\n        return client.runs.stream(usableThreadId, options.assistantId, {\n          input: values as Record<string, unknown>,\n          config: submitOptions?.config,\n          context: submitOptions?.context,\n          command: submitOptions?.command,\n\n          interruptBefore: submitOptions?.interruptBefore,\n          interruptAfter: submitOptions?.interruptAfter,\n          metadata: submitOptions?.metadata,\n          multitaskStrategy: submitOptions?.multitaskStrategy,\n          onCompletion: submitOptions?.onCompletion,\n          onDisconnect:\n            submitOptions?.onDisconnect ??\n            (streamResumable ? \"continue\" : \"cancel\"),\n\n          signal,\n\n          checkpoint,\n          streamMode,\n          streamSubgraphs: submitOptions?.streamSubgraphs,\n          streamResumable,\n          durability: submitOptions?.durability,\n          onRunCreated(params) {\n            callbackMeta = {\n              run_id: params.run_id,\n              thread_id: params.thread_id ?? usableThreadId!,\n            };\n\n            if (runMetadataStorage) {\n              rejoinKey = `lg:stream:${usableThreadId}`;\n              runMetadataStorage.setItem(rejoinKey, callbackMeta.run_id);\n            }\n\n            options.onCreated?.(callbackMeta);\n          },\n        }) as AsyncGenerator<\n          EventStreamEvent<StateType, UpdateType, CustomType>\n        >;\n      },\n      {\n        getMessages,\n        setMessages,\n\n        initialValues: historyValues,\n        callbacks: options,\n\n        async onSuccess() {\n          if (rejoinKey) runMetadataStorage?.removeItem(rejoinKey);\n\n          if (shouldRefetch) {\n            const newHistory = await history.mutate(usableThreadId!);\n            const lastHead = newHistory?.at(0);\n            if (lastHead) {\n              // We now have the latest update from /history\n              // Thus we can clear the local stream state\n              options.onFinish?.(lastHead, callbackMeta);\n              return null;\n            }\n          }\n\n          return undefined;\n        },\n        onError(error) {\n          options.onError?.(error, callbackMeta);\n        },\n        onFinish() {\n          threadIdStreamingRef.current = null;\n        },\n      }\n    );\n  };\n\n  const joinStream = async (\n    runId: string,\n    lastEventId?: string,\n    joinOptions?: { streamMode?: StreamMode | StreamMode[] }\n  ) => {\n    // eslint-disable-next-line no-param-reassign\n    lastEventId ??= \"-1\";\n    if (!threadId) return;\n\n    const callbackMeta: RunCallbackMeta = {\n      thread_id: threadId,\n      run_id: runId,\n    };\n\n    await stream.start(\n      async (signal: AbortSignal) => {\n        threadIdStreamingRef.current = threadId;\n        return client.runs.joinStream(threadId, runId, {\n          signal,\n          lastEventId,\n          streamMode: joinOptions?.streamMode,\n        }) as AsyncGenerator<\n          EventStreamEvent<StateType, UpdateType, CustomType>\n        >;\n      },\n      {\n        getMessages,\n        setMessages,\n\n        initialValues: historyValues,\n        callbacks: options,\n        async onSuccess() {\n          runMetadataStorage?.removeItem(`lg:stream:${threadId}`);\n          const newHistory = await history.mutate(threadId);\n          const lastHead = newHistory?.at(0);\n          if (lastHead) options.onFinish?.(lastHead, callbackMeta);\n        },\n        onError(error) {\n          options.onError?.(error, callbackMeta);\n        },\n        onFinish() {\n          threadIdStreamingRef.current = null;\n        },\n      }\n    );\n  };\n\n  const reconnectKey = useMemo(() => {\n    if (!runMetadataStorage || stream.isLoading) return undefined;\n    if (typeof window === \"undefined\") return undefined;\n    const runId = runMetadataStorage?.getItem(`lg:stream:${threadId}`);\n    if (!runId) return undefined;\n    return { runId, threadId };\n  }, [runMetadataStorage, stream.isLoading, threadId]);\n\n  const shouldReconnect = !!runMetadataStorage;\n  const reconnectRef = useRef({ threadId, shouldReconnect });\n\n  const joinStreamRef = useRef<typeof joinStream>(joinStream);\n  joinStreamRef.current = joinStream;\n\n  useEffect(() => {\n    // reset shouldReconnect when switching threads\n    if (reconnectRef.current.threadId !== threadId) {\n      reconnectRef.current = { threadId, shouldReconnect };\n    }\n  }, [threadId, shouldReconnect]);\n\n  useEffect(() => {\n    if (reconnectKey && reconnectRef.current.shouldReconnect) {\n      reconnectRef.current.shouldReconnect = false;\n      void joinStreamRef.current?.(reconnectKey.runId);\n    }\n  }, [reconnectKey]);\n\n  const error = stream.error ?? historyError ?? history.error;\n  const values = stream.values ?? historyValues;\n\n  return {\n    get values() {\n      trackStreamMode(\"values\");\n      return values;\n    },\n\n    client,\n    assistantId: options.assistantId,\n\n    error,\n    isLoading: stream.isLoading,\n\n    stop,\n    submit,\n\n    joinStream,\n\n    branch,\n    setBranch,\n\n    get history() {\n      if (historyLimit === false) {\n        throw new Error(\n          \"`fetchStateHistory` must be set to `true` to use `history`\"\n        );\n      }\n\n      return branchContext.flatHistory;\n    },\n\n    isThreadLoading: history.isLoading && history.data == null,\n\n    get experimental_branchTree() {\n      if (historyLimit === false) {\n        throw new Error(\n          \"`fetchStateHistory` must be set to `true` to use `experimental_branchTree`\"\n        );\n      }\n\n      return branchContext.branchTree;\n    },\n\n    get interrupt() {\n      if (\n        values != null &&\n        \"__interrupt__\" in values &&\n        Array.isArray(values.__interrupt__)\n      ) {\n        const valueInterrupts = values.__interrupt__;\n        if (valueInterrupts.length === 0) return { when: \"breakpoint\" };\n        if (valueInterrupts.length === 1) return valueInterrupts[0];\n\n        // TODO: fix the typing of interrupts if multiple interrupts are returned\n        return valueInterrupts;\n      }\n\n      // If we're deferring to old interrupt detection logic, don't show the interrupt if the stream is loading\n      if (stream.isLoading) return undefined;\n\n      const interrupts = branchContext.threadHead?.tasks?.at(-1)?.interrupts;\n      if (interrupts == null || interrupts.length === 0) {\n        // check if there's a next task present\n        const next = branchContext.threadHead?.next ?? [];\n        if (!next.length || error != null) return undefined;\n        return { when: \"breakpoint\" };\n      }\n\n      // Return only the current interrupt\n      return interrupts.at(-1) as Interrupt<InterruptType> | undefined;\n    },\n\n    get messages(): Message<ToolCallType>[] {\n      trackStreamMode(\"messages-tuple\", \"values\");\n      return getMessages(values);\n    },\n\n    get toolCalls() {\n      trackStreamMode(\"messages-tuple\", \"values\");\n      const msgs = getMessages(values) as Message<ToolCallType>[];\n      return getToolCallsWithResults<ToolCallType>(msgs);\n    },\n\n    getToolCalls(message) {\n      trackStreamMode(\"messages-tuple\", \"values\");\n      const msgs = getMessages(values) as Message<ToolCallType>[];\n      const allToolCalls = getToolCallsWithResults<ToolCallType>(msgs);\n      return allToolCalls.filter((tc) => tc.aiMessage.id === message.id);\n    },\n\n    getMessagesMetadata(\n      message: Message<ToolCallType>,\n      index?: number\n    ): MessageMetadata<StateType> | undefined {\n      trackStreamMode(\"values\");\n\n      const streamMetadata = messageManager.get(message.id)?.metadata;\n      const historyMetadata = messageMetadata?.find(\n        (m) => m.messageId === (message.id ?? index)\n      );\n\n      if (streamMetadata != null || historyMetadata != null) {\n        return {\n          ...historyMetadata,\n          streamMetadata,\n        } as MessageMetadata<StateType>;\n      }\n\n      return undefined;\n    },\n  };\n}\n"],"mappings":";;;;;;;;;;;;;;AAsCA,SAAS,mBACP,QACA,UACA,OACA;AACA,QAAO;EAACA,mCAAoB,OAAO;EAAE;EAAU;EAAM,CAAC,KAAK,IAAI;;AAGjE,SAAS,aACP,QACA,UACA,SACA;AACA,KAAI,SAAS,UAAU,MACrB,QAAO,OAAO,QAAQ,SAAoB,SAAS,CAAC,MAAM,UAAU;AAClE,MAAI,MAAM,cAAc,KAAM,QAAO,EAAE;AACvC,SAAO,CAAC,MAAM;GACd;CAGJ,MAAM,QAAQ,OAAO,SAAS,UAAU,WAAW,QAAQ,QAAQ;AACnE,QAAO,OAAO,QAAQ,WAAsB,UAAU,EAAE,OAAO,CAAC;;AAGlE,SAAS,iBACP,QACA,UACA,OACA,SAK4B;CAC5B,MAAM,MAAM,mBAAmB,QAAQ,UAAU,MAAM;CACvD,MAAM,CAAC,OAAO,uCAKJ;EACR,KAAK;EACL,MAAM;EACN,OAAO;EACP,WAAW,YAAY;EACxB,EAAE;CAEH,MAAM,8BAAmB,OAAO;AAChC,WAAU,UAAU;CAEpB,MAAM,+BAAoB,SAAS,QAAQ;AAC3C,YAAW,UAAU,SAAS;CAE9B,MAAM,kCAEF,YACA,YACsC;AAEtC,MAAI,QAAQ,YAAa,QAAO,QAAQ,QAAQ,EAAE,CAAC;EAEnD,MAAMC,WAAS,UAAU;EACzB,MAAMC,QAAM,mBAAmBD,UAAQE,YAAUC,QAAM;AAEvD,MAAID,cAAY,MAAM;AACpB,aAAU,YAAU;AAClB,QAAIE,QAAM,QAAQH,MAAK,QAAO;KAAE,GAAGG;KAAO,WAAW;KAAM;AAC3D,WAAO;KAAE;KAAK,MAAM;KAAW,OAAO;KAAW,WAAW;KAAM;KAClE;AACF,UAAO,aAAwBJ,UAAQE,YAAU,EAAE,gBAAO,CAAC,CAAC,MACzD,SAAS;AACR,cAAU,YAAU;AAClB,SAAIE,QAAM,QAAQH,MAAK,QAAOG;AAC9B,YAAO;MAAE;MAAK;MAAM,OAAO;MAAW,WAAW;MAAO;MACxD;AACF,WAAO;OAER,UAAU;AACT,cAAU,YAAU;AAClB,SAAIA,QAAM,QAAQH,MAAK,QAAOG;AAC9B,YAAO;MAAE;MAAK,MAAMA,QAAM;MAAM;MAAO,WAAW;MAAO;MACzD;AACF,eAAW,UAAU,MAAM;AAC3B,WAAO,QAAQ,OAAO,MAAM;KAE/B;;AAGH,WAAS;GAAE;GAAK,MAAM;GAAW,OAAO;GAAW,WAAW;GAAO,CAAC;AACtE,SAAO,QAAQ,QAAQ,EAAE,CAAC;IAE5B,CAAC,QAAQ,YAAY,CACtB;AAED,4BAAgB;AAEd,MACE,QAAQ,cAAc,WAAW,QACjC,QAAQ,cAAc,YAAY,SAElC;AAGF,EAAK,QAAQ,UAAU,MAAM;IAI5B,CAAC,SAAS,IAAI,CAAC;AAElB,QAAO;EACL,MAAM,MAAM;EACZ,OAAO,MAAM;EACb,WAAW,MAAM;EACjB,SAAS,aAAsB,QAAQ,YAAY,UAAU,MAAM;EACpE;;AAGH,SAAgB,aAGd,SAAsE;CAOtE,MAAM,wCAA6B,QAAQ,iBAAiB;CAC5D,MAAM,8CAAmC;AACvC,MAAI,OAAO,WAAW,YAAa,QAAO;EAC1C,MAAM,UAAU,oBAAoB;AACpC,MAAI,YAAY,KAAM,QAAO,OAAO;AACpC,MAAI,OAAO,YAAY,WAAY,QAAO,SAAS;AACnD,SAAO;IACN,EAAE,CAAC;CAEN,MAAM,kCAEF,QAAQ,UACR,IAAIC,sBAAO;EACT,QAAQ,QAAQ;EAChB,QAAQ,QAAQ;EAChB,eAAe,QAAQ;EACvB,gBAAgB,QAAQ;EACzB,CAAC,EACJ;EACE,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,QAAQ;EACR,QAAQ;EACT,CACF;CAED,MAAM,CAAC,4CAAiC,IAAIC,sCAAqB,CAAC;CAClE,MAAM,CAAC,oCAEH,IAAIC,8BAA8B,gBAAgB,EAChD,UAAU,QAAQ,YAAY,OAC/B,CAAC,CACL;AAED,iCACE,OAAO,WACP,OAAO,aACP,OAAO,YACR;CAED,MAAM,CAAC,UAAU,cAAcC,uCAAwB,QAAQ;CAC/D,MAAM,uCAA+D,EAAE,CAAC;CAExE,MAAM,0CACH,GAAG,SAA4C;EAC9C,MAAM,MAAM,mBAAmB;AAC/B,OAAK,MAAM,KAAK,KACd,KAAI,CAAC,IAAI,SAAS,EAAE,CAAE,KAAI,KAAK,EAAE;IAGrC,EAAE,CACH;CAED,MAAM,oBAAoB,QAAQ,iBAAiB;CACnD,MAAM,oBAAoB,QAAQ,iBAAiB;CACnD,MAAM,uBAAuB,QAAQ,oBAAoB;CACzD,MAAM,mBAAmB,QAAQ,gBAAgB;CACjD,MAAM,wBAAwB,QAAQ,qBAAqB;CAC3D,MAAM,kBAAkB,QAAQ,eAAe;CAE/C,MAAM,8CAAmC;EACvC,MAAM,QAA2C,EAAE;AACnD,MAAI,kBAAmB,OAAM,KAAK,UAAU;AAC5C,MAAI,kBAAmB,OAAM,KAAK,SAAS;AAC3C,MAAI,qBAAsB,OAAM,KAAK,SAAS;AAC9C,MAAI,iBAAkB,OAAM,KAAK,QAAQ;AACzC,MAAI,sBAAuB,OAAM,KAAK,cAAc;AACpD,MAAI,gBAAiB,OAAM,KAAK,QAAQ;AACxC,SAAO;IACN;EACD;EACA;EACA;EACA;EACA;EACA;EACD,CAAC;CAEF,MAAM,gCAAoC,SAAS;CACnD,MAAM,yCAA6C,KAAK;AAGxD,4BAAgB;AACd,MAAI,YAAY,YAAY,UAAU;AACpC,eAAY,UAAU;AACtB,UAAO,OAAO;;IAEf,CAAC,UAAU,OAAO,CAAC;CAEtB,MAAM,eACJ,OAAO,QAAQ,sBAAsB,YACrC,QAAQ,qBAAqB,OACzB,QAAQ,kBAAkB,SAAS,QACnC,QAAQ,qBAAqB;CAEnC,MAAM,iBAAiB,iBACrB,QACA,UACA,cACA;EACE,aAAa,QAAQ,UAAU;EAC/B,eAAe;EACf,SAAS,QAAQ;EAClB,CACF;CACD,MAAM,UAAU,QAAQ,UAAU;CAElC,MAAM,eAAe,UAAgC;EACnD,MAAM,cAAc,QAAQ,eAAe;AAC3C,SAAO,MAAM,QAAQ,MAAM,aAAa,GACnC,MAAM,eACP,EAAE;;CAGR,MAAM,eAAe,SAAoB,aAAmC;EAC1E,MAAM,cAAc,QAAQ,eAAe;AAC3C,SAAO;GAAE,GAAG;IAAU,cAAc;GAAU;;CAGhD,MAAM,CAAC,QAAQ,iCAA8B,GAAG;CAChD,MAAM,gBAAgBC,mCAAiB,QAAQ,QAAQ,QAAQ,OAAU;CAEzE,MAAM,gBACJ,cAAc,YAAY,UAC1B,QAAQ,iBACP,EAAE;CAEL,MAAM,sBAAsB;EAC1B,MAAMC,UAAQ,cAAc,YAAY,OAAO,GAAG,GAAG,EAAE;AACvD,MAAIA,WAAS,KAAM,QAAO;AAC1B,MAAI;GACF,MAAM,SAAS,KAAK,MAAMA,QAAM;AAChC,OAAIC,2BAAY,kBAAkB,OAAO,CAAE,QAAO,IAAIA,2BAAY,OAAO;AACzE,UAAO;UACD;AAGR,SAAOD;KACL;CAEJ,MAAM,yBAAyB;EAC7B,MAAM,+BAAe,IAAI,KAAa;AACtC,SAAO,YAAY,cAAc,CAAC,KAC/B,SAAS,QAA4D;GACpE,MAAM,YAAY,QAAQ,MAAM;GAGhC,MAAM,iBAAiBE,uBAAS,QAAQ,QAAQ,EAAE,GAAG,UACnD,YAAY,MAAM,OAAO,CACtB,KAAK,GAAG,UAAQ,EAAE,MAAMC,MAAI,CAC5B,SAAS,UAAU,CACvB;GAED,MAAM,eAAe,gBAAgB,YAAY;GACjD,IAAIC,WACF,gBAAgB,OACZ,cAAc,mBAAmB,gBACjC;AACN,OAAI,CAACA,UAAQ,QAAQ,OAAQ,YAAS;GAGtC,MAAM,eAAeA,UAAQ,eAAe,KAAK,EAAE,CAAC,KAAK,IAAI;AAC7D,OAAI,cAAc;AAChB,QAAI,aAAa,IAAI,aAAa,CAAE,YAAS;AAC7C,iBAAa,IAAI,aAAa;;AAGhC,UAAO;IACL,WAAW,UAAU,UAAU;IAC/B;IAEA,QAAQA,UAAQ;IAChB,eAAeA,UAAQ;IACxB;IAEJ;KACC;CAEJ,MAAM,aACJ,OAAO,KAAK,eAAe,EACzB,SAAS,SAAS;AAChB,MAAI,sBAAsB,UAAU;GAClC,MAAM,QAAQ,mBAAmB,QAAQ,aAAa,WAAW;AACjE,OAAI,MAAO,CAAK,OAAO,KAAK,OAAO,UAAU,MAAM;AACnD,sBAAmB,WAAW,aAAa,WAAW;;AAGxD,UAAQ,SAAS,KAAK;IAEzB,CAAC;CAGJ,MAAM,SAAS,OACb,UACA,kBACG;EAEH,MAAM,eAAe,eAAe,YAAY;AAChD,YACE,gBAAgB,OACZ,cAAc,mBAAmB,eAAe,UAAU,KAC1D,GACL;EAID,MAAM,wBACJ,iBAAiB,QAAQ,OAAO,iBAAiB;EAEnD,MAAM,gBAEJ,QAAQ,YAAY,QAGpB;EAEF,IAAI;EACJ,IAAI;EACJ,IAAI,iBAAiB;AAErB,QAAM,OAAO,MACX,OAAO,WAAwB;AAC7B,UAAO,iBAAiB,aAAW;IACjC,MAAM,OAAO;KAAE,GAAG;KAAe,GAAIC,YAAU,EAAE;KAAG;AACpD,QAAI,eAAe,oBAAoB,KACrC,QAAO;KACL,GAAG;KACH,GAAI,OAAO,cAAc,qBAAqB,aAC1C,cAAc,iBAAiB,KAAK,GACpC,cAAc;KACnB;AAGH,WAAO,EAAE,GAAG,MAAM;KAClB;AAEF,OAAI,CAAC,gBAAgB;AAOnB,sBANe,MAAM,OAAO,QAAQ,OAAO;KACzC,UAAU,eAAe;KACzB,UAAU,eAAe;KACzB;KACD,CAAC,EAEsB;AAKxB,gBAAY,UAAU;AACtB,yBAAqB,UAAU;AAE/B,eAAW,eAAe;;AAG5B,OAAI,CAAC,eACH,OAAM,IAAI,MAAM,oCAAoC;AAGtD,wBAAqB,UAAU;GAE/B,MAAM,aAAaC,qBAAO;IACxB,GAAI,eAAe,cAAc,EAAE;IACnC,GAAG,mBAAmB;IACtB,GAAG;IACJ,CAAC;GAEF,IAAI,aACF,eAAe,eACd,wBACG,cAAc,YAAY,aAC1B,WACJ;AAGF,OAAI,eAAe,eAAe,KAAM,cAAa;AAIrD,OAAI,cAAc,KAAM,QAAO,WAAW;GAC1C,MAAM,kBACJ,eAAe,mBAAmB,CAAC,CAAC;AAEtC,UAAO,OAAO,KAAK,OAAO,gBAAgB,QAAQ,aAAa;IAC7D,OAAOD;IACP,QAAQ,eAAe;IACvB,SAAS,eAAe;IACxB,SAAS,eAAe;IAExB,iBAAiB,eAAe;IAChC,gBAAgB,eAAe;IAC/B,UAAU,eAAe;IACzB,mBAAmB,eAAe;IAClC,cAAc,eAAe;IAC7B,cACE,eAAe,iBACd,kBAAkB,aAAa;IAElC;IAEA;IACA;IACA,iBAAiB,eAAe;IAChC;IACA,YAAY,eAAe;IAC3B,aAAa,QAAQ;AACnB,oBAAe;MACb,QAAQ,OAAO;MACf,WAAW,OAAO,aAAa;MAChC;AAED,SAAI,oBAAoB;AACtB,kBAAY,aAAa;AACzB,yBAAmB,QAAQ,WAAW,aAAa,OAAO;;AAG5D,aAAQ,YAAY,aAAa;;IAEpC,CAAC;KAIJ;GACE;GACA;GAEA,eAAe;GACf,WAAW;GAEX,MAAM,YAAY;AAChB,QAAI,UAAW,qBAAoB,WAAW,UAAU;AAExD,QAAI,eAAe;KAEjB,MAAM,YADa,MAAM,QAAQ,OAAO,eAAgB,GAC3B,GAAG,EAAE;AAClC,SAAI,UAAU;AAGZ,cAAQ,WAAW,UAAU,aAAa;AAC1C,aAAO;;;;GAMb,QAAQ,SAAO;AACb,YAAQ,UAAUL,SAAO,aAAa;;GAExC,WAAW;AACT,yBAAqB,UAAU;;GAElC,CACF;;CAGH,MAAM,aAAa,OACjB,OACA,aACA,gBACG;AAEH,kBAAgB;AAChB,MAAI,CAAC,SAAU;EAEf,MAAM,eAAgC;GACpC,WAAW;GACX,QAAQ;GACT;AAED,QAAM,OAAO,MACX,OAAO,WAAwB;AAC7B,wBAAqB,UAAU;AAC/B,UAAO,OAAO,KAAK,WAAW,UAAU,OAAO;IAC7C;IACA;IACA,YAAY,aAAa;IAC1B,CAAC;KAIJ;GACE;GACA;GAEA,eAAe;GACf,WAAW;GACX,MAAM,YAAY;AAChB,wBAAoB,WAAW,aAAa,WAAW;IAEvD,MAAM,YADa,MAAM,QAAQ,OAAO,SAAS,GACpB,GAAG,EAAE;AAClC,QAAI,SAAU,SAAQ,WAAW,UAAU,aAAa;;GAE1D,QAAQ,SAAO;AACb,YAAQ,UAAUA,SAAO,aAAa;;GAExC,WAAW;AACT,yBAAqB,UAAU;;GAElC,CACF;;CAGH,MAAM,wCAA6B;AACjC,MAAI,CAAC,sBAAsB,OAAO,UAAW,QAAO;AACpD,MAAI,OAAO,WAAW,YAAa,QAAO;EAC1C,MAAM,QAAQ,oBAAoB,QAAQ,aAAa,WAAW;AAClE,MAAI,CAAC,MAAO,QAAO;AACnB,SAAO;GAAE;GAAO;GAAU;IACzB;EAAC;EAAoB,OAAO;EAAW;EAAS,CAAC;CAEpD,MAAM,kBAAkB,CAAC,CAAC;CAC1B,MAAM,iCAAsB;EAAE;EAAU;EAAiB,CAAC;CAE1D,MAAM,kCAA0C,WAAW;AAC3D,eAAc,UAAU;AAExB,4BAAgB;AAEd,MAAI,aAAa,QAAQ,aAAa,SACpC,cAAa,UAAU;GAAE;GAAU;GAAiB;IAErD,CAAC,UAAU,gBAAgB,CAAC;AAE/B,4BAAgB;AACd,MAAI,gBAAgB,aAAa,QAAQ,iBAAiB;AACxD,gBAAa,QAAQ,kBAAkB;AACvC,GAAK,cAAc,UAAU,aAAa,MAAM;;IAEjD,CAAC,aAAa,CAAC;CAElB,MAAM,QAAQ,OAAO,SAAS,gBAAgB,QAAQ;CACtD,MAAM,SAAS,OAAO,UAAU;AAEhC,QAAO;EACL,IAAI,SAAS;AACX,mBAAgB,SAAS;AACzB,UAAO;;EAGT;EACA,aAAa,QAAQ;EAErB;EACA,WAAW,OAAO;EAElB;EACA;EAEA;EAEA;EACA;EAEA,IAAI,UAAU;AACZ,OAAI,iBAAiB,MACnB,OAAM,IAAI,MACR,6DACD;AAGH,UAAO,cAAc;;EAGvB,iBAAiB,QAAQ,aAAa,QAAQ,QAAQ;EAEtD,IAAI,0BAA0B;AAC5B,OAAI,iBAAiB,MACnB,OAAM,IAAI,MACR,6EACD;AAGH,UAAO,cAAc;;EAGvB,IAAI,YAAY;AACd,OACE,UAAU,QACV,mBAAmB,UACnB,MAAM,QAAQ,OAAO,cAAc,EACnC;IACA,MAAM,kBAAkB,OAAO;AAC/B,QAAI,gBAAgB,WAAW,EAAG,QAAO,EAAE,MAAM,cAAc;AAC/D,QAAI,gBAAgB,WAAW,EAAG,QAAO,gBAAgB;AAGzD,WAAO;;AAIT,OAAI,OAAO,UAAW,QAAO;GAE7B,MAAM,aAAa,cAAc,YAAY,OAAO,GAAG,GAAG,EAAE;AAC5D,OAAI,cAAc,QAAQ,WAAW,WAAW,GAAG;AAGjD,QAAI,EADS,cAAc,YAAY,QAAQ,EAAE,EACvC,UAAU,SAAS,KAAM,QAAO;AAC1C,WAAO,EAAE,MAAM,cAAc;;AAI/B,UAAO,WAAW,GAAG,GAAG;;EAG1B,IAAI,WAAoC;AACtC,mBAAgB,kBAAkB,SAAS;AAC3C,UAAO,YAAY,OAAO;;EAG5B,IAAI,YAAY;AACd,mBAAgB,kBAAkB,SAAS;AAE3C,UAAOO,sCADM,YAAY,OAAO,CACkB;;EAGpD,aAAa,SAAS;AACpB,mBAAgB,kBAAkB,SAAS;AAG3C,UADqBA,sCADR,YAAY,OAAO,CACgC,CAC5C,QAAQ,OAAO,GAAG,UAAU,OAAO,QAAQ,GAAG;;EAGpE,oBACE,SACA,OACwC;AACxC,mBAAgB,SAAS;GAEzB,MAAM,iBAAiB,eAAe,IAAI,QAAQ,GAAG,EAAE;GACvD,MAAM,kBAAkB,iBAAiB,MACtC,MAAM,EAAE,eAAe,QAAQ,MAAM,OACvC;AAED,OAAI,kBAAkB,QAAQ,mBAAmB,KAC/C,QAAO;IACL,GAAG;IACH;IACD;;EAKN"}