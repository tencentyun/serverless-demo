var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  agui: () => agui_exports,
  createExpressRoutes: () => createExpressRoutes,
  createExpressServer: () => createExpressServer,
  run: () => run
});
module.exports = __toCommonJS(index_exports);

// src/agui/index.ts
var agui_exports = {};
__export(agui_exports, {
  healthz: () => healthz_exports,
  openai: () => openai_exports,
  sendMessage: () => sendMessage_exports,
  sendMessageAGUI: () => sendMessageAGUI_exports
});

// src/agui/sendMessage/index.ts
var sendMessage_exports = {};
__export(sendMessage_exports, {
  createServerAdapter: () => createServerAdapter,
  handler: () => handler
});

// src/agui/sendMessage/handler.ts
var import_client = require("@ag-ui/client");
var import_uuid = require("uuid");
var import_repeater = require("@repeaterjs/repeater");
function handler(input, agent) {
  agent.threadId = input.conversationId;
  if (input.messages) {
    const aguiMessages = input.messages.map(messageToAGUIMessage);
    agent.setMessages(aguiMessages);
  }
  return new import_repeater.Repeater(async (push, stop) => {
    agent.runAgent(
      {
        tools: input.tools,
        forwardedProps: {
          resume: input.resume
        }
      },
      {
        onTextMessageContentEvent: ({ event }) => {
          push({
            type: "text",
            content: event.delta,
            rawEvent: event.rawEvent
          });
        },
        onRunFinishedEvent: () => {
          stop();
        },
        onRunErrorEvent: ({ event }) => {
          push({
            type: "error",
            error: event.message,
            code: event.code
          });
        },
        onToolCallStartEvent: ({ event }) => {
          push({
            type: "tool-call-start",
            toolCallId: event.toolCallId,
            toolCallName: event.toolCallName
          });
        },
        onToolCallArgsEvent: ({ event }) => {
          push({
            type: "tool-call-args",
            toolCallId: event.toolCallId,
            delta: event.delta
          });
        },
        onToolCallEndEvent: ({ event }) => {
          push({
            type: "tool-call-end",
            toolCallId: event.toolCallId
          });
        },
        onToolCallResultEvent: ({ event }) => {
          push({
            type: "tool-result",
            result: event.content,
            toolCallId: event.toolCallId
          });
        },
        onEvent: ({ event }) => {
          if (event.type !== import_client.EventType.RUN_FINISHED) {
            return;
          }
          if (event["outcome"] !== "interrupt") {
            return;
          }
          const interrupt = event["interrupt"];
          push({
            type: "interrupt",
            id: interrupt.id,
            reason: interrupt.reason,
            payload: interrupt.payload
          });
        }
      }
    );
  });
}
function messageToAGUIMessage(message) {
  if (message.role === "system" || message.role === "user") {
    return {
      id: (0, import_uuid.v4)(),
      role: message.role,
      content: message.content
    };
  }
  if (message.role === "tool") {
    return {
      role: "tool",
      toolCallId: message.toolCallId,
      content: message.content,
      id: (0, import_uuid.v4)()
    };
  }
  if (message.role === "assistant") {
    return {
      role: "assistant",
      content: message.content,
      id: (0, import_uuid.v4)(),
      toolCalls: message.toolCalls
    };
  }
}

// src/agui/sendMessage/server.ts
var import_server = require("@whatwg-node/server");
var import_agent_shared = require("@cloudbase/agent-shared");
function createServerAdapter(createAgent) {
  return (0, import_server.createServerAdapter)(async (request) => {
    const input = import_agent_shared.sendMessageInputSchema.parse(await request.json());
    const { agent: unknownAgent, cleanup } = await Promise.resolve(
      createAgent({ request })
    );
    const agent = "toAGUIAgent" in unknownAgent ? unknownAgent.toAGUIAgent() : unknownAgent;
    const events = handler(input, agent);
    let heartbeat;
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder();
        heartbeat = setInterval(() => {
          controller.enqueue(encoder.encode(":ping\n\n"));
        }, 15 * 1e3);
        try {
          for await (const event of events) {
            const sseChunk = `data: ${JSON.stringify(event)}

`;
            controller.enqueue(encoder.encode(sseChunk));
          }
          controller.enqueue(encoder.encode("data: [DONE]\n\n"));
        } finally {
          if (heartbeat) clearInterval(heartbeat);
          controller.close();
          cleanup == null ? void 0 : cleanup();
        }
      },
      cancel() {
        if (heartbeat) clearInterval(heartbeat);
      }
    });
    const headers = new Headers({
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive"
    });
    return new Response(stream, { status: 200, headers });
  });
}

// src/agui/sendMessageAGUI/index.ts
var sendMessageAGUI_exports = {};
__export(sendMessageAGUI_exports, {
  createServerAdapter: () => createServerAdapter2,
  handler: () => handler2
});

// src/agui/sendMessageAGUI/handler.ts
var import_repeater2 = require("@repeaterjs/repeater");
function handler2(input, agent) {
  return new import_repeater2.Repeater(async (push, stop) => {
    agent.setMessages(input.messages);
    agent.setState(input.state);
    agent.threadId = input.threadId;
    await agent.runAgent(input, {
      onEvent: ({ event }) => {
        push(event);
      }
    });
    stop();
  });
}

// src/agui/sendMessageAGUI/server.ts
var import_server3 = require("@whatwg-node/server");
var import_client2 = require("@ag-ui/client");
function createServerAdapter2(createAgent) {
  return (0, import_server3.createServerAdapter)(async (request) => {
    const input = import_client2.RunAgentInputSchema.parse(await request.json());
    const { agent: unknownAgent, cleanup } = await Promise.resolve(
      createAgent({ request })
    );
    const agent = "toAGUIAgent" in unknownAgent ? unknownAgent.toAGUIAgent() : unknownAgent;
    const events = handler2(input, agent);
    let heartbeat;
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder();
        heartbeat = setInterval(() => {
          controller.enqueue(encoder.encode(":ping\n\n"));
        }, 15 * 1e3);
        try {
          for await (const event of events) {
            const sseChunk = `data: ${JSON.stringify(event)}

`;
            controller.enqueue(encoder.encode(sseChunk));
          }
        } finally {
          if (heartbeat) clearInterval(heartbeat);
          controller.close();
          cleanup == null ? void 0 : cleanup();
        }
      },
      cancel() {
        if (heartbeat) clearInterval(heartbeat);
      }
    });
    const headers = new Headers({
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive"
    });
    return new Response(stream, { status: 200, headers });
  });
}

// src/agui/healthz/index.ts
var healthz_exports = {};
__export(healthz_exports, {
  serverAdapter: () => serverAdapter
});
var import_server5 = require("@whatwg-node/server");
var serverAdapter = (0, import_server5.createServerAdapter)(() => new Response("OK"));

// src/agui/openai/index.ts
var openai_exports = {};
__export(openai_exports, {
  createServerAdapter: () => createServerAdapter3,
  handler: () => handler3
});

// src/agui/openai/handler.ts
var import_uuid2 = require("uuid");
var import_repeater3 = require("@repeaterjs/repeater");
function handler3(input, agent) {
  var _a;
  const res = handler(
    {
      messages: input.messages.map(openAIMessageToClientMessage),
      tools: (_a = input.tools) == null ? void 0 : _a.filter((tool) => tool.type === "function").map((tool) => ({
        name: tool.function.name,
        description: tool.function.description,
        parameters: tool.function.parameters
      })),
      conversationId: (0, import_uuid2.v4)()
    },
    agent
  );
  return new import_repeater3.Repeater(async (push, stop) => {
    const id = (0, import_uuid2.v4)();
    let tools = [];
    let lastWithToolCall = false;
    let maxIndex = 0;
    const toolIdToIndex = {};
    for await (let x of res) {
      if (x.type === "text") {
        lastWithToolCall = false;
        push({
          id,
          object: "chat.completion.chunk",
          model: "",
          choices: [
            {
              delta: {
                role: "assistant",
                content: x.content
              },
              index: 0,
              finish_reason: null
            }
          ],
          created: Date.now()
        });
      }
      if (x.type === "tool-call-start") {
        toolIdToIndex[x.toolCallId] = maxIndex;
        maxIndex++;
        tools.push({
          name: x.toolCallName,
          id: x.toolCallId,
          args: ""
        });
      }
      if (x.type === "tool-call-args") {
        tools.find((t) => t.id === x.toolCallId).args += x.delta;
      }
      if (x.type === "tool-call-end") {
        const index = tools.findIndex((t) => t.id === x.toolCallId);
        const [tool] = tools.splice(index, 1);
        lastWithToolCall = true;
        push({
          id,
          created: Date.now(),
          model: "",
          object: "chat.completion.chunk",
          choices: [
            {
              index: 0,
              finish_reason: null,
              delta: {
                tool_calls: [
                  {
                    index: toolIdToIndex[tool.id],
                    type: "function",
                    id: tool.id,
                    function: {
                      name: tool.name,
                      arguments: tool.args
                    }
                  }
                ]
              }
            }
          ]
        });
      }
    }
    push({
      id,
      object: "chat.completion.chunk",
      model: "",
      created: Date.now(),
      choices: [
        {
          finish_reason: lastWithToolCall ? "tool_calls" : "stop",
          index: 0,
          delta: {}
        }
      ]
    });
    stop();
  });
}
function openAIMessageToClientMessage(message) {
  var _a;
  if (message.role === "developer" || message.role === "system") {
    return {
      role: "system",
      content: typeof message.content === "string" ? message.content : message.content.map((p) => p.text).join("")
    };
  }
  if (message.role === "user") {
    return {
      role: "user",
      content: typeof message.content === "string" ? message.content : message.content.filter((p) => p.type === "text").map((p) => p.text).join("")
    };
  }
  if (message.role === "assistant") {
    return {
      role: "assistant",
      content: typeof message.content === "string" ? message.content : message.content.filter((p) => p.type === "text").map((p) => p.text).join(""),
      toolCalls: (_a = message.tool_calls) == null ? void 0 : _a.filter((t) => t.type === "function").map((toolCall) => ({
        id: toolCall.id,
        type: "function",
        function: {
          name: toolCall.function.name,
          arguments: toolCall.function.arguments
        }
      }))
    };
  }
  if (message.role === "tool") {
    return {
      role: "tool",
      content: typeof message.content === "string" ? message.content : message.content.map((c) => c.text).join(""),
      toolCallId: message.tool_call_id
    };
  }
  if (message.role === "function") {
    throw new Error("unreachable: function message is deprecated");
  }
}

// src/agui/openai/server.ts
var import_server6 = require("@whatwg-node/server");
function createServerAdapter3(createAgent) {
  return (0, import_server6.createServerAdapter)(async (request) => {
    const input = await request.json();
    const { agent: unknownAgent, cleanup } = await Promise.resolve(
      createAgent({ request })
    );
    const agent = "toAGUIAgent" in unknownAgent ? unknownAgent.toAGUIAgent() : unknownAgent;
    const events = handler3(input, agent);
    const stream = new ReadableStream({
      async start(controller) {
        const encoder = new TextEncoder();
        for await (const event of events) {
          const sseChunk = `data: ${JSON.stringify(event)}

`;
          controller.enqueue(encoder.encode(sseChunk));
        }
        controller.enqueue(encoder.encode("data: [DONE]\n\n"));
        controller.close();
        cleanup == null ? void 0 : cleanup();
      }
    });
    const headers = new Headers({
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache, no-transform",
      Connection: "keep-alive"
    });
    return new Response(stream, { status: 200, headers });
  });
}

// src/express.ts
var import_runtime = require("@copilotkit/runtime");
var import_express = __toESM(require("express"));
var import_cors = __toESM(require("cors"));
var import_async_hooks = require("async_hooks");
var import_server8 = require("@whatwg-node/server");
var DefaultFetchAPI = __toESM(require("@whatwg-node/fetch"));
var preparedAgentStorage = new import_async_hooks.AsyncLocalStorage();
function agentCloneFn() {
  const preparedAgent = preparedAgentStorage.getStore();
  if (preparedAgent) {
    return preparedAgent;
  }
  throw new Error(
    "agent.clone() called outside of request context. This should not happen in normal operation."
  );
}
function run(props) {
  const { port, ...rest } = props;
  createExpressServer(rest).listen(
    typeof port === "number" ? port : parseInt(port)
  );
}
function createExpressServer(props) {
  const { cors: corsOption = true, ...rest } = props;
  const app = (0, import_express.default)();
  if (corsOption) {
    app.use(isCorsOptions(corsOption) ? (0, import_cors.default)(corsOption) : (0, import_cors.default)());
  }
  createExpressRoutes({
    ...rest,
    express: app
  });
  return app;
}
function createExpressRoutes({
  createAgent,
  basePath: _basePath,
  express,
  useAGUI: _useAGUI,
  aguiOptions
}) {
  const useAGUI = _useAGUI ?? true;
  const basePath = _basePath ?? (process.env.TENCENTCLOUD_RUNENV === "SCF" ? "/v1/aibot/bots/:agentId/" : "/");
  const sendMessageServerAdapter = useAGUI ? sendMessageAGUI_exports.createServerAdapter(createAgent) : sendMessage_exports.createServerAdapter(createAgent);
  if (useAGUI) {
    createAGUIRoute({
      basePath,
      express,
      createAgent,
      ...aguiOptions || {}
    });
  }
  const openaiServerAdapter = openai_exports.createServerAdapter(createAgent);
  const healthzServerAdapter = healthz_exports.serverAdapter;
  express.use(`${basePath}send-message`, sendMessageServerAdapter);
  express.use(`${basePath}healthz`, healthzServerAdapter);
  express.use(`${basePath}chat/completions`, openaiServerAdapter);
  return express;
}
var AGUIRpcHandlerPromise = null;
function getAGUIRpcHandler({
  createAgent,
  runtimeOptions,
  basePath,
  endpointOptions,
  request
}) {
  if (AGUIRpcHandlerPromise) return AGUIRpcHandlerPromise;
  AGUIRpcHandlerPromise = (async () => {
    const { agent } = await createAgent({ request });
    const templateAgent = "toAGUIAgent" in agent ? agent.toAGUIAgent() : agent;
    templateAgent.clone = agentCloneFn;
    const runtime = new import_runtime.CopilotRuntime({
      agents: {
        default: templateAgent
      },
      ...runtimeOptions || {}
    });
    return (0, import_runtime.copilotRuntimeNodeExpressEndpoint)({
      endpoint: `${basePath}agui`,
      runtime,
      serviceAdapter: new import_runtime.EmptyAdapter(),
      ...endpointOptions || {}
    });
  })();
  return AGUIRpcHandlerPromise;
}
function createAGUIRoute({
  express,
  basePath,
  createAgent,
  runtimeOptions,
  endpointOptions
}) {
  express.post(`${basePath}agui`, import_express.default.json(), async (req, res) => {
    const webRequest = (0, import_server8.normalizeNodeRequest)(req, DefaultFetchAPI);
    const { agent: rawAgent, cleanup } = await createAgent({
      request: webRequest
    });
    const preparedAgent = "toAGUIAgent" in rawAgent ? rawAgent.toAGUIAgent() : rawAgent;
    preparedAgent.clone = agentCloneFn;
    const rpcHandler = await getAGUIRpcHandler({
      createAgent,
      basePath,
      runtimeOptions,
      endpointOptions,
      request: webRequest
    });
    preparedAgentStorage.run(preparedAgent, () => {
      rpcHandler(req, res);
    });
    if (cleanup) {
      res.on("close", cleanup);
    }
  });
}
function isCorsOptions(cors2) {
  return typeof cors2 !== "boolean";
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  agui,
  createExpressRoutes,
  createExpressServer,
  run
});
