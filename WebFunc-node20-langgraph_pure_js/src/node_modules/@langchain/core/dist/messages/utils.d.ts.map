{"version":3,"file":"utils.d.ts","names":["AIMessage","AIMessageChunk","BaseMessageLike","BaseMessage","StoredMessage","ChatMessage","ChatMessageChunk","FunctionMessage","FunctionMessageChunk","HumanMessage","HumanMessageChunk","SystemMessage","SystemMessageChunk","InvalidToolCall","ToolCall","ToolCallChunk","ToolMessage","$Expand","T","U","K","$KnownKeys","$HasIndexSignature","$OnlyIndexSignatures","$MergeObjects","Record","$MergeDiscriminatedUnion","A","B","Key","PropertyKey","Extract","Constructor","iife","coerceMessageLikeToMessage","getBufferString","mapStoredMessageToChatMessage","__message_js0","MessageToolSet","MessageStructure","mapStoredMessagesToChatMessages","mapChatMessagesToStoredMessages","convertToChunk","collapseToolCallChunks"],"sources":["../../src/messages/utils.d.ts"],"sourcesContent":["import { AIMessage, AIMessageChunk } from \"./ai.js\";\nimport { BaseMessageLike, BaseMessage, StoredMessage } from \"./base.js\";\nimport { ChatMessage, ChatMessageChunk } from \"./chat.js\";\nimport { FunctionMessage, FunctionMessageChunk } from \"./function.js\";\nimport { HumanMessage, HumanMessageChunk } from \"./human.js\";\nimport { SystemMessage, SystemMessageChunk } from \"./system.js\";\nimport { InvalidToolCall, ToolCall, ToolCallChunk, ToolMessage } from \"./tool.js\";\nexport type $Expand<T> = T extends infer U ? {\n    [K in keyof U]: U[K];\n} : never;\n/**\n * Extracts the explicitly declared keys from a type T.\n *\n * @template T - The type to extract keys from\n * @returns A union of keys that are not string, number, or symbol\n */\ntype $KnownKeys<T> = {\n    [K in keyof T]: string extends K ? never : number extends K ? never : symbol extends K ? never : K;\n}[keyof T];\n/**\n * Detects if T has an index signature.\n *\n * @template T - The type to check for index signatures\n * @returns True if T has an index signature, false otherwise\n */\ntype $HasIndexSignature<T> = string extends keyof T ? true : number extends keyof T ? true : symbol extends keyof T ? true : false;\n/**\n * Detects if T has an index signature and no known keys.\n *\n * @template T - The type to check for index signatures and no known keys\n * @returns True if T has an index signature and no known keys, false otherwise\n */\ntype $OnlyIndexSignatures<T> = $HasIndexSignature<T> extends true ? [$KnownKeys<T>] extends [never] ? true : false : false;\n/**\n * Recursively merges two object types T and U, with U taking precedence over T.\n *\n * This utility type performs a deep merge of two object types:\n * - For keys that exist in both T and U:\n *   - If both values are objects (Record<string, unknown>), recursively merge them\n *   - Otherwise, U's value takes precedence\n * - For keys that exist only in T, use T's value\n * - For keys that exist only in U, use U's value\n *\n * @template T - The first object type to merge\n * @template U - The second object type to merge (takes precedence over T)\n *\n * @example\n * ```ts\n * type ObjectA = {\n *   shared: { a: string; b: number };\n *   onlyInA: boolean;\n * };\n *\n * type ObjectB = {\n *   shared: { b: string; c: Date };\n *   onlyInB: symbol;\n * };\n *\n * type Merged = $MergeObjects<ObjectA, ObjectB>;\n * // Result: {\n * //   shared: { a: string; b: string; c: Date };\n * //   onlyInA: boolean;\n * //   onlyInB: symbol;\n * // }\n * ```\n */\nexport type $MergeObjects<T, U> = $OnlyIndexSignatures<U> extends true ? U : $OnlyIndexSignatures<T> extends true ? U : {\n    [K in keyof T | keyof U]: K extends keyof T ? K extends keyof U ? T[K] extends Record<string, unknown> ? U[K] extends Record<string, unknown> ? $MergeObjects<T[K], U[K]> : U[K] : U[K] : T[K] : K extends keyof U ? U[K] : never;\n};\n/**\n * Merges two discriminated unions A and B based on a discriminator key (defaults to \"type\").\n * For each possible value of the discriminator across both unions:\n * - If B has a member with that discriminator value, use B's member\n * - Otherwise use A's member with that discriminator value\n * This effectively merges the unions while giving B's members precedence over A's members.\n *\n * @template A - First discriminated union type that extends Record<Key, PropertyKey>\n * @template B - Second discriminated union type that extends Record<Key, PropertyKey>\n * @template Key - The discriminator key property, defaults to \"type\"\n */\nexport type $MergeDiscriminatedUnion<A extends Record<Key, PropertyKey>, B extends Record<Key, PropertyKey>, Key extends PropertyKey = \"type\"> = {\n    [T in A[Key] | B[Key]]: [Extract<B, Record<Key, T>>] extends [never] ? Extract<A, Record<Key, T>> : [\n        Extract<A, Record<Key, T>>\n    ] extends [never] ? Extract<B, Record<Key, T>> : $MergeObjects<Extract<A, Record<Key, T>>, Extract<B, Record<Key, T>>>;\n}[A[Key] | B[Key]];\nexport type Constructor<T> = new (...args: unknown[]) => T;\n/**\n * Immediately-invoked function expression.\n *\n * @param fn - The function to execute\n * @returns The result of the function\n */\nexport declare const iife: <T>(fn: () => T) => T;\nexport declare function coerceMessageLikeToMessage(messageLike: BaseMessageLike): BaseMessage;\n/**\n * This function is used by memory classes to get a string representation\n * of the chat message history, based on the message content and role.\n *\n * Produces compact output like:\n * ```\n * Human: What's the weather?\n * AI: Let me check...[tool_calls]\n * Tool: 72Â°F and sunny\n * ```\n *\n * This avoids token inflation from metadata when stringifying message objects directly.\n */\nexport declare function getBufferString(messages: BaseMessage[], humanPrefix?: string, aiPrefix?: string): string;\nexport declare function mapStoredMessageToChatMessage(message: StoredMessage): AIMessage<import(\"./message.js\").MessageStructure<import(\"./message.js\").MessageToolSet>> | ChatMessage<import(\"./message.js\").MessageStructure<import(\"./message.js\").MessageToolSet>> | FunctionMessage<import(\"./message.js\").MessageStructure<import(\"./message.js\").MessageToolSet>> | HumanMessage<import(\"./message.js\").MessageStructure<import(\"./message.js\").MessageToolSet>> | SystemMessage<import(\"./message.js\").MessageStructure<import(\"./message.js\").MessageToolSet>> | ToolMessage<import(\"./message.js\").MessageStructure<import(\"./message.js\").MessageToolSet>>;\n/**\n * Transforms an array of `StoredMessage` instances into an array of\n * `BaseMessage` instances. It uses the `mapV1MessageToStoredMessage`\n * function to ensure all messages are in the `StoredMessage` format, then\n * creates new instances of the appropriate `BaseMessage` subclass based\n * on the type of each message. This function is used to prepare stored\n * messages for use in a chat context.\n */\nexport declare function mapStoredMessagesToChatMessages(messages: StoredMessage[]): BaseMessage[];\n/**\n * Transforms an array of `BaseMessage` instances into an array of\n * `StoredMessage` instances. It does this by calling the `toDict` method\n * on each `BaseMessage`, which returns a `StoredMessage`. This function\n * is used to prepare chat messages for storage.\n */\nexport declare function mapChatMessagesToStoredMessages(messages: BaseMessage[]): StoredMessage[];\nexport declare function convertToChunk(message: BaseMessage): AIMessageChunk<import(\"./message.js\").MessageStructure<import(\"./message.js\").MessageToolSet>> | ChatMessageChunk<import(\"./message.js\").MessageStructure<import(\"./message.js\").MessageToolSet>> | FunctionMessageChunk<import(\"./message.js\").MessageStructure<import(\"./message.js\").MessageToolSet>> | HumanMessageChunk<import(\"./message.js\").MessageStructure<import(\"./message.js\").MessageToolSet>> | SystemMessageChunk<import(\"./message.js\").MessageStructure<import(\"./message.js\").MessageToolSet>>;\n/**\n * Collapses an array of tool call chunks into complete tool calls.\n *\n * This function groups tool call chunks by their id and/or index, then attempts to\n * parse and validate the accumulated arguments for each group. Successfully parsed\n * tool calls are returned as valid `ToolCall` objects, while malformed ones are\n * returned as `InvalidToolCall` objects.\n *\n * @param chunks - An array of `ToolCallChunk` objects to collapse\n * @returns An object containing:\n *   - `tool_call_chunks`: The original input chunks\n *   - `tool_calls`: An array of successfully parsed and validated tool calls\n *   - `invalid_tool_calls`: An array of tool calls that failed parsing or validation\n *\n * @remarks\n * Chunks are grouped using the following matching logic:\n * - If a chunk has both an id and index, it matches chunks with the same id and index\n * - If a chunk has only an id, it matches chunks with the same id\n * - If a chunk has only an index, it matches chunks with the same index\n *\n * For each group, the function:\n * 1. Concatenates all `args` strings from the chunks\n * 2. Attempts to parse the concatenated string as JSON\n * 3. Validates that the result is a non-null object with a valid id\n * 4. Creates either a `ToolCall` (if valid) or `InvalidToolCall` (if invalid)\n */\nexport declare function collapseToolCallChunks(chunks: ToolCallChunk[]): {\n    tool_call_chunks: ToolCallChunk[];\n    tool_calls: ToolCall[];\n    invalid_tool_calls: InvalidToolCall[];\n};\nexport {};\n//# sourceMappingURL=utils.d.ts.map"],"mappings":"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"}