{"version":3,"file":"base.js","names":["firstContent: MessageContent","secondContent: MessageContent","left?: \"success\" | \"error\"","right?: \"success\" | \"error\"","obj: any","depthLimit: number","currentDepth: number","obj","result: Record<string, unknown>","arg:\n      | $InferMessageContent<TStructure, TRole>\n      | BaseMessageFields<TStructure, TRole>","fields: BaseMessageFields<TStructure, TRole>","blocks: Array<ContentBlock>","blocks","obj: unknown","value: string | undefined","depth: number | null","format: MessageStringFormat","value?: unknown","left: Record<string, any> | undefined","right: Record<string, any> | undefined","left?: Content[]","right?: Content[]","left: T | undefined","right: T | undefined","x: BaseMessageLike","messageLike?: unknown"],"sources":["../../src/messages/base.ts"],"sourcesContent":["import { Serializable, SerializedConstructor } from \"../load/serializable.js\";\nimport { ContentBlock } from \"./content/index.js\";\nimport { isDataContentBlock } from \"./content/data.js\";\nimport { convertToV1FromAnthropicInput } from \"./block_translators/anthropic.js\";\nimport { convertToV1FromDataContent } from \"./block_translators/data.js\";\nimport { convertToV1FromChatCompletionsInput } from \"./block_translators/openai.js\";\nimport {\n  $InferMessageContent,\n  $InferResponseMetadata,\n  MessageStructure,\n  MessageType,\n  isMessage,\n  Message,\n} from \"./message.js\";\nimport {\n  convertToFormattedString,\n  type MessageStringFormat,\n} from \"./format.js\";\n\n/** @internal */\nconst MESSAGE_SYMBOL = Symbol.for(\"langchain.message\");\n\nexport interface StoredMessageData {\n  content: string;\n  role: string | undefined;\n  name: string | undefined;\n  tool_call_id: string | undefined;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  additional_kwargs?: Record<string, any>;\n  /** Response metadata. For example: response headers, logprobs, token counts, model name. */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  response_metadata?: Record<string, any>;\n  id?: string;\n}\n\nexport interface StoredMessage {\n  type: string;\n  data: StoredMessageData;\n}\n\nexport interface StoredGeneration {\n  text: string;\n  message?: StoredMessage;\n}\n\nexport interface StoredMessageV1 {\n  type: string;\n  role: string | undefined;\n  text: string;\n}\n\nexport type MessageContent = string | Array<ContentBlock>;\n\nexport interface FunctionCall {\n  /**\n   * The arguments to call the function with, as generated by the model in JSON\n   * format. Note that the model does not always generate valid JSON, and may\n   * hallucinate parameters not defined by your function schema. Validate the\n   * arguments in your code before calling your function.\n   */\n  arguments: string;\n\n  /**\n   * The name of the function to call.\n   */\n  name: string;\n}\n\nexport type BaseMessageFields<\n  TStructure extends MessageStructure = MessageStructure,\n  TRole extends MessageType = MessageType,\n> = Pick<Message, \"id\" | \"name\"> & {\n  content?: $InferMessageContent<TStructure, TRole>;\n  contentBlocks?: Array<ContentBlock.Standard>;\n  /** @deprecated */\n  additional_kwargs?: {\n    /**\n     * @deprecated Use \"tool_calls\" field on AIMessages instead\n     */\n    function_call?: FunctionCall;\n    /**\n     * @deprecated Use \"tool_calls\" field on AIMessages instead\n     */\n    tool_calls?: OpenAIToolCall[];\n    [key: string]: unknown;\n  };\n  response_metadata?: Partial<$InferResponseMetadata<TStructure, TRole>>;\n};\n\nexport function mergeContent(\n  firstContent: MessageContent,\n  secondContent: MessageContent\n): MessageContent {\n  // If first content is a string\n  if (typeof firstContent === \"string\") {\n    if (firstContent === \"\") {\n      return secondContent;\n    }\n    if (typeof secondContent === \"string\") {\n      return firstContent + secondContent;\n    } else if (Array.isArray(secondContent) && secondContent.length === 0) {\n      return firstContent;\n    } else if (\n      Array.isArray(secondContent) &&\n      secondContent.some((c) => isDataContentBlock(c))\n    ) {\n      return [\n        {\n          type: \"text\",\n          source_type: \"text\",\n          text: firstContent,\n        },\n        ...secondContent,\n      ];\n    } else {\n      return [{ type: \"text\", text: firstContent }, ...secondContent];\n    }\n    // If both are arrays\n  } else if (Array.isArray(secondContent)) {\n    return (\n      _mergeLists(firstContent, secondContent) ?? [\n        ...firstContent,\n        ...secondContent,\n      ]\n    );\n  } else {\n    if (secondContent === \"\") {\n      return firstContent;\n    } else if (\n      Array.isArray(firstContent) &&\n      firstContent.some((c) => isDataContentBlock(c))\n    ) {\n      return [\n        ...firstContent,\n        {\n          type: \"file\",\n          source_type: \"text\",\n          text: secondContent,\n        },\n      ];\n    } else {\n      return [...firstContent, { type: \"text\", text: secondContent }];\n    }\n  }\n}\n\n/**\n * 'Merge' two statuses. If either value passed is 'error', it will return 'error'. Else\n * it will return 'success'.\n *\n * @param {\"success\" | \"error\" | undefined} left The existing value to 'merge' with the new value.\n * @param {\"success\" | \"error\" | undefined} right The new value to 'merge' with the existing value\n * @returns {\"success\" | \"error\"} The 'merged' value.\n */\nexport function _mergeStatus(\n  left?: \"success\" | \"error\",\n  right?: \"success\" | \"error\"\n): \"success\" | \"error\" | undefined {\n  if (left === \"error\" || right === \"error\") {\n    return \"error\";\n  }\n  return \"success\";\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction stringifyWithDepthLimit(obj: any, depthLimit: number): string {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function helper(obj: any, currentDepth: number): any {\n    if (typeof obj !== \"object\" || obj === null || obj === undefined) {\n      return obj;\n    }\n    if (currentDepth >= depthLimit) {\n      if (Array.isArray(obj)) {\n        return \"[Array]\";\n      }\n      return \"[Object]\";\n    }\n\n    if (Array.isArray(obj)) {\n      return obj.map((item) => helper(item, currentDepth + 1));\n    }\n\n    const result: Record<string, unknown> = {};\n    for (const key of Object.keys(obj)) {\n      result[key] = helper(obj[key], currentDepth + 1);\n    }\n    return result;\n  }\n\n  return JSON.stringify(helper(obj, 0), null, 2);\n}\n\n/**\n * Base class for all types of messages in a conversation. It includes\n * properties like `content`, `name`, and `additional_kwargs`. It also\n * includes methods like `toDict()` and `_getType()`.\n */\nexport abstract class BaseMessage<\n    TStructure extends MessageStructure = MessageStructure,\n    TRole extends MessageType = MessageType,\n  >\n  extends Serializable\n  implements Message<TStructure, TRole>\n{\n  lc_namespace = [\"langchain_core\", \"messages\"];\n\n  lc_serializable = true;\n\n  get lc_aliases(): Record<string, string> {\n    // exclude snake case conversion to pascal case\n    return {\n      additional_kwargs: \"additional_kwargs\",\n      response_metadata: \"response_metadata\",\n    };\n  }\n\n  readonly [MESSAGE_SYMBOL] = true as const;\n\n  abstract readonly type: TRole;\n\n  id?: string;\n\n  /** @inheritdoc */\n  name?: string;\n\n  content: $InferMessageContent<TStructure, TRole>;\n\n  additional_kwargs: NonNullable<\n    BaseMessageFields<TStructure, TRole>[\"additional_kwargs\"]\n  >;\n\n  response_metadata: NonNullable<\n    BaseMessageFields<TStructure, TRole>[\"response_metadata\"]\n  >;\n\n  /**\n   * @deprecated Use .getType() instead or import the proper typeguard.\n   * For example:\n   *\n   * ```ts\n   * import { isAIMessage } from \"@langchain/core/messages\";\n   *\n   * const message = new AIMessage(\"Hello!\");\n   * isAIMessage(message); // true\n   * ```\n   */\n  _getType(): MessageType {\n    return this.type;\n  }\n\n  /**\n   * @deprecated Use .type instead\n   * The type of the message.\n   */\n  getType(): MessageType {\n    return this._getType();\n  }\n\n  constructor(\n    arg:\n      | $InferMessageContent<TStructure, TRole>\n      | BaseMessageFields<TStructure, TRole>\n  ) {\n    const fields: BaseMessageFields<TStructure, TRole> =\n      typeof arg === \"string\" || Array.isArray(arg)\n        ? ({ content: arg } as BaseMessageFields<TStructure, TRole>)\n        : arg;\n    if (!fields.additional_kwargs) {\n      fields.additional_kwargs = {};\n    }\n    if (!fields.response_metadata) {\n      fields.response_metadata = {};\n    }\n    super(fields);\n    this.name = fields.name;\n    if (fields.content === undefined && fields.contentBlocks !== undefined) {\n      this.content = fields.contentBlocks as $InferMessageContent<\n        TStructure,\n        TRole\n      >;\n      this.response_metadata = {\n        output_version: \"v1\",\n        ...fields.response_metadata,\n      };\n    } else if (fields.content !== undefined) {\n      this.content = fields.content ?? [];\n      this.response_metadata = fields.response_metadata;\n    } else {\n      this.content = [] as $InferMessageContent<TStructure, TRole>;\n      this.response_metadata = fields.response_metadata;\n    }\n    this.additional_kwargs = fields.additional_kwargs;\n    this.id = fields.id;\n  }\n\n  /** Get text content of the message. */\n  get text(): string {\n    if (typeof this.content === \"string\") {\n      return this.content;\n    }\n    if (!Array.isArray(this.content)) return \"\";\n    return this.content\n      .map((c) => {\n        if (typeof c === \"string\") return c;\n        if (c.type === \"text\") return c.text;\n        return \"\";\n      })\n      .join(\"\");\n  }\n\n  get contentBlocks(): Array<ContentBlock.Standard> {\n    const blocks: Array<ContentBlock> =\n      typeof this.content === \"string\"\n        ? [{ type: \"text\", text: this.content }]\n        : this.content;\n    const parsingSteps = [\n      convertToV1FromDataContent,\n      convertToV1FromChatCompletionsInput,\n      convertToV1FromAnthropicInput,\n    ];\n    const parsedBlocks = parsingSteps.reduce(\n      (blocks, step) => step(blocks),\n      blocks\n    );\n    return parsedBlocks as Array<ContentBlock.Standard>;\n  }\n\n  toDict(): StoredMessage {\n    return {\n      type: this.getType(),\n      data: (this.toJSON() as SerializedConstructor)\n        .kwargs as StoredMessageData,\n    };\n  }\n\n  static lc_name() {\n    return \"BaseMessage\";\n  }\n\n  // Can't be protected for silly reasons\n  get _printableFields(): Record<string, unknown> {\n    return {\n      id: this.id,\n      content: this.content,\n      name: this.name,\n      additional_kwargs: this.additional_kwargs,\n      response_metadata: this.response_metadata,\n    };\n  }\n\n  static isInstance(obj: unknown): obj is BaseMessage {\n    return (\n      typeof obj === \"object\" &&\n      obj !== null &&\n      MESSAGE_SYMBOL in obj &&\n      obj[MESSAGE_SYMBOL] === true &&\n      isMessage(obj)\n    );\n  }\n\n  // this private method is used to update the ID for the runtime\n  // value as well as in lc_kwargs for serialisation\n  _updateId(value: string | undefined) {\n    this.id = value;\n\n    // lc_attributes wouldn't work here, because jest compares the\n    // whole object\n    this.lc_kwargs.id = value;\n  }\n\n  get [Symbol.toStringTag]() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return (this.constructor as any).lc_name();\n  }\n\n  // Override the default behavior of console.log\n  [Symbol.for(\"nodejs.util.inspect.custom\")](depth: number | null) {\n    if (depth === null) {\n      return this;\n    }\n    const printable = stringifyWithDepthLimit(\n      this._printableFields,\n      Math.max(4, depth)\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return `${(this.constructor as any).lc_name()} ${printable}`;\n  }\n\n  toFormattedString(format: MessageStringFormat = \"pretty\"): string {\n    return convertToFormattedString(this, format);\n  }\n}\n\n/**\n * @deprecated Use \"tool_calls\" field on AIMessages instead\n */\nexport type OpenAIToolCall = {\n  /**\n   * The ID of the tool call.\n   */\n  id: string;\n\n  /**\n   * The function that the model called.\n   */\n  function: FunctionCall;\n\n  /**\n   * The type of the tool. Currently, only `function` is supported.\n   */\n  type: \"function\";\n\n  index?: number;\n};\n\nexport function isOpenAIToolCallArray(\n  value?: unknown\n): value is OpenAIToolCall[] {\n  return (\n    Array.isArray(value) &&\n    value.every((v) => typeof (v as OpenAIToolCall).index === \"number\")\n  );\n}\n\nexport function _mergeDicts(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  left: Record<string, any> | undefined,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  right: Record<string, any> | undefined\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n): Record<string, any> | undefined {\n  if (left === undefined && right === undefined) {\n    return undefined;\n  }\n  if (left === undefined || right === undefined) {\n    return left ?? right;\n  }\n  const merged = { ...left };\n  for (const [key, value] of Object.entries(right)) {\n    if (merged[key] == null) {\n      merged[key] = value;\n    } else if (value == null) {\n      continue;\n    } else if (\n      typeof merged[key] !== typeof value ||\n      Array.isArray(merged[key]) !== Array.isArray(value)\n    ) {\n      throw new Error(\n        `field[${key}] already exists in the message chunk, but with a different type.`\n      );\n    } else if (typeof merged[key] === \"string\") {\n      if (key === \"type\") {\n        // Do not merge 'type' fields\n        continue;\n      } else if (\n        [\"id\", \"name\", \"output_version\", \"model_provider\"].includes(key)\n      ) {\n        // Keep the incoming value for these fields if its defined\n        if (value) {\n          merged[key] = value;\n        }\n      } else {\n        merged[key] += value;\n      }\n    } else if (typeof merged[key] === \"number\") {\n      merged[key] = merged[key] + value;\n    } else if (typeof merged[key] === \"object\" && !Array.isArray(merged[key])) {\n      merged[key] = _mergeDicts(merged[key], value);\n    } else if (Array.isArray(merged[key])) {\n      merged[key] = _mergeLists(merged[key], value);\n    } else if (merged[key] === value) {\n      continue;\n    } else {\n      console.warn(\n        `field[${key}] already exists in this message chunk and value has unsupported type.`\n      );\n    }\n  }\n  return merged;\n}\n\nexport function _mergeLists<Content extends ContentBlock>(\n  left?: Content[],\n  right?: Content[]\n): Content[] | undefined {\n  if (left === undefined && right === undefined) {\n    return undefined;\n  } else if (left === undefined || right === undefined) {\n    return left || right;\n  } else {\n    const merged = [...left];\n    for (const item of right) {\n      if (\n        typeof item === \"object\" &&\n        item !== null &&\n        \"index\" in item &&\n        typeof item.index === \"number\"\n      ) {\n        const toMerge = merged.findIndex((leftItem) => {\n          const isObject = typeof leftItem === \"object\";\n          const indiciesMatch =\n            \"index\" in leftItem && leftItem.index === item.index;\n          const idsMatch =\n            \"id\" in leftItem && \"id\" in item && leftItem?.id === item?.id;\n          const eitherItemMissingID =\n            !(\"id\" in leftItem) ||\n            !leftItem?.id ||\n            !(\"id\" in item) ||\n            !item?.id;\n          return isObject && indiciesMatch && (idsMatch || eitherItemMissingID);\n        });\n        if (\n          toMerge !== -1 &&\n          typeof merged[toMerge] === \"object\" &&\n          merged[toMerge] !== null\n        ) {\n          merged[toMerge] = _mergeDicts(\n            merged[toMerge] as Record<string, unknown>,\n            item as Record<string, unknown>\n          ) as Content;\n        } else {\n          merged.push(item);\n        }\n      } else if (\n        typeof item === \"object\" &&\n        item !== null &&\n        \"text\" in item &&\n        item.text === \"\"\n      ) {\n        // No-op - skip empty text blocks\n        continue;\n      } else {\n        merged.push(item);\n      }\n    }\n    return merged;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _mergeObj<T = any>(\n  left: T | undefined,\n  right: T | undefined\n): T | undefined {\n  if (left === undefined && right === undefined) {\n    return undefined;\n  }\n  if (left === undefined || right === undefined) {\n    return left ?? right;\n  } else if (typeof left !== typeof right) {\n    throw new Error(\n      `Cannot merge objects of different types.\\nLeft ${typeof left}\\nRight ${typeof right}`\n    );\n  } else if (typeof left === \"string\" && typeof right === \"string\") {\n    return (left + right) as T;\n  } else if (Array.isArray(left) && Array.isArray(right)) {\n    return _mergeLists(left, right) as T;\n  } else if (typeof left === \"object\" && typeof right === \"object\") {\n    return _mergeDicts(\n      left as Record<string, unknown>,\n      right as Record<string, unknown>\n    ) as T;\n  } else if (left === right) {\n    return left;\n  } else {\n    throw new Error(\n      `Can not merge objects of different types.\\nLeft ${left}\\nRight ${right}`\n    );\n  }\n}\n\n/**\n * Represents a chunk of a message, which can be concatenated with other\n * message chunks. It includes a method `_merge_kwargs_dict()` for merging\n * additional keyword arguments from another `BaseMessageChunk` into this\n * one. It also overrides the `__add__()` method to support concatenation\n * of `BaseMessageChunk` instances.\n */\nexport abstract class BaseMessageChunk<\n  TStructure extends MessageStructure = MessageStructure,\n  TRole extends MessageType = MessageType,\n> extends BaseMessage<TStructure, TRole> {\n  abstract concat(chunk: BaseMessageChunk): BaseMessageChunk<TStructure, TRole>;\n\n  static isInstance(obj: unknown): obj is BaseMessageChunk {\n    if (!super.isInstance(obj)) {\n      return false;\n    }\n    // Check if obj is an instance of BaseMessageChunk by traversing the prototype chain\n    let proto = Object.getPrototypeOf(obj);\n    while (proto !== null) {\n      if (proto === BaseMessageChunk.prototype) {\n        return true;\n      }\n      proto = Object.getPrototypeOf(proto);\n    }\n    return false;\n  }\n}\n\nexport type MessageFieldWithRole = {\n  role: MessageType;\n  content: MessageContent;\n  name?: string;\n} & Record<string, unknown>;\n\nexport function _isMessageFieldWithRole(\n  x: BaseMessageLike\n): x is MessageFieldWithRole {\n  return typeof (x as MessageFieldWithRole).role === \"string\";\n}\n\nexport type BaseMessageLike =\n  | BaseMessage\n  | MessageFieldWithRole\n  | [MessageType, MessageContent]\n  | string\n  /**\n   * @deprecated Specifying \"type\" is deprecated and will be removed in 0.4.0.\n   */\n  | ({\n      type: MessageType | \"user\" | \"assistant\" | \"placeholder\";\n    } & BaseMessageFields &\n      Record<string, unknown>)\n  | SerializedConstructor;\n\n/**\n * @deprecated Use {@link BaseMessage.isInstance} instead\n */\nexport function isBaseMessage(\n  messageLike?: unknown\n): messageLike is BaseMessage {\n  return typeof (messageLike as BaseMessage)?._getType === \"function\";\n}\n\n/**\n * @deprecated Use {@link BaseMessageChunk.isInstance} instead\n */\nexport function isBaseMessageChunk(\n  messageLike?: unknown\n): messageLike is BaseMessageChunk {\n  return BaseMessageChunk.isInstance(messageLike);\n}\n"],"mappings":"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"}