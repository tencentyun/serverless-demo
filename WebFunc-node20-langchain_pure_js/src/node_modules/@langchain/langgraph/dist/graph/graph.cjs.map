{"version":3,"file":"graph.cjs","names":["Runnable","ChannelWrite","RunnableCallable","NodeInterrupt","_isSend","END","InvalidUpdateError","args","CHECKPOINT_NAMESPACE_SEPARATOR","CHECKPOINT_NAMESPACE_END","isPregelLike","START","EphemeralValue","name","UnreachableNodeError","Pregel","PregelNode","PASSTHROUGH","TAG_HIDDEN","Channel","DrawableGraph","z","gatherIterator","gatherIteratorSync"],"sources":["../../src/graph/graph.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\nimport {\n  _coerceToRunnable,\n  Runnable,\n  RunnableConfig,\n  RunnableInterface,\n  RunnableIOSchema,\n  type RunnableLike as LangChainRunnableLike,\n} from \"@langchain/core/runnables\";\nimport {\n  Node as DrawableGraphNode,\n  Graph as DrawableGraph,\n} from \"@langchain/core/runnables/graph\";\nimport { All, BaseCheckpointSaver } from \"@langchain/langgraph-checkpoint\";\nimport { z } from \"zod/v4\";\nimport { validate as isUuid } from \"uuid\";\nimport type {\n  RunnableLike,\n  LangGraphRunnableConfig,\n} from \"../pregel/runnable_types.js\";\nimport { PregelNode } from \"../pregel/read.js\";\nimport { Channel, Pregel } from \"../pregel/index.js\";\nimport type { PregelParams } from \"../pregel/types.js\";\nimport { BaseChannel } from \"../channels/base.js\";\nimport { EphemeralValue } from \"../channels/ephemeral_value.js\";\nimport { ChannelWrite, PASSTHROUGH } from \"../pregel/write.js\";\nimport {\n  _isSend,\n  CHECKPOINT_NAMESPACE_END,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  END,\n  Send,\n  START,\n  TAG_HIDDEN,\n} from \"../constants.js\";\nimport {\n  gatherIterator,\n  gatherIteratorSync,\n  RunnableCallable,\n} from \"../utils.js\";\nimport {\n  InvalidUpdateError,\n  NodeInterrupt,\n  UnreachableNodeError,\n} from \"../errors.js\";\nimport { StateDefinition, StateType } from \"./annotation.js\";\nimport { isPregelLike } from \"../pregel/utils/subgraph.js\";\n\nexport interface BranchOptions<\n  IO,\n  N extends string,\n  CallOptions extends LangGraphRunnableConfig = LangGraphRunnableConfig\n> {\n  source: N;\n  path: RunnableLike<IO, BranchPathReturnValue, CallOptions>;\n  pathMap?: Record<string, N | typeof END> | (N | typeof END)[];\n}\n\nexport type BranchPathReturnValue =\n  | string\n  | Send\n  | (string | Send)[]\n  | Promise<string | Send | (string | Send)[]>;\n\ntype NodeAction<S, U, C extends StateDefinition> = RunnableLike<\n  S,\n  U extends object ? U & Record<string, any> : U, // eslint-disable-line @typescript-eslint/no-explicit-any\n  LangGraphRunnableConfig<StateType<C>>\n>;\n\nexport class Branch<\n  IO,\n  N extends string,\n  CallOptions extends LangGraphRunnableConfig = LangGraphRunnableConfig\n> {\n  path: Runnable<IO, BranchPathReturnValue, CallOptions>;\n\n  ends?: Record<string, N | typeof END>;\n\n  constructor(options: Omit<BranchOptions<IO, N, CallOptions>, \"source\">) {\n    if (Runnable.isRunnable(options.path)) {\n      this.path = options.path as Runnable<\n        IO,\n        BranchPathReturnValue,\n        CallOptions\n      >;\n    } else {\n      this.path = _coerceToRunnable(\n        options.path as LangChainRunnableLike<\n          IO,\n          BranchPathReturnValue,\n          CallOptions\n        >\n      ).withConfig({ runName: `Branch` } as CallOptions);\n    }\n    this.ends = Array.isArray(options.pathMap)\n      ? options.pathMap.reduce((acc, n) => {\n          acc[n] = n;\n          return acc;\n        }, {} as Record<string, N | typeof END>)\n      : options.pathMap;\n  }\n\n  run(\n    writer: (\n      dests: (string | Send)[],\n      config: LangGraphRunnableConfig\n    ) => Runnable | void | Promise<void>,\n    reader?: (config: CallOptions) => IO\n  ) {\n    return ChannelWrite.registerWriter(\n      new RunnableCallable({\n        name: \"<branch_run>\",\n        trace: false,\n        func: async (input: IO, config: CallOptions) => {\n          try {\n            return await this._route(input, config, writer, reader);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          } catch (e: any) {\n            // Detect & warn if NodeInterrupt is thrown in a conditional edge\n            if (e.name === NodeInterrupt.unminifiable_name) {\n              console.warn(\n                \"[WARN]: 'NodeInterrupt' thrown in conditional edge. This is likely a bug in your graph implementation.\\n\" +\n                  \"NodeInterrupt should only be thrown inside a node, not in edge conditions.\"\n              );\n            }\n            throw e;\n          }\n        },\n      })\n    );\n  }\n\n  async _route(\n    input: IO,\n    config: CallOptions,\n    writer: (\n      dests: (string | Send)[],\n      config: LangGraphRunnableConfig\n    ) => Runnable | void | Promise<void>,\n    reader?: (config: CallOptions) => IO\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<Runnable | any> {\n    let result = await this.path.invoke(\n      reader ? reader(config) : input,\n      config\n    );\n    if (!Array.isArray(result)) {\n      result = [result];\n    }\n\n    let destinations: (string | Send)[];\n    if (this.ends) {\n      destinations = result.map((r) => (_isSend(r) ? r : this.ends![r]));\n    } else {\n      destinations = result;\n    }\n    if (destinations.some((dest) => !dest)) {\n      throw new Error(\"Branch condition returned unknown or null destination\");\n    }\n    if (destinations.filter(_isSend).some((packet) => packet.node === END)) {\n      throw new InvalidUpdateError(\"Cannot send a packet to the END node\");\n    }\n    const writeResult = await writer(destinations, config);\n    return writeResult ?? input;\n  }\n}\n\nexport type NodeSpec<RunInput, RunOutput> = {\n  runnable: Runnable<RunInput, RunOutput>;\n  metadata?: Record<string, unknown>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  subgraphs?: Pregel<any, any>[];\n  ends?: string[];\n  defer?: boolean;\n};\n\nexport type AddNodeOptions<Nodes extends string = string> = {\n  metadata?: Record<string, unknown>;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  subgraphs?: Pregel<any, any>[];\n  ends?: Nodes[];\n  defer?: boolean;\n};\n\nexport class Graph<\n  N extends string = typeof START | typeof END,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunInput = any,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  RunOutput = any,\n  NodeSpecType extends NodeSpec<RunInput, RunOutput> = NodeSpec<\n    RunInput,\n    RunOutput\n  >,\n  C extends StateDefinition = StateDefinition\n> {\n  nodes: Record<N, NodeSpecType>;\n\n  edges: Set<[N | typeof START, N | typeof END]>;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  branches: Record<string, Record<string, Branch<RunInput, N, any>>>;\n\n  entryPoint?: string;\n\n  compiled = false;\n\n  constructor() {\n    this.nodes = {} as Record<N, NodeSpecType>;\n    this.edges = new Set();\n    this.branches = {};\n  }\n\n  protected warnIfCompiled(message: string): void {\n    if (this.compiled) {\n      console.warn(message);\n    }\n  }\n\n  get allEdges(): Set<[string, string]> {\n    return this.edges;\n  }\n\n  addNode<K extends string, NodeInput = RunInput, NodeOutput = RunOutput>(\n    nodes:\n      | Record<K, NodeAction<NodeInput, NodeOutput, C>>\n      | [\n          key: K,\n          action: NodeAction<NodeInput, NodeOutput, C>,\n          options?: AddNodeOptions\n        ][]\n  ): Graph<N | K, RunInput, RunOutput>;\n\n  addNode<K extends string, NodeInput = RunInput, NodeOutput = RunOutput>(\n    key: K,\n    action: NodeAction<NodeInput, NodeOutput, C>,\n    options?: AddNodeOptions\n  ): Graph<N | K, RunInput, RunOutput>;\n\n  addNode<K extends string, NodeInput = RunInput, NodeOutput = RunOutput>(\n    ...args:\n      | [\n          key: K,\n          action: NodeAction<NodeInput, NodeOutput, C>,\n          options?: AddNodeOptions\n        ]\n      | [\n          nodes:\n            | Record<K, NodeAction<NodeInput, NodeOutput, C>>\n            | [\n                key: K,\n                action: NodeAction<NodeInput, NodeOutput, C>,\n                options?: AddNodeOptions\n              ][]\n        ]\n  ): Graph<N | K, RunInput, RunOutput> {\n    function isMutlipleNodes(\n      args: unknown[]\n    ): args is [\n      nodes:\n        | Record<K, NodeAction<NodeInput, RunOutput, C>>\n        | [\n            key: K,\n            action: NodeAction<NodeInput, RunOutput, C>,\n            options?: AddNodeOptions\n          ][],\n      options?: AddNodeOptions\n    ] {\n      return args.length >= 1 && typeof args[0] !== \"string\";\n    }\n\n    const nodes = (\n      isMutlipleNodes(args) // eslint-disable-line no-nested-ternary\n        ? Array.isArray(args[0])\n          ? args[0]\n          : Object.entries(args[0])\n        : [[args[0], args[1], args[2]]]\n    ) as [K, NodeAction<NodeInput, RunOutput, C>, AddNodeOptions][];\n\n    if (nodes.length === 0) {\n      throw new Error(\"No nodes provided in `addNode`\");\n    }\n\n    for (const [key, action, options] of nodes) {\n      for (const reservedChar of [\n        CHECKPOINT_NAMESPACE_SEPARATOR,\n        CHECKPOINT_NAMESPACE_END,\n      ]) {\n        if (key.includes(reservedChar)) {\n          throw new Error(\n            `\"${reservedChar}\" is a reserved character and is not allowed in node names.`\n          );\n        }\n      }\n      this.warnIfCompiled(\n        `Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`\n      );\n\n      if (key in this.nodes) {\n        throw new Error(`Node \\`${key}\\` already present.`);\n      }\n      if (key === END) {\n        throw new Error(`Node \\`${key}\\` is reserved.`);\n      }\n\n      const runnable = _coerceToRunnable<RunInput, RunOutput>(\n        // Account for arbitrary state due to Send API\n        action as RunnableLike<RunInput, RunOutput>\n      );\n\n      this.nodes[key as unknown as N] = {\n        runnable,\n        metadata: options?.metadata,\n        subgraphs: isPregelLike(runnable) ? [runnable] : options?.subgraphs,\n        ends: options?.ends,\n      } as NodeSpecType;\n    }\n\n    return this as Graph<N | K, RunInput, RunOutput, NodeSpecType>;\n  }\n\n  addEdge(startKey: N | typeof START, endKey: N | typeof END): this {\n    this.warnIfCompiled(\n      `Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.`\n    );\n\n    if (startKey === END) {\n      throw new Error(\"END cannot be a start node\");\n    }\n    if (endKey === START) {\n      throw new Error(\"START cannot be an end node\");\n    }\n    if (\n      Array.from(this.edges).some(([start]) => start === startKey) &&\n      !(\"channels\" in this)\n    ) {\n      throw new Error(\n        `Already found path for ${startKey}. For multiple edges, use StateGraph.`\n      );\n    }\n\n    this.edges.add([startKey, endKey]);\n\n    return this;\n  }\n\n  addConditionalEdges(\n    source: BranchOptions<RunInput, N, LangGraphRunnableConfig<StateType<C>>>\n  ): this;\n\n  addConditionalEdges(\n    source: N,\n    path: RunnableLike<\n      RunInput,\n      BranchPathReturnValue,\n      LangGraphRunnableConfig<StateType<C>>\n    >,\n    pathMap?: BranchOptions<\n      RunInput,\n      N,\n      LangGraphRunnableConfig<StateType<C>>\n    >[\"pathMap\"]\n  ): this;\n\n  addConditionalEdges(\n    source:\n      | N\n      | BranchOptions<RunInput, N, LangGraphRunnableConfig<StateType<C>>>,\n    path?: RunnableLike<\n      RunInput,\n      BranchPathReturnValue,\n      LangGraphRunnableConfig<StateType<C>>\n    >,\n    pathMap?: BranchOptions<\n      RunInput,\n      N,\n      LangGraphRunnableConfig<StateType<C>>\n    >[\"pathMap\"]\n  ): this {\n    const options: BranchOptions<\n      RunInput,\n      N,\n      LangGraphRunnableConfig<StateType<C>>\n    > = typeof source === \"object\" ? source : { source, path: path!, pathMap };\n\n    this.warnIfCompiled(\n      \"Adding an edge to a graph that has already been compiled. This will not be reflected in the compiled graph.\"\n    );\n    if (!Runnable.isRunnable(options.path)) {\n      const pathDisplayValues = Array.isArray(options.pathMap)\n        ? options.pathMap.join(\",\")\n        : Object.keys(options.pathMap ?? {}).join(\",\");\n      options.path = _coerceToRunnable(\n        options.path as LangChainRunnableLike<\n          RunInput,\n          BranchPathReturnValue,\n          LangGraphRunnableConfig<StateType<C>>\n        >\n      ).withConfig({\n        runName: `Branch<${options.source}${\n          pathDisplayValues !== \"\" ? `,${pathDisplayValues}` : \"\"\n        }>`.slice(0, 63),\n      });\n    }\n    // find a name for condition\n    const name =\n      options.path.getName() === \"RunnableLambda\"\n        ? \"condition\"\n        : options.path.getName();\n    // validate condition\n    if (this.branches[options.source] && this.branches[options.source][name]) {\n      throw new Error(\n        `Condition \\`${name}\\` already present for node \\`${source}\\``\n      );\n    }\n    // save it\n    this.branches[options.source] ??= {};\n    this.branches[options.source][name] = new Branch(options);\n    return this;\n  }\n\n  /**\n   * @deprecated use `addEdge(START, key)` instead\n   */\n  setEntryPoint(key: N): this {\n    this.warnIfCompiled(\n      \"Setting the entry point of a graph that has already been compiled. This will not be reflected in the compiled graph.\"\n    );\n\n    return this.addEdge(START, key);\n  }\n\n  /**\n   * @deprecated use `addEdge(key, END)` instead\n   */\n  setFinishPoint(key: N): this {\n    this.warnIfCompiled(\n      \"Setting a finish point of a graph that has already been compiled. This will not be reflected in the compiled graph.\"\n    );\n\n    return this.addEdge(key, END);\n  }\n\n  compile({\n    checkpointer,\n    interruptBefore,\n    interruptAfter,\n    name,\n  }: {\n    checkpointer?: BaseCheckpointSaver | false;\n    interruptBefore?: N[] | All;\n    interruptAfter?: N[] | All;\n    name?: string;\n  } = {}): CompiledGraph<N> {\n    // validate the graph\n    this.validate([\n      ...(Array.isArray(interruptBefore) ? interruptBefore : []),\n      ...(Array.isArray(interruptAfter) ? interruptAfter : []),\n    ]);\n\n    // create empty compiled graph\n    const compiled = new CompiledGraph({\n      builder: this,\n      checkpointer,\n      interruptAfter,\n      interruptBefore,\n      autoValidate: false,\n      nodes: {} as Record<N | typeof START, PregelNode<RunInput, RunOutput>>,\n      channels: {\n        [START]: new EphemeralValue(),\n        [END]: new EphemeralValue(),\n      } as Record<N | typeof START | typeof END | string, BaseChannel>,\n      inputChannels: START,\n      outputChannels: END,\n      streamChannels: [] as N[],\n      streamMode: \"values\",\n      name,\n    });\n\n    // attach nodes, edges and branches\n    for (const [key, node] of Object.entries<NodeSpec<RunInput, RunOutput>>(\n      this.nodes\n    )) {\n      compiled.attachNode(key as N, node);\n    }\n    for (const [start, end] of this.edges) {\n      compiled.attachEdge(start, end);\n    }\n    for (const [start, branches] of Object.entries(this.branches)) {\n      for (const [name, branch] of Object.entries(branches)) {\n        compiled.attachBranch(start as N, name, branch);\n      }\n    }\n\n    return compiled.validate();\n  }\n\n  validate(interrupt?: string[]): void {\n    // assemble sources\n    const allSources = new Set([...this.allEdges].map(([src, _]) => src));\n    for (const [start] of Object.entries(this.branches)) {\n      allSources.add(start);\n    }\n\n    // validate sources\n    for (const source of allSources) {\n      if (source !== START && !(source in this.nodes)) {\n        throw new Error(`Found edge starting at unknown node \\`${source}\\``);\n      }\n    }\n\n    // assemble targets\n    const allTargets = new Set([...this.allEdges].map(([_, target]) => target));\n    for (const [start, branches] of Object.entries(this.branches)) {\n      for (const branch of Object.values(branches)) {\n        if (branch.ends != null) {\n          for (const end of Object.values(branch.ends)) {\n            allTargets.add(end);\n          }\n        } else {\n          allTargets.add(END);\n          for (const node of Object.keys(this.nodes)) {\n            if (node !== start) {\n              allTargets.add(node);\n            }\n          }\n        }\n      }\n    }\n    for (const node of Object.values<NodeSpecType>(this.nodes)) {\n      for (const target of node.ends ?? []) {\n        allTargets.add(target);\n      }\n    }\n    // validate targets\n    for (const node of Object.keys(this.nodes)) {\n      if (!allTargets.has(node)) {\n        throw new UnreachableNodeError(\n          [\n            `Node \\`${node}\\` is not reachable.`,\n            \"\",\n            \"If you are returning Command objects from your node,\",\n            'make sure you are passing names of potential destination nodes as an \"ends\" array',\n            'into \".addNode(..., { ends: [\"node1\", \"node2\"] })\".',\n          ].join(\"\\n\"),\n          {\n            lc_error_code: \"UNREACHABLE_NODE\",\n          }\n        );\n      }\n    }\n    for (const target of allTargets) {\n      if (target !== END && !(target in this.nodes)) {\n        throw new Error(`Found edge ending at unknown node \\`${target}\\``);\n      }\n    }\n\n    // validate interrupts\n    if (interrupt) {\n      for (const node of interrupt) {\n        if (!(node in this.nodes)) {\n          throw new Error(`Interrupt node \\`${node}\\` is not present`);\n        }\n      }\n    }\n\n    this.compiled = true;\n  }\n}\n\nexport class CompiledGraph<\n  N extends string,\n  State = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n  Update = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n  ContextType extends Record<string, any> = Record<string, any>, // eslint-disable-line @typescript-eslint/no-explicit-any\n  InputType = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n  OutputType = any, // eslint-disable-line @typescript-eslint/no-explicit-any\n  NodeReturnType = unknown,\n  CommandType = unknown,\n  StreamCustomType = any // eslint-disable-line @typescript-eslint/no-explicit-any\n> extends Pregel<\n  Record<N | typeof START, PregelNode<State, Update>>,\n  Record<N | typeof START | typeof END | string, BaseChannel>,\n  ContextType & Record<string, any>, // eslint-disable-line @typescript-eslint/no-explicit-any\n  InputType,\n  OutputType,\n  InputType,\n  OutputType,\n  NodeReturnType,\n  CommandType,\n  StreamCustomType\n> {\n  declare \"~NodeType\": N;\n\n  declare \"~NodeReturnType\": NodeReturnType;\n\n  declare \"~RunInput\": Update;\n\n  declare \"~RunOutput\": State;\n\n  builder: Graph<N, State, Update>;\n\n  constructor({\n    builder,\n    ...rest\n  }: { builder: Graph<N, State, Update> } & PregelParams<\n    Record<N | typeof START, PregelNode<State, Update>>,\n    Record<N | typeof START | typeof END | string, BaseChannel>\n  >) {\n    super(rest);\n    this.builder = builder;\n  }\n\n  attachNode(key: N, node: NodeSpec<State, Update>): void {\n    this.channels[key] = new EphemeralValue();\n    this.nodes[key] = new PregelNode({\n      channels: [],\n      triggers: [],\n      metadata: node.metadata,\n      subgraphs: node.subgraphs,\n      ends: node.ends,\n    })\n      .pipe(node.runnable)\n      .pipe(\n        new ChannelWrite([{ channel: key, value: PASSTHROUGH }], [TAG_HIDDEN])\n      );\n    (this.streamChannels as N[]).push(key);\n  }\n\n  attachEdge(start: N | typeof START, end: N | typeof END): void {\n    if (end === END) {\n      if (start === START) {\n        throw new Error(\"Cannot have an edge from START to END\");\n      }\n      this.nodes[start].writers.push(\n        new ChannelWrite([{ channel: END, value: PASSTHROUGH }], [TAG_HIDDEN])\n      );\n    } else {\n      this.nodes[end].triggers.push(start);\n      (this.nodes[end].channels as string[]).push(start);\n    }\n  }\n\n  attachBranch(\n    start: N | typeof START,\n    name: string,\n    branch: Branch<State, N>\n  ) {\n    // add hidden start node\n    if (start === START && !this.nodes[START]) {\n      this.nodes[START] = Channel.subscribeTo(START, { tags: [TAG_HIDDEN] });\n    }\n\n    // attach branch writer\n    this.nodes[start].pipe(\n      branch.run((dests) => {\n        const writes = dests.map((dest) => {\n          if (_isSend(dest)) {\n            return dest;\n          }\n          return {\n            channel: dest === END ? END : `branch:${start}:${name}:${dest}`,\n            value: PASSTHROUGH,\n          };\n        });\n        return new ChannelWrite(writes, [TAG_HIDDEN]);\n      })\n    );\n\n    // attach branch readers\n    const ends = branch.ends\n      ? Object.values(branch.ends)\n      : (Object.keys(this.nodes) as N[]);\n    for (const end of ends) {\n      if (end !== END) {\n        const channelName = `branch:${start}:${name}:${end}`;\n        (this.channels as Record<string, BaseChannel>)[channelName] =\n          new EphemeralValue();\n        this.nodes[end].triggers.push(channelName);\n        (this.nodes[end].channels as string[]).push(channelName);\n      }\n    }\n  }\n\n  /**\n   * Returns a drawable representation of the computation graph.\n   */\n  override async getGraphAsync(\n    config?: RunnableConfig & { xray?: boolean | number }\n  ): Promise<DrawableGraph> {\n    const xray = config?.xray;\n    const graph = new DrawableGraph();\n    const startNodes: Record<string, DrawableGraphNode> = {\n      [START]: graph.addNode({ schema: z.any() }, START),\n    };\n    const endNodes: Record<string, DrawableGraphNode> = {};\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let subgraphs: Record<string, CompiledGraph<any>> = {};\n    if (xray) {\n      subgraphs = Object.fromEntries(\n        (await gatherIterator(this.getSubgraphsAsync())).filter(\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (x): x is [string, CompiledGraph<any>] => isCompiledGraph(x[1])\n        )\n      );\n    }\n\n    function addEdge(\n      start: string,\n      end: string,\n      label?: string,\n      conditional = false\n    ) {\n      if (end === END && endNodes[END] === undefined) {\n        endNodes[END] = graph.addNode({ schema: z.any() }, END);\n      }\n      if (startNodes[start] === undefined) {\n        return;\n      }\n      if (endNodes[end] === undefined) {\n        throw new Error(`End node ${end} not found!`);\n      }\n      return graph.addEdge(\n        startNodes[start],\n        endNodes[end],\n        label !== end ? label : undefined,\n        conditional\n      );\n    }\n\n    for (const [key, nodeSpec] of Object.entries(this.builder.nodes) as [\n      N,\n      NodeSpec<State, Update>\n    ][]) {\n      const displayKey = _escapeMermaidKeywords(key);\n      const node = nodeSpec.runnable;\n      const metadata = nodeSpec.metadata ?? {};\n      if (\n        this.interruptBefore?.includes(key) &&\n        this.interruptAfter?.includes(key)\n      ) {\n        metadata.__interrupt = \"before,after\";\n      } else if (this.interruptBefore?.includes(key)) {\n        metadata.__interrupt = \"before\";\n      } else if (this.interruptAfter?.includes(key)) {\n        metadata.__interrupt = \"after\";\n      }\n      if (xray) {\n        const newXrayValue = typeof xray === \"number\" ? xray - 1 : xray;\n        const drawableSubgraph =\n          subgraphs[key] !== undefined\n            ? await subgraphs[key].getGraphAsync({\n                ...config,\n                xray: newXrayValue,\n              })\n            : node.getGraph(config);\n\n        drawableSubgraph.trimFirstNode();\n        drawableSubgraph.trimLastNode();\n\n        if (Object.keys(drawableSubgraph.nodes).length > 1) {\n          const [e, s] = graph.extend(drawableSubgraph, displayKey);\n          if (e === undefined) {\n            throw new Error(\n              `Could not extend subgraph \"${key}\" due to missing entrypoint.`\n            );\n          }\n\n          // TODO: Remove default name once we stop supporting core 0.2.0\n          // eslint-disable-next-line no-inner-declarations\n          function _isRunnableInterface(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            thing: any\n          ): thing is RunnableInterface {\n            return thing ? thing.lc_runnable : false;\n          }\n          // eslint-disable-next-line no-inner-declarations\n          function _nodeDataStr(\n            id: string | undefined,\n            data: RunnableInterface | RunnableIOSchema\n          ): string {\n            if (id !== undefined && !isUuid(id)) {\n              return id;\n            } else if (_isRunnableInterface(data)) {\n              try {\n                let dataStr = data.getName();\n                dataStr = dataStr.startsWith(\"Runnable\")\n                  ? dataStr.slice(\"Runnable\".length)\n                  : dataStr;\n                return dataStr;\n              } catch (error) {\n                return data.getName();\n              }\n            } else {\n              return data.name ?? \"UnknownSchema\";\n            }\n          }\n          // TODO: Remove casts when we stop supporting core 0.2.0\n          if (s !== undefined) {\n            startNodes[displayKey] = {\n              name: _nodeDataStr(s.id, s.data),\n              ...s,\n            } as DrawableGraphNode;\n          }\n          endNodes[displayKey] = {\n            name: _nodeDataStr(e.id, e.data),\n            ...e,\n          } as DrawableGraphNode;\n        } else {\n          // TODO: Remove when we stop supporting core 0.2.0\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          const newNode = graph.addNode(node, displayKey, metadata);\n          startNodes[displayKey] = newNode;\n          endNodes[displayKey] = newNode;\n        }\n      } else {\n        // TODO: Remove when we stop supporting core 0.2.0\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        const newNode = graph.addNode(node, displayKey, metadata);\n        startNodes[displayKey] = newNode;\n        endNodes[displayKey] = newNode;\n      }\n    }\n    const sortedEdges = [...this.builder.allEdges].sort(([a], [b]) => {\n      if (a < b) {\n        return -1;\n      } else if (b > a) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n    for (const [start, end] of sortedEdges) {\n      addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end));\n    }\n    for (const [start, branches] of Object.entries(this.builder.branches)) {\n      const defaultEnds: Record<string, string> = {\n        ...Object.fromEntries(\n          Object.keys(this.builder.nodes)\n            .filter((k) => k !== start)\n            .map((k) => [_escapeMermaidKeywords(k), _escapeMermaidKeywords(k)])\n        ),\n        [END]: END,\n      };\n      for (const branch of Object.values(branches)) {\n        let ends;\n        if (branch.ends !== undefined) {\n          ends = branch.ends;\n        } else {\n          ends = defaultEnds;\n        }\n        for (const [label, end] of Object.entries(ends)) {\n          addEdge(\n            _escapeMermaidKeywords(start),\n            _escapeMermaidKeywords(end),\n            label,\n            true\n          );\n        }\n      }\n    }\n    for (const [key, node] of Object.entries(this.builder.nodes) as [\n      N,\n      NodeSpec<State, Update>\n    ][]) {\n      if (node.ends !== undefined) {\n        for (const end of node.ends) {\n          addEdge(\n            _escapeMermaidKeywords(key),\n            _escapeMermaidKeywords(end),\n            undefined,\n            true\n          );\n        }\n      }\n    }\n    return graph;\n  }\n\n  /**\n   * Returns a drawable representation of the computation graph.\n   *\n   * @deprecated Use getGraphAsync instead. The async method will be the default in the next minor core release.\n   */\n  override getGraph(\n    config?: RunnableConfig & { xray?: boolean | number }\n  ): DrawableGraph {\n    const xray = config?.xray;\n    const graph = new DrawableGraph();\n    const startNodes: Record<string, DrawableGraphNode> = {\n      [START]: graph.addNode(\n        {\n          schema: z.any(),\n        },\n        START\n      ),\n    };\n    const endNodes: Record<string, DrawableGraphNode> = {};\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let subgraphs: Record<string, CompiledGraph<any>> = {};\n    if (xray) {\n      subgraphs = Object.fromEntries(\n        gatherIteratorSync(this.getSubgraphs()).filter(\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          (x): x is [string, CompiledGraph<any>] => isCompiledGraph(x[1])\n        )\n      );\n    }\n\n    function addEdge(\n      start: string,\n      end: string,\n      label?: string,\n      conditional = false\n    ) {\n      if (end === END && endNodes[END] === undefined) {\n        endNodes[END] = graph.addNode({ schema: z.any() }, END);\n      }\n      return graph.addEdge(\n        startNodes[start],\n        endNodes[end],\n        label !== end ? label : undefined,\n        conditional\n      );\n    }\n\n    for (const [key, nodeSpec] of Object.entries(this.builder.nodes) as [\n      N,\n      NodeSpec<State, Update>\n    ][]) {\n      const displayKey = _escapeMermaidKeywords(key);\n      const node = nodeSpec.runnable;\n      const metadata = nodeSpec.metadata ?? {};\n      if (\n        this.interruptBefore?.includes(key) &&\n        this.interruptAfter?.includes(key)\n      ) {\n        metadata.__interrupt = \"before,after\";\n      } else if (this.interruptBefore?.includes(key)) {\n        metadata.__interrupt = \"before\";\n      } else if (this.interruptAfter?.includes(key)) {\n        metadata.__interrupt = \"after\";\n      }\n      if (xray) {\n        const newXrayValue = typeof xray === \"number\" ? xray - 1 : xray;\n        const drawableSubgraph =\n          subgraphs[key] !== undefined\n            ? subgraphs[key].getGraph({\n                ...config,\n                xray: newXrayValue,\n              })\n            : node.getGraph(config);\n        drawableSubgraph.trimFirstNode();\n        drawableSubgraph.trimLastNode();\n        if (Object.keys(drawableSubgraph.nodes).length > 1) {\n          const [e, s] = graph.extend(drawableSubgraph, displayKey);\n          if (e === undefined) {\n            throw new Error(\n              `Could not extend subgraph \"${key}\" due to missing entrypoint.`\n            );\n          }\n\n          // TODO: Remove default name once we stop supporting core 0.2.0\n          // eslint-disable-next-line no-inner-declarations\n          function _isRunnableInterface(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            thing: any\n          ): thing is RunnableInterface {\n            return thing ? thing.lc_runnable : false;\n          }\n          // eslint-disable-next-line no-inner-declarations\n          function _nodeDataStr(\n            id: string | undefined,\n            data: RunnableInterface | RunnableIOSchema\n          ): string {\n            if (id !== undefined && !isUuid(id)) {\n              return id;\n            } else if (_isRunnableInterface(data)) {\n              try {\n                let dataStr = data.getName();\n                dataStr = dataStr.startsWith(\"Runnable\")\n                  ? dataStr.slice(\"Runnable\".length)\n                  : dataStr;\n                return dataStr;\n              } catch (error) {\n                return data.getName();\n              }\n            } else {\n              return data.name ?? \"UnknownSchema\";\n            }\n          }\n          // TODO: Remove casts when we stop supporting core 0.2.0\n          if (s !== undefined) {\n            startNodes[displayKey] = {\n              name: _nodeDataStr(s.id, s.data),\n              ...s,\n            } as DrawableGraphNode;\n          }\n          endNodes[displayKey] = {\n            name: _nodeDataStr(e.id, e.data),\n            ...e,\n          } as DrawableGraphNode;\n        } else {\n          // TODO: Remove when we stop supporting core 0.2.0\n          // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n          // @ts-ignore\n          const newNode = graph.addNode(node, displayKey, metadata);\n          startNodes[displayKey] = newNode;\n          endNodes[displayKey] = newNode;\n        }\n      } else {\n        // TODO: Remove when we stop supporting core 0.2.0\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        const newNode = graph.addNode(node, displayKey, metadata);\n        startNodes[displayKey] = newNode;\n        endNodes[displayKey] = newNode;\n      }\n    }\n    const sortedEdges = [...this.builder.allEdges].sort(([a], [b]) => {\n      if (a < b) {\n        return -1;\n      } else if (b > a) {\n        return 1;\n      } else {\n        return 0;\n      }\n    });\n    for (const [start, end] of sortedEdges) {\n      addEdge(_escapeMermaidKeywords(start), _escapeMermaidKeywords(end));\n    }\n    for (const [start, branches] of Object.entries(this.builder.branches)) {\n      const defaultEnds: Record<string, string> = {\n        ...Object.fromEntries(\n          Object.keys(this.builder.nodes)\n            .filter((k) => k !== start)\n            .map((k) => [_escapeMermaidKeywords(k), _escapeMermaidKeywords(k)])\n        ),\n        [END]: END,\n      };\n      for (const branch of Object.values(branches)) {\n        let ends;\n        if (branch.ends !== undefined) {\n          ends = branch.ends;\n        } else {\n          ends = defaultEnds;\n        }\n        for (const [label, end] of Object.entries(ends)) {\n          addEdge(\n            _escapeMermaidKeywords(start),\n            _escapeMermaidKeywords(end),\n            label,\n            true\n          );\n        }\n      }\n    }\n    return graph;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isCompiledGraph(x: unknown): x is CompiledGraph<any> {\n  return (\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typeof (x as CompiledGraph<any>).attachNode === \"function\" &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typeof (x as CompiledGraph<any>).attachEdge === \"function\"\n  );\n}\n\nfunction _escapeMermaidKeywords(key: string) {\n  if (key === \"subgraph\") {\n    return `\"${key}\"`;\n  }\n  return key;\n}\n"],"mappings":"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"}