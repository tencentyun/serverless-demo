{"version":3,"file":"hitl.d.cts","names":["__types_js7","z","ToolCall","InferInteropZodInput","AgentBuiltInState","Runtime","DescriptionFunctionSchema","Record","ZodTypeDef","ZodType","ZodUnknown","ZodTuple","ZodString","ZodPromise","ZodUnion","ZodFunction","DescriptionFactory","infer","DecisionType","ZodEnum","InterruptOnConfigSchema","ZodArray","ZodOptional","ZodAny","ZodRecord","ZodTypeAny","Promise","ZodObject","InterruptOnConfig","input","Action","ActionRequest","ReviewConfig","HITLRequest","ApproveDecision","EditDecision","RejectDecision","Decision","HITLResponse","contextSchema","ZodBoolean","ZodDefault","HumanInTheLoopMiddlewareConfig","humanInTheLoopMiddleware","NonNullable","_langchain_core_tools0","ServerTool","ClientTool","AgentMiddleware"],"sources":["../../../src/agents/middleware/hitl.d.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport { ToolCall } from \"@langchain/core/messages\";\nimport { InferInteropZodInput } from \"@langchain/core/utils/types\";\nimport type { AgentBuiltInState, Runtime } from \"../runtime.js\";\ndeclare const DescriptionFunctionSchema: z.ZodFunction<z.ZodTuple<[z.ZodType<ToolCall<string, Record<string, any>>, z.ZodTypeDef, ToolCall<string, Record<string, any>>>, z.ZodType<AgentBuiltInState, z.ZodTypeDef, AgentBuiltInState>, z.ZodType<Runtime<unknown>, z.ZodTypeDef, Runtime<unknown>>], z.ZodUnknown>, z.ZodUnion<[z.ZodString, z.ZodPromise<z.ZodString>]>>;\n/**\n * Function type that dynamically generates a description for a tool call approval request.\n *\n * @param toolCall - The tool call being reviewed\n * @param state - The current agent state\n * @param runtime - The agent runtime context\n * @returns A string description or Promise that resolves to a string description\n *\n * @example\n * ```typescript\n * import { type DescriptionFactory, type ToolCall } from \"langchain\";\n *\n * const descriptionFactory: DescriptionFactory = (toolCall, state, runtime) => {\n *   return `Please review: ${toolCall.name}(${JSON.stringify(toolCall.args)})`;\n * };\n * ```\n */\nexport type DescriptionFactory = z.infer<typeof DescriptionFunctionSchema>;\ndeclare const DecisionType: z.ZodEnum<[\"approve\", \"edit\", \"reject\"]>;\nexport type DecisionType = z.infer<typeof DecisionType>;\ndeclare const InterruptOnConfigSchema: z.ZodObject<{\n    /**\n     * The decisions that are allowed for this action.\n     */\n    allowedDecisions: z.ZodArray<z.ZodEnum<[\"approve\", \"edit\", \"reject\"]>, \"many\">;\n    /**\n     * The description attached to the request for human input.\n     * Can be either:\n     * - A static string describing the approval request\n     * - A callable that dynamically generates the description based on agent state,\n     *   runtime, and tool call information\n     *\n     * @example\n     * Static string description\n     * ```typescript\n     * import type { InterruptOnConfig } from \"langchain\";\n     *\n     * const config: InterruptOnConfig = {\n     *   allowedDecisions: [\"approve\", \"reject\"],\n     *   description: \"Please review this tool execution\"\n     * };\n     * ```\n     *\n     * @example\n     * Dynamic callable description\n     * ```typescript\n     * import type {\n     *   AgentBuiltInState,\n     *   Runtime,\n     *   DescriptionFactory,\n     *   ToolCall,\n     *   InterruptOnConfig\n     * } from \"langchain\";\n     *\n     * const formatToolDescription: DescriptionFactory = (\n     *   toolCall: ToolCall,\n     *   state: AgentBuiltInState,\n     *   runtime: Runtime<unknown>\n     * ) => {\n     *   return `Tool: ${toolCall.name}\\nArguments:\\n${JSON.stringify(toolCall.args, null, 2)}`;\n     * };\n     *\n     * const config: InterruptOnConfig = {\n     *   allowedDecisions: [\"approve\", \"edit\"],\n     *   description: formatToolDescription\n     * };\n     * ```\n     */\n    description: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodFunction<z.ZodTuple<[z.ZodType<ToolCall<string, Record<string, any>>, z.ZodTypeDef, ToolCall<string, Record<string, any>>>, z.ZodType<AgentBuiltInState, z.ZodTypeDef, AgentBuiltInState>, z.ZodType<Runtime<unknown>, z.ZodTypeDef, Runtime<unknown>>], z.ZodUnknown>, z.ZodUnion<[z.ZodString, z.ZodPromise<z.ZodString>]>>]>>;\n    /**\n     * JSON schema for the arguments associated with the action, if edits are allowed.\n     */\n    argsSchema: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;\n}, \"strip\", z.ZodTypeAny, {\n    allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n    description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n    argsSchema?: Record<string, any> | undefined;\n}, {\n    allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n    description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n    argsSchema?: Record<string, any> | undefined;\n}>;\nexport type InterruptOnConfig = z.input<typeof InterruptOnConfigSchema>;\n/**\n * Represents an action with a name and arguments.\n */\nexport interface Action {\n    /**\n     * The type or name of action being requested (e.g., \"add_numbers\").\n     */\n    name: string;\n    /**\n     * Key-value pairs of arguments needed for the action (e.g., {\"a\": 1, \"b\": 2}).\n     */\n    args: Record<string, any>;\n}\n/**\n * Represents an action request with a name, arguments, and description.\n */\nexport interface ActionRequest {\n    /**\n     * The name of the action being requested.\n     */\n    name: string;\n    /**\n     * Key-value pairs of arguments needed for the action (e.g., {\"a\": 1, \"b\": 2}).\n     */\n    args: Record<string, any>;\n    /**\n     * The description of the action to be reviewed.\n     */\n    description?: string;\n}\n/**\n * Policy for reviewing a HITL request.\n */\nexport interface ReviewConfig {\n    /**\n     * Name of the action associated with this review configuration.\n     */\n    actionName: string;\n    /**\n     * The decisions that are allowed for this request.\n     */\n    allowedDecisions: DecisionType[];\n    /**\n     * JSON schema for the arguments associated with the action, if edits are allowed.\n     */\n    argsSchema?: Record<string, any>;\n}\n/**\n * Request for human feedback on a sequence of actions requested by a model.\n *\n * @example\n * ```ts\n * const hitlRequest: HITLRequest = {\n *   actionRequests: [\n *     { name: \"send_email\", args: { to: \"user@example.com\", subject: \"Hello\" } }\n *   ],\n *   reviewConfigs: [\n *     {\n *       actionName: \"send_email\",\n *       allowedDecisions: [\"approve\", \"edit\", \"reject\"],\n *       description: \"Please review the email before sending\"\n *     }\n *   ]\n * };\n * const response = interrupt(hitlRequest);\n * ```\n */\nexport interface HITLRequest {\n    /**\n     * A list of agent actions for human review.\n     */\n    actionRequests: ActionRequest[];\n    /**\n     * Review configuration for all possible actions.\n     */\n    reviewConfigs: ReviewConfig[];\n}\n/**\n * Response when a human approves the action.\n */\nexport interface ApproveDecision {\n    type: \"approve\";\n}\n/**\n * Response when a human edits the action.\n */\nexport interface EditDecision {\n    type: \"edit\";\n    /**\n     * Edited action for the agent to perform.\n     * Ex: for a tool call, a human reviewer can edit the tool name and args.\n     */\n    editedAction: Action;\n}\n/**\n * Response when a human rejects the action.\n */\nexport interface RejectDecision {\n    type: \"reject\";\n    /**\n     * The message sent to the model explaining why the action was rejected.\n     */\n    message?: string;\n}\n/**\n * Union of all possible decision types.\n */\nexport type Decision = ApproveDecision | EditDecision | RejectDecision;\n/**\n * Response payload for a HITLRequest.\n */\nexport interface HITLResponse {\n    /**\n     * The decisions made by the human.\n     */\n    decisions: Decision[];\n}\ndeclare const contextSchema: z.ZodObject<{\n    /**\n     * Mapping of tool name to allowed reviewer responses.\n     * If a tool doesn't have an entry, it's auto-approved by default.\n     *\n     * - `true` -> pause for approval and allow approve/edit/reject decisions\n     * - `false` -> auto-approve (no human review)\n     * - `InterruptOnConfig` -> explicitly specify which decisions are allowed for this tool\n     */\n    interruptOn: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodBoolean, z.ZodObject<{\n        /**\n         * The decisions that are allowed for this action.\n         */\n        allowedDecisions: z.ZodArray<z.ZodEnum<[\"approve\", \"edit\", \"reject\"]>, \"many\">;\n        /**\n         * The description attached to the request for human input.\n         * Can be either:\n         * - A static string describing the approval request\n         * - A callable that dynamically generates the description based on agent state,\n         *   runtime, and tool call information\n         *\n         * @example\n         * Static string description\n         * ```typescript\n         * import type { InterruptOnConfig } from \"langchain\";\n         *\n         * const config: InterruptOnConfig = {\n         *   allowedDecisions: [\"approve\", \"reject\"],\n         *   description: \"Please review this tool execution\"\n         * };\n         * ```\n         *\n         * @example\n         * Dynamic callable description\n         * ```typescript\n         * import type {\n         *   AgentBuiltInState,\n         *   Runtime,\n         *   DescriptionFactory,\n         *   ToolCall,\n         *   InterruptOnConfig\n         * } from \"langchain\";\n         *\n         * const formatToolDescription: DescriptionFactory = (\n         *   toolCall: ToolCall,\n         *   state: AgentBuiltInState,\n         *   runtime: Runtime<unknown>\n         * ) => {\n         *   return `Tool: ${toolCall.name}\\nArguments:\\n${JSON.stringify(toolCall.args, null, 2)}`;\n         * };\n         *\n         * const config: InterruptOnConfig = {\n         *   allowedDecisions: [\"approve\", \"edit\"],\n         *   description: formatToolDescription\n         * };\n         * ```\n         */\n        description: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodFunction<z.ZodTuple<[z.ZodType<ToolCall<string, Record<string, any>>, z.ZodTypeDef, ToolCall<string, Record<string, any>>>, z.ZodType<AgentBuiltInState, z.ZodTypeDef, AgentBuiltInState>, z.ZodType<Runtime<unknown>, z.ZodTypeDef, Runtime<unknown>>], z.ZodUnknown>, z.ZodUnion<[z.ZodString, z.ZodPromise<z.ZodString>]>>]>>;\n        /**\n         * JSON schema for the arguments associated with the action, if edits are allowed.\n         */\n        argsSchema: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;\n    }, \"strip\", z.ZodTypeAny, {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }, {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }>]>>>;\n    /**\n     * Prefix used when constructing human-facing approval messages.\n     * Provides context about the tool call being reviewed; does not change the underlying action.\n     *\n     * Note: This prefix is only applied for tools that do not provide a custom\n     * `description` via their {@link InterruptOnConfig}. If a tool specifies a custom\n     * `description`, that per-tool text is used and this prefix is ignored.\n     */\n    descriptionPrefix: z.ZodDefault<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    interruptOn?: Record<string, boolean | {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }> | undefined;\n    descriptionPrefix: string;\n}, {\n    interruptOn?: Record<string, boolean | {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }> | undefined;\n    descriptionPrefix?: string | undefined;\n}>;\nexport type HumanInTheLoopMiddlewareConfig = InferInteropZodInput<typeof contextSchema>;\n/**\n * Creates a Human-in-the-Loop (HITL) middleware for tool approval and oversight.\n *\n * This middleware intercepts tool calls made by an AI agent and provides human oversight\n * capabilities before execution. It enables selective approval workflows where certain tools\n * require human intervention while others can execute automatically.\n *\n * A invocation result that has been interrupted by the middleware will have a `__interrupt__`\n * property that contains the interrupt request.\n *\n * ```ts\n * import { type HITLRequest, type HITLResponse } from \"langchain\";\n * import { type Interrupt } from \"langchain\";\n *\n * const result = await agent.invoke(request);\n * const interruptRequest = result.__interrupt__?.[0] as Interrupt<HITLRequest>;\n *\n * // Examine the action requests and review configs\n * const actionRequests = interruptRequest.value.actionRequests;\n * const reviewConfigs = interruptRequest.value.reviewConfigs;\n *\n * // Create decisions for each action\n * const resume: HITLResponse = {\n *   decisions: actionRequests.map((action, i) => {\n *     if (action.name === \"calculator\") {\n *       return { type: \"approve\" };\n *     } else if (action.name === \"write_file\") {\n *       return {\n *         type: \"edit\",\n *         editedAction: { name: \"write_file\", args: { filename: \"safe.txt\", content: \"Safe content\" } }\n *       };\n *     }\n *     return { type: \"reject\", message: \"Action not allowed\" };\n *   })\n * };\n *\n * // Resume with decisions\n * await agent.invoke(new Command({ resume }), config);\n * ```\n *\n * ## Features\n *\n * - **Selective Tool Approval**: Configure which tools require human approval\n * - **Multiple Decision Types**: Approve, edit, or reject tool calls\n * - **Asynchronous Workflow**: Uses LangGraph's interrupt mechanism for non-blocking approval\n * - **Custom Approval Messages**: Provide context-specific descriptions for approval requests\n *\n * ## Decision Types\n *\n * When a tool requires approval, the human operator can respond with:\n * - `approve`: Execute the tool with original arguments\n * - `edit`: Modify the tool name and/or arguments before execution\n * - `reject`: Provide a manual response instead of executing the tool\n *\n * @param options - Configuration options for the middleware\n * @param options.interruptOn - Per-tool configuration mapping tool names to their settings\n * @param options.interruptOn[toolName].allowedDecisions - Array of decision types allowed for this tool (e.g., [\"approve\", \"edit\", \"reject\"])\n * @param options.interruptOn[toolName].description - Custom approval message for the tool. Can be either a static string or a callable that dynamically generates the description based on agent state, runtime, and tool call information\n * @param options.interruptOn[toolName].argsSchema - JSON schema for the arguments associated with the action, if edits are allowed\n * @param options.descriptionPrefix - Default prefix for approval messages (default: \"Tool execution requires approval\"). Only used for tools that do not define a custom `description` in their InterruptOnConfig.\n *\n * @returns A middleware instance that can be passed to `createAgent`\n *\n * @example\n * Basic usage with selective tool approval\n * ```typescript\n * import { humanInTheLoopMiddleware } from \"langchain\";\n * import { createAgent } from \"langchain\";\n *\n * const hitlMiddleware = humanInTheLoopMiddleware({\n *   interruptOn: {\n *     // Interrupt write_file tool and allow edits or approvals\n *     \"write_file\": {\n *       allowedDecisions: [\"approve\", \"edit\"],\n *       description: \"‚ö†Ô∏è File write operation requires approval\"\n *     },\n *     // Auto-approve read_file tool\n *     \"read_file\": false\n *   }\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4\",\n *   tools: [writeFileTool, readFileTool],\n *   middleware: [hitlMiddleware]\n * });\n * ```\n *\n * @example\n * Handling approval requests\n * ```typescript\n * import { type HITLRequest, type HITLResponse, type Interrupt } from \"langchain\";\n * import { Command } from \"@langchain/langgraph\";\n *\n * // Initial agent invocation\n * const result = await agent.invoke({\n *   messages: [new HumanMessage(\"Write 'Hello' to output.txt\")]\n * }, config);\n *\n * // Check if agent is paused for approval\n * if (result.__interrupt__) {\n *   const interruptRequest = result.__interrupt__?.[0] as Interrupt<HITLRequest>;\n *\n *   // Show tool call details to user\n *   console.log(\"Actions:\", interruptRequest.value.actionRequests);\n *   console.log(\"Review configs:\", interruptRequest.value.reviewConfigs);\n *\n *   // Resume with approval\n *   const resume: HITLResponse = {\n *     decisions: [{ type: \"approve\" }]\n *   };\n *   await agent.invoke(\n *     new Command({ resume }),\n *     config\n *   );\n * }\n * ```\n *\n * @example\n * Different decision types\n * ```typescript\n * import { type HITLResponse } from \"langchain\";\n *\n * // Approve the tool call as-is\n * const resume: HITLResponse = {\n *   decisions: [{ type: \"approve\" }]\n * };\n *\n * // Edit the tool arguments\n * const resume: HITLResponse = {\n *   decisions: [{\n *     type: \"edit\",\n *     editedAction: { name: \"write_file\", args: { filename: \"safe.txt\", content: \"Modified\" } }\n *   }]\n * };\n *\n * // Reject with feedback\n * const resume: HITLResponse = {\n *   decisions: [{\n *     type: \"reject\",\n *     message: \"File operation not allowed in demo mode\"\n *   }]\n * };\n * ```\n *\n * @example\n * Production use case with database operations\n * ```typescript\n * const hitlMiddleware = humanInTheLoopMiddleware({\n *   interruptOn: {\n *     \"execute_sql\": {\n *       allowedDecisions: [\"approve\", \"edit\", \"reject\"],\n *       description: \"üö® SQL query requires DBA approval\\nPlease review for safety and performance\"\n *     },\n *     \"read_schema\": false,  // Reading metadata is safe\n *     \"delete_records\": {\n *       allowedDecisions: [\"approve\", \"reject\"],\n *       description: \"‚õî DESTRUCTIVE OPERATION - Requires manager approval\"\n *     }\n *   },\n *   descriptionPrefix: \"Database operation pending approval\"\n * });\n * ```\n *\n * @example\n * Using dynamic callable descriptions\n * ```typescript\n * import { type DescriptionFactory, type ToolCall } from \"langchain\";\n * import type { AgentBuiltInState, Runtime } from \"langchain/agents\";\n *\n * // Define a dynamic description factory\n * const formatToolDescription: DescriptionFactory = (\n *   toolCall: ToolCall,\n *   state: AgentBuiltInState,\n *   runtime: Runtime<unknown>\n * ) => {\n *   return `Tool: ${toolCall.name}\\nArguments:\\n${JSON.stringify(toolCall.args, null, 2)}`;\n * };\n *\n * const hitlMiddleware = humanInTheLoopMiddleware({\n *   interruptOn: {\n *     \"write_file\": {\n *       allowedDecisions: [\"approve\", \"edit\"],\n *       // Use dynamic description that can access tool call, state, and runtime\n *       description: formatToolDescription\n *     },\n *     // Or use an inline function\n *     \"send_email\": {\n *       allowedDecisions: [\"approve\", \"reject\"],\n *       description: (toolCall, state, runtime) => {\n *         const { to, subject } = toolCall.args;\n *         return `Email to ${to}\\nSubject: ${subject}\\n\\nRequires approval before sending`;\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @remarks\n * - Tool calls are processed in the order they appear in the AI message\n * - Auto-approved tools execute immediately without interruption\n * - Multiple tools requiring approval are bundled into a single interrupt request\n * - The middleware operates in the `afterModel` phase, intercepting before tool execution\n * - Requires a checkpointer to maintain state across interruptions\n *\n * @see {@link createAgent} for agent creation\n * @see {@link Command} for resuming interrupted execution\n * @public\n */\nexport declare function humanInTheLoopMiddleware(options: NonNullable<HumanInTheLoopMiddlewareConfig>): import(\"./types.js\").AgentMiddleware<undefined, z.ZodObject<{\n    /**\n     * Mapping of tool name to allowed reviewer responses.\n     * If a tool doesn't have an entry, it's auto-approved by default.\n     *\n     * - `true` -> pause for approval and allow approve/edit/reject decisions\n     * - `false` -> auto-approve (no human review)\n     * - `InterruptOnConfig` -> explicitly specify which decisions are allowed for this tool\n     */\n    interruptOn: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodBoolean, z.ZodObject<{\n        /**\n         * The decisions that are allowed for this action.\n         */\n        allowedDecisions: z.ZodArray<z.ZodEnum<[\"approve\", \"edit\", \"reject\"]>, \"many\">;\n        /**\n         * The description attached to the request for human input.\n         * Can be either:\n         * - A static string describing the approval request\n         * - A callable that dynamically generates the description based on agent state,\n         *   runtime, and tool call information\n         *\n         * @example\n         * Static string description\n         * ```typescript\n         * import type { InterruptOnConfig } from \"langchain\";\n         *\n         * const config: InterruptOnConfig = {\n         *   allowedDecisions: [\"approve\", \"reject\"],\n         *   description: \"Please review this tool execution\"\n         * };\n         * ```\n         *\n         * @example\n         * Dynamic callable description\n         * ```typescript\n         * import type {\n         *   AgentBuiltInState,\n         *   Runtime,\n         *   DescriptionFactory,\n         *   ToolCall,\n         *   InterruptOnConfig\n         * } from \"langchain\";\n         *\n         * const formatToolDescription: DescriptionFactory = (\n         *   toolCall: ToolCall,\n         *   state: AgentBuiltInState,\n         *   runtime: Runtime<unknown>\n         * ) => {\n         *   return `Tool: ${toolCall.name}\\nArguments:\\n${JSON.stringify(toolCall.args, null, 2)}`;\n         * };\n         *\n         * const config: InterruptOnConfig = {\n         *   allowedDecisions: [\"approve\", \"edit\"],\n         *   description: formatToolDescription\n         * };\n         * ```\n         */\n        description: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodFunction<z.ZodTuple<[z.ZodType<ToolCall<string, Record<string, any>>, z.ZodTypeDef, ToolCall<string, Record<string, any>>>, z.ZodType<AgentBuiltInState, z.ZodTypeDef, AgentBuiltInState>, z.ZodType<Runtime<unknown>, z.ZodTypeDef, Runtime<unknown>>], z.ZodUnknown>, z.ZodUnion<[z.ZodString, z.ZodPromise<z.ZodString>]>>]>>;\n        /**\n         * JSON schema for the arguments associated with the action, if edits are allowed.\n         */\n        argsSchema: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodAny>>;\n    }, \"strip\", z.ZodTypeAny, {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }, {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }>]>>>;\n    /**\n     * Prefix used when constructing human-facing approval messages.\n     * Provides context about the tool call being reviewed; does not change the underlying action.\n     *\n     * Note: This prefix is only applied for tools that do not provide a custom\n     * `description` via their {@link InterruptOnConfig}. If a tool specifies a custom\n     * `description`, that per-tool text is used and this prefix is ignored.\n     */\n    descriptionPrefix: z.ZodDefault<z.ZodString>;\n}, \"strip\", z.ZodTypeAny, {\n    interruptOn?: Record<string, boolean | {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }> | undefined;\n    descriptionPrefix: string;\n}, {\n    interruptOn?: Record<string, boolean | {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }> | undefined;\n    descriptionPrefix?: string | undefined;\n}>, {\n    interruptOn?: Record<string, boolean | {\n        allowedDecisions: (\"approve\" | \"edit\" | \"reject\")[];\n        description?: string | ((args_0: ToolCall<string, Record<string, any>>, args_1: AgentBuiltInState, args_2: Runtime<unknown>, ...args: unknown[]) => string | Promise<string>) | undefined;\n        argsSchema?: Record<string, any> | undefined;\n    }> | undefined;\n    descriptionPrefix: string;\n}, readonly (import(\"@langchain/core/tools\").ServerTool | import(\"@langchain/core/tools\").ClientTool)[]>;\nexport {};\n//# sourceMappingURL=hitl.d.ts.map"],"mappings":"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"}