{"version":3,"file":"algo.cjs","names":["getNullChannelVersion","INTERRUPT","START","TAG_HIDDEN","createCheckpoint","emptyChannels","readChannels","PUSH","TASKS","_isSend","InvalidUpdateError","NO_WRITES","RESUME","RETURN","ERROR","getOnlyChannels","RESERVED","PULL","isCall","getRunnableForFunc","CHECKPOINT_NAMESPACE_SEPARATOR","CHECKPOINT_NAMESPACE_END","CONFIG_KEY_TASK_ID","CONFIG_KEY_SEND","CONFIG_KEY_READ","CONFIG_KEY_CHECKPOINTER","CONFIG_KEY_CHECKPOINT_MAP","CONFIG_KEY_SCRATCHPAD","CONFIG_KEY_RESUME_MAP","XXH3","CONFIG_KEY_PREVIOUS_STATE","PREVIOUS","CACHE_NS_WRITES","_isSendInterface","Send","readChannel","EmptyChannelError","NULL_TASK_ID"],"sources":["../../src/pregel/algo.ts"],"sourcesContent":["/* eslint-disable no-param-reassign */\nimport {\n  mergeConfigs,\n  patchConfig,\n  RunnableConfig,\n} from \"@langchain/core/runnables\";\nimport { CallbackManagerForChainRun } from \"@langchain/core/callbacks/manager\";\nimport {\n  All,\n  BaseCheckpointSaver,\n  Checkpoint,\n  ReadonlyCheckpoint,\n  copyCheckpoint,\n  type PendingWrite,\n  type PendingWriteValue,\n  uuid5,\n  maxChannelVersion,\n  BaseStore,\n  CheckpointPendingWrite,\n  SendProtocol,\n} from \"@langchain/langgraph-checkpoint\";\nimport {\n  BaseChannel,\n  createCheckpoint,\n  emptyChannels,\n  getOnlyChannels,\n} from \"../channels/base.js\";\nimport { PregelNode } from \"./read.js\";\nimport { readChannel, readChannels } from \"./io.js\";\nimport {\n  _isSend,\n  _isSendInterface,\n  CONFIG_KEY_CHECKPOINT_MAP,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  CONFIG_KEY_CHECKPOINTER,\n  CONFIG_KEY_READ,\n  CONFIG_KEY_TASK_ID,\n  CONFIG_KEY_SEND,\n  INTERRUPT,\n  RESERVED,\n  Send,\n  TAG_HIDDEN,\n  TASKS,\n  CHECKPOINT_NAMESPACE_END,\n  PUSH,\n  PULL,\n  RESUME,\n  NULL_TASK_ID,\n  CONFIG_KEY_SCRATCHPAD,\n  RETURN,\n  ERROR,\n  NO_WRITES,\n  CONFIG_KEY_PREVIOUS_STATE,\n  PREVIOUS,\n  CACHE_NS_WRITES,\n  CONFIG_KEY_RESUME_MAP,\n  START,\n} from \"../constants.js\";\nimport {\n  Call,\n  isCall,\n  PregelExecutableTask,\n  PregelScratchpad,\n  PregelTaskDescription,\n  SimpleTaskPath,\n  TaskPath,\n  VariadicTaskPath,\n} from \"./types.js\";\nimport { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { getNullChannelVersion } from \"./utils/index.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\nimport { getRunnableForFunc } from \"./call.js\";\nimport { IterableReadableWritableStream } from \"./stream.js\";\nimport { XXH3 } from \"../hash.js\";\nimport { Topic } from \"../channels/topic.js\";\n\n/**\n * Construct a type with a set of properties K of type T\n */\nexport type StrRecord<K extends string, T> = {\n  [P in K]: T;\n};\n\nexport type WritesProtocol<C = string> = {\n  name: string;\n  writes: PendingWrite<C>[];\n  triggers: string[];\n  path?: TaskPath;\n};\n\nexport const increment = (current?: number) => {\n  return current !== undefined ? current + 1 : 1;\n};\n\nfunction triggersNextStep(\n  updatedChannels: Set<string>,\n  triggerToNodes: Record<string, string[]> | undefined\n) {\n  if (triggerToNodes == null) return false;\n\n  for (const chan of updatedChannels) {\n    if (triggerToNodes[chan]) return true;\n  }\n\n  return false;\n}\n\n// Avoids unnecessary double iteration\nfunction maxChannelMapVersion(\n  channelVersions: Record<string, number | string>\n): number | string | undefined {\n  let maxVersion: number | string | undefined;\n  for (const chan in channelVersions) {\n    if (!Object.prototype.hasOwnProperty.call(channelVersions, chan)) continue;\n    if (maxVersion == null) {\n      maxVersion = channelVersions[chan];\n    } else {\n      maxVersion = maxChannelVersion(maxVersion, channelVersions[chan]);\n    }\n  }\n  return maxVersion;\n}\n\nexport function shouldInterrupt<N extends PropertyKey, C extends PropertyKey>(\n  checkpoint: Checkpoint,\n  interruptNodes: All | N[],\n  tasks: PregelExecutableTask<N, C>[]\n): boolean {\n  const nullVersion = getNullChannelVersion(checkpoint.channel_versions);\n  const seen = checkpoint.versions_seen[INTERRUPT] ?? {};\n\n  let anyChannelUpdated = false;\n\n  if (\n    (checkpoint.channel_versions[START] ?? nullVersion) >\n    (seen[START] ?? nullVersion)\n  ) {\n    anyChannelUpdated = true;\n  } else {\n    for (const chan in checkpoint.channel_versions) {\n      if (\n        !Object.prototype.hasOwnProperty.call(checkpoint.channel_versions, chan)\n      )\n        continue;\n\n      if (checkpoint.channel_versions[chan] > (seen[chan] ?? nullVersion)) {\n        anyChannelUpdated = true;\n        break;\n      }\n    }\n  }\n\n  const anyTriggeredNodeInInterruptNodes = tasks.some((task) =>\n    interruptNodes === \"*\"\n      ? !task.config?.tags?.includes(TAG_HIDDEN)\n      : interruptNodes.includes(task.name)\n  );\n\n  return anyChannelUpdated && anyTriggeredNodeInInterruptNodes;\n}\n\nexport function _localRead<Cc extends Record<string, BaseChannel>>(\n  checkpoint: ReadonlyCheckpoint,\n  channels: Cc,\n  task: WritesProtocol<keyof Cc>,\n  select: Array<keyof Cc> | keyof Cc,\n  fresh: boolean = false\n): Record<string, unknown> | unknown {\n  let updated = new Set<keyof Cc>();\n\n  if (!Array.isArray(select)) {\n    for (const [c] of task.writes) {\n      if (c === select) {\n        updated = new Set([c]);\n        break;\n      }\n    }\n    updated = updated || new Set();\n  } else {\n    updated = new Set(\n      select.filter((c) => task.writes.some(([key, _]) => key === c))\n    );\n  }\n\n  let values: Record<string, unknown>;\n\n  if (fresh && updated.size > 0) {\n    const localChannels = Object.fromEntries(\n      Object.entries(channels).filter(([k, _]) => updated.has(k as keyof Cc))\n    ) as Partial<Cc>;\n\n    const newCheckpoint = createCheckpoint(checkpoint, localChannels as Cc, -1);\n    const newChannels = emptyChannels(localChannels as Cc, newCheckpoint);\n\n    _applyWrites(\n      copyCheckpoint(newCheckpoint),\n      newChannels,\n      [task],\n      undefined,\n      undefined\n    );\n    values = readChannels({ ...channels, ...newChannels }, select);\n  } else {\n    values = readChannels(channels, select);\n  }\n\n  return values;\n}\n\nexport function _localWrite(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  commit: (writes: [string, any][]) => any,\n  processes: Record<string, PregelNode>,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  writes: [string, any][]\n) {\n  for (const [chan, value] of writes) {\n    if ([PUSH, TASKS].includes(chan) && value != null) {\n      if (!_isSend(value)) {\n        throw new InvalidUpdateError(\n          `Invalid packet type, expected SendProtocol, got ${JSON.stringify(\n            value\n          )}`\n        );\n      }\n      if (!(value.node in processes)) {\n        throw new InvalidUpdateError(\n          `Invalid node name \"${value.node}\" in Send packet`\n        );\n      }\n    }\n  }\n  commit(writes);\n}\n\nconst IGNORE = new Set<string | number | symbol>([\n  NO_WRITES,\n  PUSH,\n  RESUME,\n  INTERRUPT,\n  RETURN,\n  ERROR,\n]);\n\nexport function _applyWrites<Cc extends Record<string, BaseChannel>>(\n  checkpoint: Checkpoint,\n  channels: Cc,\n  tasks: WritesProtocol<keyof Cc>[],\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  getNextVersion: ((version: any) => any) | undefined,\n  triggerToNodes: Record<string, string[]> | undefined\n): Set<string> {\n  // Sort tasks by first 3 path elements for deterministic order\n  // Later path parts (like task IDs) are ignored for sorting\n  tasks.sort((a, b) => {\n    const aPath = a.path?.slice(0, 3) || [];\n    const bPath = b.path?.slice(0, 3) || [];\n\n    // Compare each path element\n    for (let i = 0; i < Math.min(aPath.length, bPath.length); i += 1) {\n      if (aPath[i] < bPath[i]) return -1;\n      if (aPath[i] > bPath[i]) return 1;\n    }\n\n    // If one path is shorter, it comes first\n    return aPath.length - bPath.length;\n  });\n\n  // if no task has triggers this is applying writes from the null task only\n  // so we don't do anything other than update the channels written to\n  const bumpStep = tasks.some((task) => task.triggers.length > 0);\n\n  // Filter out non instances of BaseChannel\n  const onlyChannels = getOnlyChannels(channels);\n\n  // Update seen versions\n  for (const task of tasks) {\n    checkpoint.versions_seen[task.name] ??= {};\n    for (const chan of task.triggers) {\n      if (chan in checkpoint.channel_versions) {\n        checkpoint.versions_seen[task.name][chan] =\n          checkpoint.channel_versions[chan];\n      }\n    }\n  }\n\n  // Find the highest version of all channels\n  let maxVersion = maxChannelMapVersion(checkpoint.channel_versions);\n\n  // Consume all channels that were read\n  const channelsToConsume = new Set(\n    tasks\n      .flatMap((task) => task.triggers)\n      .filter((chan) => !RESERVED.includes(chan))\n  );\n\n  let usedNewVersion = false;\n  for (const chan of channelsToConsume) {\n    if (chan in onlyChannels && onlyChannels[chan].consume()) {\n      if (getNextVersion !== undefined) {\n        checkpoint.channel_versions[chan] = getNextVersion(maxVersion);\n        usedNewVersion = true;\n      }\n    }\n  }\n\n  // Group writes by channel\n  const pendingWritesByChannel = {} as Record<keyof Cc, PendingWriteValue[]>;\n  for (const task of tasks) {\n    for (const [chan, val] of task.writes) {\n      if (IGNORE.has(chan)) {\n        // do nothing\n      } else if (chan in onlyChannels) {\n        pendingWritesByChannel[chan] ??= [];\n        pendingWritesByChannel[chan].push(val);\n      }\n    }\n  }\n\n  // Find the highest version of all channels\n  if (maxVersion != null && getNextVersion != null) {\n    maxVersion = usedNewVersion ? getNextVersion(maxVersion) : maxVersion;\n  }\n\n  const updatedChannels: Set<string> = new Set();\n  // Apply writes to channels\n  for (const [chan, vals] of Object.entries(pendingWritesByChannel)) {\n    if (chan in onlyChannels) {\n      const channel = onlyChannels[chan];\n      let updated;\n      try {\n        updated = channel.update(vals);\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (e: any) {\n        if (e.name === InvalidUpdateError.unminifiable_name) {\n          const wrappedError = new InvalidUpdateError(\n            `Invalid update for channel \"${chan}\" with values ${JSON.stringify(\n              vals\n            )}: ${e.message}`\n          );\n          wrappedError.lc_error_code = e.lc_error_code;\n          throw wrappedError;\n        } else {\n          throw e;\n        }\n      }\n      if (updated && getNextVersion !== undefined) {\n        checkpoint.channel_versions[chan] = getNextVersion(maxVersion);\n\n        // unavailable channels can't trigger tasks, so don't add them\n        if (channel.isAvailable()) updatedChannels.add(chan);\n      }\n    }\n  }\n\n  // Channels that weren't updated in this step are notified of a new step\n  if (bumpStep) {\n    for (const chan in onlyChannels) {\n      if (!Object.prototype.hasOwnProperty.call(onlyChannels, chan)) continue;\n\n      const channel = onlyChannels[chan];\n      if (channel.isAvailable() && !updatedChannels.has(chan)) {\n        const updated = channel.update([]);\n\n        if (updated && getNextVersion !== undefined) {\n          checkpoint.channel_versions[chan] = getNextVersion(maxVersion);\n\n          // unavailable channels can't trigger tasks, so don't add them\n          if (channel.isAvailable()) updatedChannels.add(chan);\n        }\n      }\n    }\n  }\n\n  // If this is (tentatively) the last superstep, notify all channels of finish\n  if (bumpStep && !triggersNextStep(updatedChannels, triggerToNodes)) {\n    for (const chan in onlyChannels) {\n      if (!Object.prototype.hasOwnProperty.call(onlyChannels, chan)) continue;\n\n      const channel = onlyChannels[chan];\n      if (channel.finish() && getNextVersion !== undefined) {\n        checkpoint.channel_versions[chan] = getNextVersion(maxVersion);\n\n        // unavailable channels can't trigger tasks, so don't add them\n        if (channel.isAvailable()) updatedChannels.add(chan);\n      }\n    }\n  }\n\n  return updatedChannels;\n}\n\nfunction* candidateNodes(\n  checkpoint: ReadonlyCheckpoint,\n  processes: StrRecord<string, PregelNode>,\n  extra: NextTaskExtraFields\n) {\n  // This section is an optimization that allows which\n  // nodes will be active during the next step.\n  // When there's information about:\n  // 1. Which channels were updated in the previous step\n  // 2. Which nodes are triggered by which channels\n  // Then we can determine which nodes should be triggered\n  // in the next step without having to cycle through all nodes.\n  if (extra.updatedChannels != null && extra.triggerToNodes != null) {\n    const triggeredNodes = new Set<string>();\n\n    // Get all nodes that have triggers associated with an updated channel\n    for (const channel of extra.updatedChannels) {\n      const nodeIds = extra.triggerToNodes[channel];\n      for (const id of nodeIds ?? []) triggeredNodes.add(id);\n    }\n\n    // Sort the nodes to ensure deterministic order\n    yield* [...triggeredNodes].sort();\n    return;\n  }\n\n  // If there are no values in checkpoint, no need to run\n  // through all the PULL candidates\n  const isEmptyChannelVersions = (() => {\n    for (const chan in checkpoint.channel_versions) {\n      if (checkpoint.channel_versions[chan] !== null) return false;\n    }\n    return true;\n  })();\n\n  if (isEmptyChannelVersions) return;\n  for (const name in processes) {\n    if (!Object.prototype.hasOwnProperty.call(processes, name)) continue;\n    yield name;\n  }\n}\n\nexport type NextTaskExtraFields = {\n  step: number;\n  isResuming?: boolean;\n  checkpointer?: BaseCheckpointSaver;\n  manager?: CallbackManagerForChainRun;\n  store?: BaseStore;\n  stream?: IterableReadableWritableStream;\n  triggerToNodes?: Record<string, string[]>;\n  updatedChannels?: Set<string>;\n};\n\nexport type NextTaskExtraFieldsWithStore = NextTaskExtraFields & {\n  store?: BaseStore;\n};\n\nexport type NextTaskExtraFieldsWithoutStore = NextTaskExtraFields & {\n  store?: never;\n};\n\nexport function _prepareNextTasks<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: false,\n  extra: NextTaskExtraFieldsWithoutStore\n): Record<string, PregelTaskDescription>;\n\nexport function _prepareNextTasks<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: true,\n  extra: NextTaskExtraFieldsWithStore\n): Record<string, PregelExecutableTask<keyof Nn, keyof Cc>>;\n\n/**\n * Prepare the set of tasks that will make up the next Pregel step.\n * This is the union of all PUSH tasks (Sends) and PULL tasks (nodes triggered\n * by edges).\n */\nexport function _prepareNextTasks<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: [string, string, unknown][] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: boolean,\n  extra: NextTaskExtraFieldsWithStore | NextTaskExtraFieldsWithoutStore\n):\n  | Record<string, PregelTaskDescription>\n  | Record<string, PregelExecutableTask<keyof Nn, keyof Cc>> {\n  const tasks:\n    | Record<string, PregelExecutableTask<keyof Nn, keyof Cc>>\n    | Record<string, PregelTaskDescription> = {};\n\n  // Consume pending tasks\n  const tasksChannel = channels[TASKS] as Topic<SendProtocol> | undefined;\n\n  if (tasksChannel?.isAvailable()) {\n    const len = tasksChannel.get().length;\n    for (let i = 0; i < len; i += 1) {\n      const task = _prepareSingleTask(\n        [PUSH, i],\n        checkpoint,\n        pendingWrites,\n        processes,\n        channels,\n        config,\n        forExecution,\n        extra\n      );\n      if (task !== undefined) {\n        tasks[task.id] = task;\n      }\n    }\n  }\n\n  // Check if any processes should be run in next step\n  // If so, prepare the values to be passed to them\n  for (const name of candidateNodes(checkpoint, processes, extra)) {\n    const task = _prepareSingleTask(\n      [PULL, name],\n      checkpoint,\n      pendingWrites,\n      processes,\n      channels,\n      config,\n      forExecution,\n      extra\n    );\n    if (task !== undefined) {\n      tasks[task.id] = task;\n    }\n  }\n  return tasks;\n}\n\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: SimpleTaskPath,\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: CheckpointPendingWrite[] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: false,\n  extra: NextTaskExtraFields\n): PregelTaskDescription | undefined;\n\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: TaskPath,\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: CheckpointPendingWrite[] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: true,\n  extra: NextTaskExtraFields\n): PregelExecutableTask<keyof Nn, keyof Cc> | undefined;\n\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: TaskPath,\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: CheckpointPendingWrite[] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: RunnableConfig,\n  forExecution: boolean,\n  extra: NextTaskExtraFieldsWithStore\n): PregelTaskDescription | PregelExecutableTask<keyof Nn, keyof Cc> | undefined;\n\n/**\n * Prepares a single task for the next Pregel step, given a task path, which\n * uniquely identifies a PUSH or PULL task within the graph.\n */\nexport function _prepareSingleTask<\n  Nn extends StrRecord<string, PregelNode>,\n  Cc extends StrRecord<string, BaseChannel>\n>(\n  taskPath: TaskPath,\n  checkpoint: ReadonlyCheckpoint,\n  pendingWrites: CheckpointPendingWrite[] | undefined,\n  processes: Nn,\n  channels: Cc,\n  config: LangGraphRunnableConfig,\n  forExecution: boolean,\n  extra: NextTaskExtraFields\n):\n  | PregelTaskDescription\n  | PregelExecutableTask<keyof Nn, keyof Cc>\n  | undefined {\n  const { step, checkpointer, manager } = extra;\n  const configurable = config.configurable ?? {};\n  const parentNamespace = configurable.checkpoint_ns ?? \"\";\n\n  if (taskPath[0] === PUSH && isCall(taskPath[taskPath.length - 1])) {\n    const call = taskPath[taskPath.length - 1] as Call;\n    const proc = getRunnableForFunc(call.name, call.func);\n    const triggers = [PUSH];\n    const checkpointNamespace =\n      parentNamespace === \"\"\n        ? call.name\n        : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${call.name}`;\n    const id = uuid5(\n      JSON.stringify([\n        checkpointNamespace,\n        step.toString(),\n        call.name,\n        PUSH,\n        taskPath[1],\n        taskPath[2],\n      ]),\n      checkpoint.id\n    );\n    const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${id}`;\n\n    // we append `true` to the task path to indicate that a call is being made\n    // so we should not return interrupts from this task (responsibility lies with the parent)\n    const outputTaskPath = [...taskPath.slice(0, 3), true] as VariadicTaskPath;\n    const metadata = {\n      langgraph_step: step,\n      langgraph_node: call.name,\n      langgraph_triggers: triggers,\n      langgraph_path: outputTaskPath,\n      langgraph_checkpoint_ns: taskCheckpointNamespace,\n    };\n    if (forExecution) {\n      const writes: [keyof Cc, unknown][] = [];\n      const task = {\n        name: call.name,\n        input: call.input,\n        proc,\n        writes,\n        config: patchConfig(\n          mergeConfigs(config, {\n            metadata,\n            store: extra.store ?? config.store,\n          }),\n          {\n            runName: call.name,\n            callbacks: manager?.getChild(`graph:step:${step}`),\n            configurable: {\n              [CONFIG_KEY_TASK_ID]: id,\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              [CONFIG_KEY_SEND]: (writes_: PendingWrite[]) =>\n                _localWrite(\n                  (items: PendingWrite<keyof Cc>[]) => writes.push(...items),\n                  processes,\n                  writes_\n                ),\n              [CONFIG_KEY_READ]: (\n                select_: Array<keyof Cc> | keyof Cc,\n                fresh_: boolean = false\n              ) =>\n                _localRead(\n                  checkpoint,\n                  channels,\n                  {\n                    name: call.name,\n                    writes: writes as PendingWrite[],\n                    triggers,\n                    path: outputTaskPath,\n                  },\n                  select_,\n                  fresh_\n                ),\n              [CONFIG_KEY_CHECKPOINTER]:\n                checkpointer ?? configurable[CONFIG_KEY_CHECKPOINTER],\n              [CONFIG_KEY_CHECKPOINT_MAP]: {\n                ...configurable[CONFIG_KEY_CHECKPOINT_MAP],\n                [parentNamespace]: checkpoint.id,\n              },\n              [CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                pendingWrites: pendingWrites ?? [],\n                taskId: id,\n                currentTaskInput: call.input,\n                resumeMap: config.configurable?.[CONFIG_KEY_RESUME_MAP],\n                namespaceHash: XXH3(taskCheckpointNamespace),\n              }),\n              [CONFIG_KEY_PREVIOUS_STATE]: checkpoint.channel_values[PREVIOUS],\n              checkpoint_id: undefined,\n              checkpoint_ns: taskCheckpointNamespace,\n            },\n          }\n        ),\n        triggers,\n        retry_policy: call.retry,\n        cache_key: call.cache\n          ? {\n              key: XXH3((call.cache.keyFunc ?? JSON.stringify)([call.input])),\n              ns: [CACHE_NS_WRITES, call.name ?? \"__dynamic__\"],\n              ttl: call.cache.ttl,\n            }\n          : undefined,\n        id,\n        path: outputTaskPath,\n        writers: [],\n      } satisfies PregelExecutableTask<keyof Nn, keyof Cc>;\n      return task;\n    } else {\n      return {\n        id,\n        name: call.name,\n        interrupts: [],\n        path: outputTaskPath,\n      };\n    }\n  } else if (taskPath[0] === PUSH) {\n    const index =\n      typeof taskPath[1] === \"number\"\n        ? taskPath[1]\n        : parseInt(taskPath[1] as string, 10);\n\n    if (!channels[TASKS]?.isAvailable()) {\n      return undefined;\n    }\n\n    const sends = channels[TASKS].get() as SendProtocol[];\n    if (index < 0 || index >= sends.length) {\n      return undefined;\n    }\n\n    const packet =\n      _isSendInterface(sends[index]) && !_isSend(sends[index])\n        ? new Send(sends[index].node, sends[index].args)\n        : sends[index];\n\n    if (!_isSendInterface(packet)) {\n      console.warn(\n        `Ignoring invalid packet ${JSON.stringify(packet)} in pending sends.`\n      );\n      return undefined;\n    }\n    if (!(packet.node in processes)) {\n      console.warn(\n        `Ignoring unknown node name ${packet.node} in pending sends.`\n      );\n      return undefined;\n    }\n    const triggers = [PUSH];\n    const checkpointNamespace =\n      parentNamespace === \"\"\n        ? packet.node\n        : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${packet.node}`;\n    const taskId = uuid5(\n      JSON.stringify([\n        checkpointNamespace,\n        step.toString(),\n        packet.node,\n        PUSH,\n        index.toString(),\n      ]),\n      checkpoint.id\n    );\n    const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${taskId}`;\n    let metadata = {\n      langgraph_step: step,\n      langgraph_node: packet.node,\n      langgraph_triggers: triggers,\n      langgraph_path: taskPath.slice(0, 3),\n      langgraph_checkpoint_ns: taskCheckpointNamespace,\n    };\n    if (forExecution) {\n      const proc = processes[packet.node];\n      const node = proc.getNode();\n      if (node !== undefined) {\n        if (proc.metadata !== undefined) {\n          metadata = { ...metadata, ...proc.metadata };\n        }\n        const writes: [keyof Cc, unknown][] = [];\n        return {\n          name: packet.node,\n          input: packet.args,\n          proc: node,\n          subgraphs: proc.subgraphs,\n          writes,\n          config: patchConfig(\n            mergeConfigs(config, {\n              metadata,\n              tags: proc.tags,\n              store: extra.store ?? config.store,\n            }),\n            {\n              runName: packet.node,\n              callbacks: manager?.getChild(`graph:step:${step}`),\n              configurable: {\n                [CONFIG_KEY_TASK_ID]: taskId,\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                [CONFIG_KEY_SEND]: (writes_: PendingWrite[]) =>\n                  _localWrite(\n                    (items: PendingWrite<keyof Cc>[]) => writes.push(...items),\n                    processes,\n                    writes_\n                  ),\n                [CONFIG_KEY_READ]: (\n                  select_: Array<keyof Cc> | keyof Cc,\n                  fresh_: boolean = false\n                ) =>\n                  _localRead(\n                    checkpoint,\n                    channels,\n                    {\n                      name: packet.node,\n                      writes: writes as PendingWrite[],\n                      triggers,\n                      path: taskPath,\n                    },\n                    select_,\n                    fresh_\n                  ),\n                [CONFIG_KEY_CHECKPOINTER]:\n                  checkpointer ?? configurable[CONFIG_KEY_CHECKPOINTER],\n                [CONFIG_KEY_CHECKPOINT_MAP]: {\n                  ...configurable[CONFIG_KEY_CHECKPOINT_MAP],\n                  [parentNamespace]: checkpoint.id,\n                },\n                [CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                  pendingWrites: pendingWrites ?? [],\n                  taskId,\n                  currentTaskInput: packet.args,\n                  resumeMap: config.configurable?.[CONFIG_KEY_RESUME_MAP],\n                  namespaceHash: XXH3(taskCheckpointNamespace),\n                }),\n                [CONFIG_KEY_PREVIOUS_STATE]:\n                  checkpoint.channel_values[PREVIOUS],\n                checkpoint_id: undefined,\n                checkpoint_ns: taskCheckpointNamespace,\n              },\n            }\n          ),\n          triggers,\n          retry_policy: proc.retryPolicy,\n          cache_key: proc.cachePolicy\n            ? {\n                key: XXH3(\n                  (proc.cachePolicy.keyFunc ?? JSON.stringify)([packet.args])\n                ),\n                ns: [CACHE_NS_WRITES, proc.name ?? \"__dynamic__\", packet.node],\n                ttl: proc.cachePolicy.ttl,\n              }\n            : undefined,\n          id: taskId,\n          path: taskPath,\n          writers: proc.getWriters(),\n        } satisfies PregelExecutableTask<keyof Nn, keyof Cc>;\n      }\n    } else {\n      return {\n        id: taskId,\n        name: packet.node,\n        interrupts: [],\n        path: taskPath,\n      } satisfies PregelTaskDescription;\n    }\n  } else if (taskPath[0] === PULL) {\n    const name = taskPath[1].toString();\n    const proc = processes[name];\n    if (proc === undefined) {\n      return undefined;\n    }\n\n    // Check if this task already has successful writes in the pending writes\n    if (pendingWrites?.length) {\n      // Find the task ID for this node/path\n      const checkpointNamespace =\n        parentNamespace === \"\"\n          ? name\n          : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;\n\n      const taskId = uuid5(\n        JSON.stringify([\n          checkpointNamespace,\n          step.toString(),\n          name,\n          PULL,\n          name,\n        ]),\n        checkpoint.id\n      );\n\n      // Check if there are successful writes (not ERROR) for this task ID\n      const hasSuccessfulWrites = pendingWrites.some(\n        (w) => w[0] === taskId && w[1] !== ERROR\n      );\n\n      // If task completed successfully, don't include it in next tasks\n      if (hasSuccessfulWrites) {\n        return undefined;\n      }\n    }\n\n    const nullVersion = getNullChannelVersion(checkpoint.channel_versions);\n    if (nullVersion === undefined) {\n      return undefined;\n    }\n    const seen = checkpoint.versions_seen[name] ?? {};\n\n    // Find the first trigger that is available and has a new version\n    const trigger = proc.triggers.find((chan) => {\n      if (!channels[chan].isAvailable()) return false;\n\n      return (\n        (checkpoint.channel_versions[chan] ?? nullVersion) >\n        (seen[chan] ?? nullVersion)\n      );\n    });\n\n    // If any of the channels read by this process were updated\n    if (trigger !== undefined) {\n      const val = _procInput(proc, channels, forExecution);\n      if (val === undefined) {\n        return undefined;\n      }\n      const checkpointNamespace =\n        parentNamespace === \"\"\n          ? name\n          : `${parentNamespace}${CHECKPOINT_NAMESPACE_SEPARATOR}${name}`;\n      const taskId = uuid5(\n        JSON.stringify([\n          checkpointNamespace,\n          step.toString(),\n          name,\n          PULL,\n          [trigger],\n        ]),\n        checkpoint.id\n      );\n      const taskCheckpointNamespace = `${checkpointNamespace}${CHECKPOINT_NAMESPACE_END}${taskId}`;\n      let metadata = {\n        langgraph_step: step,\n        langgraph_node: name,\n        langgraph_triggers: [trigger],\n        langgraph_path: taskPath,\n        langgraph_checkpoint_ns: taskCheckpointNamespace,\n      };\n      if (forExecution) {\n        const node = proc.getNode();\n        if (node !== undefined) {\n          if (proc.metadata !== undefined) {\n            metadata = { ...metadata, ...proc.metadata };\n          }\n          const writes: [keyof Cc, unknown][] = [];\n          return {\n            name,\n            input: val,\n            proc: node,\n            subgraphs: proc.subgraphs,\n            writes,\n            config: patchConfig(\n              mergeConfigs(config, {\n                metadata,\n                tags: proc.tags,\n                store: extra.store ?? config.store,\n              }),\n              {\n                runName: name,\n                callbacks: manager?.getChild(`graph:step:${step}`),\n                configurable: {\n                  [CONFIG_KEY_TASK_ID]: taskId,\n                  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  [CONFIG_KEY_SEND]: (writes_: PendingWrite[]) =>\n                    _localWrite(\n                      (items: PendingWrite<keyof Cc>[]) => {\n                        writes.push(...items);\n                      },\n                      processes,\n                      writes_\n                    ),\n                  [CONFIG_KEY_READ]: (\n                    select_: Array<keyof Cc> | keyof Cc,\n                    fresh_: boolean = false\n                  ) =>\n                    _localRead(\n                      checkpoint,\n                      channels,\n                      {\n                        name,\n                        writes: writes as PendingWrite[],\n                        triggers: [trigger],\n                        path: taskPath,\n                      },\n                      select_,\n                      fresh_\n                    ),\n                  [CONFIG_KEY_CHECKPOINTER]:\n                    checkpointer ?? configurable[CONFIG_KEY_CHECKPOINTER],\n                  [CONFIG_KEY_CHECKPOINT_MAP]: {\n                    ...configurable[CONFIG_KEY_CHECKPOINT_MAP],\n                    [parentNamespace]: checkpoint.id,\n                  },\n                  [CONFIG_KEY_SCRATCHPAD]: _scratchpad({\n                    pendingWrites: pendingWrites ?? [],\n                    taskId,\n                    currentTaskInput: val,\n                    resumeMap: config.configurable?.[CONFIG_KEY_RESUME_MAP],\n                    namespaceHash: XXH3(taskCheckpointNamespace),\n                  }),\n                  [CONFIG_KEY_PREVIOUS_STATE]:\n                    checkpoint.channel_values[PREVIOUS],\n                  checkpoint_id: undefined,\n                  checkpoint_ns: taskCheckpointNamespace,\n                },\n              }\n            ),\n            triggers: [trigger],\n            retry_policy: proc.retryPolicy,\n            cache_key: proc.cachePolicy\n              ? {\n                  key: XXH3(\n                    (proc.cachePolicy.keyFunc ?? JSON.stringify)([val])\n                  ),\n                  ns: [CACHE_NS_WRITES, proc.name ?? \"__dynamic__\", name],\n                  ttl: proc.cachePolicy.ttl,\n                }\n              : undefined,\n            id: taskId,\n            path: taskPath,\n            writers: proc.getWriters(),\n          } satisfies PregelExecutableTask<keyof Nn, keyof Cc>;\n        }\n      } else {\n        return {\n          id: taskId,\n          name,\n          interrupts: [],\n          path: taskPath,\n        } satisfies PregelTaskDescription;\n      }\n    }\n  }\n  return undefined;\n}\n\n/**\n *  Function injected under CONFIG_KEY_READ in task config, to read current state.\n *  Used by conditional edges to read a copy of the state with reflecting the writes\n *  from that node only.\n *\n * @internal\n */\nfunction _procInput(\n  proc: PregelNode,\n  channels: StrRecord<string, BaseChannel>,\n  forExecution: boolean\n) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let val: any;\n\n  if (typeof proc.channels === \"object\" && !Array.isArray(proc.channels)) {\n    val = {};\n    for (const [k, chan] of Object.entries(proc.channels)) {\n      if (proc.triggers.includes(chan)) {\n        try {\n          val[k] = readChannel(channels, chan, false);\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e: any) {\n          if (e.name === EmptyChannelError.unminifiable_name) {\n            return undefined;\n          } else {\n            throw e;\n          }\n        }\n      } else if (chan in channels) {\n        try {\n          val[k] = readChannel(channels, chan, false);\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } catch (e: any) {\n          if (e.name === EmptyChannelError.unminifiable_name) {\n            continue;\n          } else {\n            throw e;\n          }\n        }\n      }\n    }\n  } else if (Array.isArray(proc.channels)) {\n    let successfulRead = false;\n    for (const chan of proc.channels) {\n      try {\n        val = readChannel(channels, chan, false);\n        successfulRead = true;\n        break;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      } catch (e: any) {\n        if (e.name === EmptyChannelError.unminifiable_name) {\n          continue;\n        } else {\n          throw e;\n        }\n      }\n    }\n    if (!successfulRead) {\n      return undefined;\n    }\n  } else {\n    throw new Error(\n      `Invalid channels type, expected list or dict, got ${proc.channels}`\n    );\n  }\n\n  // If the process has a mapper, apply it to the value\n  if (forExecution && proc.mapper !== undefined) {\n    val = proc.mapper(val);\n  }\n\n  return val;\n}\n\nfunction _scratchpad({\n  pendingWrites,\n  taskId,\n  currentTaskInput,\n  resumeMap,\n  namespaceHash,\n}: {\n  pendingWrites: CheckpointPendingWrite[];\n  taskId: string;\n  currentTaskInput: unknown;\n  resumeMap: Record<string, unknown> | undefined;\n  namespaceHash: string;\n}): PregelScratchpad {\n  const nullResume = pendingWrites.find(\n    ([writeTaskId, chan]) => writeTaskId === NULL_TASK_ID && chan === RESUME\n  )?.[2];\n\n  const resume = (() => {\n    const result = pendingWrites\n      .filter(\n        ([writeTaskId, chan]) => writeTaskId === taskId && chan === RESUME\n      )\n      .flatMap(([_writeTaskId, _chan, resume]) => resume);\n\n    if (resumeMap != null && namespaceHash in resumeMap) {\n      const mappedResume = resumeMap[namespaceHash];\n      result.push(mappedResume);\n    }\n\n    return result;\n  })();\n\n  const scratchpad = {\n    callCounter: 0,\n    interruptCounter: -1,\n    resume,\n    nullResume,\n    subgraphCounter: 0,\n    currentTaskInput,\n    consumeNullResume: () => {\n      if (scratchpad.nullResume) {\n        delete scratchpad.nullResume;\n        pendingWrites.splice(\n          pendingWrites.findIndex(\n            ([writeTaskId, chan]) =>\n              writeTaskId === NULL_TASK_ID && chan === RESUME\n          ),\n          1\n        );\n        return nullResume;\n      }\n\n      return undefined;\n    },\n  };\n  return scratchpad;\n}\n"],"mappings":"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"}