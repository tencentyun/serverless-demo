{"version":3,"sources":["../src/index.ts","../src/agent.ts","../src/utils.ts","../src/constant.ts","../src/types.ts"],"sourcesContent":["export * from \"./agent\";\n\nexport * from \"./types\";\n","import {\n  RunAgentInput,\n  Message,\n  BaseEvent,\n  EventType,\n  RunStartedEvent,\n  RunFinishedEvent,\n  RunErrorEvent,\n  TextMessageChunkEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  AbstractAgent,\n  AgentConfig,\n  UserMessage,\n  BinaryInputContent,\n  ThinkingStartEvent,\n  ThinkingTextMessageStartEvent,\n  ThinkingTextMessageContentEvent,\n  ThinkingTextMessageEndEvent,\n  ThinkingEndEvent,\n} from \"@ag-ui/client\";\nimport { Observable, Subscriber } from \"rxjs\";\nimport axios, { AxiosError, AxiosInstance } from \"axios\";\nimport { camelToSnakeKeys } from \"./utils\";\nimport { MIME_TYPES } from \"./constant\";\nimport {\n  AdpConfig,\n  AdpChatRequest,\n  AdpChunk,\n  ReplyMethod,\n  CurrentNodeStatus,\n  FileInfo,\n} from \"./types\";\nimport { randomUUID } from \"crypto\";\nimport { lke } from \"tencentcloud-sdk-nodejs-lke\";\n// import COS from \"cos-nodejs-sdk-v5\";\n\nexport class AdpAgentError extends Error {\n  code?: string;\n  constructor(message: string, code?: string) {\n    super(message);\n    this.name = \"AdpAgentError\";\n    if (code) this.code = code;\n  }\n}\n\nexport class AdpAgent extends AbstractAgent {\n  private reqAppClient: AxiosInstance;\n  private reqLkeClient: InstanceType<typeof lke.v20231130.Client>;\n  protected adpConfig: AdpConfig;\n\n  constructor(config: AgentConfig & { adpConfig: AdpConfig }) {\n    super(config);\n    this.adpConfig = config.adpConfig;\n    this.reqAppClient = axios.create({\n      baseURL:\n        this.adpConfig.request?.baseUrl || \"https://wss.lke.cloud.tencent.com\",\n    });\n    const LkeClient = lke.v20231130.Client;\n    this.reqLkeClient = new LkeClient({\n      credential: {\n        secretId:\n          this.adpConfig.credential?.secretId ||\n          process.env.TENCENTCLOUD_SECRETID,\n        secretKey:\n          this.adpConfig.credential?.secretKey ||\n          process.env.TENCENTCLOUD_SECRETKEY,\n        token:\n          this.adpConfig.credential?.token ||\n          process.env.TENCENTCLOUD_SESSIONTOKEN,\n      },\n    });\n  }\n\n  generateRequestBody({\n    message,\n    fileInfos,\n    runId,\n    threadId,\n    forwardedProps,\n  }: {\n    message: string;\n    fileInfos: FileInfo[];\n    runId: string;\n    threadId: string;\n    forwardedProps: Record<string, string>;\n  }): AdpChatRequest {\n    const requestBody: AdpChatRequest = {\n      incremental: true,\n      stream: \"enable\",\n      ...(this.adpConfig.request?.body || {}),\n      ...(forwardedProps || {}),\n\n      botAppKey:\n        this.adpConfig.appKey ||\n        this.adpConfig.request?.body?.botAppKey ||\n        process.env.ADP_APP_KEY!,\n      visitorBizId: forwardedProps?.visitorBizId || randomUUID(),\n      requestId: runId,\n      sessionId: threadId || randomUUID(),\n      content: message,\n      fileInfos,\n    };\n    return requestBody;\n  }\n\n  // @ts-ignore\n  run(input: RunAgentInput) {\n    return new Observable<BaseEvent>((subscriber) => {\n      this._run(subscriber, input);\n    });\n  }\n\n  private async _run(subscriber: Subscriber<BaseEvent>, input: RunAgentInput) {\n    try {\n      const { messages, runId, threadId, forwardedProps } = input;\n\n      subscriber.next({\n        type: EventType.RUN_STARTED,\n        runId,\n        threadId,\n      } as RunStartedEvent);\n\n      if (!this.adpConfig.appKey && !process.env.ADP_APP_KEY) {\n        throw new AdpAgentError(\n          \"ADP app key is required, check your env variables or config passed with the adapter\",\n          \"MISSING_APP_KEY\"\n        );\n      }\n\n      // try {\n      //   const historyRes = await this.reqLkeClient.GetMsgRecord({\n      //     SessionId: threadId,\n      //     Type: 5,\n      //     Count: this.adpConfig.historyCount || 30,\n      //   })\n      //   const histories = historyRes.Records;\n      //   if (histories) {\n\n      //   }\n      // } catch (e) {\n      //   throw new Error(`Get history failed: ${e}`);\n      // }\n\n      const { messages: docExtractedMessages, fileInfos } =\n        await extractDocuments(messages, this.adpConfig, this.reqLkeClient);\n      const { message, trimmed } =\n        convertAGUIMessagesToAdpMessages(docExtractedMessages);\n      if (!message) {\n        throw new AdpAgentError(\n          \"Message content format error, or empty content\",\n          \"INVALID_MESSAGE_CONTENT\"\n        );\n      }\n      if (trimmed > 0) {\n        subscriber.next({\n          type: EventType.RAW,\n          rawEvent: {\n            message: `ADP handles message history itself, so that a total of ${trimmed} messages before and including last assistant message will be trimmed.`,\n            type: \"warn\",\n          },\n        });\n      }\n\n      const requestBody: AdpChatRequest = this.generateRequestBody({\n        message,\n        fileInfos,\n        runId,\n        threadId,\n        forwardedProps,\n      });\n\n      // console.log(camelToSnakeKeys(requestBody));\n\n      const response = await this.reqAppClient.post(\n        this.adpConfig.request?.endpoint || \"/v1/qbot/chat/sse\",\n        camelToSnakeKeys(requestBody),\n        { responseType: \"stream\" }\n      );\n\n      const sseStream: ReadableStream<Uint8Array> = response.data;\n      let buffer = \"\";\n      let interruptRequested = false;\n      let thinkingStart = false;\n      let thinkingMessageSet = new Set<string>();\n\n      for await (const chunk of sseStream) {\n        buffer += chunk.toString();\n\n        const parts = buffer.split(\"\\n\\n\");\n        buffer = parts.pop() || \"\";\n\n        for (const part of parts) {\n          if (!part.trim()) continue;\n\n          const event = { data: \"\", event: \"\" };\n\n          for (const line of part.split(\"\\n\")) {\n            if (line.startsWith(\"data:\")) {\n              event.data += line.slice(5);\n            } else if (line.startsWith(\"event:\")) {\n              event.event = line.slice(6);\n            }\n          }\n\n          if (event.data) {\n            let data: AdpChunk;\n            try {\n              data = JSON.parse(event.data);\n            } catch (e) {\n              throw new AdpAgentError(\n                `ADP returned invalid data: ${event.data}`,\n                \"INVALID_DATA\"\n              );\n            }\n\n            switch (data.type) {\n              case \"reply\": {\n                // console.log(JSON.stringify(data, null, 2));\n\n                if (data.payload.is_from_self) {\n                  if (data.payload.is_evil) {\n                    throw new AdpAgentError(\n                      \"Message filtered by ADP\",\n                      \"FILTERED_MESSAGE\"\n                    );\n                  } else {\n                    continue;\n                  }\n                }\n                const messageId = data.payload.record_id;\n                const isFinal = data.payload.is_final;\n                data.payload.content = data.payload.content.replace(\n                  /\\\\n/g,\n                  \"\\n\\n\"\n                );\n\n                switch (data.payload.reply_method) {\n                  case ReplyMethod.LLM_REPLY: {\n                    subscriber.next({\n                      type: EventType.TEXT_MESSAGE_CHUNK,\n                      messageId,\n                      delta: data.payload.content,\n                    } as TextMessageChunkEvent);\n                    break;\n                  }\n                  case ReplyMethod.WORKFLOW_REPLY: {\n                    subscriber.next({\n                      type: EventType.TEXT_MESSAGE_CHUNK,\n                      messageId,\n                      delta: data.payload.content,\n                    } as TextMessageChunkEvent);\n                    if (\n                      isFinal &&\n                      data.payload.work_flow &&\n                      [\n                        CurrentNodeStatus.Pending,\n                        CurrentNodeStatus.Running,\n                      ].includes(data.payload.work_flow.current_node.Status)\n                    ) {\n                      subscriber.next({\n                        type: EventType.TOOL_CALL_START,\n                        toolCallId: data.payload.work_flow!.current_node.NodeID,\n                        toolCallName: `${data.payload.work_flow!.workflow_name}-${data.payload.work_flow!.current_node.NodeName}`,\n                        parentMessageId: messageId,\n                      } as ToolCallStartEvent);\n                      subscriber.next({\n                        type: EventType.TOOL_CALL_ARGS,\n                        toolCallId: data.payload.work_flow!.current_node.NodeID,\n                        delta:\n                          data.payload.work_flow!.current_node.Input || \"{}\",\n                      } as ToolCallArgsEvent);\n                      subscriber.next({\n                        type: EventType.TOOL_CALL_END,\n                        toolCallId: data.payload.work_flow!.current_node.NodeID,\n                      } as ToolCallEndEvent);\n                      interruptRequested = true;\n                    }\n                    break;\n                  }\n                  case ReplyMethod.WORKFLOW_EXECUTION_END: {\n                    subscriber.next({\n                      type: EventType.TOOL_CALL_RESULT,\n                      messageId,\n                      toolCallId: data.payload.work_flow!.current_node.NodeID,\n                      content: (data.payload.work_flow?.outputs || []).join(\n                        \"\\n\\n\"\n                      ),\n                    } as ToolCallResultEvent);\n                    subscriber.next({\n                      type: EventType.TEXT_MESSAGE_CHUNK,\n                      messageId,\n                      delta: data.payload.content,\n                    } as TextMessageChunkEvent);\n                    break;\n                  }\n                  default: {\n                    subscriber.next({\n                      type: EventType.TEXT_MESSAGE_CHUNK,\n                      messageId,\n                      delta: data.payload.content,\n                    } as TextMessageChunkEvent);\n                    break;\n                  }\n                }\n                break;\n              }\n              case \"thought\": {\n                const messageId = data.payload.record_id;\n                if (!thinkingStart) {\n                  thinkingStart = true;\n                  subscriber.next({\n                    type: EventType.THINKING_START,\n                    messageId,\n                  } as ThinkingStartEvent);\n                }\n                data.payload.procedures.forEach((procedure) => {\n                  if (!thinkingMessageSet.has(messageId)) {\n                    thinkingMessageSet.add(messageId);\n                    subscriber.next({\n                      type: EventType.THINKING_TEXT_MESSAGE_START,\n                      messageId,\n                      delta: procedure.debugging.content,\n                    } as ThinkingTextMessageStartEvent);\n                  } else {\n                    if (procedure.status === \"processing\") {\n                      subscriber.next({\n                        type: EventType.THINKING_TEXT_MESSAGE_CONTENT,\n                        messageId,\n                        delta: procedure.debugging.content,\n                      } as ThinkingTextMessageContentEvent);\n                    } else {\n                      thinkingMessageSet.delete(messageId);\n                      subscriber.next({\n                        type: EventType.THINKING_TEXT_MESSAGE_END,\n                        messageId,\n                      } as ThinkingTextMessageEndEvent);\n                    }\n                  }\n                });\n                const allFinished = data.payload.procedures.every(\n                  (procedure) => procedure.status !== \"processing\"\n                );\n                if (allFinished) {\n                  thinkingStart = false;\n                  thinkingMessageSet.clear();\n                  subscriber.next({\n                    type: EventType.THINKING_END,\n                    messageId,\n                  } as ThinkingEndEvent);\n                }\n                break;\n              }\n              case \"error\": {\n                console.error(JSON.stringify(data));\n                throw new AdpAgentError(\n                  data.error.message,\n                  `ADP_ERROR_${data.error.code}` || \"ADP_ERROR_0\"\n                );\n              }\n              case \"token_stat\": {\n                console.debug(JSON.stringify(data));\n                break;\n              }\n              case \"reference\": {\n                // TODO: Reference event\n                break;\n              }\n              default: {\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      if (interruptRequested) {\n        subscriber.next({\n          type: EventType.RUN_FINISHED,\n          runId,\n          threadId,\n          outcome: \"interrupt\",\n          interrupt: {},\n        } as RunFinishedEvent);\n      } else {\n        subscriber.next({\n          type: EventType.RUN_FINISHED,\n          threadId,\n          runId,\n        } as RunFinishedEvent);\n      }\n      subscriber.complete();\n    } catch (e: unknown) {\n      console.error(JSON.stringify(e));\n      let code = \"UNKNOWN_ERROR\";\n      let message = JSON.stringify(e);\n      if (e instanceof AxiosError) {\n        code = e.code || \"REQUEST_ERROR\";\n        message = e.message;\n      } else if (e instanceof AdpAgentError) {\n        code = e.code || \"AGENT_ERROR\";\n        message = e.message;\n      }\n      subscriber.next({\n        type: EventType.RUN_ERROR,\n        code,\n        message: `Sorry, an error occurred while running the agent: Error code ${code}, ${message}`,\n      } as RunErrorEvent);\n      subscriber.complete();\n    }\n  }\n}\n\nfunction convertAGUIMessagesToAdpMessages(messages: Message[]): {\n  message: string;\n  trimmed: number;\n} {\n  let result = \"\";\n  let trimmed = messages.length;\n  for (const message of messages.reverse()) {\n    if (message.role === \"assistant\") {\n      break;\n    }\n    if (message.role === \"user\") {\n      trimmed--;\n      let content = \"\";\n      if (typeof message.content === \"string\") {\n        content = message.content;\n      } else {\n        content = message.content\n          .reduce((acc, cur) => {\n            if (cur.type === \"text\") {\n              return acc + `${cur.text} `;\n            } else if (cur.type === \"binary\") {\n              // TODO: Upload to COS\n              return acc + `![${cur.filename}](${cur.url}) `;\n            } else {\n              return acc;\n            }\n          }, \"\")\n          .trim();\n      }\n      result = `${message.role}: ${content}\\n${result}`;\n    } else {\n      result = `${message.role}: ${message.content}\\n${result}`;\n    }\n  }\n  return { message: result.trim(), trimmed };\n}\n\nasync function extractDocuments(\n  messages: Message[],\n  config: AdpConfig,\n  reqLkeClient: InstanceType<typeof lke.v20231130.Client>\n) {\n  // Document Parse\n  const documentFiles: BinaryInputContent[] = [];\n  const newMessages = messages.map((msg) => {\n    if (msg.role === \"user\" && Array.isArray(msg.content)) {\n      let newContent: UserMessage[\"content\"] = [];\n      msg.content.forEach((item) => {\n        if (item.type === \"text\") {\n          newContent.push(item);\n        } else if (item.type === \"binary\") {\n          if (Object.keys(MIME_TYPES).includes(item.mimeType)) {\n            documentFiles.push(item);\n          }\n        }\n      });\n      return {\n        ...msg,\n        content: newContent,\n      };\n    } else return msg;\n  });\n  const documentAddresses = [];\n  const fileInfos: FileInfo[] = [];\n  // if (documentFiles.length) {\n  //   try {\n  //     const bizIdRes = await reqLkeClient.DescribeRobotBizIDByAppKey({\n  //       AppKey: config.appKey || process.env.ADP_APP_KEY!,\n  //     });\n  //     const storageCredRes = await reqLkeClient.DescribeStorageCredential({\n  //       BotBizId: bizIdRes.BotBizId,\n  //     });\n  //     const cosCredId = storageCredRes.Credentials?.TmpSecretId;\n  //     const cosCredKey = storageCredRes.Credentials?.TmpSecretKey;\n  //     const cosClient = new COS({\n  //       SecretId: cosCredId,\n  //       SecretKey: cosCredKey,\n  //       SessionToken: storageCredRes.Credentials?.SessionToken,\n  //     });\n  //     for (const file of documentFiles) {\n  //     }\n  //   } catch (e) {}\n  // }\n  return {\n    messages: newMessages,\n    fileInfos,\n  };\n}\n\nfunction getCosCredentialParams(extName: string) {}\n","/**\n * 将小驼峰字符串转换为下划线格式\n * 例如: \"userName\" -> \"user_name\"\n */\nfunction camelToSnake(str: string): string {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\n\n/**\n * 递归地将对象的所有小驼峰属性名转换为下划线格式\n */\nexport function camelToSnakeKeys<T>(obj: T): T {\n  if (obj === null || obj === undefined) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map((item) => camelToSnakeKeys(item)) as T;\n  }\n\n  if (typeof obj === \"object\") {\n    const result: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(obj)) {\n      const snakeKey = camelToSnake(key);\n      result[snakeKey] = camelToSnakeKeys(value);\n    }\n    return result as T;\n  }\n\n  return obj;\n}\n","export const MIME_TYPES = {\n  \"text/plain\": \"txt\",\n  \"application/msword\": \"doc\",\n  \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\":\n    \"docx\",\n  \"application/pdf\": \"pdf\",\n  \"application/vnd.ms-powerpoint\": \"ppt\",\n  \"application/vnd.openxmlformats-officedocument.presentationml.presentation\":\n    \"pptx\",\n};\n","/**\n * 文件信息\n */\nexport interface FileInfo {\n  /** 文件名称 */\n  fileName: string;\n\n  /** 文件大小（实时文档解析接口返回） */\n  fileSize: string;\n\n  /** 文件 URL（实时文档解析接口返回） */\n  fileUrl: string;\n\n  /** 文件类型 */\n  fileType: string;\n\n  /** 文档 ID（实时文档解析接口返回） */\n  docId: string;\n\n  /** 扩展参数 */\n  [key: string]: any;\n}\n\n/**\n * ADP 对话请求参数\n */\nexport interface AdpChatRequest {\n  /** 请求 ID，用于标识一个请求 */\n  requestId?: string;\n\n  /** 消息内容 */\n  content: string;\n\n  /** 文件信息 */\n  fileInfos?: FileInfo[];\n\n  /** 会话 ID，用于标识一个会话 */\n  sessionId: string;\n\n  /** 应用密钥 */\n  botAppKey: string;\n\n  /** 访客 ID，标识当前接入会话的用户 */\n  visitorBizId: string;\n\n  /** 流式回复频率控制，控制应用回包频率 */\n  streamingThrottle?: number;\n\n  /** 自定义参数，用于传递参数给工作流或设置知识库检索范围 */\n  customVariables?: Record<string, string>;\n\n  /** 角色指令（提示词） */\n  systemRole?: string;\n\n  /** 控制回复事件和思考事件中的 content 是否是增量输出 */\n  incremental?: boolean;\n\n  /** 是否开启联网搜索：空字符串-跟随配置 / enable / disable */\n  searchNetwork?: \"\" | \"enable\" | \"disable\";\n\n  /** 指定模型名称 */\n  modelName?: string;\n\n  /** 是否开启流式传输：空字符串-跟随配置 / enable / disable */\n  stream?: \"\" | \"enable\" | \"disable\";\n\n  /** 是否开启工作流：空字符串-跟随配置 / enable / disable */\n  workflowStatus?: \"\" | \"enable\" | \"disable\";\n\n  /** 扩展参数 */\n  [key: string]: any;\n}\n\nexport type AdpConfig = {\n  request?: {\n    baseUrl?: string;\n    endpoint?: string;\n    body?: Partial<AdpChatRequest>;\n  };\n  historyCount?: number;\n  appKey?: string;\n  credential?: {\n    secretId?: string;\n    secretKey?: string;\n    token?: string;\n  };\n};\n\nexport type AdpChunk =\n  | { type: \"reply\"; payload: ReplyEvent; message_id: string }\n  | { type: \"thought\"; payload: ThoughtEvent; message_id: string }\n  | { type: \"token_stat\"; payload: TokenStatEvent; message_id: string }\n  | { type: \"reference\"; payload: ReferenceEvent; message_id: string }\n  | { type: \"error\"; error: ErrorInfo };\n\n// 回复事件类型定义\nexport interface ReplyEvent {\n  request_id: string; // 请求 ID，用于标识一个请求\n  content: string; // 消息内容\n  file_infos: FileInfo[]; // 文件信息\n  record_id: string; // 消息唯一 ID\n  related_record_id: string; // 关联的消息唯一 ID\n  session_id: string; // 会话 ID\n  is_from_self: boolean; // 消息是否由自己发出\n  can_rating: boolean; // 该消息记录是否能评价\n  timestamp: number; // 消息时间戳（秒级）\n  is_final: boolean; // 消息是否已输出完\n  is_evil: boolean; // 是否命中敏感内容\n  is_llm_generated: boolean; // 是否为模型生成内容\n  reply_method: ReplyMethod; // 回复方式\n  knowledge?: Knowledge[]; // 命中的知识\n  option_cards?: string[]; // 选项卡，任务流程专有\n  custom_params?: string[]; // 用户自定义业务参数\n  task_flow?: TaskFlow; // 任务流程调试信息\n  work_flow?: WorkFlow; // 工作流调试信息\n  quote_infos?: QuoteInfo[]; // 引用信息\n}\n\n// 回复方式枚举\nexport enum ReplyMethod {\n  LLM_REPLY = 1,\n  UNKNOWN_QUESTION_REPLY = 2,\n  REJECT_QUESTION_REPLY = 3,\n  SENSITIVE_REPLY = 4,\n  ADOPTED_QA_PRIORITY_REPLY = 5,\n  WELCOME_REPLY = 6,\n  CONCURRENCY_LIMIT_REPLY = 7,\n  GLOBAL_INTERVENTION_KNOWLEDGE = 8,\n  TASK_FLOW_REPLY = 9,\n  TASK_FLOW_ANSWER = 10,\n  SEARCH_ENGINE_REPLY = 11,\n  KNOWLEDGE_POLISHED_REPLY = 12,\n  IMAGE_UNDERSTANDING_REPLY = 13,\n  REALTIME_DOCUMENT_REPLY = 14,\n  CLARIFICATION_CONFIRMATION_REPLY = 15,\n  WORKFLOW_REPLY = 16,\n  WORKFLOW_EXECUTION_END = 17,\n  AGENT_REPLY = 18,\n  MULTI_INTENT_REPLY = 19,\n}\n\n// 命中的知识类型\nexport interface Knowledge {\n  id: string; // 命中的知识 ID\n  type: number; // 命中的知识类型: 1: 问答, 2: 文档片段\n  seg_id?: string; // 片段 ID\n}\n\n// 任务流调试信息\nexport interface TaskFlow {\n  task_flow_name: string; // 任务流程名称\n  task_flow_id: string; // 任务流程 ID\n  query_rewrite: string; // 问题改写结果\n  hit_intent: string; // 命中的意图\n  slot_info: Record<string, any>; // 运行时收集的槽位信息\n  api_response: Record<string, any>; // API 节点的返回信息\n  type: number; // 任务流程回复类型\n}\n\n// 工作流调试信息\nexport interface WorkFlow {\n  workflow_name: string; // 工作流名称\n  workflow_id: string; // 工作流ID\n  workflow_run_id: string; // 工作流运行ID\n  option_cards: string[]; // 选项卡\n  current_node: CurrentNode; // 当前节点信息\n  outputs: Array<string>; // 输出结果\n}\n\nexport enum CurrentNodeStatus {\n  Pending = 0,\n  Running = 1,\n  Succeeded = 2,\n  Failed = 3,\n}\n\n// 当前工作流节点信息\nexport interface CurrentNode {\n  NodeID: string; // 节点ID\n  NodeType: number; // 节点类型\n  NodeName: string; // 节点名称\n  Status: CurrentNodeStatus; // 状态\n  Input: string; // 节点的输入\n  Output: string; // 节点的最终输出\n  TaskOutput: string; // 任务的输出\n  FailMessage: string; // 异常信息\n  CostMilliSeconds: string; // 节点的总耗时\n  Reply: string; // 当前节点的回复内容\n  BelongNodeID: string; // 节点所属工作流被引用时的引用节点的ID\n  StatisticInfo: StatisticInfo; // LLM 统计信息\n}\n\n// LLM 统计信息\nexport interface StatisticInfo {\n  ModelName: string; // 模型名称\n  FirstTokenCost: number; // 首token耗时\n  TotalCost: number; // 推理总耗时\n  InputTokens: number; // 输入token数量\n  OutputTokens: number; // 输出token数量\n  TotalTokens: number; // 输入+输出总token\n}\n\n// 引用信息\nexport interface QuoteInfo {\n  index: number; // 引用的角标索引\n  position: number; // 在回复内容中的位置\n}\n\n// token统计事件类型定义\nexport interface TokenStatEvent {\n  session_id: string; // 会话 id\n  request_id: string; // 对应发送事件对应的请求 id\n  record_id: string; // 对应发送事件对应的消息记录 id\n  status_summary: \"processing\" | \"success\" | \"failed\"; // 本轮对话状态\n  status_summary_title: string; // 本轮对话状态描述\n  elapsed: number; // 本轮调用耗时, 单位 ms\n  token_count: number; // 本轮请求消耗 token 数\n  procedures: TokenStatProcedure[]; // 调用过程列表\n}\n\n// token统计调用过程\nexport interface TokenStatProcedure {\n  name: string; // 英文名\n  title: string; // 调用过程描述\n  status: \"processing\" | \"success\" | \"failed\"; // 调用过程状态\n  input_count: number; // 当次过程输入消耗 token 数\n  output_count: number; // 当次过程输出消耗 token 数\n  count: number; // 当次过程消耗总 token 数\n}\n\n// 参考来源事件类型定义\nexport interface ReferenceEvent {\n  record_id: string; // 消息唯一 ID\n  references: Reference[]; // 参考来源\n}\n\n// 参考来源\nexport interface Reference {\n  id: string | number; // 参考来源ID\n  type: number; // 参考来源类型: 1：问答, 2：文档片段, 4：联网检索到的内容\n  url?: string; // 参考来源链接（仅参考来源类型为文档片段时使用）\n  name: string; // 参考来源名称\n  doc_id: number; // 参考来源文档 ID\n  doc_biz_id: number; // 参考来源文档业务 ID\n  doc_name: string; // 参考来源文档名称\n  qa_biz_id: string; // 参考来源问答业务 ID\n}\n\n// 错误信息\nexport interface ErrorInfo {\n  code: number; // 错误码\n  message: string; // 错误信息\n}\n\n// 思考事件类型定义\nexport interface ThoughtEvent {\n  elapsed: number; // 本轮调用耗时, 单位 ms\n  is_workflow: boolean; // 是否工作流\n  procedures: ThoughtProcedure[]; // 调用过程列表\n  record_id: string; // 对应发送事件对应的消息记录 id\n  request_id: string; // 对应发送事件对应的请求 id\n  session_id: string; // 会话 id\n  trace_id: string; // 链路 id\n  workflow_name: string; // 工作流名称\n}\n\n// 思考调用过程\nexport interface ThoughtProcedure {\n  debugging: Debugging; // 调试过程信息\n  index: number; // 过程索引\n  name: string; // 英文名\n  title: string; // 调用过程描述\n  status: \"processing\" | \"success\" | \"failed\"; // 状态\n  icon: string; // 图标\n  switch: string; // 是否切换Agent\n  workflow_name: string; // 工作流名称\n  plugin_type: number; // 插件类型: 0: 自定义插件; 1: 官方插件; 2: 工作流\n  elapsed: number; // 当前请求执行时间, 单位 ms\n}\n\n// 调试过程信息\nexport interface Debugging {\n  content: string; // 调试过程中输出的内容\n}\n"],"mappings":"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","names":["ReplyMethod","CurrentNodeStatus","axios"]}