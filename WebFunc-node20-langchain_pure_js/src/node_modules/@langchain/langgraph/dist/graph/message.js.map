{"version":3,"file":"message.js","names":[],"sources":["../../src/graph/message.ts"],"sourcesContent":["import {\n  BaseMessage,\n  BaseMessageLike,\n  coerceMessageLikeToMessage,\n} from \"@langchain/core/messages\";\nimport type { RunnableConfig } from \"@langchain/core/runnables\";\nimport { StateGraph } from \"./state.js\";\nimport { ensureLangGraphConfig } from \"../pregel/utils/config.js\";\nimport type { StreamMessagesHandler } from \"../pregel/messages.js\";\nimport { messagesStateReducer, type Messages } from \"./messages_reducer.js\";\n\n/** @ignore */\nexport class MessageGraph extends StateGraph<\n  BaseMessage[],\n  BaseMessage[],\n  Messages\n> {\n  constructor() {\n    super({\n      channels: {\n        __root__: {\n          reducer: messagesStateReducer,\n          default: () => [],\n        },\n      },\n    });\n  }\n}\n\n/**\n * Manually push a message to a message stream.\n *\n * This is useful when you need to push a manually created message before the node\n * has finished executing.\n *\n * When a message is pushed, it will be automatically persisted to the state after the node has finished executing.\n * To disable persisting, set `options.stateKey` to `null`.\n *\n * @param message The message to push. The message must have an ID set, otherwise an error will be thrown.\n * @param options RunnableConfig / Runtime coming from node context.\n */\nexport function pushMessage(\n  message: BaseMessage | BaseMessageLike,\n  options?: RunnableConfig & {\n    /**\n     * The key of the state to push the message to. Set to `null` to avoid persisting.\n     * @default \"messages\"\n     */\n    stateKey?: string | null;\n  }\n) {\n  const { stateKey: userStateKey, ...userConfig } = options ?? {};\n  const config = ensureLangGraphConfig(userConfig);\n\n  let stateKey: string | undefined = userStateKey ?? \"messages\";\n  if (userStateKey === null) stateKey = undefined;\n\n  // coerce to message\n  const validMessage = coerceMessageLikeToMessage(message);\n  if (!validMessage.id) throw new Error(\"Message ID is required.\");\n\n  const callbacks = (() => {\n    if (Array.isArray(config.callbacks)) {\n      return config.callbacks;\n    }\n\n    if (typeof config.callbacks !== \"undefined\") {\n      return config.callbacks.handlers;\n    }\n\n    return [];\n  })();\n\n  const messagesHandler = callbacks.find(\n    (cb): cb is StreamMessagesHandler =>\n      \"name\" in cb && cb.name === \"StreamMessagesHandler\"\n  );\n\n  if (messagesHandler) {\n    const metadata = config.metadata ?? {};\n    const namespace = (\n      (metadata.langgraph_checkpoint_ns ?? \"\") as string\n    ).split(\"|\");\n\n    messagesHandler._emit(\n      [namespace, metadata],\n      validMessage,\n      undefined,\n      false\n    );\n  }\n\n  if (stateKey) {\n    config.configurable?.__pregel_send?.([[stateKey, validMessage]]);\n  }\n\n  return validMessage;\n}\n"],"mappings":";;;;;;;AAYA,IAAa,eAAb,cAAkC,WAIhC;CACA,cAAc;AACZ,QAAM,EACJ,UAAU,EACR,UAAU;GACR,SAAS;GACT,eAAe,EAAE;GAClB,EACF,EACF,CAAC;;;;;;;;;;;;;;;AAgBN,SAAgB,YACd,SACA,SAOA;CACA,MAAM,EAAE,UAAU,cAAc,GAAG,eAAe,WAAW,EAAE;CAC/D,MAAM,SAAS,sBAAsB,WAAW;CAEhD,IAAI,WAA+B,gBAAgB;AACnD,KAAI,iBAAiB,KAAM,YAAW;CAGtC,MAAM,eAAe,2BAA2B,QAAQ;AACxD,KAAI,CAAC,aAAa,GAAI,OAAM,IAAI,MAAM,0BAA0B;CAchE,MAAM,yBAZmB;AACvB,MAAI,MAAM,QAAQ,OAAO,UAAU,CACjC,QAAO,OAAO;AAGhB,MAAI,OAAO,OAAO,cAAc,YAC9B,QAAO,OAAO,UAAU;AAG1B,SAAO,EAAE;KACP,CAE8B,MAC/B,OACC,UAAU,MAAM,GAAG,SAAS,wBAC/B;AAED,KAAI,iBAAiB;EACnB,MAAM,WAAW,OAAO,YAAY,EAAE;EACtC,MAAM,aACH,SAAS,2BAA2B,IACrC,MAAM,IAAI;AAEZ,kBAAgB,MACd,CAAC,WAAW,SAAS,EACrB,cACA,QACA,MACD;;AAGH,KAAI,SACF,QAAO,cAAc,gBAAgB,CAAC,CAAC,UAAU,aAAa,CAAC,CAAC;AAGlE,QAAO"}