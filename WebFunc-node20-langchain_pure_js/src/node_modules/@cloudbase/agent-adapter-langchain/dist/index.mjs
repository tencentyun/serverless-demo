// src/store/tdai.ts
import { BaseStore } from "@langchain/core/stores";
var TDAIStore = class extends BaseStore {
  constructor(fields) {
    super();
    this.lc_namespace = ["langchain", "storage", "tdai"];
    this.yieldKeysScanBatchSize = 1e3;
    this.client = fields.client;
    this.namespace = fields.namespace;
    this.yieldKeysScanBatchSize = fields.yieldKeysScanBatchSize ?? this.yieldKeysScanBatchSize;
    this.defaultSessionId = fields.defaultSessionId ?? "langchain_store_session";
    this.defaultStrategy = fields.defaultStrategy ?? "kv_cache";
    this.ttlSeconds = fields.ttlSeconds;
  }
  /**
   * Get prefixed key with namespace
   */
  _getPrefixedKey(key) {
    if (this.namespace) {
      const delimiter = "/";
      return `${this.namespace}${delimiter}${key}`;
    }
    return key;
  }
  /**
   * Remove prefix from key
   */
  _getDeprefixedKey(key) {
    if (this.namespace) {
      const delimiter = "/";
      return key.slice(this.namespace.length + delimiter.length);
    }
    return key;
  }
  /**
   * Get or create session for the store
   */
  async _getSession() {
    if (this.sessionCache) {
      return this.sessionCache;
    }
    try {
      const sessions = await this.client.querySessions({
        limit: 1
      });
      if (sessions.sessions && sessions.sessions.length > 0) {
        this.sessionCache = sessions.sessions[0].sessionId;
      } else {
        const result = await this.client.createSession({
          name: `langchain_store_${this.namespace || "default"}`
        });
        this.sessionCache = result.sessionId;
      }
      return this.sessionCache;
    } catch (error) {
      return this.defaultSessionId;
    }
  }
  /**
   * Create record content for storage
   */
  _createRecordContent(key, value) {
    const decoder = new TextDecoder();
    const content = {
      key: this._getPrefixedKey(key),
      value: decoder.decode(value),
      timestamp: Date.now(),
      ttl: this.ttlSeconds
    };
    return JSON.stringify(content);
  }
  /**
   * Parse record content from storage
   */
  _parseRecordContent(content) {
    try {
      const data = JSON.parse(content);
      const encoder = new TextEncoder();
      if (data.ttl && data.timestamp) {
        const now = Date.now();
        if (now > data.timestamp + data.ttl * 1e3) {
          return null;
        }
      }
      return {
        key: data.key,
        value: encoder.encode(data.value),
        timestamp: data.timestamp,
        ttl: data.ttl
      };
    } catch (error) {
      return null;
    }
  }
  /**
   * Gets multiple keys from the TDAI store.
   * @param keys Array of keys to be retrieved.
   * @returns An array of retrieved values.
   */
  async mget(keys) {
    if (keys.length === 0) {
      return [];
    }
    try {
      const sessionId = await this._getSession();
      const results = new Array(keys.length);
      for (let i = 0; i < keys.length; i++) {
        const prefixedKey = this._getPrefixedKey(keys[i]);
        try {
          const searchResult = await this.client.searchRecords({
            content: prefixedKey,
            sessionId,
            strategies: [this.defaultStrategy],
            limit: 1
          });
          if (searchResult.records && searchResult.records.length > 0) {
            const record = searchResult.records[0];
            const parsed = this._parseRecordContent(record.record_content);
            if (parsed && parsed.key === prefixedKey) {
              results[i] = parsed.value;
            } else {
              results[i] = void 0;
            }
          } else {
            results[i] = void 0;
          }
        } catch (error) {
          results[i] = void 0;
        }
      }
      return results;
    } catch (error) {
      return new Array(keys.length).fill(void 0);
    }
  }
  /**
   * Sets multiple keys in the TDAI store.
   * @param keyValuePairs Array of key-value pairs to be set.
   * @returns Promise that resolves when all keys have been set.
   */
  async mset(keyValuePairs) {
    if (keyValuePairs.length === 0) {
      return;
    }
    try {
      const sessionId = await this._getSession();
      for (const [key, value] of keyValuePairs) {
        const content = this._createRecordContent(key, value);
        try {
          await this.client.appendRecord({
            sessionId,
            content,
            strategy: this.defaultStrategy
          });
        } catch (error) {
          console.warn(`Failed to set key ${key}:`, error);
        }
      }
    } catch (error) {
      throw new Error(`Failed to set keys: ${error}`);
    }
  }
  /**
   * Deletes multiple keys from the TDAI store.
   * @param keys Array of keys to be deleted.
   * @returns Promise that resolves when all keys have been deleted.
   */
  async mdelete(keys) {
    if (keys.length === 0) {
      return;
    }
    try {
      const sessionId = await this._getSession();
      for (const key of keys) {
        const prefixedKey = this._getPrefixedKey(key);
        try {
          const searchResult = await this.client.searchRecords({
            content: prefixedKey,
            sessionId,
            strategies: [this.defaultStrategy],
            limit: 1
          });
          if (searchResult.records && searchResult.records.length > 0) {
            const record = searchResult.records[0];
            await this.client.deleteRecord({
              sessionId,
              recordId: record.record_id
            });
          }
        } catch (error) {
          console.warn(`Failed to delete key ${key}:`, error);
        }
      }
    } catch (error) {
      throw new Error(`Failed to delete keys: ${error}`);
    }
  }
  /**
   * Yields keys from the TDAI store.
   * @param prefix Optional prefix to filter the keys.
   * @returns An AsyncGenerator that yields keys from the TDAI store.
   */
  async *yieldKeys(prefix) {
    try {
      const sessionId = await this._getSession();
      let offset = 0;
      let hasMore = true;
      while (hasMore) {
        try {
          const result = await this.client.queryRecords({
            sessionId,
            strategies: [this.defaultStrategy],
            limit: this.yieldKeysScanBatchSize,
            offset
          });
          if (!result.records || result.records.length === 0) {
            hasMore = false;
            break;
          }
          for (const record of result.records) {
            const parsed = this._parseRecordContent(record.record_content);
            if (parsed) {
              const deprefixedKey = this._getDeprefixedKey(parsed.key);
              if (!prefix || deprefixedKey.startsWith(prefix)) {
                yield deprefixedKey;
              }
            }
          }
          offset += result.records.length;
          if (result.records.length < this.yieldKeysScanBatchSize) {
            hasMore = false;
          }
        } catch (error) {
          console.warn(`Error yielding keys at offset ${offset}:`, error);
          hasMore = false;
        }
      }
    } catch (error) {
      console.warn("Error yielding keys:", error);
    }
  }
  /**
   * Close the TDAI client connection
   */
  close() {
    this.client.close();
  }
};

// src/tool.ts
import { tool as langChainTool } from "@langchain/core/tools";
import {
  tool as agKitTool,
  ToolResult
} from "@cloudbase/agent-tools";
import { z } from "zod/v4";
function convert2LangChain(agkitTool, implFunc) {
  const func = implFunc || (async (input) => {
    const result = await agkitTool.invoke(input);
    return result;
  });
  return langChainTool(func, {
    name: agkitTool.name,
    description: agkitTool.description || agkitTool.name,
    schema: agkitTool.schema || z.object({})
  });
}
function convertLangChain2AGKit(langchainTool) {
  const func = async (input, context) => {
    try {
      const result = await langchainTool.invoke(input);
      return new ToolResult({
        success: true,
        data: result
      });
    } catch (error) {
      return new ToolResult({
        success: false,
        error: error instanceof Error ? error.message : String(error),
        error_type: "execution"
      });
    }
  };
  return agKitTool(func, {
    name: langchainTool.name,
    description: langchainTool.description || langchainTool.name,
    schema: langchainTool.schema || z.object({})
  });
}

// src/agent.ts
import { z as z2 } from "zod/v3";
import { LanggraphAgent } from "@cloudbase/agent-adapter-langgraph";
import { createMiddleware } from "langchain";
import { AIMessage } from "@langchain/core/messages";
import { END } from "@langchain/langgraph";
var LangchainAgent = class extends LanggraphAgent {
  constructor(config) {
    super({
      ...config,
      compiledWorkflow: config.agent,
      adapterName: "LangChain"
    });
  }
};
function clientTools() {
  return createMiddleware({
    name: "ClientTools",
    stateSchema: z2.object({
      client: z2.object({
        tools: z2.array(
          z2.object({
            name: z2.string(),
            description: z2.string(),
            schema: z2.any()
          })
        )
      })
    }),
    // Add frontend tools to LLM's tool list
    wrapModelCall: (request, handler) => {
      const clientToolsList = (request.state.client?.tools || []).map((tool) => {
        const { name, description, schema } = tool;
        return { name, description, schema };
      });
      return handler({
        ...request,
        tools: [...request.tools || [], ...clientToolsList]
      });
    },
    // After model: check if all tool calls are frontend actions
    // If so, skip ToolNode by jumping to END
    // Note: #createAfterModelRouter does direct comparison (jumpTo === END),
    // NOT using parseJumpToTarget(), so we must use the actual END constant.
    // Using "as any" to bypass TypeScript type mismatch (bug in langchain types).
    afterModel: {
      canJumpTo: [END],
      hook: (state) => {
        const messages = state.messages || [];
        const lastMessage = messages.at(-1);
        if (!AIMessage.isInstance(lastMessage)) return;
        if (!lastMessage.tool_calls || lastMessage.tool_calls.length === 0)
          return;
        const clientToolNames = new Set(
          (state.client?.tools || []).map((t) => t.name)
        );
        if (clientToolNames.size === 0) return;
        const anyClientTool = lastMessage.tool_calls.some(
          (call) => clientToolNames.has(call.name)
        );
        if (anyClientTool) {
          return { jumpTo: END };
        }
        return;
      }
    }
  });
}

// src/chat_history.ts
import { BaseListChatMessageHistory } from "@langchain/core/chat_history";
import {
  mapStoredMessagesToChatMessages,
  mapChatMessagesToStoredMessages
} from "@langchain/core/messages";
import { MemoryClient } from "@cloudbase/agent-agents";
var TDAIChatHistory = class extends BaseListChatMessageHistory {
  constructor(options) {
    super();
    this.lc_namespace = ["langchain", "stores", "message", "tdai"];
    const { sessionId, ...clientOptions } = options;
    this.client = new MemoryClient({
      ...clientOptions
    });
    this.sessionId = options.sessionId;
  }
  async getMessages() {
    const { events = [] } = await this.client.queryEvents({
      sessionId: this.sessionId
    });
    return mapStoredMessagesToChatMessages(
      events.map((event) => {
        return {
          type: event.type,
          data: event.data
        };
      })
    );
  }
  /**
   * Method to add a new message to the Firestore collection. The message is
   * passed as a BaseMessage object.
   * @param message The message to be added as a BaseMessage object.
   */
  async addMessage(message) {
    const messages = mapChatMessagesToStoredMessages([message]);
    await this.appendMessage(messages[0]);
  }
  async appendMessage(message) {
    await this.client.appendEvent({
      sessionId: this.sessionId,
      messages: message
    });
  }
  /**
   * Method to delete all messages from the Firestore collection associated
   * with the current session.
   */
  async clear() {
    const eventIds = await this.client.queryEvents({
      sessionId: this.sessionId
    }).then(({ events = [] }) => events.map((event) => event.event_id));
    await Promise.all(
      eventIds.map((id) => {
        return this.client.deleteEvent({
          sessionId: this.sessionId,
          eventId: id
        });
      })
    );
    await this.client.deleteSession({
      sessionId: this.sessionId
    });
  }
};
export {
  LangchainAgent,
  TDAIChatHistory,
  TDAIStore,
  clientTools,
  convert2LangChain,
  convertLangChain2AGKit
};
//# sourceMappingURL=index.mjs.map