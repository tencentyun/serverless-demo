{"version":3,"file":"json.js","names":["s: string","arr: unknown[]","obj: Record<string, unknown>"],"sources":["../../src/utils/json.ts"],"sourcesContent":["export function parseJsonMarkdown(s: string, parser = parsePartialJson) {\n  // eslint-disable-next-line no-param-reassign\n  s = s.trim();\n\n  const firstFenceIndex = s.indexOf(\"```\");\n  if (firstFenceIndex === -1) {\n    return parser(s);\n  }\n\n  let contentAfterFence = s.substring(firstFenceIndex + 3);\n\n  if (contentAfterFence.startsWith(\"json\\n\")) {\n    contentAfterFence = contentAfterFence.substring(5);\n  } else if (contentAfterFence.startsWith(\"json\")) {\n    contentAfterFence = contentAfterFence.substring(4);\n  } else if (contentAfterFence.startsWith(\"\\n\")) {\n    contentAfterFence = contentAfterFence.substring(1);\n  }\n\n  const closingFenceIndex = contentAfterFence.indexOf(\"```\");\n  let finalContent = contentAfterFence;\n  if (closingFenceIndex !== -1) {\n    finalContent = contentAfterFence.substring(0, closingFenceIndex);\n  }\n\n  return parser(finalContent.trim());\n}\n\n/**\n * Recursive descent partial JSON parser.\n * @param s - The string to parse.\n * @returns The parsed value.\n * @throws Error if the input is a malformed JSON string.\n */\nexport function strictParsePartialJson(s: string): unknown {\n  try {\n    return JSON.parse(s);\n  } catch {\n    // Continue to partial parsing\n  }\n\n  const buffer = s.trim();\n  if (buffer.length === 0) throw new Error(\"Unexpected end of JSON input\");\n\n  let pos = 0;\n\n  function skipWhitespace(): void {\n    while (pos < buffer.length && /\\s/.test(buffer[pos])) {\n      pos += 1;\n    }\n  }\n\n  function parseString(): string {\n    if (buffer[pos] !== '\"') {\n      throw new Error(`Expected '\"' at position ${pos}, got '${buffer[pos]}'`);\n    }\n\n    pos += 1;\n    let result = \"\";\n    let escaped = false;\n\n    while (pos < buffer.length) {\n      const char = buffer[pos];\n\n      if (escaped) {\n        if (char === \"n\") {\n          result += \"\\n\";\n        } else if (char === \"t\") {\n          result += \"\\t\";\n        } else if (char === \"r\") {\n          result += \"\\r\";\n        } else if (char === \"\\\\\") {\n          result += \"\\\\\";\n        } else if (char === '\"') {\n          result += '\"';\n        } else if (char === \"b\") {\n          result += \"\\b\";\n        } else if (char === \"f\") {\n          result += \"\\f\";\n        } else if (char === \"/\") {\n          result += \"/\";\n        } else if (char === \"u\") {\n          const hex = buffer.substring(pos + 1, pos + 5);\n          if (/^[0-9A-Fa-f]{0,4}$/.test(hex)) {\n            if (hex.length === 4) {\n              result += String.fromCharCode(Number.parseInt(hex, 16));\n            } else {\n              result += `u${hex}`;\n            }\n\n            pos += hex.length;\n          } else {\n            throw new Error(\n              `Invalid unicode escape sequence '\\\\u${hex}' at position ${pos}`\n            );\n          }\n        } else {\n          throw new Error(\n            `Invalid escape sequence '\\\\${char}' at position ${pos}`\n          );\n        }\n        escaped = false;\n      } else if (char === \"\\\\\") {\n        escaped = true;\n      } else if (char === '\"') {\n        pos += 1;\n        return result;\n      } else {\n        result += char;\n      }\n\n      pos += 1;\n    }\n\n    if (escaped) result += \"\\\\\";\n    return result;\n  }\n\n  function parseNumber(): number {\n    const start = pos;\n    let numStr = \"\";\n\n    if (buffer[pos] === \"-\") {\n      numStr += \"-\";\n      pos += 1;\n    }\n\n    if (pos < buffer.length && buffer[pos] === \"0\") {\n      numStr += \"0\";\n      pos += 1;\n\n      if (buffer[pos] >= \"0\" && buffer[pos] <= \"9\") {\n        throw new Error(`Invalid number at position ${start}`);\n      }\n    }\n\n    if (pos < buffer.length && buffer[pos] >= \"1\" && buffer[pos] <= \"9\") {\n      while (pos < buffer.length && buffer[pos] >= \"0\" && buffer[pos] <= \"9\") {\n        numStr += buffer[pos];\n        pos += 1;\n      }\n    }\n\n    if (pos < buffer.length && buffer[pos] === \".\") {\n      numStr += \".\";\n      pos += 1;\n      while (pos < buffer.length && buffer[pos] >= \"0\" && buffer[pos] <= \"9\") {\n        numStr += buffer[pos];\n        pos += 1;\n      }\n    }\n\n    if (pos < buffer.length && (buffer[pos] === \"e\" || buffer[pos] === \"E\")) {\n      numStr += buffer[pos];\n      pos += 1;\n      if (pos < buffer.length && (buffer[pos] === \"+\" || buffer[pos] === \"-\")) {\n        numStr += buffer[pos];\n        pos += 1;\n      }\n      while (pos < buffer.length && buffer[pos] >= \"0\" && buffer[pos] <= \"9\") {\n        numStr += buffer[pos];\n        pos += 1;\n      }\n    }\n\n    if (numStr === \"-\") return -0;\n\n    const num = Number.parseFloat(numStr);\n\n    if (Number.isNaN(num)) {\n      pos = start;\n      throw new Error(`Invalid number '${numStr}' at position ${start}`);\n    }\n\n    return num;\n  }\n\n  function parseValue(): unknown {\n    skipWhitespace();\n\n    if (pos >= buffer.length) {\n      throw new Error(`Unexpected end of input at position ${pos}`);\n    }\n\n    const char = buffer[pos];\n\n    if (char === \"{\") return parseObject();\n    if (char === \"[\") return parseArray();\n    if (char === '\"') return parseString();\n\n    if (\"null\".startsWith(buffer.substring(pos, pos + 4))) {\n      pos += Math.min(4, buffer.length - pos);\n      return null;\n    }\n\n    if (\"true\".startsWith(buffer.substring(pos, pos + 4))) {\n      pos += Math.min(4, buffer.length - pos);\n      return true;\n    }\n\n    if (\"false\".startsWith(buffer.substring(pos, pos + 5))) {\n      pos += Math.min(5, buffer.length - pos);\n      return false;\n    }\n\n    if (char === \"-\" || (char >= \"0\" && char <= \"9\")) {\n      return parseNumber();\n    }\n\n    throw new Error(`Unexpected character '${char}' at position ${pos}`);\n  }\n\n  function parseArray(): unknown[] {\n    if (buffer[pos] !== \"[\") {\n      throw new Error(`Expected '[' at position ${pos}, got '${buffer[pos]}'`);\n    }\n\n    const arr: unknown[] = [];\n\n    pos += 1;\n    skipWhitespace();\n\n    if (pos >= buffer.length) return arr;\n    if (buffer[pos] === \"]\") {\n      pos += 1;\n      return arr;\n    }\n\n    while (pos < buffer.length) {\n      skipWhitespace();\n      if (pos >= buffer.length) return arr;\n\n      arr.push(parseValue());\n\n      skipWhitespace();\n      if (pos >= buffer.length) return arr;\n\n      if (buffer[pos] === \"]\") {\n        pos += 1;\n        return arr;\n      } else if (buffer[pos] === \",\") {\n        pos += 1;\n        continue;\n      }\n\n      throw new Error(\n        `Expected ',' or ']' at position ${pos}, got '${buffer[pos]}'`\n      );\n    }\n\n    return arr;\n  }\n\n  function parseObject(): Record<string, unknown> {\n    if (buffer[pos] !== \"{\") {\n      throw new Error(`Expected '{' at position ${pos}, got '${buffer[pos]}'`);\n    }\n\n    const obj: Record<string, unknown> = {};\n    pos += 1;\n    skipWhitespace();\n\n    if (pos >= buffer.length) return obj;\n    if (buffer[pos] === \"}\") {\n      pos += 1;\n      return obj;\n    }\n\n    while (pos < buffer.length) {\n      skipWhitespace();\n      if (pos >= buffer.length) return obj;\n\n      const key = parseString();\n\n      skipWhitespace();\n      if (pos >= buffer.length) return obj;\n\n      if (buffer[pos] !== \":\") {\n        throw new Error(\n          `Expected ':' at position ${pos}, got '${buffer[pos]}'`\n        );\n      }\n      pos += 1;\n\n      skipWhitespace();\n      if (pos >= buffer.length) return obj;\n\n      obj[key] = parseValue();\n\n      skipWhitespace();\n      if (pos >= buffer.length) return obj;\n\n      if (buffer[pos] === \"}\") {\n        pos += 1;\n        return obj;\n      } else if (buffer[pos] === \",\") {\n        pos += 1;\n        continue;\n      }\n\n      throw new Error(\n        `Expected ',' or '}' at position ${pos}, got '${buffer[pos]}'`\n      );\n    }\n\n    return obj;\n  }\n\n  const value = parseValue();\n  skipWhitespace();\n\n  if (pos < buffer.length) {\n    throw new Error(`Unexpected character '${buffer[pos]}' at position ${pos}`);\n  }\n\n  return value;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function parsePartialJson(s: string): any | null {\n  // Attempt to parse the modified string as JSON.\n  try {\n    if (typeof s === \"undefined\") return null;\n    return strictParsePartialJson(s);\n  } catch {\n    // If we still can't parse the string as JSON, return null to indicate failure.\n    return null;\n  }\n}\n"],"mappings":"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"}