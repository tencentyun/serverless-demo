{"version":3,"file":"base.cjs","names":["x: BaseCallbackHandler","get_lc_unique_name","getEnvironmentVariable","input?: BaseCallbackHandlerInput","Serializable","methods: CallbackHandlerMethods","x: unknown"],"sources":["../../src/callbacks/base.ts"],"sourcesContent":["import * as uuid from \"uuid\";\nimport type { ChainValues } from \"../utils/types/index.js\";\nimport type { BaseMessage } from \"../messages/base.js\";\nimport type { AgentAction, AgentFinish } from \"../agents.js\";\nimport type {\n  ChatGenerationChunk,\n  GenerationChunk,\n  LLMResult,\n} from \"../outputs.js\";\nimport {\n  Serializable,\n  Serialized,\n  SerializedNotImplemented,\n  get_lc_unique_name,\n} from \"../load/serializable.js\";\nimport type { SerializedFields } from \"../load/map_keys.js\";\nimport type { DocumentInterface } from \"../documents/document.js\";\nimport { getEnvironmentVariable } from \"../utils/env.js\";\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Error = any;\n\n/**\n * Interface for the input parameters of the BaseCallbackHandler class. It\n * allows to specify which types of events should be ignored by the\n * callback handler.\n */\nexport interface BaseCallbackHandlerInput {\n  ignoreLLM?: boolean;\n  ignoreChain?: boolean;\n  ignoreAgent?: boolean;\n  ignoreRetriever?: boolean;\n  ignoreCustomEvent?: boolean;\n  _awaitHandler?: boolean;\n  raiseError?: boolean;\n}\n\n/**\n * Interface for the indices of a new token produced by an LLM or Chat\n * Model in streaming mode.\n */\nexport interface NewTokenIndices {\n  prompt: number;\n  completion: number;\n}\n\n// TODO: Add all additional callback fields here\nexport type HandleLLMNewTokenCallbackFields = {\n  chunk?: GenerationChunk | ChatGenerationChunk;\n};\n\n/**\n * Abstract class that provides a set of optional methods that can be\n * overridden in derived classes to handle various events during the\n * execution of a LangChain application.\n */\nabstract class BaseCallbackHandlerMethodsClass {\n  /**\n   * Called at the start of an LLM or Chat Model run, with the prompt(s)\n   * and the run ID.\n   */\n  handleLLMStart?(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: Record<string, unknown>,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called when an LLM/ChatModel in `streaming` mode produces a new token\n   */\n  handleLLMNewToken?(\n    token: string,\n    /**\n     * idx.prompt is the index of the prompt that produced the token\n     *   (if there are multiple prompts)\n     * idx.completion is the index of the completion that produced the token\n     *   (if multiple completions per prompt are requested)\n     */\n    idx: NewTokenIndices,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    fields?: HandleLLMNewTokenCallbackFields\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called if an LLM/ChatModel run encounters an error\n   */\n  handleLLMError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the end of an LLM/ChatModel run, with the output and the run ID.\n   */\n  handleLLMEnd?(\n    output: LLMResult,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    extraParams?: Record<string, unknown>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the start of a Chat Model run, with the prompt(s)\n   * and the run ID.\n   */\n  handleChatModelStart?(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string,\n    extraParams?: Record<string, unknown>,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the start of a Chain run, with the chain name and inputs\n   * and the run ID.\n   */\n  handleChainStart?(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    runType?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runName?: string,\n    parentRunId?: string,\n    extra?: Record<string, unknown>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called if a Chain run encounters an error\n   */\n  handleChainError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the end of a Chain run, with the outputs and the run ID.\n   */\n  handleChainEnd?(\n    outputs: ChainValues,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    kwargs?: { inputs?: Record<string, unknown> }\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the start of a Tool run, with the tool name and input\n   * and the run ID.\n   */\n  handleToolStart?(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    runName?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called if a Tool run encounters an error\n   */\n  handleToolError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  /**\n   * Called at the end of a Tool run, with the tool output and the run ID.\n   */\n  handleToolEnd?(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    output: any,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleText?(\n    text: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): Promise<void> | void;\n\n  /**\n   * Called when an agent is about to execute an action,\n   * with the action and the run ID.\n   */\n  handleAgentAction?(\n    action: AgentAction,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): Promise<void> | void;\n\n  /**\n   * Called when an agent finishes execution, before it exits.\n   * with the final output and the run ID.\n   */\n  handleAgentEnd?(\n    action: AgentFinish,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): Promise<void> | void;\n\n  handleRetrieverStart?(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[],\n    metadata?: Record<string, unknown>,\n    name?: string\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleRetrieverEnd?(\n    documents: DocumentInterface[],\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleRetrieverError?(\n    err: Error,\n    runId: string,\n    parentRunId?: string,\n    tags?: string[]\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n\n  handleCustomEvent?(\n    eventName: string,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    data: any,\n    runId: string,\n    tags?: string[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    metadata?: Record<string, any>\n  ): // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  Promise<any> | any;\n}\n\n/**\n * Base interface for callbacks. All methods are optional. If a method is not\n * implemented, it will be ignored. If a method is implemented, it will be\n * called at the appropriate time. All methods are called with the run ID of\n * the LLM/ChatModel/Chain that is running, which is generated by the\n * CallbackManager.\n *\n * @interface\n */\nexport type CallbackHandlerMethods = BaseCallbackHandlerMethodsClass;\n\n/**\n * Interface for handlers that can indicate a preference for streaming responses.\n * When implemented, this allows the handler to signal whether it prefers to receive\n * streaming responses from language models rather than complete responses.\n */\nexport interface CallbackHandlerPrefersStreaming {\n  readonly lc_prefer_streaming: boolean;\n}\n\nexport function callbackHandlerPrefersStreaming(x: BaseCallbackHandler) {\n  return \"lc_prefer_streaming\" in x && x.lc_prefer_streaming;\n}\n\n/**\n * Abstract base class for creating callback handlers in the LangChain\n * framework. It provides a set of optional methods that can be overridden\n * in derived classes to handle various events during the execution of a\n * LangChain application.\n */\nexport abstract class BaseCallbackHandler\n  extends BaseCallbackHandlerMethodsClass\n  implements BaseCallbackHandlerInput, Serializable\n{\n  lc_serializable = false;\n\n  get lc_namespace(): [\"langchain_core\", \"callbacks\", string] {\n    return [\"langchain_core\", \"callbacks\", this.name];\n  }\n\n  get lc_secrets(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  get lc_attributes(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  get lc_aliases(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  get lc_serializable_keys(): string[] | undefined {\n    return undefined;\n  }\n\n  /**\n   * The name of the serializable. Override to provide an alias or\n   * to preserve the serialized module name in minified environments.\n   *\n   * Implemented as a static method to support loading logic.\n   */\n  static lc_name(): string {\n    return this.name;\n  }\n\n  /**\n   * The final serialized identifier for the module.\n   */\n  get lc_id(): string[] {\n    return [\n      ...this.lc_namespace,\n      get_lc_unique_name(this.constructor as typeof BaseCallbackHandler),\n    ];\n  }\n\n  lc_kwargs: SerializedFields;\n\n  abstract name: string;\n\n  ignoreLLM = false;\n\n  ignoreChain = false;\n\n  ignoreAgent = false;\n\n  ignoreRetriever = false;\n\n  ignoreCustomEvent = false;\n\n  raiseError = false;\n\n  awaitHandlers =\n    getEnvironmentVariable(\"LANGCHAIN_CALLBACKS_BACKGROUND\") === \"false\";\n\n  constructor(input?: BaseCallbackHandlerInput) {\n    super();\n    this.lc_kwargs = input || {};\n    if (input) {\n      this.ignoreLLM = input.ignoreLLM ?? this.ignoreLLM;\n      this.ignoreChain = input.ignoreChain ?? this.ignoreChain;\n      this.ignoreAgent = input.ignoreAgent ?? this.ignoreAgent;\n      this.ignoreRetriever = input.ignoreRetriever ?? this.ignoreRetriever;\n      this.ignoreCustomEvent =\n        input.ignoreCustomEvent ?? this.ignoreCustomEvent;\n      this.raiseError = input.raiseError ?? this.raiseError;\n      this.awaitHandlers =\n        this.raiseError || (input._awaitHandler ?? this.awaitHandlers);\n    }\n  }\n\n  copy(): BaseCallbackHandler {\n    return new (this.constructor as new (\n      input?: BaseCallbackHandlerInput\n    ) => BaseCallbackHandler)(this);\n  }\n\n  toJSON(): Serialized {\n    return Serializable.prototype.toJSON.call(this);\n  }\n\n  toJSONNotImplemented(): SerializedNotImplemented {\n    return Serializable.prototype.toJSONNotImplemented.call(this);\n  }\n\n  static fromMethods(methods: CallbackHandlerMethods) {\n    class Handler extends BaseCallbackHandler {\n      name = uuid.v7();\n\n      constructor() {\n        super();\n        Object.assign(this, methods);\n      }\n    }\n    return new Handler();\n  }\n}\n\nexport const isBaseCallbackHandler = (x: unknown) => {\n  const callbackHandler = x as BaseCallbackHandler;\n  return (\n    callbackHandler !== undefined &&\n    typeof callbackHandler.copy === \"function\" &&\n    typeof callbackHandler.name === \"string\" &&\n    typeof callbackHandler.awaitHandlers === \"boolean\"\n  );\n};\n"],"mappings":";;;;;;;;;;;;;;;;;AAwDA,IAAe,kCAAf,MAA+C,CA6N9C;AAsBD,SAAgB,gCAAgCA,GAAwB;AACtE,QAAO,yBAAyB,KAAK,EAAE;AACxC;;;;;;;AAQD,IAAsB,sBAAtB,cACU,gCAEV;CACE,kBAAkB;CAElB,IAAI,eAAwD;AAC1D,SAAO;GAAC;GAAkB;GAAa,KAAK;EAAK;CAClD;CAED,IAAI,aAAoD;AACtD,SAAO;CACR;CAED,IAAI,gBAAuD;AACzD,SAAO;CACR;CAED,IAAI,aAAoD;AACtD,SAAO;CACR;CAED,IAAI,uBAA6C;AAC/C,SAAO;CACR;;;;;;;CAQD,OAAO,UAAkB;AACvB,SAAO,KAAK;CACb;;;;CAKD,IAAI,QAAkB;AACpB,SAAO,CACL,GAAG,KAAK,cACRC,6CAAmB,KAAK,YAA0C,AACnE;CACF;CAED;CAIA,YAAY;CAEZ,cAAc;CAEd,cAAc;CAEd,kBAAkB;CAElB,oBAAoB;CAEpB,aAAa;CAEb,gBACEC,yCAAuB,iCAAiC,KAAK;CAE/D,YAAYC,OAAkC;EAC5C,OAAO;EACP,KAAK,YAAY,SAAS,CAAE;AAC5B,MAAI,OAAO;GACT,KAAK,YAAY,MAAM,aAAa,KAAK;GACzC,KAAK,cAAc,MAAM,eAAe,KAAK;GAC7C,KAAK,cAAc,MAAM,eAAe,KAAK;GAC7C,KAAK,kBAAkB,MAAM,mBAAmB,KAAK;GACrD,KAAK,oBACH,MAAM,qBAAqB,KAAK;GAClC,KAAK,aAAa,MAAM,cAAc,KAAK;GAC3C,KAAK,gBACH,KAAK,eAAe,MAAM,iBAAiB,KAAK;EACnD;CACF;CAED,OAA4B;AAC1B,SAAO,IAAK,KAAK,YAES;CAC3B;CAED,SAAqB;AACnB,SAAOC,uCAAa,UAAU,OAAO,KAAK,KAAK;CAChD;CAED,uBAAiD;AAC/C,SAAOA,uCAAa,UAAU,qBAAqB,KAAK,KAAK;CAC9D;CAED,OAAO,YAAYC,SAAiC;EAClD,MAAM,gBAAgB,oBAAoB;GACxC,OAAO,KAAK,IAAI;GAEhB,cAAc;IACZ,OAAO;IACP,OAAO,OAAO,MAAM,QAAQ;GAC7B;EACF;AACD,SAAO,IAAI;CACZ;AACF;AAED,MAAa,wBAAwB,CAACC,MAAe;CACnD,MAAM,kBAAkB;AACxB,QACE,oBAAoB,UACpB,OAAO,gBAAgB,SAAS,cAChC,OAAO,gBAAgB,SAAS,YAChC,OAAO,gBAAgB,kBAAkB;AAE5C"}