{"version":3,"file":"index.cjs","names":["BaseLangChain","fields?: ToolParams","input: TInput","config?: TConfig","toolInput: Exclude<\n      StructuredToolCallInput<SchemaT, SchemaInputT>,\n      ToolCall\n    >","enrichedConfig: ToolRunnableConfig","ensureConfig","mergeConfigs","_isToolCall","arg: TArg","configArg?: TConfig","tags?: string[]","parsed: SchemaOutputT","isInteropZodSchema","interopParseAsync","isInteropZodError","z4","ToolInputParsingException","result","parseCallbackConfigArg","CallbackManager","toolCallId: string | undefined","_configHasToolCallId","z","callbacks?: TConfig","fields: DynamicToolInput<ToolOutputT>","input: string","runManager?: CallbackManagerForToolRun","parentConfig?: ToolRunnableConfig","fields: DynamicStructuredToolInput<SchemaT, SchemaOutputT, ToolOutputT>","arg: Parameters<\n      DynamicStructuredToolInput<SchemaT, SchemaOutputT>[\"func\"]\n    >[0]","parentConfig?: RunnableConfig","func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>","fields: ToolWrapperParams<SchemaT>","isSimpleStringZodSchema","validatesOnlyStrings","patchConfig","AsyncLocalStorageProviderSingleton","pickRunnableConfigKeys","listener: (() => void) | undefined","getAbortSignalError","params: {\n  content: TOutput;\n  name: string;\n  artifact?: unknown;\n  toolCallId?: string;\n  metadata?: Record<string, unknown>;\n}","isDirectToolOutput","ToolMessage","content: unknown"],"sources":["../../src/tools/index.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport { z as z4, ZodError } from \"zod/v4\";\nimport {\n  validate,\n  type Schema as ValidationSchema,\n} from \"@cfworker/json-schema\";\nimport {\n  CallbackManager,\n  CallbackManagerForToolRun,\n  parseCallbackConfigArg,\n} from \"../callbacks/manager.js\";\nimport { BaseLangChain } from \"../language_models/base.js\";\nimport {\n  mergeConfigs,\n  ensureConfig,\n  patchConfig,\n  pickRunnableConfigKeys,\n  type RunnableConfig,\n} from \"../runnables/config.js\";\nimport type { RunnableFunc } from \"../runnables/base.js\";\nimport { isDirectToolOutput, ToolCall, ToolMessage } from \"../messages/tool.js\";\nimport { AsyncLocalStorageProviderSingleton } from \"../singletons/index.js\";\nimport type { RunnableToolLike } from \"../runnables/base.js\";\nimport {\n  _configHasToolCallId,\n  _isToolCall,\n  ToolInputParsingException,\n} from \"./utils.js\";\nimport {\n  type InferInteropZodInput,\n  type InferInteropZodOutput,\n  type InteropZodObject,\n  type InteropZodType,\n  interopParseAsync,\n  isSimpleStringZodSchema,\n  isInteropZodError,\n  isInteropZodSchema,\n  type ZodStringV3,\n  type ZodStringV4,\n  type ZodObjectV3,\n  type ZodObjectV4,\n} from \"../utils/types/zod.js\";\nimport { getAbortSignalError } from \"../utils/signal.js\";\nimport type {\n  StructuredToolCallInput,\n  ToolInputSchemaBase,\n  ToolReturnType,\n  ResponseFormat,\n  ToolInputSchemaInputType,\n  ToolInputSchemaOutputType,\n  ToolParams,\n  ToolRunnableConfig,\n  StructuredToolInterface,\n  DynamicToolInput,\n  DynamicStructuredToolInput,\n  StringInputToolSchema,\n  ToolInterface,\n  ToolOutputType,\n  ToolRuntime,\n} from \"./types.js\";\nimport { type JSONSchema, validatesOnlyStrings } from \"../utils/json_schema.js\";\n\nexport type {\n  BaseDynamicToolInput,\n  ContentAndArtifact,\n  DynamicToolInput,\n  DynamicStructuredToolInput,\n  ResponseFormat,\n  StructuredToolCallInput,\n  StructuredToolInterface,\n  StructuredToolParams,\n  ToolInterface,\n  ToolParams,\n  ToolReturnType,\n  ToolRunnableConfig,\n  ToolInputSchemaBase as ToolSchemaBase,\n} from \"./types.js\";\n\nexport {\n  isLangChainTool,\n  isRunnableToolLike,\n  isStructuredTool,\n  isStructuredToolParams,\n  type ToolRuntime,\n} from \"./types.js\";\n\nexport { ToolInputParsingException };\n/**\n * Base class for Tools that accept input of any shape defined by a Zod schema.\n */\nexport abstract class StructuredTool<\n    SchemaT = ToolInputSchemaBase,\n    SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n    SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n    ToolOutputT = ToolOutputType\n  >\n  extends BaseLangChain<\n    StructuredToolCallInput<SchemaT, SchemaInputT>,\n    ToolOutputT | ToolMessage\n  >\n  implements StructuredToolInterface<SchemaT, SchemaInputT, ToolOutputT>\n{\n  abstract name: string;\n\n  abstract description: string;\n\n  abstract schema: SchemaT;\n\n  /**\n   * Optional provider-specific extra fields for the tool.\n   *\n   * This is used to pass provider-specific configuration that doesn't fit into\n   * standard tool fields.\n   */\n  extras?: Record<string, unknown>;\n\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect = false;\n\n  verboseParsingErrors = false;\n\n  get lc_namespace() {\n    return [\"langchain\", \"tools\"];\n  }\n\n  /**\n   * The tool response format.\n   *\n   * If \"content\" then the output of the tool is interpreted as the contents of a\n   * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n   * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n   *\n   * @default \"content\"\n   */\n  responseFormat?: ResponseFormat = \"content\";\n\n  /**\n   * Default config object for the tool runnable.\n   */\n  defaultConfig?: ToolRunnableConfig;\n\n  constructor(fields?: ToolParams) {\n    super(fields ?? {});\n\n    this.verboseParsingErrors =\n      fields?.verboseParsingErrors ?? this.verboseParsingErrors;\n    this.responseFormat = fields?.responseFormat ?? this.responseFormat;\n    this.defaultConfig = fields?.defaultConfig ?? this.defaultConfig;\n    this.metadata = fields?.metadata ?? this.metadata;\n    this.extras = fields?.extras ?? this.extras;\n  }\n\n  protected abstract _call(\n    arg: SchemaOutputT,\n    runManager?: CallbackManagerForToolRun,\n    parentConfig?: ToolRunnableConfig\n  ): Promise<ToolOutputT>;\n\n  /**\n   * Invokes the tool with the provided input and configuration.\n   * @param input The input for the tool.\n   * @param config Optional configuration for the tool.\n   * @returns A Promise that resolves with the tool's output.\n   */\n  async invoke<\n    TInput extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    input: TInput,\n    config?: TConfig\n  ): Promise<ToolReturnType<TInput, TConfig, ToolOutputT>> {\n    let toolInput: Exclude<\n      StructuredToolCallInput<SchemaT, SchemaInputT>,\n      ToolCall\n    >;\n\n    let enrichedConfig: ToolRunnableConfig = ensureConfig(\n      mergeConfigs(this.defaultConfig, config)\n    );\n    if (_isToolCall(input)) {\n      toolInput = input.args as Exclude<\n        StructuredToolCallInput<SchemaT, SchemaInputT>,\n        ToolCall\n      >;\n      enrichedConfig = {\n        ...enrichedConfig,\n        toolCall: input,\n      };\n    } else {\n      toolInput = input as Exclude<\n        StructuredToolCallInput<SchemaT, SchemaInputT>,\n        ToolCall\n      >;\n    }\n\n    return this.call(toolInput, enrichedConfig) as Promise<\n      ToolReturnType<TInput, TConfig, ToolOutputT>\n    >;\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument, configuration, and tags. It\n   * parses the input according to the schema, handles any errors, and\n   * manages callbacks.\n   * @param arg The input argument for the tool.\n   * @param configArg Optional configuration or callbacks for the tool.\n   * @param tags Optional tags for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  async call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig,\n    /** @deprecated */\n    tags?: string[]\n  ): Promise<ToolReturnType<TArg, TConfig, ToolOutputT>> {\n    // Determine the actual input that needs parsing/validation.\n    // If arg is a ToolCall, use its args; otherwise, use arg directly.\n    const inputForValidation = _isToolCall(arg) ? arg.args : arg;\n\n    let parsed: SchemaOutputT; // This will hold the successfully parsed input of the expected output type.\n    if (isInteropZodSchema(this.schema)) {\n      try {\n        // Validate the inputForValidation - TS needs help here as it can't exclude ToolCall based on the check\n        parsed = await interopParseAsync(\n          this.schema as InteropZodType,\n          inputForValidation as Exclude<TArg, ToolCall>\n        );\n      } catch (e) {\n        let message = `Received tool input did not match expected schema`;\n        if (this.verboseParsingErrors) {\n          message = `${message}\\nDetails: ${(e as Error).message}`;\n        }\n        if (isInteropZodError(e)) {\n          message = `${message}\\n\\n${z4.prettifyError(e as ZodError)}`;\n        }\n        // Pass the original raw input arg to the exception\n        throw new ToolInputParsingException(message, JSON.stringify(arg));\n      }\n    } else {\n      const result = validate(\n        inputForValidation,\n        this.schema as ValidationSchema\n      );\n      if (!result.valid) {\n        let message = `Received tool input did not match expected schema`;\n        if (this.verboseParsingErrors) {\n          message = `${message}\\nDetails: ${result.errors\n            .map((e) => `${e.keywordLocation}: ${e.error}`)\n            .join(\"\\n\")}`;\n        }\n        // Pass the original raw input arg to the exception\n        throw new ToolInputParsingException(message, JSON.stringify(arg));\n      }\n      // Assign the validated input to parsed\n      // We cast here because validate() doesn't narrow the type sufficiently for TS, but we know it's valid.\n      parsed = inputForValidation as SchemaOutputT;\n    }\n\n    const config = parseCallbackConfigArg(configArg);\n    const callbackManager_ = CallbackManager.configure(\n      config.callbacks,\n      this.callbacks,\n      config.tags || tags,\n      this.tags,\n      config.metadata,\n      this.metadata,\n      { verbose: this.verbose }\n    );\n    const runManager = await callbackManager_?.handleToolStart(\n      this.toJSON(),\n      // Log the original raw input arg\n      typeof arg === \"string\" ? arg : JSON.stringify(arg),\n      config.runId,\n      undefined,\n      undefined,\n      undefined,\n      config.runName\n    );\n    delete config.runId;\n    let result;\n    try {\n      // Pass the correctly typed parsed input to _call\n      result = await this._call(parsed, runManager, config);\n    } catch (e) {\n      await runManager?.handleToolError(e);\n      throw e;\n    }\n    let content;\n    let artifact;\n    if (this.responseFormat === \"content_and_artifact\") {\n      if (Array.isArray(result) && result.length === 2) {\n        [content, artifact] = result;\n      } else {\n        throw new Error(\n          `Tool response format is \"content_and_artifact\" but the output was not a two-tuple.\\nResult: ${JSON.stringify(\n            result\n          )}`\n        );\n      }\n    } else {\n      content = result;\n    }\n\n    let toolCallId: string | undefined;\n    // Extract toolCallId ONLY if the original arg was a ToolCall\n    if (_isToolCall(arg)) {\n      toolCallId = arg.id;\n    }\n    // Or if it was provided in the config's toolCall property\n    if (!toolCallId && _configHasToolCallId(config)) {\n      toolCallId = config.toolCall.id;\n    }\n\n    const formattedOutput = _formatToolOutput<ToolOutputT>({\n      content,\n      artifact,\n      toolCallId,\n      name: this.name,\n      metadata: this.metadata,\n    });\n    await runManager?.handleToolEnd(formattedOutput);\n    return formattedOutput as ToolReturnType<TArg, TConfig, ToolOutputT>;\n  }\n}\n\n/**\n * Base class for Tools that accept input as a string.\n */\nexport abstract class Tool<ToolOutputT = ToolOutputType>\n  extends StructuredTool<\n    StringInputToolSchema,\n    ToolInputSchemaOutputType<StringInputToolSchema>,\n    ToolInputSchemaInputType<StringInputToolSchema>,\n    ToolOutputT\n  >\n  implements\n    ToolInterface<\n      StringInputToolSchema,\n      ToolInputSchemaInputType<StringInputToolSchema>,\n      ToolOutputT\n    >\n{\n  schema = z\n    .object({ input: z.string().optional() })\n    .transform((obj) => obj.input);\n\n  constructor(fields?: ToolParams) {\n    super(fields);\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   *\n   * Calls the tool with the provided argument and callbacks. It handles\n   * string inputs specifically.\n   * @param arg The input argument for the tool, which can be a string, undefined, or an input of the tool's schema.\n   * @param callbacks Optional callbacks for the tool.\n   * @returns A Promise that resolves with a string.\n   */\n  // Match the base class signature including the generics and conditional return type\n  call<\n    TArg extends string | undefined | z.input<this[\"schema\"]> | ToolCall,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    callbacks?: TConfig\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>> {\n    // Prepare the input for the base class call method.\n    // If arg is string or undefined, wrap it; otherwise, pass ToolCall or { input: ... } directly.\n    const structuredArg =\n      typeof arg === \"string\" || arg == null ? { input: arg } : arg;\n\n    // Ensure TConfig is passed to super.call\n    return super.call(structuredArg, callbacks);\n  }\n}\n\n/**\n * A tool that can be created dynamically from a function, name, and description.\n */\nexport class DynamicTool<\n  ToolOutputT = ToolOutputType\n> extends Tool<ToolOutputT> {\n  static lc_name() {\n    return \"DynamicTool\";\n  }\n\n  name: string;\n\n  description: string;\n\n  func: DynamicToolInput<ToolOutputT>[\"func\"];\n\n  constructor(fields: DynamicToolInput<ToolOutputT>) {\n    super(fields);\n    this.name = fields.name;\n    this.description = fields.description;\n    this.func = fields.func;\n    this.returnDirect = fields.returnDirect ?? this.returnDirect;\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   */\n  async call<\n    TArg extends string | undefined | z.input<this[\"schema\"]> | ToolCall,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>> {\n    const config = parseCallbackConfigArg(configArg);\n    if (config.runName === undefined) {\n      config.runName = this.name;\n    }\n    // Call the Tool class's call method, passing generics through\n    // Cast config to TConfig to satisfy the super.call signature\n    return super.call<TArg, TConfig>(arg, config as TConfig);\n  }\n\n  /** @ignore */\n  async _call(\n    input: string, // DynamicTool's _call specifically expects a string after schema transformation\n    runManager?: CallbackManagerForToolRun,\n    parentConfig?: ToolRunnableConfig\n  ): Promise<ToolOutputT> {\n    return this.func(input, runManager, parentConfig);\n  }\n}\n\n/**\n * A tool that can be created dynamically from a function, name, and\n * description, designed to work with structured data. It extends the\n * StructuredTool class and overrides the _call method to execute the\n * provided function when the tool is called.\n *\n * Schema can be passed as Zod or JSON schema. The tool will not validate\n * input if JSON schema is passed.\n */\nexport class DynamicStructuredTool<\n  SchemaT = ToolInputSchemaBase,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n> extends StructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT> {\n  static lc_name() {\n    return \"DynamicStructuredTool\";\n  }\n\n  name: string;\n\n  description: string;\n\n  func: DynamicStructuredToolInput<SchemaT, SchemaOutputT, ToolOutputT>[\"func\"];\n\n  schema: SchemaT;\n\n  constructor(\n    fields: DynamicStructuredToolInput<SchemaT, SchemaOutputT, ToolOutputT>\n  ) {\n    super(fields);\n    this.name = fields.name;\n    this.description = fields.description;\n    this.func = fields.func;\n    this.returnDirect = fields.returnDirect ?? this.returnDirect;\n    this.schema = fields.schema;\n  }\n\n  /**\n   * @deprecated Use .invoke() instead. Will be removed in 0.3.0.\n   */\n  // Match the base class signature\n  async call<\n    TArg extends StructuredToolCallInput<SchemaT, SchemaInputT>,\n    TConfig extends ToolRunnableConfig | undefined\n  >(\n    arg: TArg,\n    configArg?: TConfig,\n    /** @deprecated */\n    tags?: string[]\n  ): Promise<ToolReturnType<NonNullable<TArg>, TConfig, ToolOutputT>> {\n    const config = parseCallbackConfigArg(configArg);\n    if (config.runName === undefined) {\n      config.runName = this.name;\n    }\n\n    // Call the base class method, passing generics through\n    // Cast config to TConfig to satisfy the super.call signature\n    return super.call<TArg, TConfig>(arg, config as TConfig, tags);\n  }\n\n  protected _call(\n    arg: Parameters<\n      DynamicStructuredToolInput<SchemaT, SchemaOutputT>[\"func\"]\n    >[0],\n    runManager?: CallbackManagerForToolRun,\n    parentConfig?: RunnableConfig\n  ): Promise<ToolOutputT> {\n    return this.func(arg, runManager, parentConfig);\n  }\n}\n\n/**\n * Abstract base class for toolkits in LangChain. Toolkits are collections\n * of tools that agents can use. Subclasses must implement the `tools`\n * property to provide the specific tools for the toolkit.\n */\nexport abstract class BaseToolkit {\n  abstract tools: StructuredToolInterface[];\n\n  getTools(): StructuredToolInterface[] {\n    return this.tools;\n  }\n}\n\n/**\n * Parameters for the tool function.\n * Schema can be provided as Zod or JSON schema.\n * Both schema types will be validated.\n * @template {ToolInputSchemaBase} RunInput The input schema for the tool.\n */\ninterface ToolWrapperParams<RunInput = ToolInputSchemaBase | undefined>\n  extends ToolParams {\n  /**\n   * The name of the tool. If using with an LLM, this\n   * will be passed as the tool name.\n   */\n  name: string;\n  /**\n   * The description of the tool.\n   * @default `${fields.name} tool`\n   */\n  description?: string;\n  /**\n   * The input schema for the tool. If using an LLM, this\n   * will be passed as the tool schema to generate arguments\n   * for.\n   */\n  schema?: RunInput;\n  /**\n   * The tool response format.\n   *\n   * If \"content\" then the output of the tool is interpreted as the contents of a\n   * ToolMessage. If \"content_and_artifact\" then the output is expected to be a\n   * two-tuple corresponding to the (content, artifact) of a ToolMessage.\n   *\n   * @default \"content\"\n   */\n  responseFormat?: ResponseFormat;\n  /**\n   * Whether to return the tool's output directly.\n   *\n   * Setting this to true means that after the tool is called,\n   * an agent should stop looping.\n   */\n  returnDirect?: boolean;\n}\n\n/**\n * Creates a new StructuredTool instance with the provided function, name, description, and schema.\n *\n * Schema can be provided as Zod or JSON schema, and both will be validated.\n *\n * @function\n * @template {ToolInputSchemaBase} SchemaT The input schema for the tool.\n * @template {ToolReturnType} ToolOutputT The output type of the tool.\n *\n * @param {RunnableFunc<z.output<SchemaT>, ToolOutputT>} func - The function to invoke when the tool is called.\n * @param {ToolWrapperParams<SchemaT>} fields - An object containing the following properties:\n * @param {string} fields.name The name of the tool.\n * @param {string | undefined} fields.description The description of the tool. Defaults to either the description on the Zod schema, or `${fields.name} tool`.\n * @param {z.AnyZodObject | z.ZodString | undefined} fields.schema The Zod schema defining the input for the tool. If undefined, it will default to a Zod string schema.\n *\n * @returns {DynamicStructuredTool<SchemaT>} A new StructuredTool instance.\n */\nexport function tool<SchemaT extends ZodStringV3, ToolOutputT = ToolOutputType>(\n  func: RunnableFunc<\n    InferInteropZodOutput<SchemaT>,\n    ToolOutputT,\n    ToolRunnableConfig\n  >,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<SchemaT extends ZodStringV4, ToolOutputT = ToolOutputType>(\n  func: RunnableFunc<\n    InferInteropZodOutput<SchemaT>,\n    ToolOutputT,\n    ToolRunnableConfig\n  >,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodObjectV3,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType\n>(\n  func: RunnableFunc<SchemaOutputT, ToolOutputT, ToolRunnableConfig>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodObjectV4,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType\n>(\n  func: RunnableFunc<SchemaOutputT, ToolOutputT, ToolRunnableConfig>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends JSONSchema,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n>(\n  func: RunnableFunc<\n    Parameters<DynamicStructuredToolInput<SchemaT>[\"func\"]>[0],\n    ToolOutputT,\n    ToolRunnableConfig\n  >,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends\n    | InteropZodObject\n    | InteropZodType<string>\n    | JSONSchema = InteropZodObject,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType\n>(\n  func: RunnableFunc<SchemaOutputT, ToolOutputT, ToolRunnableConfig>,\n  fields: ToolWrapperParams<SchemaT>\n):\n  | DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>\n  | DynamicTool<ToolOutputT>;\n\n// Overloads with ToolRuntime as CallOptions\nexport function tool<\n  SchemaT extends ZodStringV3,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: InferInteropZodOutput<SchemaT>,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodStringV4,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: InferInteropZodOutput<SchemaT>,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicTool<ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodObjectV3,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends ZodObjectV4,\n  SchemaOutputT = InferInteropZodOutput<SchemaT>,\n  SchemaInputT = InferInteropZodInput<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends JSONSchema,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: Parameters<DynamicStructuredToolInput<SchemaT>[\"func\"]>[0],\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n): DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>;\n\nexport function tool<\n  SchemaT extends\n    | InteropZodObject\n    | InteropZodType<string>\n    | JSONSchema = InteropZodObject,\n  SchemaOutputT = ToolInputSchemaOutputType<SchemaT>,\n  SchemaInputT = ToolInputSchemaInputType<SchemaT>,\n  ToolOutputT = ToolOutputType,\n  TState = unknown,\n  TContext = unknown\n>(\n  func: (\n    input: SchemaOutputT,\n    runtime: ToolRuntime<TState, TContext>\n  ) => ToolOutputT | Promise<ToolOutputT>,\n  fields: ToolWrapperParams<SchemaT>\n):\n  | DynamicStructuredTool<SchemaT, SchemaOutputT, SchemaInputT, ToolOutputT>\n  | DynamicTool<ToolOutputT> {\n  const isSimpleStringSchema = isSimpleStringZodSchema(fields.schema);\n  const isStringJSONSchema = validatesOnlyStrings(fields.schema);\n\n  // If the schema is not provided, or it's a simple string schema, create a DynamicTool\n  if (!fields.schema || isSimpleStringSchema || isStringJSONSchema) {\n    return new DynamicTool<ToolOutputT>({\n      ...fields,\n      description:\n        fields.description ??\n        (fields.schema as { description?: string } | undefined)?.description ??\n        `${fields.name} tool`,\n      func: async (input, runManager, config) => {\n        return new Promise<ToolOutputT>((resolve, reject) => {\n          const childConfig = patchConfig(config, {\n            callbacks: runManager?.getChild(),\n          });\n          // eslint-disable-next-line no-void\n          void AsyncLocalStorageProviderSingleton.runWithConfig(\n            pickRunnableConfigKeys(childConfig),\n            async () => {\n              try {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                resolve(func(input as any, childConfig as any));\n              } catch (e) {\n                reject(e);\n              }\n            }\n          );\n        });\n      },\n    });\n  }\n\n  const schema = fields.schema as InteropZodObject | JSONSchema;\n\n  const description =\n    fields.description ??\n    (fields.schema as { description?: string }).description ??\n    `${fields.name} tool`;\n\n  return new DynamicStructuredTool<\n    typeof schema,\n    SchemaOutputT,\n    SchemaInputT,\n    ToolOutputT\n  >({\n    ...fields,\n    description,\n    schema,\n    func: async (input, runManager, config) => {\n      return new Promise<ToolOutputT>((resolve, reject) => {\n        let listener: (() => void) | undefined;\n        const cleanup = () => {\n          if (config?.signal && listener) {\n            config.signal.removeEventListener(\"abort\", listener);\n          }\n        };\n\n        if (config?.signal) {\n          listener = () => {\n            cleanup();\n            reject(getAbortSignalError(config.signal));\n          };\n          config.signal.addEventListener(\"abort\", listener);\n        }\n\n        const childConfig = patchConfig(config, {\n          callbacks: runManager?.getChild(),\n        });\n        // eslint-disable-next-line no-void\n        void AsyncLocalStorageProviderSingleton.runWithConfig(\n          pickRunnableConfigKeys(childConfig),\n          async () => {\n            try {\n              // eslint-disable-next-line @typescript-eslint/no-explicit-any\n              const result = await func(input as any, childConfig as any);\n\n              /**\n               * If the signal is aborted, we don't want to resolve the promise\n               * as the promise is already rejected.\n               */\n              if (config?.signal?.aborted) {\n                cleanup();\n                return;\n              }\n\n              cleanup();\n              resolve(result);\n            } catch (e) {\n              cleanup();\n              reject(e);\n            }\n          }\n        );\n      });\n    },\n  }) as DynamicStructuredTool<\n    SchemaT,\n    SchemaOutputT,\n    SchemaInputT,\n    ToolOutputT\n  >;\n}\n\nfunction _formatToolOutput<TOutput extends ToolOutputType>(params: {\n  content: TOutput;\n  name: string;\n  artifact?: unknown;\n  toolCallId?: string;\n  metadata?: Record<string, unknown>;\n}): ToolMessage | TOutput {\n  const { content, artifact, toolCallId, metadata } = params;\n  if (toolCallId && !isDirectToolOutput(content)) {\n    if (\n      typeof content === \"string\" ||\n      (Array.isArray(content) &&\n        content.every((item) => typeof item === \"object\"))\n    ) {\n      return new ToolMessage({\n        status: \"success\",\n        content,\n        artifact,\n        tool_call_id: toolCallId,\n        name: params.name,\n        metadata,\n      });\n    } else {\n      return new ToolMessage({\n        status: \"success\",\n        content: _stringify(content),\n        artifact,\n        tool_call_id: toolCallId,\n        name: params.name,\n        metadata,\n      });\n    }\n  } else {\n    return content;\n  }\n}\n\nfunction _stringify(content: unknown): string {\n  try {\n    return JSON.stringify(content, null, 2) ?? \"\";\n  } catch (_noOp) {\n    return `${content}`;\n  }\n}\n\nexport type ServerTool = Record<string, unknown>;\nexport type ClientTool =\n  | StructuredToolInterface\n  | DynamicTool\n  | RunnableToolLike;\n"],"mappings":"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"}