"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxConnector = void 0;
const code_interpreter_1 = require("@e2b/code-interpreter");
const playwright_1 = require("playwright");
const events_1 = require("events");
/**
 * SandboxConnector manages the direct connection between E2B Sandbox and Playwright
 * Replaces the subprocess-based MCP server approach with direct CDP connection
 */
class SandboxConnector extends events_1.EventEmitter {
    constructor(config) {
        super();
        this.pages = [];
        this.isConnected = false;
        this.config = config;
    }
    /**
     * Initialize the sandbox and establish CDP connection
     */
    async connect() {
        if (this.isConnected) {
            return;
        }
        try {
            // Create E2B browser sandbox with minimum timeout
            this.sandbox = await code_interpreter_1.Sandbox.create("browser-v1", {
                timeoutMs: Math.max((this.config.timeout || 300) * 1000, 5 * 60 * 1000), // 最少5分钟
                apiKey: this.config.apiKey,
                domain: this.config.domain,
            });
            // this.sandbox = await Sandbox.connect('63d61b6f165e476cb4d8908db2a5b3ef')
            // Get access token from sandbox - use correct property name
            const accessToken = this.sandbox.envdAccessToken ||
                this.sandbox._envd_access_token ||
                this.sandbox.accessToken ||
                this.sandbox.envd_access_token ||
                "";
            console.log(`Access token found: ${accessToken ? "yes" : "no"}`);
            if (accessToken) {
                console.log(`Access token length: ${accessToken.length}`);
            }
            // Extract connection information
            const vncUrl = `https://${this.sandbox.getHost(9000)}/novnc/vnc_lite.html?&path=websockify?access_token=${accessToken}`;
            const cdpUrl = `https://${this.sandbox.getHost(9000)}/cdp`;
            this.connectionInfo = {
                sandboxId: this.sandbox.sandboxId,
                vncUrl: vncUrl,
                cdpUrl: cdpUrl,
                accessToken: accessToken,
            };
            // Connect to browser via CDP using Playwright
            await this.connectToBrowser();
            this.isConnected = true;
            this.emit("connected", this.connectionInfo);
            console.log(`✅ Sandbox connector initialized: ${this.sandbox.sandboxId}`);
            console.log(`CDP URL: ${this.connectionInfo.cdpUrl}`);
            console.log(`VNC URL: ${this.connectionInfo.vncUrl}`);
        }
        catch (error) {
            console.error("Failed to initialize sandbox connector:", error);
            this.emit("error", error);
            throw error;
        }
    }
    /**
     * Establish direct CDP connection to sandbox browser
     */
    async connectToBrowser() {
        if (!this.sandbox || !this.connectionInfo) {
            throw new Error("Sandbox not initialized");
        }
        try {
            // Try to connect without access token first
            console.log(`Attempting CDP connection to: ${this.connectionInfo.cdpUrl}`);
            let connectionOptions = {};
            // If we have an access token, try different authentication methods
            if (this.connectionInfo.accessToken) {
                // Try different header formats that E2B might accept
                connectionOptions.headers = {
                    Authorization: `Bearer ${this.connectionInfo.accessToken}`,
                    "X-Access-Token": this.connectionInfo.accessToken,
                    access_token: this.connectionInfo.accessToken,
                };
                console.log("Using access token for CDP connection with multiple auth headers");
            }
            else {
                console.log("No access token found, attempting connection without authentication");
            }
            // Connect to browser via CDP
            this.browser = await playwright_1.chromium.connectOverCDP(this.connectionInfo.cdpUrl, connectionOptions);
            // Get or create default context
            this.context = this.browser.contexts()[0];
            if (!this.context) {
                this.context = await this.browser.newContext();
            }
            // Ensure at least one page exists
            this.pages = this.context.pages();
            if (this.pages.length === 0) {
                const page = await this.context.newPage();
                this.pages.push(page);
            }
            console.log(`✅ Connected to browser via CDP with ${this.pages.length} pages`);
            this.emit("browser-connected", this.browser);
        }
        catch (error) {
            console.error("Failed to connect to browser via CDP:", error);
            throw error;
        }
    }
    /**
     * Get Playwright Browser instance
     */
    getBrowser() {
        if (!this.browser) {
            throw new Error("Browser not connected");
        }
        return this.browser;
    }
    /**
     * Get Playwright BrowserContext instance
     */
    getContext() {
        if (!this.context) {
            throw new Error("Browser context not available");
        }
        return this.context;
    }
    /**
     * Get Playwright Page instance by index
     */
    getPage(index = 0) {
        if (!this.pages || index >= this.pages.length) {
            throw new Error(`Page index ${index} out of range. Available pages: ${this.pages?.length || 0}`);
        }
        return this.pages[index];
    }
    /**
     * Get all Playwright Page instances
     */
    getPages() {
        return this.pages || [];
    }
    /**
     * Create new Playwright Page
     */
    async createPage() {
        if (!this.context) {
            throw new Error("Browser context not available");
        }
        const page = await this.context.newPage();
        this.pages.push(page);
        this.emit("page-created", page);
        return page;
    }
    /**
     * Close Playwright Page by index
     */
    async closePage(index) {
        if (index >= this.pages.length) {
            throw new Error(`Page index ${index} out of range`);
        }
        const page = this.pages[index];
        await page.close();
        this.pages.splice(index, 1);
        this.emit("page-closed", index);
    }
    /**
     * Get connection status
     */
    isReady() {
        return this.isConnected && !!this.browser && !!this.context;
    }
    /**
     * Get connection information
     */
    getConnectionInfo() {
        return this.connectionInfo;
    }
    /**
     * Get VNC URL for visual debugging
     */
    getVncUrl() {
        if (!this.sandbox || !this.connectionInfo) {
            throw new Error("Sandbox not initialized");
        }
        return `https://${this.sandbox.getHost(9000)}/novnc/vnc_lite.html?path=websockify&access_token=${this.connectionInfo.accessToken}`;
    }
    /**
     * Get CDP URL for direct connection
     */
    getCdpUrl() {
        if (!this.sandbox) {
            throw new Error("Sandbox not initialized");
        }
        return `https://${this.sandbox.getHost(9000)}/cdp`;
    }
    /**
     * Get sandbox ID
     */
    getSandboxId() {
        return this.sandbox?.sandboxId;
    }
    /**
     * Reconnect to sandbox if connection is lost
     */
    async reconnect() {
        console.log("Attempting to reconnect to sandbox...");
        try {
            // Close existing connections
            await this.disconnect(false);
            // Re-establish connection
            await this.connect();
            console.log("✅ Successfully reconnected to sandbox");
            this.emit("reconnected");
        }
        catch (error) {
            console.error("Failed to reconnect to sandbox:", error);
            this.emit("reconnect-failed", error);
            throw error;
        }
    }
    /**
     * Disconnect and clean up resources
     */
    async disconnect(killSandbox = true) {
        try {
            // Close browser connection
            if (this.browser) {
                await this.browser.close();
                this.browser = undefined;
            }
            // Reset context and pages
            this.context = undefined;
            this.pages = [];
            // Kill sandbox if requested
            if (killSandbox && this.sandbox) {
                await this.sandbox.kill();
                this.sandbox = undefined;
            }
            this.isConnected = false;
            this.connectionInfo = undefined;
            console.log("✅ Sandbox connector disconnected");
            this.emit("disconnected");
        }
        catch (error) {
            console.error("Error disconnecting sandbox connector:", error);
            this.emit("error", error);
            throw error;
        }
    }
    /**
     * Health check for the connection
     */
    async healthCheck() {
        try {
            if (!this.isReady()) {
                return false;
            }
            // Test browser connection by getting version
            const version = await this.browser.version();
            console.log(`Browser health check passed: ${version}`);
            return true;
        }
        catch (error) {
            console.error("Health check failed:", error);
            return false;
        }
    }
}
exports.SandboxConnector = SandboxConnector;
//# sourceMappingURL=sandbox-connector.js.map