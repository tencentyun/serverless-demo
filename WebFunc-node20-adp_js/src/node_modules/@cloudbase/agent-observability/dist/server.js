"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/OTLPExporterBase.js
var OTLPExporterBase;
var init_OTLPExporterBase = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/OTLPExporterBase.js"() {
    "use strict";
    OTLPExporterBase = class {
      _delegate;
      constructor(delegate) {
        this._delegate = delegate;
      }
      /**
       * Export items.
       * @param items
       * @param resultCallback
       */
      export(items, resultCallback) {
        this._delegate.export(items, resultCallback);
      }
      forceFlush() {
        return this._delegate.forceFlush();
      }
      shutdown() {
        return this._delegate.shutdown();
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/types.js
var OTLPExporterError;
var init_types = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/types.js"() {
    "use strict";
    OTLPExporterError = class extends Error {
      code;
      name = "OTLPExporterError";
      data;
      constructor(message, code, data) {
        super(message);
        this.data = data;
        this.code = code;
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/shared-configuration.js
function validateTimeoutMillis(timeoutMillis) {
  if (Number.isFinite(timeoutMillis) && timeoutMillis > 0) {
    return timeoutMillis;
  }
  throw new Error(`Configuration: timeoutMillis is invalid, expected number greater than 0 (actual: '${timeoutMillis}')`);
}
function wrapStaticHeadersInFunction(headers) {
  if (headers == null) {
    return void 0;
  }
  return async () => headers;
}
function mergeOtlpSharedConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration) {
  return {
    timeoutMillis: validateTimeoutMillis(userProvidedConfiguration.timeoutMillis ?? fallbackConfiguration.timeoutMillis ?? defaultConfiguration.timeoutMillis),
    concurrencyLimit: userProvidedConfiguration.concurrencyLimit ?? fallbackConfiguration.concurrencyLimit ?? defaultConfiguration.concurrencyLimit,
    compression: userProvidedConfiguration.compression ?? fallbackConfiguration.compression ?? defaultConfiguration.compression
  };
}
function getSharedConfigurationDefaults() {
  return {
    timeoutMillis: 1e4,
    concurrencyLimit: 30,
    compression: "none"
  };
}
var init_shared_configuration = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/shared-configuration.js"() {
    "use strict";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/bounded-queue-export-promise-handler.js
function createBoundedQueueExportPromiseHandler(options) {
  return new BoundedQueueExportPromiseHandler(options.concurrencyLimit);
}
var BoundedQueueExportPromiseHandler;
var init_bounded_queue_export_promise_handler = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/bounded-queue-export-promise-handler.js"() {
    "use strict";
    BoundedQueueExportPromiseHandler = class {
      _concurrencyLimit;
      _sendingPromises = [];
      /**
       * @param concurrencyLimit maximum promises allowed in a queue at the same time.
       */
      constructor(concurrencyLimit) {
        this._concurrencyLimit = concurrencyLimit;
      }
      pushPromise(promise) {
        if (this.hasReachedLimit()) {
          throw new Error("Concurrency Limit reached");
        }
        this._sendingPromises.push(promise);
        const popPromise = () => {
          const index = this._sendingPromises.indexOf(promise);
          void this._sendingPromises.splice(index, 1);
        };
        promise.then(popPromise, popPromise);
      }
      hasReachedLimit() {
        return this._sendingPromises.length >= this._concurrencyLimit;
      }
      async awaitAll() {
        await Promise.all(this._sendingPromises);
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/baggage/constants.js
var BAGGAGE_KEY_PAIR_SEPARATOR, BAGGAGE_PROPERTIES_SEPARATOR, BAGGAGE_ITEMS_SEPARATOR;
var init_constants = __esm({
  "../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/baggage/constants.js"() {
    "use strict";
    BAGGAGE_KEY_PAIR_SEPARATOR = "=";
    BAGGAGE_PROPERTIES_SEPARATOR = ";";
    BAGGAGE_ITEMS_SEPARATOR = ",";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/baggage/utils.js
function parsePairKeyValue(entry) {
  if (!entry)
    return;
  const metadataSeparatorIndex = entry.indexOf(BAGGAGE_PROPERTIES_SEPARATOR);
  const keyPairPart = metadataSeparatorIndex === -1 ? entry : entry.substring(0, metadataSeparatorIndex);
  const separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);
  if (separatorIndex <= 0)
    return;
  const rawKey = keyPairPart.substring(0, separatorIndex).trim();
  const rawValue = keyPairPart.substring(separatorIndex + 1).trim();
  if (!rawKey || !rawValue)
    return;
  let key;
  let value;
  try {
    key = decodeURIComponent(rawKey);
    value = decodeURIComponent(rawValue);
  } catch {
    return;
  }
  let metadata;
  if (metadataSeparatorIndex !== -1 && metadataSeparatorIndex < entry.length - 1) {
    const metadataString = entry.substring(metadataSeparatorIndex + 1);
    metadata = (0, import_api.baggageEntryMetadataFromString)(metadataString);
  }
  return { key, value, metadata };
}
function parseKeyPairsIntoRecord(value) {
  const result = {};
  if (typeof value === "string" && value.length > 0) {
    value.split(BAGGAGE_ITEMS_SEPARATOR).forEach((entry) => {
      const keyPair = parsePairKeyValue(entry);
      if (keyPair !== void 0 && keyPair.value.length > 0) {
        result[keyPair.key] = keyPair.value;
      }
    });
  }
  return result;
}
var import_api;
var init_utils = __esm({
  "../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/baggage/utils.js"() {
    "use strict";
    import_api = require("@opentelemetry/api");
    init_constants();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/platform/node/environment.js
function getNumberFromEnv(key) {
  const raw = process.env[key];
  if (raw == null || raw.trim() === "") {
    return void 0;
  }
  const value = Number(raw);
  if (isNaN(value)) {
    import_api2.diag.warn(`Unknown value ${(0, import_util.inspect)(raw)} for ${key}, expected a number, using defaults`);
    return void 0;
  }
  return value;
}
function getStringFromEnv(key) {
  const raw = process.env[key];
  if (raw == null || raw.trim() === "") {
    return void 0;
  }
  return raw;
}
var import_api2, import_util;
var init_environment = __esm({
  "../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/platform/node/environment.js"() {
    "use strict";
    import_api2 = require("@opentelemetry/api");
    import_util = require("util");
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/platform/node/index.js
var init_node = __esm({
  "../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/platform/node/index.js"() {
    "use strict";
    init_environment();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/platform/index.js
var init_platform = __esm({
  "../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/platform/index.js"() {
    "use strict";
    init_node();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/common/time.js
function hrTimeToNanoseconds(time) {
  return time[0] * SECOND_TO_NANOSECONDS + time[1];
}
var NANOSECOND_DIGITS, NANOSECOND_DIGITS_IN_MILLIS, MILLISECONDS_TO_NANOSECONDS, SECOND_TO_NANOSECONDS;
var init_time = __esm({
  "../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/common/time.js"() {
    "use strict";
    NANOSECOND_DIGITS = 9;
    NANOSECOND_DIGITS_IN_MILLIS = 6;
    MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);
    SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/ExportResult.js
var ExportResultCode;
var init_ExportResult = __esm({
  "../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/ExportResult.js"() {
    "use strict";
    (function(ExportResultCode2) {
      ExportResultCode2[ExportResultCode2["SUCCESS"] = 0] = "SUCCESS";
      ExportResultCode2[ExportResultCode2["FAILED"] = 1] = "FAILED";
    })(ExportResultCode || (ExportResultCode = {}));
  }
});

// ../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js
var init_esm = __esm({
  "../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/build/esm/index.js"() {
    "use strict";
    init_time();
    init_ExportResult();
    init_utils();
    init_platform();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/logging-response-handler.js
function isPartialSuccessResponse(response) {
  return Object.prototype.hasOwnProperty.call(response, "partialSuccess");
}
function createLoggingPartialSuccessResponseHandler() {
  return {
    handleResponse(response) {
      if (response == null || !isPartialSuccessResponse(response) || response.partialSuccess == null || Object.keys(response.partialSuccess).length === 0) {
        return;
      }
      import_api3.diag.warn("Received Partial Success response:", JSON.stringify(response.partialSuccess));
    }
  };
}
var import_api3;
var init_logging_response_handler = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/logging-response-handler.js"() {
    "use strict";
    import_api3 = require("@opentelemetry/api");
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/otlp-export-delegate.js
function createOtlpExportDelegate(components, settings) {
  return new OTLPExportDelegate(components.transport, components.serializer, createLoggingPartialSuccessResponseHandler(), components.promiseHandler, settings.timeout);
}
var import_api4, OTLPExportDelegate;
var init_otlp_export_delegate = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/otlp-export-delegate.js"() {
    "use strict";
    init_esm();
    init_types();
    init_logging_response_handler();
    import_api4 = require("@opentelemetry/api");
    OTLPExportDelegate = class {
      _diagLogger;
      _transport;
      _serializer;
      _responseHandler;
      _promiseQueue;
      _timeout;
      constructor(transport, serializer, responseHandler, promiseQueue, timeout) {
        this._transport = transport;
        this._serializer = serializer;
        this._responseHandler = responseHandler;
        this._promiseQueue = promiseQueue;
        this._timeout = timeout;
        this._diagLogger = import_api4.diag.createComponentLogger({
          namespace: "OTLPExportDelegate"
        });
      }
      export(internalRepresentation, resultCallback) {
        this._diagLogger.debug("items to be sent", internalRepresentation);
        if (this._promiseQueue.hasReachedLimit()) {
          resultCallback({
            code: ExportResultCode.FAILED,
            error: new Error("Concurrent export limit reached")
          });
          return;
        }
        const serializedRequest = this._serializer.serializeRequest(internalRepresentation);
        if (serializedRequest == null) {
          resultCallback({
            code: ExportResultCode.FAILED,
            error: new Error("Nothing to send")
          });
          return;
        }
        this._promiseQueue.pushPromise(this._transport.send(serializedRequest, this._timeout).then((response) => {
          if (response.status === "success") {
            if (response.data != null) {
              try {
                this._responseHandler.handleResponse(this._serializer.deserializeResponse(response.data));
              } catch (e) {
                this._diagLogger.warn("Export succeeded but could not deserialize response - is the response specification compliant?", e, response.data);
              }
            }
            resultCallback({
              code: ExportResultCode.SUCCESS
            });
            return;
          } else if (response.status === "failure" && response.error) {
            resultCallback({
              code: ExportResultCode.FAILED,
              error: response.error
            });
            return;
          } else if (response.status === "retryable") {
            resultCallback({
              code: ExportResultCode.FAILED,
              error: response.error ?? new OTLPExporterError("Export failed with retryable status")
            });
          } else {
            resultCallback({
              code: ExportResultCode.FAILED,
              error: new OTLPExporterError("Export failed with unknown error")
            });
          }
        }, (reason) => resultCallback({
          code: ExportResultCode.FAILED,
          error: reason
        })));
      }
      forceFlush() {
        return this._promiseQueue.awaitAll();
      }
      async shutdown() {
        this._diagLogger.debug("shutdown started");
        await this.forceFlush();
        this._transport.shutdown();
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/index.js
var init_esm2 = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/index.js"() {
    "use strict";
    init_OTLPExporterBase();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/esm/common/hex-to-binary.js
function intValue(charCode) {
  if (charCode >= 48 && charCode <= 57) {
    return charCode - 48;
  }
  if (charCode >= 97 && charCode <= 102) {
    return charCode - 87;
  }
  return charCode - 55;
}
function hexToBinary(hexStr) {
  const buf = new Uint8Array(hexStr.length / 2);
  let offset = 0;
  for (let i = 0; i < hexStr.length; i += 2) {
    const hi = intValue(hexStr.charCodeAt(i));
    const lo = intValue(hexStr.charCodeAt(i + 1));
    buf[offset++] = hi << 4 | lo;
  }
  return buf;
}
var init_hex_to_binary = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/esm/common/hex-to-binary.js"() {
    "use strict";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/esm/common/utils.js
function hrTimeToNanos(hrTime2) {
  const NANOSECONDS = BigInt(1e9);
  return BigInt(Math.trunc(hrTime2[0])) * NANOSECONDS + BigInt(Math.trunc(hrTime2[1]));
}
function toLongBits(value) {
  const low = Number(BigInt.asUintN(32, value));
  const high = Number(BigInt.asUintN(32, value >> BigInt(32)));
  return { low, high };
}
function encodeAsLongBits(hrTime2) {
  const nanos = hrTimeToNanos(hrTime2);
  return toLongBits(nanos);
}
function encodeAsString(hrTime2) {
  const nanos = hrTimeToNanos(hrTime2);
  return nanos.toString();
}
function identity(value) {
  return value;
}
function optionalHexToBinary(str) {
  if (str === void 0)
    return void 0;
  return hexToBinary(str);
}
function getOtlpEncoder(options) {
  if (options === void 0) {
    return DEFAULT_ENCODER;
  }
  const useLongBits = options.useLongBits ?? true;
  const useHex = options.useHex ?? false;
  return {
    encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,
    encodeSpanContext: useHex ? identity : hexToBinary,
    encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary
  };
}
var encodeTimestamp, DEFAULT_ENCODER;
var init_utils2 = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/esm/common/utils.js"() {
    "use strict";
    init_esm();
    init_hex_to_binary();
    encodeTimestamp = typeof BigInt !== "undefined" ? encodeAsString : hrTimeToNanoseconds;
    DEFAULT_ENCODER = {
      encodeHrTime: encodeAsLongBits,
      encodeSpanContext: hexToBinary,
      encodeOptionalSpanContext: optionalHexToBinary
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/esm/common/internal.js
function createResource(resource) {
  const result = {
    attributes: toAttributes(resource.attributes),
    droppedAttributesCount: 0
  };
  const schemaUrl = resource.schemaUrl;
  if (schemaUrl && schemaUrl !== "")
    result.schemaUrl = schemaUrl;
  return result;
}
function createInstrumentationScope(scope) {
  return {
    name: scope.name,
    version: scope.version
  };
}
function toAttributes(attributes) {
  return Object.keys(attributes).map((key) => toKeyValue(key, attributes[key]));
}
function toKeyValue(key, value) {
  return {
    key,
    value: toAnyValue(value)
  };
}
function toAnyValue(value) {
  const t = typeof value;
  if (t === "string")
    return { stringValue: value };
  if (t === "number") {
    if (!Number.isInteger(value))
      return { doubleValue: value };
    return { intValue: value };
  }
  if (t === "boolean")
    return { boolValue: value };
  if (value instanceof Uint8Array)
    return { bytesValue: value };
  if (Array.isArray(value))
    return { arrayValue: { values: value.map(toAnyValue) } };
  if (t === "object" && value != null)
    return {
      kvlistValue: {
        values: Object.entries(value).map(([k, v]) => toKeyValue(k, v))
      }
    };
  return {};
}
var init_internal = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/esm/common/internal.js"() {
    "use strict";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/esm/trace/internal.js
function buildSpanFlagsFrom(traceFlags, isRemote) {
  let flags = traceFlags & 255 | SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK;
  if (isRemote) {
    flags |= SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK;
  }
  return flags;
}
function sdkSpanToOtlpSpan(span, encoder) {
  const ctx = span.spanContext();
  const status = span.status;
  const parentSpanId = span.parentSpanContext?.spanId ? encoder.encodeSpanContext(span.parentSpanContext?.spanId) : void 0;
  return {
    traceId: encoder.encodeSpanContext(ctx.traceId),
    spanId: encoder.encodeSpanContext(ctx.spanId),
    parentSpanId,
    traceState: ctx.traceState?.serialize(),
    name: span.name,
    // Span kind is offset by 1 because the API does not define a value for unset
    kind: span.kind == null ? 0 : span.kind + 1,
    startTimeUnixNano: encoder.encodeHrTime(span.startTime),
    endTimeUnixNano: encoder.encodeHrTime(span.endTime),
    attributes: toAttributes(span.attributes),
    droppedAttributesCount: span.droppedAttributesCount,
    events: span.events.map((event) => toOtlpSpanEvent(event, encoder)),
    droppedEventsCount: span.droppedEventsCount,
    status: {
      // API and proto enums share the same values
      code: status.code,
      message: status.message
    },
    links: span.links.map((link) => toOtlpLink(link, encoder)),
    droppedLinksCount: span.droppedLinksCount,
    flags: buildSpanFlagsFrom(ctx.traceFlags, span.parentSpanContext?.isRemote)
  };
}
function toOtlpLink(link, encoder) {
  return {
    attributes: link.attributes ? toAttributes(link.attributes) : [],
    spanId: encoder.encodeSpanContext(link.context.spanId),
    traceId: encoder.encodeSpanContext(link.context.traceId),
    traceState: link.context.traceState?.serialize(),
    droppedAttributesCount: link.droppedAttributesCount || 0,
    flags: buildSpanFlagsFrom(link.context.traceFlags, link.context.isRemote)
  };
}
function toOtlpSpanEvent(timedEvent, encoder) {
  return {
    attributes: timedEvent.attributes ? toAttributes(timedEvent.attributes) : [],
    name: timedEvent.name,
    timeUnixNano: encoder.encodeHrTime(timedEvent.time),
    droppedAttributesCount: timedEvent.droppedAttributesCount || 0
  };
}
function createExportTraceServiceRequest(spans, options) {
  const encoder = getOtlpEncoder(options);
  return {
    resourceSpans: spanRecordsToResourceSpans(spans, encoder)
  };
}
function createResourceMap(readableSpans) {
  const resourceMap = /* @__PURE__ */ new Map();
  for (const record of readableSpans) {
    let ilsMap = resourceMap.get(record.resource);
    if (!ilsMap) {
      ilsMap = /* @__PURE__ */ new Map();
      resourceMap.set(record.resource, ilsMap);
    }
    const instrumentationScopeKey = `${record.instrumentationScope.name}@${record.instrumentationScope.version || ""}:${record.instrumentationScope.schemaUrl || ""}`;
    let records = ilsMap.get(instrumentationScopeKey);
    if (!records) {
      records = [];
      ilsMap.set(instrumentationScopeKey, records);
    }
    records.push(record);
  }
  return resourceMap;
}
function spanRecordsToResourceSpans(readableSpans, encoder) {
  const resourceMap = createResourceMap(readableSpans);
  const out = [];
  const entryIterator = resourceMap.entries();
  let entry = entryIterator.next();
  while (!entry.done) {
    const [resource, ilmMap] = entry.value;
    const scopeResourceSpans = [];
    const ilmIterator = ilmMap.values();
    let ilmEntry = ilmIterator.next();
    while (!ilmEntry.done) {
      const scopeSpans = ilmEntry.value;
      if (scopeSpans.length > 0) {
        const spans = scopeSpans.map((readableSpan) => sdkSpanToOtlpSpan(readableSpan, encoder));
        scopeResourceSpans.push({
          scope: createInstrumentationScope(scopeSpans[0].instrumentationScope),
          spans,
          schemaUrl: scopeSpans[0].instrumentationScope.schemaUrl
        });
      }
      ilmEntry = ilmIterator.next();
    }
    const processedResource = createResource(resource);
    const transformedSpans = {
      resource: processedResource,
      scopeSpans: scopeResourceSpans,
      schemaUrl: processedResource.schemaUrl
    };
    out.push(transformedSpans);
    entry = entryIterator.next();
  }
  return out;
}
var SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK, SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK;
var init_internal2 = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/esm/trace/internal.js"() {
    "use strict";
    init_internal();
    init_utils2();
    SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK = 256;
    SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK = 512;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/esm/trace/json/trace.js
var JsonTraceSerializer;
var init_trace = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/esm/trace/json/trace.js"() {
    "use strict";
    init_internal2();
    JsonTraceSerializer = {
      serializeRequest: (arg) => {
        const request = createExportTraceServiceRequest(arg, {
          useHex: true,
          useLongBits: false
        });
        const encoder = new TextEncoder();
        return encoder.encode(JSON.stringify(request));
      },
      deserializeResponse: (arg) => {
        if (arg.length === 0) {
          return {};
        }
        const decoder = new TextDecoder();
        return JSON.parse(decoder.decode(arg));
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/esm/trace/json/index.js
var init_json = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/esm/trace/json/index.js"() {
    "use strict";
    init_trace();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/esm/index.js
var init_esm3 = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/build/esm/index.js"() {
    "use strict";
    init_json();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/util.js
function validateAndNormalizeHeaders(partialHeaders) {
  const headers = {};
  Object.entries(partialHeaders ?? {}).forEach(([key, value]) => {
    if (typeof value !== "undefined") {
      headers[key] = String(value);
    } else {
      import_api5.diag.warn(`Header "${key}" has invalid value (${value}) and will be ignored`);
    }
  });
  return headers;
}
var import_api5;
var init_util = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/util.js"() {
    "use strict";
    import_api5 = require("@opentelemetry/api");
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/otlp-http-configuration.js
function mergeHeaders(userProvidedHeaders, fallbackHeaders, defaultHeaders) {
  return async () => {
    const requiredHeaders = {
      ...await defaultHeaders()
    };
    const headers = {};
    if (fallbackHeaders != null) {
      Object.assign(headers, await fallbackHeaders());
    }
    if (userProvidedHeaders != null) {
      Object.assign(headers, validateAndNormalizeHeaders(await userProvidedHeaders()));
    }
    return Object.assign(headers, requiredHeaders);
  };
}
function validateUserProvidedUrl(url) {
  if (url == null) {
    return void 0;
  }
  try {
    const base = globalThis.location?.href;
    return new URL(url, base).href;
  } catch {
    throw new Error(`Configuration: Could not parse user-provided export URL: '${url}'`);
  }
}
function mergeOtlpHttpConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration) {
  return {
    ...mergeOtlpSharedConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration),
    headers: mergeHeaders(userProvidedConfiguration.headers, fallbackConfiguration.headers, defaultConfiguration.headers),
    url: validateUserProvidedUrl(userProvidedConfiguration.url) ?? fallbackConfiguration.url ?? defaultConfiguration.url
  };
}
function getHttpConfigurationDefaults(requiredHeaders, signalResourcePath) {
  return {
    ...getSharedConfigurationDefaults(),
    headers: async () => requiredHeaders,
    url: "http://localhost:4318/" + signalResourcePath
  };
}
var init_otlp_http_configuration = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/otlp-http-configuration.js"() {
    "use strict";
    init_shared_configuration();
    init_util();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/otlp-node-http-configuration.js
function httpAgentFactoryFromOptions(options) {
  return async (protocol) => {
    const isInsecure = protocol === "http:";
    const module2 = isInsecure ? import("http") : import("https");
    const { Agent } = await module2;
    if (isInsecure) {
      const { ca, cert, key, ...insecureOptions } = options;
      return new Agent(insecureOptions);
    }
    return new Agent(options);
  };
}
function mergeOtlpNodeHttpConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration) {
  return {
    ...mergeOtlpHttpConfigurationWithDefaults(userProvidedConfiguration, fallbackConfiguration, defaultConfiguration),
    agentFactory: userProvidedConfiguration.agentFactory ?? fallbackConfiguration.agentFactory ?? defaultConfiguration.agentFactory,
    userAgent: userProvidedConfiguration.userAgent
  };
}
function getNodeHttpConfigurationDefaults(requiredHeaders, signalResourcePath) {
  return {
    ...getHttpConfigurationDefaults(requiredHeaders, signalResourcePath),
    agentFactory: httpAgentFactoryFromOptions({ keepAlive: true })
  };
}
var init_otlp_node_http_configuration = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/otlp-node-http-configuration.js"() {
    "use strict";
    init_otlp_http_configuration();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/is-export-retryable.js
function isExportHTTPErrorRetryable(statusCode) {
  return statusCode === 429 || statusCode === 502 || statusCode === 503 || statusCode === 504;
}
function parseRetryAfterToMills(retryAfter) {
  if (retryAfter == null) {
    return void 0;
  }
  const seconds = Number.parseInt(retryAfter, 10);
  if (Number.isInteger(seconds)) {
    return seconds > 0 ? seconds * 1e3 : -1;
  }
  const delay = new Date(retryAfter).getTime() - Date.now();
  if (delay >= 0) {
    return delay;
  }
  return 0;
}
var init_is_export_retryable = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/is-export-retryable.js"() {
    "use strict";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/version.js
var VERSION;
var init_version = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/version.js"() {
    "use strict";
    VERSION = "0.210.0";
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/transport/http-transport-utils.js
function sendWithHttp(request, url, headers, compression, userAgent, agent, data, onDone, timeoutMillis) {
  const parsedUrl = new URL(url);
  if (userAgent) {
    headers["User-Agent"] = `${userAgent} ${DEFAULT_USER_AGENT}`;
  } else {
    headers["User-Agent"] = DEFAULT_USER_AGENT;
  }
  const options = {
    hostname: parsedUrl.hostname,
    port: parsedUrl.port,
    path: parsedUrl.pathname,
    method: "POST",
    headers,
    agent
  };
  const req = request(options, (res) => {
    const responseData = [];
    res.on("data", (chunk) => responseData.push(chunk));
    res.on("end", () => {
      if (res.statusCode && res.statusCode < 299) {
        onDone({
          status: "success",
          data: Buffer.concat(responseData)
        });
      } else if (res.statusCode && isExportHTTPErrorRetryable(res.statusCode)) {
        onDone({
          status: "retryable",
          retryInMillis: parseRetryAfterToMills(res.headers["retry-after"])
        });
      } else {
        const error = new OTLPExporterError(res.statusMessage, res.statusCode, Buffer.concat(responseData).toString());
        onDone({
          status: "failure",
          error
        });
      }
    });
  });
  req.setTimeout(timeoutMillis, () => {
    req.destroy();
    onDone({
      status: "retryable",
      error: new Error("Request timed out")
    });
  });
  req.on("error", (error) => {
    if (isHttpTransportNetworkErrorRetryable(error)) {
      onDone({
        status: "retryable",
        error
      });
    } else {
      onDone({
        status: "failure",
        error
      });
    }
  });
  compressAndSend(req, compression, data, (error) => {
    onDone({
      status: "failure",
      error
    });
  });
}
function compressAndSend(req, compression, data, onError) {
  let dataStream = readableFromUint8Array(data);
  if (compression === "gzip") {
    req.setHeader("Content-Encoding", "gzip");
    dataStream = dataStream.on("error", onError).pipe(zlib.createGzip()).on("error", onError);
  }
  dataStream.pipe(req).on("error", onError);
}
function readableFromUint8Array(buff) {
  const readable = new import_stream.Readable();
  readable.push(buff);
  readable.push(null);
  return readable;
}
function isHttpTransportNetworkErrorRetryable(error) {
  const RETRYABLE_NETWORK_ERROR_CODES = /* @__PURE__ */ new Set([
    "ECONNRESET",
    "ECONNREFUSED",
    "EPIPE",
    "ETIMEDOUT",
    "EAI_AGAIN",
    "ENOTFOUND",
    "ENETUNREACH",
    "EHOSTUNREACH"
  ]);
  if ("code" in error && typeof error.code === "string") {
    return RETRYABLE_NETWORK_ERROR_CODES.has(error.code);
  }
  return false;
}
var zlib, import_stream, DEFAULT_USER_AGENT;
var init_http_transport_utils = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/transport/http-transport-utils.js"() {
    "use strict";
    zlib = __toESM(require("zlib"));
    import_stream = require("stream");
    init_is_export_retryable();
    init_types();
    init_version();
    DEFAULT_USER_AGENT = `OTel-OTLP-Exporter-JavaScript/${VERSION}`;
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/transport/http-exporter-transport.js
async function requestFunctionFactory(protocol) {
  const module2 = protocol === "http:" ? import("http") : import("https");
  const { request } = await module2;
  return request;
}
function createHttpExporterTransport(parameters) {
  return new HttpExporterTransport(parameters);
}
var HttpExporterTransport;
var init_http_exporter_transport = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/transport/http-exporter-transport.js"() {
    "use strict";
    init_http_transport_utils();
    HttpExporterTransport = class {
      _utils = null;
      _parameters;
      constructor(parameters) {
        this._parameters = parameters;
      }
      async send(data, timeoutMillis) {
        const { agent, request } = await this._loadUtils();
        const headers = await this._parameters.headers();
        return new Promise((resolve2) => {
          sendWithHttp(request, this._parameters.url, headers, this._parameters.compression, this._parameters.userAgent, agent, data, (result) => {
            resolve2(result);
          }, timeoutMillis);
        });
      }
      shutdown() {
      }
      async _loadUtils() {
        let utils = this._utils;
        if (utils === null) {
          const protocol = new URL(this._parameters.url).protocol;
          const [agent, request] = await Promise.all([
            this._parameters.agentFactory(protocol),
            requestFunctionFactory(protocol)
          ]);
          utils = this._utils = { agent, request };
        }
        return utils;
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/retrying-transport.js
function getJitter() {
  return Math.random() * (2 * JITTER) - JITTER;
}
function createRetryingTransport(options) {
  return new RetryingTransport(options.transport);
}
var import_api6, MAX_ATTEMPTS, INITIAL_BACKOFF, MAX_BACKOFF, BACKOFF_MULTIPLIER, JITTER, RetryingTransport;
var init_retrying_transport = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/retrying-transport.js"() {
    "use strict";
    import_api6 = require("@opentelemetry/api");
    MAX_ATTEMPTS = 5;
    INITIAL_BACKOFF = 1e3;
    MAX_BACKOFF = 5e3;
    BACKOFF_MULTIPLIER = 1.5;
    JITTER = 0.2;
    RetryingTransport = class {
      _transport;
      constructor(transport) {
        this._transport = transport;
      }
      retry(data, timeoutMillis, inMillis) {
        return new Promise((resolve2, reject) => {
          setTimeout(() => {
            this._transport.send(data, timeoutMillis).then(resolve2, reject);
          }, inMillis);
        });
      }
      async send(data, timeoutMillis) {
        let attempts = MAX_ATTEMPTS;
        let nextBackoff = INITIAL_BACKOFF;
        const deadline = Date.now() + timeoutMillis;
        let result = await this._transport.send(data, timeoutMillis);
        while (result.status === "retryable" && attempts > 0) {
          attempts--;
          const backoff = Math.max(Math.min(nextBackoff * (1 + getJitter()), MAX_BACKOFF), 0);
          nextBackoff = nextBackoff * BACKOFF_MULTIPLIER;
          const retryInMillis = result.retryInMillis ?? backoff;
          const remainingTimeoutMillis = deadline - Date.now();
          if (retryInMillis > remainingTimeoutMillis) {
            import_api6.diag.info(`Export retry time ${Math.round(retryInMillis)}ms exceeds remaining timeout ${Math.round(remainingTimeoutMillis)}ms, not retrying further.`);
            return result;
          }
          import_api6.diag.verbose(`Scheduling export retry in ${Math.round(retryInMillis)}ms`);
          result = await this.retry(data, remainingTimeoutMillis, retryInMillis);
        }
        if (result.status === "success") {
          import_api6.diag.verbose(`Export succeded after ${MAX_ATTEMPTS - attempts} retry attempts.`);
        } else if (result.status === "retryable") {
          import_api6.diag.info(`Export failed after maximum retry attempts (${MAX_ATTEMPTS}).`);
        } else {
          import_api6.diag.info(`Export failed with non-retryable error: ${result.error}`);
        }
        return result;
      }
      shutdown() {
        return this._transport.shutdown();
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/otlp-http-export-delegate.js
function createOtlpHttpExportDelegate(options, serializer) {
  return createOtlpExportDelegate({
    transport: createRetryingTransport({
      transport: createHttpExporterTransport(options)
    }),
    serializer,
    promiseHandler: createBoundedQueueExportPromiseHandler(options)
  }, { timeout: options.timeoutMillis });
}
var init_otlp_http_export_delegate = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/otlp-http-export-delegate.js"() {
    "use strict";
    init_otlp_export_delegate();
    init_http_exporter_transport();
    init_bounded_queue_export_promise_handler();
    init_retrying_transport();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/shared-env-configuration.js
function parseAndValidateTimeoutFromEnv(timeoutEnvVar) {
  const envTimeout = getNumberFromEnv(timeoutEnvVar);
  if (envTimeout != null) {
    if (Number.isFinite(envTimeout) && envTimeout > 0) {
      return envTimeout;
    }
    import_api7.diag.warn(`Configuration: ${timeoutEnvVar} is invalid, expected number greater than 0 (actual: ${envTimeout})`);
  }
  return void 0;
}
function getTimeoutFromEnv(signalIdentifier) {
  const specificTimeout = parseAndValidateTimeoutFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_TIMEOUT`);
  const nonSpecificTimeout = parseAndValidateTimeoutFromEnv("OTEL_EXPORTER_OTLP_TIMEOUT");
  return specificTimeout ?? nonSpecificTimeout;
}
function parseAndValidateCompressionFromEnv(compressionEnvVar) {
  const compression = getStringFromEnv(compressionEnvVar)?.trim();
  if (compression == null || compression === "none" || compression === "gzip") {
    return compression;
  }
  import_api7.diag.warn(`Configuration: ${compressionEnvVar} is invalid, expected 'none' or 'gzip' (actual: '${compression}')`);
  return void 0;
}
function getCompressionFromEnv(signalIdentifier) {
  const specificCompression = parseAndValidateCompressionFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_COMPRESSION`);
  const nonSpecificCompression = parseAndValidateCompressionFromEnv("OTEL_EXPORTER_OTLP_COMPRESSION");
  return specificCompression ?? nonSpecificCompression;
}
function getSharedConfigurationFromEnvironment(signalIdentifier) {
  return {
    timeoutMillis: getTimeoutFromEnv(signalIdentifier),
    compression: getCompressionFromEnv(signalIdentifier)
  };
}
var import_api7;
var init_shared_env_configuration = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/shared-env-configuration.js"() {
    "use strict";
    init_esm();
    import_api7 = require("@opentelemetry/api");
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/otlp-node-http-env-configuration.js
function getStaticHeadersFromEnv(signalIdentifier) {
  const signalSpecificRawHeaders = getStringFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_HEADERS`);
  const nonSignalSpecificRawHeaders = getStringFromEnv("OTEL_EXPORTER_OTLP_HEADERS");
  const signalSpecificHeaders = parseKeyPairsIntoRecord(signalSpecificRawHeaders);
  const nonSignalSpecificHeaders = parseKeyPairsIntoRecord(nonSignalSpecificRawHeaders);
  if (Object.keys(signalSpecificHeaders).length === 0 && Object.keys(nonSignalSpecificHeaders).length === 0) {
    return void 0;
  }
  return Object.assign({}, parseKeyPairsIntoRecord(nonSignalSpecificRawHeaders), parseKeyPairsIntoRecord(signalSpecificRawHeaders));
}
function appendRootPathToUrlIfNeeded(url) {
  try {
    const parsedUrl = new URL(url);
    return parsedUrl.toString();
  } catch {
    import_api8.diag.warn(`Configuration: Could not parse environment-provided export URL: '${url}', falling back to undefined`);
    return void 0;
  }
}
function appendResourcePathToUrl(url, path2) {
  try {
    new URL(url);
  } catch {
    import_api8.diag.warn(`Configuration: Could not parse environment-provided export URL: '${url}', falling back to undefined`);
    return void 0;
  }
  if (!url.endsWith("/")) {
    url = url + "/";
  }
  url += path2;
  try {
    new URL(url);
  } catch {
    import_api8.diag.warn(`Configuration: Provided URL appended with '${path2}' is not a valid URL, using 'undefined' instead of '${url}'`);
    return void 0;
  }
  return url;
}
function getNonSpecificUrlFromEnv(signalResourcePath) {
  const envUrl = getStringFromEnv("OTEL_EXPORTER_OTLP_ENDPOINT");
  if (envUrl === void 0) {
    return void 0;
  }
  return appendResourcePathToUrl(envUrl, signalResourcePath);
}
function getSpecificUrlFromEnv(signalIdentifier) {
  const envUrl = getStringFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_ENDPOINT`);
  if (envUrl === void 0) {
    return void 0;
  }
  return appendRootPathToUrlIfNeeded(envUrl);
}
function readFileFromEnv(signalSpecificEnvVar, nonSignalSpecificEnvVar, warningMessage) {
  const signalSpecificPath = getStringFromEnv(signalSpecificEnvVar);
  const nonSignalSpecificPath = getStringFromEnv(nonSignalSpecificEnvVar);
  const filePath = signalSpecificPath ?? nonSignalSpecificPath;
  if (filePath != null) {
    try {
      return fs.readFileSync(path.resolve(process.cwd(), filePath));
    } catch {
      import_api8.diag.warn(warningMessage);
      return void 0;
    }
  } else {
    return void 0;
  }
}
function getClientCertificateFromEnv(signalIdentifier) {
  return readFileFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_CLIENT_CERTIFICATE`, "OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE", "Failed to read client certificate chain file");
}
function getClientKeyFromEnv(signalIdentifier) {
  return readFileFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_CLIENT_KEY`, "OTEL_EXPORTER_OTLP_CLIENT_KEY", "Failed to read client certificate private key file");
}
function getRootCertificateFromEnv(signalIdentifier) {
  return readFileFromEnv(`OTEL_EXPORTER_OTLP_${signalIdentifier}_CERTIFICATE`, "OTEL_EXPORTER_OTLP_CERTIFICATE", "Failed to read root certificate file");
}
function getNodeHttpConfigurationFromEnvironment(signalIdentifier, signalResourcePath) {
  return {
    ...getSharedConfigurationFromEnvironment(signalIdentifier),
    url: getSpecificUrlFromEnv(signalIdentifier) ?? getNonSpecificUrlFromEnv(signalResourcePath),
    headers: wrapStaticHeadersInFunction(getStaticHeadersFromEnv(signalIdentifier)),
    agentFactory: httpAgentFactoryFromOptions({
      keepAlive: true,
      ca: getRootCertificateFromEnv(signalIdentifier),
      cert: getClientCertificateFromEnv(signalIdentifier),
      key: getClientKeyFromEnv(signalIdentifier)
    })
  };
}
var fs, path, import_api8;
var init_otlp_node_http_env_configuration = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/otlp-node-http-env-configuration.js"() {
    "use strict";
    fs = __toESM(require("fs"));
    path = __toESM(require("path"));
    init_esm();
    import_api8 = require("@opentelemetry/api");
    init_shared_env_configuration();
    init_shared_configuration();
    init_otlp_node_http_configuration();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/convert-legacy-http-options.js
function convertLegacyHeaders(config) {
  if (typeof config.headers === "function") {
    return config.headers;
  }
  return wrapStaticHeadersInFunction(config.headers);
}
var init_convert_legacy_http_options = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/convert-legacy-http-options.js"() {
    "use strict";
    init_shared_configuration();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/convert-legacy-node-http-options.js
function convertLegacyAgentOptions(config) {
  if (typeof config.httpAgentOptions === "function") {
    return config.httpAgentOptions;
  }
  let legacy = config.httpAgentOptions;
  if (config.keepAlive != null) {
    legacy = { keepAlive: config.keepAlive, ...legacy };
  }
  if (legacy != null) {
    return httpAgentFactoryFromOptions(legacy);
  } else {
    return void 0;
  }
}
function convertLegacyHttpOptions(config, signalIdentifier, signalResourcePath, requiredHeaders) {
  if (config.metadata) {
    import_api9.diag.warn("Metadata cannot be set when using http");
  }
  return mergeOtlpNodeHttpConfigurationWithDefaults({
    url: config.url,
    headers: convertLegacyHeaders(config),
    concurrencyLimit: config.concurrencyLimit,
    timeoutMillis: config.timeoutMillis,
    compression: config.compression,
    agentFactory: convertLegacyAgentOptions(config),
    userAgent: config.userAgent
  }, getNodeHttpConfigurationFromEnvironment(signalIdentifier, signalResourcePath), getNodeHttpConfigurationDefaults(requiredHeaders, signalResourcePath));
}
var import_api9;
var init_convert_legacy_node_http_options = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/configuration/convert-legacy-node-http-options.js"() {
    "use strict";
    import_api9 = require("@opentelemetry/api");
    init_otlp_node_http_configuration();
    init_index_node_http();
    init_otlp_node_http_env_configuration();
    init_convert_legacy_http_options();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/index-node-http.js
var init_index_node_http = __esm({
  "../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/build/esm/index-node-http.js"() {
    "use strict";
    init_otlp_node_http_configuration();
    init_otlp_http_export_delegate();
    init_convert_legacy_node_http_options();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-trace-otlp-http@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/platform/node/OTLPTraceExporter.js
var OTLPTraceExporter;
var init_OTLPTraceExporter = __esm({
  "../../node_modules/.pnpm/@opentelemetry+exporter-trace-otlp-http@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/platform/node/OTLPTraceExporter.js"() {
    "use strict";
    init_esm2();
    init_esm3();
    init_index_node_http();
    OTLPTraceExporter = class extends OTLPExporterBase {
      constructor(config = {}) {
        super(createOtlpHttpExportDelegate(convertLegacyHttpOptions(config, "TRACES", "v1/traces", {
          "Content-Type": "application/json"
        }), JsonTraceSerializer));
      }
    };
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-trace-otlp-http@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/platform/node/index.js
var init_node2 = __esm({
  "../../node_modules/.pnpm/@opentelemetry+exporter-trace-otlp-http@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/platform/node/index.js"() {
    "use strict";
    init_OTLPTraceExporter();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-trace-otlp-http@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/platform/index.js
var init_platform2 = __esm({
  "../../node_modules/.pnpm/@opentelemetry+exporter-trace-otlp-http@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/platform/index.js"() {
    "use strict";
    init_node2();
  }
});

// ../../node_modules/.pnpm/@opentelemetry+exporter-trace-otlp-http@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  OTLPTraceExporter: () => OTLPTraceExporter
});
var init_esm4 = __esm({
  "../../node_modules/.pnpm/@opentelemetry+exporter-trace-otlp-http@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-trace-otlp-http/build/esm/index.js"() {
    "use strict";
    init_platform2();
  }
});

// src/server/index.ts
var server_exports = {};
__export(server_exports, {
  ExporterType: () => ExporterType,
  setupObservability: () => setupObservability
});
module.exports = __toCommonJS(server_exports);

// src/server/setup.ts
var TRUTHY_ENV_VALUES = /* @__PURE__ */ new Set(["true", "1", "yes", "on"]);
var DEFAULT_BATCH_CONFIG = {
  maxExportBatchSize: 100,
  scheduledDelayMillis: 5e3,
  maxQueueSize: 2048,
  exportTimeoutMillis: 3e4
};
function mergeConfigs(paramConfigs) {
  const result = {
    console: null,
    otlp: [],
    custom: []
  };
  const autoTracesStdout = process.env.AUTO_TRACES_STDOUT?.toLowerCase() || "";
  if (TRUTHY_ENV_VALUES.has(autoTracesStdout)) {
    result.console = { type: "console" };
    console.debug(
      `[Observability] AUTO_TRACES_STDOUT=${autoTracesStdout}, console exporter enabled`
    );
  }
  for (const config of paramConfigs) {
    switch (config.type) {
      case "console":
        result.console = { ...result.console, ...config };
        break;
      case "otlp":
        result.otlp.push(config);
        break;
      case "custom":
        result.custom.push(config);
        break;
    }
  }
  return result;
}
function resolveBatchConfig(batch) {
  return { ...DEFAULT_BATCH_CONFIG, ...batch };
}
async function safeSetup(name, setupFn) {
  try {
    await setupFn();
  } catch (error) {
    console.warn(
      `[Observability] ${name} setup failed (non-fatal): ${error instanceof Error ? error.message : String(error)}`
    );
  }
}
async function setupConsoleExporter(config) {
  const { trace } = await import("@opentelemetry/api");
  const { resourceFromAttributes } = await import("@opentelemetry/resources");
  const { NodeTracerProvider } = await import("@opentelemetry/sdk-trace-node");
  const { ConsoleSpanExporter, BatchSpanProcessor } = await import("@opentelemetry/sdk-trace-base");
  const batchConfig = resolveBatchConfig(config.batch);
  let provider = trace.getTracerProvider();
  const isRealProvider = "addSpanProcessor" in provider;
  if (isRealProvider) {
    const exporter = new ConsoleSpanExporter();
    const processor = new BatchSpanProcessor(exporter, batchConfig);
    provider.addSpanProcessor(processor);
    console.info(
      `[Observability] Console exporter configured (batch=${batchConfig.maxExportBatchSize}, delay=${batchConfig.scheduledDelayMillis}ms)`
    );
  } else {
    const resource = resourceFromAttributes({
      "service.name": process.env.OTEL_SERVICE_NAME || "ag-ui-server",
      "service.version": "1.0.0"
    });
    const exporter = new ConsoleSpanExporter();
    const processor = new BatchSpanProcessor(exporter, batchConfig);
    const tracerProvider = new NodeTracerProvider({
      resource,
      spanProcessors: [processor]
    });
    tracerProvider.register();
    console.info(
      `[Observability] Console exporter configured (batch=${batchConfig.maxExportBatchSize}, delay=${batchConfig.scheduledDelayMillis}ms)`
    );
  }
}
async function setupOTLPExporter(config) {
  const { trace } = await import("@opentelemetry/api");
  const { resourceFromAttributes } = await import("@opentelemetry/resources");
  const { NodeTracerProvider } = await import("@opentelemetry/sdk-trace-node");
  const { OTLPTraceExporter: OTLPTraceExporter2 } = await Promise.resolve().then(() => (init_esm4(), esm_exports));
  const { BatchSpanProcessor } = await import("@opentelemetry/sdk-trace-base");
  const batchConfig = resolveBatchConfig(config.batch);
  let provider = trace.getTracerProvider();
  const isRealProvider = "addSpanProcessor" in provider;
  if (isRealProvider) {
    const exporter = new OTLPTraceExporter2({
      url: config.url,
      headers: config.headers,
      timeoutMillis: config.timeout ?? 1e4
    });
    const processor = new BatchSpanProcessor(exporter, batchConfig);
    provider.addSpanProcessor(processor);
    console.info(
      `[Observability] OTLP exporter configured (url=${config.url}, batch=${batchConfig.maxExportBatchSize}, delay=${batchConfig.scheduledDelayMillis}ms)`
    );
  } else {
    const resource = resourceFromAttributes({
      "service.name": process.env.OTEL_SERVICE_NAME || "ag-ui-server",
      "service.version": "1.0.0"
    });
    const exporter = new OTLPTraceExporter2({
      url: config.url,
      headers: config.headers,
      timeoutMillis: config.timeout ?? 1e4
    });
    const processor = new BatchSpanProcessor(exporter, batchConfig);
    const tracerProvider = new NodeTracerProvider({
      resource,
      spanProcessors: [processor]
    });
    tracerProvider.register();
    console.info(
      `[Observability] OTLP exporter configured (url=${config.url}, batch=${batchConfig.maxExportBatchSize}, delay=${batchConfig.scheduledDelayMillis}ms)`
    );
  }
}
async function setupCustomExporter(config) {
  await config.setup();
  console.info(`[Observability] Custom exporter setup completed`);
}
async function applyMergedConfigs(merged) {
  const setupTasks = [];
  if (merged.console) {
    setupTasks.push(safeSetup("Console exporter", () => setupConsoleExporter(merged.console)));
  }
  for (const otlp of merged.otlp) {
    setupTasks.push(safeSetup(`OTLP exporter (${otlp.url})`, () => setupOTLPExporter(otlp)));
  }
  for (const custom of merged.custom) {
    setupTasks.push(safeSetup("Custom exporter", () => setupCustomExporter(custom)));
  }
  await Promise.all(setupTasks);
  if (merged.console || merged.otlp.length > 0 || merged.custom.length > 0) {
    console.info(`[Observability] Setup completed`);
  }
}
var setupPromise = null;
async function setupObservability(configs) {
  if (setupPromise) {
    return setupPromise;
  }
  setupPromise = (async () => {
    try {
      const configsArray = configs ? Array.isArray(configs) ? configs : [configs] : [];
      const merged = mergeConfigs(configsArray);
      await applyMergedConfigs(merged);
    } catch (error) {
      setupPromise = null;
      console.warn(
        `[Observability] Setup failed: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  })();
  return setupPromise;
}

// src/server/config.ts
var ExporterType = {
  /** Console exporter - outputs traces to stdout */
  Console: "console",
  /** OTLP exporter - sends traces to OTLP-compatible backend */
  OTLP: "otlp",
  /** Custom exporter - user-defined setup logic */
  Custom: "custom"
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ExporterType,
  setupObservability
});
//# sourceMappingURL=server.js.map