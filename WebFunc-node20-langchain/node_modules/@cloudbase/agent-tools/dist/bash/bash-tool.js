"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.createBashTool = createBashTool;
exports.createMultiCommandTool = createMultiCommandTool;
const v4_1 = require("zod/v4");
const utils_1 = require("../utils");
const path = __importStar(require("path"));
const os = __importStar(require("os"));
const fs = __importStar(require("fs"));
const bashToolSchema = v4_1.z.object({
    command: v4_1.z
        .string()
        .describe("The bash command to execute. Use '&' for background processes. If a process will run and not stop on its own, you must use '&' to run it in the background. "),
    description: v4_1.z
        .string()
        .optional()
        .describe("Brief description of the command's purpose"),
    cwd: v4_1.z
        .string()
        .optional()
        .describe("Working directory for the command (optional)"),
    env: v4_1.z
        .record(v4_1.z.string(), v4_1.z.string())
        .optional()
        .describe("Environment variables to set (optional)"),
    timeout: v4_1.z
        .number()
        .optional()
        .describe("Timeout in milliseconds (default: 10000), -1 means no timeout."),
    /**
     * TODO: child process 使用 bash 启动后未实现
     */
    // input: z
    //   .string()
    //   .optional()
    //   .describe("Input to send to the command via stdin (optional)"),
    /**
     * 默认参数，不对 LLM 暴露
     */
    // enableInteractiveShell: z
    //   .boolean()
    //   .optional()
    //   .describe("Enable PTY for interactive commands (default: true)"),
});
function createBashTool(context) {
    // 参考 Google CLI: 命令包装逻辑在工具层实现
    function wrapCommandForBackgroundDetection(command, enableDetection) {
        if (!enableDetection) {
            return command;
        }
        // 参考 Google CLI 的命令包装模式
        // 包装命令以捕获退出码和后台进程信息
        const tempFile = path.join(os.tmpdir(), `agkit_bg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}.tmp`);
        if (!command.endsWith("&"))
            command += ";";
        return `{ ${command} }; __code=$?; pgrep -g 0 >${tempFile} 2>&1; exit $__code;`;
    }
    // 参考 Google CLI: 解析后台进程结果
    function parseBackgroundProcessResult(result, originalCommand) {
        const isBackgroundCommand = originalCommand.trim().endsWith("&");
        if (!isBackgroundCommand) {
            return result;
        }
        // 尝试从临时文件读取后台进程信息
        const tempFiles = fs
            .readdirSync(os.tmpdir())
            .filter((f) => f.startsWith("agkit_bg_"));
        let backgroundPids = [];
        for (const tempFile of tempFiles) {
            try {
                const content = fs.readFileSync(path.join(os.tmpdir(), tempFile), "utf8");
                const pids = content
                    .trim()
                    .split("\n")
                    .filter((pid) => pid && !isNaN(parseInt(pid)));
                backgroundPids.push(...pids);
                // 清理临时文件
                fs.unlinkSync(path.join(os.tmpdir(), tempFile));
            }
            catch (error) {
                // 忽略读取错误
            }
        }
        return {
            ...result,
            backgroundPids,
            executionMethod: result.executionMethod || "child_process",
        };
    }
    return (0, utils_1.tool)(async (input) => {
        const { command, description, cwd, env, timeout = context.defaultTimeout || 10000, } = input;
        const { input: stdinInput, enableInteractiveShell = true } = input;
        const { onStdout = (data) => { }, onStderr = (data) => { }, enableBackgroundProcessDetection = true, } = input;
        try {
            // 参考 Google CLI: 在工具层实现命令包装逻辑
            const wrappedCommand = wrapCommandForBackgroundDetection(command, enableBackgroundProcessDetection);
            const options = {
                cwd: cwd || path.resolve(context.workingDirectory || process.cwd()),
                env: { ...context.environmentVariables, ...env },
                timeout,
                input: stdinInput,
                onStdout,
                onStderr,
                enableInteractiveShell,
                originalCommand: command, // 传递原始命令
            };
            // Execute the wrapped command
            const result = await context.bashOperator.executeCommand(wrappedCommand, options);
            // 参考 Google CLI: 在工具层解析后台进程信息
            const parsedResult = parseBackgroundProcessResult(result, command);
            // Get current working directory
            const currentDir = await context.bashOperator.getCurrentDirectory();
            // 参考 Google CLI 的返回格式
            return new utils_1.ToolResult({
                success: parsedResult.success,
                data: {
                    command,
                    description: description || undefined,
                    directory: currentDir,
                    stdout: parsedResult.stdout || "(empty)",
                    stderr: parsedResult.stderr || "(empty)",
                    error: parsedResult.success
                        ? "(none)"
                        : parsedResult.stderr || "Unknown error",
                    exit_code: parsedResult.exitCode ?? "(none)",
                    signal: parsedResult.signal ?? "(none)",
                    background_pids: parsedResult.backgroundPids?.length
                        ? parsedResult.backgroundPids.join(", ")
                        : "(none)",
                    process_group_pgid: parsedResult.processGroupPid ?? "(none)",
                    execution_method: parsedResult.executionMethod || "child_process",
                },
                executionTime: parsedResult.executionTime,
            });
        }
        catch (error) {
            return (0, utils_1.handleToolError)(error, "Bash command execution", "execution", {
                command,
                description,
                directory: path.resolve(context.workingDirectory || ""),
                stdout: "",
                stderr: error instanceof Error ? error.message : String(error),
                error: error instanceof Error ? error.message : String(error),
                exit_code: null,
                signal: "(none)",
                background_pids: "(none)",
                process_group_pgid: "(none)",
                execution_method: "none",
            });
        }
    }, {
        name: "BashTool",
        description: `Execute shell commands with advanced features. Can start background processes using '&'.
      
      Features:
      - Background process detection with PID tracking
      - Interactive shell support via PTY (pseudo-terminal)
      - Real-time output streaming
      - Cross-platform compatibility (Linux/macOS/Windows)
      
      Examples:
      - Regular command: "ls -la"
      - Background server: "npm run dev &"
      - Interactive command: "vim file.txt" (requires enableInteractiveShell: true)
      
      Returns detailed execution information including background PIDs, signals, and execution method.`,
        schema: bashToolSchema,
        getDisplay: ({ name, input }) => {
            const bgIndicator = input.command.includes("&") ? " (background)" : "";
            const ptyIndicator = input.enableInteractiveShell
                ? " (interactive)"
                : "";
            return `> Using ${name} to execute command: ${input.command}${bgIndicator}${ptyIndicator}`;
        },
    });
}
// Multi-command execution tool
const multiCommandSchema = v4_1.z.object({
    commands: v4_1.z
        .array(v4_1.z.string())
        .describe("Array of bash commands to execute in sequence"),
    cwd: v4_1.z
        .string()
        .optional()
        .describe("Working directory for all commands (optional)"),
    env: v4_1.z
        .record(v4_1.z.string(), v4_1.z.string())
        .optional()
        .describe("Environment variables to set (optional)"),
    timeout: v4_1.z
        .number()
        .optional()
        .describe("Timeout in milliseconds per command (default: 30000)"),
    continue_on_error: v4_1.z
        .boolean()
        .optional()
        .describe("Continue executing remaining commands if one fails (default: false)"),
});
function createMultiCommandTool(context) {
    return (0, utils_1.tool)(async (input) => {
        const { commands, cwd, env, timeout = context.defaultTimeout || 30000, continue_on_error = false, } = input;
        const { onStdout = (data) => { }, onStderr = (data) => { } } = input;
        const startTime = Date.now();
        const results = [];
        let successfulCommands = 0;
        let failedCommands = 0;
        try {
            // Prepare command options
            const options = {
                cwd: cwd || path.resolve(context.workingDirectory),
                env: {
                    ...context.environmentVariables,
                    ...env,
                    CONTINUE_ON_ERROR: continue_on_error ? "1" : "0",
                },
                timeout,
                onStdout,
                onStderr,
            };
            // Execute commands in sequence
            for (let i = 0; i < commands.length; i++) {
                const command = commands[i];
                try {
                    const result = await context.bashOperator.executeCommand(command, options);
                    results.push({
                        command,
                        success: result.success,
                        exit_code: result.exitCode,
                        stdout: result.stdout,
                        stderr: result.stderr,
                        execution_time: result.executionTime,
                    });
                    if (result.success) {
                        successfulCommands++;
                    }
                    else {
                        failedCommands++;
                        // Stop on first failure unless continue_on_error is true
                        if (!continue_on_error) {
                            break;
                        }
                    }
                }
                catch (error) {
                    failedCommands++;
                    results.push({
                        command,
                        success: false,
                        exit_code: null,
                        stdout: "",
                        stderr: error instanceof Error ? error.message : String(error),
                        execution_time: 0,
                    });
                    if (!continue_on_error) {
                        break;
                    }
                }
            }
            const currentDir = await context.bashOperator.getCurrentDirectory();
            return new utils_1.ToolResult({
                success: failedCommands === 0,
                data: {
                    commands,
                    results,
                    successful_commands: successfulCommands,
                    failed_commands: failedCommands,
                    working_directory: currentDir,
                },
                executionTime: Date.now() - startTime,
            });
        }
        catch (error) {
            return (0, utils_1.handleToolError)(error, "MultiCommandTool", "execution", {
                commands,
                results,
                successful_commands: successfulCommands,
                failed_commands: failedCommands + 1,
                working_directory: path.resolve(context.workingDirectory || ""),
            });
        }
    }, {
        name: "MultiCommandTool",
        description: "Execute multiple bash commands in sequence with support for different execution environments",
        schema: multiCommandSchema,
        getDisplay: ({ name, input }) => {
            return `> Using ${name} to execute ${input.commands.length} commands`;
        },
    });
}
//# sourceMappingURL=bash-tool.js.map