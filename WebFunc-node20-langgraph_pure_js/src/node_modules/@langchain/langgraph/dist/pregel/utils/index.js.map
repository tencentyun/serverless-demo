{"version":3,"file":"index.js","names":[],"sources":["../../../src/pregel/utils/index.ts"],"sourcesContent":["import { Callbacks } from \"@langchain/core/callbacks/manager\";\nimport { RunnableConfig } from \"@langchain/core/runnables\";\nimport type {\n  ChannelVersions,\n  CheckpointMetadata,\n} from \"@langchain/langgraph-checkpoint\";\nimport { CONFIG_KEY_CHECKPOINT_MAP, START } from \"../../constants.js\";\n\nexport function getNullChannelVersion(currentVersions: ChannelVersions) {\n  // Short circuit for commonly used channels such as __start__\n  // (used by StateGraph)\n  const startVersion = typeof currentVersions[START];\n  if (startVersion === \"number\") return 0;\n  if (startVersion === \"string\") return \"\";\n\n  // Defer back to obtaining a first key from channel versions\n  for (const key in currentVersions) {\n    if (!Object.prototype.hasOwnProperty.call(currentVersions, key)) continue;\n    const versionType = typeof currentVersions[key];\n    if (versionType === \"number\") return 0;\n    if (versionType === \"string\") return \"\";\n    break;\n  }\n\n  return undefined;\n}\n\nexport function getNewChannelVersions(\n  previousVersions: ChannelVersions,\n  currentVersions: ChannelVersions\n): ChannelVersions {\n  // Get new channel versions\n  if (Object.keys(previousVersions).length > 0) {\n    const nullVersion = getNullChannelVersion(currentVersions);\n    return Object.fromEntries(\n      Object.entries(currentVersions).filter(\n        ([k, v]) => v > (previousVersions[k] ?? nullVersion)\n      )\n    );\n  } else {\n    return currentVersions;\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function _coerceToDict(value: any, defaultKey: string) {\n  return value &&\n    !Array.isArray(value) &&\n    // eslint-disable-next-line no-instanceof/no-instanceof\n    !(value instanceof Date) &&\n    typeof value === \"object\"\n    ? value\n    : { [defaultKey]: value };\n}\n\nexport type RetryPolicy = {\n  /**\n   * Amount of time that must elapse before the first retry occurs in milliseconds.\n   * @default 500\n   */\n  initialInterval?: number;\n\n  /**\n   * Multiplier by which the interval increases after each retry.\n   * @default 2\n   */\n  backoffFactor?: number;\n\n  /**\n   * Maximum amount of time that may elapse between retries in milliseconds.\n   * @default 128000\n   */\n  maxInterval?: number;\n\n  /**\n   * Maximum amount of time that may elapse between retries.\n   * @default 3\n   */\n  maxAttempts?: number;\n\n  /** Whether to add random jitter to the interval between retries. */\n  jitter?: boolean;\n\n  /** A function that returns True for exceptions that should trigger a retry. */\n  retryOn?: (e: any) => boolean; // eslint-disable-line @typescript-eslint/no-explicit-any\n\n  /** Whether to log a warning when a retry is attempted. Defaults to true. */\n  logWarning?: boolean;\n};\n\n/**\n * Configuration for caching nodes.\n */\nexport type CachePolicy = {\n  /**\n   * A function used to generate a cache key from node's input.\n   * @returns A key for the cache.\n   */\n  keyFunc?: (args: unknown[]) => string;\n\n  /**\n   * The time to live for the cache in seconds.\n   * If not defined, the entry will never expire.\n   */\n  ttl?: number;\n};\n\nexport function patchConfigurable(\n  config: RunnableConfig | undefined,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  patch: Record<string, any>\n): RunnableConfig {\n  if (config === null) {\n    return { configurable: patch };\n  } else if (config?.configurable === undefined) {\n    return { ...config, configurable: patch };\n  } else {\n    return {\n      ...config,\n      configurable: { ...config.configurable, ...patch },\n    };\n  }\n}\n\nexport function patchCheckpointMap(\n  config: RunnableConfig,\n  metadata?: CheckpointMetadata\n): RunnableConfig {\n  const parents = metadata?.parents ?? {};\n\n  if (Object.keys(parents).length > 0) {\n    return patchConfigurable(config, {\n      [CONFIG_KEY_CHECKPOINT_MAP]: {\n        ...parents,\n        [config.configurable?.checkpoint_ns ?? \"\"]:\n          config.configurable?.checkpoint_id,\n      },\n    });\n  } else {\n    return config;\n  }\n}\n\n/**\n * Combine multiple abort signals into a single abort signal.\n * @param signals - The abort signals to combine.\n * @returns A combined abort signal and a dispose function to remove the abort listener if unused.\n */\nexport function combineAbortSignals(...x: (AbortSignal | undefined)[]): {\n  signal: AbortSignal | undefined;\n  dispose?: () => void;\n} {\n  const signals = [...new Set(x.filter(Boolean))] as AbortSignal[];\n\n  if (signals.length === 0) {\n    return { signal: undefined, dispose: undefined };\n  }\n\n  if (signals.length === 1) {\n    return { signal: signals[0], dispose: undefined };\n  }\n\n  const combinedController = new AbortController();\n  const listener = () => {\n    const reason = signals.find((s) => s.aborted)?.reason;\n    combinedController.abort(reason);\n    signals.forEach((s) => s.removeEventListener(\"abort\", listener));\n  };\n\n  signals.forEach((s) => s.addEventListener(\"abort\", listener, { once: true }));\n\n  const hasAlreadyAbortedSignal = signals.find((s) => s.aborted);\n  if (hasAlreadyAbortedSignal) {\n    combinedController.abort(hasAlreadyAbortedSignal.reason);\n  }\n\n  return {\n    signal: combinedController.signal,\n    dispose: () => {\n      signals.forEach((s) => s.removeEventListener(\"abort\", listener));\n    },\n  };\n}\n\n/**\n * Combine multiple callbacks into a single callback.\n * @param callback1 - The first callback to combine.\n * @param callback2 - The second callback to combine.\n * @returns A single callback that is a combination of the input callbacks.\n */\nexport const combineCallbacks = (\n  callback1?: Callbacks,\n  callback2?: Callbacks\n): Callbacks | undefined => {\n  if (!callback1 && !callback2) {\n    return undefined;\n  }\n\n  if (!callback1) {\n    return callback2;\n  }\n\n  if (!callback2) {\n    return callback1;\n  }\n  if (Array.isArray(callback1) && Array.isArray(callback2)) {\n    return [...callback1, ...callback2];\n  }\n  if (Array.isArray(callback1)) {\n    return [...callback1, callback2] as Callbacks;\n  }\n  if (Array.isArray(callback2)) {\n    return [callback1, ...callback2];\n  }\n  return [callback1, callback2] as Callbacks;\n};\n"],"mappings":";;;AAQA,SAAgB,sBAAsB,iBAAkC;CAGtE,MAAM,eAAe,OAAO,gBAAgB;AAC5C,KAAI,iBAAiB,SAAU,QAAO;AACtC,KAAI,iBAAiB,SAAU,QAAO;AAGtC,MAAK,MAAM,OAAO,iBAAiB;AACjC,MAAI,CAAC,OAAO,UAAU,eAAe,KAAK,iBAAiB,IAAI,CAAE;EACjE,MAAM,cAAc,OAAO,gBAAgB;AAC3C,MAAI,gBAAgB,SAAU,QAAO;AACrC,MAAI,gBAAgB,SAAU,QAAO;AACrC;;;AAMJ,SAAgB,sBACd,kBACA,iBACiB;AAEjB,KAAI,OAAO,KAAK,iBAAiB,CAAC,SAAS,GAAG;EAC5C,MAAM,cAAc,sBAAsB,gBAAgB;AAC1D,SAAO,OAAO,YACZ,OAAO,QAAQ,gBAAgB,CAAC,QAC7B,CAAC,GAAG,OAAO,KAAK,iBAAiB,MAAM,aACzC,CACF;OAED,QAAO;;AAKX,SAAgB,cAAc,OAAY,YAAoB;AAC5D,QAAO,SACL,CAAC,MAAM,QAAQ,MAAM,IAErB,EAAE,iBAAiB,SACnB,OAAO,UAAU,WACf,QACA,GAAG,aAAa,OAAO;;AAuD7B,SAAgB,kBACd,QAEA,OACgB;AAChB,KAAI,WAAW,KACb,QAAO,EAAE,cAAc,OAAO;UACrB,QAAQ,iBAAiB,OAClC,QAAO;EAAE,GAAG;EAAQ,cAAc;EAAO;KAEzC,QAAO;EACL,GAAG;EACH,cAAc;GAAE,GAAG,OAAO;GAAc,GAAG;GAAO;EACnD;;AAIL,SAAgB,mBACd,QACA,UACgB;CAChB,MAAM,UAAU,UAAU,WAAW,EAAE;AAEvC,KAAI,OAAO,KAAK,QAAQ,CAAC,SAAS,EAChC,QAAO,kBAAkB,QAAQ,GAC9B,4BAA4B;EAC3B,GAAG;GACF,OAAO,cAAc,iBAAiB,KACrC,OAAO,cAAc;EACxB,EACF,CAAC;KAEF,QAAO;;;;;;;AASX,SAAgB,oBAAoB,GAAG,GAGrC;CACA,MAAM,UAAU,CAAC,GAAG,IAAI,IAAI,EAAE,OAAO,QAAQ,CAAC,CAAC;AAE/C,KAAI,QAAQ,WAAW,EACrB,QAAO;EAAE,QAAQ;EAAW,SAAS;EAAW;AAGlD,KAAI,QAAQ,WAAW,EACrB,QAAO;EAAE,QAAQ,QAAQ;EAAI,SAAS;EAAW;CAGnD,MAAM,qBAAqB,IAAI,iBAAiB;CAChD,MAAM,iBAAiB;EACrB,MAAM,SAAS,QAAQ,MAAM,MAAM,EAAE,QAAQ,EAAE;AAC/C,qBAAmB,MAAM,OAAO;AAChC,UAAQ,SAAS,MAAM,EAAE,oBAAoB,SAAS,SAAS,CAAC;;AAGlE,SAAQ,SAAS,MAAM,EAAE,iBAAiB,SAAS,UAAU,EAAE,MAAM,MAAM,CAAC,CAAC;CAE7E,MAAM,0BAA0B,QAAQ,MAAM,MAAM,EAAE,QAAQ;AAC9D,KAAI,wBACF,oBAAmB,MAAM,wBAAwB,OAAO;AAG1D,QAAO;EACL,QAAQ,mBAAmB;EAC3B,eAAe;AACb,WAAQ,SAAS,MAAM,EAAE,oBAAoB,SAAS,SAAS,CAAC;;EAEnE;;;;;;;;AASH,MAAa,oBACX,WACA,cAC0B;AAC1B,KAAI,CAAC,aAAa,CAAC,UACjB;AAGF,KAAI,CAAC,UACH,QAAO;AAGT,KAAI,CAAC,UACH,QAAO;AAET,KAAI,MAAM,QAAQ,UAAU,IAAI,MAAM,QAAQ,UAAU,CACtD,QAAO,CAAC,GAAG,WAAW,GAAG,UAAU;AAErC,KAAI,MAAM,QAAQ,UAAU,CAC1B,QAAO,CAAC,GAAG,WAAW,UAAU;AAElC,KAAI,MAAM,QAAQ,UAAU,CAC1B,QAAO,CAAC,WAAW,GAAG,UAAU;AAElC,QAAO,CAAC,WAAW,UAAU"}