const { Writable } = require('stream');
const EventEmitter = require('events');

class MultipleWriteStream extends Writable {
  /**
   * @param {Object} options
   * @param {Function} options.getNextStream
   * - the async function that return { stream, streamSize, nextParams }
   * - if no more next stream, return null
   * @param {Function} options.nextStreamEvent
   * - the event that trigger getNextStream
   * - when current stream emit nextStreamEvent event, getNextStream function will be triggered
   * @description - return a writable stream which combine by multiple writable stream
   * @example
   * new MultipleWriteStream({
   *  nextStreamEvent: 'finish',
   *  async getNextStream({ number = 0 } = {}) {
   *    if(number >= 10) {
   *      return;
   *    }
   *    return {
   *      stream: fs.createWriteStream(`./${number}.md`),
   *      streamSize: 1 * 1024 * 1024,
   *      nextParams: {
   *        number: number + 1,
   *      },
   *    }
   *  }
   * })
   */
  constructor(
    { getNextStream, nextStreamEvent = 'finish', ...args },
    ...resArgs
  ) {
    super(args, ...resArgs);
    Object.assign(this, {
      getNextStream,
      nextStreamEvent,
      currentStream: null,
      currentRestSize: 0,
      nextParams: {},
      finalCallback: null,
    });
    this.initSource();
  }
  initSource() {
    this.source = new EventEmitter();
    this.source.on('write', async (chunk, encoding, callback) => {
      try {
        if (!this.currentStream || !this.currentRestSize) {
          await this.initCurrentStream();
        }
        if (!this.currentStream) {
          callback();
          return;
        }
        if (this.currentRestSize <= chunk.length) {
          this.processLastChunk(chunk, encoding, callback);
        } else {
          this.processMiddleChunk(chunk, encoding, callback);
        }
      } catch (err) {
        callback(err);
      }
    });
    this.source.on('end', () => {
      if (this.finalCallback) {
        const { finalCallback } = this;
        this.finalCallback = null;
        finalCallback();
      }
    });
  }
  async initCurrentStream() {
    if (this.currentStream && this.currentRestSize) {
      return;
    }
    const newStreamConfig = await this.getNextStream(this.nextParams);
    if (newStreamConfig) {
      const { stream, streamSize, nextParams } = newStreamConfig;
      Object.assign(this, {
        currentStream: stream,
        currentRestSize: streamSize,
        nextParams,
      });
      this.currentStream.once('finish', () => {
        if (!this.currentStream.eventNames().includes(this.nextStreamEvent)) {
          this.currentStream.on(this.nextStreamEvent, async () => {
            try {
              this.currentRestSize = 0;
              await this.initCurrentStream();
            } catch (err) {
              this.emit('error', err);
            }
          });
        }
      });
      this.currentStream.on('error', err => this.emit('error', err));
    } else {
      this.currentStream = null;
      this.currentRestSize = 0;
      // setTimeout(() => this.source.emit('end'), 0);
      this.source.emit('end');
    }
  }
  processMiddleChunk(chunk, encoding, callback) {
    this.currentStream.write(chunk, encoding, (err, ...args) => {
      if (err) {
        callback(err);
        return;
      }
      this.currentRestSize -= chunk.length;
      callback(null, ...args);
    });
  }
  processLastChunk(chunk, encoding, callback) {
    const currentChunk = chunk.slice(0, this.currentRestSize);
    const restChunk = chunk.slice(this.currentRestSize);
    this.currentStream.on(this.nextStreamEvent, () => {
      this.currentRestSize = 0;
      this.source.emit('write', restChunk, encoding, callback);
    });
    this.currentStream.end(currentChunk, encoding, (err) => {
      if (err) {
        callback(err);
      }
    });
  }
  _write(chunk, encoding, callback) {
    this.source.emit('write', chunk, encoding, callback);
  }
  _final(callback) {
    this.finalCallback = callback;
    this.source.emit('end');
  }
  _destroy(err, callback) {
    callback();
  }
}

module.exports = MultipleWriteStream;
