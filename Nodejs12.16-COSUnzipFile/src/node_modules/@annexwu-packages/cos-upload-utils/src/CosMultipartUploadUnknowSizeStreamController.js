/* eslint-disable no-underscore-dangle */
/* eslint-disable no-param-reassign */
const { PassThrough } = require('stream');
const { getCRC64FromBuffer } = require('@annexwu-packages/simple-stream-utils');
const CosMultipartUploadBase = require('./CosMultipartUploadBase');
const QueueConsumerWriteStream = require('./common/QueueConsumerWriteStream');
const ExpectChunkSizeTransformStream = require('./common/ExpectChunkSizeTransformStream');

class CosMultipartUploadUnknowSizeStreamController extends CosMultipartUploadBase {
  /**
   * @param {Object} options
   * @param {Object} options.object
   * @param {String} options.object.Bucket
   * @param {String} options.object.Region
   * @param {String} options.object.Key
   * @param {Number} options.object.ContentLength
   * @param {String} options.uuid
   * @param {Number} options.chunkSize
   * @param {Boolean} options.hashCheck
   */
  async getStream({
    object: { Bucket, Region, Key, ContentLength, ...args },
    uuid = '',
    chunkSize,
    hashCheck,
  }) {
    chunkSize = chunkSize || this.getDefaultChunkSize(ContentLength);
    hashCheck = this.getHashCheck(hashCheck);
    uuid = `${Bucket}-${Region}-${Key}-${chunkSize}-${
      ContentLength || 'unknow'
    }-${uuid}`;
    const defaultCacheData = {
      object: {
        Bucket,
        Region,
        Key,
        ContentLength,
        ...args,
      },
      process: {},
      chunkSize,
      hashCheck,
    };
    this.cacheData[uuid] = this.cacheData[uuid] || defaultCacheData;
    try {
      await this.multipartInit({ uuid });
      await this.multipartListPart({ uuid });
      const expectChunkSizeTransformStream = new ExpectChunkSizeTransformStream({ chunkSize });
      let partNumber = 0;
      let result = {};
      const queueConsumerWriteStream = new QueueConsumerWriteStream({
        beforePushTask: ({ chunk }) => {
          partNumber += 1;
          return {
            chunk,
            partNumber,
          };
        },
        consumer: async ({ partNumber, chunk }) => {
          const { Bucket, Region, Key } = this.cacheData[uuid].object;
          const { UploadId } = this.cacheData[uuid].process;
          const { hashCheck } = this.cacheData[uuid];
          if (this.checkPart({ uuid, partNumber })) {
            return;
          }
          let crc64Hash = '';
          if (hashCheck) {
            crc64Hash = getCRC64FromBuffer(chunk);
          }
          const { ETag, headers = {} } =            await this.cosSdkInstance.multipartUploadRetry({
            Bucket,
            Region,
            Key,
            UploadId,
            PartNumber: partNumber,
            ContentLength: chunk.length,
            Body: chunk,
          });
          if (hashCheck && crc64Hash !== headers['x-cos-hash-crc64ecma']) {
            this.updateParts({ uuid, partNumber, etag: '' });
            throw {
              crc64Hash,
              headers,
            };
          } else {
            this.updateParts({
              uuid,
              partNumber,
              etag: ETag,
            });
          }
        },
        beforeFinal: async () => {
          result = await this.multipartComplete({ uuid });
          return result;
        },
      });
      const passThrough = new PassThrough();
      passThrough._on = passThrough.on;
      passThrough.on = (event, ...args) => passThrough._on(event === 'finish' ? 'success' : event, ...args);
      passThrough
        .pipe(expectChunkSizeTransformStream)
        .on('error', err => passThrough.emit('error', err))
        .pipe(queueConsumerWriteStream)
        .on('error', err => passThrough.emit('error', err))
        .on('finish', () => passThrough.emit('success', result));
      return passThrough;
    } catch (err) {
      if (err.code === 'NoSuchUpload') {
        delete this.cacheData[uuid];
      }
      throw err;
    }
  }
}

module.exports = CosMultipartUploadUnknowSizeStreamController;
