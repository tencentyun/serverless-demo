{"version":3,"file":"annotation.cjs","names":["stateSchema: TStateSchema","middlewareList: TMiddleware","schemaShape: Record<string, any>","z","ioSchemaShape: Record<string, any>","schema: InteropZodObject","schemaMetaRegistry","MessagesZodState"],"sources":["../../src/agents/annotation.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { z } from \"zod/v3\";\nimport { MessagesZodState } from \"@langchain/langgraph\";\nimport { withLangGraph, schemaMetaRegistry } from \"@langchain/langgraph/zod\";\n\nimport type { AgentMiddleware, AnyAnnotationRoot } from \"./middleware/types.js\";\nimport {\n  InteropZodObject,\n  isZodSchemaV4,\n  getInteropZodObjectShape,\n} from \"@langchain/core/utils/types\";\nimport type { BaseMessage } from \"@langchain/core/messages\";\n\nexport function createAgentAnnotationConditional<\n  TStateSchema extends\n    | AnyAnnotationRoot\n    | InteropZodObject\n    | undefined = undefined,\n  TMiddleware extends readonly AgentMiddleware<any, any, any>[] = [],\n>(\n  hasStructuredResponse = true,\n  stateSchema: TStateSchema,\n  middlewareList: TMiddleware = [] as unknown as TMiddleware\n) {\n  /**\n   * Create Zod schema object to preserve jsonSchemaExtra\n   * metadata for LangGraph Studio using v3-compatible withLangGraph\n   */\n  const schemaShape: Record<string, any> = {\n    jumpTo: z\n      .union([\n        z.literal(\"model_request\"),\n        z.literal(\"tools\"),\n        z.literal(\"end\"),\n        z.undefined(),\n      ])\n      .optional(),\n  };\n  // Separate shape for input/output without reducer metadata (to avoid channel conflicts)\n  const ioSchemaShape: Record<string, any> = {};\n\n  const applySchema = (schema: InteropZodObject) => {\n    // Handle both Zod v3 and v4 schemas\n    const shape = isZodSchemaV4(schema)\n      ? getInteropZodObjectShape(schema)\n      : schema.shape;\n\n    for (const [key, fieldSchema] of Object.entries(shape)) {\n      /**\n       * Skip private state properties\n       */\n      if (key.startsWith(\"_\")) {\n        continue;\n      }\n\n      if (!(key in schemaShape)) {\n        /**\n         * If the field schema is Zod v4, convert to v3-compatible z.any()\n         * This allows the shape to be merged while preserving the key structure\n         * Also transfer any registry metadata (reducers, defaults) to the new schema\n         * using withLangGraph which properly registers the metadata\n         */\n        if (isZodSchemaV4(fieldSchema)) {\n          const meta = schemaMetaRegistry.get(fieldSchema);\n          if (meta) {\n            // For state: include reducer metadata\n            schemaShape[key] = withLangGraph(z.any(), meta);\n            // For input/output: plain z.any() without reducer (avoids channel conflicts)\n            ioSchemaShape[key] = z.any();\n          } else {\n            schemaShape[key] = z.any();\n            ioSchemaShape[key] = z.any();\n          }\n        } else {\n          schemaShape[key] = fieldSchema;\n          ioSchemaShape[key] = fieldSchema;\n        }\n      }\n    }\n  };\n\n  /**\n   * Add state schema properties to the Zod schema\n   */\n  if (stateSchema && (\"shape\" in stateSchema || isZodSchemaV4(stateSchema))) {\n    applySchema(stateSchema as InteropZodObject);\n  }\n\n  for (const middleware of middlewareList) {\n    if (middleware.stateSchema) {\n      applySchema(middleware.stateSchema as InteropZodObject);\n    }\n  }\n\n  // Only include structuredResponse when responseFormat is defined\n  if (hasStructuredResponse) {\n    schemaShape.structuredResponse = z.string().optional();\n    ioSchemaShape.structuredResponse = z.string().optional();\n  }\n\n  // Create messages field with LangGraph UI metadata for input/output schemas\n  // Only use jsonSchemaExtra (no reducer) to avoid channel conflict - this creates\n  // a LastValue channel which is allowed to coexist with the state's messages channel\n  const messages = withLangGraph(z.custom<BaseMessage[]>(), {\n    jsonSchemaExtra: { langgraph_type: \"messages\" },\n  });\n\n  return {\n    state: MessagesZodState.extend(schemaShape),\n    input: z.object({\n      messages,\n      ...Object.fromEntries(\n        Object.entries(ioSchemaShape).filter(\n          ([key]) => ![\"structuredResponse\", \"jumpTo\"].includes(key)\n        )\n      ),\n    }),\n    output: z.object({\n      messages,\n      ...Object.fromEntries(\n        Object.entries(ioSchemaShape).filter(([key]) => key !== \"jumpTo\")\n      ),\n    }),\n  };\n}\n"],"mappings":";;;;;;;AAaA,SAAgB,iCAOd,wBAAwB,MACxBA,aACAC,iBAA8B,CAAE,GAChC;;;;;CAKA,MAAMC,cAAmC,EACvC,QAAQC,SACL,MAAM;EACLA,SAAE,QAAQ,gBAAgB;EAC1BA,SAAE,QAAQ,QAAQ;EAClBA,SAAE,QAAQ,MAAM;EAChBA,SAAE,WAAW;CACd,EAAC,CACD,UAAU,CACd;CAED,MAAMC,gBAAqC,CAAE;CAE7C,MAAM,cAAc,CAACC,WAA6B;EAEhD,MAAM,wDAAsB,OAAO,8DACN,OAAO,GAChC,OAAO;AAEX,OAAK,MAAM,CAAC,KAAK,YAAY,IAAI,OAAO,QAAQ,MAAM,EAAE;;;;AAItD,OAAI,IAAI,WAAW,IAAI,CACrB;AAGF,OAAI,EAAE,OAAO;;;;;;;AAOX,uDAAkB,YAAY,EAAE;IAC9B,MAAM,OAAOC,6CAAmB,IAAI,YAAY;AAChD,QAAI,MAAM;KAER,YAAY,oDAAqBH,SAAE,KAAK,EAAE,KAAK;KAE/C,cAAc,OAAOA,SAAE,KAAK;IAC7B,OAAM;KACL,YAAY,OAAOA,SAAE,KAAK;KAC1B,cAAc,OAAOA,SAAE,KAAK;IAC7B;GACF,OAAM;IACL,YAAY,OAAO;IACnB,cAAc,OAAO;GACtB;EAEJ;CACF;;;;AAKD,KAAI,gBAAgB,WAAW,+DAA6B,YAAY,GACtE,YAAY,YAAgC;AAG9C,MAAK,MAAM,cAAc,eACvB,KAAI,WAAW,aACb,YAAY,WAAW,YAAgC;AAK3D,KAAI,uBAAuB;EACzB,YAAY,qBAAqBA,SAAE,QAAQ,CAAC,UAAU;EACtD,cAAc,qBAAqBA,SAAE,QAAQ,CAAC,UAAU;CACzD;CAKD,MAAM,wDAAyBA,SAAE,QAAuB,EAAE,EACxD,iBAAiB,EAAE,gBAAgB,WAAY,EAChD,EAAC;AAEF,QAAO;EACL,OAAOI,uCAAiB,OAAO,YAAY;EAC3C,OAAOJ,SAAE,OAAO;GACd;GACA,GAAG,OAAO,YACR,OAAO,QAAQ,cAAc,CAAC,OAC5B,CAAC,CAAC,IAAI,KAAK,CAAC,CAAC,sBAAsB,QAAS,EAAC,SAAS,IAAI,CAC3D,CACF;EACF,EAAC;EACF,QAAQA,SAAE,OAAO;GACf;GACA,GAAG,OAAO,YACR,OAAO,QAAQ,cAAc,CAAC,OAAO,CAAC,CAAC,IAAI,KAAK,QAAQ,SAAS,CAClE;EACF,EAAC;CACH;AACF"}