{"version":3,"file":"toolCallLimit.d.cts","names":["__types_js11","z","InferInteropZodInput","ToolCallLimitExceededError","Error","ToolCallLimitOptionsSchema","ZodString","ZodOptional","ZodNumber","ZodEnum","ZodDefault","ZodTypeAny","ZodObject","ToolCallLimitConfig","toolCallLimitMiddleware","ZodRecord","Record","_langchain_core_tools7","ServerTool","ClientTool","AgentMiddleware"],"sources":["../../../src/agents/middleware/toolCallLimit.d.ts"],"sourcesContent":["import { z } from \"zod/v3\";\nimport type { InferInteropZodInput } from \"@langchain/core/utils/types\";\n/**\n * Exception raised when tool call limits are exceeded.\n *\n * This exception is raised when the configured exit behavior is 'error'\n * and either the thread or run tool call limit has been exceeded.\n */\nexport declare class ToolCallLimitExceededError extends Error {\n    /**\n     * Current thread tool call count.\n     */\n    threadCount: number;\n    /**\n     * Current run tool call count.\n     */\n    runCount: number;\n    /**\n     * Thread tool call limit (if set).\n     */\n    threadLimit: number | undefined;\n    /**\n     * Run tool call limit (if set).\n     */\n    runLimit: number | undefined;\n    /**\n     * Tool name being limited (if specific tool), or undefined for all tools.\n     */\n    toolName: string | undefined;\n    constructor(threadCount: number, runCount: number, threadLimit: number | undefined, runLimit: number | undefined, toolName?: string | undefined);\n}\n/**\n * Options for configuring the Tool Call Limit middleware.\n */\nexport declare const ToolCallLimitOptionsSchema: z.ZodObject<{\n    /**\n     * Name of the specific tool to limit. If undefined, limits apply to all tools.\n     */\n    toolName: z.ZodOptional<z.ZodString>;\n    /**\n     * Maximum number of tool calls allowed per thread.\n     * undefined means no limit.\n     */\n    threadLimit: z.ZodOptional<z.ZodNumber>;\n    /**\n     * Maximum number of tool calls allowed per run.\n     * undefined means no limit.\n     */\n    runLimit: z.ZodOptional<z.ZodNumber>;\n    /**\n     * What to do when limits are exceeded.\n     * - \"continue\": Block exceeded tools with error messages, let other tools continue (default)\n     * - \"error\": Raise a ToolCallLimitExceededError exception\n     * - \"end\": Stop execution immediately, injecting a ToolMessage and an AI message\n     *   for the single tool call that exceeded the limit. Raises NotImplementedError\n     *   if there are multiple tool calls.\n     *\n     * @default \"continue\"\n     */\n    exitBehavior: z.ZodDefault<z.ZodEnum<[\"continue\", \"error\", \"end\"]>>;\n}, \"strip\", z.ZodTypeAny, {\n    toolName?: string | undefined;\n    threadLimit?: number | undefined;\n    runLimit?: number | undefined;\n    exitBehavior: \"continue\" | \"end\" | \"error\";\n}, {\n    toolName?: string | undefined;\n    threadLimit?: number | undefined;\n    runLimit?: number | undefined;\n    exitBehavior?: \"continue\" | \"end\" | \"error\" | undefined;\n}>;\nexport type ToolCallLimitConfig = InferInteropZodInput<typeof ToolCallLimitOptionsSchema>;\n/**\n * Middleware that tracks tool call counts and enforces limits.\n *\n * This middleware monitors the number of tool calls made during agent execution\n * and can terminate the agent when specified limits are reached. It supports\n * both thread-level and run-level call counting with configurable exit behaviors.\n *\n * Thread-level: The middleware counts all tool calls in the entire message history\n * and persists this count across multiple runs (invocations) of the agent.\n *\n * Run-level: The middleware counts tool calls made after the last HumanMessage,\n * representing the current run (invocation) of the agent.\n *\n * @param options - Configuration options for the middleware\n * @param options.toolName - Name of the specific tool to limit. If undefined, limits apply to all tools.\n * @param options.threadLimit - Maximum number of tool calls allowed per thread. undefined means no limit.\n * @param options.runLimit - Maximum number of tool calls allowed per run. undefined means no limit.\n * @param options.exitBehavior - What to do when limits are exceeded.\n *   - \"continue\": Block exceeded tools with error messages, let other tools continue. Model decides when to end. (default)\n *   - \"error\": Raise a ToolCallLimitExceededError exception\n *   - \"end\": Stop execution immediately with a ToolMessage + AI message for the single tool call that exceeded the limit. Raises NotImplementedError if there are multiple tool calls.\n *\n * @throws {Error} If both limits are undefined, if exitBehavior is invalid, or if runLimit exceeds threadLimit.\n * @throws {NotImplementedError} If exitBehavior is \"end\" and there are multiple tool calls.\n *\n * @example Continue execution with blocked tools (default)\n * ```ts\n * import { toolCallLimitMiddleware } from \"@langchain/langchain/agents/middleware\";\n * import { createAgent } from \"@langchain/langchain/agents\";\n *\n * // Block exceeded tools but let other tools and model continue\n * const limiter = toolCallLimitMiddleware({\n *   threadLimit: 20,\n *   runLimit: 10,\n *   exitBehavior: \"continue\", // default\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   middleware: [limiter]\n * });\n * ```\n *\n * @example Stop immediately when limit exceeded\n * ```ts\n * // End execution immediately with an AI message\n * const limiter = toolCallLimitMiddleware({\n *   runLimit: 5,\n *   exitBehavior: \"end\"\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   middleware: [limiter]\n * });\n * ```\n *\n * @example Raise exception on limit\n * ```ts\n * // Strict limit with exception handling\n * const limiter = toolCallLimitMiddleware({\n *   toolName: \"search\",\n *   threadLimit: 5,\n *   exitBehavior: \"error\"\n * });\n *\n * const agent = createAgent({\n *   model: \"openai:gpt-4o\",\n *   middleware: [limiter]\n * });\n *\n * try {\n *   const result = await agent.invoke({ messages: [new HumanMessage(\"Task\")] });\n * } catch (error) {\n *   if (error instanceof ToolCallLimitExceededError) {\n *     console.log(`Search limit exceeded: ${error}`);\n *   }\n * }\n * ```\n */\nexport declare function toolCallLimitMiddleware(options: ToolCallLimitConfig): import(\"./types.js\").AgentMiddleware<z.ZodObject<{\n    threadToolCallCount: z.ZodDefault<z.ZodRecord<z.ZodString, z.ZodNumber>>;\n    runToolCallCount: z.ZodDefault<z.ZodRecord<z.ZodString, z.ZodNumber>>;\n}, \"strip\", z.ZodTypeAny, {\n    threadToolCallCount: Record<string, number>;\n    runToolCallCount: Record<string, number>;\n}, {\n    threadToolCallCount?: Record<string, number> | undefined;\n    runToolCallCount?: Record<string, number> | undefined;\n}>, undefined, unknown, readonly (import(\"@langchain/core/tools\").ServerTool | import(\"@langchain/core/tools\").ClientTool)[]>;\n//# sourceMappingURL=toolCallLimit.d.ts.map"],"mappings":";;;;;;;;;;;AAQA;AA0BA;AAI8BM,cA9BTH,0BAAAA,SAAmCC,KAAK,CA8B/BE;EAAdC;;;EAUcC,WAAAA,EAAAA,MAAAA;EAAdD;;;EAYFI,QAAAA,EAAAA,MAAAA;EA1BqCC;AAAS;AAqC5D;EAiFwBE,WAAAA,EAAAA,MAAAA,GAAAA,SAAuB;EAAUD;;;EACjBE,QAAAA,EAAAA,MAAAA,GAAAA,SAAAA;EAAbL;;;EACUK,QAAAA,EAAAA,MAAAA,GAAAA,SAAAA;EAAbL,WAAAA,CAAAA,WAAAA,EAAAA,MAAAA,EAAAA,QAAAA,EAAAA,MAAAA,EAAAA,WAAAA,EAAAA,MAAAA,GAAAA,SAAAA,EAAAA,QAAAA,EAAAA,MAAAA,GAAAA,SAAAA,EAAAA,QAAAA,CAAAA,EAAAA,MAAAA,GAAAA,SAAAA;;;;;AAMDM,cA9HFX,0BA8HEW,EA9H0Bf,CAAAA,CAAEW,SA8H5BI,CAAAA;EAR+FJ;;;YAlHxGX,CAAAA,CAAEM,YAAYN,CAAAA,CAAEK;EAkHqF;;;;eA7GlGL,CAAAA,CAAEM,YAAYN,CAAAA,CAAEO;;;;;YAKnBP,CAAAA,CAAEM,YAAYN,CAAAA,CAAEO;;;;;;;;;;;gBAWZP,CAAAA,CAAES,WAAWT,CAAAA,CAAEQ;YACrBR,CAAAA,CAAEU;;;;;;;;;;;KAWFE,mBAAAA,GAAsBX,4BAA4BG;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;iBAiFtCS,uBAAAA,UAAiCD,sCAA2DZ,CAAAA,CAAEW;uBAC7FX,CAAAA,CAAES,WAAWT,CAAAA,CAAEc,UAAUd,CAAAA,CAAEK,WAAWL,CAAAA,CAAEO;oBAC3CP,CAAAA,CAAES,WAAWT,CAAAA,CAAEc,UAAUd,CAAAA,CAAEK,WAAWL,CAAAA,CAAEO;YAClDP,CAAAA,CAAEU;uBACWK;oBACHA;;wBAEIA;qBACHA;kCARwGC,sBAAAA,CAS7DC,UAAAA,GAAUD,sBAAAA,CAAmCE"}