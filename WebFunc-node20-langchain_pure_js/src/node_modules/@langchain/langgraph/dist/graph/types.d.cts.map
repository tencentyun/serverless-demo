{"version":3,"file":"types.d.cts","names":["InteropZodObject","StandardSchemaV1","LangGraphRunnableConfig","CommandInstance","Send","END","AnnotationRoot","StateDefinition","StateType","UpdateType","AnnotationUpdateType","AnyStateSchema","StateSchema","StateSchemaFieldsToStateDefinition","InteropZodToStateDefinition","ToStateDefinition","T","TInit","SD","StateDefinitionInit","isStateDefinitionInit","ContextSchemaInit","StateGraphInit","I","O","C","InterruptType","WriterType","N","StateGraphOptions","Omit","isStateGraphInit","ExtractStateType","Schema","S","Fallback","ExtractUpdateType","U","FallbackBase","Partial","ExtractBagInput","Bag","Default","ExtractBagOutput","ExtractBagContext","Record","Ctx","ExtractBagNodes","GraphNodeTypes","InputSchema","OutputSchema","ContextSchema","Nodes","IsGraphNodeTypeBag","GraphNodeReturnValue","Update","Promise","GraphNode","Context","ConditionalEdgeRouterTypes","IsConditionalEdgeRouterTypeBag","ConditionalEdgeRouterReturnValue","State","Array","ConditionalEdgeRouter"],"sources":["../../src/graph/types.d.ts"],"sourcesContent":["import { type InteropZodObject } from \"@langchain/core/utils/types\";\nimport type { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport type { LangGraphRunnableConfig } from \"../pregel/runnable_types.js\";\nimport type { CommandInstance, Send } from \"../constants.js\";\nimport { END } from \"../constants.js\";\nimport type { AnnotationRoot, StateDefinition, StateType, UpdateType as AnnotationUpdateType } from \"./annotation.js\";\nimport { AnyStateSchema, StateSchema, StateSchemaFieldsToStateDefinition } from \"../state/schema.js\";\nimport type { InteropZodToStateDefinition } from \"./zod/meta.js\";\nexport { END };\n/**\n * Convert any supported schema type to a StateDefinition.\n *\n * @internal\n */\nexport type ToStateDefinition<T> = T extends StateSchema<infer TInit> ? StateSchemaFieldsToStateDefinition<TInit> : T extends AnnotationRoot<infer SD> ? SD : T extends InteropZodObject ? InteropZodToStateDefinition<T> : T extends StateDefinition ? T : never;\n/**\n * Type for schema types that can be used to initialize state.\n * Supports all valid schema types: StateDefinition, Zod objects, StateSchema, and AnnotationRoot.\n *\n * @internal\n */\nexport type StateDefinitionInit = StateDefinition | InteropZodObject | AnyStateSchema | AnnotationRoot<any>;\n/**\n * Check if a value is a valid StateDefinitionInit type.\n * Supports: StateSchema, InteropZodObject (Zod), AnnotationRoot, StateDefinition\n *\n * @internal\n */\nexport declare function isStateDefinitionInit(value: unknown): value is StateDefinitionInit;\n/**\n * Valid types for context schema.\n * Context doesn't have channels/reducers, so StateSchema is NOT supported.\n * Supports StandardSchemaV1 (Zod, Valibot, etc.) and AnnotationRoot (backward compat).\n *\n * @internal\n */\nexport type ContextSchemaInit = StandardSchemaV1 | AnnotationRoot<StateDefinition>;\n/**\n * Initialization options for StateGraph.\n * Accepts any combination of schema types for state/input/output.\n *\n * Supports both `state` and `stateSchema` as aliases for backward compatibility.\n * If only `input` is provided (no state/stateSchema), `input` is used as the state schema.\n *\n * @template SD - State definition type\n * @template I - Input definition type (defaults to undefined)\n * @template O - Output definition type (defaults to undefined)\n * @template C - Context schema type (defaults to undefined)\n * @template N - Node name union type (defaults to string)\n * @template InterruptType - Interrupt type (defaults to unknown)\n * @template WriterType - Writer type (defaults to unknown)\n */\nexport type StateGraphInit<SD extends StateDefinitionInit = StateDefinitionInit, I extends StateDefinitionInit | undefined = undefined, O extends StateDefinitionInit | undefined = undefined, C extends StateDefinitionInit | undefined = undefined, N extends string = string, InterruptType = unknown, WriterType = unknown> = {\n    /** Primary key for state schema */\n    state?: SD;\n    /**\n     * @deprecated Use `state` instead. Will be removed in a future version.\n     */\n    stateSchema?: SD;\n    input?: I;\n    output?: O;\n    /** Context schema for runtime configuration validation. Does not support StateSchema. */\n    context?: C;\n    interrupt?: InterruptType;\n    writer?: WriterType;\n    nodes?: N[];\n};\n/**\n * Options for the second argument when passing a direct schema.\n * Excludes `state` and `stateSchema` since those come from the first arg.\n *\n * @internal\n */\nexport type StateGraphOptions<I extends StateDefinitionInit | undefined = undefined, O extends StateDefinitionInit | undefined = undefined, C extends StateDefinitionInit | undefined = undefined, N extends string = string, InterruptType = unknown, WriterType = unknown> = Omit<StateGraphInit<StateDefinitionInit, I, O, C, N, InterruptType, WriterType>, \"state\" | \"stateSchema\">;\n/**\n * Check if a value is a StateGraphInit object (has state, stateSchema, or input with valid schema).\n *\n * @internal\n */\nexport declare function isStateGraphInit(value: unknown): value is StateGraphInit<StateDefinitionInit>;\n/**\n * Extract the State type from any supported schema type.\n *\n * Supports:\n * - StateSchema\n * - AnnotationRoot\n * - StateDefinition (internal channel definitions)\n * - InteropZodObject (Zod v3/v4 object schemas)\n *\n * @template Schema - The schema type to extract state from\n * @template Fallback - Type to return if schema doesn't match (default: never)\n */\nexport type ExtractStateType<Schema, Fallback = Schema> = Schema extends AnnotationRoot<infer SD> ? StateType<SD> : StateType<ToStateDefinition<Schema>> extends infer S ? [S] extends [never] ? Fallback : S : Fallback;\n/**\n * Extract the Update type from any supported schema type.\n *\n * The Update type represents what a node can return to update the state.\n * All fields are optional since nodes only need to return the fields they modify.\n *\n * Supports:\n * - StateSchema\n * - AnnotationRoot\n * - StateDefinition (internal channel definitions)\n * - InteropZodObject (Zod v3/v4 object schemas)\n *\n * @template Schema - The schema type to extract update type from\n * @template FallbackBase - Base type for fallback (will be partialized), defaults to Schema\n */\nexport type ExtractUpdateType<Schema, FallbackBase = Schema> = Schema extends AnnotationRoot<infer SD> ? AnnotationUpdateType<SD> : AnnotationUpdateType<ToStateDefinition<Schema>> extends infer U ? [U] extends [never] ? Partial<FallbackBase> : U : Partial<FallbackBase>;\n/**\n * Extract the input type from a type bag, using ExtractStateType on the InputSchema.\n * Falls back to Default if InputSchema is not provided.\n * @internal\n */\ntype ExtractBagInput<Bag, Default> = Bag extends {\n    InputSchema: infer I;\n} ? ExtractStateType<I> : Default;\n/**\n * Extract the output type from a type bag, using ExtractUpdateType on the OutputSchema.\n * Falls back to Default if OutputSchema is not provided.\n * @internal\n */\ntype ExtractBagOutput<Bag, Default> = Bag extends {\n    OutputSchema: infer O;\n} ? ExtractUpdateType<O> : Default;\n/**\n * Extract the context type from a type bag, using ExtractStateType on the ContextSchema.\n * Falls back to Default if ContextSchema is not provided.\n * Ensures result extends Record<string, unknown> for LangGraphRunnableConfig compatibility.\n * @internal\n */\ntype ExtractBagContext<Bag, Default extends Record<string, unknown>> = Bag extends {\n    ContextSchema: infer C;\n} ? ExtractStateType<C> extends infer Ctx ? Ctx extends Record<string, unknown> ? Ctx : Default : Default : Default;\n/**\n * Extract the Nodes type from a type bag.\n * Falls back to Default if Nodes is not provided.\n * @internal\n */\ntype ExtractBagNodes<Bag, Default extends string> = Bag extends {\n    Nodes: infer N extends string;\n} ? N : Default;\n/**\n * Type bag for GraphNode that accepts schema types.\n * All fields are optional - unspecified fields use defaults.\n *\n * This enables separate input/output schemas for nodes, which is useful when\n * a node receives a subset of state fields and returns different fields.\n *\n * @example\n * ```typescript\n * const node: GraphNode<{\n *   InputSchema: typeof NodeInputSchema;\n *   OutputSchema: typeof NodeOutputSchema;\n *   ContextSchema: typeof ContextSchema;\n *   Nodes: \"agent\" | \"tool\";\n * }> = (state, runtime) => {\n *   return { answer: `Response to: ${state.query}` };\n * };\n * ```\n */\nexport interface GraphNodeTypes<InputSchema = unknown, OutputSchema = unknown, ContextSchema = unknown, Nodes extends string = string> {\n    /** Schema for node input state (uses ExtractStateType) */\n    InputSchema?: InputSchema;\n    /** Schema for node output/update (uses ExtractUpdateType) */\n    OutputSchema?: OutputSchema;\n    /** Schema for runtime context (uses ExtractStateType) */\n    ContextSchema?: ContextSchema;\n    /** Union of valid node names for Command.goto */\n    Nodes?: Nodes;\n}\n/**\n * Detect if T is a type bag (has InputSchema or OutputSchema) or a direct schema.\n * @internal\n */\ntype IsGraphNodeTypeBag<T> = T extends {\n    InputSchema: unknown;\n} ? true : T extends {\n    OutputSchema: unknown;\n} ? true : false;\n/**\n * Return value type for GraphNode functions.\n * Nodes can return an update object, a Command, or a Promise of either.\n *\n * @template Update - The update type (what fields can be returned)\n * @template Nodes - Union of valid node names for Command.goto\n */\nexport type GraphNodeReturnValue<Update, Nodes extends string = string> = Update | CommandInstance<unknown, Update, Nodes> | Promise<Update | CommandInstance<unknown, Update, Nodes>>;\n/**\n * Strongly-typed utility for authoring graph nodes outside of the StateGraph builder,\n * supporting inference for both state (from Schema) and config context (from Context type).\n *\n * This type enables you to define graph node functions with full type safetyâ€”both\n * for the evolving state and for additional context that may be passed in at runtime.\n * Typing the context parameter allows for better code organization and precise editor support.\n *\n * Works with StateSchema, AnnotationRoot, and Zod object schemas for state, and\n * with a user-defined object shape for context.\n *\n * **Supports two patterns:**\n *\n * 1. **Single schema usage** - Single schema for both input and output:\n *    `GraphNode<Schema, Context, Nodes>`\n *\n * 2. **Type bag pattern** - Separate schemas for input, output, context:\n *    `GraphNode<{ InputSchema; OutputSchema; ContextSchema; Nodes }>`\n *\n * @template Schema - The state schema type (StateSchema, AnnotationRoot, InteropZodObject) OR a type bag\n * @template Context - The type of the context passed into this node (default: Record<string, unknown>)\n * @template Nodes - An optional union of valid node names for Command.goto, used for type-safe routing (default: string)\n *\n * @example Single schema usage\n * ```typescript\n * import { StateSchema, GraphNode } from \"@langchain/langgraph\";\n * import { z } from \"zod/v4\";\n *\n * const AgentState = new StateSchema({\n *   messages: MessagesValue,\n *   step: z.number().default(0),\n * });\n *\n * // Context shape for custom node logic (optional)\n * type MyContext = { userId: string };\n *\n * // Node receiving state and config\n * const processNode: GraphNode<typeof AgentState, MyContext> = (state, config) => {\n *   const userId = config.configurable?.userId; // type-safe context access\n *   return { step: state.step + 1 };\n * };\n *\n * // Node with type-safe graph routing\n * const routerNode: GraphNode<typeof AgentState, MyContext, \"agent\" | \"tool\"> = (state, config) => {\n *   if (state.needsTool) {\n *     return new Command({ goto: \"tool\", update: { step: state.step + 1 } });\n *   }\n *   return new Command({ goto: \"agent\" });\n * };\n *\n * // Use in graph\n * const graph = new StateGraph(AgentState)\n *   .addNode(\"process\", processNode)\n *   .addNode(\"router\", routerNode)\n *   .compile();\n * ```\n *\n * @example Type bag pattern - separate input/output schemas\n * ```typescript\n * const InputSchema = new StateSchema({\n *   messages: z.array(z.string()),\n *   query: z.string(),\n * });\n *\n * const OutputSchema = new StateSchema({\n *   answer: z.string(),\n * });\n *\n * const ContextSchema = z.object({ userId: z.string() });\n *\n * const node: GraphNode<{\n *   InputSchema: typeof InputSchema;\n *   OutputSchema: typeof OutputSchema;\n *   ContextSchema: typeof ContextSchema;\n *   Nodes: \"agent\" | \"tool\";\n * }> = (state, config) => {\n *   // state is { messages: string[]; query: string }\n *   // config.configurable is { userId: string } | undefined\n *   return { answer: `Response to: ${state.query}` };\n * };\n * ```\n */\nexport type GraphNode<Schema, Context extends Record<string, any> = Record<string, any>, Nodes extends string = string> = IsGraphNodeTypeBag<Schema> extends true ? (state: ExtractBagInput<Schema, unknown>, config: LangGraphRunnableConfig<ExtractBagContext<Schema, Record<string, unknown>>>) => GraphNodeReturnValue<ExtractBagOutput<Schema, Partial<ExtractBagInput<Schema, unknown>>>, ExtractBagNodes<Schema, string>> : (state: ExtractStateType<Schema>, config: LangGraphRunnableConfig<Context>) => GraphNodeReturnValue<ExtractUpdateType<Schema>, Nodes>;\n/**\n * Type bag for ConditionalEdgeRouter that accepts schema types.\n * Unlike GraphNodeTypes, conditional edges don't have separate input/output -\n * they just read state and return routing decisions.\n *\n * @example\n * ```typescript\n * const router: ConditionalEdgeRouter<{\n *   Schema: typeof StateSchema;\n *   ContextSchema: typeof ContextSchema;\n *   Nodes: \"agent\" | \"tool\";\n * }> = (state, config) => {\n *   return state.done ? END : \"agent\";\n * };\n * ```\n */\nexport interface ConditionalEdgeRouterTypes<InputSchema = unknown, ContextSchema = unknown, Nodes extends string = string> {\n    /** Schema for router state (uses ExtractStateType) */\n    InputSchema?: InputSchema;\n    /** Schema for runtime context (uses ExtractStateType) */\n    ContextSchema?: ContextSchema;\n    /** Union of valid node names that can be routed to */\n    Nodes?: Nodes;\n}\n/**\n * Detect if T is a ConditionalEdgeRouterTypes bag.\n * @internal\n */\ntype IsConditionalEdgeRouterTypeBag<T> = T extends {\n    InputSchema: unknown;\n} ? true : T extends {\n    ContextSchema: unknown;\n} ? true : false;\n/**\n * Return type for conditional edge routing functions.\n */\ntype ConditionalEdgeRouterReturnValue<Nodes extends string, State> = Nodes | typeof END | Send<Nodes, State> | Array<Nodes | Send<Nodes, State>>;\n/**\n * Type for conditional edge routing functions.\n *\n * Use this to type functions passed to `addConditionalEdges` for\n * full type safety on state, runtime context, and return values.\n *\n * **Supports two patterns:**\n *\n * 1. **Single schema pattern** - Single schema:\n *    `ConditionalEdgeRouter<Schema, Context, Nodes>`\n *\n * 2. **Type bag pattern** - Separate schemas for state, context:\n *    `ConditionalEdgeRouter<{ Schema; ContextSchema; Nodes }>`\n *\n * @template Schema - The state schema type OR a type bag\n * @template Context - The runtime context type available to node logic\n * @template Nodes - Union of valid node names that can be routed to\n *\n * @example Single schema pattern\n * ```typescript\n * type MyContext = { userId: string };\n * const router: ConditionalEdgeRouter<typeof AgentState, MyContext, \"agent\" | \"tool\"> =\n *   (state, config) => {\n *     const userId = config.context?.userId;\n *     if (state.done) return END;\n *     return state.needsTool ? \"tool\" : \"agent\";\n *   };\n *\n * graph.addConditionalEdges(\"router\", router, [\"agent\", \"tool\"]);\n * ```\n *\n * @example Type bag pattern\n * ```typescript\n * const router: ConditionalEdgeRouter<{\n *   Schema: typeof StateSchema;\n *   ContextSchema: typeof ContextSchema;\n *   Nodes: \"agent\" | \"tool\";\n * }> = (state, config) => {\n *   if (state.done) return END;\n *   return \"agent\";\n * };\n * ```\n */\nexport type ConditionalEdgeRouter<Schema, Context extends Record<string, any> = Record<string, any>, Nodes extends string = string> = IsConditionalEdgeRouterTypeBag<Schema> extends true ? (state: ExtractBagInput<Schema, unknown>, config: LangGraphRunnableConfig<ExtractBagContext<Schema, Record<string, unknown>>>) => ConditionalEdgeRouterReturnValue<ExtractBagNodes<Schema, string>, ExtractBagInput<Schema, unknown>> | Promise<ConditionalEdgeRouterReturnValue<ExtractBagNodes<Schema, string>, ExtractBagInput<Schema, unknown>>> : (state: ExtractStateType<Schema>, config: LangGraphRunnableConfig<Context>) => ConditionalEdgeRouterReturnValue<Nodes, ExtractStateType<Schema>> | Promise<ConditionalEdgeRouterReturnValue<Nodes, ExtractStateType<Schema>>>;\n"],"mappings":"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"}