{"version":3,"file":"ReactAgent.js","names":["options: CreateAgentParams<\n      Types[\"Response\"],\n      Types[\"State\"],\n      Types[\"Context\"]\n    >","#toolBehaviorVersion","beforeAgentNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[]","beforeModelNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[]","afterModelNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[]","afterAgentNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[]","wrapModelCallHookMiddleware: [\n      AgentMiddleware,\n      /**\n       * ToDo: better type to get the state of middleware\n       */\n      () => any,\n    ][]","#agentNode","beforeAgentNode: BeforeAgentNode | undefined","beforeModelNode: BeforeModelNode | undefined","afterModelNode: AfterModelNode | undefined","afterAgentNode: AfterAgentNode | undefined","#stateManager","entryNode: string","#createBeforeAgentRouter","#createBeforeModelRouter","#getModelPaths","#createModelRouter","#createAfterModelSequenceRouter","#createAfterModelRouter","#createToolsRouter","#graph","toolClasses: (ClientTool | ServerTool)[]","includeModelRequest: boolean","paths: BaseGraphDestination[]","shouldReturnDirect: Set<string>","exitNode: string | typeof END","state: Record<string, unknown>","allowJump: boolean","allowed: string[]","nextDefault: string","#initializeMiddlewareStates","state: InvokeStateParameter<Types>","config: RunnableConfig","config?: InvokeConfiguration<\n      InferContextInput<\n        Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n          ? Types[\"Context\"]\n          : AnyAnnotationRoot\n      > &\n        InferMiddlewareContextInputs<Types[\"Middleware\"]>\n    >","config?: StreamConfiguration<\n      InferContextInput<\n        Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n          ? Types[\"Context\"]\n          : AnyAnnotationRoot\n      > &\n        InferMiddlewareContextInputs<Types[\"Middleware\"]>,\n      TStreamMode,\n      TEncoding\n    >","params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n    backgroundColor?: string;\n  }","config?: StreamConfiguration<\n      InferContextInput<\n        Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n          ? Types[\"Context\"]\n          : AnyAnnotationRoot\n      > &\n        InferMiddlewareContextInputs<Types[\"Middleware\"]>,\n      StreamMode | StreamMode[] | undefined,\n      \"text/event-stream\" | undefined\n    > & { version?: \"v1\" | \"v2\" }","streamOptions?: Parameters<Runnable[\"streamEvents\"]>[2]","config?: RunnableConfig","options?: GetStateOptions","options?: CheckpointListOptions","namespace?: string","recurse?: boolean","inputConfig: LangGraphRunnableConfig","values: Record<string, unknown> | unknown","asNode?: string"],"sources":["../../src/agents/ReactAgent.ts"],"sourcesContent":["/* eslint-disable no-instanceof/no-instanceof */\n/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { InteropZodObject } from \"@langchain/core/utils/types\";\n\nimport {\n  StateGraph,\n  END,\n  START,\n  Send,\n  Command,\n  CompiledStateGraph,\n  type GetStateOptions,\n  type LangGraphRunnableConfig,\n  type StreamMode,\n  type StreamOutputMap,\n  type PregelOptions,\n} from \"@langchain/langgraph\";\nimport type { CheckpointListOptions } from \"@langchain/langgraph-checkpoint\";\nimport {\n  ToolMessage,\n  AIMessage,\n  MessageStructure,\n} from \"@langchain/core/messages\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport type { Runnable, RunnableConfig } from \"@langchain/core/runnables\";\nimport type { StreamEvent } from \"@langchain/core/tracers/log_stream\";\nimport type { ClientTool, ServerTool } from \"@langchain/core/tools\";\nimport { createAgentAnnotationConditional } from \"./annotation.js\";\nimport {\n  isClientTool,\n  validateLLMHasNoBoundTools,\n  wrapToolCall,\n  normalizeSystemPrompt,\n} from \"./utils.js\";\n\nimport { AgentNode, AGENT_NODE_NAME } from \"./nodes/AgentNode.js\";\nimport { ToolNode, TOOLS_NODE_NAME } from \"./nodes/ToolNode.js\";\nimport { BeforeAgentNode } from \"./nodes/BeforeAgentNode.js\";\nimport { BeforeModelNode } from \"./nodes/BeforeModelNode.js\";\nimport { AfterModelNode } from \"./nodes/AfterModelNode.js\";\nimport { AfterAgentNode } from \"./nodes/AfterAgentNode.js\";\nimport {\n  initializeMiddlewareStates,\n  parseJumpToTarget,\n} from \"./nodes/utils.js\";\nimport { StateManager } from \"./state.js\";\n\nimport type {\n  WithStateGraphNodes,\n  AgentTypeConfig,\n  CreateAgentParams,\n  ToolsToMessageToolSet,\n} from \"./types.js\";\n\nimport type { BuiltInState, JumpTo, UserInput } from \"./types.js\";\nimport type { InvokeConfiguration, StreamConfiguration } from \"./runtime.js\";\nimport type {\n  AgentMiddleware,\n  InferMiddlewareContextInputs,\n  InferMiddlewareStates,\n  InferMiddlewareInputStates,\n  InferContextInput,\n  AnyAnnotationRoot,\n  InferSchemaInput,\n  ToAnnotationRoot,\n} from \"./middleware/types.js\";\nimport { type ResponseFormatUndefined } from \"./responses.js\";\nimport { getHookConstraint } from \"./middleware/utils.js\";\n\n/**\n * In the ReAct pattern we have three main nodes:\n * - model_request: The node that makes the model call.\n * - tools: The node that calls the tools.\n * - END: The end of the graph.\n *\n * These are the only nodes that can be jumped to from other nodes.\n */\ntype BaseGraphDestination =\n  | typeof TOOLS_NODE_NAME\n  | typeof AGENT_NODE_NAME\n  | typeof END;\n\n// Helper type to get the state definition with middleware states\ntype MergedAgentState<Types extends AgentTypeConfig> = InferSchemaInput<\n  Types[\"State\"]\n> &\n  (Types[\"Response\"] extends ResponseFormatUndefined\n    ? Omit<\n        BuiltInState<MessageStructure<ToolsToMessageToolSet<Types[\"Tools\"]>>>,\n        \"jumpTo\"\n      >\n    : Omit<\n        BuiltInState<MessageStructure<ToolsToMessageToolSet<Types[\"Tools\"]>>>,\n        \"jumpTo\"\n      > & {\n        structuredResponse: Types[\"Response\"];\n      }) &\n  InferMiddlewareStates<Types[\"Middleware\"]>;\n\ntype InvokeStateParameter<Types extends AgentTypeConfig> =\n  | (UserInput<Types[\"State\"]> &\n      InferMiddlewareInputStates<Types[\"Middleware\"]>)\n  | Command<any, any, any>\n  | null;\n\ntype AgentGraph<Types extends AgentTypeConfig> = CompiledStateGraph<\n  any,\n  any,\n  any,\n  any,\n  MergedAgentState<Types>,\n  ToAnnotationRoot<\n    Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n      ? Types[\"Context\"]\n      : AnyAnnotationRoot\n  >[\"spec\"],\n  unknown\n>;\n\n/**\n * ReactAgent is a production-ready ReAct (Reasoning + Acting) agent that combines\n * language models with tools and middleware.\n *\n * The agent is parameterized by a single type bag `Types` that encapsulates all\n * type information:\n *\n * @typeParam Types - An {@link AgentTypeConfig} that bundles:\n *   - `Response`: The structured response type\n *   - `State`: The custom state schema type\n *   - `Context`: The context schema type\n *   - `Middleware`: The middleware array type\n *   - `Tools`: The combined tools type from agent and middleware\n *\n * @example\n * ```typescript\n * // Using the type bag pattern\n * type MyTypes = AgentTypeConfig<\n *   { name: string },  // Response\n *   typeof myState,    // State\n *   typeof myContext,  // Context\n *   typeof middleware, // Middleware\n *   typeof tools       // Tools\n * >;\n *\n * const agent: ReactAgent<MyTypes> = createAgent({ ... });\n * ```\n */\nexport class ReactAgent<\n  Types extends AgentTypeConfig = AgentTypeConfig<\n    Record<string, any>,\n    undefined,\n    AnyAnnotationRoot,\n    readonly AgentMiddleware[],\n    readonly (ClientTool | ServerTool)[]\n  >,\n> {\n  /**\n   * Type marker for extracting the AgentTypeConfig from a ReactAgent instance.\n   * This is a phantom property used only for type inference.\n   * @internal\n   */\n  declare readonly \"~agentTypes\": Types;\n\n  #graph: AgentGraph<Types>;\n\n  #toolBehaviorVersion: \"v1\" | \"v2\" = \"v2\";\n\n  #agentNode: AgentNode<any, AnyAnnotationRoot>;\n\n  #stateManager = new StateManager();\n\n  constructor(\n    public options: CreateAgentParams<\n      Types[\"Response\"],\n      Types[\"State\"],\n      Types[\"Context\"]\n    >\n  ) {\n    this.#toolBehaviorVersion = options.version ?? this.#toolBehaviorVersion;\n\n    /**\n     * validate that model option is provided\n     */\n    if (!options.model) {\n      throw new Error(\"`model` option is required to create an agent.\");\n    }\n\n    /**\n     * Check if the LLM already has bound tools and throw if it does.\n     */\n    if (typeof options.model !== \"string\") {\n      validateLLMHasNoBoundTools(options.model);\n    }\n\n    /**\n     * define complete list of tools based on options and middleware\n     */\n    const middlewareTools = (this.options.middleware\n      ?.filter((m) => m.tools)\n      .flatMap((m) => m.tools) ?? []) as (ClientTool | ServerTool)[];\n    const toolClasses = [...(options.tools ?? []), ...middlewareTools];\n\n    /**\n     * If any of the tools are configured to return_directly after running,\n     * our graph needs to check if these were called\n     */\n    const shouldReturnDirect = new Set(\n      toolClasses\n        .filter(isClientTool)\n        .filter((tool) => \"returnDirect\" in tool && tool.returnDirect)\n        .map((tool) => tool.name)\n    );\n\n    /**\n     * Create a schema that merges agent base schema with middleware state schemas\n     * Using Zod with withLangGraph ensures LangGraph Studio gets proper metadata\n     */\n    const { state, input, output } = createAgentAnnotationConditional<\n      Types[\"State\"],\n      Types[\"Middleware\"]\n    >(\n      this.options.responseFormat !== undefined,\n      this.options.stateSchema as Types[\"State\"],\n      this.options.middleware as Types[\"Middleware\"]\n    );\n\n    const workflow = new StateGraph(\n      {\n        state,\n        input,\n        output,\n      },\n      this.options.contextSchema\n    );\n\n    const allNodeWorkflows = workflow as WithStateGraphNodes<\n      typeof TOOLS_NODE_NAME | typeof AGENT_NODE_NAME | string,\n      typeof workflow\n    >;\n\n    // Generate node names for middleware nodes that have hooks\n    const beforeAgentNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[] = [];\n    const beforeModelNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[] = [];\n    const afterModelNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[] = [];\n    const afterAgentNodes: {\n      index: number;\n      name: string;\n      allowed?: string[];\n    }[] = [];\n    const wrapModelCallHookMiddleware: [\n      AgentMiddleware,\n      /**\n       * ToDo: better type to get the state of middleware\n       */\n      () => any,\n    ][] = [];\n\n    this.#agentNode = new AgentNode({\n      model: this.options.model,\n      systemMessage: normalizeSystemPrompt(this.options.systemPrompt),\n      includeAgentName: this.options.includeAgentName,\n      name: this.options.name,\n      responseFormat: this.options.responseFormat,\n      middleware: this.options.middleware,\n      toolClasses,\n      shouldReturnDirect,\n      signal: this.options.signal,\n      wrapModelCallHookMiddleware,\n    });\n\n    const middlewareNames = new Set<string>();\n    const middleware = this.options.middleware ?? [];\n    for (let i = 0; i < middleware.length; i++) {\n      let beforeAgentNode: BeforeAgentNode | undefined;\n      let beforeModelNode: BeforeModelNode | undefined;\n      let afterModelNode: AfterModelNode | undefined;\n      let afterAgentNode: AfterAgentNode | undefined;\n      const m = middleware[i];\n      if (middlewareNames.has(m.name)) {\n        throw new Error(`Middleware ${m.name} is defined multiple times`);\n      }\n\n      middlewareNames.add(m.name);\n      if (m.beforeAgent) {\n        beforeAgentNode = new BeforeAgentNode(m, {\n          getState: () => this.#stateManager.getState(m.name),\n        });\n        this.#stateManager.addNode(m, beforeAgentNode);\n        const name = `${m.name}.before_agent`;\n        beforeAgentNodes.push({\n          index: i,\n          name,\n          allowed: getHookConstraint(m.beforeAgent),\n        });\n        allNodeWorkflows.addNode(\n          name,\n          beforeAgentNode,\n          beforeAgentNode.nodeOptions\n        );\n      }\n      if (m.beforeModel) {\n        beforeModelNode = new BeforeModelNode(m, {\n          getState: () => this.#stateManager.getState(m.name),\n        });\n        this.#stateManager.addNode(m, beforeModelNode);\n        const name = `${m.name}.before_model`;\n        beforeModelNodes.push({\n          index: i,\n          name,\n          allowed: getHookConstraint(m.beforeModel),\n        });\n        allNodeWorkflows.addNode(\n          name,\n          beforeModelNode,\n          beforeModelNode.nodeOptions\n        );\n      }\n      if (m.afterModel) {\n        afterModelNode = new AfterModelNode(m, {\n          getState: () => this.#stateManager.getState(m.name),\n        });\n        this.#stateManager.addNode(m, afterModelNode);\n        const name = `${m.name}.after_model`;\n        afterModelNodes.push({\n          index: i,\n          name,\n          allowed: getHookConstraint(m.afterModel),\n        });\n        allNodeWorkflows.addNode(\n          name,\n          afterModelNode,\n          afterModelNode.nodeOptions\n        );\n      }\n      if (m.afterAgent) {\n        afterAgentNode = new AfterAgentNode(m, {\n          getState: () => this.#stateManager.getState(m.name),\n        });\n        this.#stateManager.addNode(m, afterAgentNode);\n        const name = `${m.name}.after_agent`;\n        afterAgentNodes.push({\n          index: i,\n          name,\n          allowed: getHookConstraint(m.afterAgent),\n        });\n        allNodeWorkflows.addNode(\n          name,\n          afterAgentNode,\n          afterAgentNode.nodeOptions\n        );\n      }\n\n      if (m.wrapModelCall) {\n        wrapModelCallHookMiddleware.push([\n          m,\n          () => this.#stateManager.getState(m.name),\n        ]);\n      }\n    }\n\n    /**\n     * Add Nodes\n     */\n    allNodeWorkflows.addNode(AGENT_NODE_NAME, this.#agentNode);\n\n    /**\n     * add single tool node for all tools\n     */\n    if (toolClasses.filter(isClientTool).length > 0) {\n      const toolNode = new ToolNode(toolClasses.filter(isClientTool), {\n        signal: this.options.signal,\n        wrapToolCall: wrapToolCall(middleware),\n      });\n      allNodeWorkflows.addNode(TOOLS_NODE_NAME, toolNode);\n    }\n\n    /**\n     * Add Edges\n     */\n    // Determine the entry node (runs once at start): before_agent -> before_model -> model_request\n    let entryNode: string;\n    if (beforeAgentNodes.length > 0) {\n      entryNode = beforeAgentNodes[0].name;\n    } else if (beforeModelNodes.length > 0) {\n      entryNode = beforeModelNodes[0].name;\n    } else {\n      entryNode = AGENT_NODE_NAME;\n    }\n\n    // Determine the loop entry node (beginning of agent loop, excludes before_agent)\n    // This is where tools will loop back to for the next iteration\n    const loopEntryNode =\n      beforeModelNodes.length > 0 ? beforeModelNodes[0].name : AGENT_NODE_NAME;\n\n    // Determine the exit node (runs once at end): after_agent or END\n    const exitNode =\n      afterAgentNodes.length > 0\n        ? afterAgentNodes[afterAgentNodes.length - 1].name\n        : END;\n\n    allNodeWorkflows.addEdge(START, entryNode);\n    const clientTools = toolClasses.filter(isClientTool);\n\n    // Connect beforeAgent nodes (run once at start)\n    for (let i = 0; i < beforeAgentNodes.length; i++) {\n      const node = beforeAgentNodes[i];\n      const current = node.name;\n      const isLast = i === beforeAgentNodes.length - 1;\n      const nextDefault = isLast ? loopEntryNode : beforeAgentNodes[i + 1].name;\n\n      if (node.allowed && node.allowed.length > 0) {\n        const hasTools = clientTools.length > 0;\n        const allowedMapped = node.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== TOOLS_NODE_NAME || hasTools);\n        // Replace END with exitNode (which could be an afterAgent node)\n        const destinations = Array.from(\n          new Set([\n            nextDefault,\n            ...allowedMapped.map((dest) => (dest === END ? exitNode : dest)),\n          ])\n        ) as BaseGraphDestination[];\n\n        allNodeWorkflows.addConditionalEdges(\n          current,\n          this.#createBeforeAgentRouter(clientTools, nextDefault, exitNode),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(current, nextDefault);\n      }\n    }\n\n    // Connect beforeModel nodes; add conditional routing ONLY if allowed jumps are specified\n    for (let i = 0; i < beforeModelNodes.length; i++) {\n      const node = beforeModelNodes[i];\n      const current = node.name;\n      const isLast = i === beforeModelNodes.length - 1;\n      const nextDefault = isLast\n        ? AGENT_NODE_NAME\n        : beforeModelNodes[i + 1].name;\n\n      if (node.allowed && node.allowed.length > 0) {\n        const hasTools = clientTools.length > 0;\n        const allowedMapped = node.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== TOOLS_NODE_NAME || hasTools);\n        const destinations = Array.from(\n          new Set([nextDefault, ...allowedMapped])\n        ) as BaseGraphDestination[];\n\n        allNodeWorkflows.addConditionalEdges(\n          current,\n          this.#createBeforeModelRouter(clientTools, nextDefault),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(current, nextDefault);\n      }\n    }\n\n    // Connect agent to last afterModel node (for reverse order execution)\n    const lastAfterModelNode = afterModelNodes.at(-1);\n    if (afterModelNodes.length > 0 && lastAfterModelNode) {\n      allNodeWorkflows.addEdge(AGENT_NODE_NAME, lastAfterModelNode.name);\n    } else {\n      // If no afterModel nodes, connect model_request directly to model paths\n      const modelPaths = this.#getModelPaths(clientTools);\n      // Replace END with exitNode in destinations, since exitNode might be an afterAgent node\n      const destinations = modelPaths.map((p) =>\n        p === END ? exitNode : p\n      ) as BaseGraphDestination[];\n      if (destinations.length === 1) {\n        allNodeWorkflows.addEdge(AGENT_NODE_NAME, destinations[0]);\n      } else {\n        allNodeWorkflows.addConditionalEdges(\n          AGENT_NODE_NAME,\n          this.#createModelRouter(exitNode),\n          destinations\n        );\n      }\n    }\n\n    // Connect afterModel nodes in reverse sequence; add conditional routing ONLY if allowed jumps are specified per node\n    for (let i = afterModelNodes.length - 1; i > 0; i--) {\n      const node = afterModelNodes[i];\n      const current = node.name;\n      const nextDefault = afterModelNodes[i - 1].name;\n\n      if (node.allowed && node.allowed.length > 0) {\n        const hasTools = clientTools.length > 0;\n        const allowedMapped = node.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== TOOLS_NODE_NAME || hasTools);\n        const destinations = Array.from(\n          new Set([nextDefault, ...allowedMapped])\n        ) as BaseGraphDestination[];\n\n        allNodeWorkflows.addConditionalEdges(\n          current,\n          this.#createAfterModelSequenceRouter(\n            clientTools,\n            node.allowed,\n            nextDefault\n          ),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(current, nextDefault);\n      }\n    }\n\n    // Connect first afterModel node (last to execute) to model paths with jumpTo support\n    if (afterModelNodes.length > 0) {\n      const firstAfterModel = afterModelNodes[0];\n      const firstAfterModelNode = firstAfterModel.name;\n\n      // Include exitNode in the paths since afterModel should be able to route to after_agent or END\n      const modelPaths = this.#getModelPaths(clientTools, true).filter(\n        (p) =>\n          p !== TOOLS_NODE_NAME || toolClasses.filter(isClientTool).length > 0\n      );\n\n      const allowJump = Boolean(\n        firstAfterModel.allowed && firstAfterModel.allowed.length > 0\n      );\n\n      // Replace END with exitNode in destinations, since exitNode might be an afterAgent node\n      const destinations = modelPaths.map((p) =>\n        p === END ? exitNode : p\n      ) as BaseGraphDestination[];\n\n      allNodeWorkflows.addConditionalEdges(\n        firstAfterModelNode,\n        this.#createAfterModelRouter(clientTools, allowJump, exitNode),\n        destinations\n      );\n    }\n\n    // Connect afterAgent nodes (run once at end, in reverse order like afterModel)\n    for (let i = afterAgentNodes.length - 1; i > 0; i--) {\n      const node = afterAgentNodes[i];\n      const current = node.name;\n      const nextDefault = afterAgentNodes[i - 1].name;\n\n      if (node.allowed && node.allowed.length > 0) {\n        const hasTools = clientTools.length > 0;\n        const allowedMapped = node.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== TOOLS_NODE_NAME || hasTools);\n        const destinations = Array.from(\n          new Set([nextDefault, ...allowedMapped])\n        ) as BaseGraphDestination[];\n\n        allNodeWorkflows.addConditionalEdges(\n          current,\n          this.#createAfterModelSequenceRouter(\n            clientTools,\n            node.allowed,\n            nextDefault\n          ),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(current, nextDefault);\n      }\n    }\n\n    // Connect the first afterAgent node (last to execute) to END\n    if (afterAgentNodes.length > 0) {\n      const firstAfterAgent = afterAgentNodes[0];\n      const firstAfterAgentNode = firstAfterAgent.name;\n\n      if (firstAfterAgent.allowed && firstAfterAgent.allowed.length > 0) {\n        const hasTools = clientTools.length > 0;\n        const allowedMapped = firstAfterAgent.allowed\n          .map((t) => parseJumpToTarget(t))\n          .filter((dest) => dest !== TOOLS_NODE_NAME || hasTools);\n\n        /**\n         * For after_agent, only use explicitly allowed destinations (don't add loopEntryNode)\n         * The default destination (when no jump occurs) should be END\n         */\n        const destinations = Array.from(\n          new Set([END, ...allowedMapped])\n        ) as BaseGraphDestination[];\n\n        allNodeWorkflows.addConditionalEdges(\n          firstAfterAgentNode,\n          this.#createAfterModelSequenceRouter(\n            clientTools,\n            firstAfterAgent.allowed,\n            END as string\n          ),\n          destinations\n        );\n      } else {\n        allNodeWorkflows.addEdge(firstAfterAgentNode, END);\n      }\n    }\n\n    /**\n     * add edges for tools node\n     */\n    if (clientTools.length > 0) {\n      // Tools should return to loop entry node (not including before_agent)\n      const toolReturnTarget = loopEntryNode;\n\n      if (shouldReturnDirect.size > 0) {\n        allNodeWorkflows.addConditionalEdges(\n          TOOLS_NODE_NAME,\n          this.#createToolsRouter(shouldReturnDirect, exitNode),\n          [toolReturnTarget, exitNode as string]\n        );\n      } else {\n        allNodeWorkflows.addEdge(TOOLS_NODE_NAME, toolReturnTarget);\n      }\n    }\n\n    /**\n     * compile the graph\n     */\n    this.#graph = allNodeWorkflows.compile({\n      checkpointer: this.options.checkpointer,\n      store: this.options.store,\n      name: this.options.name,\n      description: this.options.description,\n    }) as unknown as AgentGraph<Types>;\n  }\n\n  /**\n   * Get the compiled {@link https://docs.langchain.com/oss/javascript/langgraph/use-graph-api | StateGraph}.\n   */\n  get graph(): AgentGraph<Types> {\n    return this.#graph;\n  }\n\n  /**\n   * Get possible edge destinations from model node.\n   * @param toolClasses names of tools to call\n   * @param includeModelRequest whether to include \"model_request\" as a valid path (for jumpTo routing)\n   * @returns list of possible edge destinations\n   */\n  #getModelPaths(\n    toolClasses: (ClientTool | ServerTool)[],\n    includeModelRequest: boolean = false\n  ): BaseGraphDestination[] {\n    const paths: BaseGraphDestination[] = [];\n    if (toolClasses.length > 0) {\n      paths.push(TOOLS_NODE_NAME);\n    }\n\n    if (includeModelRequest) {\n      paths.push(AGENT_NODE_NAME);\n    }\n\n    paths.push(END);\n\n    return paths;\n  }\n\n  /**\n   * Create routing function for tools node conditional edges.\n   */\n  #createToolsRouter(\n    shouldReturnDirect: Set<string>,\n    exitNode: string | typeof END\n  ) {\n    return (state: Record<string, unknown>) => {\n      const builtInState = state as unknown as BuiltInState;\n      const messages = builtInState.messages;\n      const lastMessage = messages[messages.length - 1];\n\n      // Check if we just executed a returnDirect tool\n      if (\n        ToolMessage.isInstance(lastMessage) &&\n        lastMessage.name &&\n        shouldReturnDirect.has(lastMessage.name)\n      ) {\n        // If we have a response format, route to agent to generate structured response\n        // Otherwise, return directly to exit node (could be after_agent or END)\n        return this.options.responseFormat ? AGENT_NODE_NAME : exitNode;\n      }\n\n      // For non-returnDirect tools, always route back to agent\n      return AGENT_NODE_NAME;\n    };\n  }\n\n  /**\n   * Create routing function for model node conditional edges.\n   * @param exitNode - The exit node to route to (could be after_agent or END)\n   */\n  #createModelRouter(exitNode: string | typeof END = END) {\n    /**\n     * determine if the agent should continue or not\n     */\n    return (state: Record<string, unknown>) => {\n      const builtInState = state as unknown as BuiltInState;\n      const messages = builtInState.messages;\n      const lastMessage = messages.at(-1);\n\n      if (\n        !AIMessage.isInstance(lastMessage) ||\n        !lastMessage.tool_calls ||\n        lastMessage.tool_calls.length === 0\n      ) {\n        return exitNode;\n      }\n\n      // Check if all tool calls are for structured response extraction\n      const hasOnlyStructuredResponseCalls = lastMessage.tool_calls.every(\n        (toolCall) => toolCall.name.startsWith(\"extract-\")\n      );\n\n      if (hasOnlyStructuredResponseCalls) {\n        // If all tool calls are for structured response extraction, go to exit node\n        // The AgentNode will handle these internally and return the structured response\n        return exitNode;\n      }\n\n      /**\n       * The tool node processes a single message.\n       */\n      if (this.#toolBehaviorVersion === \"v1\") {\n        return TOOLS_NODE_NAME;\n      }\n\n      /**\n       * Route to tools node (filter out any structured response tool calls)\n       */\n      const regularToolCalls = lastMessage.tool_calls.filter(\n        (toolCall) => !toolCall.name.startsWith(\"extract-\")\n      );\n\n      if (regularToolCalls.length === 0) {\n        return exitNode;\n      }\n\n      return regularToolCalls.map(\n        (toolCall) =>\n          new Send(TOOLS_NODE_NAME, { ...state, lg_tool_call: toolCall })\n      );\n    };\n  }\n\n  /**\n   * Create routing function for jumpTo functionality after afterModel hooks.\n   *\n   * This router checks if the `jumpTo` property is set in the state after afterModel middleware\n   * execution. If set, it routes to the specified target (\"model_request\" or \"tools\").\n   * If not set, it falls back to the normal model routing logic for afterModel context.\n   *\n   * The jumpTo property is automatically cleared after use to prevent infinite loops.\n   *\n   * @param toolClasses - Available tool classes for validation\n   * @param allowJump - Whether jumping is allowed\n   * @param exitNode - The exit node to route to (could be after_agent or END)\n   * @returns Router function that handles jumpTo logic and normal routing\n   */\n  #createAfterModelRouter(\n    toolClasses: (ClientTool | ServerTool)[],\n    allowJump: boolean,\n    exitNode: string | typeof END\n  ) {\n    const hasStructuredResponse = Boolean(this.options.responseFormat);\n\n    return (state: Record<string, unknown>) => {\n      const builtInState = state as unknown as Omit<BuiltInState, \"jumpTo\"> & {\n        jumpTo?: JumpTo;\n      };\n      // First, check if we just processed a structured response\n      // If so, ignore any existing jumpTo and go to exitNode\n      const messages = builtInState.messages;\n      const lastMessage = messages.at(-1);\n      if (\n        AIMessage.isInstance(lastMessage) &&\n        (!lastMessage.tool_calls || lastMessage.tool_calls.length === 0)\n      ) {\n        return exitNode;\n      }\n\n      // Check if jumpTo is set in the state and allowed\n      if (allowJump && builtInState.jumpTo) {\n        const destination = parseJumpToTarget(builtInState.jumpTo);\n        if (destination === END) {\n          return exitNode;\n        }\n        if (destination === TOOLS_NODE_NAME) {\n          // If trying to jump to tools but no tools are available, go to exitNode\n          if (toolClasses.length === 0) {\n            return exitNode;\n          }\n          return new Send(TOOLS_NODE_NAME, { ...state, jumpTo: undefined });\n        }\n        // destination === \"model_request\"\n        return new Send(AGENT_NODE_NAME, { ...state, jumpTo: undefined });\n      }\n\n      // check if there are pending tool calls\n      const toolMessages = messages.filter(ToolMessage.isInstance);\n      const lastAiMessage = messages.filter(AIMessage.isInstance).at(-1);\n      const pendingToolCalls = lastAiMessage?.tool_calls?.filter(\n        (call) => !toolMessages.some((m) => m.tool_call_id === call.id)\n      );\n      if (pendingToolCalls && pendingToolCalls.length > 0) {\n        return pendingToolCalls.map(\n          (toolCall) =>\n            new Send(TOOLS_NODE_NAME, { ...state, lg_tool_call: toolCall })\n        );\n      }\n\n      // if we exhausted all tool calls, but still have no structured response tool calls,\n      // go back to model_request\n      const hasStructuredResponseCalls = lastAiMessage?.tool_calls?.some(\n        (toolCall) => toolCall.name.startsWith(\"extract-\")\n      );\n\n      if (\n        pendingToolCalls &&\n        pendingToolCalls.length === 0 &&\n        !hasStructuredResponseCalls &&\n        hasStructuredResponse\n      ) {\n        return AGENT_NODE_NAME;\n      }\n\n      if (\n        !AIMessage.isInstance(lastMessage) ||\n        !lastMessage.tool_calls ||\n        lastMessage.tool_calls.length === 0\n      ) {\n        return exitNode;\n      }\n\n      // Check if all tool calls are for structured response extraction\n      const hasOnlyStructuredResponseCalls = lastMessage.tool_calls.every(\n        (toolCall) => toolCall.name.startsWith(\"extract-\")\n      );\n\n      // Check if there are any regular tool calls (non-structured response)\n      const hasRegularToolCalls = lastMessage.tool_calls.some(\n        (toolCall) => !toolCall.name.startsWith(\"extract-\")\n      );\n\n      if (hasOnlyStructuredResponseCalls || !hasRegularToolCalls) {\n        return exitNode;\n      }\n\n      /**\n       * For routing from afterModel nodes, always use simple string paths\n       * The Send API is handled at the model_request node level\n       */\n      return TOOLS_NODE_NAME;\n    };\n  }\n\n  /**\n   * Router for afterModel sequence nodes (connecting later middlewares to earlier ones),\n   * honoring allowed jump targets and defaulting to the next node.\n   */\n  #createAfterModelSequenceRouter(\n    toolClasses: (ClientTool | ServerTool)[],\n    allowed: string[],\n    nextDefault: string\n  ) {\n    const allowedSet = new Set(allowed.map((t) => parseJumpToTarget(t)));\n    return (state: Record<string, unknown>) => {\n      const builtInState = state as unknown as BuiltInState;\n      if (builtInState.jumpTo) {\n        const dest = parseJumpToTarget(builtInState.jumpTo);\n        if (dest === END && allowedSet.has(END)) {\n          return END;\n        }\n        if (dest === TOOLS_NODE_NAME && allowedSet.has(TOOLS_NODE_NAME)) {\n          if (toolClasses.length === 0) return END;\n          return new Send(TOOLS_NODE_NAME, { ...state, jumpTo: undefined });\n        }\n        if (dest === AGENT_NODE_NAME && allowedSet.has(AGENT_NODE_NAME)) {\n          return new Send(AGENT_NODE_NAME, { ...state, jumpTo: undefined });\n        }\n      }\n      return nextDefault;\n    };\n  }\n\n  /**\n   * Create routing function for jumpTo functionality after beforeAgent hooks.\n   * Falls back to the default next node if no jumpTo is present.\n   * When jumping to END, routes to exitNode (which could be an afterAgent node).\n   */\n  #createBeforeAgentRouter(\n    toolClasses: (ClientTool | ServerTool)[],\n    nextDefault: string,\n    exitNode: string | typeof END\n  ) {\n    return (state: Record<string, unknown>) => {\n      const builtInState = state as unknown as BuiltInState;\n      if (!builtInState.jumpTo) {\n        return nextDefault;\n      }\n      const destination = parseJumpToTarget(builtInState.jumpTo);\n      if (destination === END) {\n        /**\n         * When beforeAgent jumps to END, route to exitNode (first afterAgent node)\n         */\n        return exitNode;\n      }\n      if (destination === TOOLS_NODE_NAME) {\n        if (toolClasses.length === 0) {\n          return exitNode;\n        }\n        return new Send(TOOLS_NODE_NAME, { ...state, jumpTo: undefined });\n      }\n      return new Send(AGENT_NODE_NAME, { ...state, jumpTo: undefined });\n    };\n  }\n\n  /**\n   * Create routing function for jumpTo functionality after beforeModel hooks.\n   * Falls back to the default next node if no jumpTo is present.\n   */\n  #createBeforeModelRouter(\n    toolClasses: (ClientTool | ServerTool)[],\n    nextDefault: string\n  ) {\n    return (state: Record<string, unknown>) => {\n      const builtInState = state as unknown as BuiltInState;\n      if (!builtInState.jumpTo) {\n        return nextDefault;\n      }\n      const destination = parseJumpToTarget(builtInState.jumpTo);\n      if (destination === END) {\n        return END;\n      }\n      if (destination === TOOLS_NODE_NAME) {\n        if (toolClasses.length === 0) {\n          return END;\n        }\n        return new Send(TOOLS_NODE_NAME, { ...state, jumpTo: undefined });\n      }\n      return new Send(AGENT_NODE_NAME, { ...state, jumpTo: undefined });\n    };\n  }\n\n  /**\n   * Initialize middleware states if not already present in the input state.\n   */\n  async #initializeMiddlewareStates(\n    state: InvokeStateParameter<Types>,\n    config: RunnableConfig\n  ): Promise<InvokeStateParameter<Types>> {\n    if (\n      !this.options.middleware ||\n      this.options.middleware.length === 0 ||\n      state instanceof Command ||\n      !state\n    ) {\n      return state;\n    }\n\n    const defaultStates = await initializeMiddlewareStates(\n      this.options.middleware,\n      state\n    );\n    const threadState = await this.#graph\n      .getState(config)\n      .catch(() => ({ values: {} }));\n    const updatedState = {\n      ...threadState.values,\n      ...state,\n    } as InvokeStateParameter<Types>;\n    if (!updatedState) {\n      return updatedState;\n    }\n\n    // Only add defaults for keys that don't exist in current state\n    for (const [key, value] of Object.entries(defaultStates)) {\n      if (!(key in updatedState)) {\n        updatedState[key as keyof typeof updatedState] = value;\n      }\n    }\n\n    return updatedState;\n  }\n\n  /**\n   * Executes the agent with the given state and returns the final state after all processing.\n   *\n   * This method runs the agent's entire workflow synchronously, including:\n   * - Processing the input messages through any configured middleware\n   * - Calling the language model to generate responses\n   * - Executing any tool calls made by the model\n   * - Running all middleware hooks (beforeModel, afterModel, etc.)\n   *\n   * @param state - The initial state for the agent execution. Can be:\n   *   - An object containing `messages` array and any middleware-specific state properties\n   *   - A Command object for more advanced control flow\n   *\n   * @param config - Optional runtime configuration including:\n   * @param config.context - The context for the agent execution.\n   * @param config.configurable - LangGraph configuration options like `thread_id`, `run_id`, etc.\n   * @param config.store - The store for the agent execution for persisting state, see more in {@link https://docs.langchain.com/oss/javascript/langgraph/memory#memory-storage | Memory storage}.\n   * @param config.signal - An optional {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal | `AbortSignal`} for the agent execution.\n   * @param config.recursionLimit - The recursion limit for the agent execution.\n   *\n   * @returns A Promise that resolves to the final agent state after execution completes.\n   *          The returned state includes:\n   *          - a `messages` property containing an array with all messages (input, AI responses, tool calls/results)\n   *          - a `structuredResponse` property containing the structured response (if configured)\n   *          - all state values defined in the middleware\n   *\n   * @example\n   * ```typescript\n   * const agent = new ReactAgent({\n   *   llm: myModel,\n   *   tools: [calculator, webSearch],\n   *   responseFormat: z.object({\n   *     weather: z.string(),\n   *   }),\n   * });\n   *\n   * const result = await agent.invoke({\n   *   messages: [{ role: \"human\", content: \"What's the weather in Paris?\" }]\n   * });\n   *\n   * console.log(result.structuredResponse.weather); // outputs: \"It's sunny and 75Â°F.\"\n   * ```\n   */\n  async invoke(\n    state: InvokeStateParameter<Types>,\n    config?: InvokeConfiguration<\n      InferContextInput<\n        Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n          ? Types[\"Context\"]\n          : AnyAnnotationRoot\n      > &\n        InferMiddlewareContextInputs<Types[\"Middleware\"]>\n    >\n  ) {\n    type FullState = MergedAgentState<Types>;\n    const initializedState = await this.#initializeMiddlewareStates(\n      state,\n      config as RunnableConfig\n    );\n\n    return this.#graph.invoke(\n      initializedState,\n      config as unknown as InferContextInput<\n        Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n          ? Types[\"Context\"]\n          : AnyAnnotationRoot\n      > &\n        InferMiddlewareContextInputs<Types[\"Middleware\"]>\n    ) as Promise<FullState>;\n  }\n\n  /**\n   * Executes the agent with streaming, returning an async iterable of state updates as they occur.\n   *\n   * This method runs the agent's workflow similar to `invoke`, but instead of waiting for\n   * completion, it streams high-level state updates in real-time. This allows you to:\n   * - Display intermediate results to users as they're generated\n   * - Monitor the agent's progress through each step\n   * - React to state changes as nodes complete\n   *\n   * For more granular event-level streaming (like individual LLM tokens), use `streamEvents` instead.\n   *\n   * @param state - The initial state for the agent execution. Can be:\n   *   - An object containing `messages` array and any middleware-specific state properties\n   *   - A Command object for more advanced control flow\n   *\n   * @param config - Optional runtime configuration including:\n   * @param config.context - The context for the agent execution.\n   * @param config.configurable - LangGraph configuration options like `thread_id`, `run_id`, etc.\n   * @param config.store - The store for the agent execution for persisting state, see more in {@link https://docs.langchain.com/oss/javascript/langgraph/memory#memory-storage | Memory storage}.\n   * @param config.signal - An optional {@link https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal | `AbortSignal`} for the agent execution.\n   * @param config.streamMode - The streaming mode for the agent execution, see more in {@link https://docs.langchain.com/oss/javascript/langgraph/streaming#supported-stream-modes | Supported stream modes}.\n   * @param config.recursionLimit - The recursion limit for the agent execution.\n   *\n   * @returns A Promise that resolves to an IterableReadableStream of state updates.\n   *          Each update contains the current state after a node completes.\n   *\n   * @example\n   * ```typescript\n   * const agent = new ReactAgent({\n   *   llm: myModel,\n   *   tools: [calculator, webSearch]\n   * });\n   *\n   * const stream = await agent.stream({\n   *   messages: [{ role: \"human\", content: \"What's 2+2 and the weather in NYC?\" }]\n   * });\n   *\n   * for await (const chunk of stream) {\n   *   console.log(chunk); // State update from each node\n   * }\n   * ```\n   */\n  async stream<\n    TStreamMode extends StreamMode | StreamMode[] | undefined,\n    TEncoding extends \"text/event-stream\" | undefined,\n  >(\n    state: InvokeStateParameter<Types>,\n    config?: StreamConfiguration<\n      InferContextInput<\n        Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n          ? Types[\"Context\"]\n          : AnyAnnotationRoot\n      > &\n        InferMiddlewareContextInputs<Types[\"Middleware\"]>,\n      TStreamMode,\n      TEncoding\n    >\n  ) {\n    const initializedState = await this.#initializeMiddlewareStates(\n      state,\n      config as RunnableConfig\n    );\n    return this.#graph.stream(\n      initializedState,\n      config as Record<string, any>\n    ) as Promise<\n      IterableReadableStream<\n        StreamOutputMap<\n          TStreamMode,\n          false,\n          MergedAgentState<Types>,\n          MergedAgentState<Types>,\n          string,\n          unknown,\n          unknown,\n          TEncoding\n        >\n      >\n    >;\n  }\n\n  /**\n   * Visualize the graph as a PNG image.\n   * @param params - Parameters for the drawMermaidPng method.\n   * @param params.withStyles - Whether to include styles in the graph.\n   * @param params.curveStyle - The style of the graph's curves.\n   * @param params.nodeColors - The colors of the graph's nodes.\n   * @param params.wrapLabelNWords - The maximum number of words to wrap in a node's label.\n   * @param params.backgroundColor - The background color of the graph.\n   * @returns PNG image as a buffer\n   */\n  async drawMermaidPng(params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n    backgroundColor?: string;\n  }) {\n    const representation = await this.#graph.getGraphAsync();\n    const image = await representation.drawMermaidPng(params);\n    const arrayBuffer = await image.arrayBuffer();\n    const buffer = new Uint8Array(arrayBuffer);\n    return buffer;\n  }\n\n  /**\n   * Draw the graph as a Mermaid string.\n   * @param params - Parameters for the drawMermaid method.\n   * @param params.withStyles - Whether to include styles in the graph.\n   * @param params.curveStyle - The style of the graph's curves.\n   * @param params.nodeColors - The colors of the graph's nodes.\n   * @param params.wrapLabelNWords - The maximum number of words to wrap in a node's label.\n   * @param params.backgroundColor - The background color of the graph.\n   * @returns Mermaid string\n   */\n  async drawMermaid(params?: {\n    withStyles?: boolean;\n    curveStyle?: string;\n    nodeColors?: Record<string, string>;\n    wrapLabelNWords?: number;\n    backgroundColor?: string;\n  }) {\n    const representation = await this.#graph.getGraphAsync();\n    return representation.drawMermaid(params);\n  }\n\n  /**\n   * The following are internal methods to enable support for LangGraph Platform.\n   * They are not part of the createAgent public API.\n   *\n   * Note: we intentionally return as `never` to avoid type errors due to type inference.\n   */\n\n  /**\n   * @internal\n   */\n  streamEvents(\n    state: InvokeStateParameter<Types>,\n    config?: StreamConfiguration<\n      InferContextInput<\n        Types[\"Context\"] extends AnyAnnotationRoot | InteropZodObject\n          ? Types[\"Context\"]\n          : AnyAnnotationRoot\n      > &\n        InferMiddlewareContextInputs<Types[\"Middleware\"]>,\n      StreamMode | StreamMode[] | undefined,\n      \"text/event-stream\" | undefined\n    > & { version?: \"v1\" | \"v2\" },\n    streamOptions?: Parameters<Runnable[\"streamEvents\"]>[2]\n  ): IterableReadableStream<StreamEvent> {\n    return this.#graph.streamEvents(\n      state,\n      {\n        ...(config as Partial<\n          PregelOptions<\n            any,\n            any,\n            any,\n            StreamMode | StreamMode[] | undefined,\n            boolean,\n            \"text/event-stream\"\n          >\n        >),\n        version: config?.version ?? \"v2\",\n      },\n      streamOptions\n    );\n  }\n  /**\n   * @internal\n   */\n  getGraphAsync(config?: RunnableConfig) {\n    return this.#graph.getGraphAsync(config) as never;\n  }\n  /**\n   * @internal\n   */\n  getState(config: RunnableConfig, options?: GetStateOptions) {\n    return this.#graph.getState(config, options) as never;\n  }\n  /**\n   * @internal\n   */\n  getStateHistory(config: RunnableConfig, options?: CheckpointListOptions) {\n    return this.#graph.getStateHistory(config, options) as never;\n  }\n  /**\n   * @internal\n   */\n  getSubgraphs(namespace?: string, recurse?: boolean) {\n    return this.#graph.getSubgraphs(namespace, recurse) as never;\n  }\n  /**\n   * @internal\n   */\n  getSubgraphAsync(namespace?: string, recurse?: boolean) {\n    return this.#graph.getSubgraphsAsync(namespace, recurse) as never;\n  }\n  /**\n   * @internal\n   */\n  updateState(\n    inputConfig: LangGraphRunnableConfig,\n    values: Record<string, unknown> | unknown,\n    asNode?: string\n  ) {\n    return this.#graph.updateState(inputConfig, values, asNode) as never;\n  }\n\n  /**\n   * @internal\n   */\n  get builder() {\n    return this.#graph.builder;\n  }\n}\n"],"mappings":"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"}