{"version":3,"file":"groq.cjs","names":["message: AIMessage","blocks: Array<ContentBlock.Standard>","_isString","ChatGroqTranslator: StandardContentBlockTranslator"],"sources":["../../../src/messages/block_translators/groq.ts"],"sourcesContent":["import { AIMessage } from \"../ai.js\";\nimport { ContentBlock } from \"../content/index.js\";\nimport type { StandardContentBlockTranslator } from \"./index.js\";\nimport { _isString } from \"./utils.js\";\n\n/**\n * Converts a Groq AI message to an array of v1 standard content blocks.\n *\n * This function processes an AI message from Groq's API format\n * and converts it to the standardized v1 content block format. It handles\n * both parsed reasoning (in additional_kwargs.reasoning) and raw reasoning\n * (in <think> tags within content).\n *\n * @param message - The AI message containing Groq-formatted content\n * @returns Array of content blocks in v1 standard format\n *\n * @example\n * ```typescript\n * // Parsed format (reasoning_format=\"parsed\")\n * const message = new AIMessage({\n *   content: \"The answer is 42\",\n *   additional_kwargs: { reasoning: \"Let me think about this...\" }\n * });\n * const standardBlocks = convertToV1FromGroqMessage(message);\n * // Returns:\n * // [\n * //   { type: \"reasoning\", reasoning: \"Let me think about this...\" },\n * //   { type: \"text\", text: \"The answer is 42\" }\n * // ]\n * ```\n *\n * @example\n * ```typescript\n * // Raw format (reasoning_format=\"raw\")\n * const message = new AIMessage({\n *   content: \"<think>Let me think...</think>The answer is 42\"\n * });\n * const standardBlocks = convertToV1FromGroqMessage(message);\n * // Returns:\n * // [\n * //   { type: \"reasoning\", reasoning: \"Let me think...\" },\n * //   { type: \"text\", text: \"The answer is 42\" }\n * // ]\n * ```\n */\nexport function convertToV1FromGroqMessage(\n  message: AIMessage\n): Array<ContentBlock.Standard> {\n  const blocks: Array<ContentBlock.Standard> = [];\n\n  // Check for parsed reasoning format in additional_kwargs.reasoning\n  const parsedReasoning = message.additional_kwargs?.reasoning;\n  if (_isString(parsedReasoning) && parsedReasoning.length > 0) {\n    blocks.push({\n      type: \"reasoning\",\n      reasoning: parsedReasoning,\n    });\n  }\n\n  // Handle text content\n  if (typeof message.content === \"string\") {\n    let textContent = message.content;\n\n    // Check for raw reasoning format with <think> tags\n    const thinkMatch = textContent.match(/<think>([\\s\\S]*?)<\\/think>/);\n    if (thinkMatch) {\n      const thinkingContent = thinkMatch[1].trim();\n      if (thinkingContent.length > 0) {\n        blocks.push({\n          type: \"reasoning\",\n          reasoning: thinkingContent,\n        });\n      }\n      // Remove the think tags from the text content\n      textContent = textContent.replace(/<think>[\\s\\S]*?<\\/think>/, \"\").trim();\n    }\n\n    if (textContent.length > 0) {\n      blocks.push({\n        type: \"text\",\n        text: textContent,\n      });\n    }\n  } else {\n    for (const block of message.content) {\n      if (\n        typeof block === \"object\" &&\n        \"type\" in block &&\n        block.type === \"text\" &&\n        \"text\" in block &&\n        _isString(block.text)\n      ) {\n        let textContent = block.text;\n\n        // Check for raw reasoning format with <think> tags\n        const thinkMatch = textContent.match(/<think>([\\s\\S]*?)<\\/think>/);\n        if (thinkMatch) {\n          const thinkingContent = thinkMatch[1].trim();\n          if (thinkingContent.length > 0) {\n            blocks.push({\n              type: \"reasoning\",\n              reasoning: thinkingContent,\n            });\n          }\n          textContent = textContent\n            .replace(/<think>[\\s\\S]*?<\\/think>/, \"\")\n            .trim();\n        }\n\n        if (textContent.length > 0) {\n          blocks.push({\n            type: \"text\",\n            text: textContent,\n          });\n        }\n      }\n    }\n  }\n\n  // Add tool calls if present\n  for (const toolCall of message.tool_calls ?? []) {\n    blocks.push({\n      type: \"tool_call\",\n      id: toolCall.id,\n      name: toolCall.name,\n      args: toolCall.args,\n    });\n  }\n\n  return blocks;\n}\n\nexport const ChatGroqTranslator: StandardContentBlockTranslator = {\n  translateContent: convertToV1FromGroqMessage,\n  translateContentChunk: convertToV1FromGroqMessage,\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CA,SAAgB,2BACdA,SAC8B;CAC9B,MAAMC,SAAuC,CAAE;CAG/C,MAAM,kBAAkB,QAAQ,mBAAmB;AACnD,KAAIC,wBAAU,gBAAgB,IAAI,gBAAgB,SAAS,GACzD,OAAO,KAAK;EACV,MAAM;EACN,WAAW;CACZ,EAAC;AAIJ,KAAI,OAAO,QAAQ,YAAY,UAAU;EACvC,IAAI,cAAc,QAAQ;EAG1B,MAAM,aAAa,YAAY,MAAM,6BAA6B;AAClE,MAAI,YAAY;GACd,MAAM,kBAAkB,WAAW,GAAG,MAAM;AAC5C,OAAI,gBAAgB,SAAS,GAC3B,OAAO,KAAK;IACV,MAAM;IACN,WAAW;GACZ,EAAC;GAGJ,cAAc,YAAY,QAAQ,4BAA4B,GAAG,CAAC,MAAM;EACzE;AAED,MAAI,YAAY,SAAS,GACvB,OAAO,KAAK;GACV,MAAM;GACN,MAAM;EACP,EAAC;CAEL,MACC,MAAK,MAAM,SAAS,QAAQ,QAC1B,KACE,OAAO,UAAU,YACjB,UAAU,SACV,MAAM,SAAS,UACf,UAAU,SACVA,wBAAU,MAAM,KAAK,EACrB;EACA,IAAI,cAAc,MAAM;EAGxB,MAAM,aAAa,YAAY,MAAM,6BAA6B;AAClE,MAAI,YAAY;GACd,MAAM,kBAAkB,WAAW,GAAG,MAAM;AAC5C,OAAI,gBAAgB,SAAS,GAC3B,OAAO,KAAK;IACV,MAAM;IACN,WAAW;GACZ,EAAC;GAEJ,cAAc,YACX,QAAQ,4BAA4B,GAAG,CACvC,MAAM;EACV;AAED,MAAI,YAAY,SAAS,GACvB,OAAO,KAAK;GACV,MAAM;GACN,MAAM;EACP,EAAC;CAEL;AAKL,MAAK,MAAM,YAAY,QAAQ,cAAc,CAAE,GAC7C,OAAO,KAAK;EACV,MAAM;EACN,IAAI,SAAS;EACb,MAAM,SAAS;EACf,MAAM,SAAS;CAChB,EAAC;AAGJ,QAAO;AACR;AAED,MAAaC,qBAAqD;CAChE,kBAAkB;CAClB,uBAAuB;AACxB"}