{"version":3,"file":"json_output_tools_parsers.js","names":["rawToolCall: Record<string, any>","options?: { returnId?: boolean; partial?: boolean }","e: any","parsedToolCall: ToolCall","toolCall: ToolCall","errorMsg?: string","fields?: JsonOutputToolsParserParams","generations: ChatGeneration[]","generations: ChatGenerationChunk[] | ChatGeneration[]","rawToolCall: Record<string, unknown>","backwardsCompatibleToolCall: ParsedToolCall","params:\n      | JsonOutputKeyToolsParserParamsV3<T>\n      | JsonOutputKeyToolsParserParamsV4<T>\n      | JsonOutputKeyToolsParserParamsInterop<T>","result: unknown","result: ParsedToolCall","returnedValues: ParsedToolCall[] | Record<string, any>[]"],"sources":["../../../src/output_parsers/openai_tools/json_output_tools_parsers.ts"],"sourcesContent":["import type * as z3 from \"zod/v3\";\nimport type * as z4 from \"zod/v4/core\";\nimport { ChatGeneration, ChatGenerationChunk } from \"../../outputs.js\";\nimport { OutputParserException } from \"../base.js\";\nimport { parsePartialJson } from \"../json.js\";\nimport { InvalidToolCall, ToolCall } from \"../../messages/tool.js\";\nimport {\n  BaseCumulativeTransformOutputParser,\n  BaseCumulativeTransformOutputParserInput,\n} from \"../transform.js\";\nimport { isAIMessage } from \"../../messages/ai.js\";\nimport {\n  type InteropZodType,\n  interopSafeParseAsync,\n} from \"../../utils/types/zod.js\";\n\nexport type ParsedToolCall = {\n  id?: string;\n\n  type: string;\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  args: Record<string, any>;\n};\n\nexport type JsonOutputToolsParserParams = {\n  /** Whether to return the tool call id. */\n  returnId?: boolean;\n} & BaseCumulativeTransformOutputParserInput;\n\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options: { returnId?: boolean; partial: true }\n): ToolCall | undefined;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: false }\n): ToolCall;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: boolean }\n): ToolCall | undefined;\nexport function parseToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  options?: { returnId?: boolean; partial?: boolean }\n): ToolCall | undefined {\n  if (rawToolCall.function === undefined) {\n    return undefined;\n  }\n  let functionArgs;\n  if (options?.partial) {\n    try {\n      functionArgs = parsePartialJson(rawToolCall.function.arguments ?? \"{}\");\n    } catch {\n      return undefined;\n    }\n  } else {\n    try {\n      functionArgs = JSON.parse(rawToolCall.function.arguments);\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    } catch (e: any) {\n      throw new OutputParserException(\n        [\n          `Function \"${rawToolCall.function.name}\" arguments:`,\n          ``,\n          rawToolCall.function.arguments,\n          ``,\n          `are not valid JSON.`,\n          `Error: ${e.message}`,\n        ].join(\"\\n\")\n      );\n    }\n  }\n\n  const parsedToolCall: ToolCall = {\n    name: rawToolCall.function.name,\n    args: functionArgs,\n    type: \"tool_call\",\n  };\n\n  if (options?.returnId) {\n    parsedToolCall.id = rawToolCall.id;\n  }\n\n  return parsedToolCall;\n}\n\nexport function convertLangChainToolCallToOpenAI(toolCall: ToolCall) {\n  if (toolCall.id === undefined) {\n    throw new Error(`All OpenAI tool calls must have an \"id\" field.`);\n  }\n  return {\n    id: toolCall.id,\n    type: \"function\",\n    function: {\n      name: toolCall.name,\n      arguments: JSON.stringify(toolCall.args),\n    },\n  };\n}\n\nexport function makeInvalidToolCall(\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  rawToolCall: Record<string, any>,\n  errorMsg?: string\n): InvalidToolCall {\n  return {\n    name: rawToolCall.function?.name,\n    args: rawToolCall.function?.arguments,\n    id: rawToolCall.id,\n    error: errorMsg,\n    type: \"invalid_tool_call\",\n  };\n}\n\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object.\n */\nexport class JsonOutputToolsParser<\n  T,\n> extends BaseCumulativeTransformOutputParser<T> {\n  static lc_name() {\n    return \"JsonOutputToolsParser\";\n  }\n\n  returnId = false;\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  constructor(fields?: JsonOutputToolsParserParams) {\n    super(fields);\n    this.returnId = fields?.returnId ?? this.returnId;\n  }\n\n  protected _diff() {\n    throw new Error(\"Not supported.\");\n  }\n\n  async parse(): Promise<T> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  async parseResult(generations: ChatGeneration[]): Promise<T> {\n    const result = await this.parsePartialResult(generations, false);\n    return result;\n  }\n\n  /**\n   * Parses the output and returns a JSON object. If `argsOnly` is true,\n   * only the arguments of the function call are returned.\n   * @param generations The output of the LLM to parse.\n   * @returns A JSON object representation of the function call or its arguments.\n   */\n  async parsePartialResult(\n    generations: ChatGenerationChunk[] | ChatGeneration[],\n    partial = true\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): Promise<any> {\n    const message = generations[0].message;\n    let toolCalls;\n    if (isAIMessage(message) && message.tool_calls?.length) {\n      toolCalls = message.tool_calls.map((toolCall) => {\n        const { id, ...rest } = toolCall;\n        if (!this.returnId) {\n          return rest;\n        }\n        return {\n          id,\n          ...rest,\n        };\n      });\n    } else if (message.additional_kwargs.tool_calls !== undefined) {\n      const rawToolCalls = JSON.parse(\n        JSON.stringify(message.additional_kwargs.tool_calls)\n      );\n      toolCalls = rawToolCalls.map((rawToolCall: Record<string, unknown>) => {\n        return parseToolCall(rawToolCall, { returnId: this.returnId, partial });\n      });\n    }\n    if (!toolCalls) {\n      return [];\n    }\n    const parsedToolCalls = [];\n    for (const toolCall of toolCalls) {\n      if (toolCall !== undefined) {\n        const backwardsCompatibleToolCall: ParsedToolCall = {\n          type: toolCall.name,\n          args: toolCall.args,\n          id: toolCall.id,\n        };\n        parsedToolCalls.push(backwardsCompatibleToolCall);\n      }\n    }\n    return parsedToolCalls;\n  }\n}\n\ntype JsonOutputKeyToolsParserParamsBase = {\n  keyName: string;\n  returnSingle?: boolean;\n} & JsonOutputToolsParserParams;\n\ntype JsonOutputKeyToolsParserParamsV3<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = { zodSchema?: z3.ZodType<T> } & JsonOutputKeyToolsParserParamsBase;\n\ntype JsonOutputKeyToolsParserParamsV4<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = { zodSchema?: z4.$ZodType<T, T> } & JsonOutputKeyToolsParserParamsBase;\n\nexport type JsonOutputKeyToolsParserParamsInterop<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = { zodSchema?: InteropZodType<T> } & JsonOutputKeyToolsParserParamsBase;\n\n// Use Zod 3 for backwards compatibility\nexport type JsonOutputKeyToolsParserParams<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> = JsonOutputKeyToolsParserParamsV3<T>;\n\n/**\n * Class for parsing the output of a tool-calling LLM into a JSON object if you are\n * expecting only a single tool to be called.\n */\nexport class JsonOutputKeyToolsParser<\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  T extends Record<string, any> = Record<string, any>,\n> extends JsonOutputToolsParser<T> {\n  static lc_name() {\n    return \"JsonOutputKeyToolsParser\";\n  }\n\n  lc_namespace = [\"langchain\", \"output_parsers\", \"openai_tools\"];\n\n  lc_serializable = true;\n\n  returnId = false;\n\n  /** The type of tool calls to return. */\n  keyName: string;\n\n  /** Whether to return only the first tool call. */\n  returnSingle = false;\n\n  zodSchema?: InteropZodType<T>;\n\n  constructor(params: JsonOutputKeyToolsParserParamsV3<T>);\n\n  constructor(params: JsonOutputKeyToolsParserParamsV4<T>);\n\n  constructor(params: JsonOutputKeyToolsParserParamsInterop<T>);\n\n  constructor(\n    params:\n      | JsonOutputKeyToolsParserParamsV3<T>\n      | JsonOutputKeyToolsParserParamsV4<T>\n      | JsonOutputKeyToolsParserParamsInterop<T>\n  ) {\n    super(params);\n    this.keyName = params.keyName;\n    this.returnSingle = params.returnSingle ?? this.returnSingle;\n    this.zodSchema = params.zodSchema;\n  }\n\n  protected async _validateResult(result: unknown): Promise<T> {\n    if (this.zodSchema === undefined) {\n      return result as T;\n    }\n    const zodParsedResult = await interopSafeParseAsync(this.zodSchema, result);\n    if (zodParsedResult.success) {\n      return zodParsedResult.data;\n    } else {\n      throw new OutputParserException(\n        `Failed to parse. Text: \"${JSON.stringify(\n          result,\n          null,\n          2\n        )}\". Error: ${JSON.stringify(zodParsedResult.error?.issues)}`,\n        JSON.stringify(result, null, 2)\n      );\n    }\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parsePartialResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await super.parsePartialResult(generations);\n    const matchingResults = results.filter(\n      (result: ParsedToolCall) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(\n        (result: ParsedToolCall) => result.args\n      );\n    }\n    if (this.returnSingle) {\n      return returnedValues[0];\n    }\n    return returnedValues;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  async parseResult(generations: ChatGeneration[]): Promise<any> {\n    const results = await super.parsePartialResult(generations, false);\n    const matchingResults = results.filter(\n      (result: ParsedToolCall) => result.type === this.keyName\n    );\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let returnedValues: ParsedToolCall[] | Record<string, any>[] =\n      matchingResults;\n    if (!matchingResults.length) {\n      return undefined;\n    }\n    if (!this.returnId) {\n      returnedValues = matchingResults.map(\n        (result: ParsedToolCall) => result.args\n      );\n    }\n    if (this.returnSingle) {\n      return this._validateResult(returnedValues[0]);\n    }\n    const toolCallResults = await Promise.all(\n      returnedValues.map((value) => this._validateResult(value))\n    );\n    return toolCallResults;\n  }\n}\n"],"mappings":";;;;;;;;AA6CA,SAAgB,cAEdA,aACAC,SACsB;AACtB,KAAI,YAAY,aAAa,OAC3B,QAAO;CAET,IAAI;AACJ,KAAI,SAAS,QACX,KAAI;EACF,eAAe,iBAAiB,YAAY,SAAS,aAAa,KAAK;CACxE,QAAO;AACN,SAAO;CACR;KAED,KAAI;EACF,eAAe,KAAK,MAAM,YAAY,SAAS,UAAU;CAE1D,SAAQC,GAAQ;AACf,QAAM,IAAI,sBACR;GACE,CAAC,UAAU,EAAE,YAAY,SAAS,KAAK,YAAY,CAAC;GACpD,EAAE;GACF,YAAY,SAAS;GACrB,EAAE;GACF,CAAC,mBAAmB,CAAC;GACrB,CAAC,OAAO,EAAE,EAAE,SAAS;EACtB,EAAC,KAAK,KAAK;CAEf;CAGH,MAAMC,iBAA2B;EAC/B,MAAM,YAAY,SAAS;EAC3B,MAAM;EACN,MAAM;CACP;AAED,KAAI,SAAS,UACX,eAAe,KAAK,YAAY;AAGlC,QAAO;AACR;AAED,SAAgB,iCAAiCC,UAAoB;AACnE,KAAI,SAAS,OAAO,OAClB,OAAM,IAAI,MAAM,CAAC,8CAA8C,CAAC;AAElE,QAAO;EACL,IAAI,SAAS;EACb,MAAM;EACN,UAAU;GACR,MAAM,SAAS;GACf,WAAW,KAAK,UAAU,SAAS,KAAK;EACzC;CACF;AACF;AAED,SAAgB,oBAEdJ,aACAK,UACiB;AACjB,QAAO;EACL,MAAM,YAAY,UAAU;EAC5B,MAAM,YAAY,UAAU;EAC5B,IAAI,YAAY;EAChB,OAAO;EACP,MAAM;CACP;AACF;;;;AAKD,IAAa,wBAAb,cAEU,oCAAuC;CAC/C,OAAO,UAAU;AACf,SAAO;CACR;CAED,WAAW;CAEX,eAAe;EAAC;EAAa;EAAkB;CAAe;CAE9D,kBAAkB;CAElB,YAAYC,QAAsC;EAChD,MAAM,OAAO;EACb,KAAK,WAAW,QAAQ,YAAY,KAAK;CAC1C;CAED,AAAU,QAAQ;AAChB,QAAM,IAAI,MAAM;CACjB;CAED,MAAM,QAAoB;AACxB,QAAM,IAAI,MAAM;CACjB;CAED,MAAM,YAAYC,aAA2C;EAC3D,MAAM,SAAS,MAAM,KAAK,mBAAmB,aAAa,MAAM;AAChE,SAAO;CACR;;;;;;;CAQD,MAAM,mBACJC,aACA,UAAU,MAEI;EACd,MAAM,UAAU,YAAY,GAAG;EAC/B,IAAI;AACJ,MAAI,YAAY,QAAQ,IAAI,QAAQ,YAAY,QAC9C,YAAY,QAAQ,WAAW,IAAI,CAAC,aAAa;GAC/C,MAAM,EAAE,GAAI,GAAG,MAAM,GAAG;AACxB,OAAI,CAAC,KAAK,SACR,QAAO;AAET,UAAO;IACL;IACA,GAAG;GACJ;EACF,EAAC;WACO,QAAQ,kBAAkB,eAAe,QAAW;GAC7D,MAAM,eAAe,KAAK,MACxB,KAAK,UAAU,QAAQ,kBAAkB,WAAW,CACrD;GACD,YAAY,aAAa,IAAI,CAACC,gBAAyC;AACrE,WAAO,cAAc,aAAa;KAAE,UAAU,KAAK;KAAU;IAAS,EAAC;GACxE,EAAC;EACH;AACD,MAAI,CAAC,UACH,QAAO,CAAE;EAEX,MAAM,kBAAkB,CAAE;AAC1B,OAAK,MAAM,YAAY,UACrB,KAAI,aAAa,QAAW;GAC1B,MAAMC,8BAA8C;IAClD,MAAM,SAAS;IACf,MAAM,SAAS;IACf,IAAI,SAAS;GACd;GACD,gBAAgB,KAAK,4BAA4B;EAClD;AAEH,SAAO;CACR;AACF;;;;;AAgCD,IAAa,2BAAb,cAGU,sBAAyB;CACjC,OAAO,UAAU;AACf,SAAO;CACR;CAED,eAAe;EAAC;EAAa;EAAkB;CAAe;CAE9D,kBAAkB;CAElB,WAAW;;CAGX;;CAGA,eAAe;CAEf;CAQA,YACEC,QAIA;EACA,MAAM,OAAO;EACb,KAAK,UAAU,OAAO;EACtB,KAAK,eAAe,OAAO,gBAAgB,KAAK;EAChD,KAAK,YAAY,OAAO;CACzB;CAED,MAAgB,gBAAgBC,QAA6B;AAC3D,MAAI,KAAK,cAAc,OACrB,QAAO;EAET,MAAM,kBAAkB,MAAM,sBAAsB,KAAK,WAAW,OAAO;AAC3E,MAAI,gBAAgB,QAClB,QAAO,gBAAgB;MAEvB,OAAM,IAAI,sBACR,CAAC,wBAAwB,EAAE,KAAK,UAC9B,QACA,MACA,EACD,CAAC,UAAU,EAAE,KAAK,UAAU,gBAAgB,OAAO,OAAO,EAAE,EAC7D,KAAK,UAAU,QAAQ,MAAM,EAAE;CAGpC;CAGD,MAAM,mBAAmBL,aAA6C;EACpE,MAAM,UAAU,MAAM,MAAM,mBAAmB,YAAY;EAC3D,MAAM,kBAAkB,QAAQ,OAC9B,CAACM,WAA2B,OAAO,SAAS,KAAK,QAClD;EAED,IAAIC,iBACF;AACF,MAAI,CAAC,gBAAgB,OACnB,QAAO;AAET,MAAI,CAAC,KAAK,UACR,iBAAiB,gBAAgB,IAC/B,CAACD,WAA2B,OAAO,KACpC;AAEH,MAAI,KAAK,aACP,QAAO,eAAe;AAExB,SAAO;CACR;CAGD,MAAM,YAAYN,aAA6C;EAC7D,MAAM,UAAU,MAAM,MAAM,mBAAmB,aAAa,MAAM;EAClE,MAAM,kBAAkB,QAAQ,OAC9B,CAACM,WAA2B,OAAO,SAAS,KAAK,QAClD;EAED,IAAIC,iBACF;AACF,MAAI,CAAC,gBAAgB,OACnB,QAAO;AAET,MAAI,CAAC,KAAK,UACR,iBAAiB,gBAAgB,IAC/B,CAACD,WAA2B,OAAO,KACpC;AAEH,MAAI,KAAK,aACP,QAAO,KAAK,gBAAgB,eAAe,GAAG;EAEhD,MAAM,kBAAkB,MAAM,QAAQ,IACpC,eAAe,IAAI,CAAC,UAAU,KAAK,gBAAgB,MAAM,CAAC,CAC3D;AACD,SAAO;CACR;AACF"}