/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  AssistantMessage,
  AssistantMessage$inboundSchema,
  AssistantMessage$Outbound,
  AssistantMessage$outboundSchema,
} from "./assistantmessage.js";
import {
  MistralPromptMode,
  MistralPromptMode$inboundSchema,
  MistralPromptMode$outboundSchema,
} from "./mistralpromptmode.js";
import {
  Prediction,
  Prediction$inboundSchema,
  Prediction$Outbound,
  Prediction$outboundSchema,
} from "./prediction.js";
import {
  ResponseFormat,
  ResponseFormat$inboundSchema,
  ResponseFormat$Outbound,
  ResponseFormat$outboundSchema,
} from "./responseformat.js";
import {
  SystemMessage,
  SystemMessage$inboundSchema,
  SystemMessage$Outbound,
  SystemMessage$outboundSchema,
} from "./systemmessage.js";
import {
  Tool,
  Tool$inboundSchema,
  Tool$Outbound,
  Tool$outboundSchema,
} from "./tool.js";
import {
  ToolChoice,
  ToolChoice$inboundSchema,
  ToolChoice$Outbound,
  ToolChoice$outboundSchema,
} from "./toolchoice.js";
import {
  ToolChoiceEnum,
  ToolChoiceEnum$inboundSchema,
  ToolChoiceEnum$outboundSchema,
} from "./toolchoiceenum.js";
import {
  ToolMessage,
  ToolMessage$inboundSchema,
  ToolMessage$Outbound,
  ToolMessage$outboundSchema,
} from "./toolmessage.js";
import {
  UserMessage,
  UserMessage$inboundSchema,
  UserMessage$Outbound,
  UserMessage$outboundSchema,
} from "./usermessage.js";

/**
 * Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
 */
export type AgentsCompletionRequestStop = string | Array<string>;

export type AgentsCompletionRequestMessages =
  | (SystemMessage & { role: "system" })
  | (ToolMessage & { role: "tool" })
  | (UserMessage & { role: "user" })
  | (AssistantMessage & { role: "assistant" });

export type AgentsCompletionRequestToolChoice = ToolChoice | ToolChoiceEnum;

export type AgentsCompletionRequest = {
  /**
   * The maximum number of tokens to generate in the completion. The token count of your prompt plus `max_tokens` cannot exceed the model's context length.
   */
  maxTokens?: number | null | undefined;
  /**
   * Whether to stream back partial progress. If set, tokens will be sent as data-only server-side events as they become available, with the stream terminated by a data: [DONE] message. Otherwise, the server will hold the request open until the timeout or until completion, with the response containing the full result as JSON.
   */
  stream?: boolean | undefined;
  /**
   * Stop generation if this token is detected. Or if one of these tokens is detected when providing an array
   */
  stop?: string | Array<string> | undefined;
  /**
   * The seed to use for random sampling. If set, different calls will generate deterministic results.
   */
  randomSeed?: number | null | undefined;
  metadata?: { [k: string]: any } | null | undefined;
  /**
   * The prompt(s) to generate completions for, encoded as a list of dict with role and content.
   */
  messages: Array<
    | (SystemMessage & { role: "system" })
    | (ToolMessage & { role: "tool" })
    | (UserMessage & { role: "user" })
    | (AssistantMessage & { role: "assistant" })
  >;
  /**
   * Specify the format that the model must output. By default it will use `{ "type": "text" }`. Setting to `{ "type": "json_object" }` enables JSON mode, which guarantees the message the model generates is in JSON. When using JSON mode you MUST also instruct the model to produce JSON yourself with a system or a user message. Setting to `{ "type": "json_schema" }` enables JSON schema mode, which guarantees the message the model generates is in JSON and follows the schema you provide.
   */
  responseFormat?: ResponseFormat | undefined;
  tools?: Array<Tool> | null | undefined;
  toolChoice?: ToolChoice | ToolChoiceEnum | undefined;
  /**
   * The `presence_penalty` determines how much the model penalizes the repetition of words or phrases. A higher presence penalty encourages the model to use a wider variety of words and phrases, making the output more diverse and creative.
   */
  presencePenalty?: number | undefined;
  /**
   * The `frequency_penalty` penalizes the repetition of words based on their frequency in the generated text. A higher frequency penalty discourages the model from repeating words that have already appeared frequently in the output, promoting diversity and reducing repetition.
   */
  frequencyPenalty?: number | undefined;
  /**
   * Number of completions to return for each request, input tokens are only billed once.
   */
  n?: number | null | undefined;
  /**
   * Enable users to specify an expected completion, optimizing response times by leveraging known or predictable content.
   */
  prediction?: Prediction | undefined;
  parallelToolCalls?: boolean | undefined;
  /**
   * Allows toggling between the reasoning mode and no system prompt. When set to `reasoning` the system prompt for reasoning models will be used.
   */
  promptMode?: MistralPromptMode | null | undefined;
  /**
   * The ID of the agent to use for this completion.
   */
  agentId: string;
};

/** @internal */
export const AgentsCompletionRequestStop$inboundSchema: z.ZodType<
  AgentsCompletionRequestStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

/** @internal */
export type AgentsCompletionRequestStop$Outbound = string | Array<string>;

/** @internal */
export const AgentsCompletionRequestStop$outboundSchema: z.ZodType<
  AgentsCompletionRequestStop$Outbound,
  z.ZodTypeDef,
  AgentsCompletionRequestStop
> = z.union([z.string(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AgentsCompletionRequestStop$ {
  /** @deprecated use `AgentsCompletionRequestStop$inboundSchema` instead. */
  export const inboundSchema = AgentsCompletionRequestStop$inboundSchema;
  /** @deprecated use `AgentsCompletionRequestStop$outboundSchema` instead. */
  export const outboundSchema = AgentsCompletionRequestStop$outboundSchema;
  /** @deprecated use `AgentsCompletionRequestStop$Outbound` instead. */
  export type Outbound = AgentsCompletionRequestStop$Outbound;
}

export function agentsCompletionRequestStopToJSON(
  agentsCompletionRequestStop: AgentsCompletionRequestStop,
): string {
  return JSON.stringify(
    AgentsCompletionRequestStop$outboundSchema.parse(
      agentsCompletionRequestStop,
    ),
  );
}

export function agentsCompletionRequestStopFromJSON(
  jsonString: string,
): SafeParseResult<AgentsCompletionRequestStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentsCompletionRequestStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentsCompletionRequestStop' from JSON`,
  );
}

/** @internal */
export const AgentsCompletionRequestMessages$inboundSchema: z.ZodType<
  AgentsCompletionRequestMessages,
  z.ZodTypeDef,
  unknown
> = z.union([
  SystemMessage$inboundSchema.and(
    z.object({ role: z.literal("system") }).transform((v) => ({
      role: v.role,
    })),
  ),
  ToolMessage$inboundSchema.and(
    z.object({ role: z.literal("tool") }).transform((v) => ({ role: v.role })),
  ),
  UserMessage$inboundSchema.and(
    z.object({ role: z.literal("user") }).transform((v) => ({ role: v.role })),
  ),
  AssistantMessage$inboundSchema.and(
    z.object({ role: z.literal("assistant") }).transform((v) => ({
      role: v.role,
    })),
  ),
]);

/** @internal */
export type AgentsCompletionRequestMessages$Outbound =
  | (SystemMessage$Outbound & { role: "system" })
  | (ToolMessage$Outbound & { role: "tool" })
  | (UserMessage$Outbound & { role: "user" })
  | (AssistantMessage$Outbound & { role: "assistant" });

/** @internal */
export const AgentsCompletionRequestMessages$outboundSchema: z.ZodType<
  AgentsCompletionRequestMessages$Outbound,
  z.ZodTypeDef,
  AgentsCompletionRequestMessages
> = z.union([
  SystemMessage$outboundSchema.and(
    z.object({ role: z.literal("system") }).transform((v) => ({
      role: v.role,
    })),
  ),
  ToolMessage$outboundSchema.and(
    z.object({ role: z.literal("tool") }).transform((v) => ({ role: v.role })),
  ),
  UserMessage$outboundSchema.and(
    z.object({ role: z.literal("user") }).transform((v) => ({ role: v.role })),
  ),
  AssistantMessage$outboundSchema.and(
    z.object({ role: z.literal("assistant") }).transform((v) => ({
      role: v.role,
    })),
  ),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AgentsCompletionRequestMessages$ {
  /** @deprecated use `AgentsCompletionRequestMessages$inboundSchema` instead. */
  export const inboundSchema = AgentsCompletionRequestMessages$inboundSchema;
  /** @deprecated use `AgentsCompletionRequestMessages$outboundSchema` instead. */
  export const outboundSchema = AgentsCompletionRequestMessages$outboundSchema;
  /** @deprecated use `AgentsCompletionRequestMessages$Outbound` instead. */
  export type Outbound = AgentsCompletionRequestMessages$Outbound;
}

export function agentsCompletionRequestMessagesToJSON(
  agentsCompletionRequestMessages: AgentsCompletionRequestMessages,
): string {
  return JSON.stringify(
    AgentsCompletionRequestMessages$outboundSchema.parse(
      agentsCompletionRequestMessages,
    ),
  );
}

export function agentsCompletionRequestMessagesFromJSON(
  jsonString: string,
): SafeParseResult<AgentsCompletionRequestMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentsCompletionRequestMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentsCompletionRequestMessages' from JSON`,
  );
}

/** @internal */
export const AgentsCompletionRequestToolChoice$inboundSchema: z.ZodType<
  AgentsCompletionRequestToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([ToolChoice$inboundSchema, ToolChoiceEnum$inboundSchema]);

/** @internal */
export type AgentsCompletionRequestToolChoice$Outbound =
  | ToolChoice$Outbound
  | string;

/** @internal */
export const AgentsCompletionRequestToolChoice$outboundSchema: z.ZodType<
  AgentsCompletionRequestToolChoice$Outbound,
  z.ZodTypeDef,
  AgentsCompletionRequestToolChoice
> = z.union([ToolChoice$outboundSchema, ToolChoiceEnum$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AgentsCompletionRequestToolChoice$ {
  /** @deprecated use `AgentsCompletionRequestToolChoice$inboundSchema` instead. */
  export const inboundSchema = AgentsCompletionRequestToolChoice$inboundSchema;
  /** @deprecated use `AgentsCompletionRequestToolChoice$outboundSchema` instead. */
  export const outboundSchema =
    AgentsCompletionRequestToolChoice$outboundSchema;
  /** @deprecated use `AgentsCompletionRequestToolChoice$Outbound` instead. */
  export type Outbound = AgentsCompletionRequestToolChoice$Outbound;
}

export function agentsCompletionRequestToolChoiceToJSON(
  agentsCompletionRequestToolChoice: AgentsCompletionRequestToolChoice,
): string {
  return JSON.stringify(
    AgentsCompletionRequestToolChoice$outboundSchema.parse(
      agentsCompletionRequestToolChoice,
    ),
  );
}

export function agentsCompletionRequestToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<AgentsCompletionRequestToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentsCompletionRequestToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentsCompletionRequestToolChoice' from JSON`,
  );
}

/** @internal */
export const AgentsCompletionRequest$inboundSchema: z.ZodType<
  AgentsCompletionRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_tokens: z.nullable(z.number().int()).optional(),
  stream: z.boolean().default(false),
  stop: z.union([z.string(), z.array(z.string())]).optional(),
  random_seed: z.nullable(z.number().int()).optional(),
  metadata: z.nullable(z.record(z.any())).optional(),
  messages: z.array(
    z.union([
      SystemMessage$inboundSchema.and(
        z.object({ role: z.literal("system") }).transform((v) => ({
          role: v.role,
        })),
      ),
      ToolMessage$inboundSchema.and(
        z.object({ role: z.literal("tool") }).transform((v) => ({
          role: v.role,
        })),
      ),
      UserMessage$inboundSchema.and(
        z.object({ role: z.literal("user") }).transform((v) => ({
          role: v.role,
        })),
      ),
      AssistantMessage$inboundSchema.and(
        z.object({ role: z.literal("assistant") }).transform((v) => ({
          role: v.role,
        })),
      ),
    ]),
  ),
  response_format: ResponseFormat$inboundSchema.optional(),
  tools: z.nullable(z.array(Tool$inboundSchema)).optional(),
  tool_choice: z.union([ToolChoice$inboundSchema, ToolChoiceEnum$inboundSchema])
    .optional(),
  presence_penalty: z.number().optional(),
  frequency_penalty: z.number().optional(),
  n: z.nullable(z.number().int()).optional(),
  prediction: Prediction$inboundSchema.optional(),
  parallel_tool_calls: z.boolean().optional(),
  prompt_mode: z.nullable(MistralPromptMode$inboundSchema).optional(),
  agent_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "max_tokens": "maxTokens",
    "random_seed": "randomSeed",
    "response_format": "responseFormat",
    "tool_choice": "toolChoice",
    "presence_penalty": "presencePenalty",
    "frequency_penalty": "frequencyPenalty",
    "parallel_tool_calls": "parallelToolCalls",
    "prompt_mode": "promptMode",
    "agent_id": "agentId",
  });
});

/** @internal */
export type AgentsCompletionRequest$Outbound = {
  max_tokens?: number | null | undefined;
  stream: boolean;
  stop?: string | Array<string> | undefined;
  random_seed?: number | null | undefined;
  metadata?: { [k: string]: any } | null | undefined;
  messages: Array<
    | (SystemMessage$Outbound & { role: "system" })
    | (ToolMessage$Outbound & { role: "tool" })
    | (UserMessage$Outbound & { role: "user" })
    | (AssistantMessage$Outbound & { role: "assistant" })
  >;
  response_format?: ResponseFormat$Outbound | undefined;
  tools?: Array<Tool$Outbound> | null | undefined;
  tool_choice?: ToolChoice$Outbound | string | undefined;
  presence_penalty?: number | undefined;
  frequency_penalty?: number | undefined;
  n?: number | null | undefined;
  prediction?: Prediction$Outbound | undefined;
  parallel_tool_calls?: boolean | undefined;
  prompt_mode?: string | null | undefined;
  agent_id: string;
};

/** @internal */
export const AgentsCompletionRequest$outboundSchema: z.ZodType<
  AgentsCompletionRequest$Outbound,
  z.ZodTypeDef,
  AgentsCompletionRequest
> = z.object({
  maxTokens: z.nullable(z.number().int()).optional(),
  stream: z.boolean().default(false),
  stop: z.union([z.string(), z.array(z.string())]).optional(),
  randomSeed: z.nullable(z.number().int()).optional(),
  metadata: z.nullable(z.record(z.any())).optional(),
  messages: z.array(
    z.union([
      SystemMessage$outboundSchema.and(
        z.object({ role: z.literal("system") }).transform((v) => ({
          role: v.role,
        })),
      ),
      ToolMessage$outboundSchema.and(
        z.object({ role: z.literal("tool") }).transform((v) => ({
          role: v.role,
        })),
      ),
      UserMessage$outboundSchema.and(
        z.object({ role: z.literal("user") }).transform((v) => ({
          role: v.role,
        })),
      ),
      AssistantMessage$outboundSchema.and(
        z.object({ role: z.literal("assistant") }).transform((v) => ({
          role: v.role,
        })),
      ),
    ]),
  ),
  responseFormat: ResponseFormat$outboundSchema.optional(),
  tools: z.nullable(z.array(Tool$outboundSchema)).optional(),
  toolChoice: z.union([
    ToolChoice$outboundSchema,
    ToolChoiceEnum$outboundSchema,
  ]).optional(),
  presencePenalty: z.number().optional(),
  frequencyPenalty: z.number().optional(),
  n: z.nullable(z.number().int()).optional(),
  prediction: Prediction$outboundSchema.optional(),
  parallelToolCalls: z.boolean().optional(),
  promptMode: z.nullable(MistralPromptMode$outboundSchema).optional(),
  agentId: z.string(),
}).transform((v) => {
  return remap$(v, {
    maxTokens: "max_tokens",
    randomSeed: "random_seed",
    responseFormat: "response_format",
    toolChoice: "tool_choice",
    presencePenalty: "presence_penalty",
    frequencyPenalty: "frequency_penalty",
    parallelToolCalls: "parallel_tool_calls",
    promptMode: "prompt_mode",
    agentId: "agent_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AgentsCompletionRequest$ {
  /** @deprecated use `AgentsCompletionRequest$inboundSchema` instead. */
  export const inboundSchema = AgentsCompletionRequest$inboundSchema;
  /** @deprecated use `AgentsCompletionRequest$outboundSchema` instead. */
  export const outboundSchema = AgentsCompletionRequest$outboundSchema;
  /** @deprecated use `AgentsCompletionRequest$Outbound` instead. */
  export type Outbound = AgentsCompletionRequest$Outbound;
}

export function agentsCompletionRequestToJSON(
  agentsCompletionRequest: AgentsCompletionRequest,
): string {
  return JSON.stringify(
    AgentsCompletionRequest$outboundSchema.parse(agentsCompletionRequest),
  );
}

export function agentsCompletionRequestFromJSON(
  jsonString: string,
): SafeParseResult<AgentsCompletionRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentsCompletionRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentsCompletionRequest' from JSON`,
  );
}
