/* eslint-disable no-underscore-dangle */
/* eslint-disable no-param-reassign */
const { PassThrough } = require('stream');
const CosMultipartUploadBase = require('./CosMultipartUploadBase');
const { TrashWriteStream } = require('@annexwu-packages/simple-stream-utils');
const {
  MultipleWriteStream,
} = require('@annexwu-packages/multiple-stream-utils');
const { addCRC64TransformStream } = require('./common/utils');

class CosMultipartUploadExpectSizeStreamController extends CosMultipartUploadBase {
  /**
   * @param {Object} options
   * @param {Object} options.object
   * @param {String} options.object.Bucket
   * @param {String} options.object.Region
   * @param {String} options.object.Key
   * @param {Number} options.object.ContentLength
   * @param {String} options.uuid
   * @param {Number} options.chunkSize
   * @param {Boolean} options.hashCheck
   */
  async getStream({
    object: { Bucket, Region, Key, ContentLength, ...args },
    uuid = '',
    chunkSize,
    hashCheck,
  }) {
    chunkSize = chunkSize || this.getDefaultChunkSize(ContentLength);
    hashCheck = this.getHashCheck(hashCheck);
    uuid = `${Bucket}-${Region}-${Key}-${chunkSize}-${
      ContentLength || 'unknow'
    }-${uuid}`;
    const defaultCacheData = {
      object: {
        Bucket,
        Region,
        Key,
        ContentLength,
        ...args,
      },
      process: {},
      chunkSize,
      hashCheck,
    };
    this.cacheData[uuid] = this.cacheData[uuid] || defaultCacheData;
    try {
      await this.multipartInit({ uuid });
      await this.multipartListPart({ uuid });
      const multipleWriteStream = new MultipleWriteStream({
        getNextStream: async ({ partNumber = 0 } = {}) => {
          try {
            partNumber += 1;
            const { stream, streamSize } =              this.getMultipartUploadStream({ uuid, chunkSize, partNumber })
              || {};
            if (!stream) {
              const result = await this.multipartComplete({ uuid });
              setTimeout(() => multipleWriteStream.emit('success', result), 0);
              return;
            }
            return {
              stream,
              streamSize,
              nextParams: {
                partNumber,
              },
            };
          } catch (err) {
            if (err.code === 'NoSuchUpload') {
              delete this.cacheData[uuid];
            }
            throw err;
          }
        },
        nextStreamEvent: 'multipart-upload-callback',
      });
      multipleWriteStream._on = multipleWriteStream.on;
      multipleWriteStream.on = (event, ...args) => multipleWriteStream._on(
        event === 'finish' ? 'success' : event,
        ...args,
      );
      return multipleWriteStream;
    } catch (err) {
      if (err.code === 'NoSuchUpload') {
        delete this.cacheData[uuid];
      }
      throw err;
    }
  }
  /**
   * get part upload stream
   */
  getMultipartUploadStream({ uuid, chunkSize, partNumber }) {
    const { Bucket, Region, Key, ContentLength } = this.cacheData[uuid].object;
    const { UploadId } = this.cacheData[uuid].process;
    const { hashCheck } = this.cacheData[uuid];
    const streamSize =      chunkSize * partNumber <= ContentLength
      ? chunkSize
      : ContentLength - chunkSize * (partNumber - 1);

    if (streamSize <= 0) {
      return;
    }

    const stream = new PassThrough();

    if (this.checkPart({ uuid, partNumber })) {
      /**
       * if a part is uploaded, pipe data to trashWriteStream
       * when the trashWriteStream is ended, emit multipart-upload-callback event
       */
      stream.on('end', () => stream.emit('multipart-upload-callback'));
      stream.pipe(new TrashWriteStream());
    } else {
      let crc64Hash = '';
      let targetStream = stream;
      if (hashCheck) {
        targetStream = addCRC64TransformStream({
          stream,
          onHash: hash => (crc64Hash = hash),
        });
      }
      this.cosSdkInstance.multipartUpload(
        {
          Bucket,
          Region,
          Key,
          UploadId,
          PartNumber: partNumber,
          ContentLength: streamSize,
          Body: targetStream,
        },
        (err, data) => {
          if (err) {
            if (err.code === 'NoSuchUpload') {
              delete this.cacheData[uuid];
            }
            stream.emit('error', err);
            return;
          }
          if (hashCheck && crc64Hash !== data.headers['x-cos-hash-crc64ecma']) {
            this.updateParts({ uuid, partNumber, etag: '' });
            stream.emit('multipart-upload-callback', {
              crc64Hash,
              headers: data.headers,
            });
          } else {
            this.updateParts({ uuid, partNumber, etag: data.ETag });
            stream.emit('multipart-upload-callback', null, data);
          }
        },
      );
    }
    return {
      stream,
      streamSize,
    };
  }
}

module.exports = CosMultipartUploadExpectSizeStreamController;
