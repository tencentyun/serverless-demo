// src/index.ts
import {
  AbstractAgent,
  EventType
} from "@ag-ui/client";
import {
  streamText,
  tool as createVercelAISDKTool,
  stepCountIs
} from "ai";
import { experimental_createMCPClient as createMCPClient } from "@ai-sdk/mcp";
import { Observable } from "rxjs";
import { createOpenAI } from "@ai-sdk/openai";
import { createAnthropic } from "@ai-sdk/anthropic";
import { createGoogleGenerativeAI } from "@ai-sdk/google";
import { randomUUID } from "crypto";
import { z } from "zod";
import {
  StreamableHTTPClientTransport
} from "@modelcontextprotocol/sdk/client/streamableHttp.js";
import { SSEClientTransport } from "@modelcontextprotocol/sdk/client/sse.js";
function resolveModel(spec, apiKey) {
  if (typeof spec !== "string") {
    return spec;
  }
  const normalized = spec.replace("/", ":").trim();
  const parts = normalized.split(":");
  const rawProvider = parts[0];
  const rest = parts.slice(1);
  if (!rawProvider) {
    throw new Error(
      `Invalid model string "${spec}". Use "openai/gpt-5", "anthropic/claude-sonnet-4.5", or "google/gemini-2.5-pro".`
    );
  }
  const provider = rawProvider.toLowerCase();
  const model = rest.join(":").trim();
  if (!model) {
    throw new Error(
      `Invalid model string "${spec}". Use "openai/gpt-5", "anthropic/claude-sonnet-4.5", or "google/gemini-2.5-pro".`
    );
  }
  switch (provider) {
    case "openai": {
      const openai = createOpenAI({
        apiKey: apiKey || process.env.OPENAI_API_KEY
      });
      return openai(model);
    }
    case "anthropic": {
      const anthropic = createAnthropic({
        apiKey: apiKey || process.env.ANTHROPIC_API_KEY
      });
      return anthropic(model);
    }
    case "google":
    case "gemini":
    case "google-gemini": {
      const google = createGoogleGenerativeAI({
        apiKey: apiKey || process.env.GOOGLE_API_KEY
      });
      return google(model);
    }
    default:
      throw new Error(`Unknown provider "${provider}" in "${spec}". Supported: openai, anthropic, google (gemini).`);
  }
}
function defineTool(config) {
  return {
    name: config.name,
    description: config.description,
    parameters: config.parameters,
    execute: config.execute
  };
}
function flattenUserMessageContent(content) {
  if (!content) {
    return "";
  }
  if (typeof content === "string") {
    return content;
  }
  return content.map((part) => {
    if (part && typeof part === "object" && "type" in part && part.type === "text" && typeof part.text === "string") {
      return part.text;
    }
    return "";
  }).filter((text) => text.length > 0).join("\n");
}
function convertMessagesToVercelAISDKMessages(messages, options = {}) {
  const result = [];
  for (const message of messages) {
    if (message.role === "system" && options.forwardSystemMessages) {
      const systemMsg = {
        role: "system",
        content: message.content ?? ""
      };
      result.push(systemMsg);
    } else if (message.role === "developer" && options.forwardDeveloperMessages) {
      const systemMsg = {
        role: "system",
        content: message.content ?? ""
      };
      result.push(systemMsg);
    } else if (message.role === "assistant") {
      const parts = message.content ? [{ type: "text", text: message.content }] : [];
      for (const toolCall of message.toolCalls ?? []) {
        const toolCallPart = {
          type: "tool-call",
          toolCallId: toolCall.id,
          toolName: toolCall.function.name,
          input: JSON.parse(toolCall.function.arguments)
        };
        parts.push(toolCallPart);
      }
      const assistantMsg = {
        role: "assistant",
        content: parts
      };
      result.push(assistantMsg);
    } else if (message.role === "user") {
      const userMsg = {
        role: "user",
        content: flattenUserMessageContent(message.content)
      };
      result.push(userMsg);
    } else if (message.role === "tool") {
      let toolName = "unknown";
      for (const msg of messages) {
        if (msg.role === "assistant") {
          for (const toolCall of msg.toolCalls ?? []) {
            if (toolCall.id === message.toolCallId) {
              toolName = toolCall.function.name;
              break;
            }
          }
        }
      }
      const toolResultPart = {
        type: "tool-result",
        toolCallId: message.toolCallId,
        toolName,
        output: {
          type: "text",
          value: message.content
        }
      };
      const toolMsg = {
        role: "tool",
        content: [toolResultPart]
      };
      result.push(toolMsg);
    }
  }
  return result;
}
function convertJsonSchemaToZodSchema(jsonSchema, required) {
  if (!jsonSchema.type) {
    return required ? z.object({}) : z.object({}).optional();
  }
  if (jsonSchema.type === "object") {
    const spec = {};
    if (!jsonSchema.properties || !Object.keys(jsonSchema.properties).length) {
      return !required ? z.object(spec).optional() : z.object(spec);
    }
    for (const [key, value] of Object.entries(jsonSchema.properties)) {
      spec[key] = convertJsonSchemaToZodSchema(value, jsonSchema.required ? jsonSchema.required.includes(key) : false);
    }
    let schema = z.object(spec).describe(jsonSchema.description ?? "");
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "string") {
    let schema = z.string().describe(jsonSchema.description ?? "");
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "number" || jsonSchema.type === "integer") {
    let schema = z.number().describe(jsonSchema.description ?? "");
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "boolean") {
    let schema = z.boolean().describe(jsonSchema.description ?? "");
    return required ? schema : schema.optional();
  } else if (jsonSchema.type === "array") {
    if (!jsonSchema.items) {
      throw new Error("Array type must have items property");
    }
    let itemSchema = convertJsonSchemaToZodSchema(jsonSchema.items, true);
    let schema = z.array(itemSchema).describe(jsonSchema.description ?? "");
    return required ? schema : schema.optional();
  }
  console.error("Invalid JSON schema:", JSON.stringify(jsonSchema, null, 2));
  throw new Error("Invalid JSON schema");
}
function isJsonSchema(obj) {
  if (typeof obj !== "object" || obj === null) return false;
  const schema = obj;
  if (Object.keys(schema).length === 0) return true;
  return typeof schema.type === "string" && ["object", "string", "number", "integer", "boolean", "array"].includes(schema.type);
}
function convertToolsToVercelAITools(tools) {
  const result = {};
  for (const tool of tools) {
    if (!isJsonSchema(tool.parameters)) {
      throw new Error(`Invalid JSON schema for tool ${tool.name}`);
    }
    const zodSchema = convertJsonSchemaToZodSchema(tool.parameters, true);
    result[tool.name] = createVercelAISDKTool({
      description: tool.description,
      inputSchema: zodSchema
    });
  }
  return result;
}
function convertToolDefinitionsToVercelAITools(tools) {
  const result = {};
  for (const tool of tools) {
    result[tool.name] = createVercelAISDKTool({
      description: tool.description,
      inputSchema: tool.parameters,
      execute: tool.execute
    });
  }
  return result;
}
var BuiltInAgent = class _BuiltInAgent extends AbstractAgent {
  constructor(config) {
    super();
    this.config = config;
  }
  abortController;
  /**
   * Check if a property can be overridden by forwardedProps
   */
  canOverride(property) {
    return this.config?.overridableProperties?.includes(property) ?? false;
  }
  run(input) {
    return new Observable((subscriber) => {
      const startEvent = {
        type: EventType.RUN_STARTED,
        threadId: input.threadId,
        runId: input.runId
      };
      subscriber.next(startEvent);
      const model = resolveModel(this.config.model, this.config.apiKey);
      let systemPrompt = void 0;
      const hasPrompt = !!this.config.prompt;
      const hasContext = input.context && input.context.length > 0;
      const hasState = input.state !== void 0 && input.state !== null && !(typeof input.state === "object" && Object.keys(input.state).length === 0);
      if (hasPrompt || hasContext || hasState) {
        const parts = [];
        if (hasPrompt) {
          parts.push(this.config.prompt);
        }
        if (hasContext) {
          parts.push("\n## Context from the application\n");
          for (const ctx of input.context) {
            parts.push(`${ctx.description}:
${ctx.value}
`);
          }
        }
        if (hasState) {
          parts.push(
            `
## Application State
This is state from the application that you can edit by calling AGUISendStateSnapshot or AGUISendStateDelta.
\`\`\`json
${JSON.stringify(input.state, null, 2)}
\`\`\`
`
          );
        }
        systemPrompt = parts.join("");
      }
      const messages = convertMessagesToVercelAISDKMessages(input.messages, {
        forwardSystemMessages: this.config.forwardSystemMessages,
        forwardDeveloperMessages: this.config.forwardDeveloperMessages
      });
      if (systemPrompt) {
        messages.unshift({
          role: "system",
          content: systemPrompt
        });
      }
      let allTools = convertToolsToVercelAITools(input.tools);
      if (this.config.tools && this.config.tools.length > 0) {
        const configTools = convertToolDefinitionsToVercelAITools(this.config.tools);
        allTools = { ...allTools, ...configTools };
      }
      const streamTextParams = {
        model,
        messages,
        tools: allTools,
        toolChoice: this.config.toolChoice,
        stopWhen: this.config.maxSteps ? stepCountIs(this.config.maxSteps) : void 0,
        maxOutputTokens: this.config.maxOutputTokens,
        temperature: this.config.temperature,
        topP: this.config.topP,
        topK: this.config.topK,
        presencePenalty: this.config.presencePenalty,
        frequencyPenalty: this.config.frequencyPenalty,
        stopSequences: this.config.stopSequences,
        seed: this.config.seed,
        maxRetries: this.config.maxRetries
      };
      if (input.forwardedProps && typeof input.forwardedProps === "object") {
        const props = input.forwardedProps;
        if (props.model !== void 0 && this.canOverride("model")) {
          if (typeof props.model === "string" || typeof props.model === "object") {
            streamTextParams.model = resolveModel(props.model, this.config.apiKey);
          }
        }
        if (props.toolChoice !== void 0 && this.canOverride("toolChoice")) {
          const toolChoice = props.toolChoice;
          if (toolChoice === "auto" || toolChoice === "required" || toolChoice === "none" || typeof toolChoice === "object" && toolChoice !== null && "type" in toolChoice && toolChoice.type === "tool") {
            streamTextParams.toolChoice = toolChoice;
          }
        }
        if (typeof props.maxOutputTokens === "number" && this.canOverride("maxOutputTokens")) {
          streamTextParams.maxOutputTokens = props.maxOutputTokens;
        }
        if (typeof props.temperature === "number" && this.canOverride("temperature")) {
          streamTextParams.temperature = props.temperature;
        }
        if (typeof props.topP === "number" && this.canOverride("topP")) {
          streamTextParams.topP = props.topP;
        }
        if (typeof props.topK === "number" && this.canOverride("topK")) {
          streamTextParams.topK = props.topK;
        }
        if (typeof props.presencePenalty === "number" && this.canOverride("presencePenalty")) {
          streamTextParams.presencePenalty = props.presencePenalty;
        }
        if (typeof props.frequencyPenalty === "number" && this.canOverride("frequencyPenalty")) {
          streamTextParams.frequencyPenalty = props.frequencyPenalty;
        }
        if (Array.isArray(props.stopSequences) && this.canOverride("stopSequences")) {
          if (props.stopSequences.every((item) => typeof item === "string")) {
            streamTextParams.stopSequences = props.stopSequences;
          }
        }
        if (typeof props.seed === "number" && this.canOverride("seed")) {
          streamTextParams.seed = props.seed;
        }
        if (typeof props.maxRetries === "number" && this.canOverride("maxRetries")) {
          streamTextParams.maxRetries = props.maxRetries;
        }
      }
      const mcpClients = [];
      (async () => {
        const abortController = new AbortController();
        this.abortController = abortController;
        let terminalEventEmitted = false;
        try {
          streamTextParams.tools = {
            ...streamTextParams.tools,
            AGUISendStateSnapshot: createVercelAISDKTool({
              description: "Replace the entire application state with a new snapshot",
              inputSchema: z.object({
                snapshot: z.any().describe("The complete new state object")
              }),
              execute: async ({ snapshot }) => {
                return { success: true, snapshot };
              }
            }),
            AGUISendStateDelta: createVercelAISDKTool({
              description: "Apply incremental updates to application state using JSON Patch operations",
              inputSchema: z.object({
                delta: z.array(
                  z.object({
                    op: z.enum(["add", "replace", "remove"]).describe("The operation to perform"),
                    path: z.string().describe("JSON Pointer path (e.g., '/foo/bar')"),
                    value: z.any().optional().describe(
                      "The value to set. Required for 'add' and 'replace' operations, ignored for 'remove'."
                    )
                  })
                ).describe("Array of JSON Patch operations")
              }),
              execute: async ({ delta }) => {
                return { success: true, delta };
              }
            })
          };
          if (this.config.mcpServers && this.config.mcpServers.length > 0) {
            for (const serverConfig of this.config.mcpServers) {
              let transport;
              if (serverConfig.type === "http") {
                const url = new URL(serverConfig.url);
                transport = new StreamableHTTPClientTransport(url, serverConfig.options);
              } else if (serverConfig.type === "sse") {
                transport = new SSEClientTransport(new URL(serverConfig.url), serverConfig.headers);
              }
              if (transport) {
                const mcpClient = await createMCPClient({ transport });
                mcpClients.push(mcpClient);
                const mcpTools = await mcpClient.tools();
                streamTextParams.tools = { ...streamTextParams.tools, ...mcpTools };
              }
            }
          }
          const response = streamText({ ...streamTextParams, abortSignal: abortController.signal });
          let messageId = randomUUID();
          const toolCallStates = /* @__PURE__ */ new Map();
          const ensureToolCallState = (toolCallId) => {
            let state = toolCallStates.get(toolCallId);
            if (!state) {
              state = { started: false, hasArgsDelta: false, ended: false };
              toolCallStates.set(toolCallId, state);
            }
            return state;
          };
          for await (const part of response.fullStream) {
            switch (part.type) {
              case "abort":
                const abortEndEvent = {
                  type: EventType.RUN_FINISHED,
                  threadId: input.threadId,
                  runId: input.runId
                };
                subscriber.next(abortEndEvent);
                terminalEventEmitted = true;
                subscriber.complete();
                break;
              case "tool-input-start": {
                const toolCallId = part.id;
                const state = ensureToolCallState(toolCallId);
                state.toolName = part.toolName;
                if (!state.started) {
                  state.started = true;
                  const startEvent2 = {
                    type: EventType.TOOL_CALL_START,
                    parentMessageId: messageId,
                    toolCallId,
                    toolCallName: part.toolName
                  };
                  subscriber.next(startEvent2);
                }
                break;
              }
              case "tool-input-delta": {
                const toolCallId = part.id;
                const state = ensureToolCallState(toolCallId);
                state.hasArgsDelta = true;
                const argsEvent = {
                  type: EventType.TOOL_CALL_ARGS,
                  toolCallId,
                  delta: part.delta
                };
                subscriber.next(argsEvent);
                break;
              }
              case "tool-input-end": {
                break;
              }
              case "text-start": {
                const providedId = "id" in part ? part.id : void 0;
                messageId = providedId && providedId !== "0" ? providedId : randomUUID();
                break;
              }
              case "text-delta": {
                const textDelta = "text" in part ? part.text : "";
                const textEvent = {
                  type: EventType.TEXT_MESSAGE_CHUNK,
                  role: "assistant",
                  messageId,
                  delta: textDelta
                };
                subscriber.next(textEvent);
                break;
              }
              case "tool-call": {
                const toolCallId = part.toolCallId;
                const state = ensureToolCallState(toolCallId);
                state.toolName = part.toolName ?? state.toolName;
                if (!state.started) {
                  state.started = true;
                  const startEvent2 = {
                    type: EventType.TOOL_CALL_START,
                    parentMessageId: messageId,
                    toolCallId,
                    toolCallName: part.toolName
                  };
                  subscriber.next(startEvent2);
                }
                if (!state.hasArgsDelta && "input" in part && part.input !== void 0) {
                  let serializedInput = "";
                  if (typeof part.input === "string") {
                    serializedInput = part.input;
                  } else {
                    try {
                      serializedInput = JSON.stringify(part.input);
                    } catch {
                      serializedInput = String(part.input);
                    }
                  }
                  if (serializedInput.length > 0) {
                    const argsEvent = {
                      type: EventType.TOOL_CALL_ARGS,
                      toolCallId,
                      delta: serializedInput
                    };
                    subscriber.next(argsEvent);
                    state.hasArgsDelta = true;
                  }
                }
                if (!state.ended) {
                  state.ended = true;
                  const endEvent = {
                    type: EventType.TOOL_CALL_END,
                    toolCallId
                  };
                  subscriber.next(endEvent);
                }
                break;
              }
              case "tool-result": {
                const toolResult = "output" in part ? part.output : null;
                const toolName = "toolName" in part ? part.toolName : "";
                toolCallStates.delete(part.toolCallId);
                if (toolName === "AGUISendStateSnapshot" && toolResult && typeof toolResult === "object") {
                  const stateSnapshotEvent = {
                    type: EventType.STATE_SNAPSHOT,
                    snapshot: toolResult.snapshot
                  };
                  subscriber.next(stateSnapshotEvent);
                } else if (toolName === "AGUISendStateDelta" && toolResult && typeof toolResult === "object") {
                  const stateDeltaEvent = {
                    type: EventType.STATE_DELTA,
                    delta: toolResult.delta
                  };
                  subscriber.next(stateDeltaEvent);
                }
                const resultEvent = {
                  type: EventType.TOOL_CALL_RESULT,
                  role: "tool",
                  messageId: randomUUID(),
                  toolCallId: part.toolCallId,
                  content: JSON.stringify(toolResult)
                };
                subscriber.next(resultEvent);
                break;
              }
              case "finish":
                const finishedEvent = {
                  type: EventType.RUN_FINISHED,
                  threadId: input.threadId,
                  runId: input.runId
                };
                subscriber.next(finishedEvent);
                terminalEventEmitted = true;
                subscriber.complete();
                break;
              case "error": {
                if (abortController.signal.aborted) {
                  break;
                }
                const runErrorEvent = {
                  type: EventType.RUN_ERROR,
                  message: part.error + ""
                };
                subscriber.next(runErrorEvent);
                terminalEventEmitted = true;
                subscriber.error(part.error);
                break;
              }
            }
          }
          if (!terminalEventEmitted) {
            if (abortController.signal.aborted) {
            } else {
              const finishedEvent = {
                type: EventType.RUN_FINISHED,
                threadId: input.threadId,
                runId: input.runId
              };
              subscriber.next(finishedEvent);
            }
            terminalEventEmitted = true;
            subscriber.complete();
          }
        } catch (error) {
          if (abortController.signal.aborted) {
            subscriber.complete();
          } else {
            const runErrorEvent = {
              type: EventType.RUN_ERROR,
              message: error + ""
            };
            subscriber.next(runErrorEvent);
            terminalEventEmitted = true;
            subscriber.error(error);
          }
        } finally {
          this.abortController = void 0;
          await Promise.all(mcpClients.map((client) => client.close()));
        }
      })();
      return () => {
        Promise.all(mcpClients.map((client) => client.close())).catch(() => {
        });
      };
    });
  }
  clone() {
    const cloned = new _BuiltInAgent(this.config);
    cloned.middlewares = [...this.middlewares];
    return cloned;
  }
  abortRun() {
    this.abortController?.abort();
  }
};
var BasicAgent = class extends BuiltInAgent {
  constructor(config) {
    super(config);
    console.warn("BasicAgent is deprecated, use BuiltInAgent instead");
  }
};
export {
  BasicAgent,
  BuiltInAgent,
  convertJsonSchemaToZodSchema,
  convertMessagesToVercelAISDKMessages,
  convertToolDefinitionsToVercelAITools,
  convertToolsToVercelAITools,
  defineTool,
  resolveModel
};
//# sourceMappingURL=index.mjs.map