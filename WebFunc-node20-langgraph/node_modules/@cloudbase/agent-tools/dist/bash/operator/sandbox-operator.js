"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxBashOperator = void 0;
const base_operator_1 = require("./base-operator");
const utils_1 = require("../../utils");
class SandboxBashOperator extends base_operator_1.BaseBashOperator {
    constructor(options) {
        super();
        this.sandbox = options.sandbox;
        this.currentWorkingDirectory = options.cwd || "/home/user";
        this.environmentVariables = options.env || {};
    }
    async executeCommand(command, options = {}) {
        const startTime = Date.now();
        let commandHandler = null;
        try {
            // Prepare environment variables
            const env = {
                ...this.environmentVariables,
                ...options.env,
            };
            // Build the full command with environment and working directory
            let fullCommand = command;
            // Set working directory if different from current
            const targetCwd = options.cwd || this.currentWorkingDirectory;
            if (targetCwd !== "/home/user") {
                fullCommand = `cd "${targetCwd}" && ${command}`;
            }
            // Wait for the process to complete
            commandHandler = await this.sandbox.commands.run(fullCommand, {
                envs: env,
                cwd: targetCwd,
                background: true,
                onStdout: (data) => {
                    options.onStdout?.(data);
                },
                onStderr: (data) => {
                    options.onStderr?.(data);
                },
            });
            const executionTime = Date.now() - startTime;
            // Handle input if provided
            if (options.input) {
                await this.sandbox.commands.sendStdin(commandHandler.pid, options.input);
            }
            const commandResult = await commandHandler.wait();
            const { exitCode, stderr, stdout } = commandResult;
            return {
                success: exitCode === 0,
                exitCode: exitCode,
                stdout: (0, utils_1.stripAnsi)(stdout).trim(),
                stderr: (0, utils_1.stripAnsi)(stderr).trim(),
                executionTime,
            };
        }
        catch (error) {
            const executionTime = Date.now() - startTime;
            if (commandHandler) {
                await this.sandbox.commands.kill(commandHandler.pid).catch((error) => {
                    return false;
                });
            }
            let result = {
                success: false,
                exitCode: null,
                stdout: "",
                stderr: (0, utils_1.stripAnsi)(error instanceof Error ? error.message : String(error)),
                executionTime,
            };
            if (error?.result) {
                result = {
                    ...result,
                    exitCode: error.result.exitCode,
                    stdout: (0, utils_1.stripAnsi)(error.result.stdout),
                    stderr: (0, utils_1.stripAnsi)(error.result.stderr),
                };
            }
            return result;
        }
    }
    async getCurrentDirectory() {
        const result = await this.executeCommand("pwd");
        if (result.success) {
            this.currentWorkingDirectory = result.stdout.trim();
            return this.currentWorkingDirectory;
        }
        return this.currentWorkingDirectory;
    }
    async getEnvironmentVariables() {
        return { ...this.environmentVariables };
    }
    async setEnvironmentVariable(key, value) {
        this.environmentVariables[key] = value;
    }
    /**
     * Get sandbox instance for advanced operations
     */
    getSandbox() {
        return this.sandbox;
    }
}
exports.SandboxBashOperator = SandboxBashOperator;
//# sourceMappingURL=sandbox-operator.js.map