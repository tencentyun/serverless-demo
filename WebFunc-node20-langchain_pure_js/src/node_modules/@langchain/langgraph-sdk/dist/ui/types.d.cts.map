{"version":3,"file":"types.d.cts","names":["InferInteropZodInput","Client","ClientConfig","ThreadState","Config","Checkpoint","Metadata","Command","MultitaskStrategy","OnCompletionBehavior","DisconnectMode","Durability","UpdatesStreamEvent","CustomStreamEvent","MetadataStreamEvent","EventsStreamEvent","DebugStreamEvent","CheckpointsStreamEvent","TasksStreamEvent","StreamMode","DefaultToolCall","AIMessage","Message","BagTemplate","AgentTypeConfigLike","IsAgentLike","T","ExtractAgentConfig","AgentMiddlewareLike","TSchema","TContextSchema","TFullContext","TTools","InferMiddlewareState","Record","S","IsAny","InferMiddlewareStatesFromArray","First","Rest","U","BaseAgentState","ToolCall","InferAgentState","InferAgentToolCalls","RunOutput","InferToolInput","Args","ToolCallFromAgentTool","N","Tool","ExtractToolCallFromMessageUnion","M","TC","ExtractToolCallsFromState","StateType","Messages","MessageMetadata","GetUpdateType","Bag","Partial","GetConfigurableType","GetInterruptType","GetCustomEventType","GetToolCallsType","RunCallbackMeta","UseStreamThread","Promise","UseStreamOptions","RunMetadataStorage","ConfigWithConfigurable","ConfigurableType","SubmitOptions","ContextType","Omit","Array","UseStreamTransport","AbortSignal","AsyncGenerator","UseStreamCustomOptions","Pick","CustomSubmitOptions"],"sources":["../../src/ui/types.d.ts"],"sourcesContent":["import type { InferInteropZodInput } from \"@langchain/core/utils/types\";\nimport type { Client, ClientConfig } from \"../client.js\";\nimport type { ThreadState, Config, Checkpoint, Metadata } from \"../schema.js\";\nimport type { Command, MultitaskStrategy, OnCompletionBehavior, DisconnectMode, Durability } from \"../types.js\";\nimport type { UpdatesStreamEvent, CustomStreamEvent, MetadataStreamEvent, EventsStreamEvent, DebugStreamEvent, CheckpointsStreamEvent, TasksStreamEvent, StreamMode } from \"../types.stream.js\";\nimport type { DefaultToolCall, AIMessage, Message } from \"../types.messages.js\";\nimport type { BagTemplate } from \"../types.template.js\";\n/**\n * Minimal interface matching the structure of AgentTypeConfig from @langchain/langgraph.\n * This allows type inference from ReactAgent without requiring the langchain dependency.\n */\nexport interface AgentTypeConfigLike {\n    Response: unknown;\n    State: unknown;\n    Context: unknown;\n    Middleware: unknown;\n    Tools: unknown;\n}\n/**\n * Check if a type is agent-like (has `~agentTypes` phantom property).\n * This property is present on `ReactAgent` instances created with `createAgent`.\n */\nexport type IsAgentLike<T> = T extends {\n    \"~agentTypes\": AgentTypeConfigLike;\n} ? true : false;\n/**\n * Extract the AgentTypeConfig from an agent-like type.\n *\n * @example\n * ```ts\n * const agent = createAgent({ ... });\n * type Config = ExtractAgentConfig<typeof agent>;\n * // Config is the AgentTypeConfig with Response, State, Context, Middleware, Tools\n * ```\n */\nexport type ExtractAgentConfig<T> = T extends {\n    \"~agentTypes\": infer Config;\n} ? Config extends AgentTypeConfigLike ? Config : never : never;\n/**\n * Minimal interface to structurally match AgentMiddleware from langchain.\n * We can't import AgentMiddleware due to circular dependencies, so we match\n * against its structure to extract type information.\n */\nexport interface AgentMiddlewareLike<TSchema = unknown, TContextSchema = unknown, TFullContext = unknown, TTools = unknown> {\n    name: string;\n    stateSchema?: TSchema;\n    \"~middlewareTypes\"?: {\n        Schema: TSchema;\n        ContextSchema: TContextSchema;\n        FullContext: TFullContext;\n        Tools: TTools;\n    };\n}\n/**\n * Helper type to extract state from a single middleware instance.\n * Uses structural matching against AgentMiddleware to extract the state schema\n * type parameter, similar to how langchain's InferMiddlewareState works.\n */\ntype InferMiddlewareState<T> = T extends AgentMiddlewareLike<infer TSchema, unknown, unknown, unknown> ? TSchema extends Record<string, any> ? InferInteropZodInput<TSchema> : {} : T extends {\n    stateSchema: infer S;\n} ? InferInteropZodInput<S> : {};\n/**\n * Helper type to detect if a type is `any`.\n * Uses the fact that `any` is both a subtype and supertype of all types.\n */\ntype IsAny<T> = 0 extends 1 & T ? true : false;\n/**\n * Helper type to extract and merge states from an array of middleware.\n * Recursively processes each middleware and intersects their state types.\n *\n * Handles both readonly and mutable arrays/tuples explicitly.\n *\n * @example\n * ```ts\n * type States = InferMiddlewareStatesFromArray<typeof middlewareArray>;\n * // Returns intersection of all middleware state types\n * ```\n */\nexport type InferMiddlewareStatesFromArray<T> = IsAny<T> extends true ? {} : T extends undefined | null ? {} : T extends readonly [] ? {} : T extends [] ? {} : T extends readonly [infer First, ...infer Rest extends readonly unknown[]] ? InferMiddlewareState<First> & InferMiddlewareStatesFromArray<Rest> : T extends [infer First, ...infer Rest extends unknown[]] ? InferMiddlewareState<First> & InferMiddlewareStatesFromArray<Rest> : T extends readonly (infer U)[] ? InferMiddlewareState<U> : T extends (infer U)[] ? InferMiddlewareState<U> : {};\n/**\n * Infer the complete merged state from an agent, including:\n * - The agent's own state schema (via State)\n * - All middleware states (via Middleware)\n *\n * This is the SDK equivalent of langchain's `InferAgentState` type.\n *\n * @example\n * ```ts\n * const agent = createAgent({\n *   middleware: [todoListMiddleware()],\n *   // ...\n * });\n *\n * type State = InferAgentState<typeof agent>;\n * // State includes { todos: Todo[], ... }\n * ```\n */\n/**\n * Base agent state that all agents have by default.\n * This includes the messages array which is fundamental to agent operation.\n * The ToolCall type parameter allows proper typing of tool calls in messages.\n */\ntype BaseAgentState<ToolCall = DefaultToolCall> = {\n    messages: Message<ToolCall>[];\n};\nexport type InferAgentState<T> = T extends {\n    \"~agentTypes\": unknown;\n} ? ExtractAgentConfig<T> extends never ? {} : BaseAgentState<InferAgentToolCalls<T>> & (ExtractAgentConfig<T>[\"State\"] extends undefined ? {} : InferInteropZodInput<ExtractAgentConfig<T>[\"State\"]>) & InferMiddlewareStatesFromArray<ExtractAgentConfig<T>[\"Middleware\"]> : T extends {\n    \"~RunOutput\": infer RunOutput;\n} ? RunOutput : T extends {\n    messages: unknown;\n} ? T : {};\n/**\n * Helper type to extract the input type from a DynamicStructuredTool's _call method.\n * This is more reliable than trying to infer from the schema directly because\n * DynamicStructuredTool has the input type baked into its _call signature.\n */\ntype InferToolInput<T> = T extends {\n    _call: (arg: infer Args, ...rest: any[]) => any;\n} ? Args : T extends {\n    schema: infer S;\n} ? InferInteropZodInput<S> : never;\n/**\n * Extract a tool call type from a single tool.\n * Works with tools created via `tool()` from `@langchain/core/tools`.\n *\n * This extracts the literal name type from DynamicStructuredTool's NameT parameter\n * and the args type from the _call method or schema's input property.\n */\ntype ToolCallFromAgentTool<T> = T extends {\n    name: infer N;\n} ? N extends string ? InferToolInput<T> extends infer Args ? Args extends never ? never : Args extends Record<string, any> ? {\n    name: N;\n    args: Args;\n    id?: string;\n    type?: \"tool_call\";\n} : never : never : never : never;\n/**\n * Extract tool calls type from an agent's tools.\n * Converts the tools array to a discriminated union of tool calls.\n *\n * This handles both tuple types (e.g., `readonly [Tool1, Tool2]`) and\n * array-of-union types (e.g., `readonly (Tool1 | Tool2)[]`) which is how\n * `createAgent` captures tool types.\n *\n * @example\n * ```ts\n * const agent = createAgent({ tools: [getWeather, search], ... });\n * type ToolCalls = InferAgentToolCalls<typeof agent>;\n * // ToolCalls is:\n * // | { name: \"get_weather\"; args: { location: string }; id?: string }\n * // | { name: \"search\"; args: { query: string }; id?: string }\n * ```\n */\nexport type InferAgentToolCalls<T> = ExtractAgentConfig<T>[\"Tools\"] extends readonly (infer Tool)[] ? ToolCallFromAgentTool<Tool> extends never ? DefaultToolCall : ToolCallFromAgentTool<Tool> : DefaultToolCall;\n/**\n * Extract the tool call type parameter from an AIMessage in a message union.\n * Returns `never` if the message is not an AIMessage or uses DefaultToolCall.\n *\n * The key distinction: custom tool calls have literal `name` types (e.g., \"get_weather\"),\n * while DefaultToolCall has `name: string`. We check if `string extends TC[\"name\"]` -\n * if true, it's DefaultToolCall; if false, it's a custom type with literal names.\n */\ntype ExtractToolCallFromMessageUnion<M> = M extends AIMessage<infer TC> ? TC extends {\n    name: infer N;\n} ? string extends N ? never : TC : never : never;\n/**\n * Extract the tool call type from a StateType's messages property.\n * This is the primary way to specify tool call types when using useStream.\n *\n * @example\n * ```ts\n * // Define state with typed messages\n * type MyToolCalls =\n *   | { name: \"get_weather\"; args: { location: string }; id?: string }\n *   | { name: \"search\"; args: { query: string }; id?: string };\n *\n * interface MyState {\n *   messages: Message<MyToolCalls>[];\n * }\n *\n * // ExtractToolCallsFromState<MyState> = MyToolCalls\n * ```\n */\nexport type ExtractToolCallsFromState<StateType extends Record<string, unknown>> = StateType extends {\n    messages: infer Messages;\n} ? Messages extends readonly (infer M)[] ? ExtractToolCallFromMessageUnion<M> : Messages extends (infer M)[] ? ExtractToolCallFromMessageUnion<M> : never : never;\nexport type MessageMetadata<StateType extends Record<string, unknown>> = {\n    /**\n     * The ID of the message used.\n     */\n    messageId: string;\n    /**\n     * The first thread state the message was seen in.\n     */\n    firstSeenState: ThreadState<StateType> | undefined;\n    /**\n     * The branch of the message.\n     */\n    branch: string | undefined;\n    /**\n     * The list of branches this message is part of.\n     * This is useful for displaying branching controls.\n     */\n    branchOptions: string[] | undefined;\n    /**\n     * Metadata sent alongside the message during run streaming.\n     * @remarks This metadata only exists temporarily in browser memory during streaming and is not persisted after completion.\n     */\n    streamMetadata: Record<string, unknown> | undefined;\n};\nexport type GetUpdateType<Bag extends BagTemplate, StateType extends Record<string, unknown>> = Bag extends {\n    UpdateType: unknown;\n} ? Bag[\"UpdateType\"] : Partial<StateType>;\nexport type GetConfigurableType<Bag extends BagTemplate> = Bag extends {\n    ConfigurableType: Record<string, unknown>;\n} ? Bag[\"ConfigurableType\"] : Record<string, unknown>;\nexport type GetInterruptType<Bag extends BagTemplate> = Bag extends {\n    InterruptType: unknown;\n} ? Bag[\"InterruptType\"] : unknown;\nexport type GetCustomEventType<Bag extends BagTemplate> = Bag extends {\n    CustomEventType: unknown;\n} ? Bag[\"CustomEventType\"] : unknown;\n/**\n * Extract the tool call type from a StateType's messages property.\n * This is the canonical way to get typed tool calls in useStream.\n *\n * Tool call types are now extracted from the messages property of StateType,\n * rather than being specified separately in the Bag.\n *\n * @example\n * ```ts\n * // Define state with typed messages\n * type MyToolCalls =\n *   | { name: \"get_weather\"; args: { location: string }; id?: string }\n *   | { name: \"search\"; args: { query: string }; id?: string };\n *\n * interface MyState {\n *   messages: Message<MyToolCalls>[];\n * }\n *\n * // GetToolCallsType<MyState> = MyToolCalls\n * ```\n */\nexport type GetToolCallsType<StateType extends Record<string, unknown>> = ExtractToolCallsFromState<StateType> extends never ? DefaultToolCall : ExtractToolCallsFromState<StateType>;\nexport interface RunCallbackMeta {\n    run_id: string;\n    thread_id: string;\n}\nexport interface UseStreamThread<StateType extends Record<string, unknown>> {\n    data: ThreadState<StateType>[] | null | undefined;\n    error: unknown;\n    isLoading: boolean;\n    mutate: (mutateId?: string) => Promise<ThreadState<StateType>[] | null | undefined>;\n}\nexport interface UseStreamOptions<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> {\n    /**\n     * The ID of the assistant to use.\n     */\n    assistantId: string;\n    /**\n     * Client used to send requests.\n     */\n    client?: Client;\n    /**\n     * The URL of the API to use.\n     */\n    apiUrl?: ClientConfig[\"apiUrl\"];\n    /**\n     * The API key to use.\n     */\n    apiKey?: ClientConfig[\"apiKey\"];\n    /**\n     * Custom call options, such as custom fetch implementation.\n     */\n    callerOptions?: ClientConfig[\"callerOptions\"];\n    /**\n     * Default headers to send with requests.\n     */\n    defaultHeaders?: ClientConfig[\"defaultHeaders\"];\n    /**\n     * Specify the key within the state that contains messages.\n     * Defaults to \"messages\".\n     *\n     * @default \"messages\"\n     */\n    messagesKey?: string;\n    /**\n     * Callback that is called when an error occurs.\n     */\n    onError?: (error: unknown, run: RunCallbackMeta | undefined) => void;\n    /**\n     * Callback that is called when the stream is finished.\n     */\n    onFinish?: (state: ThreadState<StateType>, run: RunCallbackMeta | undefined) => void;\n    /**\n     * Callback that is called when a new stream is created.\n     */\n    onCreated?: (run: RunCallbackMeta) => void;\n    /**\n     * Callback that is called when an update event is received.\n     */\n    onUpdateEvent?: (data: UpdatesStreamEvent<GetUpdateType<Bag, StateType>>[\"data\"], options: {\n        namespace: string[] | undefined;\n        mutate: (update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)) => void;\n    }) => void;\n    /**\n     * Callback that is called when a custom event is received.\n     */\n    onCustomEvent?: (data: CustomStreamEvent<GetCustomEventType<Bag>>[\"data\"], options: {\n        namespace: string[] | undefined;\n        mutate: (update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)) => void;\n    }) => void;\n    /**\n     * Callback that is called when a metadata event is received.\n     */\n    onMetadataEvent?: (data: MetadataStreamEvent[\"data\"]) => void;\n    /**\n     * Callback that is called when a LangChain event is received.\n     * @see https://langchain-ai.github.io/langgraph/cloud/how-tos/stream_events/#stream-graph-in-events-mode for more details.\n     */\n    onLangChainEvent?: (data: EventsStreamEvent[\"data\"]) => void;\n    /**\n     * Callback that is called when a debug event is received.\n     * @internal This API is experimental and subject to change.\n     */\n    onDebugEvent?: (data: DebugStreamEvent[\"data\"], options: {\n        namespace: string[] | undefined;\n    }) => void;\n    /**\n     * Callback that is called when a checkpoints event is received.\n     */\n    onCheckpointEvent?: (data: CheckpointsStreamEvent<StateType>[\"data\"], options: {\n        namespace: string[] | undefined;\n    }) => void;\n    /**\n     * Callback that is called when a tasks event is received.\n     */\n    onTaskEvent?: (data: TasksStreamEvent<StateType, GetUpdateType<Bag, StateType>>[\"data\"], options: {\n        namespace: string[] | undefined;\n    }) => void;\n    /**\n     * Callback that is called when the stream is stopped by the user.\n     * Provides a mutate function to update the stream state immediately\n     * without requiring a server roundtrip.\n     *\n     * @example\n     * ```typescript\n     * onStop: ({ mutate }) => {\n     *   mutate((prev) => ({\n     *     ...prev,\n     *     ui: prev.ui?.map(component =>\n     *       component.props.isLoading\n     *         ? { ...component, props: { ...component.props, stopped: true, isLoading: false }}\n     *         : component\n     *     )\n     *   }));\n     * }\n     * ```\n     */\n    onStop?: (options: {\n        mutate: (update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)) => void;\n    }) => void;\n    /**\n     * The ID of the thread to fetch history and current values from.\n     */\n    threadId?: string | null;\n    /**\n     * Callback that is called when the thread ID is updated (ie when a new thread is created).\n     */\n    onThreadId?: (threadId: string) => void;\n    /** Will reconnect the stream on mount */\n    reconnectOnMount?: boolean | (() => RunMetadataStorage);\n    /**\n     * Initial values to display immediately when loading a thread.\n     * Useful for displaying cached thread data while official history loads.\n     * These values will be replaced when official thread data is fetched.\n     *\n     * Note: UI components from initialValues will render immediately if they're\n     * predefined in LoadExternalComponent's components prop, providing instant\n     * cached UI display without server fetches.\n     */\n    initialValues?: StateType | null;\n    /**\n     * Whether to fetch the history of the thread.\n     * If true, the history will be fetched from the server. Defaults to 10 entries.\n     * If false, only the last state will be fetched from the server.\n     * @default true\n     */\n    fetchStateHistory?: boolean | {\n        limit: number;\n    };\n    /**\n     * Manage the thread state externally.\n     */\n    thread?: UseStreamThread<StateType>;\n    /**\n     * Throttle the stream.\n     * If a number is provided, the stream will be throttled to the given number of milliseconds.\n     * If `true`, updates are batched in a single macrotask.\n     * If `false`, updates are not throttled or batched.\n     * @default true\n     */\n    throttle?: number | boolean;\n}\ninterface RunMetadataStorage {\n    getItem(key: `lg:stream:${string}`): string | null;\n    setItem(key: `lg:stream:${string}`, value: string): void;\n    removeItem(key: `lg:stream:${string}`): void;\n}\ntype ConfigWithConfigurable<ConfigurableType extends Record<string, unknown>> = Config & {\n    configurable?: ConfigurableType;\n};\nexport interface SubmitOptions<StateType extends Record<string, unknown> = Record<string, unknown>, ContextType extends Record<string, unknown> = Record<string, unknown>> {\n    config?: ConfigWithConfigurable<ContextType>;\n    context?: ContextType;\n    checkpoint?: Omit<Checkpoint, \"thread_id\"> | null;\n    command?: Command;\n    interruptBefore?: \"*\" | string[];\n    interruptAfter?: \"*\" | string[];\n    metadata?: Metadata;\n    multitaskStrategy?: MultitaskStrategy;\n    onCompletion?: OnCompletionBehavior;\n    onDisconnect?: DisconnectMode;\n    feedbackKeys?: string[];\n    streamMode?: Array<StreamMode>;\n    runId?: string;\n    optimisticValues?: Partial<StateType> | ((prev: StateType) => Partial<StateType>);\n    /**\n     * Whether or not to stream the nodes of any subgraphs called\n     * by the assistant.\n     * @default false\n     */\n    streamSubgraphs?: boolean;\n    /**\n     * Mark the stream as resumable. All events emitted during the run will be temporarily persisted\n     * in order to be re-emitted if the stream is re-joined.\n     * @default false\n     */\n    streamResumable?: boolean;\n    /**\n     * Whether to checkpoint during the run (or only at the end/interruption).\n     * - `\"async\"`: Save checkpoint asynchronously while the next step executes (default).\n     * - `\"sync\"`: Save checkpoint synchronously before the next step starts.\n     * - `\"exit\"`: Save checkpoint only when the graph exits.\n     * @default \"async\"\n     */\n    durability?: Durability;\n    /**\n     * The ID to use when creating a new thread. When provided, this ID will be used\n     * for thread creation when threadId is `null` or `undefined`.\n     * This enables optimistic UI updates where you know the thread ID\n     * before the thread is actually created.\n     */\n    threadId?: string;\n}\n/**\n * Transport used to stream the thread.\n * Only applicable for custom endpoints using `toLangGraphEventStream` or `toLangGraphEventStreamResponse`.\n */\nexport interface UseStreamTransport<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> {\n    stream: (payload: {\n        input: GetUpdateType<Bag, StateType> | null | undefined;\n        context: GetConfigurableType<Bag> | undefined;\n        command: Command | undefined;\n        config: ConfigWithConfigurable<GetConfigurableType<Bag>> | undefined;\n        signal: AbortSignal;\n    }) => Promise<AsyncGenerator<{\n        id?: string;\n        event: string;\n        data: unknown;\n    }>>;\n}\nexport type UseStreamCustomOptions<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> = Pick<UseStreamOptions<StateType, Bag>, \"messagesKey\" | \"threadId\" | \"onThreadId\" | \"onError\" | \"onCreated\" | \"onUpdateEvent\" | \"onCustomEvent\" | \"onMetadataEvent\" | \"onLangChainEvent\" | \"onDebugEvent\" | \"onCheckpointEvent\" | \"onTaskEvent\" | \"onStop\" | \"initialValues\" | \"throttle\"> & {\n    transport: UseStreamTransport<StateType, Bag>;\n};\nexport type CustomSubmitOptions<StateType extends Record<string, unknown> = Record<string, unknown>, ConfigurableType extends Record<string, unknown> = Record<string, unknown>> = Pick<SubmitOptions<StateType, ConfigurableType>, \"optimisticValues\" | \"context\" | \"command\" | \"config\">;\nexport {};\n"],"mappings":"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"}