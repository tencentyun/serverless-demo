{"version":3,"file":"state.js","names":[],"sources":["../../src/graph/state.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-use-before-define */\nimport { _coerceToRunnable, Runnable } from \"@langchain/core/runnables\";\nimport {\n  All,\n  type BaseCache,\n  BaseCheckpointSaver,\n  BaseStore,\n} from \"@langchain/langgraph-checkpoint\";\nimport {\n  type InteropZodObject,\n  interopParse,\n  interopZodObjectPartial,\n  isInteropZodObject,\n} from \"@langchain/core/utils/types\";\nimport type {\n  RunnableLike,\n  LangGraphRunnableConfig,\n  Runtime,\n} from \"../pregel/runnable_types.js\";\nimport { BaseChannel } from \"../channels/base.js\";\nimport {\n  CompiledGraph,\n  Graph,\n  Branch,\n  AddNodeOptions,\n  NodeSpec,\n} from \"./graph.js\";\nimport {\n  ChannelWrite,\n  ChannelWriteEntry,\n  ChannelWriteTupleEntry,\n  PASSTHROUGH,\n} from \"../pregel/write.js\";\nimport { ChannelRead, PregelNode } from \"../pregel/read.js\";\nimport {\n  NamedBarrierValue,\n  NamedBarrierValueAfterFinish,\n} from \"../channels/named_barrier_value.js\";\nimport { EphemeralValue } from \"../channels/ephemeral_value.js\";\nimport { RunnableCallable } from \"../utils.js\";\nimport {\n  isCommand,\n  _isSend,\n  CHECKPOINT_NAMESPACE_END,\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  Command,\n  SELF,\n  Send,\n  START,\n  END,\n  TAG_HIDDEN,\n  CommandInstance,\n  isInterrupted,\n  Interrupt,\n  INTERRUPT,\n} from \"../constants.js\";\nimport {\n  InvalidUpdateError,\n  ParentCommand,\n  StateGraphInputError,\n} from \"../errors.js\";\nimport {\n  AnnotationRoot,\n  getChannel,\n  SingleReducer,\n  StateDefinition,\n  StateType,\n} from \"./annotation.js\";\nimport { StateSchema } from \"../state/index.js\";\nimport type { CachePolicy, RetryPolicy } from \"../pregel/utils/index.js\";\nimport { isPregelLike } from \"../pregel/utils/subgraph.js\";\nimport { LastValueAfterFinish } from \"../channels/last_value.js\";\nimport { type SchemaMetaRegistry, schemaMetaRegistry } from \"./zod/meta.js\";\nimport type {\n  InferInterruptResumeType,\n  InferInterruptInputType,\n} from \"../interrupt.js\";\nimport type { InferWriterType } from \"../writer.js\";\nimport type { AnyStateSchema } from \"../state/schema.js\";\nimport {\n  ContextSchemaInit,\n  ExtractStateType,\n  ExtractUpdateType,\n  isStateDefinitionInit,\n  isStateGraphInit,\n  StateGraphInit,\n  StateGraphOptions,\n  ToStateDefinition,\n  type StateDefinitionInit,\n} from \"./types.js\";\n\nconst ROOT = \"__root__\";\n\nexport type ChannelReducers<Channels extends object> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [K in keyof Channels]: SingleReducer<Channels[K], any>;\n};\n\nexport interface StateGraphArgs<Channels extends object | unknown> {\n  channels: Channels extends object\n    ? Channels extends unknown[]\n      ? ChannelReducers<{ __root__: Channels }>\n      : ChannelReducers<Channels>\n    : ChannelReducers<{ __root__: Channels }>;\n}\n\nexport type StateGraphNodeSpec<RunInput, RunOutput> = NodeSpec<\n  RunInput,\n  RunOutput\n> & {\n  input?: StateDefinition;\n  retryPolicy?: RetryPolicy;\n  cachePolicy?: CachePolicy;\n};\n\n/**\n * Options for StateGraph.addNode() method.\n *\n * @template Nodes - Node name constraints\n * @template InputSchema - Per-node input schema type (inferred from options.input)\n */\nexport type StateGraphAddNodeOptions<\n  Nodes extends string = string,\n  InputSchema extends StateDefinitionInit | undefined =\n    | StateDefinitionInit\n    | undefined\n> = {\n  retryPolicy?: RetryPolicy;\n  cachePolicy?: CachePolicy | boolean;\n  input?: InputSchema;\n} & AddNodeOptions<Nodes>;\n\nexport type StateGraphArgsWithStateSchema<\n  SD extends StateDefinition,\n  I extends StateDefinition,\n  O extends StateDefinition\n> = {\n  stateSchema: AnnotationRoot<SD>;\n  input?: AnnotationRoot<I>;\n  output?: AnnotationRoot<O>;\n};\n\nexport type StateGraphArgsWithInputOutputSchemas<\n  SD extends StateDefinition,\n  O extends StateDefinition = SD\n> = {\n  input: AnnotationRoot<SD>;\n  output: AnnotationRoot<O>;\n};\n\ntype ExtractStateDefinition<T> = T extends AnyStateSchema\n  ? T // Keep StateSchema as-is to preserve type information\n  : T extends StateDefinitionInit\n  ? ToStateDefinition<T>\n  : StateDefinition;\n\ntype NodeAction<\n  S,\n  U,\n  C extends StateDefinitionInit,\n  InterruptType,\n  WriterType\n> = RunnableLike<\n  S,\n  U extends object ? U & Record<string, any> : U, // eslint-disable-line @typescript-eslint/no-explicit-any\n  Runtime<StateType<ToStateDefinition<C>>, InterruptType, WriterType>\n>;\n\ntype StrictNodeAction<\n  S,\n  U,\n  C extends StateDefinitionInit,\n  Nodes extends string,\n  InterruptType,\n  WriterType\n> = RunnableLike<\n  Prettify<S>,\n  | U\n  | Command<\n      InferInterruptResumeType<InterruptType>,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      U & Record<string, any>,\n      Nodes\n    >,\n  Runtime<StateType<ToStateDefinition<C>>, InterruptType, WriterType>\n>;\n\nconst PartialStateSchema = Symbol.for(\"langgraph.state.partial\");\ntype PartialStateSchema = typeof PartialStateSchema;\n\ntype MergeReturnType<Prev, Curr> = Prev & Curr extends infer T\n  ? { [K in keyof T]: T[K] } & unknown\n  : never;\n\ntype Prettify<T> = {\n  [K in keyof T]: T[K];\n  // eslint-disable-next-line @typescript-eslint/ban-types\n} & {};\n\n/**\n * A graph whose nodes communicate by reading and writing to a shared state.\n * Each node takes a defined `State` as input and returns a `Partial<State>`.\n *\n * Each state key can optionally be annotated with a reducer function that\n * will be used to aggregate the values of that key received from multiple nodes.\n * The signature of a reducer function is (left: Value, right: UpdateValue) => Value.\n *\n * See {@link Annotation} for more on defining state.\n *\n * After adding nodes and edges to your graph, you must call `.compile()` on it before\n * you can use it.\n *\n * @example\n * ```ts\n * import {\n *   type BaseMessage,\n *   AIMessage,\n *   HumanMessage,\n * } from \"@langchain/core/messages\";\n * import { StateGraph, Annotation } from \"@langchain/langgraph\";\n *\n * // Define a state with a single key named \"messages\" that will\n * // combine a returned BaseMessage or arrays of BaseMessages\n * const StateAnnotation = Annotation.Root({\n *   sentiment: Annotation<string>,\n *   messages: Annotation<BaseMessage[]>({\n *     reducer: (left: BaseMessage[], right: BaseMessage | BaseMessage[]) => {\n *       if (Array.isArray(right)) {\n *         return left.concat(right);\n *       }\n *       return left.concat([right]);\n *     },\n *     default: () => [],\n *   }),\n * });\n *\n * const graphBuilder = new StateGraph(StateAnnotation);\n *\n * // A node in the graph that returns an object with a \"messages\" key\n * // will update the state by combining the existing value with the returned one.\n * const myNode = (state: typeof StateAnnotation.State) => {\n *   return {\n *     messages: [new AIMessage(\"Some new response\")],\n *     sentiment: \"positive\",\n *   };\n * };\n *\n * const graph = graphBuilder\n *   .addNode(\"myNode\", myNode)\n *   .addEdge(\"__start__\", \"myNode\")\n *   .addEdge(\"myNode\", \"__end__\")\n *   .compile();\n *\n * await graph.invoke({ messages: [new HumanMessage(\"how are you?\")] });\n *\n * // {\n * //   messages: [HumanMessage(\"how are you?\"), AIMessage(\"Some new response\")],\n * //   sentiment: \"positive\",\n * // }\n * ```\n */\nexport class StateGraph<\n  SD extends StateDefinitionInit | unknown,\n  S = ExtractStateType<SD>,\n  U = ExtractUpdateType<SD, S>,\n  N extends string = typeof START,\n  I extends StateDefinitionInit = ExtractStateDefinition<SD>,\n  O extends StateDefinitionInit = ExtractStateDefinition<SD>,\n  C extends StateDefinitionInit = StateDefinition,\n  NodeReturnType = unknown,\n  InterruptType = unknown,\n  WriterType = unknown\n> extends Graph<N, S, U, StateGraphNodeSpec<S, U>, ToStateDefinition<C>> {\n  channels: Record<string, BaseChannel> = {};\n\n  // TODO: this doesn't dedupe edges as in py, so worth fixing at some point\n  waitingEdges: Set<[N[], N]> = new Set();\n\n  /** @internal */\n  _schemaDefinition: StateDefinition;\n\n  /** @internal */\n  _schemaRuntimeDefinition: InteropZodObject | AnyStateSchema | undefined;\n\n  /** @internal */\n  _inputDefinition: I;\n\n  /** @internal */\n  _inputRuntimeDefinition:\n    | InteropZodObject\n    | AnyStateSchema\n    | PartialStateSchema\n    | undefined;\n\n  /** @internal */\n  _outputDefinition: O;\n\n  /** @internal */\n  _outputRuntimeDefinition: InteropZodObject | AnyStateSchema | undefined;\n\n  /**\n   * Map schemas to managed values\n   * @internal\n   */\n  _schemaDefinitions = new Map();\n\n  /** @internal */\n  _metaRegistry: SchemaMetaRegistry = schemaMetaRegistry;\n\n  /** @internal Used only for typing. */\n  _configSchema: ToStateDefinition<C> | undefined;\n\n  /** @internal */\n  _configRuntimeSchema: InteropZodObject | undefined;\n\n  /** @internal */\n  _interrupt: InterruptType;\n\n  /** @internal */\n  _writer: WriterType;\n\n  declare Node: StrictNodeAction<S, U, C, N, InterruptType, WriterType>;\n\n  /**\n   * Create a new StateGraph for building stateful, multi-step workflows.\n   *\n   * Accepts state definitions via `Annotation.Root`, `StateSchema`, or Zod schemas.\n   *\n   * @example Direct schema\n   * ```ts\n   * const StateAnnotation = Annotation.Root({\n   *   messages: Annotation<string[]>({ reducer: (a, b) => [...a, ...b] }),\n   * });\n   * const graph = new StateGraph(StateAnnotation);\n   * ```\n   *\n   * @example Direct schema with input/output filtering\n   * ```ts\n   * const graph = new StateGraph(StateAnnotation, {\n   *   input: InputSchema,\n   *   output: OutputSchema,\n   * });\n   * ```\n   *\n   * @example Object pattern with state, input, output\n   * ```ts\n   * const graph = new StateGraph({\n   *   state: FullStateSchema,\n   *   input: InputSchema,\n   *   output: OutputSchema,\n   * });\n   * ```\n   *\n   * @example Input/output only (state inferred from input)\n   * ```ts\n   * const graph = new StateGraph({\n   *   input: InputAnnotation,\n   *   output: OutputAnnotation,\n   * });\n   * ```\n   */\n  constructor(\n    state: SD extends StateDefinitionInit ? SD : never,\n    options?:\n      | C\n      | AnnotationRoot<ToStateDefinition<C>>\n      | StateGraphOptions<I, O, C, N, InterruptType, WriterType>\n  );\n\n  constructor(\n    fields: SD extends StateDefinition\n      ? StateGraphArgsWithInputOutputSchemas<SD, ToStateDefinition<O>>\n      : never,\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  constructor(\n    fields: SD extends StateDefinition\n      ?\n          | AnnotationRoot<SD>\n          | StateGraphArgsWithStateSchema<\n              SD,\n              ToStateDefinition<I>,\n              ToStateDefinition<O>\n            >\n      : never,\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  constructor(\n    init: Omit<\n      StateGraphInit<\n        SD extends StateDefinitionInit ? SD : StateDefinitionInit,\n        SD extends StateDefinitionInit ? SD : StateDefinitionInit,\n        O,\n        C extends ContextSchemaInit ? C : undefined,\n        N,\n        InterruptType,\n        WriterType\n      >,\n      \"state\" | \"stateSchema\" | \"input\"\n    > & {\n      input: SD extends StateDefinitionInit ? SD : never;\n      state?: never;\n      stateSchema?: never;\n    },\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  constructor(\n    init: StateGraphInit<\n      SD extends StateDefinitionInit ? SD : StateDefinitionInit,\n      I,\n      O,\n      C extends ContextSchemaInit ? C : undefined,\n      N,\n      InterruptType,\n      WriterType\n    >\n  );\n\n  /** @deprecated Use `Annotation.Root`, `StateSchema`, or Zod schemas instead. */\n  constructor(\n    fields: StateGraphArgs<S>,\n    contextSchema?: C | AnnotationRoot<ToStateDefinition<C>>\n  );\n\n  constructor(\n    stateOrInit:\n      | StateDefinitionInit\n      | StateGraphInit<StateDefinitionInit, I, O>\n      | StateGraphArgs<S>,\n    options?:\n      | C\n      | AnnotationRoot<ToStateDefinition<C>>\n      | StateGraphOptions<\n          I,\n          O,\n          C extends ContextSchemaInit ? C : undefined,\n          N,\n          InterruptType,\n          WriterType\n        >\n  ) {\n    super();\n\n    // Normalize all input patterns to StateGraphInit format\n    const init = this._normalizeToStateGraphInit(stateOrInit, options);\n\n    // Resolve state schema: state > stateSchema (deprecated) > input\n    const stateSchema = init.state ?? init.stateSchema ?? init.input;\n    if (!stateSchema) {\n      throw new StateGraphInputError();\n    }\n\n    // Get channel definitions from the schema (may contain channel factories)\n    const stateChannelDef = this._getChannelsFromSchema(stateSchema);\n\n    // Set schema definitions (these may contain channel factories)\n    this._schemaDefinition = stateChannelDef;\n\n    // Set runtime definitions for validation\n    if (StateSchema.isInstance(stateSchema)) {\n      this._schemaRuntimeDefinition = stateSchema;\n    } else if (isInteropZodObject(stateSchema)) {\n      this._schemaRuntimeDefinition = stateSchema;\n    }\n\n    // Set input runtime definition\n    if (init.input) {\n      if (StateSchema.isInstance(init.input)) {\n        this._inputRuntimeDefinition = init.input;\n      } else if (isInteropZodObject(init.input)) {\n        this._inputRuntimeDefinition = init.input;\n      } else {\n        this._inputRuntimeDefinition = PartialStateSchema;\n      }\n    } else {\n      this._inputRuntimeDefinition = PartialStateSchema;\n    }\n\n    // Set output runtime definition\n    if (init.output) {\n      if (StateSchema.isInstance(init.output)) {\n        this._outputRuntimeDefinition = init.output;\n      } else if (isInteropZodObject(init.output)) {\n        this._outputRuntimeDefinition = init.output;\n      } else {\n        this._outputRuntimeDefinition = this._schemaRuntimeDefinition;\n      }\n    } else {\n      this._outputRuntimeDefinition = this._schemaRuntimeDefinition;\n    }\n\n    // Set input/output definitions (default to state)\n    const inputChannelDef = init.input\n      ? this._getChannelsFromSchema(init.input)\n      : stateChannelDef;\n    const outputChannelDef = init.output\n      ? (this._getChannelsFromSchema(init.output) as O)\n      : stateChannelDef;\n    this._inputDefinition = inputChannelDef as I;\n    this._outputDefinition = outputChannelDef as O;\n\n    // Add all schemas (_addSchema instantiates channel factories and populates this.channels)\n    this._addSchema(this._schemaDefinition);\n    this._addSchema(this._inputDefinition);\n    this._addSchema(this._outputDefinition);\n\n    // Handle context schema\n    if (init.context) {\n      if (isInteropZodObject(init.context)) {\n        this._configRuntimeSchema = init.context;\n      }\n    }\n\n    // Handle interrupt and writer\n    this._interrupt = init.interrupt as InterruptType;\n    this._writer = init.writer as WriterType;\n  }\n\n  /**\n   * Normalize all constructor input patterns to a unified StateGraphInit object.\n   * @internal\n   */\n  private _normalizeToStateGraphInit(\n    stateOrInit: unknown,\n    options?: unknown\n  ): StateGraphInit<StateDefinitionInit, I, O, C> {\n    // Check if already StateGraphInit format\n    if (isStateGraphInit(stateOrInit)) {\n      // Second arg can be either a direct context schema or an options object\n      if (isInteropZodObject(options) || AnnotationRoot.isInstance(options)) {\n        return {\n          ...stateOrInit,\n          context: options as C,\n        };\n      }\n      // Merge any 2nd arg options\n      const opts = options as StateGraphOptions<I, O> | undefined;\n      return {\n        ...stateOrInit,\n        input: stateOrInit.input ?? opts?.input,\n        output: stateOrInit.output ?? opts?.output,\n        context: stateOrInit.context ?? opts?.context,\n        interrupt: stateOrInit.interrupt ?? opts?.interrupt,\n        writer: stateOrInit.writer ?? opts?.writer,\n        nodes: stateOrInit.nodes ?? opts?.nodes,\n      } as StateGraphInit<StateDefinitionInit, I, O, C>;\n    }\n\n    // Check if direct schema (StateSchema, Zod, Annotation, StateDefinition)\n    if (isStateDefinitionInit(stateOrInit)) {\n      // Second arg can be either a direct context schema or an options object\n      if (isInteropZodObject(options) || AnnotationRoot.isInstance(options)) {\n        return {\n          state: stateOrInit,\n          context: options as C,\n        };\n      }\n      const opts = options as StateGraphOptions<I, O> | undefined;\n      return {\n        state: stateOrInit as StateDefinitionInit,\n        input: opts?.input as I,\n        output: opts?.output as O,\n        context: opts?.context,\n        interrupt: opts?.interrupt,\n        writer: opts?.writer,\n        nodes: opts?.nodes,\n      };\n    }\n\n    // Check for legacy { channels } format\n    if (isStateGraphArgs(stateOrInit as StateGraphArgs<S>)) {\n      const legacyArgs = stateOrInit as StateGraphArgs<S>;\n      const spec = _getChannels(legacyArgs.channels);\n      return {\n        state: spec as StateDefinitionInit,\n      };\n    }\n\n    throw new StateGraphInputError();\n  }\n\n  /**\n   * Convert any supported schema type to a StateDefinition (channel map).\n   * @internal\n   */\n  private _getChannelsFromSchema(schema: StateDefinitionInit): StateDefinition {\n    if (StateSchema.isInstance(schema)) {\n      return schema.getChannels();\n    }\n\n    if (isInteropZodObject(schema)) {\n      return this._metaRegistry.getChannelsForSchema(schema);\n    }\n\n    // AnnotationRoot - has .spec property that is the StateDefinition\n    if (\n      typeof schema === \"object\" &&\n      \"lc_graph_name\" in schema &&\n      (schema as { lc_graph_name: unknown }).lc_graph_name === \"AnnotationRoot\"\n    ) {\n      return (schema as AnnotationRoot<StateDefinition>).spec;\n    }\n\n    // StateDefinition (raw channel map) - return as-is\n    if (\n      typeof schema === \"object\" &&\n      !Array.isArray(schema) &&\n      Object.keys(schema).length > 0\n    ) {\n      return schema as StateDefinition;\n    }\n\n    throw new StateGraphInputError(\n      \"Invalid schema type. Expected StateSchema, Zod object, AnnotationRoot, or StateDefinition.\"\n    );\n  }\n\n  get allEdges(): Set<[string, string]> {\n    return new Set([\n      ...this.edges,\n      ...Array.from(this.waitingEdges).flatMap(([starts, end]) =>\n        starts.map((start) => [start, end] as [string, string])\n      ),\n    ]);\n  }\n\n  _addSchema(stateDefinition: StateDefinitionInit) {\n    if (this._schemaDefinitions.has(stateDefinition)) {\n      return;\n    }\n    // TODO: Support managed values\n    this._schemaDefinitions.set(stateDefinition, stateDefinition);\n    for (const [key, val] of Object.entries(stateDefinition)) {\n      let channel;\n      if (typeof val === \"function\") {\n        channel = val();\n      } else {\n        channel = val;\n      }\n      if (this.channels[key] !== undefined) {\n        if (!this.channels[key].equals(channel)) {\n          if (channel.lc_graph_name !== \"LastValue\") {\n            throw new Error(\n              `Channel \"${key}\" already exists with a different type.`\n            );\n          }\n        }\n      } else {\n        this.channels[key] = channel;\n      }\n    }\n  }\n\n  override addNode<\n    K extends string,\n    NodeMap extends Record<K, NodeAction<S, U, C, InterruptType, WriterType>>\n  >(\n    nodes: NodeMap\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<\n      NodeReturnType,\n      {\n        [key in keyof NodeMap]: NodeMap[key] extends NodeAction<\n          S,\n          infer U,\n          C,\n          InterruptType,\n          WriterType\n        >\n          ? U\n          : never;\n      }\n    >\n  >;\n\n  override addNode<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    nodes:\n      | [\n          key: K,\n          action: NodeAction<\n            NodeInput,\n            NodeOutput,\n            C,\n            InterruptType,\n            WriterType\n          >,\n          options?: StateGraphAddNodeOptions\n        ][]\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  override addNode<\n    K extends string,\n    InputSchema extends StateDefinitionInit,\n    NodeOutput extends U = U\n  >(\n    key: K,\n    action: NodeAction<\n      ExtractStateType<InputSchema>,\n      NodeOutput,\n      C,\n      InterruptType,\n      WriterType\n    >,\n    options: StateGraphAddNodeOptions<N | K, InputSchema>\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  override addNode<\n    K extends string,\n    InputSchema extends StateDefinitionInit,\n    NodeOutput extends U = U\n  >(\n    key: K,\n    action: NodeAction<\n      ExtractStateType<InputSchema>,\n      NodeOutput,\n      C,\n      InterruptType,\n      WriterType\n    >,\n    options: StateGraphAddNodeOptions<N | K, InputSchema>\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  override addNode<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    key: K,\n    action: NodeAction<NodeInput, NodeOutput, C, InterruptType, WriterType>,\n    options?: StateGraphAddNodeOptions\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  override addNode<K extends string, NodeInput = S>(\n    key: K,\n    action: NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n    options?: StateGraphAddNodeOptions\n  ): StateGraph<SD, S, U, N | K, I, O, C, NodeReturnType>;\n\n  override addNode<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    ...args:\n      | [\n          key: K,\n          action: NodeAction<\n            NodeInput,\n            NodeOutput,\n            C,\n            InterruptType,\n            WriterType\n          >,\n          options?: StateGraphAddNodeOptions\n        ]\n      | [\n          nodes:\n            | Record<K, NodeAction<NodeInput, U, C, InterruptType, WriterType>>\n            | [\n                key: K,\n                action: NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n                options?: StateGraphAddNodeOptions\n              ][]\n        ]\n  ): StateGraph<SD, S, U, N | K, I, O, C> {\n    function isMultipleNodes(\n      args: unknown[]\n    ): args is [\n      nodes:\n        | Record<K, NodeAction<NodeInput, U, C, InterruptType, WriterType>>\n        | [\n            key: K,\n            action: NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n            options?: AddNodeOptions\n          ][]\n    ] {\n      return args.length >= 1 && typeof args[0] !== \"string\";\n    }\n\n    const nodes = (\n      isMultipleNodes(args) // eslint-disable-line no-nested-ternary\n        ? Array.isArray(args[0])\n          ? args[0]\n          : Object.entries(args[0]).map(([key, action]) => [key, action])\n        : [[args[0], args[1], args[2]]]\n    ) as [\n      K,\n      NodeAction<NodeInput, U, C, InterruptType, WriterType>,\n      StateGraphAddNodeOptions | undefined\n    ][];\n\n    if (nodes.length === 0) {\n      throw new Error(\"No nodes provided in `addNode`\");\n    }\n\n    for (const [key, action, options] of nodes) {\n      if (key in this.channels) {\n        throw new Error(\n          `${key} is already being used as a state attribute (a.k.a. a channel), cannot also be used as a node name.`\n        );\n      }\n\n      for (const reservedChar of [\n        CHECKPOINT_NAMESPACE_SEPARATOR,\n        CHECKPOINT_NAMESPACE_END,\n      ]) {\n        if (key.includes(reservedChar)) {\n          throw new Error(\n            `\"${reservedChar}\" is a reserved character and is not allowed in node names.`\n          );\n        }\n      }\n      this.warnIfCompiled(\n        `Adding a node to a graph that has already been compiled. This will not be reflected in the compiled graph.`\n      );\n\n      if (key in this.nodes) {\n        throw new Error(`Node \\`${key}\\` already present.`);\n      }\n      if (key === END || key === START) {\n        throw new Error(`Node \\`${key}\\` is reserved.`);\n      }\n\n      let inputSpec: StateDefinition = this._schemaDefinition;\n      if (options?.input !== undefined) {\n        inputSpec = this._getChannelsFromSchema(options.input);\n      }\n      this._addSchema(inputSpec);\n\n      let runnable;\n      if (Runnable.isRunnable(action)) {\n        runnable = action;\n      } else if (typeof action === \"function\") {\n        runnable = new RunnableCallable({\n          func: action,\n          name: key,\n          trace: false,\n        });\n      } else {\n        runnable = _coerceToRunnable(action);\n      }\n\n      let cachePolicy = options?.cachePolicy;\n      if (typeof cachePolicy === \"boolean\") {\n        cachePolicy = cachePolicy ? {} : undefined;\n      }\n\n      const nodeSpec: StateGraphNodeSpec<S, U> = {\n        runnable: runnable as unknown as Runnable<S, U>,\n        retryPolicy: options?.retryPolicy,\n        cachePolicy,\n        metadata: options?.metadata,\n        input: inputSpec ?? this._schemaDefinition,\n        subgraphs: isPregelLike(runnable)\n          ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            [runnable as any]\n          : options?.subgraphs,\n        ends: options?.ends,\n        defer: options?.defer,\n      };\n\n      this.nodes[key as unknown as N] = nodeSpec;\n    }\n\n    return this as StateGraph<SD, S, U, N | K, I, O, C>;\n  }\n\n  override addEdge(\n    startKey: typeof START | N | N[],\n    endKey: N | typeof END\n  ): this {\n    if (typeof startKey === \"string\") {\n      return super.addEdge(startKey, endKey);\n    }\n\n    if (this.compiled) {\n      console.warn(\n        \"Adding an edge to a graph that has already been compiled. This will \" +\n          \"not be reflected in the compiled graph.\"\n      );\n    }\n\n    for (const start of startKey) {\n      if (start === END) {\n        throw new Error(\"END cannot be a start node\");\n      }\n      if (!Object.keys(this.nodes).some((node) => node === start)) {\n        throw new Error(`Need to add a node named \"${start}\" first`);\n      }\n    }\n    if (endKey === END) {\n      throw new Error(\"END cannot be an end node\");\n    }\n    if (!Object.keys(this.nodes).some((node) => node === endKey)) {\n      throw new Error(`Need to add a node named \"${endKey}\" first`);\n    }\n\n    this.waitingEdges.add([startKey, endKey]);\n\n    return this;\n  }\n\n  addSequence<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    nodes: [\n      key: K,\n      action: NodeAction<NodeInput, NodeOutput, C, InterruptType, WriterType>,\n      options?: StateGraphAddNodeOptions\n    ][]\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  >;\n\n  addSequence<\n    K extends string,\n    NodeMap extends Record<K, NodeAction<S, U, C, InterruptType, WriterType>>\n  >(\n    nodes: NodeMap\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<\n      NodeReturnType,\n      {\n        [key in keyof NodeMap]: NodeMap[key] extends NodeAction<\n          S,\n          infer U,\n          C,\n          InterruptType,\n          WriterType\n        >\n          ? U\n          : never;\n      }\n    >\n  >;\n\n  addSequence<K extends string, NodeInput = S, NodeOutput extends U = U>(\n    nodes:\n      | [\n          key: K,\n          action: NodeAction<\n            NodeInput,\n            NodeOutput,\n            C,\n            InterruptType,\n            WriterType\n          >,\n          options?: StateGraphAddNodeOptions\n        ][]\n      | Record<\n          K,\n          NodeAction<NodeInput, NodeOutput, C, InterruptType, WriterType>\n        >\n  ): StateGraph<\n    SD,\n    S,\n    U,\n    N | K,\n    I,\n    O,\n    C,\n    MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n  > {\n    const parsedNodes = Array.isArray(nodes) ? nodes : Object.entries(nodes);\n\n    if (parsedNodes.length === 0) {\n      throw new Error(\"Sequence requires at least one node.\");\n    }\n\n    let previousNode: N | undefined;\n    for (const [key, action, options] of parsedNodes) {\n      if (key in this.nodes) {\n        throw new Error(\n          `Node names must be unique: node with the name \"${key}\" already exists.`\n        );\n      }\n\n      const validKey = key as unknown as N;\n      this.addNode(\n        validKey,\n        action as NodeAction<S, U, C, InterruptType, WriterType>,\n        options\n      );\n      if (previousNode != null) {\n        this.addEdge(previousNode, validKey);\n      }\n\n      previousNode = validKey;\n    }\n\n    return this as StateGraph<\n      SD,\n      S,\n      U,\n      N | K,\n      I,\n      O,\n      C,\n      MergeReturnType<NodeReturnType, { [key in K]: NodeOutput }>\n    >;\n  }\n\n  override compile({\n    checkpointer,\n    store,\n    cache,\n    interruptBefore,\n    interruptAfter,\n    name,\n    description,\n  }: {\n    checkpointer?: BaseCheckpointSaver | boolean;\n    store?: BaseStore;\n    cache?: BaseCache;\n    interruptBefore?: N[] | All;\n    interruptAfter?: N[] | All;\n    name?: string;\n    description?: string;\n  } = {}): CompiledStateGraph<\n    Prettify<S>,\n    Prettify<U>,\n    N,\n    I,\n    O,\n    C,\n    NodeReturnType,\n    InterruptType,\n    WriterType\n  > {\n    // validate the graph\n    this.validate([\n      ...(Array.isArray(interruptBefore) ? interruptBefore : []),\n      ...(Array.isArray(interruptAfter) ? interruptAfter : []),\n    ]);\n\n    // prepare output channels\n    const outputKeys = Object.keys(\n      this._schemaDefinitions.get(this._outputDefinition)\n    );\n    const outputChannels =\n      outputKeys.length === 1 && outputKeys[0] === ROOT ? ROOT : outputKeys;\n\n    const streamKeys = Object.keys(this.channels);\n    const streamChannels =\n      streamKeys.length === 1 && streamKeys[0] === ROOT ? ROOT : streamKeys;\n\n    const userInterrupt = this._interrupt;\n    // create empty compiled graph\n    const compiled = new CompiledStateGraph<\n      S,\n      U,\n      N,\n      I,\n      O,\n      C,\n      NodeReturnType,\n      InterruptType,\n      WriterType\n    >({\n      builder: this,\n      checkpointer,\n      interruptAfter,\n      interruptBefore,\n      autoValidate: false,\n      nodes: {} as Record<N | typeof START, PregelNode<S, U>>,\n      channels: {\n        ...this.channels,\n        [START]: new EphemeralValue(),\n      } as Record<N | typeof START | typeof END | string, BaseChannel>,\n      inputChannels: START,\n      outputChannels,\n      streamChannels,\n      streamMode: \"updates\",\n      store,\n      cache,\n      name,\n      description,\n      userInterrupt,\n    });\n\n    // attach nodes, edges and branches\n    compiled.attachNode(START);\n    for (const [key, node] of Object.entries<StateGraphNodeSpec<S, U>>(\n      this.nodes\n    )) {\n      compiled.attachNode(key as N, node);\n    }\n    compiled.attachBranch(START, SELF, _getControlBranch() as Branch<S, N>, {\n      withReader: false,\n    });\n    for (const [key] of Object.entries<StateGraphNodeSpec<S, U>>(this.nodes)) {\n      compiled.attachBranch(\n        key as N,\n        SELF,\n        _getControlBranch() as Branch<S, N>,\n        {\n          withReader: false,\n        }\n      );\n    }\n    for (const [start, end] of this.edges) {\n      compiled.attachEdge(start, end);\n    }\n    for (const [starts, end] of this.waitingEdges) {\n      compiled.attachEdge(starts, end);\n    }\n    for (const [start, branches] of Object.entries(this.branches)) {\n      for (const [name, branch] of Object.entries(branches)) {\n        compiled.attachBranch(start as N, name, branch);\n      }\n    }\n\n    return compiled.validate();\n  }\n}\n\nfunction _getChannels<Channels extends Record<string, unknown> | unknown>(\n  schema: StateGraphArgs<Channels>[\"channels\"]\n): Record<string, BaseChannel> {\n  const channels: Record<string, BaseChannel> = {};\n  for (const [name, val] of Object.entries(schema)) {\n    if (name === ROOT) {\n      channels[name] = getChannel<Channels>(val as SingleReducer<Channels>);\n    } else {\n      const key = name as keyof Channels;\n      channels[name] = getChannel<Channels[typeof key]>(\n        val as SingleReducer<Channels[typeof key]>\n      );\n    }\n  }\n  return channels;\n}\n\n/**\n * Final result from building and compiling a {@link StateGraph}.\n * Should not be instantiated directly, only using the StateGraph `.compile()`\n * instance method.\n */\nexport class CompiledStateGraph<\n  S,\n  U,\n  N extends string = typeof START,\n  I extends StateDefinitionInit = StateDefinition,\n  O extends StateDefinitionInit = StateDefinition,\n  C extends StateDefinitionInit = StateDefinition,\n  NodeReturnType = unknown,\n  InterruptType = unknown,\n  WriterType = unknown\n> extends CompiledGraph<\n  N,\n  S,\n  U,\n  ExtractStateType<C>,\n  ExtractUpdateType<I, ExtractStateType<I>>,\n  ExtractStateType<O>,\n  NodeReturnType,\n  CommandInstance<InferInterruptResumeType<InterruptType>, Prettify<U>, N>,\n  InferWriterType<WriterType>\n> {\n  declare builder: StateGraph<unknown, S, U, N, I, O, C, NodeReturnType>;\n\n  /**\n   * The description of the compiled graph.\n   * This is used by the supervisor agent to describe the handoff to the agent.\n   */\n  description?: string;\n\n  /** @internal */\n  _metaRegistry: SchemaMetaRegistry = schemaMetaRegistry;\n\n  constructor({\n    description,\n    ...rest\n  }: { description?: string } & ConstructorParameters<\n    typeof CompiledGraph<\n      N,\n      S,\n      U,\n      ExtractStateType<C>,\n      ExtractUpdateType<I, ExtractStateType<I>>,\n      ExtractStateType<O>,\n      NodeReturnType,\n      CommandInstance<InferInterruptResumeType<InterruptType>, Prettify<U>, N>,\n      InferWriterType<WriterType>\n    >\n  >[0]) {\n    super(rest);\n    this.description = description;\n  }\n\n  attachNode(key: typeof START, node?: never): void;\n\n  attachNode(key: N, node: StateGraphNodeSpec<S, U>): void;\n\n  attachNode(key: N | typeof START, node?: StateGraphNodeSpec<S, U>): void {\n    let outputKeys: string[];\n    if (key === START) {\n      // Get input schema keys excluding managed values\n      outputKeys = Object.entries(\n        this.builder._schemaDefinitions.get(this.builder._inputDefinition)\n      ).map(([k]) => k);\n    } else {\n      outputKeys = Object.keys(this.builder.channels);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function _getRoot(input: unknown): [string, any][] | null {\n      if (isCommand(input)) {\n        if (input.graph === Command.PARENT) {\n          return null;\n        }\n        return input._updateAsTuples();\n      } else if (\n        Array.isArray(input) &&\n        input.length > 0 &&\n        input.some((i) => isCommand(i))\n      ) {\n        const updates: [string, unknown][] = [];\n        for (const i of input) {\n          if (isCommand(i)) {\n            if (i.graph === Command.PARENT) {\n              continue;\n            }\n            updates.push(...i._updateAsTuples());\n          } else {\n            updates.push([ROOT, i]);\n          }\n        }\n        return updates;\n      } else if (input != null) {\n        return [[ROOT, input]];\n      }\n      return null;\n    }\n\n    // to avoid name collision below\n    const nodeKey = key;\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function _getUpdates(input: U): [string, any][] | null {\n      if (!input) {\n        return null;\n      } else if (isCommand(input)) {\n        if (input.graph === Command.PARENT) {\n          return null;\n        }\n        return input._updateAsTuples().filter(([k]) => outputKeys.includes(k));\n      } else if (\n        Array.isArray(input) &&\n        input.length > 0 &&\n        input.some(isCommand)\n      ) {\n        const updates: [string, unknown][] = [];\n        for (const item of input) {\n          if (isCommand(item)) {\n            if (item.graph === Command.PARENT) {\n              continue;\n            }\n            updates.push(\n              ...item._updateAsTuples().filter(([k]) => outputKeys.includes(k))\n            );\n          } else {\n            const itemUpdates = _getUpdates(item);\n            if (itemUpdates) {\n              updates.push(...(itemUpdates ?? []));\n            }\n          }\n        }\n        return updates;\n      } else if (typeof input === \"object\" && !Array.isArray(input)) {\n        return Object.entries(input).filter(([k]) => outputKeys.includes(k));\n      } else {\n        const typeofInput = Array.isArray(input) ? \"array\" : typeof input;\n        throw new InvalidUpdateError(\n          `Expected node \"${nodeKey.toString()}\" to return an object or an array containing at least one Command object, received ${typeofInput}`,\n          {\n            lc_error_code: \"INVALID_GRAPH_NODE_RETURN_VALUE\",\n          }\n        );\n      }\n    }\n\n    const stateWriteEntries: (ChannelWriteTupleEntry | ChannelWriteEntry)[] = [\n      {\n        value: PASSTHROUGH,\n        mapper: new RunnableCallable({\n          func:\n            outputKeys.length && outputKeys[0] === ROOT\n              ? _getRoot\n              : _getUpdates,\n          trace: false,\n          recurse: false,\n        }),\n      },\n    ];\n\n    // add node and output channel\n    if (key === START) {\n      this.nodes[key] = new PregelNode<S, U>({\n        tags: [TAG_HIDDEN],\n        triggers: [START],\n        channels: [START],\n        writers: [new ChannelWrite(stateWriteEntries, [TAG_HIDDEN])],\n      });\n    } else {\n      const inputDefinition = node?.input ?? this.builder._schemaDefinition;\n      const inputValues = Object.fromEntries(\n        Object.keys(this.builder._schemaDefinitions.get(inputDefinition)).map(\n          (k) => [k, k]\n        )\n      );\n      const isSingleInput =\n        Object.keys(inputValues).length === 1 && ROOT in inputValues;\n      const branchChannel = `branch:to:${key}` as string | N;\n      this.channels[branchChannel] = node?.defer\n        ? new LastValueAfterFinish()\n        : new EphemeralValue(false);\n      this.nodes[key] = new PregelNode<S, U>({\n        triggers: [branchChannel],\n        // read state keys\n        channels: isSingleInput ? Object.keys(inputValues) : inputValues,\n        // publish to state keys\n        writers: [new ChannelWrite(stateWriteEntries, [TAG_HIDDEN])],\n        mapper: isSingleInput\n          ? undefined\n          : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (input: Record<string, any>) => {\n              return Object.fromEntries(\n                Object.entries(input).filter(([k]) => k in inputValues)\n              );\n            },\n        bound: node?.runnable,\n        metadata: node?.metadata,\n        retryPolicy: node?.retryPolicy,\n        cachePolicy: node?.cachePolicy,\n        subgraphs: node?.subgraphs,\n        ends: node?.ends,\n      });\n    }\n  }\n\n  attachEdge(starts: N | N[] | \"__start__\", end: N | \"__end__\"): void {\n    if (end === END) return;\n    if (typeof starts === \"string\") {\n      this.nodes[starts].writers.push(\n        new ChannelWrite(\n          [{ channel: `branch:to:${end}`, value: null }],\n          [TAG_HIDDEN]\n        )\n      );\n    } else if (Array.isArray(starts)) {\n      const channelName = `join:${starts.join(\"+\")}:${end}`;\n      // register channel\n      this.channels[channelName as string | N] = this.builder.nodes[end].defer\n        ? new NamedBarrierValueAfterFinish(new Set(starts))\n        : new NamedBarrierValue(new Set(starts));\n      // subscribe to channel\n      this.nodes[end].triggers.push(channelName);\n      // publish to channel\n      for (const start of starts) {\n        this.nodes[start].writers.push(\n          new ChannelWrite(\n            [{ channel: channelName, value: start }],\n            [TAG_HIDDEN]\n          )\n        );\n      }\n    }\n  }\n\n  attachBranch(\n    start: N | typeof START,\n    _: string,\n    branch: Branch<S, N>,\n    options: { withReader?: boolean } = { withReader: true }\n  ): void {\n    const branchWriter = async (\n      packets: (string | Send)[],\n      config: LangGraphRunnableConfig\n    ) => {\n      const filteredPackets = packets.filter((p) => p !== END);\n      if (!filteredPackets.length) return;\n\n      const writes: (ChannelWriteEntry | Send)[] = filteredPackets.map((p) => {\n        if (_isSend(p)) return p;\n        return { channel: p === END ? p : `branch:to:${p}`, value: start };\n      });\n      await ChannelWrite.doWrite(\n        { ...config, tags: (config.tags ?? []).concat([TAG_HIDDEN]) },\n        writes\n      );\n    };\n    // attach branch publisher\n    this.nodes[start].writers.push(\n      branch.run(\n        branchWriter,\n        // reader\n        options.withReader\n          ? (config) =>\n              ChannelRead.doRead<S>(\n                config,\n                this.streamChannels ?? this.outputChannels,\n                true\n              )\n          : undefined\n      )\n    );\n  }\n\n  protected async _validateInput(\n    input: ExtractUpdateType<I, ExtractStateType<I>>\n  ): Promise<ExtractUpdateType<I, ExtractStateType<I>>> {\n    if (input == null) return input;\n\n    const inputDef = this.builder._inputRuntimeDefinition;\n    const schemaDef = this.builder._schemaRuntimeDefinition;\n\n    // Determine which schema to use for validation\n    // Priority: inputDef (if it's a validatable schema), otherwise fall back to schemaDef\n\n    // Handle StateSchema validation for input schema\n    if (StateSchema.isInstance(inputDef)) {\n      if (isCommand(input)) {\n        const parsedInput = input;\n        if (input.update) {\n          parsedInput.update = await inputDef.validateInput(\n            Array.isArray(input.update)\n              ? Object.fromEntries(input.update)\n              : input.update\n          );\n        }\n        return parsedInput;\n      }\n      return await inputDef.validateInput(input);\n    }\n\n    // Handle StateSchema validation for state schema (when input is partial state)\n    if (inputDef === PartialStateSchema && StateSchema.isInstance(schemaDef)) {\n      if (isCommand(input)) {\n        const parsedInput = input;\n        if (input.update) {\n          parsedInput.update = await schemaDef.validateInput(\n            Array.isArray(input.update)\n              ? Object.fromEntries(input.update)\n              : input.update\n          );\n        }\n        return parsedInput;\n      }\n      return await schemaDef.validateInput(input);\n    }\n\n    // Handle InteropZodObject validation\n    const schema = (() => {\n      const apply = (schema: InteropZodObject | undefined) => {\n        if (schema == null) return undefined;\n        return this._metaRegistry.getExtendedChannelSchemas(schema, {\n          withReducerSchema: true,\n        });\n      };\n\n      if (isInteropZodObject(inputDef)) return apply(inputDef);\n      if (inputDef === PartialStateSchema) {\n        if (isInteropZodObject(schemaDef)) {\n          return interopZodObjectPartial(apply(schemaDef)!);\n        }\n        return undefined;\n      }\n      return undefined;\n    })();\n\n    if (isCommand(input)) {\n      const parsedInput = input;\n      if (input.update && schema != null)\n        parsedInput.update = interopParse(schema, input.update);\n      return parsedInput;\n    }\n    if (schema != null) return interopParse(schema, input);\n    return input;\n  }\n\n  public isInterrupted(input: unknown): input is {\n    [INTERRUPT]: Interrupt<InferInterruptInputType<InterruptType>>[];\n  } {\n    return isInterrupted(input);\n  }\n\n  protected async _validateContext(\n    config: Partial<Record<string, unknown>>\n  ): Promise<Partial<Record<string, unknown>>> {\n    const configSchema = this.builder._configRuntimeSchema;\n    if (isInteropZodObject(configSchema)) interopParse(configSchema, config);\n    return config;\n  }\n}\n\n/**\n * Check if value is a legacy StateGraphArgs with channels.\n * @internal\n * @deprecated Use StateGraphInit instead\n */\nfunction isStateGraphArgs<Channels extends object | unknown>(\n  obj: unknown | StateGraphArgs<Channels>\n): obj is StateGraphArgs<Channels> {\n  return (\n    typeof obj === \"object\" &&\n    obj !== null &&\n    (obj as StateGraphArgs<Channels>).channels !== undefined\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction _controlBranch(value: any): (string | Send)[] {\n  if (_isSend(value)) {\n    return [value];\n  }\n  const commands = [];\n  if (isCommand(value)) {\n    commands.push(value);\n  } else if (Array.isArray(value)) {\n    commands.push(...value.filter(isCommand));\n  }\n  const destinations: (string | Send)[] = [];\n\n  for (const command of commands) {\n    if (command.graph === Command.PARENT) {\n      throw new ParentCommand(command);\n    }\n\n    if (_isSend(command.goto)) {\n      destinations.push(command.goto);\n    } else if (typeof command.goto === \"string\") {\n      destinations.push(command.goto);\n    } else {\n      if (Array.isArray(command.goto)) {\n        destinations.push(...command.goto);\n      }\n    }\n  }\n  return destinations;\n}\n\nfunction _getControlBranch() {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const CONTROL_BRANCH_PATH = new RunnableCallable<any, (string | Send)[]>({\n    func: _controlBranch,\n    tags: [TAG_HIDDEN],\n    trace: false,\n    recurse: false,\n    name: \"<control_branch>\",\n  });\n  return new Branch({\n    path: CONTROL_BRANCH_PATH,\n  });\n}\n"],"mappings":"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"}