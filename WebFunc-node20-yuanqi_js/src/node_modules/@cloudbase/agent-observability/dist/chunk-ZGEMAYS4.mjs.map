{"version":3,"sources":["../src/core/constants.ts","../src/core/attributes.ts","../src/core/tracerProvider.ts","../src/core/spanWrapper.ts","../src/index.ts"],"sourcesContent":["/**\n * OTEL attribute constants for AG-Kit observability.\n *\n * Uses OpenInference semantic conventions where applicable:\n * https://github.com/Arize-ai/openinference/tree/main/spec\n *\n * Falls back to AG-Kit specific attributes where OpenInference\n * doesn't define a standard.\n *\n * @module\n */\n\nimport {\n  SemanticConventions,\n  OpenInferenceSpanKind,\n} from \"@arizeai/openinference-semantic-conventions\";\n\n// Re-export OpenInference types for convenience\nexport { OpenInferenceSpanKind };\n\n/**\n * SDK information\n */\nexport const OBSERVABILITY_TRACER_NAME = \"agkit-tracer\";\nexport const OBSERVABILITY_SDK_NAME = \"@agkit/observability\";\n// Version will be injected from package.json\n\n/**\n * Combined attribute namespace for internal use\n * Provides a single namespace for all OTEL attributes used by AG-Kit\n *\n * Combines OpenInference SemanticConventions with AG-Kit specific attributes\n */\nexport const OtelSpanAttributes = {\n  // OpenInference - re-export all standard conventions\n  ...SemanticConventions,\n\n  // AG-Kit Trace attributes (non-standard)\n  TRACE_NAME: \"trace.name\",\n  TRACE_TAGS: \"trace.tags\",\n  TRACE_PUBLIC: \"trace.public\",\n  TRACE_METADATA: \"trace.metadata\",\n  TRACE_INPUT: \"trace.input\",\n  TRACE_OUTPUT: \"trace.output\",\n\n  // AG-Kit Observation attributes (non-standard)\n  OBSERVATION_TYPE: \"observation.type\",\n  OBSERVATION_LEVEL: \"observation.level\",\n  OBSERVATION_STATUS_MESSAGE: \"observation.status_message\",\n  OBSERVATION_INPUT: \"observation.input\",\n  OBSERVATION_OUTPUT: \"observation.output\",\n  OBSERVATION_METADATA: \"observation.metadata\",\n\n  // AG-Kit LLM-specific (non-standard)\n  LLM_COMPLETION_START_TIME: \"llm.completion_start_time\",\n  LLM_MODEL_PARAMETERS: \"llm.model_parameters\",\n  LLM_USAGE_DETAILS: \"llm.usage_details\",\n  LLM_COST_DETAILS: \"llm.cost_details\",\n\n  // AG-Kit Retriever-specific (non-standard)\n  RETRIEVER_NAME: \"retriever.name\",\n  RETRIEVER_QUERY: \"retriever.query\",\n  RETRIEVER_INDEX_ID: \"retriever.index_id\",\n  RETRIEVER_TOP_K: \"retriever.top_k\",\n\n  // AG-Kit General (non-standard)\n  ENVIRONMENT: \"environment\",\n  RELEASE: \"release\",\n  VERSION: \"version\",\n} as const;\n\n/**\n * Type for the OtelSpanAttributes object values\n */\nexport type OtelSpanAttributeValues = typeof OtelSpanAttributes[keyof typeof OtelSpanAttributes];\n","import { OBSERVABILITY_TRACER_NAME, OtelSpanAttributes } from \"./constants.js\";\nimport { SemanticConventions } from \"@arizeai/openinference-semantic-conventions\";\nimport { ObservationAttributes, TraceAttributes, ObservationType } from \"../types.js\";\nimport { type Attributes } from \"@opentelemetry/api\";\n\n/**\n * Creates OpenTelemetry attributes from trace attributes.\n *\n * Converts user-friendly trace attributes into OpenTelemetry attribute format\n * using OpenInference semantic conventions where applicable.\n *\n * @param attributes - Trace attributes to convert\n * @returns OpenTelemetry attributes object\n *\n * @example\n * ```typescript\n * const otelAttributes = createTraceAttributes({\n *   name: 'user-workflow',\n *   userId: 'user-123',\n *   sessionId: 'session-456',\n *   tags: ['checkout', 'payment']\n * });\n * ```\n *\n * @public\n */\nexport function createTraceAttributes({\n  name,\n  userId,\n  sessionId,\n  version,\n  release,\n  input,\n  output,\n  metadata,\n  tags,\n  environment,\n  public: isPublic,\n}: TraceAttributes = {}): Attributes {\n  const attributes = {\n    [OtelSpanAttributes.TRACE_NAME]: name,\n    // Use OpenInference standard attributes for user and session\n    [OtelSpanAttributes.USER_ID]: userId,\n    [OtelSpanAttributes.SESSION_ID]: sessionId,\n    [OtelSpanAttributes.VERSION]: version,\n    [OtelSpanAttributes.RELEASE]: release,\n    [OtelSpanAttributes.TRACE_INPUT]: _serialize(input),\n    [OtelSpanAttributes.TRACE_OUTPUT]: _serialize(output),\n    [OtelSpanAttributes.TRACE_TAGS]: tags,\n    [OtelSpanAttributes.ENVIRONMENT]: environment,\n    [OtelSpanAttributes.TRACE_PUBLIC]: isPublic,\n    ..._flattenAndSerializeMetadata(metadata, OtelSpanAttributes.TRACE_METADATA),\n  };\n\n  return Object.fromEntries(\n    Object.entries(attributes).filter(([_, v]) => v != null),\n  );\n}\n\n/**\n * Creates OpenTelemetry attributes from observation attributes.\n *\n * Maps observation attributes to OpenInference semantic conventions:\n * - Uses `openinference.span.kind` for span type\n * - Uses `llm.*` for LLM-specific attributes\n * - Uses `tool.*` for tool-specific attributes\n * - Falls back to `agkit.observation.*` for non-standard attributes\n *\n * @param type - Observation type (llm, tool, chain, etc.)\n * @param attributes - Observation attributes to convert\n * @returns OpenTelemetry attributes object\n *\n * @public\n */\nexport function createObservationAttributes(\n  type: ObservationType,\n  attributes: ObservationAttributes,\n): Attributes {\n  const {\n    metadata,\n    input,\n    output,\n    level,\n    statusMessage,\n    version,\n    completionStartTime,\n    model,\n    modelParameters,\n    usageDetails,\n  } = attributes;\n\n  // Base attributes for all observation types\n  const otelAttributes: Attributes = {\n    [SemanticConventions.OPENINFERENCE_SPAN_KIND]: type.toUpperCase(),\n    [OtelSpanAttributes.OBSERVATION_TYPE]: type,\n    [OtelSpanAttributes.OBSERVATION_LEVEL]: level,\n    [OtelSpanAttributes.OBSERVATION_STATUS_MESSAGE]: statusMessage,\n    [OtelSpanAttributes.VERSION]: version,\n    // Use OpenInference input.value convention\n    [SemanticConventions.INPUT_VALUE]: _serialize(input),\n    // Also set legacy agkit.observation.input for compatibility\n    [OtelSpanAttributes.OBSERVATION_INPUT]: _serialize(input),\n    // Use OpenInference output.value convention\n    [SemanticConventions.OUTPUT_VALUE]: _serialize(output),\n    // Also set legacy agkit.observation.output for compatibility\n    [OtelSpanAttributes.OBSERVATION_OUTPUT]: _serialize(output),\n  };\n\n  // LLM-specific attributes\n  if (type === \"llm\") {\n    if (model) {\n      otelAttributes[SemanticConventions.LLM_MODEL_NAME] = model;\n    }\n    if (modelParameters) {\n      otelAttributes[SemanticConventions.LLM_INVOCATION_PARAMETERS] =\n        _serialize(modelParameters);\n      // Also set agkit.llm.model_parameters for compatibility\n      otelAttributes[OtelSpanAttributes.LLM_MODEL_PARAMETERS] =\n        _serialize(modelParameters);\n    }\n    if (usageDetails) {\n      // Map to OpenInference llm.token_count.* attributes\n      if (typeof usageDetails === \"object\") {\n        const usage = usageDetails as Record<string, number>;\n        if (usage.promptTokens !== undefined) {\n          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_PROMPT] =\n            usage.promptTokens;\n        }\n        if (usage.completionTokens !== undefined) {\n          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_COMPLETION] =\n            usage.completionTokens;\n        }\n        if (usage.totalTokens !== undefined) {\n          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_TOTAL] =\n            usage.totalTokens;\n        }\n      }\n      // Also set legacy agkit.llm.usage_details for compatibility\n      otelAttributes[OtelSpanAttributes.LLM_USAGE_DETAILS] =\n        _serialize(usageDetails);\n    }\n    if (completionStartTime) {\n      otelAttributes[OtelSpanAttributes.LLM_COMPLETION_START_TIME] =\n        _serialize(completionStartTime);\n    }\n  }\n\n  // Embedding-specific attributes\n  if (type === \"embedding\") {\n    if (model) {\n      otelAttributes[SemanticConventions.EMBEDDING_MODEL_NAME] = model;\n    }\n    if (modelParameters) {\n      otelAttributes[SemanticConventions.LLM_INVOCATION_PARAMETERS] =\n        _serialize(modelParameters);\n    }\n  }\n\n  // Add metadata (use OpenInference metadata convention)\n  const metadataAttrs = _flattenAndSerializeMetadata(\n    metadata,\n    SemanticConventions.METADATA,\n  );\n  Object.assign(otelAttributes, metadataAttrs);\n\n  // Also add agkit.observation.metadata for compatibility\n  const obsetvabilityMetadataAttrs = _flattenAndSerializeMetadata(\n    metadata,\n    OtelSpanAttributes.OBSERVATION_METADATA\n  );\n  Object.assign(otelAttributes, obsetvabilityMetadataAttrs);\n\n  // Filter out null/undefined values\n  return Object.fromEntries(\n    Object.entries(otelAttributes).filter(([_, v]) => v != null),\n  );\n}\n\n/**\n * Safely serializes an object to JSON string.\n *\n * @param obj - Object to serialize\n * @returns JSON string or undefined if null/undefined\n * @internal\n */\nfunction _serialize(obj: unknown): string | undefined {\n  try {\n    if (typeof obj === \"string\") return obj;\n    if (obj instanceof Date) return obj.toISOString();\n    return obj != null ? JSON.stringify(obj) : undefined;\n  } catch {\n    return \"<failed to serialize>\";\n  }\n}\n\n/**\n * Flattens and serializes metadata into OpenTelemetry attribute format.\n *\n * Converts nested metadata objects into dot-notation attribute keys.\n * For example, `{ database: { host: 'localhost' } }` becomes\n * `{ 'metadata.database.host': 'localhost' }` (or 'agkit.observation.metadata.database.host').\n *\n * @param metadata - Metadata object to flatten\n * @param prefix - Attribute prefix (e.g., 'metadata' or 'agkit.observation.metadata')\n * @returns Flattened metadata attributes\n * @internal\n */\nfunction _flattenAndSerializeMetadata(\n  metadata: unknown,\n  prefix: string,\n): Record<string, string> {\n  const metadataAttributes: Record<string, string> = {};\n\n  if (metadata === undefined || metadata === null) {\n    return metadataAttributes;\n  }\n\n  if (typeof metadata !== \"object\" || Array.isArray(metadata)) {\n    const serialized = _serialize(metadata);\n    if (serialized) {\n      metadataAttributes[prefix] = serialized;\n    }\n  } else {\n    for (const [key, value] of Object.entries(metadata)) {\n      const serialized = typeof value === \"string\" ? value : _serialize(value);\n      if (serialized) {\n        metadataAttributes[`${prefix}.${key}`] = serialized;\n      }\n    }\n  }\n\n  return metadataAttributes;\n}\n","import { TracerProvider, trace, context } from \"@opentelemetry/api\";\n\nconst OBSERVABILITY_GLOBAL_SYMBOL = Symbol.for(\"observability\");\n\ntype ObservabilityGlobalState = {\n  isolatedTracerProvider: TracerProvider | null;\n};\n\nfunction createState(): ObservabilityGlobalState {\n  return {\n    isolatedTracerProvider: null,\n  };\n}\n\ninterface GlobalThis {\n  [OBSERVABILITY_GLOBAL_SYMBOL]?: ObservabilityGlobalState;\n}\n\n/**\n * Gets the global state for tracing observability.\n *\n * @returns The global state object\n * @internal\n */\nfunction getObservabilityGlobalState(): ObservabilityGlobalState {\n  const initialState = createState();\n\n  try {\n    const g = globalThis as typeof globalThis & GlobalThis;\n\n    if (typeof g !== \"object\" || g === null) {\n      console.warn(\n        \"[Observability] globalThis is not available, using fallback state\",\n      );\n      return initialState;\n    }\n\n    if (!g[OBSERVABILITY_GLOBAL_SYMBOL]) {\n      Object.defineProperty(g, OBSERVABILITY_GLOBAL_SYMBOL, {\n        value: initialState,\n        writable: false,\n        configurable: false,\n        enumerable: false,\n      });\n    }\n\n    return g[OBSERVABILITY_GLOBAL_SYMBOL]!;\n  } catch (err) {\n    console.error(\n      `[Observability] Failed to access global state: ${err instanceof Error ? err.message : String(err)}`,\n    );\n    return initialState;\n  }\n}\n\n/**\n * Sets an isolated TracerProvider for tracing tracing operations.\n *\n * This allows tracing to use its own TracerProvider instance, separate from\n * the global OpenTelemetry TracerProvider.\n *\n * Note: While this isolates span processing and export, it does NOT provide\n * complete trace isolation. OpenTelemetry context (trace IDs, parent spans)\n * is still shared between the global and isolated providers.\n *\n * @param provider - The TracerProvider instance to use, or null to clear\n *\n * @example\n * ```typescript\n * import { NodeTracerProvider } from '@opentelemetry/sdk-trace-node';\n * import { setTracerProvider } from './observability';\n *\n * const provider = new NodeTracerProvider();\n * setTracerProvider(provider);\n * ```\n *\n * @public\n */\nexport function setTracerProvider(provider: TracerProvider | null) {\n  getObservabilityGlobalState().isolatedTracerProvider = provider;\n}\n\n/**\n * Gets the TracerProvider for tracing tracing operations.\n *\n * Returns the isolated TracerProvider if one has been set via setTracerProvider(),\n * otherwise falls back to the global OpenTelemetry TracerProvider.\n *\n * @returns The TracerProvider instance to use for tracing tracing\n *\n * @example\n * ```typescript\n * import { getTracerProvider } from './observability';\n *\n * const provider = getTracerProvider();\n * const tracer = provider.getTracer('my-tracer', '1.0.0');\n * ```\n *\n * @public\n */\nexport function getTracerProvider(): TracerProvider {\n  const { isolatedTracerProvider } = getObservabilityGlobalState();\n\n  if (isolatedTracerProvider) return isolatedTracerProvider;\n\n  return trace.getTracerProvider();\n}\n\n/**\n * Gets the OpenTelemetry tracer instance for tracing.\n *\n * Returns a tracer specifically configured for tracing with the correct\n * tracer name and version.\n *\n * @returns The tracing OpenTelemetry tracer instance\n *\n * @example\n * ```typescript\n * import { getTracer } from './observability';\n *\n * const tracer = getTracer();\n * const span = tracer.startSpan('my-operation');\n * ```\n *\n * @public\n */\nexport function getTracer() {\n  return getTracerProvider().getTracer(\n    OBSERVABILITY_SDK_NAME,\n    OBSERVABILITY_SDK_VERSION\n  );\n}\n\n// SDK version - could be read from package.json in production\nconst OBSERVABILITY_SDK_NAME = \"ag-kit-observability\";\nconst OBSERVABILITY_SDK_VERSION = \"0.1.0\";\n","import { Span, TimeInput } from \"@opentelemetry/api\";\n\nimport { createObservationAttributes, createTraceAttributes } from \"./attributes.js\";\nimport { getTracer } from \"./tracerProvider.js\";\nimport {\n  BaseSpanAttributes,\n  LLMAttributes,\n  TraceAttributes,\n  ObservationType,\n} from \"../types.js\";\nimport type {\n  ToolAttributes,\n  AgentAttributes,\n  ChainAttributes,\n  RetrieverAttributes,\n  RerankerAttributes,\n  EvaluatorAttributes,\n  GuardrailAttributes,\n  EmbeddingAttributes,\n  ObservationAttributes,\n} from \"../types.js\";\n\n/**\n * Union type representing any observation wrapper.\n *\n * @public\n */\nexport type Observation =\n  | ObservationSpan\n  | ObservationLLM\n  | ObservationEmbedding\n  | ObservationAgent\n  | ObservationTool\n  | ObservationChain\n  | ObservationRetriever\n  | ObservationReranker\n  | ObservationEvaluator\n  | ObservationGuardrail;\n\n/**\n * Parameters for creating an observation wrapper.\n *\n * @internal\n */\ntype ObservationParams = {\n  otelSpan: Span;\n  type: ObservationType;\n  attributes?: BaseSpanAttributes | LLMAttributes;\n};\n\n/**\n * Base class for all observation wrappers.\n *\n * Provides common functionality for all observation types including:\n * - OpenTelemetry span integration\n * - Unique identification (span ID, trace ID)\n * - Lifecycle management (update, end)\n * - Trace context management\n * - Child observation creation\n *\n * @internal\n */\nabstract class BaseObservation {\n  /** The underlying OpenTelemetry span */\n  public readonly otelSpan: Span;\n  /** The observation type */\n  public readonly type: ObservationType;\n  /** The span ID from the OpenTelemetry span context */\n  public id: string;\n  /** The trace ID from the OpenTelemetry span context */\n  public traceId: string;\n\n  constructor(params: ObservationParams) {\n    this.otelSpan = params.otelSpan;\n    this.id = params.otelSpan.spanContext().spanId;\n    this.traceId = params.otelSpan.spanContext().traceId;\n    this.type = params.type;\n\n    if (params.attributes) {\n      this.otelSpan.setAttributes(\n        createObservationAttributes(params.type, params.attributes),\n      );\n    }\n  }\n\n  /** Gets the AG-Kit OpenTelemetry tracer instance */\n  protected get tracer() {\n    return getTracer();\n  }\n\n  /**\n   * Ends the observation, marking it as complete.\n   *\n   * @param endTime - Optional end time, defaults to current time\n   */\n  public end(endTime?: TimeInput) {\n    this.otelSpan.end(endTime);\n  }\n\n  /**\n   * Updates the OTEL span attributes.\n   *\n   * @param attributes - Attributes to update\n   * @internal\n   */\n  updateOtelSpanAttributes(attributes: ObservationAttributes) {\n    this.otelSpan.setAttributes(\n      createObservationAttributes(this.type, attributes),\n    );\n  }\n\n  /**\n   * Updates the parent trace with new attributes.\n   *\n   * @param attributes - Trace attributes to set\n   * @returns This observation for method chaining\n   */\n  public updateTrace(attributes: TraceAttributes) {\n    this.otelSpan.setAttributes(createTraceAttributes(attributes));\n    return this;\n  }\n\n  /**\n   * Creates a new child observation within this observation's context.\n   *\n   * @param name - Name for the child observation\n   * @param attributes - Type-specific attributes\n   * @param options - Configuration including observation type\n   * @returns Child observation instance\n   */\n  public startObservation(\n    name: string,\n    attributes: LLMAttributes,\n    options: { asType: \"llm\" },\n  ): ObservationLLM;\n  public startObservation(\n    name: string,\n    attributes: EmbeddingAttributes,\n    options: { asType: \"embedding\" },\n  ): ObservationEmbedding;\n  public startObservation(\n    name: string,\n    attributes: AgentAttributes,\n    options: { asType: \"agent\" },\n  ): ObservationAgent;\n  public startObservation(\n    name: string,\n    attributes: ToolAttributes,\n    options: { asType: \"tool\" },\n  ): ObservationTool;\n  public startObservation(\n    name: string,\n    attributes: ChainAttributes,\n    options: { asType: \"chain\" },\n  ): ObservationChain;\n  public startObservation(\n    name: string,\n    attributes: RetrieverAttributes,\n    options: { asType: \"retriever\" },\n  ): ObservationRetriever;\n  public startObservation(\n    name: string,\n    attributes: RerankerAttributes,\n    options: { asType: \"reranker\" },\n  ): ObservationReranker;\n  public startObservation(\n    name: string,\n    attributes: EvaluatorAttributes,\n    options: { asType: \"evaluator\" },\n  ): ObservationEvaluator;\n  public startObservation(\n    name: string,\n    attributes: GuardrailAttributes,\n    options: { asType: \"guardrail\" },\n  ): ObservationGuardrail;\n  public startObservation(\n    name: string,\n    attributes?: BaseSpanAttributes,\n    options?: { asType?: \"span\" },\n  ): ObservationSpan;\n  public startObservation(\n    name: string,\n    attributes?:\n      | BaseSpanAttributes\n      | LLMAttributes\n      | ToolAttributes\n      | AgentAttributes\n      | ChainAttributes\n      | RetrieverAttributes\n      | RerankerAttributes\n      | EvaluatorAttributes\n      | GuardrailAttributes\n      | EmbeddingAttributes,\n    options?: { asType?: ObservationType },\n  ): Observation {\n    // Import here to avoid circular dependency\n    const { startObservation: startObs } = require(\"../index.js\");\n    const { asType = \"span\" } = options || {};\n\n    return startObs(name, attributes, {\n      asType: asType as \"span\",\n      parentSpanContext: this.otelSpan.spanContext(),\n    });\n  }\n}\n\n// Type-specific observation classes\n\ntype ObservationSpanParams = {\n  otelSpan: Span;\n  attributes?: BaseSpanAttributes;\n};\n\n/**\n * General-purpose observation for tracking operations.\n *\n * @public\n */\nexport class ObservationSpan extends BaseObservation {\n  constructor(params: ObservationSpanParams) {\n    super({ ...params, type: \"span\" });\n  }\n\n  public update(attributes: BaseSpanAttributes): ObservationSpan {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationLLMParams = {\n  otelSpan: Span;\n  attributes?: LLMAttributes;\n};\n\n/**\n * LLM observation for tracking language model calls.\n *\n * @public\n */\nexport class ObservationLLM extends BaseObservation {\n  constructor(params: ObservationLLMParams) {\n    super({ ...params, type: \"llm\" });\n  }\n\n  public update(attributes: LLMAttributes): ObservationLLM {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationEmbeddingParams = {\n  otelSpan: Span;\n  attributes?: EmbeddingAttributes;\n};\n\n/**\n * Embedding observation for tracking embedding operations.\n *\n * @public\n */\nexport class ObservationEmbedding extends BaseObservation {\n  constructor(params: ObservationEmbeddingParams) {\n    super({ ...params, type: \"embedding\" });\n  }\n\n  public update(attributes: EmbeddingAttributes): ObservationEmbedding {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationAgentParams = {\n  otelSpan: Span;\n  attributes?: AgentAttributes;\n};\n\n/**\n * Agent observation for tracking AI agent workflows.\n *\n * @public\n */\nexport class ObservationAgent extends BaseObservation {\n  constructor(params: ObservationAgentParams) {\n    super({ ...params, type: \"agent\" });\n  }\n\n  public update(attributes: AgentAttributes): ObservationAgent {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationToolParams = {\n  otelSpan: Span;\n  attributes?: ToolAttributes;\n};\n\n/**\n * Tool observation for tracking tool calls.\n *\n * @public\n */\nexport class ObservationTool extends BaseObservation {\n  constructor(params: ObservationToolParams) {\n    super({ ...params, type: \"tool\" });\n  }\n\n  public update(attributes: ToolAttributes): ObservationTool {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationChainParams = {\n  otelSpan: Span;\n  attributes?: ChainAttributes;\n};\n\n/**\n * Chain observation for tracking multi-step workflows.\n *\n * @public\n */\nexport class ObservationChain extends BaseObservation {\n  constructor(params: ObservationChainParams) {\n    super({ ...params, type: \"chain\" });\n  }\n\n  public update(attributes: ChainAttributes): ObservationChain {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationRetrieverParams = {\n  otelSpan: Span;\n  attributes?: RetrieverAttributes;\n};\n\n/**\n * Retriever observation for tracking document retrieval.\n *\n * @public\n */\nexport class ObservationRetriever extends BaseObservation {\n  constructor(params: ObservationRetrieverParams) {\n    super({ ...params, type: \"retriever\" });\n  }\n\n  public update(attributes: RetrieverAttributes): ObservationRetriever {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationRerankerParams = {\n  otelSpan: Span;\n  attributes?: RerankerAttributes;\n};\n\n/**\n * Reranker observation for tracking reranking operations.\n *\n * @public\n */\nexport class ObservationReranker extends BaseObservation {\n  constructor(params: ObservationRerankerParams) {\n    super({ ...params, type: \"reranker\" });\n  }\n\n  public update(attributes: RerankerAttributes): ObservationReranker {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationEvaluatorParams = {\n  otelSpan: Span;\n  attributes?: EvaluatorAttributes;\n};\n\n/**\n * Evaluator observation for tracking evaluation operations.\n *\n * @public\n */\nexport class ObservationEvaluator extends BaseObservation {\n  constructor(params: ObservationEvaluatorParams) {\n    super({ ...params, type: \"evaluator\" });\n  }\n\n  public update(attributes: EvaluatorAttributes): ObservationEvaluator {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationGuardrailParams = {\n  otelSpan: Span;\n  attributes?: GuardrailAttributes;\n};\n\n/**\n * Guardrail observation for tracking safety checks.\n *\n * @public\n */\nexport class ObservationGuardrail extends BaseObservation {\n  constructor(params: ObservationGuardrailParams) {\n    super({ ...params, type: \"guardrail\" });\n  }\n\n  public update(attributes: GuardrailAttributes): ObservationGuardrail {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n","/**\n * Observability - OpenTelemetry-based tracing with OpenInference semantic conventions\n *\n * @packageDocumentation\n */\n\nimport { trace, context, TimeInput, SpanStatusCode, Span, SpanContext } from \"@opentelemetry/api\";\n\nimport {\n  createObservationAttributes,\n  createTraceAttributes,\n} from \"./core/attributes.js\";\nimport {\n  ObservationSpan,\n  ObservationLLM,\n  ObservationEmbedding,\n  ObservationAgent,\n  ObservationTool,\n  ObservationChain,\n  ObservationRetriever,\n  ObservationReranker,\n  ObservationEvaluator,\n  ObservationGuardrail,\n  type Observation,\n} from \"./core/spanWrapper.js\";\nimport { getTracer } from \"./core/tracerProvider.js\";\nimport {\n  ObservationType,\n  ObservationLevel,\n  BaseSpanAttributes,\n  LLMAttributes,\n  ToolAttributes,\n  AgentAttributes,\n  ChainAttributes,\n  RetrieverAttributes,\n  RerankerAttributes,\n  EvaluatorAttributes,\n  GuardrailAttributes,\n  EmbeddingAttributes,\n  ObservationAttributes,\n  TraceAttributes,\n} from \"./types.js\";\n\n// Export types\nexport type {\n  ObservationType,\n  ObservationLevel,\n  BaseSpanAttributes,\n  LLMAttributes,\n  ToolAttributes,\n  AgentAttributes,\n  ChainAttributes,\n  RetrieverAttributes,\n  RerankerAttributes,\n  EvaluatorAttributes,\n  GuardrailAttributes,\n  EmbeddingAttributes,\n  ObservationAttributes,\n  TraceAttributes,\n};\n\n// Export observation classes\nexport {\n  ObservationSpan,\n  ObservationLLM,\n  ObservationEmbedding,\n  ObservationAgent,\n  ObservationTool,\n  ObservationChain,\n  ObservationRetriever,\n  ObservationReranker,\n  ObservationEvaluator,\n  ObservationGuardrail,\n};\n\n// Export observation union type\nexport type { Observation };\n\n// Export core functions\nexport {\n  createTraceAttributes,\n  createObservationAttributes,\n} from \"./core/attributes.js\";\nexport {\n  setTracerProvider,\n  getTracerProvider,\n  getTracer,\n} from \"./core/tracerProvider.js\";\n\n/**\n * Options for starting observations (spans).\n *\n * @public\n */\nexport type StartObservationOptions = {\n  /** Custom start time for the observation */\n  startTime?: Date;\n  /** Parent span context to attach this observation to */\n  parentSpanContext?: SpanContext;\n};\n\n/**\n * Options for startObservation function.\n *\n * @public\n */\nexport type StartObservationOpts = StartObservationOptions & {\n  /** Type of observation to create. Defaults to 'span' */\n  asType?: ObservationType;\n};\n\n/**\n * Creates an OpenTelemetry span with the AG-Kit tracer.\n *\n * @param params - Parameters for span creation\n * @returns The created OpenTelemetry span\n * @internal\n */\nfunction createOtelSpan(params: {\n  name: string;\n  startTime?: TimeInput;\n  parentSpanContext?: SpanContext;\n}): Span {\n  return getTracer().startSpan(\n    params.name,\n    { startTime: params.startTime },\n    createParentContext(params.parentSpanContext),\n  );\n}\n\n/**\n * Creates a parent context from a span context.\n *\n * @param parentSpanContext - The span context to use as parent\n * @returns The created context or undefined if no parent provided\n * @internal\n */\nfunction createParentContext(\n  parentSpanContext?: SpanContext,\n): ReturnType<typeof trace.setSpanContext> | undefined {\n  if (!parentSpanContext) return;\n  return trace.setSpanContext(context.active(), parentSpanContext);\n}\n\n// Function overloads for proper type inference\n// Generic overload for dynamic asType (returns Observation union)\nexport function startObservation(\n  name: string,\n  attributes?: BaseSpanAttributes,\n  options?: StartObservationOpts & { asType?: ObservationType },\n): Observation;\n\n// Type-specific overloads for precise type inference\nexport function startObservation(\n  name: string,\n  attributes: LLMAttributes,\n  options: StartObservationOpts & { asType: \"llm\" },\n): ObservationLLM;\nexport function startObservation(\n  name: string,\n  attributes: EmbeddingAttributes,\n  options: StartObservationOpts & { asType: \"embedding\" },\n): ObservationEmbedding;\nexport function startObservation(\n  name: string,\n  attributes: AgentAttributes,\n  options: StartObservationOpts & { asType: \"agent\" },\n): ObservationAgent;\nexport function startObservation(\n  name: string,\n  attributes: ToolAttributes,\n  options: StartObservationOpts & { asType: \"tool\" },\n): ObservationTool;\nexport function startObservation(\n  name: string,\n  attributes: ChainAttributes,\n  options: StartObservationOpts & { asType: \"chain\" },\n): ObservationChain;\nexport function startObservation(\n  name: string,\n  attributes: RetrieverAttributes,\n  options: StartObservationOpts & { asType: \"retriever\" },\n): ObservationRetriever;\nexport function startObservation(\n  name: string,\n  attributes: RerankerAttributes,\n  options: StartObservationOpts & { asType: \"reranker\" },\n): ObservationReranker;\nexport function startObservation(\n  name: string,\n  attributes: EvaluatorAttributes,\n  options: StartObservationOpts & { asType: \"evaluator\" },\n): ObservationEvaluator;\nexport function startObservation(\n  name: string,\n  attributes: GuardrailAttributes,\n  options: StartObservationOpts & { asType: \"guardrail\" },\n): ObservationGuardrail;\nexport function startObservation(\n  name: string,\n  attributes?: BaseSpanAttributes,\n  options?: StartObservationOpts & { asType?: \"span\" },\n): ObservationSpan;\n\n/**\n * Creates and starts a new AG-Kit observation.\n *\n * Supports multiple observation types with full TypeScript type safety:\n * - **span**: General-purpose operations (default)\n * - **llm**: LLM calls and AI model interactions\n * - **embedding**: Text embedding and vector operations\n * - **agent**: AI agent workflows\n * - **tool**: Individual tool calls\n * - **chain**: Multi-step processes\n * - **retriever**: Document retrieval\n * - **reranker**: Result reranking\n * - **evaluator**: Quality assessment\n * - **guardrail**: Safety checks\n *\n * @param name - Descriptive name for the observation\n * @param attributes - Type-specific attributes\n * @param options - Configuration options\n * @returns Strongly-typed observation object\n *\n * @example\n * ```typescript\n * import { startObservation } from './observability';\n *\n * // LLM observation\n * const llm = startObservation('openai-gpt-4', {\n *   input: [{ role: 'user', content: 'Hello' }],\n *   model: 'gpt-4',\n *   modelParameters: { temperature: 0.7 }\n * }, { asType: 'llm' });\n *\n * // Tool observation\n * const tool = startObservation('weather-api', {\n *   input: { location: 'SF' }\n * }, { asType: 'tool' });\n *\n * // Chain observation\n * const chain = startObservation('rag-pipeline', {\n *   input: { question: 'What is AI?' }\n * }, { asType: 'chain' });\n * ```\n *\n * @public\n */\nexport function startObservation(\n  name: string,\n  attributes?:\n    | BaseSpanAttributes\n    | LLMAttributes\n    | EmbeddingAttributes\n    | AgentAttributes\n    | ToolAttributes\n    | ChainAttributes\n    | RetrieverAttributes\n    | RerankerAttributes\n    | EvaluatorAttributes\n    | GuardrailAttributes,\n  options?: StartObservationOpts,\n): Observation {\n  const { asType = \"span\", ...observationOptions } = options || {};\n\n  const otelSpan = createOtelSpan({\n    name,\n    ...observationOptions,\n  });\n\n  switch (asType) {\n    case \"llm\":\n      return new ObservationLLM({\n        otelSpan,\n        attributes: attributes as LLMAttributes,\n      });\n\n    case \"embedding\":\n      return new ObservationEmbedding({\n        otelSpan,\n        attributes: attributes as EmbeddingAttributes,\n      });\n\n    case \"agent\":\n      return new ObservationAgent({\n        otelSpan,\n        attributes: attributes as AgentAttributes,\n      });\n\n    case \"tool\":\n      return new ObservationTool({\n        otelSpan,\n        attributes: attributes as ToolAttributes,\n      });\n\n    case \"chain\":\n      return new ObservationChain({\n        otelSpan,\n        attributes: attributes as ChainAttributes,\n      });\n\n    case \"retriever\":\n      return new ObservationRetriever({\n        otelSpan,\n        attributes: attributes as RetrieverAttributes,\n      });\n\n    case \"reranker\":\n      return new ObservationReranker({\n        otelSpan,\n        attributes: attributes as RerankerAttributes,\n      });\n\n    case \"evaluator\":\n      return new ObservationEvaluator({\n        otelSpan,\n        attributes: attributes as EvaluatorAttributes,\n      });\n\n    case \"guardrail\":\n      return new ObservationGuardrail({\n        otelSpan,\n        attributes: attributes as GuardrailAttributes,\n      });\n\n    case \"span\":\n    default:\n      return new ObservationSpan({\n        otelSpan,\n        attributes: attributes as BaseSpanAttributes,\n      });\n  }\n}\n\n/**\n * Updates the currently active trace with new attributes.\n *\n * @param attributes - Trace attributes to set\n *\n * @example\n * ```typescript\n * import { updateActiveTrace } from './observability';\n *\n * updateActiveTrace({\n *   name: 'user-workflow',\n *   userId: 'user-123',\n *   tags: ['production']\n * });\n * ```\n *\n * @public\n */\nexport function updateActiveTrace(attributes: TraceAttributes) {\n  const span = trace.getActiveSpan();\n\n  if (!span) {\n    console.warn(\n      \"[Observability] No active OTEL span in context. Skipping trace update.\",\n    );\n    return;\n  }\n\n  span.setAttributes(createTraceAttributes(attributes));\n}\n\n/**\n * Gets the current active trace ID.\n *\n * @returns The trace ID of the currently active span, or undefined\n *\n * @public\n */\nexport function getActiveTraceId(): string | undefined {\n  return trace.getActiveSpan()?.spanContext().traceId;\n}\n\n/**\n * Gets the current active observation ID.\n *\n * @returns The span ID of the currently active span, or undefined\n *\n * @public\n */\nexport function getActiveSpanId(): string | undefined {\n  return trace.getActiveSpan()?.spanContext().spanId;\n}\n\n// ============================================================================\n// Active Observation Functions\n// ============================================================================\n\n/**\n * Options for startActiveObservation.\n *\n * @public\n */\nexport type StartActiveObservationOpts = StartObservationOpts & {\n  /** Whether to automatically end the observation when the function exits. Default: true */\n  endOnExit?: boolean;\n};\n\n/**\n * Wraps a Promise to automatically end the span when it resolves/rejects.\n *\n * @param promise - The promise to wrap\n * @param span - The OpenTelemetry span\n * @param endOnExit - Whether to end the span on exit\n * @returns The wrapped promise\n * @internal\n */\nfunction wrapPromise<T>(\n  promise: Promise<T>,\n  span: Span,\n  endOnExit: boolean | undefined,\n): Promise<T> {\n  return promise.then(\n    (value) => {\n      if (endOnExit !== false) {\n        span.end();\n      }\n      return value;\n    },\n    (err: unknown) => {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err instanceof Error ? err.message : \"Unknown error\",\n      });\n      if (endOnExit !== false) {\n        span.end();\n      }\n      throw err;\n    },\n  );\n}\n\n// Function overloads for startActiveObservation\nexport function startActiveObservation<\n  F extends (observation: ObservationSpan) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationLLM) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationEmbedding) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationAgent) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationTool) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationChain) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationRetriever) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationReranker) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationEvaluator) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationGuardrail) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\n\n/**\n * Creates an observation with automatic lifecycle management.\n *\n * This function creates an observation and executes a function with that observation\n * as a parameter. The observation is automatically ended when the function completes\n * (unless `endOnExit` is set to `false`).\n *\n * Supports both synchronous and asynchronous functions, with automatic error handling.\n *\n * @param name - Descriptive name for the observation\n * @param fn - Function to execute with the observation\n * @param options - Configuration options\n * @returns The result of the function\n *\n * @example\n * ```typescript\n * import { startActiveObservation } from './observability';\n *\n * // Synchronous function\n * const result = startActiveObservation('data-processing', (span) => {\n *   span.update({ input: { data: [1, 2, 3] } });\n *   const processed = data.map(x => x * 2);\n *   span.update({ output: { result: processed } });\n *   return processed;\n * }, { asType: 'span' });\n *\n * // Asynchronous function\n * const embeddings = await startActiveObservation(\n *   'text-embeddings',\n *   async (embedding) => {\n *     embedding.update({\n *       input: { texts: ['Hello', 'World'] },\n *       model: 'text-embedding-ada-002'\n *     });\n *\n *     const vectors = await generateEmbeddings(texts);\n *\n *     embedding.update({ output: { embeddings: vectors } });\n *     return vectors;\n *   },\n *   { asType: 'embedding' }\n * );\n *\n * // Disable automatic ending (for long-running operations)\n * startActiveObservation(\n *   'background-task',\n *   (span) => {\n *     span.update({ input: { taskId: '123' } });\n *     startBackgroundProcess(span);\n *     return 'started';\n *   },\n *   { asType: 'span', endOnExit: false }\n * );\n * ```\n *\n * @see {@link startObservation} for manual observation lifecycle management\n * @see {@link observe} for decorator-style function wrapping\n *\n * @public\n */\nexport function startActiveObservation<\n  F extends (observation: Observation) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F> {\n  const { asType = \"span\", endOnExit, ...observationOptions } = options || {};\n\n  return getTracer().startActiveSpan(\n    name,\n    { startTime: observationOptions?.startTime },\n    createParentContext(observationOptions?.parentSpanContext) ??\n      context.active(),\n    (span) => {\n      try {\n        let observation: Observation;\n\n        switch (asType) {\n          case \"llm\":\n            observation = new ObservationLLM({ otelSpan: span });\n            break;\n          case \"embedding\":\n            observation = new ObservationEmbedding({ otelSpan: span });\n            break;\n          case \"agent\":\n            observation = new ObservationAgent({ otelSpan: span });\n            break;\n          case \"tool\":\n            observation = new ObservationTool({ otelSpan: span });\n            break;\n          case \"chain\":\n            observation = new ObservationChain({ otelSpan: span });\n            break;\n          case \"retriever\":\n            observation = new ObservationRetriever({ otelSpan: span });\n            break;\n          case \"reranker\":\n            observation = new ObservationReranker({ otelSpan: span });\n            break;\n          case \"evaluator\":\n            observation = new ObservationEvaluator({ otelSpan: span });\n            break;\n          case \"guardrail\":\n            observation = new ObservationGuardrail({ otelSpan: span });\n            break;\n          case \"span\":\n          default:\n            observation = new ObservationSpan({ otelSpan: span });\n        }\n\n        const result = fn(observation as Parameters<F>[0]);\n\n        if (result instanceof Promise) {\n          return wrapPromise(\n            result,\n            span,\n            endOnExit,\n          ) as ReturnType<F>;\n        } else {\n          if (endOnExit !== false) {\n            span.end();\n          }\n          return result as ReturnType<F>;\n        }\n      } catch (err) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err instanceof Error ? err.message : \"Unknown error\",\n        });\n        if (endOnExit !== false) {\n          span.end();\n        }\n        throw err;\n      }\n    },\n  );\n}\n\n/**\n * Updates the currently active observation with new attributes.\n *\n * @param attributes - Observation attributes to set\n *\n * @example\n * ```typescript\n * import { updateActiveObservation } from './observability';\n *\n * // Within an active observation context\n * updateActiveObservation({\n *   metadata: { stage: 'processing' }\n * });\n * ```\n *\n * @public\n */\nexport function updateActiveObservation(\n  attributes: BaseSpanAttributes,\n): void {\n  const span = trace.getActiveSpan();\n\n  if (!span) {\n    console.warn(\n      \"[Observability] No active OTEL span in context. Skipping observation update.\",\n    );\n    return;\n  }\n\n  span.setAttributes(createObservationAttributes(\"span\", attributes));\n}\n\n// ============================================================================\n// Decorator Function\n// ============================================================================\n\n/**\n * Options for the observe decorator.\n *\n * @public\n */\nexport type ObserveOptions = Omit<StartObservationOpts, \"name\"> & {\n  /** Whether to capture function arguments as input. Default: true */\n  captureInput?: boolean;\n  /** Whether to capture return value as output. Default: true */\n  captureOutput?: boolean;\n};\n\n/**\n * Captures function arguments for observability input.\n *\n * @param args - Function arguments to capture\n * @returns Serialized arguments\n * @internal\n */\nfunction _captureArguments(args: unknown[]): Record<string, unknown> {\n  if (args.length === 0) return {};\n  if (args.length === 1) return { arg: args[0] };\n  return { args };\n}\n\n/**\n * Decorator function to add observability to any function.\n *\n * Wraps a function with automatic observation creation, input/output capture,\n * and lifecycle management. The observation is automatically ended when the\n * function completes.\n *\n * @param fn - Function to wrap\n * @param options - Configuration options\n * @returns Wrapped function with observability\n *\n * @example\n * ```typescript\n * import { observe } from './observability';\n *\n * // Wrap an existing function\n * const fetchData = observe(async (url: string) => {\n *   const response = await fetch(url);\n *   return response.json();\n * }, { asType: 'tool' });\n *\n * // Wrap with custom name\n * const processPayment = observe(\n *   async (amount: number, currency: string) => {\n *     return await paymentGateway.charge(amount, currency);\n *   },\n *   { name: 'payment-gateway-call', asType: 'tool' }\n * );\n *\n * // Class method decoration\n * class UserService {\n *   @observe({ asType: 'chain' })\n *   async getUser(id: string) {\n *     return await db.users.find(id);\n *   }\n * }\n * ```\n *\n * @public\n */\nexport function observe<T extends (...args: any[]) => any>(\n  fn: T,\n  options: ObserveOptions = {},\n): T {\n  const {\n    asType = \"span\",\n    captureInput = true,\n    captureOutput = true,\n    ...observationOptions\n  } = options;\n\n  const wrappedFunction = function (\n    this: any,\n    ...args: Parameters<T>\n  ): ReturnType<T> {\n    const name = fn.name || \"anonymous-function\";\n\n    // Prepare input data\n    const inputData = captureInput ? _captureArguments(args) : undefined;\n\n    // Create the observation\n    const observation = startObservation(\n      name,\n      inputData ? { input: inputData } : {},\n      {\n        ...observationOptions,\n        asType: asType as \"span\",\n      },\n    );\n\n    // Set the observation span as active in the context\n    const activeContext = trace.setSpan(context.active(), observation.otelSpan);\n\n    // Execute the function within the observation context\n    const result = context.with(activeContext, () => fn.apply(this, args));\n\n    // Handle promises\n    if (result instanceof Promise) {\n      return result.then(\n        (value) => {\n          if (captureOutput) {\n            observation.update({ output: value });\n          }\n          observation.end();\n          return value;\n        },\n        (err: unknown) => {\n          observation.update({\n            level: \"ERROR\",\n            statusMessage: err instanceof Error ? err.message : \"Unknown error\",\n          });\n          observation.end();\n          throw err;\n        },\n      ) as ReturnType<T>;\n    }\n\n    // Handle synchronous functions\n    if (captureOutput) {\n      observation.update({ output: result });\n    }\n    observation.end();\n\n    return result as ReturnType<T>;\n  };\n\n  // Preserve function properties\n  Object.defineProperty(wrappedFunction, \"name\", { value: fn.name });\n  Object.defineProperty(wrappedFunction, \"length\", { value: fn.length });\n\n  return wrappedFunction as T;\n}\n"],"mappings":"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","names":["SemanticConventions","trace","context"]}