// src/agent.ts
import {
  AbstractAgent,
  EventType as EventType2
} from "@ag-ui/client";
import tcb from "@cloudbase/node-sdk";
import managedTcb from "@cloudbase/manager-node";
import OpenAI from "openai";
import { randomUUID } from "crypto";

// src/utils.ts
function camelToSnake(str) {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}
function camelToSnakeKeys(obj) {
  if (obj === null || obj === void 0) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => camelToSnakeKeys(item));
  }
  if (typeof obj === "object") {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
      const snakeKey = camelToSnake(key);
      result[snakeKey] = camelToSnakeKeys(value);
    }
    return result;
  }
  return obj;
}
function genRandomStr(length) {
  const chars = "abcdefghijklmnopqrstuvwxyz0123456789";
  let result = "";
  for (let i = 0; i < length; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

// src/stream.ts
import { EventType } from "@ag-ui/client";
async function* processYuanqiStream(stream, context) {
  const { threadId, runId, messageId } = context;
  const state = {
    hasStarted: false,
    fullContent: "",
    toolCallsMap: /* @__PURE__ */ new Map()
  };
  const reasoningState = {
    hasStarted: false,
    fullContent: "",
    toolCallsMap: /* @__PURE__ */ new Map()
  };
  for await (const chunk of stream) {
    const delta = chunk.choices[0]?.delta;
    if (!delta) continue;
    if (delta.role === "tool") {
      const toolCallId = delta.tool_call_id;
      if (toolCallId) {
        if (state.toolCallsMap.has(toolCallId)) {
          yield {
            type: EventType.TOOL_CALL_END,
            threadId,
            runId,
            toolCallId
          };
          state.toolCallsMap.delete(toolCallId);
        }
        yield {
          type: EventType.TOOL_CALL_RESULT,
          threadId,
          runId,
          toolCallId,
          content: delta.content || ""
        };
      }
      continue;
    }
    if (delta.content) {
      if (reasoningState.hasStarted) {
        reasoningState.hasStarted = false;
        yield {
          type: EventType.THINKING_TEXT_MESSAGE_END,
          threadId,
          runId,
          messageId
        };
        yield {
          type: EventType.THINKING_END,
          threadId,
          runId,
          messageId
        };
      }
      if (!state.hasStarted) {
        yield {
          type: EventType.TEXT_MESSAGE_START,
          threadId,
          runId,
          messageId,
          role: "assistant"
        };
        state.hasStarted = true;
      }
      state.fullContent += delta.content;
      yield {
        type: EventType.TEXT_MESSAGE_CONTENT,
        threadId,
        runId,
        messageId,
        delta: delta.content
      };
    }
    if (delta.reasoning_content) {
      if (!reasoningState.hasStarted) {
        yield {
          type: EventType.THINKING_START,
          threadId,
          runId,
          messageId
        };
        yield {
          type: EventType.THINKING_TEXT_MESSAGE_START,
          threadId,
          runId,
          messageId,
          role: "assistant"
        };
        reasoningState.hasStarted = true;
      }
      reasoningState.fullContent += delta.reasoning_content;
      yield {
        type: EventType.THINKING_TEXT_MESSAGE_CONTENT,
        threadId,
        runId,
        messageId,
        delta: delta.reasoning_content
      };
    }
    if (delta.tool_calls) {
      for (const toolCall of delta.tool_calls) {
        const toolCallId = toolCall.id || `tool_${toolCall.index}`;
        if (toolCall.function?.name) {
          yield {
            type: EventType.TOOL_CALL_START,
            threadId,
            runId,
            toolCallId,
            toolCallName: toolCall.function.name
          };
          if (toolCall.function.arguments) {
            yield {
              type: EventType.TOOL_CALL_ARGS,
              threadId,
              runId,
              toolCallId,
              delta: toolCall.function.arguments
            };
          }
          state.toolCallsMap.set(toolCallId, {
            name: toolCall.function.name,
            args: toolCall.function.arguments || ""
          });
        } else if (toolCall.function?.arguments) {
          const existing = state.toolCallsMap.get(toolCallId);
          if (existing) {
            existing.args += toolCall.function.arguments;
            yield {
              type: EventType.TOOL_CALL_ARGS,
              threadId,
              runId,
              toolCallId,
              delta: toolCall.function.arguments
            };
          }
        }
      }
    }
  }
  if (state.hasStarted) {
    yield {
      type: EventType.TEXT_MESSAGE_END,
      threadId,
      runId,
      messageId
    };
  }
  if (reasoningState.hasStarted) {
    yield {
      type: EventType.THINKING_TEXT_MESSAGE_END,
      threadId,
      runId,
      messageId
    };
    yield {
      type: EventType.THINKING_END,
      threadId,
      runId,
      messageId
    };
  }
  for (const [toolCallId] of state.toolCallsMap) {
    yield {
      type: EventType.TOOL_CALL_END,
      threadId,
      runId,
      toolCallId
    };
  }
}

// src/agent.ts
import { Observable } from "rxjs";

// src/constant.ts
var CHAT_HISTORY_DATA_SOURCE = "ai_bot_chat_history_5hobd2b";

// src/chat_history.ts
function genRecordId() {
  return "record-" + genRandomStr(8);
}
async function createChatHistory({
  tcbClient,
  chatHistoryEntity
}) {
  try {
    const recordId = chatHistoryEntity.recordId || genRecordId();
    const data = {
      record_id: recordId,
      bot_id: chatHistoryEntity.botId,
      role: chatHistoryEntity.role,
      content: chatHistoryEntity.content,
      sender: chatHistoryEntity.sender,
      conversation: chatHistoryEntity.conversation,
      type: chatHistoryEntity.type,
      image: chatHistoryEntity.image,
      trigger_src: chatHistoryEntity.triggerSrc,
      origin_msg: chatHistoryEntity.originMsg,
      reply_to: chatHistoryEntity.replyTo,
      reply: chatHistoryEntity.reply,
      trace_id: chatHistoryEntity.traceId,
      need_async_reply: chatHistoryEntity.needAsyncReply,
      async_reply: chatHistoryEntity.asyncReply,
      createdAt: Date.now(),
      updatedAt: Date.now()
    };
    const db = tcbClient.database();
    const collection = db.collection(CHAT_HISTORY_DATA_SOURCE);
    const result = await collection.add(data);
    return recordId;
  } catch (error) {
    console.error("Failed to create chat history record, error:", error);
    return void 0;
  }
}
async function updateChatHistoryByRecordId({
  tcbClient,
  recordId,
  chatHistoryEntity
}) {
  try {
    const db = tcbClient.database();
    const _ = db.command;
    const collection = db.collection(CHAT_HISTORY_DATA_SOURCE);
    const result = await collection.where({ record_id: _.eq(recordId) }).update({
      content: chatHistoryEntity.content,
      image: chatHistoryEntity.image,
      async_reply: chatHistoryEntity.asyncReply,
      recommend_questions: chatHistoryEntity.recommendQuestions,
      status: chatHistoryEntity.status,
      origin_msg: chatHistoryEntity.originMsg,
      updatedAt: Date.now()
    });
    return chatHistoryEntity.recordId;
  } catch (error) {
    console.error("Failed to update chat history, error:", error);
    return void 0;
  }
}
async function describeChatHistory({
  tcbClient,
  botId,
  sort,
  pageSize = 10,
  pageNumber = 1,
  conversation,
  startCreatedAt,
  triggerSrc
}) {
  if (!sort || sort.length === 0) {
    sort = "desc";
  }
  try {
    const db = tcbClient.database();
    const _ = db.command;
    const collection = db.collection(CHAT_HISTORY_DATA_SOURCE);
    const whereConditions = {
      bot_id: _.eq(botId)
    };
    if (conversation) {
      whereConditions.conversation = _.eq(conversation);
    }
    if (startCreatedAt !== void 0) {
      whereConditions.createdAt = _.gt(startCreatedAt);
    }
    if (triggerSrc) {
      whereConditions.trigger_src = _.eq(triggerSrc);
    }
    const skip = (pageNumber - 1) * pageSize;
    const result = await collection.where(whereConditions).orderBy("createdAt", sort).skip(skip).limit(pageSize).get();
    const countResult = await collection.where(whereConditions).count();
    const total = countResult.total || 0;
    const records = result?.data || [];
    const entityList = records.map(
      (item) => transDataToChatEntity(item)
    );
    return [entityList, total];
  } catch (error) {
    console.error("Failed to query chat history, error:", error);
    return [[], 0];
  }
}
function transDataToChatEntity(item) {
  if (!item) {
    return new ChatHistoryEntity();
  }
  const chatEntity = new ChatHistoryEntity();
  chatEntity.botId = item.bot_id;
  chatEntity.recordId = item.record_id;
  chatEntity.role = item.role;
  chatEntity.status = item.status;
  chatEntity.content = item.content;
  chatEntity.sender = item.sender;
  chatEntity.conversation = item.conversation;
  chatEntity.type = item.type;
  chatEntity.triggerSrc = item.trigger_src;
  chatEntity.originMsg = item.origin_msg;
  chatEntity.replyTo = item.reply_to;
  chatEntity.reply = item.reply;
  chatEntity.traceId = item.trace_id;
  chatEntity.needAsyncReply = item.need_async_reply;
  chatEntity.asyncReply = item.async_reply;
  chatEntity.createdAt = item.createdAt;
  chatEntity.updatedAt = item.updatedAt;
  return chatEntity;
}
async function queryForLLM({
  tcbClient,
  botId,
  pageSize = 10,
  startCreatedAt,
  triggerSrc
}) {
  if (startCreatedAt === void 0) {
    startCreatedAt = Date.now() - 24 * 60 * 60 * 1e3;
  }
  const recordEntityList = [];
  const [recordList] = await describeChatHistory({
    tcbClient,
    botId,
    sort: "desc",
    pageSize,
    startCreatedAt,
    triggerSrc
  });
  recordEntityList.push(...recordList.reverse());
  const entityMap = /* @__PURE__ */ new Map();
  recordEntityList.filter((item) => {
    if (item.needAsyncReply === true) {
      return !!item.asyncReply;
    } else {
      return !!item.content;
    }
  }).forEach((item) => {
    entityMap.set(item.recordId, item);
  });
  const result = [];
  recordEntityList.forEach((item) => {
    const { role, content, reply } = item;
    if (role === "user" && content?.length !== 0) {
      if (entityMap.has(reply)) {
        result.push({ role, content });
        result.push({
          role: entityMap.get(reply).role,
          content: entityMap.get(reply).content
        });
      }
    }
  });
  if (result.length % 2 === 1) {
    result.splice(-1, 1);
  }
  return result;
}
var ChatHistoryEntity = class {
};

// src/agent.ts
var YuanqiAgentError = class extends Error {
  constructor(message, code) {
    super(message);
    this.name = "YuanqiAgentError";
    if (code) this.code = code;
  }
};
var YuanqiAgent = class extends AbstractAgent {
  constructor(config) {
    super(config);
    this.finalCloudCredential = {};
    this.yuanqiConfig = config.yuanqiConfig;
    this.model = new OpenAI({
      apiKey: "",
      baseURL: this.yuanqiConfig.request?.baseUrl || "https://yuanqi.tencent.com/openapi/v1/agent"
    });
    this.finalAppId = this.yuanqiConfig.appId || this.yuanqiConfig.request?.body?.assistantId || process.env.YUANQI_APP_ID || "";
    this.finalCloudCredential = {
      secretId: this.yuanqiConfig.credential?.secretId || process.env.TENCENTCLOUD_SECRETID,
      secretKey: this.yuanqiConfig.credential?.secretKey || process.env.TENCENTCLOUD_SECRETKEY,
      token: this.yuanqiConfig.credential?.token || process.env.TENCENTCLOUD_SESSIONTOKEN
    };
  }
  generateRequestBody({
    messages,
    input
  }) {
    const { state, forwardedProps } = input;
    const requestBody = {
      stream: true,
      ...this.yuanqiConfig.request?.body || {},
      ...forwardedProps || {},
      assistantId: this.finalAppId,
      userId: state?.__request_context__?.id || forwardedProps?.userId || randomUUID(),
      messages
    };
    return requestBody;
  }
  run(input) {
    return new Observable((subscriber) => {
      this._run(subscriber, input);
    });
  }
  async _run(subscriber, input) {
    try {
      const { messages, runId } = input;
      const openai = this.model;
      const threadId = input.threadId || randomUUID();
      subscriber.next({
        type: EventType2.RUN_STARTED,
        threadId,
        runId
      });
      if (!this.finalAppId) {
        throw new YuanqiAgentError(
          "YUANQI_APP_ID is required, check your env variables or config passed with the adapter",
          "MISSING_YUANQI_APP_ID"
        );
      }
      if (!this.yuanqiConfig.appKey && !process.env.YUANQI_APP_KEY) {
        throw new YuanqiAgentError(
          "YUANQI_APP_KEY is required, check your env variables or config passed with the adapter",
          "MISSING_YUANQI_APP_KEY"
        );
      }
      const trimmedCount = messages.length - 1;
      if (trimmedCount > 0) {
        subscriber.next({
          type: EventType2.RAW,
          rawEvent: {
            message: `Yuanqi handles message history itself, so that a total of ${trimmedCount} messages before the last user message will be trimmed.`,
            type: "warn"
          }
        });
      }
      const latestUserMessage = messages.filter((m) => m.role === "user").pop();
      if (!latestUserMessage) {
        throw new YuanqiAgentError(
          "No user message found, please send a message first.",
          "MESSAGE_FORMAT_ERROR"
        );
      }
      const allMessages = await this.getChatHistory(
        subscriber,
        latestUserMessage
      );
      const body = this.generateRequestBody({
        messages: allMessages,
        input
      });
      const stream = await openai.chat.completions.create(
        {
          stream: true,
          messages: [],
          model: ""
        },
        {
          body: camelToSnakeKeys(body),
          headers: {
            ...this.yuanqiConfig.request?.headers,
            Authorization: `Bearer ${this.yuanqiConfig.appKey || process.env.YUANQI_APP_KEY}`
          }
        }
      );
      const userRecordId = `record-${randomUUID().slice(0, 8)}`;
      const assistantRecordId = `record-${randomUUID().slice(0, 8)}`;
      const context = { threadId, runId, messageId: userRecordId };
      let fullAssistantContent = "";
      for await (const event of processYuanqiStream(stream, context)) {
        subscriber.next(event);
        if (event.type === EventType2.TEXT_MESSAGE_CONTENT && event.delta) {
          fullAssistantContent += event.delta;
        }
      }
      const userContent = typeof latestUserMessage?.content === "string" ? latestUserMessage.content : latestUserMessage?.content?.filter((c) => c.type === "text").map((c) => c.text).join("") || "";
      await this.saveChatHistory(
        subscriber,
        input,
        userRecordId,
        assistantRecordId,
        userContent,
        fullAssistantContent
      );
      subscriber.next({
        type: EventType2.RUN_FINISHED,
        threadId,
        runId
      });
    } catch (e) {
      console.error("[ERROR] Uncaught error: ", JSON.stringify(e));
      let code = "UNKNOWN_ERROR";
      let message = JSON.stringify(e);
      if (e instanceof YuanqiAgentError) {
        code = e.code || "AGENT_ERROR";
        message = e.message;
      } else if (e instanceof Error) {
        code = e.name || "ERROR";
        message = e.message;
      }
      subscriber.next({
        type: EventType2.RUN_ERROR,
        code,
        message: `Sorry, an error occurred while running the agent: Error code ${code}, ${message}`
      });
    } finally {
      subscriber.complete();
    }
  }
  // Can be override by subclasses
  async getChatHistory(subscriber, latestUserMessage) {
    const botId = `bot-yuanqi-${this.finalAppId}`;
    const tcbClient = this.getTcbClient();
    const isDBReady = await this.checkIsDatabaseReady();
    if (!isDBReady) {
      subscriber.next({
        type: EventType2.RAW,
        rawEvent: {
          message: `Chat history database is not ready, skip history loading.`,
          type: "warn"
        }
      });
      return convertMessagesToOpenAI([latestUserMessage]);
    }
    let historyMessages = [];
    const historyCount = this.yuanqiConfig.historyCount ?? 10;
    const historyRecords = await queryForLLM({
      tcbClient,
      botId,
      pageSize: historyCount
    });
    historyMessages = historyRecords.map((record) => ({
      role: record.role,
      content: [{ type: "text", text: record.content }]
    }));
    const allMessages = historyMessages.concat(
      convertMessagesToOpenAI([latestUserMessage])
    );
    return allMessages;
  }
  // Can be override by subclasses
  async saveChatHistory(subscriber, input, userRecordId, assistantRecordId, userContent, assistantContent) {
    const botId = `bot-yuanqi-${this.finalAppId}`;
    const { threadId, runId } = input;
    const tcbClient = this.getTcbClient();
    const isDBReady = await this.checkIsDatabaseReady();
    if (!isDBReady) {
      subscriber.next({
        type: EventType2.RAW,
        rawEvent: {
          message: `Chat history database is not ready, skip history saving.`,
          type: "warn"
        }
      });
      return;
    }
    const userEntity = new ChatHistoryEntity();
    userEntity.recordId = userRecordId;
    userEntity.botId = botId;
    userEntity.role = "user";
    userEntity.content = userContent;
    userEntity.conversation = threadId;
    userEntity.reply = assistantRecordId;
    userEntity.triggerSrc = "";
    userEntity.traceId = randomUUID();
    await createChatHistory({ tcbClient, chatHistoryEntity: userEntity });
    const assistantEntity = new ChatHistoryEntity();
    assistantEntity.recordId = assistantRecordId;
    assistantEntity.botId = botId;
    assistantEntity.role = "assistant";
    assistantEntity.content = assistantContent;
    assistantEntity.conversation = threadId;
    assistantEntity.replyTo = userRecordId;
    assistantEntity.triggerSrc = "";
    assistantEntity.traceId = runId;
    assistantEntity.status = "done";
    await createChatHistory({
      tcbClient,
      chatHistoryEntity: assistantEntity
    });
  }
  getTcbClient() {
    const envId = this.yuanqiConfig.envId || getCloudbaseEnvId();
    const tcbClient = tcb.init({
      env: envId,
      secretId: this.finalCloudCredential.secretId,
      secretKey: this.finalCloudCredential.secretKey,
      sessionToken: this.finalCloudCredential.token
    });
    return tcbClient;
  }
  async checkIsDatabaseReady() {
    try {
      const envId = this.yuanqiConfig.envId || getCloudbaseEnvId();
      if (!envId) {
        throw new YuanqiAgentError(
          "When saving chat history to CloudBase, CLOUDBASE_ENV_ID is required, check your env variables or config passed with the adapter",
          "MISSING_CLOUDBASE_ENV_ID"
        );
      }
      if (!this.finalCloudCredential.token) {
        if (!this.finalCloudCredential.secretId) {
          throw new YuanqiAgentError(
            "When saving chat history to CloudBase, TENCENTCLOUD_SECRETID is required, check your env variables or config passed with the adapter",
            "MISSING_SECRET_ID"
          );
        }
        if (!this.finalCloudCredential.secretKey) {
          throw new YuanqiAgentError(
            "When saving chat history to CloudBase, TENCENTCLOUD_SECRETKEY is required, check your env variables or config passed with the adapter",
            "MISSING_SECRET_KEY"
          );
        }
      }
      const managedTcbClient = managedTcb.init({
        envId,
        secretId: this.finalCloudCredential.secretId,
        secretKey: this.finalCloudCredential.secretKey,
        token: this.finalCloudCredential.token
      });
      const checkDBRes = await managedTcbClient.database.checkCollectionExists(
        CHAT_HISTORY_DATA_SOURCE
      );
      if (checkDBRes && checkDBRes.Exists) {
        return true;
      } else if (checkDBRes && !checkDBRes.Exists) {
        await managedTcbClient.database.createCollection(
          CHAT_HISTORY_DATA_SOURCE
        );
        return true;
      } else {
        throw new Error("Check database exists failed");
      }
    } catch (dbError) {
      console.error(
        "[ERROR] Failed to check/create chat history collection:",
        JSON.stringify(dbError)
      );
      return false;
    }
  }
};
function getCloudbaseEnvId() {
  if (process.env.CBR_ENV_ID) {
    return process.env.CBR_ENV_ID;
  } else if (process.env.SCF_NAMESPACE) {
    return process.env.SCF_NAMESPACE;
  } else {
    return process.env.CLOUDBASE_ENV_ID || "";
  }
}
function convertMessagesToOpenAI(messages, systemPrompt) {
  const openaiMessages = [];
  if (systemPrompt) {
    openaiMessages.push({
      role: "system",
      content: systemPrompt
    });
  }
  for (const msg of messages) {
    if (msg.role === "user") {
      openaiMessages.push({
        role: "user",
        content: typeof msg.content === "string" ? [{ type: "text", text: msg.content }] : msg.content.map((item) => {
          if (item.type === "text") {
            return { type: "text", text: item.text };
          } else {
            return {
              type: "image_url",
              image_url: { url: item.url || "" }
            };
          }
        })
      });
    } else if (msg.role === "assistant") {
      openaiMessages.push({
        role: "assistant",
        content: msg.content ? [{ type: "text", text: msg.content }] : [],
        tool_calls: msg.toolCalls?.map((tc) => ({
          id: tc.id,
          type: "function",
          function: {
            name: tc.function.name,
            arguments: tc.function.arguments
          }
        }))
      });
    } else if (msg.role === "tool") {
      openaiMessages.push({
        role: "tool",
        tool_call_id: msg.toolCallId,
        content: msg.content ? [{ type: "text", text: msg.content }] : []
      });
    }
  }
  return openaiMessages;
}
export {
  ChatHistoryEntity,
  YuanqiAgent,
  YuanqiAgentError,
  convertMessagesToOpenAI,
  createChatHistory,
  describeChatHistory,
  processYuanqiStream,
  queryForLLM,
  transDataToChatEntity,
  updateChatHistoryByRecordId
};
//# sourceMappingURL=index.mjs.map