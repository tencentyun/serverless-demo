import { MaybePromise, NonEmptyRecord } from '@copilotkitnext/shared';
import { AbstractAgent, RunAgentInput, BaseEvent } from '@ag-ui/client';
import { Observable } from 'rxjs';

/**
 * Middleware support for CopilotKit Runtime.
 *
 * A middleware hook can be provided as either:
 *   1. A **callback function** executed in-process.
 *   2. A **webhook URL** (http/https).  The runtime will `POST` a JSON payload
 *      to the URL and, for *before* hooks, accept an optional modified
 *      `Request` object in the response body.
 *
 * Two lifecycle hooks are available:
 *   • `BEFORE_REQUEST` – runs *before* the request handler.
 *   • `AFTER_REQUEST`  – runs *after* the handler returns a `Response`.
 */

interface BeforeRequestMiddlewareParameters {
    runtime: CopilotRuntime;
    request: Request;
    path: string;
}
interface AfterRequestMiddlewareParameters {
    runtime: CopilotRuntime;
    response: Response;
    path: string;
}
type BeforeRequestMiddlewareFn = (params: BeforeRequestMiddlewareParameters) => MaybePromise<Request | void>;
type AfterRequestMiddlewareFn = (params: AfterRequestMiddlewareParameters) => MaybePromise<void>;
/**
 * A middleware value can be either a callback function or a webhook URL.
 */
type BeforeRequestMiddleware = BeforeRequestMiddlewareFn;
type AfterRequestMiddleware = AfterRequestMiddlewareFn;

interface TranscribeFileOptions {
    audioFile: File;
    /** MIME type of the audio file */
    mimeType?: string;
    /** Size of the audio file in bytes */
    size?: number;
}
declare abstract class TranscriptionService {
    abstract transcribeFile(options: TranscribeFileOptions): Promise<string>;
}

interface AgentRunnerRunRequest {
    threadId: string;
    agent: AbstractAgent;
    input: RunAgentInput;
}
interface AgentRunnerConnectRequest {
    threadId: string;
    headers?: Record<string, string>;
}
interface AgentRunnerIsRunningRequest {
    threadId: string;
}
interface AgentRunnerStopRequest {
    threadId: string;
}
declare abstract class AgentRunner {
    abstract run(request: AgentRunnerRunRequest): Observable<BaseEvent>;
    abstract connect(request: AgentRunnerConnectRequest): Observable<BaseEvent>;
    abstract isRunning(request: AgentRunnerIsRunningRequest): Promise<boolean>;
    abstract stop(request: AgentRunnerStopRequest): Promise<boolean | undefined>;
}

declare const VERSION: string;
/**
 * Options used to construct a `CopilotRuntime` instance.
 */
interface CopilotRuntimeOptions {
    /** Map of available agents (loaded lazily is fine). */
    agents: MaybePromise<NonEmptyRecord<Record<string, AbstractAgent>>>;
    /** The runner to use for running agents. */
    runner?: AgentRunner;
    /** Optional transcription service for audio processing. */
    transcriptionService?: TranscriptionService;
    /** Optional *before* middleware – callback function or webhook URL. */
    beforeRequestMiddleware?: BeforeRequestMiddleware;
    /** Optional *after* middleware – callback function or webhook URL. */
    afterRequestMiddleware?: AfterRequestMiddleware;
}
/**
 * Central runtime object passed to all request handlers.
 */
declare class CopilotRuntime {
    agents: CopilotRuntimeOptions["agents"];
    transcriptionService: CopilotRuntimeOptions["transcriptionService"];
    beforeRequestMiddleware: CopilotRuntimeOptions["beforeRequestMiddleware"];
    afterRequestMiddleware: CopilotRuntimeOptions["afterRequestMiddleware"];
    runner: AgentRunner;
    constructor({ agents, transcriptionService, beforeRequestMiddleware, afterRequestMiddleware, runner, }: CopilotRuntimeOptions);
}

export { AgentRunner as A, CopilotRuntime as C, type TranscribeFileOptions as T, VERSION as V, type AgentRunnerRunRequest as a, type AgentRunnerConnectRequest as b, type AgentRunnerIsRunningRequest as c, type AgentRunnerStopRequest as d, type CopilotRuntimeOptions as e, TranscriptionService as f };
