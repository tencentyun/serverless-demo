"use strict";
/**
 * MCP Client Tool - Wraps MCP tools to work within AG-Kit's tool system
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MCPClientTool = void 0;
const v4_1 = require("zod/v4");
const utils_1 = require("../utils");
/**
 * MCPClientTool wraps an external MCP tool to work within AG-Kit's tool system
 */
class MCPClientTool extends utils_1.BaseTool {
    constructor(mcpClient, mcpToolMetadata, config = {}, adapterConfig = {}) {
        // Convert MCP input schema to zod schema for AG-Kit compatibility
        const zodSchema = MCPClientTool.convertMCPSchemaToZod(mcpToolMetadata.inputSchema);
        super({
            name: config.name || mcpToolMetadata.name,
            description: config.description ||
                mcpToolMetadata.description ||
                `MCP tool: ${mcpToolMetadata.name}`,
            schema: zodSchema,
        });
        this.mcpClient = mcpClient;
        this.mcpToolMetadata = mcpToolMetadata;
        this.config = { timeout: 30000, retries: 1, ...config };
        this.adapterConfig = { includeMetadata: true, ...adapterConfig };
    }
    /**
     * Convert MCP JSON Schema to Zod schema (basic conversion)
     */
    static convertMCPSchemaToZod(mcpSchema) {
        if (mcpSchema.type !== "object") {
            return v4_1.z.any();
        }
        const shape = {};
        const properties = mcpSchema.properties || {};
        const required = mcpSchema.required || [];
        for (const [key, prop] of Object.entries(properties)) {
            let zodType = v4_1.z.any();
            // Basic type conversion - this could be expanded for more complex schemas
            if (typeof prop === "object" && prop !== null && "type" in prop) {
                switch (prop.type) {
                    case "string":
                        zodType = v4_1.z.string();
                        break;
                    case "number":
                        zodType = v4_1.z.number();
                        break;
                    case "boolean":
                        zodType = v4_1.z.boolean();
                        break;
                    case "array":
                        zodType = v4_1.z.array(v4_1.z.any());
                        break;
                    case "object":
                        zodType = v4_1.z.record(v4_1.z.string(), v4_1.z.any());
                        break;
                    default:
                        zodType = v4_1.z.any();
                }
                // Add description if available
                if ("description" in prop && typeof prop.description === "string") {
                    zodType = zodType.describe(prop.description);
                }
            }
            // Make optional if not required
            if (!required.includes(key)) {
                zodType = zodType.optional();
            }
            shape[key] = zodType;
        }
        return v4_1.z.object(shape);
    }
    /**
     * Execute the MCP tool
     */
    async _invoke(input, context) {
        const startTime = Date.now();
        try {
            // Transform input if configured
            const transformedInput = this.adapterConfig.transformInput
                ? this.adapterConfig.transformInput(input)
                : input;
            // Call the MCP tool with retry logic
            let lastError = null;
            let result = null;
            for (let attempt = 0; attempt <= this.config.retries; attempt++) {
                try {
                    // Create timeout promise
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error("MCP tool call timeout")), this.config.timeout);
                    });
                    // Call MCP tool
                    const callPromise = this.mcpClient.callTool({
                        name: this.mcpToolMetadata.name,
                        arguments: transformedInput,
                    });
                    result = await Promise.race([callPromise, timeoutPromise]);
                    break; // Success, exit retry loop
                }
                catch (error) {
                    lastError = error instanceof Error ? error : new Error(String(error));
                    if (attempt < this.config.retries) {
                        // Wait before retry
                        await new Promise((resolve) => setTimeout(resolve, 1000 * (attempt + 1)));
                    }
                }
            }
            if (!result) {
                throw lastError || new Error("MCP tool call failed after retries");
            }
            // Handle MCP error response
            if (result.isError) {
                const errorText = result.content
                    .filter((c) => c.type === "text")
                    .map((c) => c.text)
                    .join("\n");
                if (this.adapterConfig.errorHandler) {
                    return this.adapterConfig.errorHandler(new Error(errorText));
                }
                return (0, utils_1.handleToolError)(new Error(errorText), `MCP tool '${this.mcpToolMetadata.name}' execution`, "execution");
            }
            // Process successful result
            const textContent = result.content
                .filter((c) => c.type === "text")
                .map((c) => c.text)
                .join("\n");
            let processedOutput = textContent;
            // Try to parse JSON if it looks like JSON
            if (textContent.trim().startsWith("{") ||
                textContent.trim().startsWith("[")) {
                try {
                    processedOutput = JSON.parse(textContent);
                }
                catch {
                    // Keep as text if JSON parsing fails
                }
            }
            // Transform output if configured
            if (this.adapterConfig.transformOutput) {
                processedOutput = this.adapterConfig.transformOutput(processedOutput);
            }
            // Include metadata if configured
            const resultData = this.adapterConfig.includeMetadata
                ? {
                    output: processedOutput,
                    metadata: {
                        mcpTool: this.mcpToolMetadata.name,
                        executionTime: Date.now() - startTime,
                        contentTypes: result.content.map((c) => c.type),
                    },
                }
                : processedOutput;
            return new utils_1.ToolResult({
                success: true,
                data: resultData,
                executionTime: Date.now() - startTime,
            });
        }
        catch (error) {
            if (this.adapterConfig.errorHandler) {
                return this.adapterConfig.errorHandler(error instanceof Error ? error : new Error(String(error)));
            }
            return (0, utils_1.handleToolError)(error, `MCP tool '${this.mcpToolMetadata.name}' execution`, "execution", {
                mcpTool: this.mcpToolMetadata.name,
                input: input,
                executionTime: Date.now() - startTime,
            });
        }
    }
    /**
     * Get display information for the tool
     */
    getDisplay(params) {
        return `> Using MCP tool '${this.mcpToolMetadata.name}': ${JSON.stringify(params.input)}`;
    }
    /**
     * Get MCP-specific metadata
     */
    getMCPMetadata() {
        return { ...this.mcpToolMetadata };
    }
    /**
     * Get combined metadata (AG-Kit + MCP)
     */
    getMetadata() {
        const baseMetadata = super.getMetadata();
        return {
            ...baseMetadata,
            mcp: {
                originalName: this.mcpToolMetadata.name,
                originalDescription: this.mcpToolMetadata.description,
                inputSchema: this.mcpToolMetadata.inputSchema,
                config: this.config,
                adapterConfig: this.adapterConfig,
            },
        };
    }
    /**
     * Check if the MCP client is connected
     */
    isConnected() {
        // This would depend on the MCP client implementation
        return this.mcpClient && typeof this.mcpClient.callTool === "function";
    }
    /**
     * Update tool configuration
     */
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
    }
    /**
     * Update adapter configuration
     */
    updateAdapterConfig(newAdapterConfig) {
        this.adapterConfig = { ...this.adapterConfig, ...newAdapterConfig };
    }
}
exports.MCPClientTool = MCPClientTool;
//# sourceMappingURL=client-tool.js.map