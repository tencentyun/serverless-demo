{"version":3,"sources":["../src/agent.ts","../src/utils.ts","../src/constant.ts","../src/types.ts"],"sourcesContent":["import {\n  RunAgentInput,\n  Message,\n  BaseEvent,\n  EventType,\n  RunStartedEvent,\n  RunFinishedEvent,\n  RunErrorEvent,\n  TextMessageChunkEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  AbstractAgent,\n  AgentConfig,\n  UserMessage,\n  BinaryInputContent,\n  ThinkingStartEvent,\n  ThinkingTextMessageStartEvent,\n  ThinkingTextMessageContentEvent,\n  ThinkingTextMessageEndEvent,\n  ThinkingEndEvent,\n} from \"@ag-ui/client\";\nimport { Observable, Subscriber } from \"rxjs\";\nimport axios, { AxiosError, AxiosInstance } from \"axios\";\nimport { camelToSnakeKeys } from \"./utils\";\nimport { DOCUMENT_MIME_TYPES, IMAGE_MIME_TYPES, MIME_TYPES } from \"./constant\";\nimport {\n  AdpConfig,\n  AdpChatRequest,\n  AdpChunk,\n  ReplyMethod,\n  CurrentNodeStatus,\n  FileInfo,\n  DocumentParseRequest,\n  DocumentParseChunk,\n} from \"./types\";\nimport { randomUUID } from \"crypto\";\nimport { lke } from \"tencentcloud-sdk-nodejs-lke\";\nimport COS from \"cos-nodejs-sdk-v5\";\n\nexport class AdpAgentError extends Error {\n  code?: string;\n  constructor(message: string, code?: string) {\n    super(message);\n    this.name = \"AdpAgentError\";\n    if (code) this.code = code;\n  }\n}\n\nexport type CosParams = Awaited<\n  ReturnType<typeof lke.v20231130.Client.prototype.DescribeStorageCredential>\n>;\n\nexport class AdpAgent extends AbstractAgent {\n  private reqAppClient: AxiosInstance;\n  private reqLkeClient: InstanceType<typeof lke.v20231130.Client>;\n  protected adpConfig: AdpConfig;\n  private finalAppKey: string = \"\";\n  private finalCloudCredential: {\n    secretId?: string;\n    secretKey?: string;\n    token?: string;\n  } = {};\n\n  constructor(config: AgentConfig & { adpConfig: AdpConfig }) {\n    super(config);\n    this.adpConfig = config.adpConfig;\n    this.finalAppKey =\n      this.adpConfig.appKey ||\n      this.adpConfig.request?.body?.botAppKey ||\n      process.env.ADP_APP_KEY ||\n      \"\";\n    this.reqAppClient = axios.create({\n      baseURL:\n        this.adpConfig.request?.baseUrl || \"https://wss.lke.cloud.tencent.com\",\n    });\n    const LkeClient = lke.v20231130.Client;\n    this.finalCloudCredential = {\n      secretId:\n        this.adpConfig.credential?.secretId ||\n        process.env.TENCENTCLOUD_SECRETID,\n      secretKey:\n        this.adpConfig.credential?.secretKey ||\n        process.env.TENCENTCLOUD_SECRETKEY,\n      token:\n        this.adpConfig.credential?.token ||\n        process.env.TENCENTCLOUD_SESSIONTOKEN,\n    };\n    this.reqLkeClient = new LkeClient({\n      credential: this.finalCloudCredential,\n    });\n  }\n\n  generateRequestBody({\n    message,\n    fileInfos,\n    input,\n  }: {\n    message: string;\n    fileInfos: FileInfo[];\n    input: RunAgentInput;\n  }): AdpChatRequest {\n    const { state, runId, threadId, forwardedProps } = input;\n    const requestBody: AdpChatRequest = {\n      incremental: true,\n      stream: \"enable\",\n      ...(this.adpConfig.request?.body || {}),\n      ...(forwardedProps || {}),\n\n      botAppKey: this.finalAppKey,\n      visitorBizId:\n        state?.__request_context__?.id ||\n        forwardedProps?.visitorBizId ||\n        randomUUID(),\n      requestId: runId,\n      sessionId: threadId,\n      content: message,\n      fileInfos,\n    };\n    return requestBody;\n  }\n\n  run(input: RunAgentInput) {\n    return new Observable<BaseEvent>((subscriber) => {\n      this._run(subscriber, input);\n    });\n  }\n\n  private async _run(subscriber: Subscriber<BaseEvent>, input: RunAgentInput) {\n    let thinkingMessageSet = new Set<string>();\n    let thinkFinishedMessageSet = new Set<string>();\n    try {\n      const { runId } = input;\n      const threadId = input.threadId || randomUUID();\n\n      subscriber.next({\n        type: EventType.RUN_STARTED,\n        runId,\n        threadId,\n      } as RunStartedEvent);\n\n      if (!this.finalAppKey) {\n        throw new AdpAgentError(\n          \"ADP_APP_KEY is required, check your env variables or config passed with the adapter\",\n          \"MISSING_APP_KEY\"\n        );\n      }\n\n      // Get history, if necessary\n      // try {\n      //   const historyRes = await this.reqLkeClient.GetMsgRecord({\n      //     SessionId: threadId,\n      //     Type: 5,\n      //     Count: this.adpConfig.historyCount || 30,\n      //   })\n      //   const histories = historyRes.Records;\n      //   if (histories) {\n\n      //   }\n      // } catch (e) {\n      //   throw new Error(`Get history failed: ${e}`);\n      // }\n\n      const latestUserMessage = input.messages\n        .filter((m) => m.role === \"user\")\n        .pop();\n      if (!latestUserMessage) {\n        throw new AdpAgentError(\n          \"Message content format error, or empty content\",\n          \"INVALID_MESSAGE_FORMAT\"\n        );\n      }\n      const { message: docExtractedMessage, fileInfos } =\n        await this.extractDocuments(latestUserMessage, threadId, subscriber);\n      const message =\n        await this.convertAGUIMessagesToAdpMessages(docExtractedMessage);\n      if (!message) {\n        throw new AdpAgentError(\n          \"Message content format error, or empty content\",\n          \"INVALID_MESSAGE_FORMAT\"\n        );\n      }\n      if (input.messages.length > 1) {\n        subscriber.next({\n          type: EventType.RAW,\n          rawEvent: {\n            message: `ADP handles message history itself, so that a total of ${input.messages.length - 1} messages before and including last assistant message will be trimmed.`,\n            type: \"warn\",\n          },\n        });\n      }\n\n      const requestBody: AdpChatRequest = this.generateRequestBody({\n        message,\n        fileInfos,\n        input,\n      });\n\n      // console.log(camelToSnakeKeys(requestBody));\n\n      const response = await this.reqAppClient.post(\n        this.adpConfig.request?.endpoint || \"/v1/qbot/chat/sse\",\n        camelToSnakeKeys(requestBody),\n        { responseType: \"stream\" }\n      );\n\n      const sseStream: ReadableStream<Uint8Array> = response.data;\n      let buffer = \"\";\n      let interruptRequested = false;\n      let thinkingStart = false;\n\n      for await (const chunk of sseStream) {\n        buffer += chunk.toString();\n\n        const parts = buffer.split(\"\\n\\n\");\n        buffer = parts.pop() || \"\";\n\n        for (const part of parts) {\n          if (!part.trim()) continue;\n\n          const event = { data: \"\", event: \"\" };\n\n          for (const line of part.split(\"\\n\")) {\n            if (line.startsWith(\"data:\")) {\n              event.data += line.slice(5);\n            } else if (line.startsWith(\"event:\")) {\n              event.event = line.slice(6);\n            }\n          }\n\n          if (event.data) {\n            let data: AdpChunk;\n            try {\n              data = JSON.parse(event.data);\n            } catch (e) {\n              throw new AdpAgentError(\n                `ADP returned invalid data: ${event.data}`,\n                \"INVALID_DATA\"\n              );\n            }\n\n            switch (data.type) {\n              case \"reply\": {\n                const messageId = data.payload.record_id;\n                const isFinal = data.payload.is_final;\n\n                // console.log(JSON.stringify(data, null, 2));\n\n                if (thinkingStart) {\n                  thinkingStart = false;\n                  // 先结束所有未结束的 thinking messages\n                  for (const index of thinkingMessageSet) {\n                    subscriber.next({\n                      type: EventType.THINKING_TEXT_MESSAGE_END,\n                      messageId: `${messageId}-think-${index}`,\n                    } as ThinkingTextMessageEndEvent);\n                  }\n                  thinkingMessageSet.clear();\n                  subscriber.next({\n                    type: EventType.THINKING_END,\n                    messageId,\n                  } as ThinkingEndEvent);\n                }\n\n                if (data.payload.is_from_self) {\n                  if (data.payload.is_evil) {\n                    throw new AdpAgentError(\n                      \"Message filtered by ADP\",\n                      \"FILTERED_MESSAGE\"\n                    );\n                  } else {\n                    continue;\n                  }\n                }\n                data.payload.content = data.payload.content.replace(\n                  /\\\\n/g,\n                  \"\\n\\n\"\n                );\n\n                switch (data.payload.reply_method) {\n                  case ReplyMethod.LLM_REPLY: {\n                    subscriber.next({\n                      type: EventType.TEXT_MESSAGE_CHUNK,\n                      messageId,\n                      delta: data.payload.content,\n                    } as TextMessageChunkEvent);\n                    break;\n                  }\n                  case ReplyMethod.WORKFLOW_REPLY: {\n                    subscriber.next({\n                      type: EventType.TEXT_MESSAGE_CHUNK,\n                      messageId,\n                      delta: data.payload.content,\n                    } as TextMessageChunkEvent);\n                    if (\n                      isFinal &&\n                      data.payload.work_flow &&\n                      [\n                        CurrentNodeStatus.Pending,\n                        CurrentNodeStatus.Running,\n                      ].includes(data.payload.work_flow.current_node.Status)\n                    ) {\n                      subscriber.next({\n                        type: EventType.TOOL_CALL_START,\n                        toolCallId: data.payload.work_flow!.current_node.NodeID,\n                        toolCallName: `${data.payload.work_flow!.workflow_name}-${data.payload.work_flow!.current_node.NodeName}`,\n                        parentMessageId: messageId,\n                      } as ToolCallStartEvent);\n                      subscriber.next({\n                        type: EventType.TOOL_CALL_ARGS,\n                        toolCallId: data.payload.work_flow!.current_node.NodeID,\n                        delta:\n                          data.payload.work_flow!.current_node.Input || \"{}\",\n                      } as ToolCallArgsEvent);\n                      subscriber.next({\n                        type: EventType.TOOL_CALL_END,\n                        toolCallId: data.payload.work_flow!.current_node.NodeID,\n                      } as ToolCallEndEvent);\n                      interruptRequested = true;\n                    }\n                    break;\n                  }\n                  case ReplyMethod.WORKFLOW_EXECUTION_END: {\n                    subscriber.next({\n                      type: EventType.TOOL_CALL_RESULT,\n                      messageId,\n                      toolCallId: data.payload.work_flow!.current_node.NodeID,\n                      content: (data.payload.work_flow?.outputs || []).join(\n                        \"\\n\\n\"\n                      ),\n                    } as ToolCallResultEvent);\n                    subscriber.next({\n                      type: EventType.TEXT_MESSAGE_CHUNK,\n                      messageId,\n                      delta: data.payload.content,\n                    } as TextMessageChunkEvent);\n                    break;\n                  }\n                  default: {\n                    subscriber.next({\n                      type: EventType.TEXT_MESSAGE_CHUNK,\n                      messageId,\n                      delta: data.payload.content,\n                    } as TextMessageChunkEvent);\n                    break;\n                  }\n                }\n                break;\n              }\n              case \"thought\": {\n                // console.log(JSON.stringify(data, null, 2));\n\n                const messageId = data.payload.record_id;\n                if (!thinkingStart) {\n                  thinkingStart = true;\n                  subscriber.next({\n                    type: EventType.THINKING_START,\n                    messageId,\n                  } as ThinkingStartEvent);\n                }\n                data.payload.procedures.forEach((procedure) => {\n                  const index = procedure.index.toString();\n                  if (\n                    !thinkingMessageSet.has(index) &&\n                    !thinkFinishedMessageSet.has(index)\n                  ) {\n                    thinkingMessageSet.add(index);\n                    subscriber.next({\n                      type: EventType.THINKING_TEXT_MESSAGE_START,\n                      messageId: `${messageId}-think-${index}`,\n                      delta: procedure.debugging.content,\n                    } as ThinkingTextMessageStartEvent);\n                  } else {\n                    if (procedure.status === \"processing\") {\n                      subscriber.next({\n                        type: EventType.THINKING_TEXT_MESSAGE_CONTENT,\n                        messageId: `${messageId}-think-${index}`,\n                        delta: procedure.debugging.content,\n                      } as ThinkingTextMessageContentEvent);\n                    } else {\n                      thinkingMessageSet.delete(index);\n                      if (!thinkFinishedMessageSet.has(index)) {\n                        thinkFinishedMessageSet.add(index);\n                        subscriber.next({\n                          type: EventType.THINKING_TEXT_MESSAGE_END,\n                          messageId: `${messageId}-think-${index}`,\n                        } as ThinkingTextMessageEndEvent);\n                      }\n                    }\n                  }\n                });\n                break;\n              }\n              case \"error\": {\n                console.error(\n                  \"[ERROR] ADP throws error: \",\n                  JSON.stringify(data)\n                );\n                throw new AdpAgentError(\n                  data.error.message,\n                  data.error.code\n                    ? `ADP_ERROR_${data.error.code}`\n                    : \"ADP_ERROR_-1\"\n                );\n              }\n              case \"token_stat\": {\n                console.debug(\"[DEBUG] ADP token stat: \", JSON.stringify(data));\n                break;\n              }\n              case \"reference\": {\n                // TODO: Reference event\n                break;\n              }\n              default: {\n                break;\n              }\n            }\n          }\n        }\n      }\n\n      if (interruptRequested) {\n        subscriber.next({\n          type: EventType.RUN_FINISHED,\n          runId,\n          threadId,\n          outcome: \"interrupt\",\n          interrupt: {},\n        } as RunFinishedEvent);\n      } else {\n        subscriber.next({\n          type: EventType.RUN_FINISHED,\n          threadId,\n          runId,\n        } as RunFinishedEvent);\n      }\n      subscriber.complete();\n    } catch (e: unknown) {\n      console.error(\"[ERROR] Uncaught error: \", JSON.stringify(e));\n      let code = \"UNKNOWN_ERROR\";\n      let message = JSON.stringify(e);\n      if (e instanceof AxiosError) {\n        code = e.code || \"REQUEST_ERROR\";\n        message = e.message;\n      } else if (e instanceof AdpAgentError) {\n        code = e.code || \"AGENT_ERROR\";\n        message = e.message;\n      }\n      subscriber.next({\n        type: EventType.RUN_ERROR,\n        code,\n        message: `Sorry, an error occurred while running the agent: Error code ${code}, ${message}`,\n      } as RunErrorEvent);\n      subscriber.complete();\n    } finally {\n      thinkingMessageSet.clear();\n      thinkFinishedMessageSet.clear();\n    }\n  }\n\n  private async convertAGUIMessagesToAdpMessages(message: Message) {\n    let result = \"\";\n    if (message.role === \"user\") {\n      let content = \"\";\n      if (typeof message.content === \"string\") {\n        content = message.content;\n      } else {\n        if (this.adpConfig.enableUpload) {\n          if (!this.finalCloudCredential.token) {\n            if (!this.finalCloudCredential.secretId) {\n              throw new AdpAgentError(\n                \"TENCENTCLOUD_SECRETID is required, check your env variables or config passed with the adapter\",\n                \"MISSING_SECRET_ID\"\n              );\n            }\n            if (!this.finalCloudCredential.secretKey) {\n              throw new AdpAgentError(\n                \"TENCENTCLOUD_SECRETKEY is required, check your env variables or config passed with the adapter\",\n                \"MISSING_SECRET_KEY\"\n              );\n            }\n          }\n          const imageMap = new Map<string, string>();\n          // Accumulate images to upload\n          const imagesToUpload: BinaryInputContent[] = [];\n          message.content.forEach((item) => {\n            if (item.type === \"binary\") {\n              if (Object.keys(IMAGE_MIME_TYPES).includes(item.mimeType)) {\n                imagesToUpload.push(item);\n              }\n            }\n          });\n          if (imagesToUpload.length) {\n            await this.uploadToCos(\n              imagesToUpload,\n              (data, _, file) => {\n                imageMap.set(\n                  file.id || file.filename!,\n                  `https://${data.Location}`\n                );\n              },\n              (fileName, error) => {\n                throw new AdpAgentError(\n                  `Upload image ${fileName} failed: ${error}`,\n                  \"UPLOAD_IMAGE_FAILED\"\n                );\n              }\n            );\n          }\n          content = message.content\n            .reduce((acc, cur) => {\n              if (cur.type === \"text\") {\n                return acc + `${cur.text} `;\n              } else if (cur.type === \"binary\") {\n                if (Object.keys(IMAGE_MIME_TYPES).includes(cur.mimeType)) {\n                  if (imageMap.has(cur.id || cur.filename!)) {\n                    return (\n                      acc +\n                      `![${cur.filename}](${imageMap.get(cur.id || cur.filename!)}) `\n                    );\n                  } else {\n                    return acc;\n                  }\n                } else return acc;\n              } else {\n                return acc;\n              }\n            }, \"\")\n            .trim();\n        }\n      }\n      result = `${message.role}: ${content}\\n${result}`;\n    } else {\n      result = `${message.role}: ${message.content}\\n${result}`;\n    }\n    return result.trim();\n  }\n\n  private async extractDocuments(\n    message: Message,\n    threadId: string,\n    subscriber: Subscriber<BaseEvent>\n  ) {\n    // Document Extract\n    const documentFiles: BinaryInputContent[] = [];\n    let newMessage: Message;\n    if (message.role === \"user\" && Array.isArray(message.content)) {\n      let newContent: UserMessage[\"content\"] = [];\n      message.content.forEach((item) => {\n        if (item.type === \"text\") {\n          newContent.push(item);\n        } else if (item.type === \"binary\") {\n          if (Object.keys(DOCUMENT_MIME_TYPES).includes(item.mimeType)) {\n            documentFiles.push(item);\n          } else {\n            newContent.push(item);\n          }\n        }\n      });\n      newMessage = {\n        ...message,\n        content: newContent,\n      };\n    } else newMessage = message;\n    const fileInfos: FileInfo[] = [];\n    const successedFiles: {\n      data: COS.PutObjectResult;\n      cosParams: CosParams;\n      file: BinaryInputContent;\n    }[] = [];\n    const failedFiles: { fileName: string; error: string }[] = [];\n    if (this.adpConfig.enableUpload) {\n      if (!this.finalCloudCredential.token) {\n        if (!this.finalCloudCredential.secretId) {\n          throw new AdpAgentError(\n            \"TENCENTCLOUD_SECRETID is required, check your env variables or config passed with the adapter\",\n            \"MISSING_SECRET_ID\"\n          );\n        }\n        if (!this.finalCloudCredential.secretKey) {\n          throw new AdpAgentError(\n            \"TENCENTCLOUD_SECRETKEY is required, check your env variables or config passed with the adapter\",\n            \"MISSING_SECRET_KEY\"\n          );\n        }\n      }\n      if (documentFiles.length) {\n        try {\n          await this.uploadToCos(\n            documentFiles,\n            (data, cosParams, file) => {\n              successedFiles.push({ data, cosParams, file });\n            },\n            (fileName, error) => {\n              failedFiles.push({ fileName, error });\n            }\n          );\n        } catch (e) {\n          console.error(\"Document upload failed: \", JSON.stringify(e));\n        }\n      }\n      // Document Parse\n      if (successedFiles.length) {\n        for (const { data: cosData, cosParams, file } of successedFiles) {\n          const extName = MIME_TYPES[file.mimeType];\n          const requestBody: DocumentParseRequest = {\n            sessionId: threadId,\n            botAppKey: this.finalAppKey,\n            requestId: randomUUID(),\n            cosBucket: cosParams.Bucket!,\n            fileType: extName,\n            fileName: file.filename!,\n            cosUrl: cosParams.UploadPath!,\n            cosHash: cosData.headers?.[\"x-cos-hash-crc64ecma\"] || \"\",\n            eTag: cosData.ETag,\n            size: file.data?.length.toString() || \"0\",\n          };\n          const response = await this.reqAppClient.post(\n            this.adpConfig.request?.docParseEndpoint ||\n              \"/v1/qbot/chat/docParse\",\n            camelToSnakeKeys(requestBody),\n            { responseType: \"stream\" }\n          );\n\n          const sseStream: ReadableStream<Uint8Array> = response.data;\n          let buffer = \"\";\n\n          for await (const chunk of sseStream) {\n            buffer += chunk.toString();\n\n            const parts = buffer.split(\"\\n\\n\");\n            buffer = parts.pop() || \"\";\n\n            for (const part of parts) {\n              if (!part.trim()) continue;\n\n              const event = { data: \"\", event: \"\" };\n\n              for (const line of part.split(\"\\n\")) {\n                if (line.startsWith(\"data:\")) {\n                  event.data += line.slice(5);\n                } else if (line.startsWith(\"event:\")) {\n                  event.event = line.slice(6);\n                }\n              }\n\n              if (event.data) {\n                let data: DocumentParseChunk;\n                try {\n                  data = JSON.parse(event.data);\n                } catch (e) {\n                  throw new AdpAgentError(\n                    `ADP returned invalid data: ${event.data}`,\n                    \"INVALID_DATA\"\n                  );\n                }\n\n                switch (data.type) {\n                  case \"parsing\": {\n                    subscriber.next({\n                      type: EventType.RAW,\n                      rawEvent: {\n                        message: `Parsing document ${file.filename}: ${data.payload.process}%`,\n                        type: \"info\",\n                      },\n                    });\n                    if (data.payload.is_final) {\n                      if (data.payload.error_message) {\n                        subscriber.next({\n                          type: EventType.RAW,\n                          rawEvent: {\n                            message: `Parsing document ${file.filename} failed: ${data.payload.error_message}`,\n                            type: \"error\",\n                          },\n                        });\n                      } else {\n                        const fileNameNoExt = file\n                          .filename!.split(\".\")\n                          .splice(0, -1)\n                          .join(\".\");\n                        fileInfos.push({\n                          docId: data.payload.doc_id,\n                          fileName: fileNameNoExt,\n                          fileType: extName,\n                          fileSize: file.data?.length.toString() || \"0\",\n                          fileUrl: `https://${cosData.Location}`,\n                        });\n                      }\n                    }\n                    break;\n                  }\n                  default: {\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      message: newMessage,\n      fileInfos,\n      failedFiles,\n    };\n  }\n\n  private async getCosParams(mimeType: string) {\n    const extName = MIME_TYPES?.[mimeType];\n    if (!extName) {\n      throw new Error(`Unsupported mime type: ${mimeType}`);\n    }\n    const isPicture = Object.keys(IMAGE_MIME_TYPES).includes(mimeType);\n    const bizIdRes = await this.reqLkeClient.DescribeRobotBizIDByAppKey({\n      AppKey: this.finalAppKey,\n    });\n    const storageRes = await this.reqLkeClient.DescribeStorageCredential({\n      BotBizId: bizIdRes.BotBizId,\n      FileType: extName,\n      IsPublic: isPicture,\n      TypeKey: \"realtime\",\n    });\n    return storageRes;\n  }\n\n  private async uploadToCos(\n    files: BinaryInputContent[],\n    onSuccess: (\n      result: COS.PutObjectResult,\n      cosParams: CosParams,\n      file: BinaryInputContent\n    ) => void,\n    onError: (fileName: string, error: string) => void\n  ) {\n    const promises: Promise<void>[] = [];\n    for (const file of files) {\n      const extName = MIME_TYPES?.[file.mimeType];\n      if (!extName) {\n        onError(file.filename || \"unknown-file\", \"Unsupported file type\");\n        continue;\n      }\n      const cosParams = await this.getCosParams(file.mimeType);\n      const cosClient = new COS({\n        SecretId: cosParams.Credentials?.TmpSecretId,\n        SecretKey: cosParams.Credentials?.TmpSecretKey,\n        SecurityToken: cosParams.Credentials?.Token,\n      });\n      if (!cosParams.Bucket || !cosParams.Region || !cosParams.UploadPath) {\n        onError(file.filename || \"unknown-file\", \"Failed to get COS params\");\n        continue;\n      }\n      const promise = new Promise<void>((resolve, reject) => {\n        cosClient.putObject(\n          {\n            Bucket: cosParams.Bucket!,\n            Region: cosParams.Region!,\n            Key: cosParams.UploadPath!,\n            Body: file.data!,\n          },\n          (err, data) => {\n            if (err) {\n              onError(file.filename || \"unknown-file\", err.message);\n              reject();\n            } else {\n              onSuccess(data, cosParams, file);\n              resolve();\n            }\n          }\n        );\n      });\n      promises.push(promise);\n    }\n    await Promise.allSettled(promises);\n  }\n}\n","/**\n * 将小驼峰字符串转换为下划线格式\n * 例如: \"userName\" -> \"user_name\"\n */\nfunction camelToSnake(str: string): string {\n  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);\n}\n\n/**\n * 递归地将对象的所有小驼峰属性名转换为下划线格式\n */\nexport function camelToSnakeKeys<T>(obj: T): T {\n  if (obj === null || obj === undefined) {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map((item) => camelToSnakeKeys(item)) as T;\n  }\n\n  if (typeof obj === \"object\") {\n    const result: Record<string, unknown> = {};\n    for (const [key, value] of Object.entries(obj)) {\n      const snakeKey = camelToSnake(key);\n      result[snakeKey] = camelToSnakeKeys(value);\n    }\n    return result as T;\n  }\n\n  return obj;\n}\n","export const DOCUMENT_MIME_TYPES: Record<string, string> = {\n  \"text/plain\": \"txt\",\n  \"application/msword\": \"doc\",\n  \"application/vnd.openxmlformats-officedocument.wordprocessingml.document\":\n    \"docx\",\n  \"application/pdf\": \"pdf\",\n  \"application/vnd.ms-powerpoint\": \"ppt\",\n  \"application/vnd.openxmlformats-officedocument.presentationml.presentation\":\n    \"pptx\",\n};\n\nexport const IMAGE_MIME_TYPES: Record<string, string> = {\n  \"image/png\": \"png\",\n  \"image/jpeg\": \"jpg\",\n  \"image/bmp\": \"bmp\",\n};\n\nexport const MIME_TYPES: Record<string, string> = {\n  ...DOCUMENT_MIME_TYPES,\n  ...IMAGE_MIME_TYPES,\n};\n","/**\n * 文件信息\n */\nexport interface FileInfo {\n  /** 文件名称 */\n  fileName: string;\n\n  /** 文件大小（实时文档解析接口返回） */\n  fileSize: string;\n\n  /** 文件 URL（实时文档解析接口返回） */\n  fileUrl: string;\n\n  /** 文件类型 */\n  fileType: string;\n\n  /** 文档 ID（实时文档解析接口返回） */\n  docId: string;\n\n  /** 扩展参数 */\n  [key: string]: any;\n}\n\n/**\n * ADP 对话请求参数\n */\nexport interface AdpChatRequest {\n  /** 请求 ID，用于标识一个请求 */\n  requestId?: string;\n\n  /** 消息内容 */\n  content: string;\n\n  /** 文件信息 */\n  fileInfos?: FileInfo[];\n\n  /** 会话 ID，用于标识一个会话 */\n  sessionId: string;\n\n  /** 应用密钥 */\n  botAppKey: string;\n\n  /** 访客 ID，标识当前接入会话的用户 */\n  visitorBizId: string;\n\n  /** 流式回复频率控制，控制应用回包频率 */\n  streamingThrottle?: number;\n\n  /** 自定义参数，用于传递参数给工作流或设置知识库检索范围 */\n  customVariables?: Record<string, string>;\n\n  /** 角色指令（提示词） */\n  systemRole?: string;\n\n  /** 控制回复事件和思考事件中的 content 是否是增量输出 */\n  incremental?: boolean;\n\n  /** 是否开启联网搜索：空字符串-跟随配置 / enable / disable */\n  searchNetwork?: \"\" | \"enable\" | \"disable\";\n\n  /** 指定模型名称 */\n  modelName?: string;\n\n  /** 是否开启流式传输：空字符串-跟随配置 / enable / disable */\n  stream?: \"\" | \"enable\" | \"disable\";\n\n  /** 是否开启工作流：空字符串-跟随配置 / enable / disable */\n  workflowStatus?: \"\" | \"enable\" | \"disable\";\n\n  /** 扩展参数 */\n  [key: string]: any;\n}\n\nexport type AdpConfig = {\n  request?: {\n    baseUrl?: string;\n    endpoint?: string;\n    body?: Partial<AdpChatRequest>;\n    docParseEndpoint?: string;\n  };\n  historyCount?: number;\n  enableUpload?: boolean;\n  appKey?: string;\n  credential?: {\n    secretId?: string;\n    secretKey?: string;\n    token?: string;\n  };\n};\n\nexport type AdpChunk =\n  | { type: \"reply\"; payload: ReplyEvent; message_id: string }\n  | { type: \"thought\"; payload: ThoughtEvent; message_id: string }\n  | { type: \"token_stat\"; payload: TokenStatEvent; message_id: string }\n  | { type: \"reference\"; payload: ReferenceEvent; message_id: string }\n  | { type: \"error\"; error: ErrorInfo };\n\n// 回复事件类型定义\nexport interface ReplyEvent {\n  request_id: string; // 请求 ID，用于标识一个请求\n  content: string; // 消息内容\n  file_infos: FileInfo[]; // 文件信息\n  record_id: string; // 消息唯一 ID\n  related_record_id: string; // 关联的消息唯一 ID\n  session_id: string; // 会话 ID\n  is_from_self: boolean; // 消息是否由自己发出\n  can_rating: boolean; // 该消息记录是否能评价\n  timestamp: number; // 消息时间戳（秒级）\n  is_final: boolean; // 消息是否已输出完\n  is_evil: boolean; // 是否命中敏感内容\n  is_llm_generated: boolean; // 是否为模型生成内容\n  reply_method: ReplyMethod; // 回复方式\n  knowledge?: Knowledge[]; // 命中的知识\n  option_cards?: string[]; // 选项卡，任务流程专有\n  custom_params?: string[]; // 用户自定义业务参数\n  task_flow?: TaskFlow; // 任务流程调试信息\n  work_flow?: WorkFlow; // 工作流调试信息\n  quote_infos?: QuoteInfo[]; // 引用信息\n}\n\n// 回复方式枚举\nexport enum ReplyMethod {\n  LLM_REPLY = 1,\n  UNKNOWN_QUESTION_REPLY = 2,\n  REJECT_QUESTION_REPLY = 3,\n  SENSITIVE_REPLY = 4,\n  ADOPTED_QA_PRIORITY_REPLY = 5,\n  WELCOME_REPLY = 6,\n  CONCURRENCY_LIMIT_REPLY = 7,\n  GLOBAL_INTERVENTION_KNOWLEDGE = 8,\n  TASK_FLOW_REPLY = 9,\n  TASK_FLOW_ANSWER = 10,\n  SEARCH_ENGINE_REPLY = 11,\n  KNOWLEDGE_POLISHED_REPLY = 12,\n  IMAGE_UNDERSTANDING_REPLY = 13,\n  REALTIME_DOCUMENT_REPLY = 14,\n  CLARIFICATION_CONFIRMATION_REPLY = 15,\n  WORKFLOW_REPLY = 16,\n  WORKFLOW_EXECUTION_END = 17,\n  AGENT_REPLY = 18,\n  MULTI_INTENT_REPLY = 19,\n}\n\n// 命中的知识类型\nexport interface Knowledge {\n  id: string; // 命中的知识 ID\n  type: number; // 命中的知识类型: 1: 问答, 2: 文档片段\n  seg_id?: string; // 片段 ID\n}\n\n// 任务流调试信息\nexport interface TaskFlow {\n  task_flow_name: string; // 任务流程名称\n  task_flow_id: string; // 任务流程 ID\n  query_rewrite: string; // 问题改写结果\n  hit_intent: string; // 命中的意图\n  slot_info: Record<string, any>; // 运行时收集的槽位信息\n  api_response: Record<string, any>; // API 节点的返回信息\n  type: number; // 任务流程回复类型\n}\n\n// 工作流调试信息\nexport interface WorkFlow {\n  workflow_name: string; // 工作流名称\n  workflow_id: string; // 工作流ID\n  workflow_run_id: string; // 工作流运行ID\n  option_cards: string[]; // 选项卡\n  current_node: CurrentNode; // 当前节点信息\n  outputs: Array<string>; // 输出结果\n}\n\nexport enum CurrentNodeStatus {\n  Pending = 0,\n  Running = 1,\n  Succeeded = 2,\n  Failed = 3,\n}\n\n// 当前工作流节点信息\nexport interface CurrentNode {\n  NodeID: string; // 节点ID\n  NodeType: number; // 节点类型\n  NodeName: string; // 节点名称\n  Status: CurrentNodeStatus; // 状态\n  Input: string; // 节点的输入\n  Output: string; // 节点的最终输出\n  TaskOutput: string; // 任务的输出\n  FailMessage: string; // 异常信息\n  CostMilliSeconds: string; // 节点的总耗时\n  Reply: string; // 当前节点的回复内容\n  BelongNodeID: string; // 节点所属工作流被引用时的引用节点的ID\n  StatisticInfo: StatisticInfo; // LLM 统计信息\n}\n\n// LLM 统计信息\nexport interface StatisticInfo {\n  ModelName: string; // 模型名称\n  FirstTokenCost: number; // 首token耗时\n  TotalCost: number; // 推理总耗时\n  InputTokens: number; // 输入token数量\n  OutputTokens: number; // 输出token数量\n  TotalTokens: number; // 输入+输出总token\n}\n\n// 引用信息\nexport interface QuoteInfo {\n  index: number; // 引用的角标索引\n  position: number; // 在回复内容中的位置\n}\n\n// token统计事件类型定义\nexport interface TokenStatEvent {\n  session_id: string; // 会话 id\n  request_id: string; // 对应发送事件对应的请求 id\n  record_id: string; // 对应发送事件对应的消息记录 id\n  status_summary: \"processing\" | \"success\" | \"failed\"; // 本轮对话状态\n  status_summary_title: string; // 本轮对话状态描述\n  elapsed: number; // 本轮调用耗时, 单位 ms\n  token_count: number; // 本轮请求消耗 token 数\n  procedures: TokenStatProcedure[]; // 调用过程列表\n}\n\n// token统计调用过程\nexport interface TokenStatProcedure {\n  name: string; // 英文名\n  title: string; // 调用过程描述\n  status: \"processing\" | \"success\" | \"failed\"; // 调用过程状态\n  input_count: number; // 当次过程输入消耗 token 数\n  output_count: number; // 当次过程输出消耗 token 数\n  count: number; // 当次过程消耗总 token 数\n}\n\n// 参考来源事件类型定义\nexport interface ReferenceEvent {\n  record_id: string; // 消息唯一 ID\n  references: Reference[]; // 参考来源\n}\n\n// 参考来源\nexport interface Reference {\n  id: string | number; // 参考来源ID\n  type: number; // 参考来源类型: 1：问答, 2：文档片段, 4：联网检索到的内容\n  url?: string; // 参考来源链接（仅参考来源类型为文档片段时使用）\n  name: string; // 参考来源名称\n  doc_id: number; // 参考来源文档 ID\n  doc_biz_id: number; // 参考来源文档业务 ID\n  doc_name: string; // 参考来源文档名称\n  qa_biz_id: string; // 参考来源问答业务 ID\n}\n\n// 错误信息\nexport interface ErrorInfo {\n  code: number; // 错误码\n  message: string; // 错误信息\n}\n\n// 思考事件类型定义\nexport interface ThoughtEvent {\n  elapsed: number; // 本轮调用耗时, 单位 ms\n  is_workflow: boolean; // 是否工作流\n  procedures: ThoughtProcedure[]; // 调用过程列表\n  record_id: string; // 对应发送事件对应的消息记录 id\n  request_id: string; // 对应发送事件对应的请求 id\n  session_id: string; // 会话 id\n  trace_id: string; // 链路 id\n  workflow_name: string; // 工作流名称\n}\n\n// 思考调用过程\nexport interface ThoughtProcedure {\n  debugging: Debugging; // 调试过程信息\n  index: number; // 过程索引\n  name: string; // 英文名\n  title: string; // 调用过程描述\n  status: \"processing\" | \"success\" | \"failed\"; // 状态\n  icon: string; // 图标\n  switch: string; // 是否切换Agent\n  workflow_name: string; // 工作流名称\n  plugin_type: number; // 插件类型: 0: 自定义插件; 1: 官方插件; 2: 工作流\n  elapsed: number; // 当前请求执行时间, 单位 ms\n}\n\n// 调试过程信息\nexport interface Debugging {\n  content: string; // 调试过程中输出的内容\n}\n\n// 文档解析请求\nexport interface DocumentParseRequest {\n  sessionId: string;\n  botAppKey: string;\n  requestId: string;\n  cosBucket: string;\n  fileType: string;\n  fileName: string;\n  cosUrl: string;\n  cosHash: string;\n  eTag: string;\n  size: string;\n}\n\nexport interface DocumentParseChunk {\n  type: \"parsing\";\n  payload: ParsingEvent;\n}\n\n// 文档解析响应事件\nexport interface ParsingEvent {\n  session_id: string;\n  trace_id: string;\n  is_final: boolean;\n  doc_id: string;\n  process: number;\n  status: string;\n  timestamp: number;\n  error_message: string;\n}\n"],"mappings":"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","names":["ReplyMethod","CurrentNodeStatus"]}