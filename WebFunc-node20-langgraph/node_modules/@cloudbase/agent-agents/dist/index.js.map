{"version":3,"sources":["../src/core/events.ts","../src/core/storage/memory/in-memory/in-memory-query-builder.ts","../src/core/storage/memory/in-memory/in-memory-adapter.ts","../src/agkit/agent.ts","../src/agkit/converter.ts","../src/index.ts","../src/core/agent.ts","../src/core/errors.ts","../src/core/config-validation.ts","../src/core/tool-proxy.ts","../src/core/tool-execution-handler.ts","../src/core/message-builder.ts","../src/core/agent-executor.ts","../src/core/storage/utils/token-utils.ts","../src/core/storage/memory/memory-base.ts","../src/core/storage/memory/in-memory/utils.ts","../src/core/storage/memory/common/state-manager.ts","../src/core/storage/memory/common/cursor-manager.ts","../src/core/storage/memory/common/summary-manager.ts","../src/core/storage/memory/common/branch-manager.ts","../src/core/storage/memory/in-memory/in-memory-memory.ts","../src/core/type-validation.ts","../src/core/index.ts","../src/core/optimized-events.ts","../src/core/providers/model-provider.ts","../src/core/providers/openai-provider.ts","../src/core/providers/anthropic-provider.ts","../src/core/providers/factory.ts","../src/core/tool-helpers.ts","../src/core/conversation-manager.ts","../src/agkit/index.ts","../src/core/storage/tdaimemory/errors.ts","../src/core/storage/tdaimemory/stub.ts","../src/core/storage/tdaimemory/client.ts","../src/core/storage/tdaimemory/params.ts","../src/core/storage/memory/tdai-memory.ts","../src/core/storage/memory/cloudbase/cloudbase-query-builder.ts","../src/core/storage/memory/cloudbase/cloudbase-adapter.ts","../src/core/storage/memory/cloudbase/utils.ts","../src/core/storage/memory/cloudbase/cloudbase-memory.ts","../src/core/storage/memory/mongodb/mongodb-memory.ts","../src/core/storage/memory/mongodb/mongodb-query-builder.ts","../src/core/storage/memory/mongodb/mongodb-adapter.ts","../src/core/storage/memory/mongodb/collection-manager.ts","../src/core/storage/memory/common/document-converter.ts","../src/core/storage/memory/mysql/mysql-memory.ts","../src/core/storage/memory/typeorm/typeorm-memory.ts","../src/core/storage/memory/typeorm/typeorm-query-builder.ts","../src/core/storage/memory/typeorm/typeorm-adapter.ts","../src/core/storage/memory/typeorm/typeorm-collection-manager.ts","../src/core/storage/memory/typeorm/entities/memory-event.entity.ts","../src/core/storage/memory/typeorm/entities/memory-state.entity.ts","../src/core/storage/memory/typeorm/entities/memory-summary.entity.ts","../src/core/storage/memory/mysql/index.ts","../src/core/storage/memory/typeorm/index.ts","../src/core/storage/long-term-memory/long-term-memory-base.ts","../src/core/storage/long-term-memory/tdai-long-term-memory.ts","../src/core/storage/long-term-memory/mem0-long-term-memory.ts"],"sourcesContent":["import { EventEmitter } from \"events\";\nimport { Message, ToolCall, AgentError } from \"./types\";\n\n// Event type enumeration - matches AG-UI Protocol Buffers naming\nexport enum EventType {\n  // Core AG-UI Protocol events (matches protobuf exactly)\n  TEXT_MESSAGE_START = 'TEXT_MESSAGE_START',\n  TEXT_MESSAGE_CONTENT = 'TEXT_MESSAGE_CONTENT',\n  TEXT_MESSAGE_END = 'TEXT_MESSAGE_END',\n  TOOL_CALL_START = 'TOOL_CALL_START',\n  TOOL_CALL_ARGS = 'TOOL_CALL_ARGS',\n  TOOL_CALL_END = 'TOOL_CALL_END',\n  STATE_SNAPSHOT = 'STATE_SNAPSHOT',\n  STATE_DELTA = 'STATE_DELTA',\n  MESSAGES_SNAPSHOT = 'MESSAGES_SNAPSHOT',\n  RAW = 'RAW',\n  CUSTOM = 'CUSTOM',\n  RUN_STARTED = 'RUN_STARTED',\n  RUN_FINISHED = 'RUN_FINISHED',\n  RUN_ERROR = 'RUN_ERROR',\n  STEP_STARTED = 'STEP_STARTED',\n  STEP_FINISHED = 'STEP_FINISHED',\n  // Additional AG-UI Protocol events\n  TEXT_MESSAGE_CHUNK = 'TEXT_MESSAGE_CHUNK',\n  TOOL_CALL_CHUNK = 'TOOL_CALL_CHUNK',\n  // AG-Kit specific extensions\n  TOOL_CALL_RESULT = 'TOOL_CALL_RESULT',\n  TOOL_REGISTERED = 'TOOL_REGISTERED',\n  TOOL_UNREGISTERED = 'TOOL_UNREGISTERED',\n  TOOL_VALIDATION_FAILED = 'TOOL_VALIDATION_FAILED',\n  STATE_UPDATE = 'STATE_UPDATE',\n  APPROVAL_REQUIRED = 'APPROVAL_REQUIRED',\n  APPROVAL_RECEIVED = 'APPROVAL_RECEIVED',\n  CONVERSATION_CREATED = 'CONVERSATION_CREATED',\n  CONVERSATION_UPDATED = 'CONVERSATION_UPDATED',\n  CONVERSATION_DELETED = 'CONVERSATION_DELETED',\n  CONTROL_FLOW_DECISION = 'CONTROL_FLOW_DECISION',\n  EXECUTION_PAUSED = 'EXECUTION_PAUSED',\n  EXECUTION_RESUMED = 'EXECUTION_RESUMED',\n}\n\n// Base event interface - matches AG-UI Protocol Buffers\nexport interface BaseEvent {\n  type: EventType;\n  timestamp?: number;\n  rawEvent?: any; // google.protobuf.Value equivalent\n}\n\n// Run lifecycle events - matches AG-UI Protocol Buffers\nexport interface RunStartedEvent extends BaseEvent {\n  type: EventType.RUN_STARTED;\n  threadId: string; // matches AG-UI thread_id\n  runId: string;    // matches AG-UI run_id\n  input?: string | Message[];\n  options?: any;\n}\n\nexport interface RunFinishedEvent extends BaseEvent {\n  type: EventType.RUN_FINISHED;\n  threadId: string; // matches AG-UI thread_id\n  runId: string;    // matches AG-UI run_id\n  result?: any;\n  executionTime?: number; // AG-Kit specific\n}\n\nexport interface RunErrorEvent extends BaseEvent {\n  type: EventType.RUN_ERROR;\n  threadId: string; // matches AG-UI thread_id\n  runId: string;    // matches AG-UI run_id\n  code?: string;    // matches AG-UI optional code\n  message: string;  // matches AG-UI message\n  executionTime?: number; // AG-Kit specific\n}\n\n// Step events - matches AG-UI Protocol Buffers\nexport interface StepStartedEvent extends BaseEvent {\n  type: EventType.STEP_STARTED;\n  stepName: string; // matches AG-UI step_name\n}\n\nexport interface StepFinishedEvent extends BaseEvent {\n  type: EventType.STEP_FINISHED;\n  stepName: string; // matches AG-UI step_name\n}\n\n// Message events - matches AG-UI Protocol Buffers\nexport interface TextMessageStartEvent extends BaseEvent {\n  type: EventType.TEXT_MESSAGE_START;\n  messageId: string; // matches AG-UI message_id\n  role?: string;     // matches AG-UI optional role\n}\n\nexport interface TextMessageContentEvent extends BaseEvent {\n  type: EventType.TEXT_MESSAGE_CONTENT;\n  messageId: string; // matches AG-UI message_id\n  delta: string;     // matches AG-UI delta\n}\n\nexport interface TextMessageEndEvent extends BaseEvent {\n  type: EventType.TEXT_MESSAGE_END;\n  messageId: string; // matches AG-UI message_id\n}\n\n// Additional message event for AG-UI compatibility\nexport interface TextMessageChunkEvent extends BaseEvent {\n  type: EventType.TEXT_MESSAGE_CHUNK;\n  messageId?: string; // matches AG-UI optional message_id\n  role?: string;      // matches AG-UI optional role\n  delta?: string;     // matches AG-UI optional delta\n}\n\nexport interface MessagesSnapshotEvent extends BaseEvent {\n  type: EventType.MESSAGES_SNAPSHOT;\n  messages: Message[]; // matches AG-UI repeated Message messages\n}\n\n// Tool call events - matches AG-UI Protocol Buffers\nexport interface ToolCallStartEvent extends BaseEvent {\n  type: EventType.TOOL_CALL_START;\n  toolCallId: string;     // matches AG-UI tool_call_id\n  toolCallName: string;   // matches AG-UI tool_call_name\n  parentMessageId?: string; // matches AG-UI optional parent_message_id\n}\n\nexport interface ToolCallArgsEvent extends BaseEvent {\n  type: EventType.TOOL_CALL_ARGS;\n  toolCallId: string; // matches AG-UI tool_call_id\n  delta: string;      // matches AG-UI delta\n}\n\nexport interface ToolCallEndEvent extends BaseEvent {\n  type: EventType.TOOL_CALL_END;\n  toolCallId: string; // matches AG-UI tool_call_id\n}\n\n// Additional tool call event for AG-UI compatibility\nexport interface ToolCallChunkEvent extends BaseEvent {\n  type: EventType.TOOL_CALL_CHUNK;\n  toolCallId?: string;     // matches AG-UI optional tool_call_id\n  toolCallName?: string;   // matches AG-UI optional tool_call_name\n  parentMessageId?: string; // matches AG-UI optional parent_message_id\n  delta?: string;          // matches AG-UI optional delta\n}\n\nexport interface ToolCallResultEvent extends BaseEvent {\n  type: EventType.TOOL_CALL_RESULT;\n  toolCallId: string;\n  content: string;\n  messageId: string;\n  conversationId: string;\n  runId: string;\n}\n\n// Tool management events\nexport interface ToolRegisteredEvent extends BaseEvent {\n  type: EventType.TOOL_REGISTERED;\n  toolName: string;\n}\n\nexport interface ToolUnregisteredEvent extends BaseEvent {\n  type: EventType.TOOL_UNREGISTERED;\n  toolName: string;\n}\n\nexport interface ToolValidationFailedEvent extends BaseEvent {\n  type: EventType.TOOL_VALIDATION_FAILED;\n  toolName: string;\n  input: any;\n  error: string;\n}\n\n// System events\nexport interface StateUpdateEvent extends BaseEvent {\n  type: EventType.STATE_UPDATE;\n  state: any;\n  conversationId: string;\n  runId: string;\n}\n\nexport interface ApprovalRequiredEvent extends BaseEvent {\n  type: EventType.APPROVAL_REQUIRED;\n  interruptId: string;\n  toolName: string;\n  params: any;\n  conversationId: string;\n  runId: string;\n  message: string;\n  context: any;\n}\n\nexport interface ApprovalReceivedEvent extends BaseEvent {\n  type: EventType.APPROVAL_RECEIVED;\n  interruptId: string;\n  action: 'approve' | 'reject' | 'modify';\n  value?: any;\n  reason?: string;\n  conversationId: string;\n  runId: string;\n}\n\nexport interface ErrorEvent extends BaseEvent {\n  type: EventType.RUN_ERROR;\n  error: AgentError;\n  context?: any;\n  conversationId?: string;\n  runId?: string;\n}\n\n// State management events - matches AG-UI Protocol Buffers\nexport interface StateSnapshotEvent extends BaseEvent {\n  type: EventType.STATE_SNAPSHOT;\n  snapshot: any; // matches AG-UI google.protobuf.Value snapshot\n}\n\nexport interface StateDeltaEvent extends BaseEvent {\n  type: EventType.STATE_DELTA;\n  delta: any[]; // matches AG-UI repeated JsonPatchOperation delta\n}\n\n// Conversation events\nexport interface ConversationCreatedEvent extends BaseEvent {\n  type: EventType.CONVERSATION_CREATED;\n  conversation: any;\n  conversationId: string;\n}\n\nexport interface ConversationUpdatedEvent extends BaseEvent {\n  type: EventType.CONVERSATION_UPDATED;\n  conversation: any;\n  conversationId: string;\n  updates: any;\n}\n\nexport interface ConversationDeletedEvent extends BaseEvent {\n  type: EventType.CONVERSATION_DELETED;\n  conversationId: string;\n}\n\n// Control flow events\nexport interface ControlFlowDecisionEvent extends BaseEvent {\n  type: EventType.CONTROL_FLOW_DECISION;\n  decision: any;\n  context: any;\n  conversationId: string;\n  runId: string;\n}\n\nexport interface ExecutionPausedEvent extends BaseEvent {\n  type: EventType.EXECUTION_PAUSED;\n  reason: string;\n  resumeData?: any;\n  conversationId: string;\n  runId: string;\n}\n\nexport interface ExecutionResumedEvent extends BaseEvent {\n  type: EventType.EXECUTION_RESUMED;\n  resumeData?: any;\n  conversationId: string;\n  runId: string;\n}\n\n// Special events - matches AG-UI Protocol Buffers\nexport interface RawEvent extends BaseEvent {\n  type: EventType.RAW;\n  event: any;      // matches AG-UI google.protobuf.Value event\n  source?: string; // matches AG-UI optional string source\n}\n\nexport interface CustomEvent extends BaseEvent {\n  type: EventType.CUSTOM;\n  name: string;  // matches AG-UI string name\n  value?: any;   // matches AG-UI optional google.protobuf.Value value\n}\n\n// Union type for all events\nexport type AgentEvent = \n  | RunStartedEvent\n  | RunFinishedEvent\n  | RunErrorEvent\n  | StepStartedEvent\n  | StepFinishedEvent\n  | TextMessageStartEvent\n  | TextMessageContentEvent\n  | TextMessageEndEvent\n  | TextMessageChunkEvent\n  | MessagesSnapshotEvent\n  | ToolCallStartEvent\n  | ToolCallArgsEvent\n  | ToolCallEndEvent\n  | ToolCallChunkEvent\n  | ToolCallResultEvent\n  | ToolRegisteredEvent\n  | ToolUnregisteredEvent\n  | ToolValidationFailedEvent\n  | StateUpdateEvent\n  | StateSnapshotEvent\n  | StateDeltaEvent\n  | ApprovalRequiredEvent\n  | ApprovalReceivedEvent\n  | ErrorEvent\n  | ConversationCreatedEvent\n  | ConversationUpdatedEvent\n  | ConversationDeletedEvent\n  | ControlFlowDecisionEvent\n  | ExecutionPausedEvent\n  | ExecutionResumedEvent\n  | RawEvent\n  | CustomEvent;\n\n// Event data type mapping for type-safe event handling\nexport interface EventData {\n  [EventType.TEXT_MESSAGE_START]: TextMessageStartEvent;\n  [EventType.TEXT_MESSAGE_CONTENT]: TextMessageContentEvent;\n  [EventType.TEXT_MESSAGE_END]: TextMessageEndEvent;\n  [EventType.TOOL_CALL_START]: ToolCallStartEvent;\n  [EventType.TOOL_CALL_ARGS]: ToolCallArgsEvent;\n  [EventType.TOOL_CALL_END]: ToolCallEndEvent;\n  [EventType.STATE_SNAPSHOT]: StateSnapshotEvent;\n  [EventType.STATE_DELTA]: StateDeltaEvent;\n  [EventType.MESSAGES_SNAPSHOT]: MessagesSnapshotEvent;\n  [EventType.RAW]: RawEvent;\n  [EventType.CUSTOM]: CustomEvent;\n  [EventType.RUN_STARTED]: RunStartedEvent;\n  [EventType.RUN_FINISHED]: RunFinishedEvent;\n  [EventType.RUN_ERROR]: RunErrorEvent;\n  [EventType.STEP_STARTED]: StepStartedEvent;\n  [EventType.STEP_FINISHED]: StepFinishedEvent;\n  // Additional AG-Kit specific events\n  [EventType.TEXT_MESSAGE_CHUNK]: TextMessageChunkEvent;\n  [EventType.TOOL_CALL_CHUNK]: ToolCallChunkEvent;\n  [EventType.TOOL_CALL_RESULT]: ToolCallResultEvent;\n  [EventType.TOOL_REGISTERED]: ToolRegisteredEvent;\n  [EventType.TOOL_UNREGISTERED]: ToolUnregisteredEvent;\n  [EventType.TOOL_VALIDATION_FAILED]: ToolValidationFailedEvent;\n  [EventType.STATE_UPDATE]: StateUpdateEvent;\n  [EventType.APPROVAL_REQUIRED]: ApprovalRequiredEvent;\n  [EventType.APPROVAL_RECEIVED]: ApprovalReceivedEvent;\n  [EventType.RUN_ERROR]: RunErrorEvent;\n  [EventType.CONVERSATION_CREATED]: ConversationCreatedEvent;\n  [EventType.CONVERSATION_UPDATED]: ConversationUpdatedEvent;\n  [EventType.CONVERSATION_DELETED]: ConversationDeletedEvent;\n  [EventType.CONTROL_FLOW_DECISION]: ControlFlowDecisionEvent;\n  [EventType.EXECUTION_PAUSED]: ExecutionPausedEvent;\n  [EventType.EXECUTION_RESUMED]: ExecutionResumedEvent;\n}\n\n// Event handler type\nexport type EventHandler<T extends EventType> = (data: EventData[T]) => void;\n\n// Event system class\nexport class EventSystem extends EventEmitter {\n  constructor() {\n    super();\n    this.setMaxListeners(100); // Allow more listeners for complex agents\n  }\n\n  // Type-safe event emission\n  emit<T extends EventType>(event: T, data: EventData[T]): boolean {\n    return super.emit(event, { ...data, timestamp: Date.now() });\n  }\n  \n  // Type-safe event listening\n  on<T extends EventType>(event: T, handler: EventHandler<T>): this {\n    return super.on(event, handler);\n  }\n  \n  // Type-safe event listening (once)\n  once<T extends EventType>(event: T, handler: EventHandler<T>): this {\n    return super.once(event, handler);\n  }\n  \n  // Type-safe event removal\n  off<T extends EventType>(event: T, handler: EventHandler<T>): this {\n    return super.off(event, handler);\n  }\n  \n  // Remove all listeners for a specific event\n  removeAllListeners<T extends EventType>(event?: T): this {\n    return super.removeAllListeners(event);\n  }\n  \n  // Get listener count for an event\n  listenerCount<T extends EventType>(event: T): number {\n    return super.listenerCount(event);\n  }\n  \n  // Get all event names that have listeners\n  getEventNames(): EventType[] {\n    return super.eventNames() as EventType[];\n  }\n  \n  // Check if an event has listeners\n  hasListeners<T extends EventType>(event: T): boolean {\n    return this.listenerCount(event) > 0;\n  }\n  \n  // Emit event with error handling\n  safeEmit<T extends EventType>(event: T, data: EventData[T]): boolean {\n    try {\n      return this.emit(event, data);\n    } catch (error) {\n      console.error(`Error emitting event ${event}:`, error);\n      return false;\n    }\n  }\n  \n  // Create a promise that resolves when an event is emitted\n  waitFor<T extends EventType>(event: T, timeout?: number): Promise<EventData[T]> {\n    return new Promise((resolve, reject) => {\n      const timeoutId = timeout ? setTimeout(() => {\n        reject(new Error(`Timeout waiting for event ${event}`));\n      }, timeout) : undefined;\n      \n      this.once(event, (data) => {\n        if (timeoutId) {\n          clearTimeout(timeoutId);\n        }\n        resolve(data);\n      });\n    });\n  }\n  \n  // Create a promise that resolves when any of the specified events are emitted\n  waitForAny<T extends EventType>(events: T[], timeout?: number): Promise<{ event: T; data: EventData[T] }> {\n    return new Promise((resolve, reject) => {\n      const timeoutId = timeout ? setTimeout(() => {\n        reject(new Error(`Timeout waiting for any of events: ${events.join(', ')}`));\n      }, timeout) : undefined;\n      \n      const handlers = new Map<T, EventHandler<T>>();\n      \n      events.forEach(event => {\n        const handler: EventHandler<T> = (data) => {\n          // Clean up all handlers\n          events.forEach(e => {\n            if (handlers.has(e)) {\n              this.off(e, handlers.get(e)!);\n            }\n          });\n          \n          if (timeoutId) {\n            clearTimeout(timeoutId);\n          }\n          \n          resolve({ event, data });\n        };\n        \n        handlers.set(event, handler);\n        this.once(event, handler);\n      });\n    });\n  }\n}\n","/**\n * In-Memory Query Builder\n *\n * Implements query building for in-memory collections using JavaScript filtering\n */\n\nimport { IQueryBuilder, IUpdateBuilder, ComparisonOperator } from \"../common/query-builder\";\n\n/**\n * In-memory query builder that builds JavaScript filter functions\n */\nexport class InMemoryQueryBuilder implements IQueryBuilder {\n  private conditions: Array<(doc: any) => boolean> = [];\n\n  where(field: string, operator: ComparisonOperator, value: any): this {\n    const condition = this.buildCondition(field, operator, value);\n    this.conditions.push(condition);\n    return this;\n  }\n\n  and(field: string, operator: ComparisonOperator, value: any): this {\n    return this.where(field, operator, value);\n  }\n\n  or(conditions: IQueryBuilder[]): this {\n    const orCondition = (doc: any) => {\n      return conditions.some(builder => {\n        const builtQuery = builder.build();\n        return builtQuery(doc);\n      });\n    };\n    this.conditions.push(orCondition);\n    return this;\n  }\n\n  in(field: string, values: any[]): this {\n    const condition = (doc: any) => {\n      const fieldValue = this.getFieldValue(doc, field);\n      return values.includes(fieldValue);\n    };\n    this.conditions.push(condition);\n    return this;\n  }\n\n  nin(field: string, values: any[]): this {\n    const condition = (doc: any) => {\n      const fieldValue = this.getFieldValue(doc, field);\n      return !values.includes(fieldValue);\n    };\n    this.conditions.push(condition);\n    return this;\n  }\n\n  regex(field: string, pattern: string | RegExp, flags?: string): this {\n    const regex = typeof pattern === 'string' ? new RegExp(pattern, flags) : pattern;\n    const condition = (doc: any) => {\n      const fieldValue = this.getFieldValue(doc, field);\n      return typeof fieldValue === 'string' && regex.test(fieldValue);\n    };\n    this.conditions.push(condition);\n    return this;\n  }\n\n  clone(): IQueryBuilder {\n    const cloned = new InMemoryQueryBuilder();\n    cloned.conditions = [...this.conditions];\n    return cloned;\n  }\n\n  build(): (doc: any) => boolean {\n    if (this.conditions.length === 0) {\n      return () => true; // Match all documents\n    }\n\n    return (doc: any) => {\n      return this.conditions.every(condition => condition(doc));\n    };\n  }\n\n  private buildCondition(field: string, operator: ComparisonOperator, value: any): (doc: any) => boolean {\n    return (doc: any) => {\n      const fieldValue = this.getFieldValue(doc, field);\n      \n      switch (operator) {\n        case 'eq':\n          return fieldValue === value;\n        case 'ne':\n          return fieldValue !== value;\n        case 'gt':\n          return fieldValue > value;\n        case 'gte':\n          return fieldValue >= value;\n        case 'lt':\n          return fieldValue < value;\n        case 'lte':\n          return fieldValue <= value;\n        default:\n          throw new Error(`Unsupported operator: ${operator}`);\n      }\n    };\n  }\n\n  private getFieldValue(doc: any, field: string): any {\n    return field.split('.').reduce((obj, key) => obj?.[key], doc);\n  }\n}\n\n/**\n * In-memory update builder that builds update operations\n */\nexport class InMemoryUpdateBuilder implements IUpdateBuilder {\n  private updates: Record<string, any> = {};\n\n  set(field: string, value: any): this {\n    this.updates[field] = value;\n    return this;\n  }\n\n  unset(field: string): this {\n    this.updates[field] = undefined;\n    return this;\n  }\n\n  inc(field: string, value: number): this {\n    // For in-memory, we'll handle this in the adapter\n    this.updates[field] = { $inc: value };\n    return this;\n  }\n\n  push(field: string, value: any): this {\n    // For in-memory, we'll handle this in the adapter\n    this.updates[field] = { $push: value };\n    return this;\n  }\n\n  pull(field: string, value: any): this {\n    // For in-memory, we'll handle this in the adapter\n    this.updates[field] = { $pull: value };\n    return this;\n  }\n\n  clone(): IUpdateBuilder {\n    const cloned = new InMemoryUpdateBuilder();\n    cloned.updates = { ...this.updates };\n    return cloned;\n  }\n\n  build(): Record<string, any> {\n    return { ...this.updates };\n  }\n}","/**\n * In-Memory Database Adapter\n *\n * Implements database operations for in-memory collections using JavaScript arrays\n */\n\nimport { IDatabaseAdapter, QueryOptions } from \"../common/types\";\nimport { IQueryBuilder, IUpdateBuilder } from \"../common/query-builder\";\n// Import will be done lazily to avoid circular dependency\nimport { InMemoryCollection } from \"./types\";\n\n/**\n * In-memory database adapter that operates on JavaScript arrays\n */\nexport class InMemoryAdapter implements IDatabaseAdapter {\n  createQueryBuilder(): IQueryBuilder {\n    // Lazy import to avoid circular dependency\n    const { InMemoryQueryBuilder } = require(\"./in-memory-query-builder\");\n    return new InMemoryQueryBuilder();\n  }\n\n  createUpdateBuilder(): IUpdateBuilder {\n    // Lazy import to avoid circular dependency\n    const { InMemoryUpdateBuilder } = require(\"./in-memory-query-builder\");\n    return new InMemoryUpdateBuilder();\n  }\n\n  async find<T>(\n    collection: InMemoryCollection<T>,\n    query: any,\n    options?: QueryOptions\n  ): Promise<T[]> {\n    let results: T[];\n\n    if (typeof query === 'function') {\n      // Query is a filter function from QueryBuilder\n      results = collection.filter(query);\n    } else {\n      // Query is a plain object - convert to filter function\n      results = collection.filter(doc => this.matchesQuery(doc, query));\n    }\n\n    // Apply sorting\n    if (options?.sort) {\n      results = this.applySorting(results, options.sort);\n    }\n\n    // Apply pagination\n    if (options?.skip) {\n      results = results.slice(options.skip);\n    }\n    if (options?.limit) {\n      results = results.slice(0, options.limit);\n    }\n\n    return results;\n  }\n\n  async findOne<T>(\n    collection: InMemoryCollection<T>,\n    query: any\n  ): Promise<T | null> {\n    const results = await this.find(collection, query, { limit: 1 });\n    return results.length > 0 ? results[0] : null;\n  }\n\n  async insertOne<T>(\n    collection: InMemoryCollection<T>,\n    document: Partial<T>\n  ): Promise<T> {\n    const newDoc = {\n      _id: this.generateId(),\n      ...document,\n    } as T;\n\n    collection.push(newDoc);\n    return newDoc;\n  }\n\n  async insertMany<T>(\n    collection: InMemoryCollection<T>,\n    documents: Partial<T>[]\n  ): Promise<{ insertedCount: number }> {\n    let insertedCount = 0;\n    for (const doc of documents) {\n      await this.insertOne(collection, doc);\n      insertedCount++;\n    }\n    return { insertedCount };\n  }\n\n  async updateOne<T>(\n    collection: InMemoryCollection<T>,\n    filter: any,\n    update: any\n  ): Promise<{ modifiedCount: number }> {\n    const doc = await this.findOne(collection, filter);\n    if (!doc) {\n      return { modifiedCount: 0 };\n    }\n\n    this.applyUpdate(doc, update);\n    return { modifiedCount: 1 };\n  }\n\n  async deleteOne<T>(\n    collection: InMemoryCollection<T>,\n    filter: any\n  ): Promise<{ deletedCount: number }> {\n    const index = collection.findIndex(doc => \n      typeof filter === 'function' ? filter(doc) : this.matchesQuery(doc, filter)\n    );\n\n    if (index === -1) {\n      return { deletedCount: 0 };\n    }\n\n    collection.splice(index, 1);\n    return { deletedCount: 1 };\n  }\n\n  async deleteMany<T>(\n    collection: InMemoryCollection<T>,\n    filter: any\n  ): Promise<{ deletedCount: number }> {\n    let deletedCount = 0;\n    \n    // Delete in reverse order to avoid index shifting issues\n    for (let i = collection.length - 1; i >= 0; i--) {\n      const doc = collection[i];\n      const matches = typeof filter === 'function' ? filter(doc) : this.matchesQuery(doc, filter);\n      \n      if (matches) {\n        collection.splice(i, 1);\n        deletedCount++;\n      }\n    }\n\n    return { deletedCount };\n  }\n\n  async count<T>(\n    collection: InMemoryCollection<T>,\n    query: any\n  ): Promise<number> {\n    const results = await this.find(collection, query);\n    return results.length;\n  }\n\n  private matchesQuery(doc: any, query: any): boolean {\n    if (!query || typeof query !== 'object') {\n      return true;\n    }\n\n    return Object.entries(query).every(([field, value]) => {\n      const docValue = this.getFieldValue(doc, field);\n      \n      if (value && typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date)) {\n        // Handle MongoDB-style operators\n        return Object.entries(value).every(([operator, operatorValue]) => {\n          switch (operator) {\n            case '$gt':\n              return docValue > operatorValue;\n            case '$gte':\n              return docValue >= operatorValue;\n            case '$lt':\n              return docValue < operatorValue;\n            case '$lte':\n              return docValue <= operatorValue;\n            case '$ne':\n            case '$neq':\n              return docValue !== operatorValue;\n            case '$in':\n              return Array.isArray(operatorValue) && operatorValue.includes(docValue);\n            case '$nin':\n              return Array.isArray(operatorValue) && !operatorValue.includes(docValue);\n            case '$regex':\n              const regex = new RegExp(operatorValue);\n              return typeof docValue === 'string' && regex.test(docValue);\n            default:\n              return docValue === operatorValue;\n          }\n        });\n      }\n      \n      return docValue === value;\n    });\n  }\n\n  private getFieldValue(doc: any, field: string): any {\n    return field.split('.').reduce((obj, key) => obj?.[key], doc);\n  }\n\n  private applySorting<T>(results: T[], sort: Record<string, 1 | -1>): T[] {\n    return results.sort((a, b) => {\n      for (const [field, direction] of Object.entries(sort)) {\n        const aValue = this.getFieldValue(a, field);\n        const bValue = this.getFieldValue(b, field);\n        \n        let comparison = 0;\n        if (aValue < bValue) comparison = -1;\n        else if (aValue > bValue) comparison = 1;\n        \n        if (comparison !== 0) {\n          return direction === 1 ? comparison : -comparison;\n        }\n      }\n      return 0;\n    });\n  }\n\n  private applyUpdate(doc: any, update: any): void {\n    Object.entries(update).forEach(([field, value]) => {\n      if (value && typeof value === 'object' && !Array.isArray(value) && !(value instanceof Date)) {\n        // Handle special update operators\n        if (value.$inc !== undefined) {\n          const currentValue = this.getFieldValue(doc, field) || 0;\n          this.setFieldValue(doc, field, currentValue + value.$inc);\n        } else if (value.$push !== undefined) {\n          const currentArray = this.getFieldValue(doc, field) || [];\n          currentArray.push(value.$push);\n        } else if (value.$pull !== undefined) {\n          const currentArray = this.getFieldValue(doc, field) || [];\n          const index = currentArray.indexOf(value.$pull);\n          if (index > -1) {\n            currentArray.splice(index, 1);\n          }\n        } else {\n          this.setFieldValue(doc, field, value);\n        }\n      } else if (value === undefined) {\n        // Unset field\n        this.unsetFieldValue(doc, field);\n      } else {\n        this.setFieldValue(doc, field, value);\n      }\n    });\n  }\n\n  private setFieldValue(doc: any, field: string, value: any): void {\n    const keys = field.split('.');\n    let current = doc;\n    \n    for (let i = 0; i < keys.length - 1; i++) {\n      const key = keys[i];\n      if (!(key in current) || typeof current[key] !== 'object') {\n        current[key] = {};\n      }\n      current = current[key];\n    }\n    \n    current[keys[keys.length - 1]] = value;\n  }\n\n  private unsetFieldValue(doc: any, field: string): void {\n    const keys = field.split('.');\n    let current = doc;\n    \n    for (let i = 0; i < keys.length - 1; i++) {\n      const key = keys[i];\n      if (!(key in current)) {\n        return; // Field doesn't exist\n      }\n      current = current[key];\n    }\n    \n    delete current[keys[keys.length - 1]];\n  }\n\n  private generateId(): string {\n    return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;\n  }\n}","/**\n * AGKitAgent - AG-UI protocol implementation for AG-Kit Agent\n */\n\nimport { AbstractAgent, RunAgentInput, BaseEvent, EventType, AgentConfig } from '@ag-ui/client';\nimport { Observable } from 'rxjs';\nimport { Agent } from '../core/agent';\nimport { EventType as AGKitEventType } from '../core/events';\nimport { Message } from '../core/types';\n\n// Convert AG-UI messages to AG-Kit messages\nfunction convertMessages(aguiMessages: any[]): Message[] {\n  return aguiMessages.map(msg => {\n    // Convert role: developer -> system, other roles remain the same\n    let role: 'user' | 'assistant' | 'system' | 'tool';\n    if (msg.role === 'developer') {\n      role = 'system';\n    } else if (msg.role === 'user' || msg.role === 'assistant' || msg.role === 'system' || msg.role === 'tool') {\n      role = msg.role;\n    } else {\n      // Default to user for unknown roles\n      role = 'user';\n    }\n    \n    return {\n      id: msg.id,\n      role,\n      content: msg.content || '',\n      toolCalls: msg.toolCalls,\n      toolCallId: msg.toolCallId,\n      timestamp: msg.timestamp ? new Date(msg.timestamp) : new Date(),\n      metadata: msg.metadata\n    };\n  });\n}\n\nexport class AGKitAgent extends AbstractAgent {\n  private agent: Agent;\n\n  constructor(agent: Agent, config?: Partial<AgentConfig>) {\n    super({\n      agentId: config?.agentId || agent.name,\n      description: config?.description || agent.description || '',\n      threadId: config?.threadId || '',\n      ...config\n    });\n    this.agent = agent;\n  }\n\n  run(input: RunAgentInput): Observable<BaseEvent> {\n    return new Observable<BaseEvent>((subscriber) => {\n      this._run(subscriber, input);\n    });\n  }\n\n  private async _run(subscriber: any, input: RunAgentInput): Promise<void> {\n    const { messages, runId, threadId, tools, forwardedProps } = input;\n\n    try {\n      subscriber.next({ type: EventType.RUN_STARTED, threadId, runId });\n\n      // Convert client-side tools format to AG-Kit format\n      const convertedTools = tools?.map(tool => {\n        let schema;\n        \n        // Convert parameters (JSON schema string) to schema (Zod schema)\n        if ((tool as any).parameters) {\n          try {\n            const jsonSchema = typeof (tool as any).parameters === 'string' \n              ? JSON.parse((tool as any).parameters) \n              : (tool as any).parameters;\n\n            \n            schema =  jsonSchema;\n          } catch (error) {\n            console.warn('Failed to convert parameters to schema:', error);\n            schema = undefined;\n          }\n        }\n\n        return {\n          name: tool.name,\n          description: tool.description,\n          schema: schema,\n          // No handler for client-side tools\n          handler: undefined\n        };\n      });\n\n      // Convert AG-UI messages to AG-Kit messages\n      const convertedMessages = convertMessages(messages);\n      \n      // Use onEvent callback to bridge events for THIS specific run\n      await this.agent.run(convertedMessages, undefined, {\n        conversationId: threadId,\n        runId,\n        tools: convertedTools,\n        ...forwardedProps,\n        // Bridge AG-Kit events to AG-UI events for this specific run\n        onEvent: (event) => {\n          this.bridgeEvent(subscriber, threadId, runId, event);\n        }\n      });\n\n      subscriber.complete();\n    } catch (error) {\n      subscriber.next({\n        type: EventType.RUN_ERROR,\n        threadId,\n        runId,\n        message: error instanceof Error ? error.message : String(error),\n        code: error instanceof Error ? error.name : 'UNKNOWN_ERROR'\n      });\n      subscriber.error(error);\n    }\n  }\n\n  /**\n   * Bridge a single AG-Kit event to AG-UI event format\n   * This is called per-event for a specific run (no global listeners)\n   */\n  private bridgeEvent(subscriber: any, threadId: string, runId: string, event: any): void {\n    switch (event.type) {\n      case AGKitEventType.TEXT_MESSAGE_START:\n        subscriber.next({ \n          type: EventType.TEXT_MESSAGE_START, \n          threadId, \n          runId, \n          messageId: event.messageId, \n          role: event.role \n        });\n        break;\n\n      case AGKitEventType.TEXT_MESSAGE_CONTENT:\n        subscriber.next({ \n          type: EventType.TEXT_MESSAGE_CONTENT, \n          threadId, \n          runId, \n          messageId: event.messageId, \n          delta: event.delta \n        });\n        break;\n\n      case AGKitEventType.TEXT_MESSAGE_END:\n        subscriber.next({ \n          type: EventType.TEXT_MESSAGE_END, \n          threadId, \n          runId, \n          messageId: event.messageId \n        });\n        break;\n\n      case AGKitEventType.TOOL_CALL_START:\n        subscriber.next({ \n          type: EventType.TOOL_CALL_START, \n          threadId, \n          runId, \n          toolCallId: event.toolCallId, \n          toolCallName: event.toolCallName \n        });\n        break;\n\n      case AGKitEventType.TOOL_CALL_ARGS:\n        subscriber.next({ \n          type: EventType.TOOL_CALL_ARGS, \n          threadId, \n          runId, \n          toolCallId: event.toolCallId, \n          delta: event.delta \n        });\n        break;\n\n      case AGKitEventType.TOOL_CALL_END:\n        subscriber.next({ \n          type: EventType.TOOL_CALL_END, \n          threadId, \n          runId, \n          toolCallId: event.toolCallId \n        });\n        break;\n\n      case AGKitEventType.TOOL_CALL_RESULT:\n        subscriber.next({ \n          type: EventType.TOOL_CALL_RESULT, \n          threadId, \n          runId, \n          toolCallId: event.toolCallId, \n          content: event.content \n        });\n        break;\n\n      case AGKitEventType.RUN_FINISHED:\n        if (event.outcome === 'interrupt') {\n          subscriber.next({\n            type: EventType.RUN_FINISHED,\n            threadId,\n            runId,\n            outcome: 'interrupt',\n            interrupt: event.interrupt\n          });\n        } else {\n          subscriber.next({\n            type: EventType.RUN_FINISHED,\n            threadId,\n            runId,\n            result: event.result\n          });\n        }\n        break;\n\n      // Ignore other event types (they're not part of AG-UI protocol)\n      default:\n        break;\n    }\n  }\n\n  destroy(): void {\n    this.agent.destroy();\n  }\n}\n\n","/**\n * Converter utility to transform AG-Kit Agent to AG-UI AbstractAgent\n */\n\nimport { AbstractAgent, AgentConfig } from '@ag-ui/client';\nimport { Agent } from '../core/agent';\nimport { AGKitAgent } from './agent';\n\n/**\n * Convert AG-Kit Agent to AbstractAgent for AG-UI server integration\n */\nexport function toAGUIAgent(\n  agent: Agent | AbstractAgent,\n  config?: Partial<AgentConfig>\n): AbstractAgent {\n  if (agent instanceof AbstractAgent) {\n    return agent;\n  }\n  return new AGKitAgent(agent, config);\n}\n\n","// Core Agent exports\nexport * from \"./core\";\n\n// AG-UI integration\nexport * from \"./agkit\";\n\n// Storage exports\nexport * from \"./core/storage\";\n","import { randomUUID } from \"node:crypto\";\nimport {\n  AgentConfig,\n  RunOptions,\n  AgentResult,\n  AgentState,\n  Message,\n  AgentError,\n  ModelProvider,\n  RunContext,\n  StateConstraint,\n  OutputConstraint,\n} from \"./types\";\nimport { EventSystem, EventType, AgentEvent } from \"./events\";\nimport { ExecutionError } from \"./errors\";\nimport { configValidator } from \"./config-validation\";\nimport { ToolProxy } from \"./tool-proxy\";\nimport { ToolExecutionHandler } from \"./tool-execution-handler\";\nimport { MessageBuilder } from \"./message-builder\";\nimport { AgentExecutor } from \"./agent-executor\";\nimport { InMemoryMemory } from \"./storage/memory/in-memory-memory\";\nimport { BaseTool, ToolExecutionContext } from \"@cloudbase/agent-tools\";\n\n// Global singleton InMemoryMemory for memory-based conversation persistence\nlet globalMemory: InMemoryMemory | null = null;\n\nfunction getGlobalMemory(): InMemoryMemory {\n  if (!globalMemory) {\n    globalMemory = new InMemoryMemory();\n  }\n  return globalMemory;\n}\n\n/**\n * Get the global singleton InMemoryMemory instance\n * This is useful for accessing conversation history across different Agent instances\n */\nexport function getGlobalMemoryInstance(): InMemoryMemory {\n  return getGlobalMemory();\n}\n\n// Core Agent class with enhanced type safety\nexport class Agent<\n  TState extends StateConstraint = StateConstraint,\n  TOutput extends OutputConstraint = string,\n> {\n  private config: AgentConfig<TState, TOutput>;\n  private modelProvider: ModelProvider;\n  private eventSystem: EventSystem;\n  private toolProxy: ToolProxy<TState>;\n  private toolExecutionHandler: ToolExecutionHandler<TState>;\n  private messageBuilder: MessageBuilder<TState>;\n  private agentExecutor: AgentExecutor<TState, TOutput>;\n  private state: AgentState<TState>;\n  private isRunning: boolean = false;\n  private isPaused: boolean = false;\n\n  // Memory management removed - handled by memory module automatically\n\n  // Memory management\n  private memory: InMemoryMemory;\n\n  /**\n   * Create a message with state metadata for memory storage\n   */\n  private createMessageWithState(\n    role: Message['role'],\n    content: string,\n    conversationId: string,\n    state: TState,\n    options?: {\n      runId?: string;\n      userId?: string;\n      toolCalls?: any[];\n      toolCallId?: string;\n    }\n  ): Message {\n    return this.messageBuilder.createMessageWithState(\n      role,\n      content,\n      conversationId,\n      state,\n      options\n    );\n  }\n\n  /**\n   * Get conversation messages from memory\n   */\n  private async getConversationMessages(conversationId: string): Promise<Message[]> {\n    const events = await this.memory.list({\n      limit: 1000,\n      sessionId: conversationId // Use conversationId as sessionId\n    });\n    return events\n      .map(event => event.message)\n      .sort((a, b) => (a.timestamp?.getTime() || 0) - (b.timestamp?.getTime() || 0));\n  }\n\n  /**\n   * Add messages to memory\n   */\n  private async addMessages(conversationId: string, messages: Message[], state: TState): Promise<void> {\n    const events = messages.map(message => ({\n      message,\n      state\n    }));\n    await this.memory.addList(events, { sessionId: conversationId });\n  }\n\n  /**\n   * Extract current state from messages\n   */\n  private extractStateFromMessages(messages: Message[]): TState {\n    return this.messageBuilder.extractStateFromMessages(messages);\n  }\n\n\n  constructor(config: AgentConfig<TState, TOutput>) {\n    // Validate configuration\n    this.config = configValidator.validateAgentConfig(config as any, {\n      agentName: config.name,\n    }) as unknown as AgentConfig<TState, TOutput>;\n\n    this.eventSystem = new EventSystem();\n    this.toolProxy = new ToolProxy<TState>(this.eventSystem);\n    this.toolExecutionHandler = new ToolExecutionHandler<TState>(\n      this.toolProxy,\n      this.config.controlFlow?.errorRetryLimit || 0,\n      this.config.controlFlow?.customHandler\n    );\n    this.messageBuilder = new MessageBuilder<TState>();\n    this.state = this.initializeState();\n    // Use provided memory or fall back to global singleton\n    this.memory = (config as any).memory || getGlobalMemory();\n\n    // Initialize model provider\n    this.modelProvider = this.initializeModelProvider();\n\n    // Initialize tools\n    this.initializeTools();\n\n    // Initialize event listeners\n    this.initializeEventListeners();\n\n    // Initialize agent executor\n    this.agentExecutor = new AgentExecutor<TState, TOutput>(\n      this.config,\n      this.modelProvider,\n      this.toolExecutionHandler,\n      this.messageBuilder,\n      () => this.state.businessState as TState,\n      (conversationId, messages, state) => this.addMessages(conversationId, messages, state),\n      // State sync callback: merge updated state into businessState\n      (updatedState: TState) => {\n        if (this.state.businessState && typeof this.state.businessState === \"object\" && typeof updatedState === \"object\") {\n          Object.assign(this.state.businessState as any, updatedState as any);\n        } else {\n          this.state.businessState = updatedState;\n        }\n      }\n    );\n\n    // Memory management handled by memory module automatically\n  }\n\n  // Core run method\n  async run(\n    input: string | Message[],\n    state?: TState,\n    options?: RunOptions<TState>\n  ): Promise<AgentResult<TOutput>> {\n    // Memory management handled by memory module automatically\n\n    // Validate run options if provided\n    const validatedOptions = options\n      ? (configValidator.validateRunOptions(options as any, {\n        agentName: this.config.name,\n        inputType: typeof input,\n      }) as RunOptions<TState>)\n      : undefined;\n\n    const runId = validatedOptions?.runId || randomUUID();\n    const conversationId = options?.conversationId || randomUUID();\n\n    // Create event emitter that supports both EventSystem and onEvent callback\n    const eventEmitter = {\n      emit: (type: EventType, event: any) => {\n        this.eventSystem.emit(type, event);\n        // Also call onEvent callback if provided\n        if (validatedOptions?.onEvent) {\n          validatedOptions.onEvent(event);\n        }\n      },\n      next: (event: any) => {\n        this.eventSystem.emit(event.type, event);\n        // Also call onEvent callback if provided\n        if (validatedOptions?.onEvent) {\n          validatedOptions.onEvent(event);\n        }\n      },\n    };\n\n    // Check if already aborted\n    if (options?.signal?.aborted) {\n      throw new ExecutionError(\n        \"Run aborted before start\",\n        { reason: options.signal.reason || \"AbortSignal was already aborted\" }\n      );\n    }\n\n    // Set up abort listener\n    const abortHandler = () => {\n      this.isRunning = false;\n      this.state.status = \"idle\";\n    };\n    options?.signal?.addEventListener(\"abort\", abortHandler);\n\n    // Emit run started event\n    eventEmitter.emit(EventType.RUN_STARTED, {\n      type: EventType.RUN_STARTED,\n      threadId: conversationId, // AG-UI compatibility\n      runId,\n      input,\n      options: options || {},\n    } as any);\n\n    try {\n      this.isRunning = true;\n      this.state.status = \"running\";\n      this.state.runId = runId;\n      this.state.conversationId = conversationId;\n\n      // Check abort signal\n      if (options?.signal?.aborted) {\n        throw new ExecutionError(\n          \"Run aborted\",\n          { reason: options.signal.reason || \"AbortSignal was aborted\" }\n        );\n      }\n\n      // Handle resume from interrupt\n      if (options?.resume) {\n        try {\n          const resumePayload = JSON.parse(options.resume.payload);\n          // Update business state with resume payload\n          if (this.state.businessState) {\n            Object.assign(this.state.businessState, {\n              userResponse: resumePayload,\n            });\n          }\n        } catch (error) {\n          console.error(\"Failed to parse resume payload:\", error);\n        }\n      }\n\n      // Emit state update event\n      eventEmitter.emit(EventType.STATE_UPDATE, {\n        type: EventType.STATE_UPDATE,\n        conversationId,\n        runId,\n        state: this.state,\n      } as any);\n\n      // Process input and create context\n      const context = await this.createRunContext(input, state, options);\n\n      // Check abort signal before execution\n      if (options?.signal?.aborted) {\n        throw new ExecutionError(\n          \"Run aborted\",\n          { reason: options.signal.reason || \"AbortSignal was aborted\" }\n        );\n      }\n\n      // Execute the agent logic using unified streaming implementation\n      const result = (await this.executeAgentCore(\n        eventEmitter,\n        context,\n        validatedOptions,\n        true\n      )) as AgentResult<TOutput>;\n\n      // Check abort signal after execution\n      if (options?.signal?.aborted) {\n        throw new ExecutionError(\n          \"Run aborted\",\n          { reason: options.signal.reason || \"AbortSignal was aborted\" }\n        );\n      }\n\n      // Emit run finished event only if not interrupted\n      if (\n        result &&\n        result.metadata &&\n        (result.metadata as any).outcome !== \"interrupt\"\n      ) {\n        // Use eventEmitter to support onEvent callback\n        eventEmitter.emit(EventType.RUN_FINISHED, {\n          type: EventType.RUN_FINISHED,\n          threadId: conversationId, // AG-UI compatibility\n          runId,\n          result,\n          executionTime:\n            Date.now() - (this.state.lastActivity?.getTime() || Date.now()),\n        } as any);\n      }\n\n      this.isRunning = false;\n      this.state.status = \"idle\";\n\n      return result;\n    } catch (error) {\n      const agentError = this.createAgentError(error);\n\n      // Emit run failed event - use eventEmitter to support onEvent callback\n      eventEmitter.emit(EventType.RUN_ERROR, {\n        type: EventType.RUN_ERROR,\n        threadId: conversationId, // AG-UI compatibility\n        runId,\n        code: agentError.code,\n        message: agentError.message,\n        details: (agentError as any)?.details,\n        executionTime:\n          Date.now() - (this.state.lastActivity?.getTime() || Date.now()),\n      } as any);\n\n      this.isRunning = false;\n      this.state.status = \"error\";\n\n      throw agentError;\n    } finally {\n      // Clean up abort listener\n      if (options?.signal) {\n        options.signal.removeEventListener(\"abort\", abortHandler);\n      }\n    }\n  }\n\n  // Streaming run method - Returns AsyncIterator (no RxJS dependency)\n  async *stream(\n    input: string | Message[],\n    state?: TState,\n    options?: RunOptions<TState>\n  ): AsyncIterableIterator<AgentEvent> {\n    const runId = options?.runId || randomUUID();\n    const conversationId = options?.conversationId || randomUUID();\n\n    // Create event queue\n    const eventQueue: AgentEvent[] = [];\n    let isDone = false;\n    let error: Error | null = null;\n\n    // Set up event collector\n    const eventCollector = (event: AgentEvent) => {\n      eventQueue.push(event);\n    };\n\n    // Execute agent in background\n    const executePromise = (async () => {\n      try {\n        // Emit run started event\n        eventCollector({\n          type: EventType.RUN_STARTED,\n          threadId: conversationId,\n          runId,\n        } as any);\n\n        // Process input and create context\n        const context = await this.createRunContext(input, state, options);\n\n        // Create custom event emitter for this stream\n        const streamEmitter = {\n          emit: (type: string, event: any) => eventCollector(event),\n          next: (event: any) => eventCollector(event),\n        };\n\n        // Use unified streaming implementation\n        await this.executeAgentCore(streamEmitter, context, options, false);\n\n        isDone = true;\n      } catch (err) {\n        error = err instanceof Error ? err : new Error(String(err));\n        isDone = true;\n\n        // Emit error event\n        eventCollector({\n          type: EventType.RUN_ERROR,\n          threadId: conversationId,\n          runId,\n          message: error.message,\n          code: error.name,\n          executionTime: 0,\n        } as any);\n      }\n    })();\n\n    // Yield events as they arrive\n    while (!isDone || eventQueue.length > 0) {\n      if (eventQueue.length > 0) {\n        yield eventQueue.shift()!;\n      } else {\n        // Wait a bit before checking again\n        await new Promise((resolve) => setTimeout(resolve, 10));\n      }\n    }\n\n    // Throw error if execution failed\n    if (error) {\n      throw error;\n    }\n\n    // Wait for execution to complete\n    await executePromise;\n  }\n\n  // Tool management\n  addTool<T extends BaseTool<any, TState>>(tool: T): void {\n    this.toolProxy.registerTool(tool);\n  }\n\n  removeTool(toolName: string): boolean {\n    return this.toolProxy.unregisterTool(toolName);\n  }\n\n  getTool(toolName: string): BaseTool<any, TState> | undefined {\n    return this.toolProxy.getTool(toolName);\n  }\n\n  getTools(): BaseTool<any, TState>[] {\n    return this.toolProxy.getAllTools();\n  }\n\n  getToolCount(): number {\n    return this.toolProxy.getToolCount();\n  }\n\n  // Enhanced tool management methods\n  hasTool(toolName: string): boolean {\n    return this.toolProxy.hasTool(toolName);\n  }\n\n  getToolNames(): string[] {\n    return this.toolProxy.getToolNames();\n  }\n\n  getToolsRequiringApproval(): BaseTool<any, TState>[] {\n    return this.toolProxy.getToolsRequiringApproval();\n  }\n\n  async executeTool(\n    toolName: string,\n    input: unknown,\n    context?: Partial<ToolExecutionContext>\n  ): Promise<unknown> {\n    return this.toolProxy.executeTool(\n      toolName,\n      input,\n      context,\n      this.state.businessState\n    );\n  }\n\n  validateToolInput(toolName: string, input: unknown): boolean {\n    return this.toolProxy.validateToolInput(toolName, input);\n  }\n\n  getToolMetadata(toolName: string) {\n    return this.toolProxy.getToolMetadata(toolName);\n  }\n\n  // Conversation management (placeholder - will be implemented in Phase 3)\n  async createConversation(userId?: string, config?: any): Promise<any> {\n    // TODO: Implement in Phase 3\n    throw new Error(\"Conversation management not yet implemented\");\n  }\n\n  async getConversation(conversationId: string): Promise<any> {\n    // TODO: Implement in Phase 3\n    throw new Error(\"Conversation management not yet implemented\");\n  }\n\n  async deleteConversation(conversationId: string): Promise<void> {\n    // TODO: Implement in Phase 3\n    throw new Error(\"Conversation management not yet implemented\");\n  }\n\n  // State management\n  getState(): AgentState<TState> {\n    return { ...this.state };\n  }\n\n  setState(state: Partial<AgentState<TState>>): void {\n    this.state = { ...this.state, ...state };\n    this.state.lastActivity = new Date();\n\n    // Emit state update event\n    this.eventSystem.emit(EventType.STATE_UPDATE, {\n      type: EventType.STATE_UPDATE,\n      state: this.state,\n      conversationId: this.state.conversationId || \"\",\n      runId: this.state.runId || \"\",\n    } as any);\n  }\n\n  // Lifecycle control\n  async start(): Promise<void> {\n    if (this.isRunning) {\n      throw new Error(\"Agent is already running\");\n    }\n    this.isRunning = true;\n    this.state.status = \"running\";\n  }\n\n  async pause(): Promise<void> {\n    if (!this.isRunning) {\n      throw new Error(\"Agent is not running\");\n    }\n    this.isPaused = true;\n    this.state.status = \"paused\";\n\n    // Emit execution paused event\n    this.eventSystem.emit(EventType.EXECUTION_PAUSED, {\n      type: EventType.EXECUTION_PAUSED,\n      reason: \"Manual pause\",\n      conversationId: this.state.conversationId || \"\",\n      runId: this.state.runId || \"\",\n    } as any);\n  }\n\n  async resume(resumeData?: any): Promise<void> {\n    if (!this.isPaused) {\n      throw new Error(\"Agent is not paused\");\n    }\n    this.isPaused = false;\n    this.state.status = \"running\";\n\n    // Emit execution resumed event\n    this.eventSystem.emit(EventType.EXECUTION_RESUMED, {\n      type: EventType.EXECUTION_RESUMED,\n      resumeData,\n      conversationId: this.state.conversationId || \"\",\n      runId: this.state.runId || \"\",\n    } as any);\n  }\n\n  async stop(): Promise<void> {\n    this.isRunning = false;\n    this.isPaused = false;\n    this.state.status = \"idle\";\n  }\n\n  // Event system\n  on<T extends EventType>(event: T, handler: (data: any) => void): void {\n    this.eventSystem.on(event, handler);\n  }\n\n  off<T extends EventType>(event: T, handler: (data: any) => void): void {\n    this.eventSystem.off(event, handler);\n  }\n\n  // Private methods\n  private initializeState(): AgentState<TState> {\n    return {\n      businessState: this.config.stateType\n        ? new (this.config.stateType as any)()\n        : ({} as TState),\n      context: {} as RunContext<TState>,\n      status: \"idle\",\n      lastActivity: new Date(),\n    };\n  }\n\n  private initializeModelProvider(): ModelProvider {\n    if (typeof this.config.model === \"string\") {\n      // TODO: Use provider factory to create provider from string\n      throw new Error(\"String-based model provider not yet implemented\");\n    }\n    return this.config.model;\n  }\n\n  private initializeTools(): void {\n    if (this.config.tools) {\n      for (const tool of this.config.tools) {\n        this.toolProxy.registerTool(tool);\n      }\n    }\n  }\n\n  private initializeEventListeners(): void {\n    // Set up default event listeners\n    this.eventSystem.on(EventType.RUN_ERROR, (event) => {\n      console.error(\"Agent error:\", event.message);\n    });\n  }\n\n  private async createRunContext(\n    input: string | Message[],\n    state?: TState,\n    options?: RunOptions<TState>\n  ): Promise<RunContext<TState>> {\n    const runId = options?.runId || randomUUID();\n    const conversationId = options?.conversationId || randomUUID();\n\n    // Get existing conversation messages\n    let messages = await this.getConversationMessages(conversationId);\n\n    // Handle current input\n    const currentMessages =\n      typeof input === \"string\"\n        ? [\n          this.createMessageWithState(\n            \"user\",\n            input,\n            conversationId,\n            this.state.businessState as TState,\n            { runId, userId: options?.userId }\n          ),\n        ]\n        : input;\n\n    // Add current messages to conversation\n    await this.addMessages(conversationId, currentMessages, this.state.businessState as TState);\n    messages = await this.getConversationMessages(conversationId);\n\n    // Handle resume from interrupt\n    if (options?.resume) {\n      try {\n        const resumePayload = JSON.parse(options.resume.payload);\n        const resumeMessage = this.createMessageWithState(\n          \"user\",\n          `Resume: ${JSON.stringify(resumePayload)}`,\n          conversationId,\n          this.state.businessState as TState,\n          { runId, userId: options?.userId }\n        );\n        await this.addMessages(conversationId, [resumeMessage], this.state.businessState as TState);\n        messages = await this.getConversationMessages(conversationId);\n      } catch (error) {\n        console.error(\"Failed to parse resume payload:\", error);\n      }\n    }\n\n    // Extract current state from messages\n    const currentState = this.extractStateFromMessages(messages);\n\n    // Sync agent business state with conversation-derived state\n    if (currentState && typeof currentState === \"object\") {\n      if (this.state.businessState) {\n        Object.assign(this.state.businessState as any, currentState as any);\n      } else {\n        this.state.businessState = currentState as TState;\n      }\n    }\n\n    return {\n      conversationId,\n      runId,\n      userId: options?.userId,\n      requestId: randomUUID(),\n      messages,\n      state: currentState,\n      metadata: options?.metadata,\n    };\n  }\n\n  // Helper method to emit events to either eventSystem or Observable subscriber\n  private emitEvent(eventEmitter: any, event: any): void {\n    if (eventEmitter.next) {\n      // Observable subscriber\n      eventEmitter.next(event);\n    } else {\n      // EventSystem\n      eventEmitter.emit(event.type, event);\n    }\n  }\n\n  // Unified streaming execution method - delegates to AgentExecutor\n  private async executeAgentCore(\n    eventEmitter: any, // Can be eventSystem or Observable subscriber\n    context: RunContext<TState>,\n    options?: RunOptions<TState>,\n    returnResult: boolean = true\n  ): Promise<AgentResult<TOutput> | void> {\n    try {\n      return await this.agentExecutor.execute(\n        eventEmitter,\n        context,\n        options,\n        returnResult\n      );\n    } catch (error) {\n      throw this.createAgentError(error);\n    }\n  }\n\n  private createAgentError(error: any): AgentError {\n    return new ExecutionError(\n      error instanceof Error ? error.message : String(error),\n      { originalError: error },\n      error instanceof Error ? error : undefined\n    );\n  }\n\n  // Getters for configuration and state\n  get name(): string {\n    return this.config.name;\n  }\n\n  get description(): string | undefined {\n    return this.config.description;\n  }\n\n  get isActive(): boolean {\n    return this.isRunning;\n  }\n\n  get isPausedState(): boolean {\n    return this.isPaused;\n  }\n\n  // Memory management methods removed - handled by memory module automatically\n\n  // AG-UI integration\n  public toAGUIAgent(): any {\n    // Lazy import to avoid circular dependency\n    const { toAGUIAgent } = require(\"../agkit/converter\");\n    return toAGUIAgent(this);\n  }\n\n  // Cleanup on destruction\n  public destroy(): void {\n    // Memory cleanup handled by memory module automatically\n    this.eventSystem.removeAllListeners();\n  }\n}\n","/**\n * Enhanced error handling system for AG-Kit\n */\n\n// Base error class\nexport abstract class AGKitError extends Error {\n  abstract readonly code: string;\n  abstract readonly category: ErrorCategory;\n  readonly timestamp: Date;\n  readonly context?: Record<string, unknown>;\n\n  public readonly cause?: Error;\n\n  constructor(\n    message: string,\n    context?: Record<string, unknown>,\n    cause?: Error\n  ) {\n    super(message);\n    this.name = this.constructor.name;\n    this.timestamp = new Date();\n    this.context = context;\n    this.cause = cause;\n    \n    // Maintain proper stack trace\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      code: this.code,\n      category: this.category,\n      message: this.message,\n      timestamp: this.timestamp.toISOString(),\n      context: this.context,\n      stack: this.stack\n    };\n  }\n}\n\n// Error categories\nexport enum ErrorCategory {\n  CONFIGURATION = 'CONFIGURATION',\n  NETWORK = 'NETWORK',\n  MODEL = 'MODEL',\n  TOOL = 'TOOL',\n  VALIDATION = 'VALIDATION',\n  RUNTIME = 'RUNTIME',\n  MEMORY = 'MEMORY',\n  CONTROL_FLOW = 'CONTROL_FLOW'\n}\n\n// Configuration errors\nexport class ConfigurationError extends AGKitError {\n  readonly code = 'CONFIG_ERROR';\n  readonly category = ErrorCategory.CONFIGURATION;\n}\n\nexport class InvalidModelProviderError extends AGKitError {\n  readonly code = 'INVALID_MODEL_PROVIDER';\n  readonly category = ErrorCategory.CONFIGURATION;\n}\n\nexport class MissingRequiredConfigError extends AGKitError {\n  readonly code = 'MISSING_REQUIRED_CONFIG';\n  readonly category = ErrorCategory.CONFIGURATION;\n}\n\n// Network errors\nexport class NetworkError extends AGKitError {\n  readonly code = 'NETWORK_ERROR';\n  readonly category = ErrorCategory.NETWORK;\n}\n\nexport class TimeoutError extends AGKitError {\n  readonly code = 'TIMEOUT_ERROR';\n  readonly category = ErrorCategory.NETWORK;\n}\n\nexport class RateLimitError extends AGKitError {\n  readonly code = 'RATE_LIMIT_ERROR';\n  readonly category = ErrorCategory.NETWORK;\n}\n\n// Model errors\nexport class ModelError extends AGKitError {\n  readonly code = 'MODEL_ERROR';\n  readonly category = ErrorCategory.MODEL;\n}\n\nexport class ModelProviderError extends AGKitError {\n  readonly code = 'MODEL_PROVIDER_ERROR';\n  readonly category = ErrorCategory.MODEL;\n}\n\nexport class TokenLimitError extends AGKitError {\n  readonly code = 'TOKEN_LIMIT_ERROR';\n  readonly category = ErrorCategory.MODEL;\n}\n\nexport class InvalidModelResponseError extends AGKitError {\n  readonly code = 'INVALID_MODEL_RESPONSE';\n  readonly category = ErrorCategory.MODEL;\n}\n\n// Tool errors\nexport class ToolError extends AGKitError {\n  readonly code = 'TOOL_ERROR';\n  readonly category = ErrorCategory.TOOL;\n}\n\nexport class ToolExecutionError extends AGKitError {\n  readonly code = 'TOOL_EXECUTION_ERROR';\n  readonly category = ErrorCategory.TOOL;\n}\n\nexport class ToolNotFoundError extends AGKitError {\n  readonly code = 'TOOL_NOT_FOUND';\n  readonly category = ErrorCategory.TOOL;\n}\n\nexport class ToolValidationError extends AGKitError {\n  readonly code = 'TOOL_VALIDATION_ERROR';\n  readonly category = ErrorCategory.TOOL;\n}\n\n// Validation errors\nexport class ValidationError extends AGKitError {\n  readonly code = 'VALIDATION_ERROR';\n  readonly category = ErrorCategory.VALIDATION;\n}\n\nexport class SchemaValidationError extends AGKitError {\n  readonly code = 'SCHEMA_VALIDATION_ERROR';\n  readonly category = ErrorCategory.VALIDATION;\n}\n\n// Runtime errors\nexport class RuntimeError extends AGKitError {\n  readonly code = 'RUNTIME_ERROR';\n  readonly category = ErrorCategory.RUNTIME;\n}\n\nexport class StateError extends AGKitError {\n  readonly code = 'STATE_ERROR';\n  readonly category = ErrorCategory.RUNTIME;\n}\n\nexport class ExecutionError extends AGKitError {\n  readonly code = 'EXECUTION_ERROR';\n  readonly category = ErrorCategory.RUNTIME;\n}\n\n// Memory errors\nexport class MemoryError extends AGKitError {\n  readonly code = 'MEMORY_ERROR';\n  readonly category = ErrorCategory.MEMORY;\n}\n\nexport class MemoryLimitError extends AGKitError {\n  readonly code = 'MEMORY_LIMIT_ERROR';\n  readonly category = ErrorCategory.MEMORY;\n}\n\n// Control flow errors\nexport class ControlFlowError extends AGKitError {\n  readonly code = 'CONTROL_FLOW_ERROR';\n  readonly category = ErrorCategory.CONTROL_FLOW;\n}\n\nexport class HumanApprovalRequiredError extends AGKitError {\n  readonly code = 'HUMAN_APPROVAL_REQUIRED';\n  readonly category = ErrorCategory.CONTROL_FLOW;\n}\n\n// Error handler interface\nexport interface ErrorHandler {\n  handle(error: AGKitError): Promise<void> | void;\n  canHandle(error: AGKitError): boolean;\n}\n\n// Default error handlers\nexport class LoggingErrorHandler implements ErrorHandler {\n  canHandle(error: AGKitError): boolean {\n    return true; // Can handle all errors\n  }\n\n  handle(error: AGKitError): void {\n    console.error(`[${error.category}] ${error.code}: ${error.message}`, {\n      context: error.context,\n      stack: error.stack\n    });\n  }\n}\n\nexport class RetryErrorHandler implements ErrorHandler {\n  private maxRetries: number;\n  private retryableCategories: Set<ErrorCategory>;\n\n  constructor(\n    maxRetries: number = 3,\n    retryableCategories: ErrorCategory[] = [\n      ErrorCategory.NETWORK,\n      ErrorCategory.MODEL\n    ]\n  ) {\n    this.maxRetries = maxRetries;\n    this.retryableCategories = new Set(retryableCategories);\n  }\n\n  canHandle(error: AGKitError): boolean {\n    return this.retryableCategories.has(error.category);\n  }\n\n  async handle(error: AGKitError): Promise<void> {\n    // This would be implemented with retry logic\n    console.warn(`Retrying operation after ${error.code} error`);\n  }\n}\n\n// Error recovery strategies\nexport interface ErrorRecoveryStrategy {\n  canRecover(error: AGKitError): boolean;\n  recover(error: AGKitError): Promise<unknown>;\n}\n\nexport class FallbackModelStrategy implements ErrorRecoveryStrategy {\n  canRecover(error: AGKitError): boolean {\n    return error instanceof ModelError || error instanceof NetworkError;\n  }\n\n  async recover(error: AGKitError): Promise<unknown> {\n    // Implement fallback to different model provider\n    console.log('Attempting recovery with fallback model provider');\n    return null;\n  }\n}\n\n// Error context builder\nexport class ErrorContextBuilder {\n  private context: Record<string, unknown> = {};\n\n  withAgentId(agentId: string): this {\n    this.context.agentId = agentId;\n    return this;\n  }\n\n  withRunId(runId: string): this {\n    this.context.runId = runId;\n    return this;\n  }\n\n  withToolName(toolName: string): this {\n    this.context.toolName = toolName;\n    return this;\n  }\n\n  withModelName(modelName: string): this {\n    this.context.modelName = modelName;\n    return this;\n  }\n\n  withRetryCount(count: number): this {\n    this.context.retryCount = count;\n    return this;\n  }\n\n  withCustom(key: string, value: unknown): this {\n    this.context[key] = value;\n    return this;\n  }\n\n  build(): Record<string, unknown> {\n    return { ...this.context };\n  }\n}\n\n// Utility functions\nexport function isRetryableError(error: AGKitError): boolean {\n  const retryableCategories = [\n    ErrorCategory.NETWORK,\n    ErrorCategory.MODEL\n  ];\n  return retryableCategories.includes(error.category);\n}\n\nexport function isConfigurationError(error: AGKitError): boolean {\n  return error.category === ErrorCategory.CONFIGURATION;\n}\n\nexport function isToolError(error: AGKitError): boolean {\n  return error.category === ErrorCategory.TOOL;\n}\n\nexport function createErrorContext(): ErrorContextBuilder {\n  return new ErrorContextBuilder();\n}\n","/**\n * Configuration validation using Zod schemas\n */\n\nimport { z } from \"zod/v4\";\nimport { ConfigurationError, MissingRequiredConfigError, createErrorContext } from \"./errors\";\n\n\n// Use `zFunction()` instead of `z.function()`\n// https://github.com/colinhacks/zod/issues/4143#issuecomment-2845134912\nfunction zFunction() {\n  return z.custom<CallableFunction>(value => typeof value === 'function');\n}\n\n// Base configuration schemas\nexport const ModelSettingsSchema = z.object({\n  temperature: z.number().min(0).max(2).optional(),\n  maxTokens: z.number().positive().optional(),\n  topP: z.number().min(0).max(1).optional(),\n  frequencyPenalty: z.number().min(-2).max(2).optional(),\n  presencePenalty: z.number().min(-2).max(2).optional(),\n  stop: z.array(z.string()).optional(),\n});\n\n// MemoryConfigSchema removed - memory should be BaseMemory instance, not config object\n\nexport const HumanInTheLoopConfigSchema = z.object({\n  enabled: z.boolean(),\n  requireApproval: z.array(z.string()).optional(),\n  highRiskTools: z.array(z.string()).optional(),\n  timeout: z.number().positive().optional(),\n  defaultAction: z.enum(['approve', 'reject', 'pause']).optional(),\n});\n\nexport const ControlFlowConfigSchema = z.object({\n  maxSteps: z.number().positive().optional(),\n  errorRetryLimit: z.number().nonnegative().optional(),\n  pauseOnHumanInput: z.boolean().optional(),\n  customHandler: z.object({\n    handleNextStep: zFunction(),\n    handleToolCall: zFunction(),\n    handleError: zFunction()\n  }).optional(),\n});\n\nexport const ToolDefinitionSchema = z.object({\n  name: z.string().min(1),\n  description: z.string().optional(),\n  schema: z.any().optional(),\n  invoke: zFunction().optional(),\n  requiresApproval: z.boolean().optional(),\n});\n\nexport const OutputTypeSchema = z.union([\n  z.literal('string'),\n  z.literal('structured'),\n  z.object({\n    schema: z.any(),\n  }),\n]);\n\n// Main AgentConfig schema\nexport const AgentConfigSchema = z.object({\n  name: z.string().min(1, \"Agent name is required\"),\n  description: z.string().optional(),\n  model: z.union([z.string(), z.any()]),\n  instructions: z.union([z.string(), zFunction()]).optional(),\n  // Use any to avoid Zod wrapping constructors; we call with `new` downstream\n  stateType: z.any().optional(),\n  outputType: OutputTypeSchema.optional(),\n  modelSettings: ModelSettingsSchema.optional(),\n  tools: z.array(ToolDefinitionSchema).optional(),\n  memory: z.any().optional(), // BaseMemory instance, not config object\n  humanInTheLoop: HumanInTheLoopConfigSchema.optional(),\n  controlFlow: ControlFlowConfigSchema.optional(),\n});\n\n// RunOptions schema\nexport const RunOptionsSchema = z.object({\n  state: z.record(z.string(), z.unknown()).optional(),\n  conversationId: z.string().optional(),\n  runId: z.string().optional(),\n  userId: z.string().optional(),\n  model: z.string().optional(), // Runtime model override\n  temperature: z.number().min(0).max(2).optional(),\n  maxTokens: z.number().positive().optional(),\n  stream: z.boolean().optional(),\n  tools: z.array(ToolDefinitionSchema).optional(),\n  // memory removed - should not be configurable at runtime\n  humanInTheLoop: HumanInTheLoopConfigSchema.optional(),\n  controlFlow: ControlFlowConfigSchema.optional(),\n});\n\n// Configuration validator class\nexport class ConfigValidator {\n  private static instance: ConfigValidator;\n  \n  static getInstance(): ConfigValidator {\n    if (!ConfigValidator.instance) {\n      ConfigValidator.instance = new ConfigValidator();\n    }\n    return ConfigValidator.instance;\n  }\n  \n  // Validate agent configuration\n  validateAgentConfig<T extends Record<string, unknown>>(\n    config: unknown,\n    context?: Record<string, unknown>\n  ): T {\n    try {\n      // Use parse only for validation, return original config to preserve prototype\n      AgentConfigSchema.parse(config);\n      return config as T;\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        const contextData = createErrorContext()\n          .withCustom('validationErrors', (error as any).errors)\n          .withCustom('config', config)\n          .withCustom('context', context)\n          .build();\n        \n        throw new ConfigurationError(\n          `Agent configuration validation failed: ${this.formatZodErrors((error as any).errors)}`,\n          contextData,\n          error\n        );\n      }\n      throw error;\n    }\n  }\n  \n  // Validate run options\n  validateRunOptions<T extends Record<string, unknown>>(\n    options: unknown,\n    context?: Record<string, unknown>\n  ): T {\n    try {\n      // Use parse only for validation, return original options to preserve prototype\n      RunOptionsSchema.parse(options);\n      return options as T;\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        const contextData = createErrorContext()\n          .withCustom('validationErrors', (error as any).errors)\n          .withCustom('options', options)\n          .withCustom('context', context)\n          .build();\n        \n        throw new ConfigurationError(\n          `Run options validation failed: ${this.formatZodErrors((error as any).errors)}`,\n          contextData,\n          error\n        );\n      }\n      throw error;\n    }\n  }\n  \n  // Validate model settings\n  validateModelSettings<T extends Record<string, unknown>>(settings: unknown): T {\n    try {\n      // Use parse only for validation, return original settings to preserve prototype\n      ModelSettingsSchema.parse(settings);\n      return settings as T;\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        const contextData = createErrorContext()\n          .withCustom('validationErrors', (error as any).errors)\n          .withCustom('settings', settings)\n          .build();\n        \n        throw new ConfigurationError(\n          `Model settings validation failed: ${this.formatZodErrors((error as any).errors)}`,\n          contextData,\n          error\n        );\n      }\n      throw error;\n    }\n  }\n  \n  // Validate tool definitions\n  validateToolDefinitions<T extends Record<string, unknown>[]>(tools: unknown): T {\n    try {\n      // Use parse only for validation, return original tools to preserve prototype\n      z.array(ToolDefinitionSchema).parse(tools);\n      return tools as T;\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        const contextData = createErrorContext()\n          .withCustom('validationErrors', (error as any).errors)\n          .withCustom('tools', tools)\n          .build();\n        \n        throw new ConfigurationError(\n          `Tool definitions validation failed: ${this.formatZodErrors((error as any).errors)}`,\n          contextData,\n          error\n        );\n      }\n      throw error;\n    }\n  }\n  \n  // Memory validation removed - memory should be BaseMemory instance, not config object\n  \n  // Validate human-in-the-loop configuration\n  validateHumanInTheLoopConfig<T extends Record<string, unknown>>(config: unknown): T {\n    try {\n      // Use parse only for validation, return original config to preserve prototype\n      HumanInTheLoopConfigSchema.parse(config);\n      return config as T;\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        const contextData = createErrorContext()\n          .withCustom('validationErrors', (error as any).errors)\n          .withCustom('config', config)\n          .build();\n        \n        throw new ConfigurationError(\n          `Human-in-the-loop configuration validation failed: ${this.formatZodErrors((error as any).errors)}`,\n          contextData,\n          error\n        );\n      }\n      throw error;\n    }\n  }\n  \n  // Validate control flow configuration\n  validateControlFlowConfig<T extends Record<string, unknown>>(config: unknown): T {\n    try {\n      // Use parse only for validation, return original config to preserve prototype\n      ControlFlowConfigSchema.parse(config);\n      return config as T;\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        const contextData = createErrorContext()\n          .withCustom('validationErrors', (error as any).errors)\n          .withCustom('config', config)\n          .build();\n        \n        throw new ConfigurationError(\n          `Control flow configuration validation failed: ${this.formatZodErrors((error as any).errors)}`,\n          contextData,\n          error\n        );\n      }\n      throw error;\n    }\n  }\n  \n  // Check for required configuration fields\n  checkRequiredFields(config: Record<string, unknown>, requiredFields: string[]): void {\n    const missingFields = requiredFields.filter(field => !(field in config));\n    \n    if (missingFields.length > 0) {\n      const contextData = createErrorContext()\n        .withCustom('missingFields', missingFields)\n        .withCustom('config', config)\n        .build();\n      \n      throw new MissingRequiredConfigError(\n        `Missing required configuration fields: ${missingFields.join(', ')}`,\n        contextData\n      );\n    }\n  }\n  \n  // Format Zod errors for better readability\n  private formatZodErrors(errors: z.ZodIssue[] | undefined): string {\n    if (!errors || errors.length === 0) {\n      return 'Unknown validation error';\n    }\n    return errors\n      .map(error => {\n        const path = error.path.length > 0 ? error.path.join('.') : 'root';\n        return `${path}: ${error.message}`;\n      })\n      .join('; ');\n  }\n  \n  // Validate configuration with custom schema\n  validateWithCustomSchema<T>(\n    data: unknown,\n    schema: z.ZodSchema<T>,\n    errorMessage: string\n  ): T {\n    try {\n      // Use parse only for validation, return original data to preserve prototype\n      schema.parse(data);\n      return data as T;\n    } catch (error) {\n      if (error instanceof z.ZodError) {\n        const contextData = createErrorContext()\n          .withCustom('validationErrors', (error as any).errors)\n          .withCustom('data', data)\n          .build();\n        \n        throw new ConfigurationError(\n          `${errorMessage}: ${this.formatZodErrors((error as any).errors)}`,\n          contextData,\n          error\n        );\n      }\n      throw error;\n    }\n  }\n}\n\n// Configuration validation decorator\nexport function validateConfig(schema: z.ZodSchema) {\n  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n    const originalMethod = descriptor.value;\n    \n    descriptor.value = function (...args: any[]) {\n      // Validate configuration argument\n      if (args.length > 0) {\n        const configArg = args[0];\n        if (configArg !== undefined && configArg !== null) {\n          try {\n            schema.parse(configArg);\n          } catch (error) {\n            if (error instanceof z.ZodError) {\n              const contextData = createErrorContext()\n                .withCustom('validationErrors', (error as any).errors)\n                .withCustom('config', configArg)\n                .build();\n              \n              throw new ConfigurationError(\n                `Configuration validation failed: ${(error as any).errors.map((e: any) => e.message).join('; ')}`,\n                contextData,\n                error\n              );\n            }\n            throw error;\n          }\n        }\n      }\n      \n      return originalMethod.apply(this, args);\n    };\n    \n    return descriptor;\n  };\n}\n\n// Export singleton instance\nexport const configValidator = ConfigValidator.getInstance();\n\n// Utility functions for common validations\nexport function validateAgentName(name: unknown): string {\n  if (typeof name !== 'string' || name.trim().length === 0) {\n    throw new ConfigurationError('Agent name must be a non-empty string');\n  }\n  return name.trim();\n}\n\nexport function validateModelProvider(provider: unknown): string | object {\n  if (typeof provider !== 'string' && typeof provider !== 'object') {\n    throw new ConfigurationError('Model provider must be a string or object');\n  }\n  return provider as any;\n}\n\nexport function validateInstructions(instructions: unknown): string | Function {\n  if (typeof instructions !== 'string' && typeof instructions !== 'function') {\n    throw new ConfigurationError('Instructions must be a string or function');\n  }\n  return instructions;\n}\n","import { ToolExecutionContext, StateConstraint } from \"./types\";\nimport { EventSystem, EventType } from \"./events\";\nimport { ToolExecutionError } from \"./errors\";\nimport { BaseTool } from \"@cloudbase/agent-tools\";\n\n/**\n * Tool Proxy System for managing and executing tools\n * Provides a unified interface for tool management and execution\n */\nexport class ToolProxy<TState extends StateConstraint = StateConstraint> {\n  private tools: Map<string, BaseTool<any, TState>>;\n  private eventSystem: EventSystem;\n  private executionContext: ToolExecutionContext;\n\n  constructor(\n    eventSystem: EventSystem,\n    context?: Partial<ToolExecutionContext>\n  ) {\n    this.tools = new Map();\n    this.eventSystem = eventSystem;\n    this.executionContext = {\n      timestamp: new Date(),\n      ...context,\n    };\n  }\n\n  /**\n   * Register a tool with the proxy\n   */\n  registerTool(tool: BaseTool<any, TState>): void {\n    if (this.tools.has(tool.name)) {\n      throw new Error(`Tool '${tool.name}' is already registered`);\n    }\n\n    // Validate tool definition\n    this.validateToolDefinition(tool);\n\n    this.tools.set(tool.name, tool);\n\n    // Emit tool registered event\n    this.eventSystem.emit(EventType.TOOL_REGISTERED, {\n      type: EventType.TOOL_REGISTERED,\n      toolName: tool.name,\n      timestamp: Date.now(),\n    });\n  }\n\n  /**\n   * Remove a tool from the proxy\n   */\n  unregisterTool(toolName: string): boolean {\n    const removed = this.tools.delete(toolName);\n\n    if (removed) {\n      // Emit tool unregistered event\n      this.eventSystem.emit(EventType.TOOL_UNREGISTERED, {\n        type: EventType.TOOL_UNREGISTERED,\n        toolName,\n        timestamp: Date.now(),\n      });\n    }\n\n    return removed;\n  }\n\n  /**\n   * Get a tool by name\n   */\n  getTool(toolName: string): BaseTool<any, TState> | undefined {\n    return this.tools.get(toolName);\n  }\n\n  /**\n   * Get all registered tools\n   */\n  getAllTools(): BaseTool<any, TState>[] {\n    return Array.from(this.tools.values());\n  }\n\n  /**\n   * Get the number of registered tools\n   */\n  getToolCount(): number {\n    return this.tools.size;\n  }\n\n  /**\n   * Get tool names\n   */\n  getToolNames(): string[] {\n    return Array.from(this.tools.keys());\n  }\n\n  /**\n   * Check if a tool is registered\n   */\n  hasTool(toolName: string): boolean {\n    return this.tools.has(toolName);\n  }\n\n  /**\n   * Execute a tool with the given input\n   */\n  async executeTool(\n    toolName: string,\n    input: unknown,\n    context?: Partial<ToolExecutionContext>,\n    state?: TState\n  ): Promise<unknown> {\n    const tool = this.getTool(toolName);\n\n    if (!tool) {\n      throw new ToolExecutionError(`Tool '${toolName}' not found`, {\n        toolName,\n        input,\n        context: this.executionContext,\n      });\n    }\n\n    // Merge execution contexts\n    const mergedContext: ToolExecutionContext<TState> = {\n      ...this.executionContext,\n      ...context,\n      timestamp: new Date(),\n      state,\n    };\n\n    // Tool execution start event is handled by core/agent.ts\n\n    try {\n      // Check if tool has a handler (client-side tools don't have handlers)\n      if (!tool.invoke) {\n        throw new ToolExecutionError(\n          `Tool '${toolName}' has no handler (client-side tool)`,\n          {\n            toolName,\n            input,\n            context: mergedContext,\n          }\n        );\n      }\n\n      // Execute the tool\n      const result = await tool.invoke(input, mergedContext);\n\n      // Tool execution end event is handled by core/agent.ts\n\n      return result;\n    } catch (error) {\n      // Emit tool execution error event\n      this.eventSystem.emit(EventType.RUN_ERROR, {\n        type: EventType.RUN_ERROR,\n        threadId: mergedContext.conversationId || \"unknown\",\n        runId: mergedContext.runId || \"unknown\",\n        message: error instanceof Error ? error.message : String(error),\n        code: error instanceof Error ? error.name : \"TOOL_EXECUTION_ERROR\",\n      });\n\n      throw new ToolExecutionError(\n        `Tool execution failed: ${error instanceof Error ? error.message : String(error)}`,\n        {\n          toolName,\n          input,\n          context: mergedContext,\n          originalError: error,\n        }\n      );\n    }\n  }\n\n  /**\n   * Execute multiple tools in parallel\n   */\n  async executeToolsParallel(\n    executions: Array<{\n      toolName: string;\n      input: unknown;\n      context?: Partial<ToolExecutionContext>;\n    }>,\n    state?: TState\n  ): Promise<Array<{ toolName: string; result: unknown; error?: Error }>> {\n    const promises = executions.map(async (execution) => {\n      try {\n        const result = await this.executeTool(\n          execution.toolName,\n          execution.input,\n          execution.context,\n          state\n        );\n        return { toolName: execution.toolName, result };\n      } catch (error) {\n        return {\n          toolName: execution.toolName,\n          result: null,\n          error: error instanceof Error ? error : new Error(String(error)),\n        };\n      }\n    });\n\n    return Promise.all(promises);\n  }\n\n  /**\n   * Execute multiple tools sequentially\n   */\n  async executeToolsSequential(\n    executions: Array<{\n      toolName: string;\n      input: unknown;\n      context?: Partial<ToolExecutionContext>;\n    }>,\n    state?: TState\n  ): Promise<Array<{ toolName: string; result: unknown; error?: Error }>> {\n    const results: Array<{ toolName: string; result: unknown; error?: Error }> =\n      [];\n\n    for (const execution of executions) {\n      try {\n        const result = await this.executeTool(\n          execution.toolName,\n          execution.input,\n          execution.context,\n          state\n        );\n        results.push({ toolName: execution.toolName, result });\n      } catch (error) {\n        results.push({\n          toolName: execution.toolName,\n          result: null,\n          error: error instanceof Error ? error : new Error(String(error)),\n        });\n      }\n    }\n\n    return results;\n  }\n\n  /**\n   * Validate tool input against schema if available\n   */\n  validateToolInput(toolName: string, input: unknown): boolean {\n    const tool = this.getTool(toolName);\n\n    if (!tool) {\n      return false;\n    }\n\n    if (!tool.schema) {\n      return true; // No schema validation required\n    }\n\n    try {\n      tool.schema.parse(input);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Get tool metadata\n   */\n  getToolMetadata(toolName: string): {\n    name: string;\n    description?: string;\n    hasSchema: boolean;\n    requiresApproval: boolean;\n  } | null {\n    const tool = this.getTool(toolName);\n\n    if (!tool) {\n      return null;\n    }\n\n    return {\n      name: tool.name,\n      description: tool.description,\n      hasSchema: !!tool.schema,\n      requiresApproval: !!tool.requiresApproval,\n    };\n  }\n\n  /**\n   * Update execution context\n   */\n  updateExecutionContext(context: Partial<ToolExecutionContext>): void {\n    this.executionContext = {\n      ...this.executionContext,\n      ...context,\n      timestamp: new Date(),\n    };\n  }\n\n  /**\n   * Get current execution context\n   */\n  getExecutionContext(): ToolExecutionContext {\n    return { ...this.executionContext };\n  }\n\n  /**\n   * Clear all tools\n   */\n  clearTools(): void {\n    const toolNames = this.getToolNames();\n\n    for (const toolName of toolNames) {\n      this.unregisterTool(toolName);\n    }\n  }\n\n  /**\n   * Get tools that require approval\n   */\n  getToolsRequiringApproval(): BaseTool<any, TState>[] {\n    return this.getAllTools().filter((tool) => tool.requiresApproval);\n  }\n\n  /**\n   * Validate tool definition\n   */\n  private validateToolDefinition(tool: BaseTool<any, TState>): void {\n    if (!tool.name || typeof tool.name !== \"string\") {\n      throw new Error(\"Tool name must be a non-empty string\");\n    }\n\n    if (tool.schema && typeof tool.schema.parse !== \"function\") {\n      throw new Error(\"Tool schema must be a valid Zod schema\");\n    }\n  }\n}\n","import { randomUUID } from \"node:crypto\";\nimport { Message, RunContext, StateConstraint, ControlFlowHandler } from \"./types\";\nimport { ToolProxy } from \"./tool-proxy\";\nimport { EventType } from \"./events\";\n\n/**\n * Handles tool execution with retry logic and custom control flow\n */\nexport class ToolExecutionHandler<TState extends StateConstraint = StateConstraint> {\n  constructor(\n    private toolProxy: ToolProxy<TState>,\n    private maxRetries: number = 0,\n    private customHandler?: ControlFlowHandler\n  ) {}\n\n  /**\n   * Execute a tool call with retry logic\n   * Returns result object with success status and optional message to save\n   */\n  async executeWithRetry(\n    eventEmitter: any,\n    toolCall: any,\n    assistantMessage: Message,\n    conversationMessages: any[],\n    allMessages: Message[],\n    context: RunContext<TState>,\n    state: TState\n  ): Promise<{ success: boolean; messageToSave?: Message }> {\n    let retryCount = 0;\n\n    while (retryCount <= this.maxRetries) {\n      try {\n        // Parse tool input\n        const toolName = toolCall.function.name;\n        const toolInput = toolCall.function.arguments\n          ? JSON.parse(toolCall.function.arguments)\n          : {};\n\n        // Validate tool call structure\n        if (!toolName) {\n          throw new Error(\n            `Tool call missing function name. Tool call data: ${JSON.stringify(toolCall)}`\n          );\n        }\n\n        // Check with custom control flow handler before executing tool\n        if (this.customHandler) {\n          try {\n            const toolDecision = await this.customHandler.handleToolCall(\n              toolCall,\n              context,\n              state\n            );\n\n            switch (toolDecision.action) {\n              case \"execute\":\n                // Continue with normal tool execution\n                break;\n              case \"request_approval\":\n                // Request approval from human or agent\n                this.emitEvent(eventEmitter, {\n                  type: EventType.APPROVAL_REQUIRED,\n                  toolName,\n                  toolInput,\n                  approver: toolDecision.approver,\n                  conversationId: context.conversationId,\n                  runId: context.runId,\n                } as any);\n                throw new Error(\n                  `Tool execution requires approval from ${toolDecision.approver}`\n                );\n              case \"reject\":\n                // Reject tool execution\n                throw new Error(\n                  `Tool execution rejected: ${toolDecision.reason}`\n                );\n              case \"modify\":\n                // Modify tool parameters\n                Object.assign(toolInput, toolDecision.newParams);\n                break;\n            }\n          } catch (error) {\n            console.error(\"Custom tool control flow handler error:\", error);\n            // Continue with normal execution if custom handler fails\n          }\n        }\n\n        // Check if tool has a handler before executing\n        const tool = this.toolProxy.getTool(toolName);\n        if (!tool?.invoke) {\n          // Client-side tool - skip execution, but add tool call to conversation history\n          // The client will handle the tool execution\n\n          // Add tool call to conversation history so LLM knows it was called\n          const toolCallMessage: any = {\n            role: \"tool\",\n            tool_call_id: toolCall.id,\n            content: `Tool '${toolName}' executed successfully by client. Result: ${JSON.stringify(toolInput)}`,\n          };\n          conversationMessages.push(toolCallMessage);\n\n          // Add to allMessages for tracking\n          allMessages.push({\n            id: randomUUID(),\n            role: \"tool\",\n            content: `Tool '${toolName}' executed successfully by client. Result: ${JSON.stringify(toolInput)}`,\n            toolCallId: toolCall.id,\n            timestamp: new Date(),\n          });\n\n          // Don't emit tool call result event for client-side tools\n          // The client will handle the tool execution and send the result back\n\n          return { success: false }; // Return false to indicate tool needs client handling, break the loop\n        }\n\n        // Execute the tool (server-side tool with handler)\n        const toolResult = await this.toolProxy.executeTool(\n          toolName,\n          toolInput,\n          {\n            conversationId: context.conversationId,\n            runId: context.runId,\n            timestamp: new Date(),\n            state: state, // Pass state directly for direct modification\n          },\n          state\n        );\n\n        // No need to handle _stateChanges anymore - tools modify state directly\n        const cleanResult = toolResult;\n\n        // Emit tool call result and end events\n        this.emitEvent(eventEmitter, {\n          type: EventType.TOOL_CALL_RESULT,\n          toolCallId: toolCall.id,\n          content: JSON.stringify(cleanResult),\n        } as any);\n\n        // Add tool result to conversation messages (for next LLM call)\n        const toolResultMessage = {\n          role: \"tool\",\n          tool_call_id: toolCall.id,\n          content: JSON.stringify(cleanResult),\n        };\n        conversationMessages.push(toolResultMessage);\n\n        // Create tool message with current state\n        const toolMessage: Message = {\n          id: randomUUID(),\n          role: \"tool\",\n          content: JSON.stringify(cleanResult),\n          timestamp: new Date(),\n          toolCallId: toolCall.id,\n          metadata: {\n            state: this.deepClone(state),\n            conversationId: context.conversationId,\n            runId: context.runId,\n            userId: context.userId,\n          },\n        };\n        allMessages.push(toolMessage);\n\n        // Success - break out of retry loop and return message to save\n        return { success: true, messageToSave: toolMessage };\n      } catch (error) {\n        retryCount++;\n\n        // Check with custom control flow handler for error handling\n        if (this.customHandler) {\n          try {\n            const errorDecision = await this.customHandler.handleError(\n              error as any,\n              context,\n              state\n            );\n\n            switch (errorDecision.action) {\n              case \"retry\":\n                // Override retry count with custom decision\n                if (retryCount <= errorDecision.maxAttempts) {\n                  console.warn(\n                    `Tool execution failed for ${toolCall.function.name}, retrying (${retryCount}/${errorDecision.maxAttempts}):`,\n                    error\n                  );\n                  await new Promise((resolve) =>\n                    setTimeout(resolve, 1000 * retryCount)\n                  );\n                  continue; // Continue retry loop\n                }\n                break;\n              case \"recover\":\n                // Attempt recovery\n                // Attempt recovery - could be extended to execute recovery logic\n                // For now, just log the recovery step - could be extended to execute recovery logic\n                break;\n              case \"escalate\":\n                // Escalate to human or agent\n                this.emitEvent(eventEmitter, {\n                  type: EventType.APPROVAL_REQUIRED,\n                  toolName: toolCall.function.name,\n                  error: error instanceof Error ? error.message : String(error),\n                  target: errorDecision.target,\n                  conversationId: context.conversationId,\n                  runId: context.runId,\n                } as any);\n                throw new Error(\n                  `Tool execution escalated to ${errorDecision.target}: ${error instanceof Error ? error.message : String(error)}`\n                );\n              case \"abort\":\n                // Abort execution\n                throw new Error(\n                  `Tool execution aborted: ${errorDecision.reason}`\n                );\n            }\n          } catch (handlerError) {\n            console.error(\n              \"Custom error control flow handler error:\",\n              handlerError\n            );\n            // Continue with normal error handling if custom handler fails\n          }\n        }\n\n        if (retryCount > this.maxRetries) {\n          // Max retries exceeded - log error and add error result\n          console.error(\n            `Tool execution failed for ${toolCall.function.name} after ${this.maxRetries} retries:`,\n            error\n          );\n\n          const errorContent = `Error: ${error instanceof Error ? error.message : String(error)}`;\n          conversationMessages.push({\n            role: \"tool\",\n            tool_call_id: toolCall.id,\n            content: errorContent,\n          });\n\n          allMessages.push({\n            id: randomUUID(),\n            role: \"tool\",\n            content: errorContent,\n            timestamp: new Date(),\n            toolCallId: toolCall.id,\n          });\n        } else {\n          // Retry - log warning and continue\n          console.warn(\n            `Tool execution failed for ${toolCall.function.name}, retrying (${retryCount}/${this.maxRetries}):`,\n            error\n          );\n\n          // Add a small delay before retry\n          await new Promise((resolve) =>\n            setTimeout(resolve, 1000 * retryCount)\n          );\n        }\n      }\n    }\n\n    // If we reach here, all retries failed\n    return { success: false };\n  }\n\n  /**\n   * Helper method to emit events\n   */\n  private emitEvent(eventEmitter: any, event: any): void {\n    if (eventEmitter.next) {\n      // Observable subscriber\n      eventEmitter.next(event);\n    } else if (eventEmitter.emit) {\n      // EventSystem\n      eventEmitter.emit(event.type, event);\n    }\n  }\n\n  /**\n   * Deep clone an object to prevent reference sharing\n   */\n  private deepClone<T>(obj: T): T {\n    if (obj === null || typeof obj !== 'object') {\n      return obj;\n    }\n    \n    if (obj instanceof Date) {\n      return new Date(obj.getTime()) as T;\n    }\n    \n    if (Array.isArray(obj)) {\n      return obj.map(item => this.deepClone(item)) as T;\n    }\n    \n    if (typeof obj === 'object') {\n      const cloned = {} as T;\n      for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          cloned[key] = this.deepClone(obj[key]);\n        }\n      }\n      return cloned;\n    }\n    \n    return obj;\n  }\n}\n\n","import { randomUUID } from \"node:crypto\";\nimport { Message, RunContext, StateConstraint } from \"./types\";\n\n/**\n * Handles message creation and building for agent execution\n */\nexport class MessageBuilder<TState extends StateConstraint = StateConstraint> {\n  /**\n   * Create a message with state metadata for memory storage\n   */\n  createMessageWithState(\n    role: Message['role'],\n    content: string,\n    conversationId: string,\n    state: TState,\n    options?: {\n      runId?: string;\n      userId?: string;\n      toolCalls?: any[];\n      toolCallId?: string;\n    }\n  ): Message {\n    return {\n      id: randomUUID(),\n      role,\n      content,\n      timestamp: new Date(),\n      toolCalls: options?.toolCalls,\n      toolCallId: options?.toolCallId,\n      metadata: {\n        state: this.deepClone(state),\n        conversationId,\n        runId: options?.runId,\n        userId: options?.userId\n      }\n    };\n  }\n\n  /**\n   * Build initial messages for agent execution\n   */\n  buildInitialMessages(\n    systemInstruction: string,\n    conversationMessages: Message[]\n  ): any[] {\n    const messages: any[] = [\n      { role: \"system\", content: systemInstruction },\n    ];\n\n    // Add conversation history in OpenAI format\n    for (const message of conversationMessages) {\n      if (message.role === \"user\") {\n        messages.push({\n          role: \"user\",\n          content: message.content,\n        });\n      } else if (message.role === \"assistant\") {\n        const assistantMessage: any = {\n          role: \"assistant\",\n          content: message.content,\n        };\n        if (message.toolCalls && message.toolCalls.length > 0) {\n          assistantMessage.tool_calls = message.toolCalls;\n        }\n        messages.push(assistantMessage);\n      } else if (message.role === \"tool\") {\n        messages.push({\n          role: \"tool\",\n          tool_call_id: message.toolCallId,\n          content: message.content,\n        });\n      }\n    }\n\n    return messages;\n  }\n\n  /**\n   * Extract current state from messages\n   */\n  extractStateFromMessages(messages: Message[]): TState {\n    const lastMessage = messages[messages.length - 1];\n    if (lastMessage?.metadata?.state) {\n      return lastMessage.metadata.state as TState;\n    }\n    return {} as TState;\n  }\n\n  /**\n   * Deep clone an object to prevent reference sharing\n   */\n  private deepClone<T>(obj: T): T {\n    if (obj === null || typeof obj !== 'object') {\n      return obj;\n    }\n    \n    if (obj instanceof Date) {\n      return new Date(obj.getTime()) as T;\n    }\n    \n    if (Array.isArray(obj)) {\n      return obj.map(item => this.deepClone(item)) as T;\n    }\n    \n    if (typeof obj === 'object') {\n      const cloned = {} as T;\n      for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          cloned[key] = this.deepClone(obj[key]);\n        }\n      }\n      return cloned;\n    }\n    \n    return obj;\n  }\n}\n\n","import { randomUUID } from \"node:crypto\";\nimport {\n  Message,\n  RunContext,\n  RunOptions,\n  StateConstraint,\n  OutputConstraint,\n  AgentResult,\n  AgentConfig,\n  ModelProvider,\n} from \"./types\";\nimport { EventType } from \"./events\";\nimport { ToolExecutionHandler } from \"./tool-execution-handler\";\nimport { MessageBuilder } from \"./message-builder\";\nimport { z } from \"zod/v4\";\n\n/**\n * AgentExecutor handles the core agent loop execution\n * Separated from Agent class to reduce complexity and improve testability\n */\nexport class AgentExecutor<\n  TState extends StateConstraint = StateConstraint,\n  TOutput extends OutputConstraint = string,\n> {\n  constructor(\n    private config: AgentConfig<TState, TOutput>,\n    private modelProvider: ModelProvider,\n    private toolExecutionHandler: ToolExecutionHandler<TState>,\n    private messageBuilder: MessageBuilder<TState>,\n    private getBusinessState: () => TState,\n    private addMessages: (\n      conversationId: string,\n      messages: Message[],\n      state: TState\n    ) => Promise<void>,\n    private syncState?: (state: TState) => void\n  ) {}\n\n  /**\n   * Execute the agent core loop\n   * @param eventEmitter - Event emitter (EventSystem or Observable subscriber)\n   * @param context - Run context containing conversation state\n   * @param options - Runtime options\n   * @param returnResult - Whether to return result or just emit events\n   * @returns AgentResult if returnResult is true, void otherwise\n   */\n  async execute(\n    eventEmitter: any,\n    context: RunContext<TState>,\n    options?: RunOptions<TState>,\n    returnResult: boolean = true\n  ): Promise<AgentResult<TOutput> | void> {\n    const startTime = Date.now();\n    const maxIterations = this.config.controlFlow?.maxSteps;\n    let iteration = 0;\n\n    try {\n      // Step 1: Build initial messages\n      this.emitEvent(eventEmitter, {\n        type: EventType.STEP_STARTED,\n        stepName: \"build_initial_messages\",\n      });\n\n      const systemInstruction = await this.getSystemInstruction(context);\n      let conversationMessages = this.messageBuilder.buildInitialMessages(\n        systemInstruction,\n        context.messages\n      );\n\n      this.emitEvent(eventEmitter, {\n        type: EventType.STEP_FINISHED,\n        stepName: \"build_initial_messages\",\n      });\n\n      // Step 2: Agent Loop\n      const loopResult = await this.executeAgentLoop(\n        eventEmitter,\n        context,\n        conversationMessages,\n        options,\n        maxIterations,\n        iteration,\n        startTime\n      );\n\n      if (loopResult.earlyReturn) {\n        return returnResult ? loopResult.result : undefined;\n      }\n\n      // Step 3: Transform output if needed\n      const outputData = await this.transformOutput(loopResult.finalResponse);\n\n      // Step 4: Build final result\n      const executionTime = Date.now() - startTime;\n      const result = this.buildResult(\n        outputData,\n        loopResult.allMessages,\n        context,\n        executionTime,\n        loopResult.totalTokenUsage\n      );\n\n      // Emit RUN_FINISHED event for stream mode\n      if (!returnResult) {\n        this.emitEvent(eventEmitter, {\n          type: EventType.RUN_FINISHED,\n          threadId: context.conversationId,\n          runId: context.runId,\n          result: result,\n          executionTime: executionTime,\n        });\n      }\n\n      return returnResult ? result : undefined;\n    } catch (error) {\n      const executionTime = Date.now() - startTime;\n      this.emitErrorEvent(eventEmitter, context, error, executionTime);\n      throw error;\n    }\n  }\n\n  /**\n   * Execute the main agent loop\n   */\n  private async executeAgentLoop(\n    eventEmitter: any,\n    context: RunContext<TState>,\n    conversationMessages: any[],\n    options: RunOptions<TState> | undefined,\n    maxIterations: number | undefined,\n    iteration: number,\n    startTime: number\n  ): Promise<{\n    finalResponse: string;\n    allMessages: Message[];\n    totalTokenUsage: any;\n    earlyReturn?: boolean;\n    result?: AgentResult<TOutput>;\n  }> {\n    let finalResponse = \"\";\n    let allMessages: Message[] = [];\n    let totalTokenUsage: any = null;\n    const customHandler = this.config.controlFlow?.customHandler;\n\n    while (maxIterations === undefined || iteration < maxIterations) {\n      iteration++;\n\n      // Check abort signal\n      if (options?.signal?.aborted) {\n        throw new Error(\n          `Run aborted: ${options.signal.reason || \"AbortSignal was aborted\"}`\n        );\n      }\n\n      // Check custom control flow\n      const controlResult = await this.checkControlFlow(\n        customHandler,\n        context,\n        eventEmitter,\n        startTime,\n        allMessages,\n        totalTokenUsage\n      );\n\n      if (controlResult) {\n        return {\n          finalResponse,\n          allMessages,\n          totalTokenUsage,\n          earlyReturn: true,\n          result: controlResult,\n        };\n      }\n\n      // Execute single iteration\n      this.emitEvent(eventEmitter, {\n        type: EventType.STEP_STARTED,\n        stepName: `agent_loop_iteration_${iteration}`,\n      });\n\n      const iterationResult = await this.executeSingleIteration(\n        eventEmitter,\n        context,\n        conversationMessages,\n        options,\n        allMessages\n      );\n\n      totalTokenUsage = this.accumulateTokenUsage(\n        totalTokenUsage,\n        iterationResult.tokenUsage\n      );\n\n      this.emitEvent(eventEmitter, {\n        type: EventType.STEP_FINISHED,\n        stepName: `agent_loop_iteration_${iteration}`,\n      });\n\n      // Check if we're done\n      if (iterationResult.isDone) {\n        finalResponse = iterationResult.content;\n        break;\n      }\n\n      // Check if we should break due to tool execution failure\n      if (!iterationResult.allToolsHandled) {\n        break;\n      }\n    }\n\n    // Check max iterations warning\n    if (maxIterations !== undefined && iteration >= maxIterations) {\n      console.warn(\n        `  Agent loop reached maximum iterations (${maxIterations})`\n      );\n      finalResponse =\n        finalResponse ||\n        \"Maximum iterations reached. The agent was unable to complete the task.\";\n    }\n\n    return { finalResponse, allMessages, totalTokenUsage };\n  }\n\n  /**\n   * Execute a single iteration of the agent loop\n   */\n  private async executeSingleIteration(\n    eventEmitter: any,\n    context: RunContext<TState>,\n    conversationMessages: any[],\n    options: RunOptions<TState> | undefined,\n    allMessages: Message[]\n  ): Promise<{\n    content: string;\n    isDone: boolean;\n    allToolsHandled: boolean;\n    tokenUsage: any;\n  }> {\n    // Call LLM\n    // Note: Abort signal is now handled at the HTTP request level by the model provider\n    const llmResponse = await this.callLLM(\n      conversationMessages,\n      context,\n      options,\n      true\n    );\n\n    // Process streaming response\n    const streamResult = await this.processStreamingResponse(\n      llmResponse,\n      eventEmitter,\n      options\n    );\n\n    // Create and save assistant message\n    const assistantMessage = await this.saveAssistantMessage(\n      streamResult.content,\n      streamResult.toolCalls,\n      context,\n      allMessages,\n      conversationMessages\n    );\n\n    // If no tool calls, we're done\n    if (streamResult.toolCalls.length === 0) {\n      return {\n        content: streamResult.content,\n        isDone: true,\n        allToolsHandled: true,\n        tokenUsage: streamResult.tokenUsage,\n      };\n    }\n\n    // Execute tool calls\n    const allToolsHandled = await this.executeToolCalls(\n      streamResult.toolCalls,\n      eventEmitter,\n      context,\n      conversationMessages,\n      allMessages,\n      assistantMessage\n    );\n\n    return {\n      content: streamResult.content,\n      isDone: false,\n      allToolsHandled,\n      tokenUsage: streamResult.tokenUsage,\n    };\n  }\n\n  /**\n   * Process streaming response from LLM\n   */\n  private async processStreamingResponse(\n    llmResponse: any,\n    eventEmitter: any\n  ): Promise<{\n    content: string;\n    toolCalls: any[];\n    tokenUsage: any;\n  }> {\n    let messageId: string | undefined;\n    let content = \"\";\n    let toolCalls: any[] = [];\n    let tokenUsage: any = null;\n\n    for await (const chunk of llmResponse) {\n      const choice = chunk.choices?.[0];\n      if (!choice) continue;\n\n      // Handle message start\n      if (choice.delta?.role && !messageId) {\n        messageId = randomUUID();\n        this.emitEvent(eventEmitter, {\n          type: EventType.TEXT_MESSAGE_START,\n          messageId,\n          role: \"assistant\",\n        });\n      }\n\n      // Handle content streaming\n      if (choice.delta?.content) {\n        content += choice.delta.content;\n        this.emitEvent(eventEmitter, {\n          type: EventType.TEXT_MESSAGE_CONTENT,\n          messageId: messageId!,\n          delta: choice.delta.content,\n        });\n      }\n\n      // Handle tool calls\n      if (choice.delta?.tool_calls) {\n        this.processToolCallDeltas(\n          choice.delta.tool_calls,\n          toolCalls,\n          eventEmitter\n        );\n      }\n\n      // Accumulate token usage\n      if (chunk.usage) {\n        tokenUsage = this.accumulateTokenUsage(tokenUsage, chunk.usage);\n      }\n    }\n\n    // Emit message end\n    if (messageId) {\n      this.emitEvent(eventEmitter, {\n        type: EventType.TEXT_MESSAGE_END,\n        messageId,\n      });\n    }\n\n    // Emit tool call end events\n    if (toolCalls.length > 0) {\n      for (const toolCall of toolCalls) {\n        this.emitEvent(eventEmitter, {\n          type: EventType.TOOL_CALL_END,\n          toolCallId: toolCall.id,\n        });\n      }\n    }\n\n    return { content, toolCalls, tokenUsage };\n  }\n\n  /**\n   * Process tool call deltas from streaming response\n   */\n  private processToolCallDeltas(\n    toolCallDeltas: any[],\n    toolCalls: any[],\n    eventEmitter: any\n  ): void {\n    for (const toolCallDelta of toolCallDeltas) {\n      let toolCallIndex = toolCallDelta.index;\n      if (toolCallIndex === undefined || toolCallIndex < 0) {\n        toolCallIndex = toolCalls.length;\n      }\n\n      if (!toolCalls[toolCallIndex]) {\n        toolCalls[toolCallIndex] = {\n          id: toolCallDelta.id || randomUUID(),\n          type: toolCallDelta.type || \"function\",\n          function: {\n            name: \"\",\n            arguments: \"\",\n          },\n        };\n\n        this.emitEvent(eventEmitter, {\n          type: EventType.TOOL_CALL_START,\n          toolCallId: toolCalls[toolCallIndex].id,\n          toolCallName: toolCallDelta.function?.name || \"\",\n        });\n      } else {\n        if (\n          toolCallDelta.id &&\n          toolCalls[toolCallIndex].id !== toolCallDelta.id\n        ) {\n          toolCalls[toolCallIndex].id = toolCallDelta.id;\n        }\n      }\n\n      if (toolCallDelta.function?.name) {\n        toolCalls[toolCallIndex].function.name = toolCallDelta.function.name;\n      }\n\n      if (toolCallDelta.function?.arguments) {\n        toolCalls[toolCallIndex].function.arguments +=\n          toolCallDelta.function.arguments;\n\n        this.emitEvent(eventEmitter, {\n          type: EventType.TOOL_CALL_ARGS,\n          toolCallId: toolCalls[toolCallIndex].id,\n          delta: toolCallDelta.function.arguments,\n        });\n      }\n    }\n  }\n\n  /**\n   * Save assistant message to conversation\n   */\n  private async saveAssistantMessage(\n    content: string,\n    toolCalls: any[],\n    context: RunContext<TState>,\n    allMessages: Message[],\n    conversationMessages: any[]\n  ): Promise<Message> {\n    const assistantMessage = this.messageBuilder.createMessageWithState(\n      \"assistant\",\n      content,\n      context.conversationId,\n      this.getBusinessState(),\n      {\n        runId: context.runId,\n        userId: context.userId,\n      }\n    );\n\n    if (toolCalls.length > 0) {\n      assistantMessage.toolCalls = toolCalls.map((tc: any) => ({\n        id: tc.id,\n        type: tc.type,\n        function: {\n          name: tc.function.name,\n          arguments: tc.function.arguments,\n        },\n      }));\n    }\n\n    allMessages.push(assistantMessage);\n\n    await this.addMessages(\n      context.conversationId,\n      [assistantMessage],\n      this.getBusinessState()\n    );\n\n    // Add to conversation messages\n    const assistantConversationMessage: any = {\n      role: \"assistant\",\n      content: content || null,\n    };\n    if (toolCalls.length > 0) {\n      assistantConversationMessage.tool_calls = toolCalls;\n    }\n    conversationMessages.push(assistantConversationMessage);\n\n    return assistantMessage;\n  }\n\n  /**\n   * Execute all tool calls\n   */\n  private async executeToolCalls(\n    toolCalls: any[],\n    eventEmitter: any,\n    context: RunContext<TState>,\n    conversationMessages: any[],\n    allMessages: Message[],\n    assistantMessage: Message\n  ): Promise<boolean> {\n    let allToolsHandled = true;\n\n    for (const toolCall of toolCalls) {\n      const result = await this.toolExecutionHandler.executeWithRetry(\n        eventEmitter,\n        toolCall,\n        assistantMessage,\n        conversationMessages,\n        allMessages,\n        context,\n        this.getBusinessState()\n      );\n\n      if (result.messageToSave) {\n        await this.addMessages(\n          context.conversationId,\n          [result.messageToSave],\n          this.getBusinessState()\n        );\n\n        // Sync state from tool message metadata after tool execution\n        if (this.syncState && result.messageToSave.metadata?.state) {\n          const updatedState = result.messageToSave.metadata.state as TState;\n          this.syncState(updatedState);\n        }\n      }\n\n      if (!result.success) {\n        allToolsHandled = false;\n      }\n    }\n\n    return allToolsHandled;\n  }\n\n  /**\n   * Check custom control flow handler\n   */\n  private async checkControlFlow(\n    customHandler: any,\n    context: RunContext<TState>,\n    eventEmitter: any,\n    startTime: number,\n    allMessages: Message[],\n    totalTokenUsage: any\n  ): Promise<AgentResult<TOutput> | null> {\n    if (!customHandler) return null;\n\n    try {\n      // Get the latest user message for handleNextStep\n      const latestUserMessage = allMessages\n        .filter((m) => m.role === \"user\")\n        .pop()?.content || \"\";\n      \n      // Also check state.userResponse if available\n      const state = this.getBusinessState();\n      const userMessage = (state as any)?.userResponse || latestUserMessage;\n\n      const controlDecision = await customHandler.handleNextStep(\n        context,\n        state,\n        userMessage\n      );\n\n      // Sync state after handleNextStep in case it was modified\n      // (handleNextStep modifies state directly, but we ensure it's synced)\n      if (this.syncState) {\n        this.syncState(state);\n      }\n\n      switch (controlDecision.action) {\n        case \"continue\":\n          return null;\n\n        case \"pause\":\n          this.emitEvent(eventEmitter, {\n            type: EventType.EXECUTION_PAUSED,\n            reason: controlDecision.reason,\n            conversationId: context.conversationId,\n            runId: context.runId,\n          });\n          throw new Error(`Execution paused: ${controlDecision.reason}`);\n\n        case \"complete\":\n          return this.buildResult(\n            controlDecision.result as TOutput,\n            allMessages,\n            context,\n            Date.now() - startTime,\n            totalTokenUsage\n          );\n\n        case \"interrupt\":\n          this.emitEvent(eventEmitter, {\n            type: EventType.RUN_FINISHED,\n            threadId: context.conversationId,\n            runId: context.runId,\n            outcome: \"interrupt\",\n            interrupt: {\n              id: randomUUID(),\n              reason: controlDecision.reason,\n              payload: controlDecision.payload,\n            },\n          });\n          return {\n            success: true,\n            data: \"\" as TOutput,\n            messages: allMessages,\n            metadata: {\n              conversationId: context.conversationId,\n              runId: context.runId,\n              executionTime: Date.now() - startTime,\n              tokenUsage: this.buildTokenUsage(totalTokenUsage),\n              outcome: \"interrupt\",\n              interrupt: {\n                reason: controlDecision.reason,\n                payload: controlDecision.payload,\n              },\n            } as any,\n          };\n\n        case \"escalate\":\n          this.emitEvent(eventEmitter, {\n            type: EventType.APPROVAL_REQUIRED,\n            target: controlDecision.target,\n            context: controlDecision.context,\n            conversationId: context.conversationId,\n            runId: context.runId,\n          });\n          throw new Error(\n            `Execution escalated to ${controlDecision.target}`\n          );\n      }\n    } catch (error) {\n      console.error(\"Custom control flow handler error:\", error);\n      // Continue with normal execution if custom handler fails\n    }\n\n    return null;\n  }\n\n  /**\n   * Get system instruction\n   */\n  private async getSystemInstruction(\n    context: RunContext<TState>\n  ): Promise<string> {\n    if (typeof this.config.instructions === \"function\") {\n      return await this.config.instructions(this.getBusinessState(), context);\n    }\n    return (\n      `${this.config.instructions} You are an Agent named \"${this.config.name || 'unnamed'}\" ${this.config.description ? `with description: \"${this.config.description}\".` : ''}.` ||\n      \"You are a helpful AI assistant. Do not assume or guess parameter values for function calls. If the user's description is unclear, ask the user to provide necessary information.\"\n    );\n  }\n\n  /**\n   * Transform output using configured output type\n   */\n  private async transformOutput(finalResponse: string): Promise<TOutput> {\n    if (\n      this.config.outputType &&\n      typeof this.config.outputType === \"object\" &&\n      \"schema\" in this.config.outputType\n    ) {\n      const zodSchema = this.config.outputType.schema;\n      if (zodSchema) {\n        try {\n          const parsedOutput = JSON.parse(finalResponse);\n          const validatedOutput = zodSchema.parse(parsedOutput);\n          return validatedOutput as TOutput;\n        } catch (error) {\n          console.error(\"Output validation failed:\", error);\n          return finalResponse as TOutput;\n        }\n      }\n    }\n    return finalResponse as TOutput;\n  }\n\n  /**\n   * Build final result object\n   */\n  private buildResult(\n    outputData: TOutput,\n    allMessages: Message[],\n    context: RunContext<TState>,\n    executionTime: number,\n    totalTokenUsage: any\n  ): AgentResult<TOutput> {\n    return {\n      success: true,\n      data: outputData,\n      messages: allMessages,\n      metadata: {\n        conversationId: context.conversationId,\n        runId: context.runId,\n        executionTime,\n        tokenUsage: this.buildTokenUsage(totalTokenUsage),\n      },\n    };\n  }\n\n  /**\n   * Build token usage object\n   */\n  private buildTokenUsage(totalTokenUsage: any): {\n    promptTokens: number;\n    completionTokens: number;\n    totalTokens: number;\n  } {\n    return totalTokenUsage\n      ? {\n          promptTokens: totalTokenUsage.prompt_tokens || 0,\n          completionTokens: totalTokenUsage.completion_tokens || 0,\n          totalTokens: totalTokenUsage.total_tokens || 0,\n        }\n      : {\n          promptTokens: 0,\n          completionTokens: 0,\n          totalTokens: 0,\n        };\n  }\n\n  /**\n   * Accumulate token usage\n   */\n  private accumulateTokenUsage(\n    currentUsage: any,\n    newUsage: any\n  ): any {\n    if (!newUsage) return currentUsage;\n\n    if (!currentUsage) {\n      return { ...newUsage };\n    }\n\n    return {\n      prompt_tokens:\n        (currentUsage.prompt_tokens || 0) + (newUsage.prompt_tokens || 0),\n      completion_tokens:\n        (currentUsage.completion_tokens || 0) +\n        (newUsage.completion_tokens || 0),\n      total_tokens:\n        (currentUsage.total_tokens || 0) + (newUsage.total_tokens || 0),\n    };\n  }\n\n  /**\n   * Call LLM with streaming\n   */\n  private async callLLM(\n    messages: Array<{ role: string; content: string; tool_calls?: any[] }>,\n    context: RunContext<TState>,\n    options?: RunOptions<TState>,\n    stream: boolean = false\n  ): Promise<any> {\n    if (!this.modelProvider?.chat) {\n      throw new Error(\"No model provider configured or chat interface not available\");\n    }\n\n    // Determine model name\n    const modelName = this.getModelName(options);\n\n    // Prepare tools\n    const toolDefinitions = this.prepareToolDefinitions(options);\n\n    // Build request params\n    const requestParams: any = {\n      model: modelName,\n      messages,\n      temperature:\n        options?.temperature ?? this.config.modelSettings?.temperature ?? 0.7,\n      max_tokens:\n        options?.maxTokens ?? this.config.modelSettings?.maxTokens ?? 1000,\n      stream: stream,\n    };\n\n    if (toolDefinitions && toolDefinitions.length > 0) {\n      requestParams.tools = toolDefinitions;\n      requestParams.tool_choice = \"auto\";\n    }\n\n    // Pass abort signal to the model provider\n    if (options?.signal) {\n      requestParams.signal = options.signal;\n    }\n\n    return this.modelProvider.chat.completions.stream(requestParams);\n  }\n\n  /**\n   * Get model name from options or config\n   */\n  private getModelName(options?: RunOptions<TState>): string {\n    if (options?.model) {\n      return options.model;\n    }\n    if (typeof this.config.model === \"string\") {\n      return this.config.model;\n    }\n    return (this.modelProvider as any).getDefaultModel();\n  }\n\n  /**\n   * Prepare tool definitions for LLM\n   */\n  private prepareToolDefinitions(options?: RunOptions<TState>): any[] | undefined {\n    const configTools = this.config.tools ?? [];\n    const runtimeTools = options?.tools ?? [];\n    \n    if (!configTools.length && !runtimeTools.length) return undefined;\n\n    // Merge tools (runtime overrides config by name)\n    const byName = new Map<string, any>();\n    for (const t of configTools) byName.set(t.name, t);\n    for (const t of runtimeTools) byName.set(t.name, t);\n    const mergedTools = Array.from(byName.values());\n\n    return mergedTools.map((tool) => {\n      const isZodSchema =\n        !!tool.schema &&\n        typeof (tool.schema as any).safeParse === \"function\";\n\n      let parameters;\n      if (isZodSchema) {\n        try {\n          parameters = z.toJSONSchema(tool.schema as any);\n        } catch (error) {\n          parameters = tool.schema;\n        }\n      } else {\n        parameters = tool.schema;\n      }\n\n      return {\n        type: \"function\" as const,\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters,\n        },\n      };\n    });\n  }\n\n  /**\n   * Emit event to either EventSystem or Observable subscriber\n   */\n  private emitEvent(eventEmitter: any, event: any): void {\n    if (eventEmitter.next) {\n      eventEmitter.next(event);\n    } else {\n      eventEmitter.emit(event.type, event);\n    }\n  }\n\n  /**\n   * Emit error event\n   */\n  private emitErrorEvent(\n    eventEmitter: any,\n    context: RunContext<TState>,\n    error: any,\n    executionTime: number\n  ): void {\n    this.emitEvent(eventEmitter, {\n      type: EventType.RUN_ERROR,\n      threadId: context.conversationId,\n      runId: context.runId,\n      message: error instanceof Error ? error.message : String(error),\n      code: error instanceof Error ? error.name : \"UNKNOWN_ERROR\",\n      details: error,\n    });\n  }\n}\n\n","import { Tiktoken, get_encoding, TiktokenEncoding } from \"tiktoken\";\n\n/**\n * @fileoverview Token utilities for text processing and token management\n */\n\n/**\n * Tokenizer interface for encoding, decoding, and counting tokens\n */\nexport interface ITokenizer {\n  /** Encode text into tokens */\n  encode(text: string): Uint32Array;\n  /** Decode tokens back to text */\n  decode(tokens: Uint32Array): string;\n  /** Count the number of tokens in text */\n  countTokens(text: string): number;\n}\n\n/**\n * Default tokenizer implementation based on tiktoken\n * Provides accurate token counting for OpenAI models\n */\nexport class TiktokenTokenizer implements ITokenizer {\n  /** Tiktoken encoding instance for token operations */\n  private encoding: Tiktoken;\n\n  /**\n   * Creates a new TiktokenTokenizer instance\n   * @param encodingName - Tiktoken encoding name, defaults to 'o200k_base'\n   */\n  constructor(encodingName: TiktokenEncoding = \"o200k_base\") {\n    this.encoding = get_encoding(encodingName);\n  }\n\n  /**\n   * Encode text into token array\n   * @param text - Text to encode\n   * @returns Array of token IDs\n   */\n  encode(text: string): Uint32Array {\n    return this.encoding.encode(text);\n  }\n\n  /**\n   * Decode tokens back to text\n   * @param tokens - Token array to decode\n   * @returns Decoded text string\n   */\n  decode(tokens: Uint32Array): string {\n    const decoded = this.encoding.decode(tokens);\n    return typeof decoded === \"string\"\n      ? decoded\n      : new TextDecoder().decode(decoded);\n  }\n\n  /**\n   * Count the number of tokens in text\n   * @param text - Text to count tokens for\n   * @returns Number of tokens\n   */\n  countTokens(text: string): number {\n    return this.encoding.encode(text).length;\n  }\n\n  /**\n   * Free the encoding resources\n   */\n  free(): void {\n    this.encoding.free();\n  }\n}\n\n/**\n * Simple character-based tokenizer for testing or basic scenarios\n * Provides approximate token counting based on character length\n */\nexport class SimpleTokenizer implements ITokenizer {\n  /** Ratio of tokens per character for estimation */\n  private tokensPerChar: number;\n\n  /**\n   * Creates a new SimpleTokenizer instance\n   * @param tokensPerChar - Estimated tokens per character ratio, defaults to 0.25\n   */\n  constructor(tokensPerChar: number = 0.25) {\n    this.tokensPerChar = tokensPerChar;\n  }\n\n  /**\n   * Encode text into token array (simple character-based implementation)\n   * @param text - Text to encode\n   * @returns Array of character codes as tokens\n   */\n  encode(text: string): Uint32Array {\n    // Simple implementation: convert each character to a token\n    const tokens = new Uint32Array(text.length);\n    for (let i = 0; i < text.length; i++) {\n      tokens[i] = text.charCodeAt(i);\n    }\n    return tokens;\n  }\n\n  /**\n   * Decode tokens back to text\n   * @param tokens - Token array to decode\n   * @returns Decoded text string\n   */\n  decode(tokens: Uint32Array): string {\n    return String.fromCharCode(...Array.from(tokens));\n  }\n\n  /**\n   * Count tokens based on character length and ratio\n   * @param text - Text to count tokens for\n   * @returns Estimated number of tokens\n   */\n  countTokens(text: string): number {\n    return Math.ceil(text.length * this.tokensPerChar);\n  }\n}\n\n/**\n * Token trimming utility class for managing message token limits\n * Similar to LangChain's trimMessage functionality\n */\nexport class TokenTrimmer {\n  /** Tokenizer instance for token counting */\n  private tokenizer: ITokenizer;\n\n  /**\n   * Creates a new TokenTrimmer instance\n   * @param tokenizer - Optional tokenizer, defaults to TiktokenTokenizer\n   */\n  constructor(tokenizer?: ITokenizer) {\n    this.tokenizer = tokenizer || new TiktokenTokenizer();\n  }\n\n  /**\n   * Calculate the token count for a message including role and content\n   * @param message - Message object with role and content\n   * @returns Total token count including formatting overhead\n   */\n  countMessageTokens(message: { role: string; content: string }): number {\n    // Calculate tokens for role and content\n    const roleTokens = this.tokenizer.countTokens(message.role);\n    const contentTokens = this.tokenizer.countTokens(message.content);\n    // Add extra tokens for formatting (similar to ChatML format)\n    return roleTokens + contentTokens + 4; // 4 extra tokens for formatting\n  }\n\n  /**\n   * Trim message list to fit within token limits\n   * Preserves messages starting from newest or oldest based on strategy\n   * @param events - Array of events with message objects\n   * @param maxTokens - Maximum token limit\n   * @param strategy - Trimming strategy: 'newest_first' or 'oldest_first'\n   * @returns Trimmed array of events within token limit\n   */\n  trimMessages<T extends { message: { role: string; content: string } }>(\n    events: T[],\n    maxTokens: number,\n    strategy: \"newest_first\" | \"oldest_first\" = \"newest_first\"\n  ): T[] {\n    if (maxTokens <= 0) {\n      return [];\n    }\n\n    const eventsToProcess =\n      strategy === \"newest_first\" ? [...events].reverse() : [...events];\n\n    const result: T[] = [];\n    let totalTokens = 0;\n\n    for (const event of eventsToProcess) {\n      const messageTokens = this.countMessageTokens(event.message);\n\n      if (totalTokens + messageTokens <= maxTokens) {\n        result.push(event);\n        totalTokens += messageTokens;\n      } else {\n        // If a single message exceeds the limit, we can choose to truncate or skip\n        if (result.length === 0 && messageTokens > maxTokens) {\n          // If this is the first message and exceeds limit, try to truncate content\n          const truncatedEvent = this.truncateMessage(event, maxTokens);\n          if (truncatedEvent) {\n            result.push(truncatedEvent);\n          }\n        }\n        break;\n      }\n    }\n\n    // If processed from newest first, restore original order\n    return strategy === \"newest_first\" ? result.reverse() : result;\n  }\n\n  /**\n   * Truncate a single message to fit within token limits\n   * @param event - Event to truncate\n   * @param maxTokens - Maximum token limit\n   * @returns Truncated event or null if cannot fit\n   */\n  private truncateMessage<\n    T extends { message: { role: string; content: string } },\n  >(event: T, maxTokens: number): T | null {\n    const roleTokens = this.tokenizer.countTokens(event.message.role);\n    const availableTokens = maxTokens - roleTokens - 4; // Subtract formatting tokens\n\n    if (availableTokens <= 0) {\n      return null;\n    }\n\n    // Binary search to find appropriate truncation length\n    let left = 0;\n    let right = event.message.content.length;\n    let bestLength = 0;\n\n    while (left <= right) {\n      const mid = Math.floor((left + right) / 2);\n      const truncatedContent = event.message.content.substring(0, mid);\n      const contentTokens = this.tokenizer.countTokens(truncatedContent);\n\n      if (contentTokens <= availableTokens) {\n        bestLength = mid;\n        left = mid + 1;\n      } else {\n        right = mid - 1;\n      }\n    }\n\n    if (bestLength === 0) {\n      return null;\n    }\n\n    return {\n      ...event,\n      message: {\n        ...event.message,\n        content: event.message.content.substring(0, bestLength) + \"...\",\n      },\n    };\n  }\n\n  /**\n   * Free tokenizer resources\n   */\n  free(): void {\n    if (this.tokenizer instanceof TiktokenTokenizer) {\n      this.tokenizer.free();\n    }\n  }\n}\n","/**\n * @fileoverview Base memory interfaces and abstract class for short-term memory management\n */\n\nimport {\n  TokenTrimmer,\n  ITokenizer,\n  TiktokenTokenizer,\n} from \"../utils/token-utils\";\n\n/**\n * Message interface representing a conversation message\n */\nexport interface Message {\n  /** Unique identifier for the message */\n  id: string;\n  /** Role of the message sender */\n  role: \"user\" | \"assistant\" | \"system\" | \"tool\";\n  /** Content of the message */\n  content: string;\n  /** Optional timestamp when the message was created */\n  timestamp?: Date;\n  /** Optional tool calls associated with the message */\n  toolCalls?: any[];\n  /** Optional tool call identifier */\n  toolCallId?: string;\n}\n\n/**\n * Memory event interface combining message and state information\n */\nexport interface IMemoryEvent {\n  /** The message content */\n  message: Message;\n  /** Additional state information */\n  state: Record<string, any>;\n}\n\nexport type TInputMemoryEvent = Omit<IMemoryEvent, \"message\"> & {\n  message: Omit<Message, \"id\"> & { id?: Message[\"id\"] };\n};\n\n/**\n * Options for listing and querying memory events\n */\nexport interface ListOptions {\n  /** Maximum number of tokens to include in results */\n  maxTokens?: number;\n  /** Maximum number of events to return */\n  limit?: number;\n  /** Number of events to skip (for pagination) */\n  offset?: number;\n  /** Sort order by timestamp */\n  order?: \"asc\" | \"desc\";\n  /** Session identifier for multi-session support */\n  sessionId?: string;\n}\n\n/**\n * Options for adding memory events\n */\nexport interface AddOptions {\n  /** Session identifier for multi-session support */\n  sessionId?: string;\n}\n\n/**\n * Options for deleting memory events\n */\nexport interface DeleteOptions {\n  /** Session identifier for multi-session support */\n  sessionId?: string;\n}\n\n/**\n * Options for retrieving memory events\n */\nexport interface RetrieveOptions {\n  /** Session identifier for multi-session support */\n  sessionId?: string;\n}\n\n/**\n * Options for clearing memory events\n */\nexport interface ClearOptions {\n  /** Session identifier for multi-session support. If not provided, clears all sessions */\n  sessionId?: string;\n}\n\n/**\n * Branch information for session management\n */\nexport interface BranchInfo {\n  /** Branch name */\n  name: string;\n  /** When the branch was created */\n  createdAt: Date;\n  /** Event ID this branch was created from */\n  fromEventId?: string;\n  /** Whether this is the currently active branch */\n  isActive: boolean;\n}\n\n/**\n * Compaction metadata stored in event.state.__compaction__\n */\nexport interface CompactionMetadata {\n  /** Original full message content before compaction */\n  originalContent: string;\n  /** Original token count */\n  originalTokens: number;\n  /** Compacted token count */\n  compactedTokens: number;\n}\n\n/**\n * Structured summary schema (not free-form text)\n */\nexport interface StructuredSummary {\n  content: string;\n  count: number;\n  timeRange: { start?: Date; end?: Date };\n  timestamp: Date;\n}\n\n/**\n * Context thresholds configuration\n */\nexport interface ContextThresholds {\n  /** Pre-rot threshold - where performance starts degrading */\n  preRotThreshold: number;\n  /** Trigger compaction at this percentage of pre-rot threshold */\n  compactionTrigger: number; // e.g., 0.8 = 80%\n  /** Trigger summarization at this percentage of pre-rot threshold */\n  summarizationTrigger: number; // e.g., 0.95 = 95%\n  /** Number of recent events to keep */\n  recentToKeep: number;\n}\n\nexport interface IBaseMemoryOptions {\n  tokenizer?: ITokenizer;\n  thresholds?: Partial<ContextThresholds>;\n  summarizer?: (events: IMemoryEvent[]) => Promise<StructuredSummary>;\n}\n\n/**\n * Abstract base class for short-term memory implementations\n *\n * Provides the core interface for storing, retrieving, and managing\n * conversation events in short-term memory systems with built-in\n * context engineering capabilities.\n */\nexport abstract class BaseMemory {\n  public tokenTrimmer: TokenTrimmer;\n  protected thresholds?: ContextThresholds;\n\n  // Metrics\n  protected compactionCount = 0;\n  protected summarizationCount = 0;\n  protected lastCompactionGain = 0;\n\n  constructor(config?: IBaseMemoryOptions) {\n    this.tokenTrimmer = new TokenTrimmer(\n      config?.tokenizer || new TiktokenTokenizer()\n    );\n\n    if (config?.thresholds) {\n      this.thresholds = {\n        preRotThreshold: config.thresholds.preRotThreshold || 150_000,\n        compactionTrigger: config.thresholds.compactionTrigger || 0.8,\n        summarizationTrigger: config.thresholds.summarizationTrigger || 0.95,\n        recentToKeep: config.thresholds.recentToKeep || 5,\n      };\n    }\n\n    if (config?.summarizer) {\n      this.summarizer = config.summarizer;\n    }\n  }\n\n  /**\n   * Returns a list of events stored in the memory\n   * @param options - Optional filtering and pagination options\n   * @returns Promise resolving to array of memory events\n   */\n  public abstract list(options?: ListOptions): Promise<IMemoryEvent[]>;\n\n  /**\n   * Add a single memory event to storage\n   * @param event - The memory event to store\n   * @param options - Optional configuration including session ID\n   * @returns Promise that resolves when the event is stored\n   */\n  public abstract add(event: TInputMemoryEvent, options?: AddOptions): Promise<void>;\n\n  /**\n   * Add multiple memory events efficiently\n   *\n   * Implementations should override this method to handle bulk addition\n   * efficiently and avoid unnecessary round-trips to the underlying store.\n   *\n   * @param list - Array of memory events to store\n   * @returns Promise that resolves when all events are stored\n   */\n  public async addList(\n    list: TInputMemoryEvent[],\n    options?: AddOptions\n  ): Promise<void> {\n    for (const event of list) {\n      await this.add(event, options);\n    }\n  }\n\n  public abstract update(params: {\n    sessionId?: string;\n    event: Partial<IMemoryEvent>;\n  }): Promise<void>;\n\n  /**\n   * Delete memory events from storage\n   * @param args - Implementation-specific arguments for deletion\n   * @returns Promise that resolves when deletion is complete\n   */\n  public abstract delete(...args: any[]): Promise<void>;\n\n  /**\n   * Retrieve memory events based on search criteria\n   * @param args - Implementation-specific arguments for retrieval\n   * @returns Promise resolving to array of matching memory events\n   */\n  public abstract retrieve(...args: any[]): Promise<IMemoryEvent[]>;\n\n  /**\n   * Remove all events from storage\n   * @returns Promise that resolves when all events are cleared\n   * @throws Error if not implemented by subclass\n   */\n  public clear(): Promise<void> {\n    throw new Error(\"Clear method not implemented.\");\n  }\n\n  // ==================== Session Branching (Optional) ====================\n\n  /**\n   * Create a new branch from current session state\n   * @param branchName - Name for the new branch\n   * @param fromEventId - Optional event ID to branch from\n   * @returns Promise resolving to branch ID\n   * @throws Error if not implemented by subclass\n   */\n  public branch(branchName: string, fromEventId?: string): Promise<string> {\n    throw new Error(\"Branch method not implemented.\");\n  }\n\n  /**\n   * Switch to a different branch or checkout to a specific event\n   * @param target - Branch name or event ID to checkout\n   * @param options - Optional configuration\n   * @param options.type - Type of checkout: 'branch' or 'event' (default: auto-detect)\n   * @param options.sessionId - Session ID when checking out to an event\n   * @returns Promise that resolves when checkout is complete\n   * @throws Error if not implemented by subclass\n   *\n   * @example\n   * // Checkout to a branch\n   * await memory.checkout('experiment-1');\n   *\n   * // Checkout to a specific event (deletes all events after it)\n   * await memory.checkout('event-123', { type: 'event', sessionId: 'session-1' });\n   */\n  public checkout(\n    target: string,\n    options?: { type?: \"branch\" | \"event\"; sessionId?: string }\n  ): Promise<void> {\n    throw new Error(\"Checkout method not implemented.\");\n  }\n\n  /**\n   * List all available branches\n   * @returns Promise resolving to array of branch information\n   * @throws Error if not implemented by subclass\n   */\n  public listBranches(): Promise<BranchInfo[]> {\n    throw new Error(\"ListBranches method not implemented.\");\n  }\n\n  /**\n   * Delete a branch\n   * @param branchName - Name of the branch to delete\n   * @returns Promise that resolves when deletion is complete\n   * @throws Error if not implemented by subclass or trying to delete active branch\n   */\n  public deleteBranch(branchName: string): Promise<void> {\n    throw new Error(\"DeleteBranch method not implemented.\");\n  }\n\n  /**\n   * Clean up all inactive branches, keeping only the main branch\n   * This is useful for maintaining a single trunk after experimentation\n   * @param keepBranches - Optional list of branch names to keep (in addition to active branch)\n   * @returns Promise that resolves when cleanup is complete\n   * @throws Error if not implemented by subclass\n   */\n  public cleanupBranches(keepBranches?: string[]): Promise<void> {\n    throw new Error(\"CleanupBranches method not implemented.\");\n  }\n\n  // ==================== Context Engineering (Optional) ====================\n\n  /**\n   * Check if an event is compacted\n   * @param event - Event to check\n   * @returns True if event has compaction metadata\n   */\n  public isCompacted(event: IMemoryEvent): boolean {\n    return event.state?.__compaction__ !== undefined;\n  }\n\n  /**\n   * Decompress a compacted event\n   * @param event - Event to decompress\n   * @returns Decompressed event with original content and state\n   */\n  public decompressEvent(event: IMemoryEvent): IMemoryEvent {\n    if (!this.isCompacted(event)) {\n      return event;\n    }\n\n    const { __compaction__, ...metadata } = event.state;\n\n    return {\n      message: {\n        ...event.message,\n        content: __compaction__.originalContent,\n      },\n      state: metadata,\n    };\n  }\n\n  /**\n   * Decompress multiple events\n   * @param events - Events to decompress\n   * @returns Array of decompressed events\n   */\n  public decompressEvents(events: IMemoryEvent[]): IMemoryEvent[] {\n    return events.map((e) => this.decompressEvent(e));\n  }\n\n  // ==================== Context Engineering Core Methods ====================\n\n  /**\n   * Manage context automatically when adding events\n   * Subclasses should call this method after adding events if context management is enabled\n   */\n  protected async manageContext({\n    sessionId,\n    events,\n  }: {\n    sessionId: string;\n    events: IMemoryEvent[];\n  }): Promise<{ events: IMemoryEvent[] }> {\n    if (!this.thresholds) {\n      return { events };\n    }\n    const currentTokens = await this.getCurrentTokenCount(events);\n\n    const compactionThreshold =\n      this.thresholds!.preRotThreshold * this.thresholds!.compactionTrigger;\n    const summarizationThreshold =\n      this.thresholds!.preRotThreshold * this.thresholds!.summarizationTrigger;\n\n    if (\n      this.thresholds?.recentToKeep &&\n      events.length > this.thresholds?.recentToKeep\n    ) {\n      if (currentTokens >= summarizationThreshold) {\n        const { events: processedEvents } = await this.performSummarization({ sessionId, events });\n        return { events: processedEvents }\n      }\n\n      // Step 1: Check if compaction is needed\n      if (currentTokens >= compactionThreshold) {\n        const { events: compactedEvents, gain: gainFromCompaction } = await this.performCompaction({\n          sessionId,\n          events,\n        });\n\n        if (gainFromCompaction > this.thresholds!.preRotThreshold * 0.05) {\n          return { events: compactedEvents };\n        }\n\n        const { events: processedEvents } = await this.performSummarization({ sessionId, events });\n        return { events: processedEvents }\n      }\n    }\n\n    return { events }\n  }\n\n  /**\n   * Perform compaction (reversible externalization to event.state)\n   * Subclasses should override this method to implement compaction logic\n   * @returns Token gain from compaction\n   */\n  protected async performCompaction({\n    sessionId,\n    events,\n  }: {\n    sessionId?: string;\n    events: IMemoryEvent[];\n  }): Promise<{ events: IMemoryEvent[], gain: number }> {\n    const tokensBefore = await this.getCurrentTokenCount(events);\n\n    // Calculate how many events to compact\n    const totalEvents = events.length;\n    const recentToKeep = this.thresholds!.recentToKeep;\n    const delta = totalEvents - recentToKeep;\n\n    if (delta <= 0) {\n      return { events, gain: 0 };\n    }\n\n    // Compact oldest events\n    const processedEvents = await Promise.all(events.map(async (event, i) => {\n      if (i < delta) {\n        if (!this.isCompacted(event)) {\n          return this.compactEvent({ sessionId, event });\n        }\n      }\n      return event;\n    }))\n\n    const tokensAfter = await this.getCurrentTokenCount(processedEvents);\n    const gain = tokensBefore - tokensAfter;\n\n    this.compactionCount++;\n    this.lastCompactionGain = gain;\n\n    return { events: processedEvents, gain };\n  }\n\n  /**\n   * Compact a single event - store full content in state\n   */\n  protected async compactEvent({\n    sessionId,\n    event,\n  }: {\n    sessionId?: string;\n    event: IMemoryEvent;\n  }): Promise<IMemoryEvent> {\n    if (!this.tokenTrimmer) {\n      return event;\n    }\n\n    // Calculate original tokens\n    const originalTokens = await this.tokenTrimmer.countMessageTokens(\n      event.message\n    );\n\n    // Store original content and state in event.state.__compaction__\n    const compactionMetadata: CompactionMetadata = {\n      originalContent: event.message.content,\n      originalTokens,\n      compactedTokens: 0,\n    };\n\n    // Replace content with compact reference\n    const compactContent = `[Compacted: ${event.message.role} message, ${originalTokens} tokens]`;\n    event.message.content = compactContent;\n\n    // Store metadata in state\n    event.state = {\n      ...event.state,\n      __compaction__: compactionMetadata,\n    };\n\n    // Calculate compacted tokens\n    compactionMetadata.compactedTokens =\n      await this.tokenTrimmer.countMessageTokens(event.message);\n\n    await this.update({ sessionId, event });\n    return event\n  }\n\n  /**\n   * Perform summarization (irreversible refinement)\n   * @param sessionId - Optional session identifier (implementation-specific)\n   */\n  protected async performSummarization({\n    sessionId,\n    events,\n  }: {\n    sessionId?: string;\n    events: IMemoryEvent[];\n  }): Promise<{ events: IMemoryEvent[], summary?: StructuredSummary }> {\n    const recentToKeep = this.thresholds!.recentToKeep;\n\n    if (events.length <= recentToKeep) {\n      return { events }\n    }\n\n    // Events to summarize (excluding recent ones)\n    const eventsToSummarize = events.slice(0, -recentToKeep);\n\n    // Decompress events before summarization for better quality\n    const decompressedEvents = this.decompressEvents(eventsToSummarize);\n\n    // Create structured summary\n    const summary = await this.summarizer(decompressedEvents);\n\n    // Store summary (subclasses should implement this)\n    await this.storeSummary({ sessionId, summary });\n\n    // Remove summarized events, keep recent ones\n    await this.clearSummarizedEvents({ sessionId, recentToKeep });\n\n    this.summarizationCount++;\n\n    return { events: events.slice(-recentToKeep), summary }\n  }\n\n  /**\n   * Store summary (to be implemented by subclasses)\n   * @param summary - The structured summary to store\n   */\n  protected async storeSummary(params: {\n    sessionId?: string;\n    summary: StructuredSummary;\n  }): Promise<void> {\n    // Default implementation does nothing - subclasses should override\n  }\n\n  /**\n   * Clear summarized events (to be implemented by subclasses)\n   * @param sessionId - Optional session identifier (implementation-specific)\n   * @param recentToKeep - Number of recent events to keep\n   */\n  protected async clearSummarizedEvents(params: {\n    sessionId?: string;\n    recentToKeep: number;\n  }): Promise<void> {\n    // Default implementation does nothing - subclasses should override\n  }\n\n  /**\n   * Get current token count for a session\n   */\n  protected async getCurrentTokenCount(\n    events: IMemoryEvent[]\n  ): Promise<number> {\n    if (!this.tokenTrimmer) {\n      return 0;\n    }\n\n    let total = 0;\n\n    for (const event of events) {\n      if (this.isCompacted(event)) {\n        const __compaction__ = event.state.__compaction__ as CompactionMetadata;\n        total += __compaction__.compactedTokens;\n      } else {\n        total += await this.tokenTrimmer.countMessageTokens(event.message);\n      }\n    }\n\n    return total;\n  }\n\n  /**\n   * Create default structured summary\n   */\n  public async summarizer(events: IMemoryEvent[]): Promise<StructuredSummary> {\n    return {\n      content: \"\",\n      count: events.length,\n      timeRange: {\n        start: events[0]?.message.timestamp,\n        end: events[events.length - 1]?.message.timestamp,\n      },\n      timestamp: new Date(),\n    };\n  }\n}\n","/**\n * In-Memory Utility Functions\n *\n * Collection management and document conversion utilities for in-memory implementation\n */\n\nimport { IMemoryEvent } from \"../memory-base\";\nimport { ICollectionManager, IDatabaseAdapter } from \"../common/types\";\nimport { InMemoryCollection, InMemoryDocument, InMemorySummaryDocument, InMemoryStateDocument } from \"./types\";\n// Import will be done lazily to avoid circular dependency\n\n// ==================== Collection Manager ====================\n\n/**\n * Manages in-memory collection instances (JavaScript arrays)\n */\nexport class CollectionManager implements ICollectionManager {\n  private adapter: IDatabaseAdapter;\n  private eventsCollection: InMemoryCollection<InMemoryDocument>;\n  private summaryCollection: InMemoryCollection<InMemorySummaryDocument>;\n  private stateCollection: InMemoryCollection<InMemoryStateDocument>;\n\n  constructor() {\n    // Lazy import to avoid circular dependency\n    const { InMemoryAdapter } = require(\"./in-memory-adapter\");\n    this.adapter = new InMemoryAdapter();\n    this.eventsCollection = [];\n    this.summaryCollection = [];\n    this.stateCollection = [];\n  }\n\n  /**\n   * Get the main events collection\n   */\n  getCollection(): InMemoryCollection<InMemoryDocument> {\n    return this.eventsCollection;\n  }\n\n  /**\n   * Get the summary collection\n   */\n  getSummaryCollection(): InMemoryCollection<InMemorySummaryDocument> {\n    return this.summaryCollection;\n  }\n\n  /**\n   * Get the state collection\n   */\n  getStateCollection(): InMemoryCollection<InMemoryStateDocument> {\n    return this.stateCollection;\n  }\n\n  /**\n   * Get database adapter\n   */\n  getAdapter(): IDatabaseAdapter {\n    return this.adapter;\n  }\n\n  /**\n   * Get database instance (not applicable for in-memory, returns null)\n   */\n  getDatabase(): any {\n    return null;\n  }\n\n  /**\n   * Clear all collections (useful for testing)\n   */\n  clearAll(): void {\n    this.eventsCollection.length = 0;\n    this.summaryCollection.length = 0;\n    this.stateCollection.length = 0;\n  }\n}\n\n// ==================== Document Converter ====================\n\n/**\n * Converts between IMemoryEvent and in-memory documents\n */\nexport class DocumentConverter {\n  /**\n   * Convert IMemoryEvent to in-memory document\n   */\n  toDocument(\n    event: IMemoryEvent,\n    sessionId: string,\n    branchPath: string\n  ): InMemoryDocument {\n    return {\n      sessionId,\n      messageId: event.message.id,\n      branchPath,\n      role: event.message.role,\n      content: event.message.content,\n      toolCalls: event.message.toolCalls,\n      toolCallId: event.message.toolCallId,\n      state: event.state || {},\n      createdAt: event.message.timestamp || new Date(),\n      updatedAt: new Date(),\n    };\n  }\n\n  /**\n   * Convert in-memory document to IMemoryEvent\n   */\n  fromDocument(doc: InMemoryDocument): IMemoryEvent {\n    return {\n      message: {\n        id: doc.messageId,\n        role: doc.role as \"user\" | \"assistant\" | \"system\" | \"tool\",\n        content: doc.content,\n        toolCalls: doc.toolCalls,\n        toolCallId: doc.toolCallId,\n        timestamp: doc.createdAt,\n      },\n      state: doc.state,\n    };\n  }\n}","/**\n * Generic State Manager\n *\n * Manages session state documents using database adapter\n */\n\nimport { ICollectionManager, BaseStateDocument, BranchMetadata } from \"./types\";\n\nexport class StateManager {\n  private stateCache: Map<string, BaseStateDocument> = new Map();\n  private branchesCache: Record<string, BranchMetadata> | null = null;\n\n  constructor(private collectionManager: ICollectionManager) {}\n\n  /**\n   * Get state document for a session\n   */\n  async getStateDocument(sessionId: string): Promise<BaseStateDocument | null> {\n    // Check cache first\n    if (this.stateCache.has(sessionId)) {\n      return this.stateCache.get(sessionId)!;\n    }\n\n    try {\n      const collection = this.collectionManager.getStateCollection();\n      const adapter = this.collectionManager.getAdapter();\n      \n      const state = await adapter.findOne(collection, { sessionId });\n      \n      if (state) {\n        this.stateCache.set(sessionId, state as BaseStateDocument);\n        return state as BaseStateDocument;\n      }\n\n      return null;\n    } catch (error) {\n      console.error(\"Error getting state document:\", error);\n      return null;\n    }\n  }\n\n  /**\n   * Update state document\n   */\n  async updateStateDocument(\n    sessionId: string,\n    updates: Partial<BaseStateDocument>\n  ): Promise<void> {\n    try {\n      const collection = this.collectionManager.getStateCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const existingState = await this.getStateDocument(sessionId);\n\n      if (existingState && existingState._id) {\n        // Update existing document\n        await adapter.updateOne(\n          collection,\n          { _id: existingState._id },\n          {\n            ...updates,\n            updatedAt: new Date(),\n          }\n        );\n\n        // Re-fetch from database to get the latest state\n        const updatedState = await adapter.findOne(collection, { sessionId });\n        if (updatedState) {\n          this.stateCache.set(sessionId, updatedState as BaseStateDocument);\n        }\n      } else {\n        // Create new document\n        const newState: Omit<BaseStateDocument, \"_id\"> = {\n          sessionId,\n          currentBranch: \"main\",\n          branches: {},\n          createdAt: new Date(),\n          updatedAt: new Date(),\n          ...updates,\n        };\n\n        const result = await adapter.insertOne(collection, newState);\n        this.stateCache.set(sessionId, result as BaseStateDocument);\n      }\n\n      // Clear branches cache when state is updated\n      this.branchesCache = null;\n    } catch (error) {\n      console.error(\"Error updating state document:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get current branch name\n   */\n  async getCurrentBranch(sessionId: string): Promise<string> {\n    const state = await this.getStateDocument(sessionId);\n    return state?.currentBranch || \"main\";\n  }\n\n  /**\n   * Save current branch\n   */\n  async saveCurrentBranch(\n    sessionId: string,\n    branchName: string\n  ): Promise<void> {\n    await this.updateStateDocument(sessionId, { currentBranch: branchName });\n  }\n\n  /**\n   * Get branches metadata\n   */\n  async getBranches(\n    sessionId: string\n  ): Promise<Record<string, BranchMetadata>> {\n    // Check cache first\n    if (this.branchesCache) {\n      return this.branchesCache;\n    }\n\n    const state = await this.getStateDocument(sessionId);\n\n    if (!state) {\n      // Initialize with main branch\n      const mainBranch: BranchMetadata = {\n        name: \"main\",\n        branchPath: \"main\",\n        createdAt: new Date(0), // Epoch time for main branch\n        snapshotTime: new Date(),\n      };\n\n      const branches = { main: mainBranch };\n      await this.updateStateDocument(sessionId, { branches });\n      this.branchesCache = branches;\n      return branches;\n    }\n\n    this.branchesCache = state.branches;\n    return state.branches;\n  }\n\n  /**\n   * Save branches metadata\n   */\n  async saveBranches(\n    sessionId: string,\n    branches: Record<string, BranchMetadata>\n  ): Promise<void> {\n    await this.updateStateDocument(sessionId, { branches });\n    this.branchesCache = branches;\n  }\n\n  /**\n   * Update branches cache without database update\n   * Used when branches are updated as part of a batch operation\n   */\n  updateBranchesCache(branches: Record<string, BranchMetadata>): void {\n    this.branchesCache = branches;\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(): void {\n    this.stateCache.clear();\n    this.branchesCache = null;\n  }\n}\n","/**\n * Generic Cursor Manager\n *\n * Manages soft delete cursors (timestamps) for sessions\n */\n\nimport { ICollectionManager, BaseMemoryDocument } from \"./types\";\nimport { StateManager } from \"./state-manager\";\n\nexport class CursorManager {\n  constructor(\n    private collectionManager: ICollectionManager,\n    private stateManager: StateManager\n  ) {}\n\n  /**\n   * Get start cursor (timestamp) for soft delete\n   */\n  async getStartCursor(sessionId: string): Promise<Date | undefined> {\n    const state = await this.stateManager.getStateDocument(sessionId);\n    return state?.startCursor;\n  }\n\n  /**\n   * Set start cursor (timestamp) for soft delete\n   */\n  async setStartCursor(sessionId: string, cursor: Date): Promise<void> {\n    await this.stateManager.updateStateDocument(sessionId, {\n      startCursor: cursor,\n    });\n  }\n\n  /**\n   * Get event document by message ID\n   * Used for getting event timestamp when needed\n   */\n  async getEventByMessageId(\n    sessionId: string,\n    messageId: string\n  ): Promise<BaseMemoryDocument | null> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n\n      const doc = await adapter.findOne(collection, { sessionId, messageId });\n      return doc as BaseMemoryDocument | null;\n    } catch (error) {\n      console.error(\"Error getting event by message ID:\", error);\n      return null;\n    }\n  }\n}\n","/**\n * Generic Summary Manager\n *\n * Manages summary operations using database adapter\n */\n\nimport { ICollectionManager, BaseSummaryDocument, BaseMemoryDocument } from \"./types\";\nimport { CursorManager } from \"./cursor-manager\";\n\nexport interface SummarizeParams {\n  sessionId?: string;\n  recentToKeep: number;\n}\n\nexport class SummaryManager {\n  constructor(\n    private sessionId: string,\n    private collectionManager: ICollectionManager,\n    private cursorManager: CursorManager\n  ) { }\n\n  /**\n   * Add a summary\n   */\n  async addSummary(\n    summaryId: string,\n    content: string,\n    metadata?: Record<string, any>,\n    sessionId?: string\n  ): Promise<void> {\n    try {\n      const collection = this.collectionManager.getSummaryCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = sessionId || this.sessionId;\n\n      const summary: Omit<BaseSummaryDocument, \"_id\"> = {\n        sessionId: sid,\n        summaryId,\n        content,\n        metadata,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      };\n\n      await adapter.insertOne(collection, summary);\n    } catch (error) {\n      console.error(\"Error adding summary to database:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all summaries for a session\n   */\n  async getSummaries(sessionId?: string): Promise<BaseSummaryDocument[]> {\n    try {\n      const collection = this.collectionManager.getSummaryCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = sessionId || this.sessionId;\n\n      const summaries = await adapter.find(\n        collection,\n        { sessionId: sid },\n        { sort: { createdAt: 1 } }\n      );\n\n      return summaries as BaseSummaryDocument[];\n    } catch (error) {\n      console.error(\"Error getting summaries from database:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clear old events by setting soft delete cursor\n   */\n  async clearSummarizedEvents(params: SummarizeParams): Promise<void> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = params.sessionId || this.sessionId;\n\n      // Get start cursor first\n      const currentCursor = await this.cursorManager.getStartCursor(sid);\n\n      let whereCondition: any = { sessionId: sid };\n\n      // If there's already a cursor, only query events after it\n      if (currentCursor) {\n        const queryBuilder = adapter.createQueryBuilder();\n        const cursorCondition = queryBuilder.where(\"createdAt\", \"gt\", currentCursor).build();\n        whereCondition = { ...whereCondition, ...cursorCondition };\n      }\n\n      // Get all visible events ordered by createdAt\n      const result = await adapter.find(\n        collection,\n        whereCondition,\n        { sort: { createdAt: 1 } }\n      );\n\n      // Calculate how many to \"delete\" (soft delete)\n      const totalEvents = result.length;\n      const eventsToDelete = totalEvents - params.recentToKeep;\n\n      if (eventsToDelete > 0) {\n        // Set cursor to the last event to be \"deleted\"\n        const lastDeletedEvent = result[\n          eventsToDelete - 1\n        ] as BaseMemoryDocument;\n        await this.cursorManager.setStartCursor(\n          sid,\n          lastDeletedEvent.createdAt\n        );\n      }\n    } catch (error) {\n      console.error(\"Error clearing summarized events from database:\", error);\n      throw error;\n    }\n  }\n}\n","/**\n * Generic Branch Manager\n *\n * Manages branch operations using database adapter\n */\n\nimport { ICollectionManager, BranchMetadata } from \"./types\";\nimport { StateManager } from \"./state-manager\";\nimport { CursorManager } from \"./cursor-manager\";\nimport { IMemoryEvent } from \"../memory-base\";\n\nexport class BranchManager {\n  constructor(\n    private collectionManager: ICollectionManager,\n    private stateManager: StateManager,\n    private cursorManager: CursorManager\n  ) { }\n\n  /**\n   * Get current branch path\n   */\n  async getCurrentBranchPath(sessionId: string): Promise<string> {\n    const currentBranch = await this.stateManager.getCurrentBranch(sessionId);\n    const branches = await this.stateManager.getBranches(sessionId);\n    return branches[currentBranch]?.branchPath || \"main\";\n  }\n\n  /**\n   * Build branch query conditions\n   */\n  async buildBranchConditions(\n    sessionId: string,\n    currentBranchPath: string\n  ): Promise<any[]> {\n    const adapter = this.collectionManager.getAdapter();\n    const branches = await this.stateManager.getBranches(sessionId);\n    const conditions: any[] = [];\n\n    // Get all ancestor branches\n    const pathParts = currentBranchPath.split(\"/\");\n    for (let i = 1; i <= pathParts.length; i++) {\n      const ancestorPath = pathParts.slice(0, i).join(\"/\");\n      const branch = Object.values(branches).find(\n        (b) => b.branchPath === ancestorPath\n      );\n\n      if (branch) {\n        const queryBuilder = adapter\n          .createQueryBuilder()\n          .where(\"sessionId\", \"eq\", sessionId)\n          .and(\"branchPath\", \"eq\", ancestorPath);\n\n        // Only include events created before this branch was created\n        if (i < pathParts.length) {\n          const childBranch = Object.values(branches).find(\n            (b) => b.branchPath === pathParts.slice(0, i + 1).join(\"/\")\n          );\n          if (childBranch) {\n            queryBuilder.and(\"createdAt\", \"lte\", childBranch.snapshotTime);\n          }\n        }\n\n        conditions.push(queryBuilder.build());\n      }\n    }\n\n    return conditions.length > 0\n      ? conditions\n      : [\n        adapter\n          .createQueryBuilder()\n          .where(\"sessionId\", \"eq\", sessionId)\n          .and(\"branchPath\", \"eq\", \"main\")\n          .build(),\n      ];\n  }\n\n  /**\n   * Apply cursor condition to branch conditions\n   */\n  applyCursorCondition(\n    conditions: any[],\n    cursorTime: Date\n  ): any[] {\n    const adapter = this.collectionManager.getAdapter();\n\n    return conditions.map((cond) => {\n      // Create a new query builder from existing condition\n      const builder = adapter.createQueryBuilder();\n\n      // Check if this is a complex query from our query builder\n      if (cond && cond.__typeorm_query__) {\n        // For complex queries, we need to combine the existing WHERE clause with the cursor condition\n        // Parse the existing WHERE clause and parameters\n        const existingWhere = cond.where;\n        const existingParams = cond.parameters;\n\n        // Create a new builder and manually set the conditions\n        // We'll wrap the existing WHERE in parentheses and add the cursor condition\n        const cursorParamName = `cursor_param_${Date.now()}`;\n        const combinedWhere = `(${existingWhere}) AND entity.createdAt > :${cursorParamName}`;\n        const combinedParams = { ...existingParams, [cursorParamName]: cursorTime };\n\n        return {\n          __typeorm_query__: true,\n          where: combinedWhere,\n          parameters: combinedParams,\n        };\n      } else {\n        // Add existing conditions for simple objects\n        Object.entries(cond).forEach(([field, value]) => {\n          if (field !== \"_id\") {\n            builder.where(field, \"eq\", value);\n          }\n        });\n\n        // Add cursor condition\n        builder.and(\"createdAt\", \"gt\", cursorTime);\n\n        return builder.build();\n      }\n    });\n  }\n\n  /**\n   * Create a new branch\n   */\n  async createBranch(\n    sessionId: string,\n    branchName: string,\n    fromEventId?: string,\n    listEvents?: () => Promise<IMemoryEvent[]>\n  ): Promise<string> {\n    const branches = await this.stateManager.getBranches(sessionId);\n\n    if (branches[branchName]) {\n      throw new Error(`Branch '${branchName}' already exists`);\n    }\n\n    // Get current branch info\n    const currentBranchName =\n      await this.stateManager.getCurrentBranch(sessionId);\n    const currentBranchPath = await this.getCurrentBranchPath(sessionId);\n\n    // Construct new branch path\n    const newBranchPath = `${currentBranchPath}/${branchName}`;\n\n    // Get snapshot time\n    let snapshotTime: Date;\n    if (fromEventId) {\n      const fromEvent = await this.cursorManager.getEventByMessageId(\n        sessionId,\n        fromEventId\n      );\n      if (!fromEvent) {\n        throw new Error(`Event '${fromEventId}' not found`);\n      }\n      snapshotTime = fromEvent.createdAt;\n    } else {\n      // Use the last event's time in current branch\n      if (listEvents) {\n        const events = await listEvents();\n        if (events.length > 0) {\n          const lastEvent = events[events.length - 1];\n          const lastDoc = await this.cursorManager.getEventByMessageId(\n            sessionId,\n            lastEvent.message.id\n          );\n          snapshotTime = lastDoc ? lastDoc.createdAt : new Date();\n        } else {\n          // No events, use current time\n          snapshotTime = new Date();\n        }\n      } else {\n        snapshotTime = new Date();\n      }\n    }\n\n    // Get current cursor (timestamp) to save with branch\n    const currentCursor = await this.cursorManager.getStartCursor(sessionId);\n\n    // Create new branch metadata\n    branches[branchName] = {\n      name: branchName,\n      parentBranch: currentBranchName,\n      branchPath: newBranchPath,\n      createdAt: new Date(),\n      fromEventId,\n      snapshotTime,\n      startCursor: currentCursor,\n    };\n\n    await this.stateManager.saveBranches(sessionId, branches);\n\n    return branchName;\n  }\n\n  /**\n   * Switch to a different branch\n   */\n  async checkoutBranch(sessionId: string, branchName: string): Promise<void> {\n    const branches = await this.stateManager.getBranches(sessionId);\n    const branch = branches[branchName];\n\n    if (!branch) {\n      throw new Error(`Branch '${branchName}' does not exist`);\n    }\n\n    // Save current branch's cursor (timestamp) before switching\n    const currentBranchName =\n      await this.stateManager.getCurrentBranch(sessionId);\n    const currentCursor = await this.cursorManager.getStartCursor(sessionId);\n\n    if (branches[currentBranchName]) {\n      branches[currentBranchName].startCursor = currentCursor;\n    }\n\n    // Batch update: branches + currentBranch + startCursor in one operation\n    const updates: any = {\n      branches,\n      currentBranch: branchName,\n    };\n\n    // Set startCursor - use branch's cursor or undefined for new branches\n    if (branch.startCursor !== undefined) {\n      updates.startCursor = branch.startCursor;\n    } else {\n      updates.startCursor = undefined;\n    }\n\n    await this.stateManager.updateStateDocument(sessionId, updates);\n\n    // Update branches cache\n    this.stateManager.updateBranchesCache(branches);\n  }\n\n  /**\n   * Checkout to a specific event, deleting all events after it\n   */\n  async checkoutToEvent(sessionId: string, eventId: string): Promise<void> {\n    const collection = this.collectionManager.getCollection();\n    const event = await this.cursorManager.getEventByMessageId(sessionId, eventId);\n    const adapter = this.collectionManager.getAdapter();\n\n    if (!event) {\n      throw new Error(`Event '${eventId}' not found in session '${sessionId}'`);\n    }\n\n    const currentBranchPath =\n      await this.getCurrentBranchPath(sessionId);\n\n    // Build branch conditions\n    let conditions = await this.buildBranchConditions(\n      sessionId,\n      currentBranchPath\n    );\n\n    conditions = this.applyCursorCondition(\n      conditions,\n      event.createdAt\n    );\n\n    let whereCondition: any;\n    if (conditions.length > 1) {\n      const orBuilder = adapter.createQueryBuilder();\n      const conditionBuilders = conditions.map((cond: any) => {\n        const builder = adapter.createQueryBuilder();\n        Object.entries(cond).forEach(([field, value]) => {\n          builder.where(field, \"eq\", value);\n        });\n        return builder;\n      });\n      whereCondition = orBuilder.or(conditionBuilders).build();\n    } else {\n      whereCondition = conditions[0];\n    }\n\n    await adapter.deleteMany(collection, whereCondition);\n  }\n\n  /**\n   * Detect whether target is a branch name or event ID\n   */\n  async detectCheckoutType(\n    sessionId: string,\n    target: string\n  ): Promise<\"branch\" | \"event\"> {\n    const branches = await this.stateManager.getBranches(sessionId);\n    return branches[target] ? \"branch\" : \"event\";\n  }\n\n  /**\n   * Delete a branch\n   */\n  async deleteBranch(sessionId: string, branchName: string): Promise<void> {\n    if (branchName === \"main\") {\n      throw new Error(\"Cannot delete main branch\");\n    }\n\n    const currentBranch = await this.stateManager.getCurrentBranch(sessionId);\n    if (currentBranch === branchName) {\n      throw new Error(\n        \"Cannot delete current branch. Switch to another branch first.\"\n      );\n    }\n\n    const branches = await this.stateManager.getBranches(sessionId);\n    if (!branches[branchName]) {\n      throw new Error(`Branch '${branchName}' does not exist`);\n    }\n\n    delete branches[branchName];\n    await this.stateManager.saveBranches(sessionId, branches);\n  }\n\n  /**\n   * List all branches\n   */\n  async listBranches(\n    sessionId: string\n  ): Promise<Array<BranchMetadata & { isActive: boolean }>> {\n    const branches = await this.stateManager.getBranches(sessionId);\n    const currentBranch = await this.stateManager.getCurrentBranch(sessionId);\n\n    return Object.values(branches).map((branch) => ({\n      ...branch,\n      isActive: branch.name === currentBranch,\n    }));\n  }\n\n  /**\n   * Get current branch name\n   */\n  async getCurrentBranch(sessionId: string): Promise<string> {\n    return this.stateManager.getCurrentBranch(sessionId);\n  }\n\n  /**\n   * Clean up branches, keeping only specified branches and the current active branch\n   * @param sessionId - Session identifier\n   * @param keepBranches - Optional list of branch names to keep (in addition to active branch)\n   */\n  async cleanupBranches(sessionId: string, keepBranches: string[] = []): Promise<void> {\n    const branches = await this.stateManager.getBranches(sessionId);\n    const currentBranch = await this.stateManager.getCurrentBranch(sessionId);\n\n    // Always keep main branch and current branch\n    const branchesToKeep = new Set([\n      \"main\",\n      currentBranch,\n      ...keepBranches\n    ]);\n\n    // Find branches to delete\n    const branchesToDelete = Object.keys(branches).filter(\n      branchName => !branchesToKeep.has(branchName)\n    );\n\n    // Delete each branch\n    for (const branchName of branchesToDelete) {\n      delete branches[branchName];\n    }\n\n    // Save updated branches\n    await this.stateManager.saveBranches(sessionId, branches);\n  }\n}\n","/**\n * @fileoverview In-memory implementation using unified adapter architecture\n *\n * In-memory Memory implementation providing volatile storage using\n * JavaScript arrays with support for CRUD operations, session management,\n * branch isolation, and soft delete using cursor-based approach.\n *\n * @example\n * ```typescript\n * const memory = new InMemoryMemory({\n *   sessionId: 'user-session-123'\n * });\n *\n * await memory.add({\n *   message: { id: '1', role: 'user', content: 'Hello' },\n *   state: { userId: 'user123' }\n * });\n *\n * const events = await memory.list({ limit: 10 });\n * ```\n */\n\nimport {\n  BaseMemory,\n  IMemoryEvent,\n  ListOptions,\n  AddOptions,\n  DeleteOptions,\n  RetrieveOptions,\n  ClearOptions,\n  StructuredSummary,\n  BranchInfo,\n  Message,\n  TInputMemoryEvent,\n} from \"../memory-base\";\n\nimport { InMemoryDocument } from \"./types\";\nimport { CollectionManager, DocumentConverter } from \"./utils\";\nimport { StateManager } from \"../common/state-manager\";\nimport { CursorManager } from \"../common/cursor-manager\";\nimport { SummaryManager } from \"../common/summary-manager\";\nimport { BranchManager } from \"../common/branch-manager\";\n\n/**\n * In-Memory Memory implementation using unified adapter architecture\n *\n * Provides volatile storage using JavaScript arrays with support for\n * session-based memory management, CRUD operations, branch isolation, optional context engineering,\n * and efficient soft delete using cursor-based approach.\n */\nexport class InMemoryMemory extends BaseMemory {\n  /** Session identifier for memory isolation */\n  public sessionId: string;\n  /** Whether to enable automatic context management */\n  private enableContextManagement: boolean;\n\n  // Core utilities\n  private collectionManager: CollectionManager;\n  private documentConverter: DocumentConverter;\n\n  // Managers\n  private stateManager: StateManager;\n  private cursorManager: CursorManager;\n  private branchManager: BranchManager;\n  private summaryManager: SummaryManager;\n\n  /**\n   * Creates a new InMemoryMemory instance\n   * @param options - Configuration options\n   * @param options.sessionId - Unique session identifier (default: 'default')\n   * @param options.enableContextManagement - Whether to automatically manage context (default: true if thresholds provided)\n   */\n  constructor(\n    options: {\n      sessionId?: string;\n      enableContextManagement?: boolean;\n    } & ConstructorParameters<typeof BaseMemory>[0] = {}\n  ) {\n    super(options);\n\n    this.sessionId = options.sessionId || \"default\";\n    this.enableContextManagement =\n      options.enableContextManagement ?? (options.thresholds ? true : false);\n\n    // Initialize core utilities\n    this.collectionManager = new CollectionManager();\n    this.documentConverter = new DocumentConverter();\n\n    // Initialize managers\n    this.stateManager = new StateManager(this.collectionManager);\n    this.cursorManager = new CursorManager(\n      this.collectionManager,\n      this.stateManager\n    );\n    this.branchManager = new BranchManager(\n      this.collectionManager,\n      this.stateManager,\n      this.cursorManager\n    );\n    this.summaryManager = new SummaryManager(\n      this.sessionId,\n      this.collectionManager,\n      this.cursorManager\n    );\n  }\n\n  // ==================== CRUD Operations ====================\n\n  /**\n   * Returns events from in-memory storage with filtering, pagination, and token limiting\n   * Respects branch isolation using branch path and snapshot time\n   * @param options - Optional filtering and pagination options\n   * @returns Promise resolving to filtered array of memory events\n   */\n  public async list(options?: ListOptions): Promise<IMemoryEvent[]> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      // Get current branch path\n      const currentBranchPath =\n        await this.branchManager.getCurrentBranchPath(sid);\n\n      // Build branch conditions using adapter\n      const branchConditions = await this.branchManager.buildBranchConditions(\n        sid,\n        currentBranchPath\n      );\n\n      // Apply soft delete cursor\n      const startCursor = await this.cursorManager.getStartCursor(sid);\n      let conditions = branchConditions;\n\n      if (startCursor) {\n        conditions = this.branchManager.applyCursorCondition(\n          conditions,\n          startCursor\n        );\n      }\n\n      // Execute query with OR conditions using adapter\n      let whereCondition: (doc: any) => boolean;\n      if (conditions.length > 1) {\n        whereCondition = (doc: any) => {\n          return conditions.some((cond) => {\n            if (typeof cond === \"function\") {\n              return cond(doc);\n            }\n            // Convert object condition to function\n            return Object.entries(cond).every(([field, value]) => {\n              const docValue = field\n                .split(\".\")\n                .reduce((obj, key) => obj?.[key], doc);\n              if (\n                value &&\n                typeof value === \"object\" &&\n                !Array.isArray(value) &&\n                !(value instanceof Date)\n              ) {\n                return Object.entries(value).every(([op, opValue]) => {\n                  switch (op) {\n                    case \"$gt\":\n                      return docValue > opValue;\n                    case \"$gte\":\n                      return docValue >= opValue;\n                    case \"$lt\":\n                      return docValue < opValue;\n                    case \"$lte\":\n                      return docValue <= opValue;\n                    case \"$ne\":\n                    case \"$neq\":\n                      return docValue !== opValue;\n                    default:\n                      return docValue === opValue;\n                  }\n                });\n              }\n              return docValue === value;\n            });\n          });\n        };\n      } else {\n        const cond = conditions[0];\n        if (typeof cond === \"function\") {\n          whereCondition = cond;\n        } else {\n          whereCondition = (doc: any) => {\n            return Object.entries(cond).every(([field, value]) => {\n              const docValue = field\n                .split(\".\")\n                .reduce((obj, key) => obj?.[key], doc);\n              if (\n                value &&\n                typeof value === \"object\" &&\n                !Array.isArray(value) &&\n                !(value instanceof Date)\n              ) {\n                return Object.entries(value).every(([op, opValue]) => {\n                  switch (op) {\n                    case \"$gt\":\n                      return docValue > opValue;\n                    case \"$gte\":\n                      return docValue >= opValue;\n                    case \"$lt\":\n                      return docValue < opValue;\n                    case \"$lte\":\n                      return docValue <= opValue;\n                    case \"$ne\":\n                    case \"$neq\":\n                      return docValue !== opValue;\n                    default:\n                      return docValue === opValue;\n                  }\n                });\n              }\n              return docValue === value;\n            });\n          };\n        }\n      }\n\n      // Apply ordering\n      const order = options?.order || \"asc\";\n      const queryOptions: any = {\n        sort: { createdAt: order === \"asc\" ? 1 : -1 },\n      };\n\n      if (options?.offset) {\n        queryOptions.skip = options.offset;\n      }\n      if (options?.limit) {\n        queryOptions.limit = options.limit;\n      }\n\n      // Execute query using adapter\n      const result = await adapter.find<InMemoryDocument>(\n        collection,\n        whereCondition,\n        queryOptions\n      );\n\n      // Convert documents to events\n      return (order === \"desc\" ? result.reverse() : result).map(\n        (doc: InMemoryDocument) => this.documentConverter.fromDocument(doc)\n      );\n    } catch (error) {\n      console.error(\"Error listing events from in-memory storage:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Adds a new event to in-memory storage\n   * @param event - The memory event to add\n   * @param options - Optional session and branch options\n   */\n  public async add(\n    event: TInputMemoryEvent,\n    options?: AddOptions\n  ): Promise<void> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      // Get current branch path\n      const currentBranchPath =\n        await this.branchManager.getCurrentBranchPath(sid);\n\n      // Convert event to document\n      const document = this.documentConverter.toDocument(\n        event as IMemoryEvent,\n        sid,\n        currentBranchPath\n      );\n\n      // Insert document using adapter\n      await adapter.insertOne(collection, document);\n\n      // Handle context management if enabled\n      if (this.enableContextManagement && this.thresholds) {\n        const events = await this.list({ sessionId: sid });\n        await this.manageContext({ sessionId: sid, events });\n      }\n    } catch (error) {\n      console.error(\"Error adding event to in-memory storage:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Adds multiple events to in-memory storage\n   * @param list - Array of memory events to add\n   * @param options - Optional session and branch options\n   */\n  public async addList(\n    list: TInputMemoryEvent[],\n    options?: AddOptions\n  ): Promise<void> {\n    try {\n      for (const event of list) {\n        await this.add(event, options);\n      }\n    } finally {\n      // Context management is handled in individual add() calls\n    }\n  }\n\n  /**\n   * Update an existing event in memory storage\n   * @param params - Update parameters including session ID and event\n   */\n  public async update(params: {\n    sessionId: string;\n    event: Partial<IMemoryEvent> & { message: { id: string } };\n  }): Promise<void> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n\n      // Find and update the document\n      const updateBuilder = adapter.createUpdateBuilder();\n\n      [\"role\", \"content\", \"toolCalls\", \"toolCallId\", \"state\"].forEach((key) => {\n        if ((params.event.message as any)[key]) {\n          updateBuilder.set(key, (params.event.message as any)[key]);\n        }\n      });\n\n      if (params.event.state) {\n        updateBuilder.set(\"state\", params.event.state);\n      }\n      updateBuilder.set(\"updatedAt\", new Date());\n\n      const query = adapter\n        .createQueryBuilder()\n        .where(\"sessionId\", \"eq\", params.sessionId)\n        .and(\"messageId\", \"eq\", params.event.message.id)\n        .build();\n\n      await adapter.updateOne(collection, query, updateBuilder.build());\n    } catch (error) {\n      console.error(\"Error updating event in in-memory storage:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Deletes an event from in-memory storage by message ID or event object\n   * @param params - Delete parameters including event reference or message ID\n   */\n  public async delete(\n    params:\n      | {\n          event: IMemoryEvent;\n          sessionId?: string;\n        }\n      | string\n      | number,\n    options?: { sessionId?: string }\n  ): Promise<void> {\n    // Handle backward compatibility with old API\n    if (typeof params === \"string\" || typeof params === \"number\") {\n      return this.deleteByIdOrIndex(params, options);\n    }\n\n    // New API with event object\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = params.sessionId || this.sessionId;\n\n      const query = adapter\n        .createQueryBuilder()\n        .where(\"sessionId\", \"eq\", sid)\n        .and(\"messageId\", \"eq\", params.event.message.id)\n        .build();\n\n      await adapter.deleteOne(collection, query);\n    } catch (error) {\n      console.error(\"Error deleting event from in-memory storage:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Deletes an event by ID or index\n   * @param idOrIndex - Event message ID or array index\n   * @param options - Optional session options\n   */\n  public async deleteByIdOrIndex(\n    idOrIndex: string | number,\n    options?: DeleteOptions | { sessionId?: string }\n  ): Promise<void> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      if (typeof idOrIndex === \"string\") {\n        // Delete by message ID\n        const query = adapter\n          .createQueryBuilder()\n          .where(\"sessionId\", \"eq\", sid)\n          .and(\"messageId\", \"eq\", idOrIndex)\n          .build();\n\n        await adapter.deleteOne(collection, query);\n      } else {\n        // Delete by index - get all events first, then delete the specific one\n        const events = await this.list({ sessionId: sid });\n        if (idOrIndex >= 0 && idOrIndex < events.length) {\n          const eventToDelete = events[idOrIndex];\n          await this.delete({ event: eventToDelete, sessionId: sid });\n        }\n      }\n    } catch (error) {\n      console.error(\n        \"Error deleting event by ID/index from in-memory storage:\",\n        error\n      );\n      throw error;\n    }\n  }\n\n  /**\n   * Clears events from in-memory storage\n   * @param options - Optional session-specific clearing\n   */\n  public async clear(options?: ClearOptions): Promise<void> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const stateCollection = this.collectionManager.getStateCollection();\n      const summaryCollection = this.collectionManager.getSummaryCollection();\n      const adapter = this.collectionManager.getAdapter();\n\n      if (options?.sessionId) {\n        // Clear specific session - use soft delete by setting cursor to last event\n        const sid = options.sessionId;\n\n        // Get the last event in the session\n        const result = await adapter.find<InMemoryDocument>(\n          collection,\n          { sessionId: sid },\n          { sort: { createdAt: -1 }, limit: 1 }\n        );\n\n        if (result.length > 0) {\n          const lastEvent = result[0];\n          // Set cursor to the last event's timestamp, effectively hiding all events\n          await this.cursorManager.setStartCursor(sid, lastEvent.createdAt);\n        }\n\n        // Clear summaries for this session\n        await adapter.deleteMany(summaryCollection, { sessionId: sid });\n      } else {\n        // Clear all sessions - hard delete\n        await adapter.deleteMany(collection, {});\n        await adapter.deleteMany(stateCollection, {});\n        await adapter.deleteMany(summaryCollection, {});\n      }\n\n      // Clear cache\n      this.stateManager.clearCache();\n    } catch (error) {\n      console.error(\"Error clearing events from in-memory storage:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Gets the count of events in in-memory storage\n   * @param options - Optional session filtering\n   * @returns Promise resolving to the count of events\n   */\n  public async getCount(options?: { sessionId?: string }): Promise<number> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      // Get current branch path\n      const currentBranchPath =\n        await this.branchManager.getCurrentBranchPath(sid);\n\n      // Build branch conditions\n      const branchConditions = await this.branchManager.buildBranchConditions(\n        sid,\n        currentBranchPath\n      );\n\n      // Apply soft delete cursor\n      const startCursor = await this.cursorManager.getStartCursor(sid);\n      let conditions = branchConditions;\n\n      if (startCursor) {\n        conditions = this.branchManager.applyCursorCondition(\n          conditions,\n          startCursor\n        );\n      }\n\n      // Execute count query using adapter\n      let whereCondition: (doc: any) => boolean;\n      if (conditions.length > 1) {\n        whereCondition = (doc: any) => {\n          return conditions.some((cond) => {\n            if (typeof cond === \"function\") {\n              return cond(doc);\n            }\n            return Object.entries(cond).every(([field, value]) => {\n              const docValue = field\n                .split(\".\")\n                .reduce((obj, key) => obj?.[key], doc);\n              return docValue === value;\n            });\n          });\n        };\n      } else {\n        const cond = conditions[0];\n        if (typeof cond === \"function\") {\n          whereCondition = cond;\n        } else {\n          whereCondition = (doc: any) => {\n            return Object.entries(cond).every(([field, value]) => {\n              const docValue = field\n                .split(\".\")\n                .reduce((obj, key) => obj?.[key], doc);\n              return docValue === value;\n            });\n          };\n        }\n      }\n\n      const count = await adapter.count(collection, whereCondition);\n      return count;\n    } catch (error) {\n      console.error(\"Error getting count from in-memory storage:\", error);\n      return 0;\n    }\n  }\n\n  // ==================== Search Operations ====================\n\n  /**\n   * Retrieve events using content-based search\n   * @param query - Search query text to match against message content\n   * @param options - Optional search and session options\n   * @returns Promise resolving to array of matching memory events\n   */\n  public async retrieve(\n    query: string,\n    options?: RetrieveOptions\n  ): Promise<IMemoryEvent[]> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      // Get current branch path\n      const currentBranchPath =\n        await this.branchManager.getCurrentBranchPath(sid);\n\n      // Build base conditions\n      const branchConditions = await this.branchManager.buildBranchConditions(\n        sid,\n        currentBranchPath\n      );\n\n      // Apply soft delete cursor\n      const startCursor = await this.cursorManager.getStartCursor(sid);\n      let conditions = branchConditions;\n\n      if (startCursor) {\n        conditions = this.branchManager.applyCursorCondition(\n          conditions,\n          startCursor\n        );\n      }\n\n      // Add content search condition\n      const searchCondition = (doc: any) => {\n        // Check if document matches branch conditions\n        const matchesBranch = conditions.some((cond) => {\n          if (typeof cond === \"function\") {\n            return cond(doc);\n          }\n          return Object.entries(cond).every(([field, value]) => {\n            const docValue = field\n              .split(\".\")\n              .reduce((obj, key) => obj?.[key], doc);\n            return docValue === value;\n          });\n        });\n\n        if (!matchesBranch) return false;\n\n        // Check content match\n        const content = doc.content || \"\";\n        return content.toLowerCase().includes(query.toLowerCase());\n      };\n\n      const result = await adapter.find<InMemoryDocument>(\n        collection,\n        searchCondition\n      );\n\n      return result.map((doc: InMemoryDocument) =>\n        this.documentConverter.fromDocument(doc)\n      );\n    } catch (error) {\n      console.error(\"Error retrieving events from in-memory storage:\", error);\n      throw error;\n    }\n  }\n\n  // ==================== Summary Operations ====================\n\n  /**\n   * Get summaries for a session\n   * @param sessionId - Optional session identifier\n   * @returns Array of structured summaries\n   */\n  public async getSummaries(sessionId?: string): Promise<StructuredSummary[]> {\n    const summaries = await this.summaryManager.getSummaries(sessionId);\n\n    // Convert BaseSummaryDocument to StructuredSummary\n    return summaries.map((doc) => ({\n      content: doc.content,\n      count: 1, // Default count since BaseSummaryDocument doesn't have count\n      timeRange: {\n        start: doc.metadata?.timeRangeStart,\n        end: doc.metadata?.timeRangeEnd,\n      },\n      timestamp: doc.createdAt,\n    }));\n  }\n\n  /**\n   * Store summary implementation\n   * @param params - Summary storage parameters\n   */\n  protected async storeSummary(params: {\n    sessionId?: string;\n    summary: StructuredSummary;\n  }): Promise<void> {\n    const summaryId = `summary_${Date.now()}`;\n    const metadata = {\n      count: params.summary.count,\n      timeRangeStart: params.summary.timeRange.start,\n      timeRangeEnd: params.summary.timeRange.end,\n    };\n\n    return this.summaryManager.addSummary(\n      summaryId,\n      params.summary.content,\n      metadata,\n      params.sessionId\n    );\n  }\n\n  /**\n   * Clear summarized events implementation using soft delete\n   * Sets cursor to hide old events without actually deleting them\n   * @param params - Clear parameters\n   */\n  protected async clearSummarizedEvents(params: {\n    sessionId?: string;\n    recentToKeep: number;\n  }): Promise<void> {\n    return this.summaryManager.clearSummarizedEvents({\n      sessionId: params.sessionId,\n      recentToKeep: params.recentToKeep,\n    });\n  }\n\n  // ==================== Branch Operations ====================\n\n  /**\n   * Create a new branch from the current state\n   * @param branchName - Name of the new branch\n   * @param fromEventId - Optional event ID to branch from\n   * @returns Promise resolving to the branch name\n   */\n  public async branch(\n    branchName: string,\n    fromEventId?: string\n  ): Promise<string> {\n    return this.branchManager.createBranch(\n      this.sessionId,\n      branchName,\n      fromEventId,\n      () => this.list({ sessionId: this.sessionId })\n    );\n  }\n\n  /**\n   * Switch to a different branch or checkout to a specific event\n   * @param target - Branch name or event ID\n   * @param options - Optional checkout options\n   */\n  public async checkout(\n    target: string,\n    options?: { type?: \"branch\" | \"event\"; sessionId?: string }\n  ): Promise<void> {\n    const checkoutType =\n      options?.type ||\n      (await this.branchManager.detectCheckoutType(\n        options?.sessionId || this.sessionId,\n        target\n      ));\n\n    const sessionId = options?.sessionId || this.sessionId;\n\n    if (checkoutType === \"event\") {\n      const collection = this.collectionManager.getCollection();\n      const event = await this.cursorManager.getEventByMessageId(\n        sessionId,\n        target\n      );\n      const adapter = this.collectionManager.getAdapter();\n\n      if (!event) {\n        throw new Error(`Event '${target}' not found`);\n      }\n\n      // Get current branch path\n      const currentBranchPath =\n        await this.branchManager.getCurrentBranchPath(sessionId);\n\n      // Build branch conditions\n      let conditions = await this.branchManager.buildBranchConditions(\n        sessionId,\n        currentBranchPath\n      );\n\n      conditions = this.branchManager.applyCursorCondition(\n        conditions,\n        event.createdAt\n      );\n\n      const whereCondition = (doc: any) => {\n        return conditions.some((cond) => {\n          if (typeof cond === \"function\") {\n            return cond(doc);\n          }\n          return Object.entries(cond).every(([field, value]) => {\n            const docValue = field\n              .split(\".\")\n              .reduce((obj, key) => obj?.[key], doc);\n            return docValue === value;\n          });\n        });\n      };\n\n      await adapter.deleteMany(collection, whereCondition);\n    } else {\n      await this.branchManager.checkoutBranch(sessionId, target);\n    }\n  }\n\n  /**\n   * Delete a branch\n   * @param branchName - Name of the branch to delete\n   */\n  public async deleteBranch(branchName: string): Promise<void> {\n    return this.branchManager.deleteBranch(this.sessionId, branchName);\n  }\n\n  /**\n   * List all branches for the current session\n   * @returns Promise resolving to array of branch information\n   */\n  public async listBranches(): Promise<BranchInfo[]> {\n    const branches = await this.branchManager.listBranches(this.sessionId);\n\n    // Calculate event count for each branch\n    const branchInfos: BranchInfo[] = [];\n    for (const branch of branches) {\n      branchInfos.push({\n        name: branch.name,\n        isActive: branch.isActive,\n        createdAt: branch.createdAt,\n        fromEventId: branch.fromEventId,\n      });\n    }\n\n    return branchInfos;\n  }\n\n  /**\n   * Get current branch name\n   * @returns Promise resolving to current branch name\n   */\n  public async getCurrentBranch(): Promise<string> {\n    return this.branchManager.getCurrentBranch(this.sessionId);\n  }\n\n  /**\n   * Clean up branches, keeping only specified branches and the current active branch\n   * @param keepBranches - Optional list of branch names to keep (in addition to active branch)\n   */\n  public async cleanupBranches(keepBranches?: string[]): Promise<void> {\n    return this.branchManager.cleanupBranches(this.sessionId, keepBranches);\n  }\n\n  // ==================== Utility Methods ====================\n\n  /**\n   * Clear all collections (useful for testing)\n   */\n  public clearAll(): void {\n    this.collectionManager.clearAll();\n    this.stateManager.clearCache();\n  }\n\n  /**\n   * Check if the memory storage is empty\n   * @param options - Optional session options\n   * @returns Promise resolving to true if no events are stored\n   */\n  public async isEmpty(options?: { sessionId?: string }): Promise<boolean> {\n    const count = await this.getCount(options);\n    return count === 0;\n  }\n\n  /**\n   * Get all session IDs currently stored in memory\n   * @returns Array of session identifiers\n   */\n  public getSessionIds(): string[] {\n    const collection = this.collectionManager.getCollection();\n    const sessionIds = new Set<string>();\n\n    for (const doc of collection) {\n      sessionIds.add(doc.sessionId);\n    }\n\n    return Array.from(sessionIds);\n  }\n\n  /**\n   * Check if a specific session exists\n   * @param sessionId - The session identifier to check\n   * @returns True if the session exists\n   */\n  public hasSession(sessionId: string): boolean {\n    return this.getSessionIds().includes(sessionId);\n  }\n\n  /**\n   * Get raw session events (for testing purposes)\n   * @param sessionId - The session identifier\n   * @returns Array of raw events without decompression\n   */\n  public getSessionEvents(sessionId: string): IMemoryEvent[] {\n    const collection = this.collectionManager.getCollection();\n    const rawEvents = collection\n      .filter((doc) => doc.sessionId === sessionId)\n      .map((doc) => this.documentConverter.fromDocument(doc))\n      .sort((a, b) => {\n        const aTime = a.message.timestamp?.getTime() || 0;\n        const bTime = b.message.timestamp?.getTime() || 0;\n        return bTime - aTime;\n      });\n\n    return rawEvents;\n  }\n}\n","/**\n * Type validation utilities for enhanced type safety\n */\n\nimport { z } from \"zod/v4\";\nimport { StateConstraint, OutputConstraint } from \"./types\";\n\n// Type guard functions\nexport function isStateConstraint(value: unknown): value is StateConstraint {\n  return typeof value === 'object' && value !== null && !Array.isArray(value);\n}\n\nexport function isOutputConstraint(value: unknown): value is OutputConstraint {\n  return (\n    typeof value === 'string' ||\n    (typeof value === 'object' && value !== null) ||\n    Array.isArray(value)\n  );\n}\n\n// Enhanced type validation schemas\nexport const StateConstraintSchema = z.record(z.string(), z.unknown());\nexport const OutputConstraintSchema = z.union([\n  z.string(),\n  z.record(z.string(), z.unknown()),\n  z.array(z.unknown())\n]);\n\n// Type-safe state validation\nexport function validateState<T extends StateConstraint>(\n  value: unknown,\n  schema?: z.ZodSchema<T>\n): T {\n  if (!isStateConstraint(value)) {\n    throw new Error('Value is not a valid state constraint');\n  }\n  \n  if (schema) {\n    return schema.parse(value);\n  }\n  \n  return value as T;\n}\n\n// Type-safe output validation\nexport function validateOutput<T extends OutputConstraint>(\n  value: unknown,\n  schema?: z.ZodSchema<T>\n): T {\n  if (!isOutputConstraint(value)) {\n    throw new Error('Value is not a valid output constraint');\n  }\n  \n  if (schema) {\n    return schema.parse(value);\n  }\n  \n  return value as T;\n}\n\n// Runtime type checking utilities\nexport class TypeChecker {\n  private static instance: TypeChecker;\n  \n  static getInstance(): TypeChecker {\n    if (!TypeChecker.instance) {\n      TypeChecker.instance = new TypeChecker();\n    }\n    return TypeChecker.instance;\n  }\n  \n  // Check if a value matches a specific type at runtime\n  checkType<T>(value: unknown, typeName: string): value is T {\n    switch (typeName) {\n      case 'string':\n        return typeof value === 'string';\n      case 'number':\n        return typeof value === 'number';\n      case 'boolean':\n        return typeof value === 'boolean';\n      case 'object':\n        return typeof value === 'object' && value !== null;\n      case 'array':\n        return Array.isArray(value);\n      case 'function':\n        return typeof value === 'function';\n      default:\n        return false;\n    }\n  }\n  \n  // Validate object structure\n  validateObjectStructure(\n    obj: unknown,\n    requiredKeys: string[],\n    optionalKeys: string[] = []\n  ): obj is Record<string, unknown> {\n    if (!isStateConstraint(obj)) {\n      return false;\n    }\n    \n    const keys = Object.keys(obj);\n    \n    // Check required keys\n    for (const key of requiredKeys) {\n      if (!keys.includes(key)) {\n        return false;\n      }\n    }\n    \n    // Check that all keys are either required or optional\n    for (const key of keys) {\n      if (!requiredKeys.includes(key) && !optionalKeys.includes(key)) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n  \n  // Deep type validation\n  validateDeepType(value: unknown, expectedType: string): boolean {\n    try {\n      switch (expectedType) {\n        case 'StateConstraint':\n          return isStateConstraint(value);\n        case 'OutputConstraint':\n          return isOutputConstraint(value);\n        default:\n          return this.checkType(value, expectedType);\n      }\n    } catch {\n      return false;\n    }\n  }\n}\n\n// Type-safe factory functions\nexport function createTypeSafeState<T extends StateConstraint>(\n  initialState: T\n): T {\n  if (!isStateConstraint(initialState)) {\n    throw new Error('Initial state must be a valid state constraint');\n  }\n  return initialState;\n}\n\nexport function createTypeSafeOutput<T extends OutputConstraint>(\n  output: T\n): T {\n  if (!isOutputConstraint(output)) {\n    throw new Error('Output must be a valid output constraint');\n  }\n  return output;\n}\n\n// Generic type validation decorator\nexport function validateTypes<T extends StateConstraint, U extends OutputConstraint>(\n  stateSchema?: z.ZodSchema<T>,\n  outputSchema?: z.ZodSchema<U>\n) {\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n    \n    descriptor.value = function (...args: any[]) {\n      // Validate state if provided\n      if (stateSchema && args.length > 0) {\n        const stateArg = args[0];\n        if (stateArg !== undefined && stateArg !== null) {\n          validateState(stateArg, stateSchema);\n        }\n      }\n      \n      // Call original method\n      const result = originalMethod.apply(this, args);\n      \n      // Validate output if provided and result is a promise\n      if (outputSchema && result instanceof Promise) {\n        return result.then((output) => {\n          if (output !== undefined && output !== null) {\n            return validateOutput(output, outputSchema);\n          }\n          return output;\n        });\n      } else if (outputSchema && result !== undefined && result !== null) {\n        return validateOutput(result, outputSchema);\n      }\n      \n      return result;\n    };\n    \n    return descriptor;\n  };\n}\n\n// Export singleton instance\nexport const typeChecker = TypeChecker.getInstance();\n","/**\n * AG-Kit Core Agent Module\n * \n * This module provides the core agent functionality including:\n * - Agent class and configuration\n * - Type definitions and constraints\n * - Event system and error handling\n * - Model providers and validation\n */\n\n// Core Agent\nexport { Agent } from './agent';\n\n// Types and validation\nexport * from './types';\nexport * from './type-validation';\n\n// Event system\nexport * from './events';\nexport { OptimizedEventSystem, createOptimizedEventSystem, optimizedEventSystem } from './optimized-events';\n\n// Model providers - selective exports to avoid conflicts\nexport {\n  BaseModelProvider,\n  ModelProviderRegistry,\n  modelProviderRegistry,\n  ChatCompletionParams,\n  ChatCompletion,\n  ChatCompletionChunk,\n  ModelProviderConfig\n} from './providers/model-provider';\n\nexport {\n  OpenAIProvider,\n  createOpenAIProvider,\n  createDefaultOpenAIProvider,\n  OpenAIProviderConfig\n} from './providers/openai-provider';\n\nexport {\n  AnthropicProvider,\n  createAnthropicProvider,\n  createDefaultAnthropicProvider,\n  AnthropicProviderConfig\n} from './providers/anthropic-provider';\n\nexport {\n  ProviderFactory,\n  providerFactory,\n  createOpenAIProviderFromEnv,\n  createAnthropicProviderFromEnv,\n  createProviderFromConfig,\n  createProviderFromApiKey,\n  ProviderPresets\n} from './providers/factory';\n\n// Error handling\nexport * from './errors';\n\n// Configuration validation\nexport * from './config-validation';\n\n// Tool system\nexport * from './tool-proxy';\nexport * from './tool-helpers';\n\n// Conversation management\nexport { ConversationManager } from './conversation-manager';\n\n","/**\n * Optimized Event System with batching and async processing\n */\n\nimport { EventEmitter } from \"events\";\nimport { Message, ToolCall, AgentError } from \"./types\";\n\n// Event type enumeration (re-export from events.ts)\nexport enum EventType {\n  // Run lifecycle events\n  RUN_STARTED = 'run_started',\n  RUN_FINISHED = 'run_finished',\n  RUN_FAILED = 'run_failed',\n  \n  // Message events\n  TEXT_MESSAGE_START = 'text_message_start',\n  TEXT_MESSAGE_CONTENT = 'text_message_content',\n  TEXT_MESSAGE_END = 'text_message_end',\n  MESSAGES_SNAPSHOT = 'messages_snapshot',\n  \n  // Tool call events\n  TOOL_CALL_START = 'tool_call_start',\n  TOOL_CALL_ARGS = 'tool_call_args',\n  TOOL_CALL_END = 'tool_call_end',\n  TOOL_CALL_RESULT = 'tool_call_result',\n  \n  // System events\n  STATE_UPDATE = 'state_update',\n  APPROVAL_REQUIRED = 'approval_required',\n  APPROVAL_RECEIVED = 'approval_received',\n  ERROR = 'error',\n  \n  // Conversation events\n  CONVERSATION_CREATED = 'conversation_created',\n  CONVERSATION_UPDATED = 'conversation_updated',\n  CONVERSATION_DELETED = 'conversation_deleted',\n  \n  // Control flow events\n  CONTROL_FLOW_DECISION = 'control_flow_decision',\n  EXECUTION_PAUSED = 'execution_paused',\n  EXECUTION_RESUMED = 'execution_resumed',\n}\n\n// Base event interface\nexport interface BaseEvent {\n  type: EventType;\n  conversationId?: string;\n  runId?: string;\n  timestamp?: number;\n}\n\n// Event data types (simplified for performance)\nexport type EventData = {\n  [EventType.RUN_STARTED]: BaseEvent & { conversationId: string; runId: string };\n  [EventType.RUN_FINISHED]: BaseEvent & { conversationId: string; runId: string; executionTime: number };\n  [EventType.RUN_FAILED]: BaseEvent & { conversationId: string; runId: string; error: AgentError };\n  [EventType.TEXT_MESSAGE_START]: BaseEvent & { messageId: string; content: string };\n  [EventType.TEXT_MESSAGE_CONTENT]: BaseEvent & { messageId: string; content: string; delta: string };\n  [EventType.TEXT_MESSAGE_END]: BaseEvent & { messageId: string; content: string };\n  [EventType.MESSAGES_SNAPSHOT]: BaseEvent & { messages: Message[] };\n  [EventType.TOOL_CALL_START]: BaseEvent & { toolCallId: string; toolName: string };\n  [EventType.TOOL_CALL_ARGS]: BaseEvent & { toolCallId: string; args: any };\n  [EventType.TOOL_CALL_END]: BaseEvent & { toolCallId: string; result: any };\n  [EventType.TOOL_CALL_RESULT]: BaseEvent & { toolCallId: string; result: any };\n  [EventType.STATE_UPDATE]: BaseEvent & { state: any };\n  [EventType.APPROVAL_REQUIRED]: BaseEvent & { toolName: string; args: any };\n  [EventType.APPROVAL_RECEIVED]: BaseEvent & { toolName: string; approved: boolean };\n  [EventType.ERROR]: BaseEvent & { error: AgentError };\n  [EventType.CONVERSATION_CREATED]: BaseEvent & { conversationId: string };\n  [EventType.CONVERSATION_UPDATED]: BaseEvent & { conversationId: string; messages: Message[] };\n  [EventType.CONVERSATION_DELETED]: BaseEvent & { conversationId: string };\n  [EventType.CONTROL_FLOW_DECISION]: BaseEvent & { decision: string; context: any };\n  [EventType.EXECUTION_PAUSED]: BaseEvent & { reason: string };\n  [EventType.EXECUTION_RESUMED]: BaseEvent & { reason: string };\n};\n\n// Event handler type\nexport type EventHandler<T extends EventType> = (data: EventData[T]) => void | Promise<void>;\n\n// Batched event item\ninterface BatchedEvent<T extends EventType> {\n  type: T;\n  data: EventData[T];\n  timestamp: number;\n  priority: number;\n}\n\n// Event processing options\ninterface EventProcessingOptions {\n  batchSize: number;\n  batchTimeout: number;\n  maxConcurrentHandlers: number;\n  enableBatching: boolean;\n  enableAsyncProcessing: boolean;\n}\n\n// Optimized Event System\nexport class OptimizedEventSystem extends EventEmitter {\n  private eventQueue: BatchedEvent<EventType>[] = [];\n  private batchTimer?: NodeJS.Timeout;\n  private processingHandlers = new Set<Promise<void>>();\n  private options: EventProcessingOptions;\n  private isProcessing = false;\n\n  constructor(options: Partial<EventProcessingOptions> = {}) {\n    super();\n    this.setMaxListeners(1000); // Allow more listeners\n    \n    this.options = {\n      batchSize: 10,\n      batchTimeout: 16, // ~60fps\n      maxConcurrentHandlers: 5,\n      enableBatching: true,\n      enableAsyncProcessing: true,\n      ...options\n    };\n  }\n\n  // High-performance event emission with batching\n  emit<T extends EventType>(event: T, data: EventData[T]): boolean {\n    const timestamp = Date.now();\n    const priority = this.getEventPriority(event);\n    \n    const batchedEvent: BatchedEvent<T> = {\n      type: event,\n      data: { ...data, timestamp } as EventData[T],\n      timestamp,\n      priority\n    };\n\n    if (this.options.enableBatching) {\n      this.addToBatch(batchedEvent);\n      return true;\n    } else {\n      return this.processEventImmediately(batchedEvent);\n    }\n  }\n\n  private addToBatch<T extends EventType>(event: BatchedEvent<T>): void {\n    // Insert event in priority order\n    const insertIndex = this.eventQueue.findIndex(e => e.priority < event.priority);\n    if (insertIndex === -1) {\n      this.eventQueue.push(event);\n    } else {\n      this.eventQueue.splice(insertIndex, 0, event);\n    }\n\n    // Process batch if it's full\n    if (this.eventQueue.length >= this.options.batchSize) {\n      this.processBatch();\n    } else if (!this.batchTimer) {\n      // Set timer for batch timeout\n      this.batchTimer = setTimeout(() => {\n        this.processBatch();\n      }, this.options.batchTimeout);\n    }\n  }\n\n  private async processBatch(): Promise<void> {\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n      this.batchTimer = undefined;\n    }\n\n    if (this.eventQueue.length === 0) return;\n\n    const batch = this.eventQueue.splice(0, this.options.batchSize);\n    \n    if (this.options.enableAsyncProcessing) {\n      // Process batch asynchronously\n      this.processBatchAsync(batch);\n    } else {\n      // Process batch synchronously\n      this.processBatchSync(batch);\n    }\n  }\n\n  private async processBatchAsync(batch: BatchedEvent<EventType>[]): Promise<void> {\n    // Limit concurrent processing\n    if (this.processingHandlers.size >= this.options.maxConcurrentHandlers) {\n      // Queue for later processing\n      this.eventQueue.unshift(...batch);\n      return;\n    }\n\n    const processingPromise = this.processBatchSync(batch);\n    this.processingHandlers.add(processingPromise);\n    \n    try {\n      await processingPromise;\n    } finally {\n      this.processingHandlers.delete(processingPromise);\n    }\n  }\n\n  private async processBatchSync(batch: BatchedEvent<EventType>[]): Promise<void> {\n    // Group events by type for efficient processing\n    const eventsByType = new Map<EventType, BatchedEvent<EventType>[]>();\n    \n    for (const event of batch) {\n      if (!eventsByType.has(event.type)) {\n        eventsByType.set(event.type, []);\n      }\n      eventsByType.get(event.type)!.push(event);\n    }\n\n    // Process each event type\n    const promises: Promise<void>[] = [];\n    \n    for (const [eventType, events] of eventsByType) {\n      const handlers = this.listeners(eventType) as EventHandler<EventType>[];\n      \n      for (const handler of handlers) {\n        for (const event of events) {\n          try {\n            const result = handler(event.data);\n            if (result instanceof Promise) {\n              promises.push(result);\n            }\n          } catch (error) {\n            console.error(`Error in event handler for ${eventType}:`, error);\n          }\n        }\n      }\n    }\n\n    // Wait for all async handlers to complete\n    if (promises.length > 0) {\n      await Promise.allSettled(promises);\n    }\n  }\n\n  private processEventImmediately<T extends EventType>(event: BatchedEvent<T>): boolean {\n    try {\n      return super.emit(event.type, event.data);\n    } catch (error) {\n      console.error(`Error emitting event ${event.type}:`, error);\n      return false;\n    }\n  }\n\n  private getEventPriority(eventType: EventType): number {\n    // Higher number = higher priority\n    const priorities: Record<EventType, number> = {\n      [EventType.ERROR]: 100,\n      [EventType.RUN_FAILED]: 90,\n      [EventType.APPROVAL_REQUIRED]: 80,\n      [EventType.EXECUTION_PAUSED]: 70,\n      [EventType.EXECUTION_RESUMED]: 70,\n      [EventType.RUN_STARTED]: 60,\n      [EventType.RUN_FINISHED]: 60,\n      [EventType.TOOL_CALL_START]: 50,\n      [EventType.TOOL_CALL_END]: 50,\n      [EventType.TOOL_CALL_RESULT]: 50,\n      [EventType.STATE_UPDATE]: 40,\n      [EventType.TEXT_MESSAGE_START]: 30,\n      [EventType.TEXT_MESSAGE_END]: 30,\n      [EventType.TEXT_MESSAGE_CONTENT]: 20,\n      [EventType.MESSAGES_SNAPSHOT]: 10,\n      [EventType.CONVERSATION_CREATED]: 10,\n      [EventType.CONVERSATION_UPDATED]: 10,\n      [EventType.CONVERSATION_DELETED]: 10,\n      [EventType.CONTROL_FLOW_DECISION]: 10,\n      [EventType.TOOL_CALL_ARGS]: 10,\n      [EventType.APPROVAL_RECEIVED]: 10,\n    };\n    \n    return priorities[eventType] || 0;\n  }\n\n  // Type-safe event listening\n  on<T extends EventType>(event: T, handler: EventHandler<T>): this {\n    return super.on(event, handler);\n  }\n  \n  // Type-safe event listening (once)\n  once<T extends EventType>(event: T, handler: EventHandler<T>): this {\n    return super.once(event, handler);\n  }\n\n  // Performance monitoring\n  getPerformanceMetrics(): {\n    queueSize: number;\n    processingHandlers: number;\n    isProcessing: boolean;\n  } {\n    return {\n      queueSize: this.eventQueue.length,\n      processingHandlers: this.processingHandlers.size,\n      isProcessing: this.isProcessing\n    };\n  }\n\n  // Flush all pending events\n  async flush(): Promise<void> {\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n      this.batchTimer = undefined;\n    }\n    \n    while (this.eventQueue.length > 0) {\n      await this.processBatch();\n    }\n    \n    // Wait for all processing to complete\n    await Promise.allSettled(Array.from(this.processingHandlers));\n  }\n\n  // Cleanup\n  destroy(): void {\n    if (this.batchTimer) {\n      clearTimeout(this.batchTimer);\n    }\n    \n    this.eventQueue = [];\n    this.processingHandlers.clear();\n    this.removeAllListeners();\n  }\n}\n\n// Factory function for creating optimized event systems\nexport function createOptimizedEventSystem(options?: Partial<EventProcessingOptions>): OptimizedEventSystem {\n  return new OptimizedEventSystem(options);\n}\n\n// Default optimized event system instance\nexport const optimizedEventSystem = new OptimizedEventSystem();\n\n\n\n","import { Message } from \"../types\";\n\n// Tool call interface\nexport interface ToolCall {\n  id: string;\n  function: {\n    name: string;\n    arguments: string;\n  };\n}\n\n// Chat completion parameters interface\nexport interface ChatCompletionParams {\n  model: string;\n  messages: Message[];\n  temperature?: number;\n  max_tokens?: number;\n  top_p?: number;\n  frequency_penalty?: number;\n  presence_penalty?: number;\n  tools?: ToolDefinition[];\n  tool_choice?: 'auto' | 'none' | { type: 'function'; function: { name: string } };\n  stream?: boolean;\n  stop?: string[];\n  /**\n   * AbortSignal for cancelling the LLM request.\n   * When aborted, the underlying HTTP request will be cancelled.\n   */\n  signal?: AbortSignal;\n}\n\n// Tool definition for model providers\nexport interface ToolDefinition {\n  type: 'function';\n  function: {\n    name: string;\n    description?: string;\n    parameters: any;\n  };\n}\n\n// Chat completion response interface\nexport interface ChatCompletion {\n  id: string;\n  object: 'chat.completion';\n  created: number;\n  model: string;\n  choices: Array<{\n    index: number;\n    message: {\n      role: 'assistant';\n      content: string | null;\n      tool_calls?: ToolCall[];\n    };\n    finish_reason: 'stop' | 'length' | 'content_filter' | 'tool_calls';\n  }>;\n  usage: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\n// Chat completion chunk interface for streaming\nexport interface ChatCompletionChunk {\n  id: string;\n  object: 'chat.completion.chunk';\n  created: number;\n  model: string;\n  choices: Array<{\n    index: number;\n    delta: {\n      role?: 'assistant';\n      content?: string;\n      tool_calls?: ToolCall[];\n    };\n    finish_reason?: 'stop' | 'length' | 'content_filter' | 'tool_calls';\n  }>;\n}\n\n// Model provider interface\nexport interface ModelProvider {\n  // Chat completions\n  chat: {\n    completions: {\n      create: (params: ChatCompletionParams) => Promise<ChatCompletion>;\n      stream: (params: ChatCompletionParams) => AsyncIterable<ChatCompletionChunk>;\n    };\n  };\n  \n  // Provider capabilities\n  supportsTools(): boolean;\n  supportsStreaming(): boolean;\n  \n  // Tool formatting\n  formatTools(tools: any[]): ToolDefinition[];\n  parseToolCalls(response: ChatCompletion): ToolCall[];\n  \n  // Provider information\n  getProviderName(): string;\n  getDefaultModel(): string;\n  \n  // Configuration validation\n  validateConfig(config: any): boolean;\n}\n\n// Model provider configuration interface\nexport interface ModelProviderConfig {\n  apiKey: string;\n  baseURL?: string;\n  defaultModel?: string;\n  timeout?: number;\n  maxRetries?: number;\n  retryDelay?: number;\n  proxy?: string;\n  rejectUnauthorized?: boolean; // For SSL certificate validation\n}\n\n// Model provider error interface\nexport interface ModelProviderError extends Error {\n  type: 'authentication' | 'rate_limit' | 'quota_exceeded' | 'invalid_request' | 'server_error' | 'timeout' | 'aborted' | 'unknown';\n  status?: number;\n  code?: string;\n  details?: any;\n}\n\n// Model provider factory interface\nexport interface ModelProviderFactory {\n  createOpenAI(config: ModelProviderConfig): ModelProvider;\n  createAnthropic(config: ModelProviderConfig): ModelProvider;\n  createCustom(config: ModelProviderConfig & { providerType: string }): ModelProvider;\n}\n\n// Base model provider class with common functionality\nexport abstract class BaseModelProvider implements ModelProvider {\n  protected config: ModelProviderConfig;\n  protected defaultModel: string;\n\n  constructor(config: ModelProviderConfig) {\n    this.config = config;\n    this.defaultModel = config.defaultModel || this.getDefaultModel();\n  }\n\n  // Abstract methods that must be implemented by subclasses\n  abstract get chat(): {\n    completions: {\n      create: (params: ChatCompletionParams) => Promise<ChatCompletion>;\n      stream: (params: ChatCompletionParams) => AsyncIterable<ChatCompletionChunk>;\n    };\n  };\n\n  abstract getProviderName(): string;\n  abstract getDefaultModel(): string;\n  abstract formatTools(tools: any[]): ToolDefinition[];\n  abstract parseToolCalls(response: ChatCompletion): ToolCall[];\n\n  // Common implementations\n  supportsTools(): boolean {\n    return true; // Most modern providers support tools\n  }\n\n  supportsStreaming(): boolean {\n    return true; // Most modern providers support streaming\n  }\n\n  validateConfig(config: any): boolean {\n    return !!(config.apiKey && config.apiKey.trim().length > 0);\n  }\n\n  // Utility methods\n  protected createError(message: string, type: ModelProviderError['type'], details?: any): ModelProviderError {\n    const error = new Error(message) as ModelProviderError;\n    error.type = type;\n    // Avoid circular reference issues by creating a safe details object\n    if (details) {\n      if (details.message && details.name && details.stack) {\n        // It's already a clean error object\n        error.details = details;\n      } else {\n        // Create a safe details object\n        error.details = {\n          message: details.message || 'Unknown error',\n          name: details.name || 'Error',\n          stack: details.stack || 'No stack trace available'\n        };\n      }\n    }\n    return error;\n  }\n\n  protected async withRetry<T>(\n    operation: () => Promise<T>,\n    maxRetries: number = this.config.maxRetries || 3,\n    delay: number = this.config.retryDelay || 1000\n  ): Promise<T> {\n    let lastError: Error;\n    \n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        return await operation();\n      } catch (error) {\n        lastError = error as Error;\n        \n        // Don't retry on certain error types\n        if (error instanceof Error && this.isNonRetryableError(error)) {\n          // Create a clean error without circular references\n          const cleanError = new Error(error.message);\n          cleanError.name = error.name;\n          cleanError.stack = error.stack;\n          throw cleanError;\n        }\n        \n        // Don't retry on last attempt\n        if (attempt === maxRetries) {\n          break;\n        }\n        \n        // Wait before retrying\n        await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, attempt)));\n      }\n    }\n    \n    // Create a clean error without circular references\n    const cleanError = new Error(lastError!.message);\n    cleanError.name = lastError!.name;\n    cleanError.stack = lastError!.stack;\n    throw cleanError;\n  }\n\n  protected isNonRetryableError(error: Error): boolean {\n    // Authentication errors, invalid requests, etc. should not be retried\n    const nonRetryableTypes = ['authentication', 'invalid_request'];\n    return nonRetryableTypes.includes((error as ModelProviderError).type);\n  }\n\n  protected formatMessages(messages: Message[]): any[] {\n    return messages.map(msg => {\n      const formatted: any = {\n        role: msg.role,\n        content: msg.content,\n      };\n      \n      // Handle tool_calls for assistant messages\n      if (msg.toolCalls && msg.toolCalls.length > 0) {\n        formatted.tool_calls = msg.toolCalls;\n      }\n      \n      // Handle tool_call_id for tool messages\n      if (msg.role === 'tool' && msg.toolCallId) {\n        formatted.tool_call_id = msg.toolCallId;\n      }\n      \n      return formatted;\n    });\n  }\n\n  protected parseMessages(response: any): Message[] {\n    const messages: Message[] = [];\n    \n    if (response.choices && response.choices.length > 0) {\n      const choice = response.choices[0];\n      if (choice.message) {\n        messages.push({\n          id: response.id || `msg_${Date.now()}`,\n          role: choice.message.role,\n          content: choice.message.content || '',\n          toolCalls: choice.message.tool_calls,\n          timestamp: new Date()\n        });\n      }\n    }\n    \n    return messages;\n  }\n}\n\n// Model provider registry for managing multiple providers\nexport class ModelProviderRegistry {\n  private providers = new Map<string, ModelProvider>();\n  private defaultProvider?: string;\n\n  // Register a provider\n  register(name: string, provider: ModelProvider): this {\n    this.providers.set(name, provider);\n    return this;\n  }\n\n  // Unregister a provider\n  unregister(name: string): boolean {\n    return this.providers.delete(name);\n  }\n\n  // Get a provider by name\n  get(name: string): ModelProvider | undefined {\n    return this.providers.get(name);\n  }\n\n  // Get all registered providers\n  getAll(): Map<string, ModelProvider> {\n    return new Map(this.providers);\n  }\n\n  // Set default provider\n  setDefault(name: string): this {\n    if (!this.providers.has(name)) {\n      throw new Error(`Provider '${name}' is not registered`);\n    }\n    this.defaultProvider = name;\n    return this;\n  }\n\n  // Get default provider\n  getDefault(): ModelProvider | undefined {\n    if (this.defaultProvider) {\n      return this.providers.get(this.defaultProvider);\n    }\n    return undefined;\n  }\n\n  // List all provider names\n  listNames(): string[] {\n    return Array.from(this.providers.keys());\n  }\n\n  // Check if a provider is registered\n  has(name: string): boolean {\n    return this.providers.has(name);\n  }\n\n  // Clear all providers\n  clear(): void {\n    this.providers.clear();\n    this.defaultProvider = undefined;\n  }\n}\n\n// Export singleton registry\nexport const modelProviderRegistry = new ModelProviderRegistry();\n","import OpenAI from 'openai';\nimport {\n  ModelProvider,\n  ModelProviderConfig,\n  ModelProviderError,\n  BaseModelProvider,\n  ChatCompletionParams,\n  ChatCompletion,\n  ChatCompletionChunk,\n  ToolDefinition,\n  ToolCall\n} from './model-provider';\nimport { Message } from '../types';\n\n// OpenAI fetch options type - compatible with OpenAI client\nexport interface OpenAIFetchOptions {\n  fetch?: typeof fetch;\n  dispatcher?: any; // For proxy agents (undici, node-fetch, etc.)\n  [key: string]: any; // Allow additional properties for flexibility\n}\n\n// OpenAI provider configuration\nexport interface OpenAIProviderConfig extends ModelProviderConfig {\n  organization?: string;\n  project?: string;\n  fetchOptions?: OpenAIFetchOptions;\n}\n\n// OpenAI provider implementation\nexport class OpenAIProvider extends BaseModelProvider implements ModelProvider {\n  private client: OpenAI;\n  protected config: OpenAIProviderConfig;\n\n  constructor(config: OpenAIProviderConfig) {\n    super(config);\n    this.config = config;\n    \n    if (!this.validateConfig(config)) {\n      throw this.createError('Invalid OpenAI configuration', 'invalid_request', config);\n    }\n\n    this.client = new OpenAI({\n      apiKey: config.apiKey,\n      baseURL: config.baseURL,\n      organization: config.organization,\n      project: config.project,\n      timeout: config.timeout || 30000,\n      fetchOptions: config.fetchOptions,\n    });\n  }\n\n  get chat() {\n    return {\n      completions: {\n        create: this.createCompletion.bind(this),\n        stream: this.createStream.bind(this)\n      }\n    };\n  }\n\n  getProviderName(): string {\n    return 'openai';\n  }\n\n  getDefaultModel(): string {\n    return this.config.defaultModel || 'gpt-4';\n  }\n\n  validateConfig(config: any): boolean {\n    return super.validateConfig(config) && \n           typeof config.apiKey === 'string' && \n           config.apiKey.length > 0;\n  }\n\n  formatTools(tools: any[]): ToolDefinition[] {\n    return tools\n  }\n\n  parseToolCalls(response: ChatCompletion): ToolCall[] {\n    const toolCalls: ToolCall[] = [];\n    \n    if (response.choices && response.choices.length > 0) {\n      const choice = response.choices[0];\n      if (choice.message.tool_calls) {\n        for (const toolCall of choice.message.tool_calls) {\n          toolCalls.push({\n            id: toolCall.id,\n            function: {\n              name: toolCall.function.name,\n              arguments: toolCall.function.arguments\n            }\n          });\n        }\n      }\n    }\n    \n    return toolCalls;\n  }\n\n  // Enhanced chat completion with error handling and retries\n  async createCompletion(params: ChatCompletionParams): Promise<ChatCompletion> {\n    try {\n      const openaiParams = this.convertToOpenAIParams(params);\n\n      // Prepare request options with signal\n      const requestOptions: any = {};\n      if (params.signal) {\n        requestOptions.signal = params.signal;\n      }\n\n      const response = await this.withRetry(async () => {\n        return await this.client.chat.completions.create(openaiParams, requestOptions);\n      });\n\n\n      return this.convertFromOpenAIResponse(response);\n    } catch (error) {\n      // Create a clean error without circular references\n      const cleanError = new Error((error as Error).message);\n      cleanError.name = (error as Error).name;\n      cleanError.stack = (error as Error).stack;\n      throw this.handleOpenAIError(cleanError);\n    }\n  }\n\n  // Enhanced streaming with error handling\n  async *createStream(params: ChatCompletionParams): AsyncIterable<ChatCompletionChunk> {\n\n    try {\n      const openaiParams = this.convertToOpenAIParams(params);\n\n      // Prepare request options with signal\n      const requestOptions: any = {};\n      if (params.signal) {\n        requestOptions.signal = params.signal;\n      }\n\n      const stream = await this.client.chat.completions.create({\n        ...openaiParams,\n        stream: true\n      }, requestOptions);\n\n      if (Symbol.asyncIterator in stream) {\n        for await (const chunk of stream as any) {\n          yield this.convertFromOpenAIChunk(chunk);\n        }\n      } else {\n        throw new Error('Streaming not supported by this OpenAI client version');\n      }\n    } catch (error) {\n      throw this.handleOpenAIError(error);\n    }\n  }\n\n  // Convert our params to OpenAI format\n  private convertToOpenAIParams(params: ChatCompletionParams): any {\n    const openaiParams: any = {\n      model: params.model,\n      messages: params.messages, // Use messages directly without formatting\n      temperature: params.temperature,\n      max_tokens: params.max_tokens,\n      top_p: params.top_p,\n      frequency_penalty: params.frequency_penalty,\n      presence_penalty: params.presence_penalty,\n      stop: params.stop,\n    };\n\n    // Add tools if provided\n    if (params.tools && params.tools.length > 0) {\n      openaiParams.tools = this.formatTools(params.tools);\n      openaiParams.tool_choice = params.tool_choice || 'auto';\n    }\n\n    return openaiParams;\n  }\n\n  // Convert OpenAI response to our format\n  private convertFromOpenAIResponse(response: any): ChatCompletion {\n    \n    return {\n      id: response.id,\n      object: response.object,\n      created: response.created,\n      model: response.model,\n      choices: response.choices.map((choice: any) => ({\n        index: choice.index,\n        message: {\n          role: choice.message.role,\n          content: choice.message.content,\n          tool_calls: choice.message.tool_calls\n        },\n        finish_reason: choice.finish_reason\n      })),\n      usage: response.usage\n    };\n  }\n\n  // Convert OpenAI chunk to our format\n  private convertFromOpenAIChunk(chunk: any): ChatCompletionChunk {\n    return {\n      id: chunk.id,\n      object: chunk.object,\n      created: chunk.created,\n      model: chunk.model,\n      choices: chunk.choices.map((choice: any) => ({\n        index: choice.index,\n        delta: choice.delta,\n        finish_reason: choice.finish_reason\n      }))\n    };\n  }\n\n  // Handle OpenAI-specific errors\n  private handleOpenAIError(error: any): ModelProviderError {\n    if (error instanceof Error) {\n      // Check for abort errors first\n      if (error.name === 'AbortError' || error.message.includes('abort')) {\n        return this.createError('Request aborted', 'aborted', error);\n      }\n\n      // Check for specific OpenAI error types\n      if (error.message.includes('401') || error.message.includes('Unauthorized')) {\n        return this.createError('Invalid API key', 'authentication', error);\n      }\n\n      if (error.message.includes('429') || error.message.includes('rate limit')) {\n        return this.createError('Rate limit exceeded', 'rate_limit', error);\n      }\n\n      if (error.message.includes('quota') || error.message.includes('billing')) {\n        return this.createError('Quota exceeded', 'quota_exceeded', error);\n      }\n\n      if (error.message.includes('400') || error.message.includes('Bad Request')) {\n        return this.createError('Invalid request', 'invalid_request', error);\n      }\n\n      if (error.message.includes('500') || error.message.includes('Internal Server Error')) {\n        return this.createError('Server error', 'server_error', error);\n      }\n\n      if (error.message.includes('timeout')) {\n        return this.createError('Request timeout', 'timeout', error);\n      }\n    }\n    \n    return this.createError(\n      error.message || 'Unknown OpenAI error',\n      'unknown',\n      {\n        message: error.message,\n        name: error.name,\n        stack: error.stack\n      }\n    );\n  }\n\n  // Get available models (if supported by the API)\n  async getAvailableModels(): Promise<string[]> {\n    try {\n      const response = await this.client.models.list();\n      return response.data\n        .filter(model => model.id.includes('gpt'))\n        .map(model => model.id);\n    } catch (error) {\n      console.warn('Failed to fetch available models:', error);\n      return ['gpt-4', 'gpt-4-turbo', 'gpt-3.5-turbo']; // Fallback to common models\n    }\n  }\n\n  // Check if a model is available\n  async isModelAvailable(model: string): Promise<boolean> {\n    try {\n      const models = await this.getAvailableModels();\n      return models.includes(model);\n    } catch (error) {\n      console.warn('Failed to check model availability:', error);\n      return true; // Assume available if we can't check\n    }\n  }\n\n  // Get model information\n  async getModelInfo(model: string): Promise<any> {\n    try {\n      const response = await this.client.models.retrieve(model);\n      return {\n        id: response.id,\n        object: response.object,\n        created: response.created,\n        owned_by: (response as any).owned_by,\n        permission: (response as any).permission,\n        root: (response as any).root,\n        parent: (response as any).parent\n      };\n    } catch (error) {\n      throw this.handleOpenAIError(error);\n    }\n  }\n\n  // Estimate token usage for a request\n  async estimateTokens(params: ChatCompletionParams): Promise<number> {\n    // Simple estimation based on character count\n    // In production, you might want to use a more accurate tokenizer\n    const text = params.messages.map(msg => msg.content).join(' ');\n    return Math.ceil(text.length / 4); // Rough estimate: 4 characters per token\n  }\n\n  // Get usage statistics\n  async getUsage(startDate?: Date, endDate?: Date): Promise<any> {\n    try {\n      const params: any = {};\n      if (startDate) params.start_date = startDate.toISOString().split('T')[0];\n      if (endDate) params.end_date = endDate.toISOString().split('T')[0];\n      \n      // OpenAI doesn't have a usage API in the current SDK\n      throw new Error('Usage statistics not available in current OpenAI SDK');\n    } catch (error) {\n      throw this.handleOpenAIError(error);\n    }\n  }\n}\n\n// Factory function for creating OpenAI provider\nexport function createOpenAIProvider(config: OpenAIProviderConfig): OpenAIProvider {\n  return new OpenAIProvider(config);\n}\n\n// Default configuration helper\nexport function createDefaultOpenAIProvider(apiKey: string, options?: Partial<OpenAIProviderConfig>): OpenAIProvider {\n  return new OpenAIProvider({\n    apiKey,\n    defaultModel: 'gpt-4',\n    timeout: 30000,\n    maxRetries: 3,\n    retryDelay: 1000,\n    ...options\n  });\n}\n","import Anthropic from '@anthropic-ai/sdk';\nimport {\n  ModelProvider,\n  ModelProviderConfig,\n  ModelProviderError,\n  BaseModelProvider,\n  ChatCompletionParams,\n  ChatCompletion,\n  ChatCompletionChunk,\n  ToolDefinition,\n  ToolCall\n} from './model-provider';\nimport { Message } from '../types';\n\n// Anthropic provider configuration\nexport interface AnthropicProviderConfig extends ModelProviderConfig {\n  anthropicVersion?: string;\n}\n\n// Anthropic provider implementation\nexport class AnthropicProvider extends BaseModelProvider implements ModelProvider {\n  private client: Anthropic;\n  protected config: AnthropicProviderConfig;\n\n  constructor(config: AnthropicProviderConfig) {\n    super(config);\n    this.config = config;\n    \n    if (!this.validateConfig(config)) {\n      throw this.createError('Invalid Anthropic configuration', 'invalid_request', config);\n    }\n\n    this.client = new Anthropic({\n      apiKey: config.apiKey,\n      baseURL: config.baseURL,\n      timeout: config.timeout || 30000,\n    });\n  }\n\n  get chat() {\n    return {\n      completions: {\n        create: this.createCompletion.bind(this),\n        stream: this.createStream.bind(this)\n      }\n    };\n  }\n\n  getProviderName(): string {\n    return 'anthropic';\n  }\n\n  getDefaultModel(): string {\n    return this.config.defaultModel || 'claude-3-sonnet-20240229';\n  }\n\n  validateConfig(config: any): boolean {\n    return super.validateConfig(config) && \n           typeof config.apiKey === 'string' && \n           config.apiKey.length > 0;\n  }\n\n  formatTools(tools: any[]): ToolDefinition[] {\n    return tools.map(tool => ({\n      type: 'function' as const,\n      function: {\n        name: tool.name,\n        description: tool.description,\n        parameters: tool.schema || {}\n      }\n    }));\n  }\n\n  parseToolCalls(response: ChatCompletion): ToolCall[] {\n    const toolCalls: ToolCall[] = [];\n    \n    if (response.choices && response.choices.length > 0) {\n      const choice = response.choices[0];\n      if (choice.message.tool_calls) {\n        for (const toolCall of choice.message.tool_calls) {\n          toolCalls.push({\n            id: toolCall.id,\n            function: {\n              name: toolCall.function.name,\n              arguments: toolCall.function.arguments\n            }\n          });\n        }\n      }\n    }\n    \n    return toolCalls;\n  }\n\n  // Create completion using Anthropic API\n  async createCompletion(params: ChatCompletionParams): Promise<ChatCompletion> {\n    try {\n      const anthropicParams = this.convertToAnthropicParams(params);\n\n      // Add signal to request options if provided\n      const requestOptions: any = {};\n      if (params.signal) {\n        requestOptions.signal = params.signal;\n      }\n\n      const response = await this.withRetry(async () => {\n        return await this.client.messages.create(anthropicParams, requestOptions);\n      });\n\n      return this.convertFromAnthropicResponse(response, params.model);\n    } catch (error) {\n      // Create a clean error without circular references\n      const cleanError = new Error((error as Error).message);\n      cleanError.name = (error as Error).name;\n      cleanError.stack = (error as Error).stack;\n      throw this.handleAnthropicError(cleanError);\n    }\n  }\n\n  // Create streaming completion\n  async *createStream(params: ChatCompletionParams): AsyncIterable<ChatCompletionChunk> {\n    try {\n      const anthropicParams = this.convertToAnthropicParams(params);\n      anthropicParams.stream = true;\n\n      // Add signal to request options if provided\n      const requestOptions: any = {};\n      if (params.signal) {\n        requestOptions.signal = params.signal;\n      }\n\n      const stream = await this.client.messages.create(anthropicParams, requestOptions);\n\n      if (Symbol.asyncIterator in stream) {\n        for await (const chunk of stream as any) {\n          yield this.convertFromAnthropicChunk(chunk, params.model);\n        }\n      } else {\n        throw new Error('Streaming not supported by this Anthropic client version');\n      }\n    } catch (error) {\n      throw this.handleAnthropicError(error);\n    }\n  }\n\n  // Convert our params to Anthropic format\n  private convertToAnthropicParams(params: ChatCompletionParams): any {\n    const anthropicParams: any = {\n      model: params.model,\n      max_tokens: params.max_tokens || 1024,\n      temperature: params.temperature,\n      top_p: params.top_p,\n      stop_sequences: params.stop,\n    };\n\n    // Convert messages to Anthropic format\n    const systemMessages: string[] = [];\n    const messages: any[] = [];\n\n    for (const message of params.messages) {\n      if (message.role === 'system') {\n        systemMessages.push(message.content);\n      } else {\n        messages.push({\n          role: message.role === 'assistant' ? 'assistant' : 'user',\n          content: message.content\n        });\n      }\n    }\n\n    if (systemMessages.length > 0) {\n      anthropicParams.system = systemMessages.join('\\n');\n    }\n\n    anthropicParams.messages = messages;\n\n    // Add tools if provided\n    if (params.tools && params.tools.length > 0) {\n      anthropicParams.tools = this.formatTools(params.tools);\n    }\n\n    return anthropicParams;\n  }\n\n  // Convert Anthropic response to our format\n  private convertFromAnthropicResponse(response: any, model: string): ChatCompletion {\n    const choice = {\n      index: 0,\n      message: {\n        role: 'assistant' as const,\n        content: response.content[0]?.text || '',\n        tool_calls: response.content\n          .filter((item: any) => item.type === 'tool_use')\n          .map((item: any) => ({\n            id: item.id,\n            function: {\n              name: item.name,\n              arguments: JSON.stringify(item.input)\n            }\n          }))\n      },\n      finish_reason: this.mapFinishReason(response.stop_reason)\n    };\n\n    return {\n      id: response.id,\n      object: 'chat.completion',\n      created: Date.now(),\n      model: model,\n      choices: [choice],\n      usage: {\n        prompt_tokens: response.usage?.input_tokens || 0,\n        completion_tokens: response.usage?.output_tokens || 0,\n        total_tokens: (response.usage?.input_tokens || 0) + (response.usage?.output_tokens || 0)\n      }\n    };\n  }\n\n  // Convert Anthropic chunk to our format\n  private convertFromAnthropicChunk(chunk: any, model: string): ChatCompletionChunk {\n    const choice = {\n      index: 0,\n      delta: {\n        content: chunk.delta?.text || '',\n        role: 'assistant' as const\n      },\n      finish_reason: chunk.type === 'message_stop' ? 'stop' : undefined\n    };\n\n    return {\n      id: chunk.id || `chunk_${Date.now()}`,\n      object: 'chat.completion.chunk',\n      created: Date.now(),\n      model: model,\n      choices: [choice as any]\n    };\n  }\n\n  // Map Anthropic stop reasons to OpenAI format\n  private mapFinishReason(stopReason: string): 'stop' | 'length' | 'content_filter' | 'tool_calls' {\n    switch (stopReason) {\n      case 'end_turn':\n        return 'stop';\n      case 'max_tokens':\n        return 'length';\n      case 'stop_sequence':\n        return 'stop';\n      default:\n        return 'stop';\n    }\n  }\n\n  // Handle Anthropic-specific errors\n  private handleAnthropicError(error: any): ModelProviderError {\n    if (error instanceof Error) {\n      // Check for abort errors first\n      if (error.name === 'AbortError' || error.message.includes('abort')) {\n        return this.createError('Request aborted', 'aborted', error);\n      }\n\n      // Check for specific Anthropic error types\n      if (error.message.includes('401') || error.message.includes('Unauthorized')) {\n        return this.createError('Invalid API key', 'authentication', error);\n      }\n\n      if (error.message.includes('429') || error.message.includes('rate limit')) {\n        return this.createError('Rate limit exceeded', 'rate_limit', error);\n      }\n\n      if (error.message.includes('quota') || error.message.includes('billing')) {\n        return this.createError('Quota exceeded', 'quota_exceeded', error);\n      }\n\n      if (error.message.includes('400') || error.message.includes('Bad Request')) {\n        return this.createError('Invalid request', 'invalid_request', error);\n      }\n\n      if (error.message.includes('500') || error.message.includes('Internal Server Error')) {\n        return this.createError('Server error', 'server_error', error);\n      }\n\n      if (error.message.includes('timeout')) {\n        return this.createError('Request timeout', 'timeout', error);\n      }\n    }\n    \n    return this.createError(\n      error.message || 'Unknown Anthropic error',\n      'unknown',\n      {\n        message: error.message,\n        name: error.name,\n        stack: error.stack\n      }\n    );\n  }\n\n  // Get available models\n  async getAvailableModels(): Promise<string[]> {\n    // Anthropic doesn't have a models list API, so we return the known models\n    return [\n      'claude-3-opus-20240229',\n      'claude-3-sonnet-20240229',\n      'claude-3-haiku-20240307',\n      'claude-2.1',\n      'claude-2.0',\n      'claude-instant-1.2'\n    ];\n  }\n\n  // Check if a model is available\n  async isModelAvailable(model: string): Promise<boolean> {\n    const models = await this.getAvailableModels();\n    return models.includes(model);\n  }\n\n  // Get model information\n  async getModelInfo(model: string): Promise<any> {\n    // Anthropic doesn't provide detailed model info via API\n    return {\n      id: model,\n      object: 'model',\n      created: Date.now(),\n      owned_by: 'anthropic'\n    };\n  }\n\n  // Estimate token usage for a request\n  async estimateTokens(params: ChatCompletionParams): Promise<number> {\n    // Simple estimation based on character count\n    const text = params.messages.map(msg => msg.content).join(' ');\n    return Math.ceil(text.length / 4); // Rough estimate: 4 characters per token\n  }\n\n  // Get usage statistics (Anthropic doesn't provide usage API)\n  async getUsage(startDate?: Date, endDate?: Date): Promise<any> {\n    throw this.createError('Usage statistics not available for Anthropic', 'invalid_request');\n  }\n}\n\n// Factory function for creating Anthropic provider\nexport function createAnthropicProvider(config: AnthropicProviderConfig): AnthropicProvider {\n  return new AnthropicProvider(config);\n}\n\n// Default configuration helper\nexport function createDefaultAnthropicProvider(apiKey: string, options?: Partial<AnthropicProviderConfig>): AnthropicProvider {\n  return new AnthropicProvider({\n    apiKey,\n    defaultModel: 'claude-3-sonnet-20240229',\n    timeout: 30000,\n    maxRetries: 3,\n    retryDelay: 1000,\n    ...options\n  });\n}\n","import {\n  ModelProvider,\n  ModelProviderConfig,\n  ModelProviderFactory,\n  ModelProviderRegistry,\n  modelProviderRegistry\n} from './model-provider';\nimport {\n  OpenAIProvider,\n  OpenAIProviderConfig,\n  createOpenAIProvider,\n  createDefaultOpenAIProvider\n} from './openai-provider';\nimport {\n  AnthropicProvider,\n  AnthropicProviderConfig,\n  createAnthropicProvider,\n  createDefaultAnthropicProvider\n} from './anthropic-provider';\n\n// Provider factory implementation\nexport class ProviderFactory implements ModelProviderFactory {\n  private registry: ModelProviderRegistry;\n\n  constructor(registry: ModelProviderRegistry = modelProviderRegistry) {\n    this.registry = registry;\n  }\n\n  // Create OpenAI provider\n  createOpenAI(config: ModelProviderConfig): ModelProvider {\n    const openaiConfig: OpenAIProviderConfig = {\n      ...config,\n      // Ensure OpenAI-specific defaults\n      defaultModel: config.defaultModel || 'gpt-4',\n      timeout: config.timeout || 30000,\n      maxRetries: config.maxRetries || 3,\n      retryDelay: config.retryDelay || 1000,\n    };\n\n    const provider = createOpenAIProvider(openaiConfig);\n    this.registry.register('openai', provider);\n    return provider;\n  }\n\n  // Create Anthropic provider\n  createAnthropic(config: ModelProviderConfig): ModelProvider {\n    const anthropicConfig: AnthropicProviderConfig = {\n      ...config,\n      // Ensure Anthropic-specific defaults\n      defaultModel: config.defaultModel || 'claude-3-sonnet-20240229',\n      timeout: config.timeout || 30000,\n      maxRetries: config.maxRetries || 3,\n      retryDelay: config.retryDelay || 1000,\n    };\n\n    const provider = createAnthropicProvider(anthropicConfig);\n    this.registry.register('anthropic', provider);\n    return provider;\n  }\n\n  // Create custom provider (for future extensibility)\n  createCustom(config: ModelProviderConfig & { providerType: string }): ModelProvider {\n    const { providerType, ...baseConfig } = config;\n\n    switch (providerType.toLowerCase()) {\n      case 'openai':\n        return this.createOpenAI(baseConfig);\n      case 'anthropic':\n        return this.createAnthropic(baseConfig);\n      default:\n        throw new Error(`Unsupported provider type: ${providerType}`);\n    }\n  }\n\n  // Create provider from environment variables\n  createFromEnv(providerType: string = 'openai'): ModelProvider {\n    const config: ModelProviderConfig = {\n      apiKey: this.getApiKeyFromEnv(providerType),\n      baseURL: this.getBaseURLFromEnv(providerType),\n      defaultModel: this.getDefaultModelFromEnv(providerType),\n      timeout: this.getTimeoutFromEnv(),\n      maxRetries: this.getMaxRetriesFromEnv(),\n      retryDelay: this.getRetryDelayFromEnv(),\n    };\n\n    return this.createCustom({ ...config, providerType });\n  }\n\n  // Get API key from environment variables\n  private getApiKeyFromEnv(providerType: string): string {\n    const envKey = providerType.toUpperCase() + '_API_KEY';\n    const apiKey = process.env[envKey];\n    \n    if (!apiKey) {\n      throw new Error(`API key not found in environment variable: ${envKey}`);\n    }\n    \n    return apiKey;\n  }\n\n  // Get base URL from environment variables\n  private getBaseURLFromEnv(providerType: string): string | undefined {\n    const envKey = providerType.toUpperCase() + '_BASE_URL';\n    return process.env[envKey];\n  }\n\n  // Get default model from environment variables\n  private getDefaultModelFromEnv(providerType: string): string | undefined {\n    const envKey = providerType.toUpperCase() + '_DEFAULT_MODEL';\n    return process.env[envKey];\n  }\n\n  // Get timeout from environment variables\n  private getTimeoutFromEnv(): number | undefined {\n    const timeout = process.env.MODEL_PROVIDER_TIMEOUT;\n    return timeout ? parseInt(timeout, 10) : undefined;\n  }\n\n  // Get max retries from environment variables\n  private getMaxRetriesFromEnv(): number | undefined {\n    const maxRetries = process.env.MODEL_PROVIDER_MAX_RETRIES;\n    return maxRetries ? parseInt(maxRetries, 10) : undefined;\n  }\n\n  // Get retry delay from environment variables\n  private getRetryDelayFromEnv(): number | undefined {\n    const retryDelay = process.env.MODEL_PROVIDER_RETRY_DELAY;\n    return retryDelay ? parseInt(retryDelay, 10) : undefined;\n  }\n\n  // Create provider with validation\n  createWithValidation(config: ModelProviderConfig & { providerType: string }): ModelProvider {\n    this.validateConfig(config);\n    return this.createCustom(config);\n  }\n\n  // Validate provider configuration\n  private validateConfig(config: ModelProviderConfig & { providerType: string }): void {\n    if (!config.apiKey) {\n      throw new Error('API key is required');\n    }\n\n    if (!config.providerType) {\n      throw new Error('Provider type is required');\n    }\n\n    const supportedProviders = ['openai', 'anthropic'];\n    if (!supportedProviders.includes(config.providerType.toLowerCase())) {\n      throw new Error(`Unsupported provider type: ${config.providerType}. Supported types: ${supportedProviders.join(', ')}`);\n    }\n\n    // Provider-specific validation\n    switch (config.providerType.toLowerCase()) {\n      case 'openai':\n        if (!config.apiKey.startsWith('sk-')) {\n          throw new Error('Invalid OpenAI API key format');\n        }\n        break;\n      case 'anthropic':\n        if (!config.apiKey.startsWith('sk-ant-')) {\n          throw new Error('Invalid Anthropic API key format');\n        }\n        break;\n    }\n  }\n\n  // Get registry\n  getRegistry(): ModelProviderRegistry {\n    return this.registry;\n  }\n}\n\n// Convenience functions for creating providers\nexport function createOpenAIProviderFromEnv(): ModelProvider {\n  const factory = new ProviderFactory();\n  return factory.createFromEnv('openai');\n}\n\nexport function createAnthropicProviderFromEnv(): ModelProvider {\n  const factory = new ProviderFactory();\n  return factory.createFromEnv('anthropic');\n}\n\nexport function createProviderFromConfig(config: {\n  type: 'openai' | 'anthropic';\n  apiKey: string;\n  baseURL?: string;\n  defaultModel?: string;\n  timeout?: number;\n  maxRetries?: number;\n  retryDelay?: number;\n}): ModelProvider {\n  const factory = new ProviderFactory();\n  return factory.createCustom({\n    providerType: config.type,\n    apiKey: config.apiKey,\n    baseURL: config.baseURL,\n    defaultModel: config.defaultModel,\n    timeout: config.timeout,\n    maxRetries: config.maxRetries,\n    retryDelay: config.retryDelay,\n  });\n}\n\n// Auto-detect provider from API key\nexport function createProviderFromApiKey(apiKey: string, options?: Partial<ModelProviderConfig>): ModelProvider {\n  const factory = new ProviderFactory();\n  \n  if (apiKey.startsWith('sk-') && !apiKey.startsWith('sk-ant-')) {\n    // OpenAI API key\n    return factory.createOpenAI({\n      apiKey,\n      ...options\n    });\n  } else if (apiKey.startsWith('sk-ant-')) {\n    // Anthropic API key\n    return factory.createAnthropic({\n      apiKey,\n      ...options\n    });\n  } else {\n    throw new Error('Unable to detect provider type from API key format');\n  }\n}\n\n// Provider configuration presets\nexport const ProviderPresets = {\n  // OpenAI presets\n  openai: {\n    gpt4: (apiKey: string) => createProviderFromConfig({\n      type: 'openai',\n      apiKey,\n      defaultModel: 'gpt-4'\n    }),\n    gpt4Turbo: (apiKey: string) => createProviderFromConfig({\n      type: 'openai',\n      apiKey,\n      defaultModel: 'gpt-4-turbo'\n    }),\n    gpt35Turbo: (apiKey: string) => createProviderFromConfig({\n      type: 'openai',\n      apiKey,\n      defaultModel: 'gpt-3.5-turbo'\n    }),\n  },\n  \n  // Anthropic presets\n  anthropic: {\n    claude3Opus: (apiKey: string) => createProviderFromConfig({\n      type: 'anthropic',\n      apiKey,\n      defaultModel: 'claude-3-opus-20240229'\n    }),\n    claude3Sonnet: (apiKey: string) => createProviderFromConfig({\n      type: 'anthropic',\n      apiKey,\n      defaultModel: 'claude-3-sonnet-20240229'\n    }),\n    claude3Haiku: (apiKey: string) => createProviderFromConfig({\n      type: 'anthropic',\n      apiKey,\n      defaultModel: 'claude-3-haiku-20240307'\n    }),\n  }\n};\n\n// Export singleton factory instance\nexport const providerFactory = new ProviderFactory();\n\n// Export all provider types and configurations\nexport type {\n  ModelProvider,\n  ModelProviderConfig\n} from './model-provider';\n\nexport type {\n  OpenAIProviderConfig\n} from './openai-provider';\n\nexport type {\n  AnthropicProviderConfig\n} from './anthropic-provider';\n\nexport {\n  OpenAIProvider,\n  createOpenAIProvider,\n  createDefaultOpenAIProvider\n} from './openai-provider';\n\nexport {\n  AnthropicProvider,\n  createAnthropicProvider,\n  createDefaultAnthropicProvider\n} from './anthropic-provider';\n","import { z } from \"zod/v4\";\nimport { StateConstraint } from \"./types\";\nimport { ToolValidationError } from \"./errors\";\nimport { tool, BaseTool, ToolExecutionContext } from \"@cloudbase/agent-tools\";\n\n/**\n * Helper functions for tool creation and management\n */\n\n/**\n * Create a tool definition with validation\n */\nfunction createTool<TState extends StateConstraint = StateConstraint>(\n  name: string,\n  description: string,\n  handler: (\n    input: any,\n    context: ToolExecutionContext & { state?: TState }\n  ) => Promise<any>,\n  options?: {\n    schema?: z.ZodObject<any>;\n    requiresApproval?: boolean;\n  }\n) {\n  if (!name || typeof name !== \"string\") {\n    throw new ToolValidationError(\"Tool name must be a non-empty string\");\n  }\n\n  if (!description || typeof description !== \"string\") {\n    throw new ToolValidationError(\n      \"Tool description must be a non-empty string\"\n    );\n  }\n\n  if (!handler || typeof handler !== \"function\") {\n    throw new ToolValidationError(\"Tool handler must be a function\");\n  }\n\n  return tool(handler as any, {\n    name,\n    description,\n    schema: options?.schema || (z.object({}) as any),\n    requiresApproval: options?.requiresApproval || false,\n  });\n}\n\n/**\n * Create a tool with Zod schema validation\n */\nexport function createTypedTool<\n  TInput = any,\n  TState extends StateConstraint = StateConstraint,\n>(\n  name: string,\n  description: string,\n  schema: z.ZodObject<any>,\n  handler: (\n    input: TInput,\n    context: ToolExecutionContext & { state?: TState }\n  ) => Promise<unknown>,\n  options?: {\n    requiresApproval?: boolean;\n  }\n) {\n  return createTool(\n    name,\n    description,\n    async (\n      input: unknown,\n      context: ToolExecutionContext & { state?: TState }\n    ) => {\n      // Validate input against schema\n      const validatedInput = schema.parse(input);\n      return handler(validatedInput as TInput, context);\n    },\n    {\n      schema,\n      requiresApproval: options?.requiresApproval,\n    }\n  );\n}\n\n/**\n * Create a tool with input/output logging\n */\nexport function createLoggedTool<\n  TState extends StateConstraint = StateConstraint,\n>(\n  name: string,\n  description: string,\n  handler: (\n    input: any,\n    context: ToolExecutionContext & { state?: TState }\n  ) => Promise<any>,\n  options?: {\n    schema?: z.ZodObject<any>;\n    requiresApproval?: boolean;\n    logLevel?: \"debug\" | \"info\" | \"warn\" | \"error\";\n  }\n): BaseTool<any, TState> {\n  const logLevel = options?.logLevel || \"info\";\n\n  return createTool(\n    name,\n    description,\n    async (\n      input: unknown,\n      context: ToolExecutionContext & { state?: TState }\n    ) => {\n      const startTime = Date.now();\n\n      try {\n        if (logLevel === \"debug\" || logLevel === \"info\") {\n          console.log(`[${name}] Input:`, input);\n        }\n\n        const result = await handler(input, context);\n\n        const executionTime = Date.now() - startTime;\n\n        if (logLevel === \"debug\" || logLevel === \"info\") {\n          console.log(`[${name}] Output:`, result);\n          console.log(`[${name}] Execution time: ${executionTime}ms`);\n        }\n\n        return result;\n      } catch (error) {\n        const executionTime = Date.now() - startTime;\n\n        if (logLevel === \"error\" || logLevel === \"warn\") {\n          console.error(`[${name}] Error after ${executionTime}ms:`, error);\n        }\n\n        throw error;\n      }\n    },\n    options\n  );\n}\n\n/**\n * Create a tool with retry logic\n */\nexport function createRetryTool<\n  TState extends StateConstraint = StateConstraint,\n>(\n  name: string,\n  description: string,\n  handler: (\n    input: any,\n    context: ToolExecutionContext & { state?: TState }\n  ) => Promise<any>,\n  options?: {\n    schema?: z.ZodObject<any>;\n    requiresApproval?: boolean;\n    maxRetries?: number;\n    retryDelay?: number;\n    retryCondition?: (error: Error) => boolean;\n  }\n): BaseTool<any, TState> {\n  const maxRetries = options?.maxRetries || 3;\n  const retryDelay = options?.retryDelay || 1000;\n  const retryCondition = options?.retryCondition || (() => true);\n\n  return createTool(\n    name,\n    description,\n    async (\n      input: unknown,\n      context: ToolExecutionContext & { state?: TState }\n    ) => {\n      let lastError: Error;\n\n      for (let attempt = 0; attempt <= maxRetries; attempt++) {\n        try {\n          return await handler(input, context);\n        } catch (error) {\n          lastError = error instanceof Error ? error : new Error(String(error));\n\n          if (attempt === maxRetries || !retryCondition(lastError)) {\n            throw lastError;\n          }\n\n          // Wait before retry\n          await new Promise((resolve) =>\n            setTimeout(resolve, retryDelay * (attempt + 1))\n          );\n        }\n      }\n\n      throw lastError!;\n    },\n    options\n  );\n}\n\n/**\n * Create a tool with timeout\n */\nexport function createTimeoutTool<\n  TState extends StateConstraint = StateConstraint,\n>(\n  name: string,\n  description: string,\n  handler: (\n    input: any,\n    context: ToolExecutionContext & { state?: TState }\n  ) => Promise<any>,\n  options?: {\n    schema?: z.ZodObject<any>;\n    requiresApproval?: boolean;\n    timeout?: number;\n  }\n): BaseTool<any, TState> {\n  const timeout = options?.timeout || 30000; // 30 seconds default\n\n  return createTool(\n    name,\n    description,\n    async (\n      input: unknown,\n      context: ToolExecutionContext & { state?: TState }\n    ) => {\n      return Promise.race([\n        handler(input, context),\n        new Promise((_, reject) => {\n          setTimeout(() => {\n            reject(new Error(`Tool '${name}' timed out after ${timeout}ms`));\n          }, timeout);\n        }),\n      ]);\n    },\n    options\n  );\n}\n\n/**\n * Create a tool that combines multiple tools\n */\nexport function createCompositeTool<\n  TState extends StateConstraint = StateConstraint,\n>(\n  name: string,\n  description: string,\n  tools: BaseTool<any, TState>[],\n  options?: {\n    requiresApproval?: boolean;\n    executionMode?: \"sequential\" | \"parallel\";\n  }\n): BaseTool<any, TState> {\n  const executionMode = options?.executionMode || \"sequential\";\n\n  return createTool(\n    name,\n    description,\n    async (\n      input: unknown,\n      context: ToolExecutionContext & { state?: TState }\n    ) => {\n      if (!Array.isArray(input)) {\n        throw new Error(\n          \"Composite tool input must be an array of tool executions\"\n        );\n      }\n\n      const results: unknown[] = [];\n\n      if (executionMode === \"parallel\") {\n        const promises = input.map(async (toolInput: any) => {\n          const toolName = toolInput.toolName;\n          const tool = tools.find((t) => t.name === toolName);\n\n          if (!tool) {\n            throw new Error(`Tool '${toolName}' not found in composite tool`);\n          }\n\n          if (!tool.invoke) {\n            throw new Error(\n              `Tool '${toolName}' has no invoke (client-side tool)`\n            );\n          }\n\n          return tool.invoke(toolInput.input, context);\n        });\n\n        const parallelResults = await Promise.all(promises);\n        results.push(...parallelResults);\n      } else {\n        for (const toolInput of input) {\n          const toolName = toolInput.toolName;\n          const tool = tools.find((t) => t.name === toolName);\n\n          if (!tool) {\n            throw new Error(`Tool '${toolName}' not found in composite tool`);\n          }\n\n          if (!tool.invoke) {\n            throw new Error(\n              `Tool '${toolName}' has no invoke (client-side tool)`\n            );\n          }\n\n          const result = await tool.invoke(toolInput.input, context);\n          results.push(result);\n        }\n      }\n\n      return results;\n    },\n    {\n      requiresApproval:\n        options?.requiresApproval || tools.some((t) => t.requiresApproval),\n    }\n  );\n}\n","import { randomUUID } from 'node:crypto';\nimport { Message, MessageMetadata, StateConstraint } from './types';\n\n/**\n * Conversation management utilities for handling conversations and state in message metadata\n */\nexport class ConversationManager<TState extends StateConstraint = StateConstraint> {\n  public conversations: Map<string, Message[]> = new Map();\n  private currentState: Map<string, TState> = new Map();\n\n  /**\n   * Create a message with state metadata\n   */\n  createMessageWithState(\n    role: Message['role'],\n    content: string,\n    conversationId: string,\n    options?: {\n      runId?: string;\n      userId?: string;\n      toolCalls?: any[];\n      toolCallId?: string;\n    }\n  ): Message {\n    const currentState = this.currentState.get(conversationId) || ({} as TState);\n\n    return {\n      id: randomUUID(),\n      role,\n      content,\n      timestamp: new Date(),\n      toolCalls: options?.toolCalls,\n      toolCallId: options?.toolCallId,\n      metadata: {\n        state: this.deepClone(currentState),\n        conversationId,\n        runId: options?.runId,\n        userId: options?.userId\n      }\n    };\n  }\n\n  /**\n   * Extract current state from messages\n   */\n  extractStateFromMessages(messages: Message[]): TState {\n    const lastMessage = messages[messages.length - 1];\n    if (lastMessage?.metadata?.state) {\n      return lastMessage.metadata.state as TState;\n    }\n    return {} as TState;\n  }\n\n  /**\n   * Get conversation messages\n   */\n  getConversationMessages(conversationId: string): Message[] {\n    return this.conversations.get(conversationId) || [];\n  }\n\n  /**\n   * Add messages to conversation\n   */\n  addMessages(conversationId: string, messages: Message[]): void {\n    const existing = this.conversations.get(conversationId) || [];\n    this.conversations.set(conversationId, [...existing, ...messages]);\n  }\n\n  /**\n   * Get current state for conversation\n   */\n  getCurrentState(conversationId: string): TState {\n    return this.currentState.get(conversationId) || ({} as TState);\n  }\n\n  /**\n   * Update state for conversation\n   */\n  updateState(conversationId: string, stateChanges: Partial<TState>): void {\n    const current = this.currentState.get(conversationId) || ({} as TState);\n    this.currentState.set(conversationId, { ...current, ...stateChanges });\n  }\n\n  /**\n   * Clear conversation data\n   */\n  clearConversation(conversationId: string): void {\n    this.conversations.delete(conversationId);\n    this.currentState.delete(conversationId);\n  }\n\n  /**\n   * Deep clone an object to prevent reference sharing\n   */\n  private deepClone<T>(obj: T): T {\n    if (obj === null || typeof obj !== 'object') {\n      return obj;\n    }\n    \n    if (obj instanceof Date) {\n      return new Date(obj.getTime()) as T;\n    }\n    \n    if (Array.isArray(obj)) {\n      return obj.map(item => this.deepClone(item)) as T;\n    }\n    \n    if (typeof obj === 'object') {\n      const cloned = {} as T;\n      for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          cloned[key] = this.deepClone(obj[key]);\n        }\n      }\n      return cloned;\n    }\n    \n    return obj;\n  }\n}\n","export { AGKitAgent } from './agent';\nexport { toAGUIAgent } from './converter';\n\n","/**\n * Error thrown when parameters are incorrect\n */\nexport class ParamError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = 'ParamError';\n  }\n}\n\n/**\n * TDAI API Exception\n */\nexport class TDAIException extends Error {\n  public code?: string | number;\n  public message: string;\n  public requestId?: string;\n\n  constructor(data: { code?: string | number; message?: string; req_id?: string }, requestId?: string) {\n    super(data.message);\n    this.name = 'TDAIException';\n    this.code = data.code;\n    this.message = data.message || '';\n    this.requestId = requestId || data.req_id;\n  }\n\n  toString(): string {\n    if (this.requestId) {\n      return `<${this.constructor.name}: (code=${this.code}, message=${this.message}, request_id=${this.requestId})>`;\n    } else {\n      return `<${this.constructor.name}: (code=${this.code}, message=${this.message})>`;\n    }\n  }\n}","import { TDAIException } from './errors';\n\n/**\n * Abstract base class for API communication stubs\n */\nexport abstract class Stub {\n  abstract post(path: string, body: Record<string, any>, timeout?: number): Promise<any>;\n  abstract close(): void;\n}\n\n/**\n * HTTP client configuration options\n */\nexport interface HttpStubOptions {\n  endpoint: string;\n  apiKey: string;\n  serviceId: string;\n  timeout?: number;\n}\n\n/**\n * HTTP client class for communicating with a specified endpoint\n */\nexport class HttpStub extends Stub {\n  private endpoint: string;\n  private timeout: number;\n  private headers: Record<string, string>;\n\n  constructor(options: HttpStubOptions) {\n    super();\n    this.endpoint = options.endpoint;\n    this.timeout = options.timeout || 10000; // Default 10 seconds in milliseconds\n    this.headers = {\n      'x-tdai-service-id': options.serviceId,\n      'Authorization': `Bearer ${options.apiKey}`,\n      'Content-Type': 'application/json',\n    };\n  }\n\n  /**\n   * Send a POST request to the specified path\n   */\n  async post(path: string, body: Record<string, any>, timeout?: number): Promise<any> {\n    const requestTimeout = timeout ? timeout * 1000 : this.timeout;\n    const url = `${this.endpoint}${path}`;\n    \n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), requestTimeout);\n\n      const response = await fetch(url, {\n        method: 'POST',\n        headers: this.headers,\n        body: JSON.stringify(body),\n        signal: controller.signal,\n      });\n\n      clearTimeout(timeoutId);\n\n      if (!response.ok) {\n        throw new Error(`HTTP error! status: ${response.status}`);\n      }\n\n      const responseText = await response.text();\n\n      const data = JSON.parse(responseText);\n      \n      if (data.code !== 0) {\n        const requestId = response.headers.get('x-qcloud-transaction-id');\n        throw new TDAIException(data, requestId || undefined);\n      }\n\n      return data.data;\n    } catch (error) {\n      if (error instanceof TDAIException) {\n        throw error;\n      }\n      throw new Error(`Request failed: ${error instanceof Error ? error.message : String(error)}`);\n    }\n  }\n\n  /**\n   * Close the HTTP client connection\n   * Note: fetch API doesn't require explicit cleanup, but this method is provided for interface compatibility\n   */\n  close(): void {\n    // No explicit cleanup needed for fetch API\n  }\n}","import { ParamError } from \"./errors\";\nimport { Stub, HttpStub, HttpStubOptions } from \"./stub\";\nimport { QueryOptions, SearchOptions, WhereClause, Message } from \"./params\";\n\n/**\n * Configuration options for MemoryClient\n */\nexport interface IMemoryClientOptions {\n  endpoint: string;\n  apiKey: string;\n  memoryId: string;\n  defaultActorId?: string;\n  timeout?: number;\n  stub?: Stub;\n}\n\nexport interface IEvent extends Record<string, any> {\n  event_id: string;\n  created_at: number;\n  updated_at: number; // 1760501605;\n}\n\n/**\n * High-level Agent Memory client with essential operations\n */\nexport class MemoryClient {\n  private defaultMemoryId: string;\n  private defaultActorId?: string;\n  private stub: Stub;\n\n  constructor(options: IMemoryClientOptions) {\n    this.defaultMemoryId = options.memoryId;\n    this.defaultActorId = options.defaultActorId;\n\n    if (options.stub) {\n      this.stub = options.stub;\n    } else {\n      this.stub = new HttpStub({\n        endpoint: options.endpoint || \"https://memory.tdai.tencentyun.com\",\n        apiKey: options.apiKey,\n        serviceId: options.memoryId,\n        timeout: options.timeout,\n      });\n    }\n  }\n\n  /**\n   * Close the client connection\n   */\n  close(): void {\n    this.stub.close();\n  }\n\n  private getMemoryId(memoryId?: string): string {\n    return memoryId || this.defaultMemoryId;\n  }\n\n  private getActorId(actorId?: string): string {\n    if (actorId) {\n      return actorId;\n    }\n    if (this.defaultActorId) {\n      return this.defaultActorId;\n    }\n    throw new ParamError(\"actor_id is required\");\n  }\n\n  /**\n   * Create a new session\n   */\n  async createSession(\n    options: {\n      name?: string;\n      memoryId?: string;\n      actorId?: string;\n    } = {}\n  ): Promise<any> {\n    const requestBody: Record<string, any> = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n    };\n\n    if (options.name !== undefined) {\n      requestBody.name = options.name;\n    }\n\n    return this.stub.post(\"/memory/v1/session/create\", requestBody);\n  }\n\n  /**\n   * Query sessions based on conditions\n   */\n  async querySessions(\n    options: {\n      memoryId?: string;\n      actorId?: string;\n    } & QueryOptions = {}\n  ): Promise<any> {\n    const requestBody: Record<string, any> = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n    };\n\n    if (options.orderBy !== undefined) {\n      requestBody.order_by = options.orderBy;\n    }\n    if (options.limit !== undefined) {\n      requestBody.limit = options.limit;\n    }\n    if (options.offset !== undefined) {\n      requestBody.offset = options.offset;\n    }\n\n    return this.stub.post(\"/memory/v1/session/query\", requestBody);\n  }\n\n  /**\n   * Update an existing session\n   */\n  async updateSession(options: {\n    sessionId: string;\n    name: string;\n    memoryId?: string;\n    actorId?: string;\n  }): Promise<any> {\n    const requestBody = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n      session_id: options.sessionId,\n      name: options.name,\n    };\n\n    return this.stub.post(\"/memory/v1/session/update\", requestBody);\n  }\n\n  /**\n   * Delete an existing session\n   */\n  async deleteSession(options: {\n    sessionId: string;\n    memoryId?: string;\n    actorId?: string;\n  }): Promise<any> {\n    const requestBody = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n      session_id: options.sessionId,\n    };\n\n    return this.stub.post(\"/memory/v1/session/delete\", requestBody);\n  }\n\n  /**\n   * Search sessions based on conditions and keywords\n   */\n  async searchSessions(\n    options: {\n      content: string;\n      memoryId?: string;\n      actorId?: string;\n    } & Omit<QueryOptions, \"offset\">\n  ): Promise<any> {\n    const requestBody: Record<string, any> = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n      content: options.content,\n    };\n\n    if (options.orderBy !== undefined) {\n      requestBody.order_by = options.orderBy;\n    }\n    if (options.limit !== undefined) {\n      requestBody.limit = options.limit;\n    }\n\n    return this.stub.post(\"/memory/v1/session/search\", requestBody);\n  }\n\n  /**\n   * Append events to a session\n   */\n  async appendEvent(options: {\n    sessionId: string;\n    messages: Record<string, any>;\n    memoryId?: string;\n    actorId?: string;\n  }): Promise<{ event_id: string }> {\n    const requestBody = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n      session_id: options.sessionId,\n      messages: options.messages,\n    };\n\n    return this.stub.post(\"/memory/v1/event/append\", requestBody);\n  }\n\n  /**\n   * Query events based on conditions\n   */\n  async queryEvents(\n    options: {\n      memoryId?: string;\n      actorId?: string;\n      sessionId?: string;\n      where?: WhereClause;\n    } & QueryOptions = {}\n  ): Promise<{ events: IEvent[]; total_count: number }> {\n    const requestBody: Record<string, any> = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n    };\n\n    if (options.sessionId !== undefined) {\n      requestBody.session_id = options.sessionId;\n    }\n    if (options.where !== undefined) {\n      requestBody.where = options.where;\n    }\n    if (options.orderBy !== undefined) {\n      requestBody.order_by = options.orderBy;\n    }\n    if (options.limit !== undefined) {\n      requestBody.limit = options.limit;\n    }\n    if (options.offset !== undefined) {\n      requestBody.offset = options.offset;\n    }\n\n    return this.stub.post(\"/memory/v1/event/query\", requestBody);\n  }\n\n  /**\n   * Delete an event from a session\n   */\n  async deleteEvent(options: {\n    sessionId: string;\n    eventId: string;\n    memoryId?: string;\n    actorId?: string;\n  }): Promise<any> {\n    const requestBody = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n      session_id: options.sessionId,\n      event_id: options.eventId,\n    };\n\n    return this.stub.post(\"/memory/v1/event/delete\", requestBody);\n  }\n\n  /**\n   * Set state for a session\n   */\n  async setState(options: {\n    sessionId: string;\n    state: Record<string, any>;\n    memoryId?: string;\n    actorId?: string;\n  }): Promise<any> {\n    const requestBody = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n      session_id: options.sessionId,\n      state: options.state,\n    };\n\n    return this.stub.post(\"/memory/v1/state/set\", requestBody);\n  }\n\n  /**\n   * Get state for a session\n   */\n  async getStates(options: {\n    sessionId: string;\n    keys?: string[];\n    memoryId?: string;\n    actorId?: string;\n  }): Promise<any> {\n    const requestBody = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n      session_id: options.sessionId,\n      keys: options.keys,\n    };\n\n    return this.stub.post(\"/memory/v1/state/get\", requestBody);\n  }\n\n  /**\n   * Get all states for an actor in a memory\n   */\n  async getAllStates(options: {\n    sessionId: string;\n    memoryId?: string;\n    actorId?: string;\n  }): Promise<any> {\n    const requestBody = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n      session_id: options.sessionId,\n    };\n\n    return this.stub.post(\"/memory/v1/state/get_all\", requestBody);\n  }\n\n  /**\n   * Delete specified state keys for a session\n   */\n  async deleteStates(options: {\n    sessionId: string;\n    keys?: string[];\n    memoryId?: string;\n    actorId?: string;\n  }): Promise<any> {\n    const requestBody = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n      session_id: options.sessionId,\n      keys: options.keys,\n    };\n\n    return this.stub.post(\"/memory/v1/state/delete\", requestBody);\n  }\n\n  /**\n   * Flush all states for a session\n   */\n  async flushStates(options: {\n    sessionId: string;\n    memoryId?: string;\n    actorId?: string;\n  }): Promise<any> {\n    const requestBody = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n      session_id: options.sessionId,\n    };\n\n    return this.stub.post(\"/memory/v1/state/flush\", requestBody);\n  }\n\n  /**\n   * Append records to a session\n   */\n  async appendRecord(options: {\n    sessionId: string;\n    content: string;\n    strategy: string;\n    memoryId?: string;\n    actorId?: string;\n  }): Promise<any> {\n    const requestBody = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n      session_id: options.sessionId,\n      content: options.content,\n      strategy: options.strategy,\n    };\n\n    return this.stub.post(\"/memory/v1/record/append\", requestBody);\n  }\n\n  /**\n   * Query records based on conditions\n   */\n  async queryRecords(\n    options: {\n      memoryId?: string;\n      actorId?: string;\n      sessionId?: string;\n      strategies?: string[];\n      where?: WhereClause;\n    } & QueryOptions = {}\n  ): Promise<{\n    records: {\n      created_at: number;\n      updated_at: number;\n      event_ids: string;\n      record_content: string;\n      record_id: string;\n      score: number;\n      strategy_name: string;\n    }[];\n    total_count: number;\n  }> {\n    const requestBody: Record<string, any> = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n    };\n\n    if (options.sessionId !== undefined) {\n      requestBody.session_id = options.sessionId;\n    }\n    if (options.strategies !== undefined) {\n      requestBody.strategies = options.strategies;\n    }\n    if (options.where !== undefined) {\n      requestBody.where = options.where;\n    }\n    if (options.orderBy !== undefined) {\n      requestBody.order_by = options.orderBy;\n    }\n    if (options.limit !== undefined) {\n      requestBody.limit = options.limit;\n    }\n    if (options.offset !== undefined) {\n      requestBody.offset = options.offset;\n    }\n\n    return this.stub.post(\"/memory/v1/record/query\", requestBody);\n  }\n\n  /**\n   * Update an existing record\n   */\n  async updateRecord(options: {\n    sessionId: string;\n    recordId: string;\n    content: string;\n    memoryId?: string;\n    actorId?: string;\n  }): Promise<any> {\n    const requestBody = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n      session_id: options.sessionId,\n      record_id: options.recordId,\n      content: options.content,\n    };\n\n    return this.stub.post(\"/memory/v1/record/update\", requestBody);\n  }\n\n  /**\n   * Delete an existing record\n   */\n  async deleteRecord(options: {\n    sessionId: string;\n    recordId: string;\n    memoryId?: string;\n    actorId?: string;\n  }): Promise<any> {\n    const requestBody = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n      session_id: options.sessionId,\n      record_id: options.recordId,\n    };\n\n    return this.stub.post(\"/memory/v1/record/delete\", requestBody);\n  }\n\n  /**\n   * Search records based on conditions and keywords\n   */\n  async searchRecords(\n    options: {\n      content: string;\n      memoryId?: string;\n      actorId?: string;\n      sessionId?: string;\n      strategies?: string[];\n      where?: WhereClause;\n    } & Omit<QueryOptions, \"offset\">\n  ): Promise<{\n    records: {\n      created_at: number;\n      updated_at: number;\n      event_ids: string;\n      record_content: string;\n      record_id: string;\n      score: number;\n      strategy_name: string;\n    }[];\n    total_count: number;\n  }> {\n    const requestBody: Record<string, any> = {\n      memory_id: this.getMemoryId(options.memoryId),\n      actor_id: this.getActorId(options.actorId),\n      content: options.content,\n    };\n\n    if (options.sessionId !== undefined) {\n      requestBody.session_id = options.sessionId;\n    }\n    if (options.strategies !== undefined) {\n      requestBody.strategies = options.strategies;\n    }\n    if (options.where !== undefined) {\n      requestBody.where = options.where;\n    }\n    if (options.orderBy !== undefined) {\n      requestBody.order_by = options.orderBy;\n    }\n    if (options.limit !== undefined) {\n      requestBody.limit = options.limit;\n    }\n\n    return this.stub.post(\"/memory/v1/record/search\", requestBody);\n  }\n}\n","/**\n * Sort order constants\n */\nexport class Order {\n  /** Ascending sort order */\n  static readonly ASCENDING = 1;\n  \n  /** Descending sort order */\n  static readonly DESCENDING = -1;\n}\n\n/**\n * Common types used across the SDK\n */\nexport interface QueryOptions {\n  orderBy?: Record<string, number>;\n  limit?: number;\n  offset?: number;\n}\n\nexport interface SearchOptions extends QueryOptions {\n  content: string;\n}\n\nexport interface WhereClause {\n  [key: string]: any;\n}\n\nexport interface Message {\n  role: string;\n  content: string;\n}","import {\n  BaseMemory,\n  IMemoryEvent,\n  ListOptions,\n  AddOptions,\n  DeleteOptions,\n  RetrieveOptions,\n  ClearOptions,\n} from \"./memory-base\";\nimport { Order, QueryOptions } from \"../tdaimemory\";\nimport {\n  MemoryClient,\n  IMemoryClientOptions,\n  IEvent as ITDAIEvent,\n} from \"../tdaimemory/client\";\n\n/**\n * @fileoverview TDAI cloud-based memory implementation for production environments\n *\n * TDAI Memory implementation providing cloud-based persistent storage with semantic search,\n * advanced querying capabilities, and production-grade scalability through TDAI services.\n *\n * @example\n * ```typescript\n * const memory = new TDAIMemory({\n *   sessionId: 'user-session-123',\n *   clientOptions: { apiKey: 'your-api-key' },\n *   useCache: true\n * });\n * await memory.add({ message: { id: '1', role: 'user', content: 'Hello' } });\n * const results = await memory.retrieve('greeting');\n * ```\n */\nexport class TDAIMemory extends BaseMemory {\n  /** TDAI client instance for cloud operations */\n  private client: MemoryClient;\n  /** Session identifier for memory isolation */\n  private sessionId: string;\n  /** Cache storage for improved performance */\n  private cachedMap: Map<string, any>;\n  /** Whether local caching is enabled */\n  private useCache: boolean;\n  /** Whether to enable automatic context management */\n  private enableContextManagement: boolean;\n\n  /**\n   * Creates a new TDAIMemory instance\n   * @param options - Configuration options\n   * @param options.sessionId - Unique session identifier\n   * @param options.client - Optional pre-configured TDAI client\n   * @param options.clientOptions - TDAI client configuration if client not provided\n   * @param options.useCache - Enable local caching for better performance\n   * @param options.enableContextManagement - Whether to automatically manage context after adding events (default: true)\n   */\n  constructor(\n    options: {\n      sessionId: string;\n      client?: MemoryClient;\n      clientOptions?: IMemoryClientOptions;\n      useCache?: boolean;\n      enableContextManagement?: boolean;\n    } & ConstructorParameters<typeof BaseMemory>[0]\n  ) {\n    super(options);\n    if (!options.client && !options.clientOptions) {\n      throw new Error(\"Either client or clientOptions must be provided\");\n    }\n    this.client =\n      options.client ||\n      new MemoryClient(options.clientOptions as IMemoryClientOptions);\n    this.sessionId = options.sessionId;\n    this.cachedMap = new Map<string, any>();\n    this.useCache = options.useCache ?? false;\n    this.enableContextManagement = options.enableContextManagement ?? options.thresholds ? true : false;\n  }\n\n  /**\n   * Returns events from TDAI service with filtering, pagination, and token limiting\n   * @param options - Optional filtering and pagination options\n   * @returns Promise resolving to filtered array of memory events\n   */\n  public async list(options?: ListOptions): Promise<IMemoryEvent[]> {\n    try {\n      // Build query parameters\n      const queryParams: QueryOptions & { sessionId: string } = {\n        sessionId: this.sessionId,\n      };\n\n      // Add pagination parameters\n      if (options?.limit) {\n        queryParams.limit = options.limit;\n      }\n      if (options?.offset) {\n        queryParams.offset = options.offset;\n      }\n\n      // Add ordering\n      if (options?.order) {\n        queryParams.orderBy = {\n          created_at:\n            options.order === \"desc\" ? Order.DESCENDING : Order.ASCENDING,\n        };\n      }\n\n      const { events = [], total_count } =\n        await this.client.queryEvents(queryParams);\n\n      let memoryEvents = this.convertTDAIEventsToMemoryEvents(events);\n\n      // Trigger context management if enabled\n      if (this.enableContextManagement) {\n        await this.manageContext({\n          sessionId: this.sessionId,\n          events: memoryEvents,\n        });\n      }\n\n      // Apply token limiting if specified\n      if (options?.maxTokens) {\n        memoryEvents = this.tokenTrimmer.trimMessages(\n          memoryEvents,\n          options.maxTokens\n        );\n      }\n\n      // Cache results if caching is enabled\n      if (this.useCache) {\n        this.cachedMap.set(\"events\", events);\n        this.cachedMap.set(\"total_count\", total_count);\n      }\n\n      return options?.order === \"desc\" ? memoryEvents.reverse() : memoryEvents;\n    } catch (error) {\n      console.error(\"Error listing events:\", error);\n      return [];\n    }\n  }\n\n  /**\n   * Add a single event to TDAI cloud storage\n   * @param event - The memory event to store\n   * @param options - Optional session options\n   */\n  public async add(event: IMemoryEvent, options?: AddOptions): Promise<void> {\n    try {\n      await this.client.appendEvent({\n        sessionId: this.sessionId,\n        messages: {\n          role: event.message.role,\n          content: event.message.content,\n          metadata: {\n            ...event.state,\n            messageId: event.message.id,\n            timestamp: event.message.timestamp?.toISOString(),\n            toolCalls: event.message.toolCalls,\n            toolCallId: event.message.toolCallId,\n          },\n        },\n      });\n      this.cachedMap.clear();\n    } catch (error) {\n      console.error(\"Error adding event:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Add multiple events efficiently with sequential processing\n   * @param list - Array of memory events to store\n   */\n  public async addList(list: IMemoryEvent[], options?: AddOptions): Promise<void> {\n    // Temporarily disable context management for batch operations\n    const originalContextManagement = this.enableContextManagement;\n    this.enableContextManagement = false;\n\n    try {\n      for (const event of list) {\n        await this.add(event, options);\n      }\n    } finally {\n      // Restore original setting\n      this.enableContextManagement = originalContextManagement;\n    }\n  }\n\n\n  // TODO: impl update event in tdaiclient\n  public async update({ sessionId, event }: { sessionId?: string, event: IMemoryEvent }) {\n\n  }\n\n  /**\n   * Delete an event from TDAI cloud storage\n   * @param idOrIndex - Event ID (string) or array index (number, not yet implemented)\n   */\n  public async delete(idOrIndex: string | number): Promise<void> {\n    if (typeof idOrIndex === \"string\") {\n      // Delete by event ID\n      await this.client.deleteEvent({\n        sessionId: this.sessionId,\n        eventId: idOrIndex,\n      });\n      this.cachedMap.clear();\n    } else {\n      // TODO: Consider supporting negative indices for recent events (-1, -2, etc.)\n      console.warn(\"Deleting by index is not yet implemented\", idOrIndex);\n      throw new Error(\"Deleting by index is not yet implemented\");\n\n      // Future implementation for index-based deletion:\n      // const { events = [] } = await this.client.queryEvents({\n      //   sessionId: this.sessionId,\n      // });\n      // if (idOrIndex >= 0 && idOrIndex < events.length) {\n      //   const eventToDelete = events[idOrIndex];\n      //   if (eventToDelete.event_id) {\n      //     await this.client.deleteEvent({\n      //       sessionId: this.sessionId,\n      //       eventId: eventToDelete.event_id,\n      //     });\n      //   }\n      // }\n      this.cachedMap.clear();\n    }\n  }\n\n  /**\n   * Retrieve events using TDAI's search capabilities\n   * @param query - Optional search query for content matching\n   * @returns Promise resolving to array of matching events\n   */\n  public async retrieve(query?: string): Promise<IMemoryEvent[]> {\n    if (!query) {\n      return this.list();\n    }\n\n    const { events = [] } = await this.client.queryEvents({\n      sessionId: this.sessionId,\n      where: {\n        content: {\n          // TODO: Replace with semantic similarity search\n          $eq: query,\n        },\n      },\n    });\n    return this.convertTDAIEventsToMemoryEvents(events);\n  }\n\n  /**\n   * Clear all events.\n   */\n  // public async clear(): Promise<void> {\n  //   return this.delete();\n  // }\n\n  /**\n   * Check if the session contains any events\n   * @returns Promise resolving to true if no events are stored\n   */\n  public async isEmpty(): Promise<boolean> {\n    return (await this.getCount()) === 0;\n  }\n\n  /**\n   * Get the current number of events stored in the session\n   * @returns Promise resolving to the count of stored events\n   */\n  public async getCount(): Promise<number> {\n    if (this.useCache && this.cachedMap.get(\"total_count\") !== undefined) {\n      return this.cachedMap.get(\"total_count\");\n    } else {\n      const { total_count } = await this.client.queryEvents({\n        sessionId: this.sessionId,\n      });\n      return total_count;\n    }\n  }\n\n  /**\n   * Convert TDAI events to IMemoryEvent format for compatibility\n   * @param events - Array of TDAI events to convert\n   * @returns Array of converted memory events\n   */\n  private convertTDAIEventsToMemoryEvents(\n    events: ITDAIEvent[]\n  ): IMemoryEvent[] {\n    return events.map((event) => ({\n      message: {\n        id:\n          event.metadata?.messageId || Math.random().toString(36).substr(2, 9),\n        role: event.role || \"user\",\n        content: event.content || \"\",\n        timestamp: event.metadata?.timestamp\n          ? new Date(event.metadata.timestamp)\n          : new Date(),\n        toolCalls: event.metadata?.toolCalls,\n        toolCallId: event.metadata?.toolCallId,\n      },\n      state: {\n        ...this.extractStateFromMetadata(event.metadata || {}),\n        ...(event.score !== undefined && { score: event.score }),\n      },\n    }));\n  }\n\n  /**\n   * Extract state from metadata, excluding message-specific fields\n   * @param metadata - Event metadata object\n   * @returns Cleaned state object without message fields\n   */\n  private extractStateFromMetadata(\n    metadata: Record<string, any>\n  ): Record<string, any> {\n    const { messageId, timestamp, toolCalls, toolCallId, ...state } = metadata;\n    return state;\n  }\n\n  /**\n   * Clean up branches - not supported by TDAI Memory\n   * @param keepBranches - Ignored parameter\n   * @throws Error indicating branch operations are not supported\n   */\n  public async cleanupBranches(keepBranches?: string[]): Promise<void> {\n    throw new Error(\"Branch operations are not supported by TDAI Memory\");\n  }\n}\n","/**\n * CloudBase Query Builder\n *\n * Implements query builder for Tencent CloudBase\n */\n\nimport {\n  IQueryBuilder,\n  IUpdateBuilder,\n  ComparisonOperator,\n} from \"../common/query-builder\";\n\n/**\n * CloudBase Query Builder implementation\n */\nexport class CloudBaseQueryBuilder implements IQueryBuilder {\n  private conditions: Record<string, any> = {};\n  private orConditions: any[] = [];\n  private db: any;\n\n  constructor(db: any) {\n    this.db = db;\n  }\n\n  where(field: string, operator: ComparisonOperator, value: any): this {\n    this.conditions[field] = this.buildOperator(operator, value);\n    return this;\n  }\n\n  and(field: string, operator: ComparisonOperator, value: any): this {\n    // In CloudBase, multiple conditions at the same level are implicitly AND\n    return this.where(field, operator, value);\n  }\n\n  or(conditions: IQueryBuilder[]): this {\n    this.orConditions = conditions.map((builder) => builder.build());\n    return this;\n  }\n\n  in(field: string, values: any[]): this {\n    const _ = this.db.command;\n    this.conditions[field] = _.in(values);\n    return this;\n  }\n\n  regex(field: string, pattern: string, options?: string): this {\n    this.conditions[field] = this.db.RegExp({\n      regexp: pattern,\n      options: options || \"i\",\n    });\n    return this;\n  }\n\n  build(): any {\n    if (this.orConditions.length > 0) {\n      const _ = this.db.command;\n      return _.or(this.orConditions);\n    }\n    return this.conditions;\n  }\n\n  clone(): IQueryBuilder {\n    const cloned = new CloudBaseQueryBuilder(this.db);\n    cloned.conditions = { ...this.conditions };\n    cloned.orConditions = [...this.orConditions];\n    return cloned;\n  }\n\n  /**\n   * Build CloudBase operator from generic operator\n   */\n  private buildOperator(operator: ComparisonOperator, value: any): any {\n    const _ = this.db.command;\n\n    const operatorMap: Record<ComparisonOperator, (v: any) => any> = {\n      eq: (v) => _.eq(v),\n      ne: (v) => _.neq(v),\n      gt: (v) => _.gt(v),\n      gte: (v) => _.gte(v),\n      lt: (v) => _.lt(v),\n      lte: (v) => _.lte(v),\n      in: (v) => _.in(v),\n      nin: (v) => _.nin(v),\n    };\n\n    // For equality, CloudBase allows direct value assignment\n    if (operator === \"eq\") {\n      return value;\n    }\n\n    const buildFn = operatorMap[operator];\n    return buildFn ? buildFn(value) : value;\n  }\n}\n\n/**\n * CloudBase Update Builder implementation\n */\nexport class CloudBaseUpdateBuilder implements IUpdateBuilder {\n  private updates: Record<string, any> = {};\n  private removes: string[] = [];\n  private increments: Record<string, number> = {};\n\n  set(field: string, value: any): this {\n    this.updates[field] = value;\n    return this;\n  }\n\n  setMultiple(updates: Record<string, any>): this {\n    Object.assign(this.updates, updates);\n    return this;\n  }\n\n  unset(field: string): this {\n    this.removes.push(field);\n    return this;\n  }\n\n  increment(field: string, value: number): this {\n    this.increments[field] = value;\n    return this;\n  }\n\n  build(): any {\n    // CloudBase uses a flat update object\n    const result: Record<string, any> = { ...this.updates };\n\n    // Handle increments by adding to the value\n    // Note: CloudBase doesn't have a direct $inc operator like MongoDB\n    // We need to handle this at the application level\n    Object.entries(this.increments).forEach(([field, value]) => {\n      // Store increment info for later processing\n      result[`__inc_${field}`] = value;\n    });\n\n    // Handle removes\n    this.removes.forEach((field) => {\n      result[field] = null; // CloudBase uses null to remove fields\n    });\n\n    return result;\n  }\n}\n","/**\n * CloudBase Adapter\n *\n * Implements database operations for Tencent CloudBase\n */\n\nimport { IDatabaseAdapter, QueryOptions } from \"../common/types\";\nimport { IQueryBuilder, IUpdateBuilder } from \"../common/query-builder\";\nimport { CloudBaseQueryBuilder, CloudBaseUpdateBuilder } from \"./cloudbase-query-builder\";\nimport { CloudBaseCollection, CloudBaseDatabase } from \"./types\";\n\nexport class CloudBaseAdapter implements IDatabaseAdapter {\n  constructor(private db: CloudBaseDatabase) {}\n\n  getCollection(name: string): CloudBaseCollection {\n    return this.db.collection(name);\n  }\n\n  async find<T = any>(\n    collection: CloudBaseCollection,\n    query: any,\n    options?: QueryOptions\n  ): Promise<T[]> {\n    let queryBuilder = collection.where(query);\n\n    if (options?.sort) {\n      // CloudBase only supports single field sorting\n      const sortField = Object.keys(options.sort)[0];\n      const sortOrder = options.sort[sortField] === 1 ? \"asc\" : \"desc\";\n      queryBuilder = queryBuilder.orderBy(sortField, sortOrder);\n    }\n\n    if (options?.skip) {\n      queryBuilder = queryBuilder.skip(options.skip);\n    }\n\n    if (options?.limit) {\n      queryBuilder = queryBuilder.limit(options.limit);\n    }\n\n    const result = await queryBuilder.get();\n    return result.data as T[];\n  }\n\n  async findOne<T = any>(\n    collection: CloudBaseCollection,\n    query: any\n  ): Promise<T | null> {\n    const result = await collection.where(query).limit(1).get();\n    return result.data.length > 0 ? (result.data[0] as T) : null;\n  }\n\n  async insertOne<T = any>(\n    collection: CloudBaseCollection,\n    document: Partial<T>\n  ): Promise<T> {\n    const result = await collection.add(document);\n    return { _id: result.id, ...document } as T;\n  }\n\n  async insertMany<T = any>(\n    collection: CloudBaseCollection,\n    documents: Partial<T>[]\n  ): Promise<{ insertedCount: number }> {\n    let insertedCount = 0;\n    for (const doc of documents) {\n      await collection.add(doc);\n      insertedCount++;\n    }\n    return { insertedCount };\n  }\n\n  async updateOne(\n    collection: CloudBaseCollection,\n    filter: any,\n    update: any\n  ): Promise<{ modifiedCount: number }> {\n    // Find the document first\n    const result = await collection.where(filter).limit(1).get();\n    \n    if (result.data.length === 0) {\n      return { modifiedCount: 0 };\n    }\n\n    const docId = result.data[0]._id;\n    \n    // Handle increments if present\n    const updateData = { ...update };\n    const incrementFields: Record<string, number> = {};\n    \n    Object.keys(updateData).forEach((key) => {\n      if (key.startsWith(\"__inc_\")) {\n        const field = key.substring(6); // Remove \"__inc_\" prefix\n        incrementFields[field] = updateData[key];\n        delete updateData[key];\n      }\n    });\n\n    // If there are increments, we need to read current values first\n    if (Object.keys(incrementFields).length > 0) {\n      const currentDoc = result.data[0];\n      Object.entries(incrementFields).forEach(([field, value]) => {\n        updateData[field] = (currentDoc[field] || 0) + value;\n      });\n    }\n\n    await collection.doc(docId).update(updateData);\n    return { modifiedCount: 1 };\n  }\n\n  async deleteOne(\n    collection: CloudBaseCollection,\n    filter: any\n  ): Promise<{ deletedCount: number }> {\n    const result = await collection.where(filter).limit(1).get();\n    \n    if (result.data.length === 0) {\n      return { deletedCount: 0 };\n    }\n\n    const docId = result.data[0]._id;\n    await collection.doc(docId).remove();\n    return { deletedCount: 1 };\n  }\n\n  async deleteMany(\n    collection: CloudBaseCollection,\n    filter: any\n  ): Promise<{ deletedCount: number }> {\n    const result = await collection.where(filter).remove();\n    return { deletedCount: result.deleted || 0 };\n  }\n\n  async count(collection: CloudBaseCollection, query: any): Promise<number> {\n    const result = await collection.where(query).count();\n    return result.total;\n  }\n\n  // Query builder factory methods\n  createQueryBuilder(): IQueryBuilder {\n    return new CloudBaseQueryBuilder(this.db);\n  }\n\n  createUpdateBuilder(): IUpdateBuilder {\n    return new CloudBaseUpdateBuilder();\n  }\n}\n","/**\n * Utility Functions\n *\n * Collection management and document conversion utilities\n */\n\nimport { IMemoryEvent } from \"../memory-base\";\nimport { ICollectionManager, IDatabaseAdapter } from \"../common/types\";\nimport {\n  CloudBaseApp,\n  CloudBaseCollection,\n  CloudBaseMemoryDocument,\n  CloudBaseSummaryDocument,\n} from \"./types\";\nimport { CloudBaseAdapter } from \"./cloudbase-adapter\";\n\n// ==================== Collection Manager ====================\n\n/**\n * Manages CloudBase collection instances\n */\nexport class CollectionManager implements ICollectionManager {\n  private adapter: CloudBaseAdapter;\n\n  constructor(\n    private app: CloudBaseApp,\n    private collectionName: string,\n    private summaryCollectionName: string,\n    private stateCollectionName: string\n  ) {\n    this.adapter = new CloudBaseAdapter(this.app.database());\n  }\n\n  /**\n   * Get the main events collection\n   */\n  getCollection(): CloudBaseCollection {\n    return this.app.database().collection(this.collectionName);\n  }\n\n  /**\n   * Get the summary collection\n   */\n  getSummaryCollection(): CloudBaseCollection {\n    return this.app.database().collection(this.summaryCollectionName);\n  }\n\n  /**\n   * Get the state collection\n   */\n  getStateCollection(): CloudBaseCollection {\n    return this.app.database().collection(this.stateCollectionName);\n  }\n\n  /**\n   * Get database instance\n   */\n  getDatabase() {\n    return this.app.database();\n  }\n\n  /**\n   * Get database adapter\n   */\n  getAdapter(): IDatabaseAdapter {\n    return this.adapter;\n  }\n}\n\n// ==================== Document Converter ====================\n\n/**\n * Converts between IMemoryEvent and CloudBase documents\n */\nexport class DocumentConverter {\n  /**\n   * Convert IMemoryEvent to CloudBase document\n   */\n  toDocument(\n    event: IMemoryEvent,\n    sessionId: string,\n    branchPath: string\n  ): CloudBaseMemoryDocument {\n    return {\n      sessionId,\n      messageId: event.message.id,\n      branchPath,\n      role: event.message.role,\n      content: event.message.content,\n      toolCalls: event.message.toolCalls,\n      toolCallId: event.message.toolCallId,\n      state: event.state || {},\n      createdAt: event.message.timestamp || new Date(),\n      updatedAt: new Date(),\n    };\n  }\n\n  /**\n   * Convert CloudBase document to IMemoryEvent\n   */\n  fromDocument(doc: CloudBaseMemoryDocument): IMemoryEvent {\n    return {\n      message: {\n        id: doc.messageId,\n        role: doc.role as \"user\" | \"assistant\" | \"system\" | \"tool\",\n        content: doc.content,\n        toolCalls: doc.toolCalls,\n        toolCallId: doc.toolCallId,\n        timestamp: doc.createdAt,\n      },\n      state: doc.state,\n    };\n  }\n\n  /**\n   * Convert summary to CloudBase summary document\n   */\n  toSummaryDocument(\n    summary: { id: string; content: string; metadata?: Record<string, any> },\n    sessionId: string\n  ): CloudBaseSummaryDocument {\n    return {\n      sessionId,\n      summaryId: summary.id,\n      content: summary.content,\n      metadata: summary.metadata,\n      createdAt: new Date(),\n      updatedAt: new Date(),\n    };\n  }\n\n  /**\n   * Convert CloudBase summary document to summary\n   */\n  fromSummaryDocument(doc: CloudBaseSummaryDocument): {\n    id: string;\n    content: string;\n    metadata?: Record<string, any>;\n  } {\n    return {\n      id: doc.summaryId,\n      content: doc.content,\n      metadata: doc.metadata,\n    };\n  }\n}\n","/**\n * @fileoverview CloudBase cloud-based memory implementation for Tencent CloudBase\n *\n * CloudBase Memory implementation providing cloud-based persistent storage using\n * Tencent CloudBase database service with support for CRUD operations, session management,\n * branch isolation, and soft delete using cursor-based approach.\n *\n * @example\n * ```typescript\n * import cloudbase from '@cloudbase/node-sdk';\n *\n * const app = cloudbase.init({\n *   env: 'your-env-id',\n *   secretId: 'your-secret-id',\n *   secretKey: 'your-secret-key'\n * });\n *\n * const memory = new CloudBaseMemory({\n *   app,\n *   collectionName: 'memory_events',\n *   sessionId: 'user-session-123'\n * });\n *\n * await memory.add({\n *   message: { id: '1', role: 'user', content: 'Hello' },\n *   state: { userId: 'user123' }\n * });\n *\n * const events = await memory.list({ limit: 10 });\n * ```\n */\n\nimport {\n  BaseMemory,\n  IMemoryEvent,\n  ListOptions,\n  AddOptions,\n  DeleteOptions,\n  RetrieveOptions,\n  ClearOptions,\n  StructuredSummary,\n  BranchInfo,\n} from \"../memory-base\";\n\nimport {\n  CloudBaseApp,\n  BranchMetadata,\n  CloudBaseMemoryDocument,\n  CollectionManager,\n  DocumentConverter,\n} from \".\";\nimport { StateManager } from \"../common/state-manager\";\nimport { CursorManager } from \"../common/cursor-manager\";\nimport { SummaryManager } from \"../common/summary-manager\";\nimport { BranchManager } from \"../common/branch-manager\";\n\n/**\n * CloudBase Memory implementation for Tencent CloudBase\n *\n * Provides persistent storage using CloudBase database service with support for\n * session-based memory management, CRUD operations, branch isolation, optional context engineering,\n * and efficient soft delete using cursor-based approach.\n */\nexport class CloudBaseMemory extends BaseMemory {\n  /** Session identifier for memory isolation */\n  public sessionId: string;\n  /** Whether to enable automatic context management */\n  private enableContextManagement: boolean;\n\n  // Core utilities\n  private collectionManager: CollectionManager;\n  private documentConverter: DocumentConverter;\n\n  // Managers\n  private stateManager: StateManager;\n  private cursorManager: CursorManager;\n  private branchManager: BranchManager;\n  private summaryManager: SummaryManager;\n\n  /**\n   * Creates a new CloudBaseMemory instance\n   * @param options - Configuration options\n   * @param options.app - CloudBase app instance from @cloudbase/node-sdk\n   * @param options.collectionName - Collection name for storing events (default: 'memory_events')\n   * @param options.summaryCollectionName - Collection name for storing summaries (default: 'memory_summaries')\n   * @param options.stateCollectionName - Collection name for storing session state (default: 'memory_state')\n   * @param options.sessionId - Unique session identifier (default: 'default')\n   * @param options.enableContextManagement - Whether to automatically manage context (default: true if thresholds provided)\n   */\n  constructor(\n    options: {\n      app: CloudBaseApp;\n      collectionName?: string;\n      summaryCollectionName?: string;\n      stateCollectionName?: string;\n      sessionId?: string;\n      enableContextManagement?: boolean;\n    } & ConstructorParameters<typeof BaseMemory>[0]\n  ) {\n    super(options);\n\n    if (!options.app) {\n      throw new Error(\"CloudBase app instance is required\");\n    }\n\n    this.sessionId = options.sessionId || \"default\";\n    this.enableContextManagement =\n      options.enableContextManagement ?? (options.thresholds ? true : false);\n\n    // Initialize core utilities\n    this.collectionManager = new CollectionManager(\n      options.app,\n      options.collectionName || \"memory_events\",\n      options.summaryCollectionName || \"memory_summaries\",\n      options.stateCollectionName || \"memory_state\"\n    );\n\n    this.documentConverter = new DocumentConverter();\n\n    // Initialize managers\n    this.stateManager = new StateManager(this.collectionManager);\n    this.cursorManager = new CursorManager(\n      this.collectionManager,\n      this.stateManager\n    );\n    this.branchManager = new BranchManager(\n      this.collectionManager,\n      this.stateManager,\n      this.cursorManager\n    );\n    this.summaryManager = new SummaryManager(\n      this.sessionId,\n      this.collectionManager,\n      this.cursorManager\n    );\n  }\n\n  // ==================== CRUD Operations ====================\n\n  /**\n   * Returns events from CloudBase database with filtering, pagination, and token limiting\n   * Respects branch isolation using branch path and snapshot time\n   * @param options - Optional filtering and pagination options\n   * @returns Promise resolving to filtered array of memory events\n   */\n  public async list(options?: ListOptions): Promise<IMemoryEvent[]> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const db = this.collectionManager.getDatabase();\n      const _ = db.command;\n      const sid = options?.sessionId || this.sessionId;\n\n      // Get current branch path\n      const currentBranchPath =\n        await this.branchManager.getCurrentBranchPath(sid);\n\n      // Build branch conditions using new adapter\n      const branchConditions = await this.branchManager.buildBranchConditions(\n        sid,\n        currentBranchPath\n      );\n\n      // Apply soft delete cursor\n      const startCursor = await this.cursorManager.getStartCursor(sid);\n      let conditions = branchConditions;\n\n      if (startCursor) {\n        conditions = this.branchManager.applyCursorCondition(\n          conditions,\n          startCursor\n        );\n      }\n\n      // Execute query with OR conditions using adapter\n      let whereCondition: any;\n      if (conditions.length > 1) {\n        whereCondition = _.or(conditions);\n      } else {\n        whereCondition = conditions[0];\n      }\n\n      // Apply ordering\n      const order = options?.order || \"desc\";\n      const queryOptions: any = {\n        sort: { createdAt: order === \"asc\" ? 1 : -1 },\n      };\n\n      if (options?.offset) {\n        queryOptions.skip = options.offset;\n      }\n      if (options?.limit) {\n        queryOptions.limit = options.limit;\n      }\n\n      // Execute query using adapter\n      const result = await adapter.find<CloudBaseMemoryDocument>(\n        collection,\n        whereCondition,\n        queryOptions\n      );\n\n      let events = (order === \"desc\" ? result.reverse() : result).map(\n        (doc: CloudBaseMemoryDocument) =>\n          this.documentConverter.fromDocument(doc)\n      );\n\n      // Trigger context management if enabled\n      if (this.enableContextManagement && events.length > 0) {\n        const res = await this.manageContext({ sessionId: sid, events });\n        events = res.events;\n      }\n\n      // Apply token limiting if specified\n      if (options?.maxTokens) {\n        events = this.tokenTrimmer.trimMessages(events, options.maxTokens);\n      }\n\n      return events;\n    } catch (error) {\n      console.error(\"Error listing events from CloudBase:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Add a single event to CloudBase database\n   * @param event - The memory event to store\n   * @param options - Optional session options\n   */\n  public async add(event: IMemoryEvent, options?: AddOptions): Promise<void> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      // Ensure timestamp\n      if (!event.message.timestamp) {\n        event.message.timestamp = new Date();\n      }\n\n      // Get current branch path\n      const branchPath = await this.branchManager.getCurrentBranchPath(sid);\n\n      // Create document\n      const doc = this.documentConverter.toDocument(event, sid, branchPath);\n\n      // Use adapter to insert\n      await adapter.insertOne(collection, doc);\n\n    } catch (error) {\n      console.error(\"Error adding event to CloudBase:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Add multiple events efficiently\n   * @param list - Array of memory events to store\n   * @param options - Optional session options\n   */\n  public async addList(\n    list: IMemoryEvent[],\n    options?: AddOptions\n  ): Promise<void> {\n    // Temporarily disable context management for batch operations\n\n    for (const event of list) {\n      await this.add(event, options);\n    }\n  }\n\n  /**\n   * Update an event in CloudBase database\n   * @param params - Update parameters\n   */\n  public async update(params: {\n    sessionId?: string;\n    event: IMemoryEvent;\n  }): Promise<void> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = params.sessionId || this.sessionId;\n\n      // Build query using adapter\n      const query = adapter\n        .createQueryBuilder()\n        .where(\"sessionId\", \"eq\", sid)\n        .and(\"messageId\", \"eq\", params.event.message.id)\n        .build();\n\n      // Find the document\n      const doc = await adapter.findOne<CloudBaseMemoryDocument>(\n        collection,\n        query\n      );\n\n      if (!doc) {\n        throw new Error(\n          `Event with messageId '${params.event.message.id}' not found in session '${sid}'`\n        );\n      }\n\n      const branchPath = await this.branchManager.getCurrentBranchPath(sid);\n      const updateDoc = this.documentConverter.toDocument(\n        params.event,\n        sid,\n        branchPath\n      );\n\n      // Build update using adapter\n      const update = adapter\n        .createUpdateBuilder()\n        .setMultiple({\n          ...updateDoc,\n          updatedAt: new Date(),\n        })\n        .build();\n\n      // Update using adapter\n      await adapter.updateOne(collection, query, update);\n    } catch (error) {\n      console.error(\"Error updating event in CloudBase:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete an event from CloudBase database\n   * @param idOrIndex - Message ID (string) to delete\n   * @param options - Optional session options\n   */\n  public async delete(\n    idOrIndex: string | number,\n    options?: DeleteOptions\n  ): Promise<void> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      if (typeof idOrIndex === \"string\") {\n        // Delete by message ID using adapter\n        const query = adapter\n          .createQueryBuilder()\n          .where(\"sessionId\", \"eq\", sid)\n          .and(\"messageId\", \"eq\", idOrIndex)\n          .build();\n\n        await adapter.deleteMany(collection, query);\n      } else {\n        // Delete by index - not recommended for CloudBase\n        console.warn(\n          \"Deleting by index is not efficient in CloudBase. Consider using message ID instead.\"\n        );\n        const events = await this.list({ sessionId: sid });\n        if (idOrIndex >= 0 && idOrIndex < events.length) {\n          const eventToDelete = events[idOrIndex];\n          await this.delete(eventToDelete.message.id, options);\n        }\n      }\n    } catch (error) {\n      console.error(\"Error deleting event from CloudBase:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clear all events from CloudBase database\n   * @param options - Optional session options. If sessionId provided, clears only that session using soft delete.\n   */\n  public async clear(options?: ClearOptions): Promise<void> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const stateCollection = this.collectionManager.getStateCollection();\n      const summaryCollection = this.collectionManager.getSummaryCollection();\n\n      if (options?.sessionId) {\n        // Clear specific session - use soft delete by setting cursor to last event\n        const sid = options.sessionId;\n        const adapter = this.collectionManager.getAdapter();\n\n        // Get the last event in the session\n        const result = await adapter.find<CloudBaseMemoryDocument>(\n          collection,\n          { sessionId: sid },\n          { sort: { createdAt: -1 }, limit: 1 }\n        );\n\n        if (result.length > 0) {\n          const lastEvent = result[0];\n          // Set cursor to the last event's timestamp, effectively hiding all events\n          await this.cursorManager.setStartCursor(sid, lastEvent.createdAt);\n        }\n\n        // Clear summaries for this session\n        await adapter.deleteMany(summaryCollection, { sessionId: sid });\n      } else {\n        // Clear all sessions - hard delete\n        const adapter = this.collectionManager.getAdapter();\n\n        // Delete all documents\n        await adapter.deleteMany(collection, {});\n        await adapter.deleteMany(stateCollection, {});\n        await adapter.deleteMany(summaryCollection, {});\n      }\n\n      // Clear cache\n      this.stateManager.clearCache();\n    } catch (error) {\n      console.error(\"Error clearing events from CloudBase:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check if the session contains any events (respecting soft delete)\n   * @param options - Optional session options\n   * @returns Promise resolving to true if no events are stored\n   */\n  public async isEmpty(options?: { sessionId?: string }): Promise<boolean> {\n    return (await this.getCount(options)) === 0;\n  }\n\n  /**\n   * Get the current number of events stored in the session (respecting soft delete)\n   * @param options - Optional session options\n   * @returns Promise resolving to the count of stored events\n   */\n  public async getCount(options?: { sessionId?: string }): Promise<number> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const db = this.collectionManager.getDatabase();\n      const _ = db.command;\n      const sid = options?.sessionId || this.sessionId;\n\n      // Get current branch path\n      const currentBranchPath =\n        await this.branchManager.getCurrentBranchPath(sid);\n\n      // Build branch conditions\n      const branchConditions = await this.branchManager.buildBranchConditions(\n        sid,\n        currentBranchPath\n      );\n\n      // Apply soft delete cursor\n      const startCursor = await this.cursorManager.getStartCursor(sid);\n      let conditions = branchConditions;\n\n      if (startCursor) {\n        conditions = this.branchManager.applyCursorCondition(\n          conditions,\n          startCursor\n        );\n      }\n\n      // Execute count query using adapter\n      const adapter = this.collectionManager.getAdapter();\n      let whereCondition: any;\n      if (conditions.length > 1) {\n        whereCondition = _.or(conditions);\n      } else {\n        whereCondition = conditions[0];\n      }\n\n      const count = await adapter.count(collection, whereCondition);\n      return count;\n    } catch (error) {\n      console.error(\"Error getting count from CloudBase:\", error);\n      throw error\n    }\n  }\n\n  // ==================== Search Operations ====================\n\n  /**\n   * Retrieve events using content-based search\n   * @param query - Search query text to match against message content\n   * @param options - Optional session options\n   * @returns Promise resolving to array of matching events\n   */\n  public async retrieve(\n    query: string,\n    options?: RetrieveOptions\n  ): Promise<IMemoryEvent[]> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const db = this.collectionManager.getDatabase();\n      const _ = db.command;\n      const sid = options?.sessionId || this.sessionId;\n\n      // Get start cursor for soft delete\n      const startCursor = await this.cursorManager.getStartCursor(sid);\n\n      // CloudBase supports regex search\n      let whereCondition: any = {\n        sessionId: sid,\n        content: db.RegExp({\n          regexp: query,\n          options: \"i\", // case-insensitive\n        }),\n      };\n\n      // Apply soft delete cursor\n      const adapter = this.collectionManager.getAdapter();\n      if (startCursor) {\n        const queryBuilder = adapter.createQueryBuilder();\n        const cursorCondition = queryBuilder.where(\"createdAt\", \"gt\", startCursor).build();\n        whereCondition = { ...whereCondition, ...cursorCondition };\n      }\n\n      const result = await adapter.find<CloudBaseMemoryDocument>(\n        collection,\n        whereCondition\n      );\n\n      return result.map((doc: CloudBaseMemoryDocument) =>\n        this.documentConverter.fromDocument(doc)\n      );\n    } catch (error) {\n      console.error(\"Error retrieving events from CloudBase:\", error);\n      throw error;\n    }\n  }\n\n  // ==================== Summary Operations ====================\n\n  /**\n   * Get summaries for a session\n   * @param sessionId - Optional session identifier\n   * @returns Array of structured summaries\n   */\n  public async getSummaries(sessionId?: string): Promise<StructuredSummary[]> {\n    const summaries = await this.summaryManager.getSummaries(sessionId);\n\n    // Convert BaseSummaryDocument to StructuredSummary\n    return summaries.map(doc => ({\n      content: doc.content,\n      count: 1, // Default count since BaseSummaryDocument doesn't have count\n      timeRange: {\n        start: doc.metadata?.timeRangeStart,\n        end: doc.metadata?.timeRangeEnd\n      },\n      timestamp: doc.createdAt\n    }));\n  }\n\n  /**\n   * Store summary implementation\n   * @param params - Summary storage parameters\n   */\n  protected async storeSummary(params: {\n    sessionId?: string;\n    summary: StructuredSummary;\n  }): Promise<void> {\n    const summaryId = `summary_${Date.now()}`;\n    const metadata = {\n      count: params.summary.count,\n      timeRangeStart: params.summary.timeRange.start,\n      timeRangeEnd: params.summary.timeRange.end\n    };\n\n    return this.summaryManager.addSummary(\n      summaryId,\n      params.summary.content,\n      metadata,\n      params.sessionId\n    );\n  }\n\n  /**\n   * Clear summarized events implementation using soft delete\n   * Sets cursor to hide old events without actually deleting them\n   * @param params - Clear parameters\n   */\n  protected async clearSummarizedEvents(params: {\n    sessionId: string | undefined;\n    recentToKeep: number;\n  }): Promise<void> {\n    return this.summaryManager.clearSummarizedEvents(params);\n  }\n\n  // ==================== Branch Management ====================\n\n  /**\n   * Create a new branch from current session state\n   * @param branchName - Name for the new branch\n   * @param fromEventId - Optional event ID to branch from\n   * @returns Promise resolving to branch ID\n   */\n  public async branch(\n    branchName: string,\n    fromEventId?: string\n  ): Promise<string> {\n    return this.branchManager.createBranch(\n      this.sessionId,\n      branchName,\n      fromEventId,\n      () => this.list({ sessionId: this.sessionId })\n    );\n  }\n\n  /**\n   * Switch to a different branch or checkout to a specific event\n   * @param target - Branch name or event ID to checkout\n   * @param options - Optional configuration\n   */\n  public async checkout(\n    target: string,\n    options?: { type?: \"branch\" | \"event\"; sessionId?: string }\n  ): Promise<void> {\n    const sid = options?.sessionId || this.sessionId;\n    const checkoutType =\n      options?.type ||\n      (await this.branchManager.detectCheckoutType(sid, target));\n\n    if (checkoutType === \"event\") {\n      await this.branchManager.checkoutToEvent(sid, target)\n    } else {\n      await this.branchManager.checkoutBranch(sid, target);\n    }\n  }\n\n  /**\n   * Delete a branch\n   * @param branchName - Name of the branch to delete\n   */\n  public async deleteBranch(branchName: string): Promise<void> {\n    return this.branchManager.deleteBranch(this.sessionId, branchName);\n  }\n\n  /**\n   * List all branches\n   * @returns Promise resolving to array of branch information\n   */\n  public async listBranches(): Promise<BranchInfo[]> {\n    const branches = await this.branchManager.listBranches(this.sessionId);\n    const currentBranch = await this.getCurrentBranch();\n\n    return branches.map((branch: BranchMetadata) => ({\n      id: branch.name,\n      name: branch.name,\n      createdAt: branch.createdAt,\n      fromEventId: branch.fromEventId,\n      isActive: branch.name === currentBranch,\n    }));\n  }\n\n  /**\n   * Get current branch name\n   * @returns Promise resolving to current branch name\n   */\n  public async getCurrentBranch(): Promise<string> {\n    return this.branchManager.getCurrentBranch(this.sessionId);\n  }\n\n  /**\n   * Clean up branches, keeping only specified branches and the current active branch\n   * @param keepBranches - Optional list of branch names to keep (in addition to active branch)\n   */\n  public async cleanupBranches(keepBranches?: string[]): Promise<void> {\n    return this.branchManager.cleanupBranches(this.sessionId, keepBranches);\n  }\n}\n","/**\n * @fileoverview MongoDB memory implementation for persistent storage\n *\n * MongoDB Memory implementation providing persistent storage using MongoDB\n * with support for CRUD operations, session management, branch isolation,\n * and soft delete using cursor-based approach.\n *\n * @example\n * ```typescript\n * import { MongoClient } from 'mongodb';\n *\n * const client = new MongoClient('mongodb://localhost:27017');\n * await client.connect();\n * const db = client.db('ag_kit_memory');\n *\n * const memory = new MongoDBMemory({\n *   db,\n *   sessionId: 'user-session-123',\n *   collectionName: 'memory_events'\n * });\n *\n * await memory.add({\n *   message: { id: '1', role: 'user', content: 'Hello' },\n *   state: { userId: 'user123' }\n * });\n *\n * const events = await memory.list({ limit: 10 });\n * ```\n */\n\nimport { Db, MongoClient, MongoClientOptions } from \"mongodb\";\nimport {\n  BaseMemory,\n  IMemoryEvent,\n  ListOptions,\n  AddOptions,\n  DeleteOptions,\n  RetrieveOptions,\n  ClearOptions,\n  StructuredSummary,\n  BranchInfo,\n  IBaseMemoryOptions,\n} from \"../memory-base\";\nimport { MongoDBCollectionManager } from \"./collection-manager\";\nimport { DocumentConverter } from \"../common/document-converter\";\nimport { StateManager } from \"../common/state-manager\";\nimport { CursorManager } from \"../common/cursor-manager\";\nimport { BranchManager } from \"../common/branch-manager\";\nimport { SummaryManager } from \"../common/summary-manager\";\nimport { BaseMemoryDocument } from \"../common/types\";\n\n/**\n * Configuration options for MongoDBMemory\n */\nexport interface MongoDBMemoryConfig extends IBaseMemoryOptions {\n  // Option 1: Pass existing DB instance\n  db?: Db;\n\n  // Option 2: Pass connection parameters for auto-initialization\n  connectionString?: string;\n  databaseName?: string;\n  clientOptions?: MongoClientOptions;\n\n  // Collection configuration\n  collectionName?: string;\n  stateCollectionName?: string;\n  summaryCollectionName?: string;\n\n  // Session configuration\n  sessionId?: string;\n\n  // Context management\n  enableContextManagement?: boolean;\n}\n\n/**\n * MongoDB Memory implementation for persistent storage\n *\n * Provides persistent storage using MongoDB with support for\n * session-based memory management, CRUD operations, branch isolation, optional context engineering,\n * and efficient soft delete using cursor-based approach.\n */\nexport class MongoDBMemory extends BaseMemory {\n  /** Session identifier for memory isolation */\n  public sessionId: string;\n  /** Whether to enable automatic context management */\n  private enableContextManagement: boolean;\n\n  // Core database components\n  private db: Db | null = null;\n  private client?: MongoClient;\n\n  // Core utilities\n  private collectionManager!: MongoDBCollectionManager;\n  private documentConverter!: DocumentConverter;\n\n  // Managers\n  private stateManager!: StateManager;\n  private cursorManager!: CursorManager;\n  private branchManager!: BranchManager;\n  private summaryManager!: SummaryManager;\n\n  /**\n   * Creates a new MongoDBMemory instance\n   * @param config - Configuration options\n   * @param config.db - MongoDB database instance\n   * @param config.connectionString - MongoDB connection string for auto-initialization\n   * @param config.databaseName - Database name (default: 'ag_kit_memory')\n   * @param config.collectionName - Collection name for storing events (default: 'memory_events')\n   * @param config.summaryCollectionName - Collection name for storing summaries (default: 'memory_summaries')\n   * @param config.stateCollectionName - Collection name for storing session state (default: 'memory_state')\n   * @param config.sessionId - Unique session identifier (default: 'default')\n   * @param config.enableContextManagement - Whether to automatically manage context (default: true if thresholds provided)\n   */\n  constructor(config: MongoDBMemoryConfig) {\n    super(config);\n\n    if (!config.db && !config.connectionString) {\n      throw new Error(\n        \"Either 'db' instance or 'connectionString' must be provided\"\n      );\n    }\n\n    this.sessionId = config.sessionId || \"default\";\n    this.enableContextManagement =\n      config.enableContextManagement ?? (config.thresholds ? true : false);\n\n    if (config.db) {\n      // Use existing DB instance\n      this.db = config.db;\n      this._initializeManagers(config);\n    }\n    // If no db provided, will be initialized asynchronously via initialize() method\n  }\n\n  /**\n   * Initialize MongoDB connection and managers\n   */\n  async initialize(config: MongoDBMemoryConfig): Promise<void> {\n    if (this.db) {\n      return; // Already initialized\n    }\n\n    if (!config.connectionString) {\n      throw new Error(\"Connection string is required for initialization\");\n    }\n\n    try {\n      this.client = new MongoClient(config.connectionString, {\n        ...config.clientOptions,\n      });\n\n      await this.client.connect();\n\n      const databaseName = config.databaseName || \"ag_kit_memory\";\n      this.db = this.client.db(databaseName);\n\n      this._initializeManagers(config);\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  /**\n   * Initialize all manager instances\n   */\n  private _initializeManagers(config: MongoDBMemoryConfig): void {\n    if (!this.db) {\n      throw new Error(\"Database instance is required for initialization\");\n    }\n\n    // Initialize core utilities\n    this.collectionManager = new MongoDBCollectionManager(\n      this.db,\n      config.collectionName || \"memory_events\",\n      config.stateCollectionName || \"memory_state\",\n      config.summaryCollectionName || \"memory_summaries\"\n    );\n\n    this.documentConverter = new DocumentConverter();\n\n    // Initialize managers\n    this.stateManager = new StateManager(this.collectionManager);\n    this.cursorManager = new CursorManager(\n      this.collectionManager,\n      this.stateManager\n    );\n    this.branchManager = new BranchManager(\n      this.collectionManager,\n      this.stateManager,\n      this.cursorManager\n    );\n    this.summaryManager = new SummaryManager(\n      this.sessionId,\n      this.collectionManager,\n      this.cursorManager\n    );\n  }\n\n  // ==================== CRUD Operations ====================\n\n  /**\n   * Add a single event to MongoDB database\n   * @param event - The memory event to store\n   * @param options - Optional session options\n   */\n  public async add(event: IMemoryEvent, options?: AddOptions): Promise<void> {\n    this.ensureInitialized();\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      // Ensure timestamp\n      if (!event.message.timestamp) {\n        event.message.timestamp = new Date();\n      }\n\n      // Get current branch path\n      const branchPath = await this.branchManager.getCurrentBranchPath(sid);\n\n      // Create document\n      const doc = this.documentConverter.toDocument(event, sid, branchPath);\n\n      // Use adapter to insert\n      await adapter.insertOne(collection, doc);\n    } catch (error) {\n      console.error(\"Error adding event to MongoDB:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Add multiple events efficiently\n   * @param list - Array of memory events to store\n   * @param options - Optional session options\n   */\n  public async addList(\n    list: IMemoryEvent[],\n    options?: AddOptions\n  ): Promise<void> {\n    if (list.length === 0) return;\n\n    // Temporarily disable context management for batch operations\n    for (const event of list) {\n      await this.add(event, options);\n    }\n  }\n\n  /**\n   * Returns events from MongoDB database with filtering, pagination, and token limiting\n   * Respects branch isolation using branch path and snapshot time\n   * @param options - Optional filtering and pagination options\n   * @returns Promise resolving to filtered array of memory events\n   */\n  public async list(options?: ListOptions): Promise<IMemoryEvent[]> {\n    this.ensureInitialized();\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      // Get current branch path\n      const currentBranchPath =\n        await this.branchManager.getCurrentBranchPath(sid);\n\n      // Build branch conditions using adapter\n      const branchConditions = await this.branchManager.buildBranchConditions(\n        sid,\n        currentBranchPath\n      );\n\n      // Apply soft delete cursor\n      const startCursor = await this.cursorManager.getStartCursor(sid);\n      let conditions = branchConditions;\n\n      if (startCursor) {\n        conditions = this.branchManager.applyCursorCondition(\n          conditions,\n          startCursor\n        );\n      }\n\n      // Execute query with OR conditions using adapter\n      let whereCondition: any;\n      if (conditions.length > 1) {\n        const orBuilder = adapter.createQueryBuilder();\n        const conditionBuilders = conditions.map((cond: any) => {\n          const builder = adapter.createQueryBuilder();\n          Object.entries(cond).forEach(([field, value]) => {\n            builder.where(field, \"eq\", value);\n          });\n          return builder;\n        });\n        whereCondition = orBuilder.or(conditionBuilders).build();\n      } else {\n        whereCondition = conditions[0];\n      }\n\n      // Apply ordering\n      const order = options?.order || \"asc\";\n      const queryOptions: any = {\n        sort: { createdAt: order === \"asc\" ? 1 : -1 },\n      };\n\n      if (options?.offset) {\n        queryOptions.skip = options.offset;\n      }\n      if (options?.limit) {\n        queryOptions.limit = options.limit;\n      }\n\n      // Execute query using adapter\n      const result = await adapter.find(\n        collection,\n        whereCondition,\n        queryOptions\n      );\n\n      let events = (order === \"desc\" ? result.reverse() : result).map(\n        (doc: BaseMemoryDocument) => this.documentConverter.fromDocument(doc)\n      );\n\n      // Trigger context management if enabled\n      if (this.enableContextManagement && events.length > 0) {\n        const res = await this.manageContext({ sessionId: sid, events });\n        events = res.events;\n      }\n\n      // Apply token limiting if specified\n      if (options?.maxTokens) {\n        events = this.tokenTrimmer.trimMessages(events, options.maxTokens);\n      }\n\n      return events;\n    } catch (error) {\n      console.error(\"Error listing events from MongoDB:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update an event in MongoDB database\n   * @param params - Update parameters\n   */\n  public async update(params: {\n    sessionId?: string;\n    event: IMemoryEvent;\n  }): Promise<void> {\n    this.ensureInitialized();\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = params.sessionId || this.sessionId;\n\n      const { event } = params;\n\n      // Get current branch path\n      const currentBranchPath =\n        await this.branchManager.getCurrentBranchPath(sid);\n\n      // Convert to document\n      const document = this.documentConverter.toDocument(\n        event,\n        sid,\n        currentBranchPath\n      );\n\n      await adapter.updateOne(\n        collection,\n        { sessionId: sid, messageId: event.message.id },\n        document\n      );\n    } catch (error) {\n      console.error(\"Error updating event in MongoDB:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete an event from MongoDB database\n   * @param messageId - Message ID (string) to delete\n   * @param options - Optional session options\n   */\n  async delete(messageId: string): Promise<void> {\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = this.sessionId;\n\n      await adapter.deleteOne(collection, {\n        sessionId: sid,\n        messageId,\n      });\n    } catch (error) {\n      console.error(\"Error deleting event from MongoDB:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clear all events from MongoDB database\n   * @param options - Optional session options. If sessionId provided, clears only that session using soft delete.\n   */\n  public async clear(options?: ClearOptions): Promise<void> {\n    this.ensureInitialized();\n    try {\n      const collection = this.collectionManager.getCollection();\n      const stateCollection = this.collectionManager.getStateCollection();\n      const summaryCollection = this.collectionManager.getSummaryCollection();\n\n      if (options?.sessionId) {\n        // Clear specific session - use soft delete by setting cursor to last event\n        const sid = options.sessionId;\n        const adapter = this.collectionManager.getAdapter();\n\n        // Get the last event in the session\n        const result = await adapter.find<BaseMemoryDocument>(\n          collection,\n          { sessionId: sid },\n          { sort: { createdAt: -1 }, limit: 1 }\n        );\n\n        if (result.length > 0) {\n          const lastEvent = result[0];\n          // Set cursor to the last event's timestamp, effectively hiding all events\n          await this.cursorManager.setStartCursor(sid, lastEvent.createdAt);\n        }\n\n        // Clear summaries for this session\n        await adapter.deleteMany(summaryCollection, { sessionId: sid });\n      } else {\n        // Clear all sessions - hard delete\n        const adapter = this.collectionManager.getAdapter();\n\n        // Delete all documents\n        await adapter.deleteMany(collection, {});\n        await adapter.deleteMany(stateCollection, {});\n        await adapter.deleteMany(summaryCollection, {});\n      }\n\n      // Clear cache\n      this.stateManager.clearCache();\n    } catch (error) {\n      console.error(\"Error clearing events from MongoDB:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check if the session contains any events (respecting soft delete)\n   * @param options - Optional session options\n   * @returns Promise resolving to true if no events are stored\n   */\n  public async isEmpty(options?: { sessionId?: string }): Promise<boolean> {\n    return (await this.getCount(options)) === 0;\n  }\n\n  /**\n   * Get the current number of events stored in the session (respecting soft delete)\n   * @param options - Optional session options\n   * @returns Promise resolving to the count of stored events\n   */\n  public async getCount(options?: { sessionId?: string }): Promise<number> {\n    this.ensureInitialized();\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      // Get current branch path\n      const currentBranchPath =\n        await this.branchManager.getCurrentBranchPath(sid);\n\n      // Build branch conditions\n      const branchConditions = await this.branchManager.buildBranchConditions(\n        sid,\n        currentBranchPath\n      );\n\n      // Apply soft delete cursor\n      const startCursor = await this.cursorManager.getStartCursor(sid);\n      let conditions = branchConditions;\n\n      if (startCursor) {\n        conditions = this.branchManager.applyCursorCondition(\n          conditions,\n          startCursor\n        );\n      }\n\n      // Execute count query using adapter\n      let whereCondition: any;\n      if (conditions.length > 1) {\n        const orBuilder = adapter.createQueryBuilder();\n        const conditionBuilders = conditions.map((cond: any) => {\n          const builder = adapter.createQueryBuilder();\n          Object.entries(cond).forEach(([field, value]) => {\n            builder.where(field, \"eq\", value);\n          });\n          return builder;\n        });\n        whereCondition = orBuilder.or(conditionBuilders).build();\n      } else {\n        whereCondition = conditions[0];\n      }\n\n      const count = await adapter.count(collection, whereCondition);\n      return count;\n    } catch (error) {\n      console.error(\"Error getting count from MongoDB:\", error);\n      throw error;\n    }\n  }\n\n  // ==================== Search Operations ====================\n\n  /**\n   * Retrieve events using content-based search\n   * @param query - Search query text to match against message content\n   * @param options - Optional session options\n   * @returns Promise resolving to array of matching events\n   */\n  public async retrieve(\n    query: string,\n    options?: RetrieveOptions\n  ): Promise<IMemoryEvent[]> {\n    this.ensureInitialized();\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      // Get start cursor for soft delete\n      const startCursor = await this.cursorManager.getStartCursor(sid);\n\n      // MongoDB supports regex search\n      const queryBuilder = adapter\n        .createQueryBuilder()\n        .where(\"sessionId\", \"eq\", sid)\n        .regex(\"content\", query, \"i\"); // case-insensitive\n\n      // Apply soft delete cursor\n      if (startCursor) {\n        queryBuilder.and(\"createdAt\", \"gt\", startCursor);\n      }\n\n      const whereCondition = queryBuilder.build();\n\n      const result = await adapter.find<BaseMemoryDocument>(\n        collection,\n        whereCondition\n      );\n\n      return result.map((doc: BaseMemoryDocument) =>\n        this.documentConverter.fromDocument(doc)\n      );\n    } catch (error) {\n      console.error(\"Error retrieving events from MongoDB:\", error);\n      throw error;\n    }\n  }\n\n  // ==================== Summary Operations ====================\n\n  /**\n   * Get summaries for a session\n   * @param sessionId - Optional session identifier\n   * @returns Array of structured summaries\n   */\n  public async getSummaries(sessionId?: string): Promise<StructuredSummary[]> {\n    const summaries = await this.summaryManager.getSummaries(sessionId);\n\n    // Convert BaseSummaryDocument to StructuredSummary\n    return summaries.map((doc) => ({\n      content: doc.content,\n      count: 1, // Default count since BaseSummaryDocument doesn't have count\n      timeRange: {\n        start: doc.metadata?.timeRangeStart,\n        end: doc.metadata?.timeRangeEnd,\n      },\n      timestamp: doc.createdAt,\n    }));\n  }\n\n  /**\n   * Store summary implementation\n   * @param params - Summary storage parameters\n   */\n  protected async storeSummary(params: {\n    sessionId?: string;\n    summary: StructuredSummary;\n  }): Promise<void> {\n    const summaryId = `summary_${Date.now()}`;\n    const metadata = {\n      count: params.summary.count,\n      timeRangeStart: params.summary.timeRange.start,\n      timeRangeEnd: params.summary.timeRange.end,\n    };\n\n    return this.summaryManager.addSummary(\n      summaryId,\n      params.summary.content,\n      metadata,\n      params.sessionId\n    );\n  }\n\n  /**\n   * Clear summarized events implementation using soft delete\n   * Sets cursor to hide old events without actually deleting them\n   * @param params - Clear parameters\n   */\n  protected async clearSummarizedEvents(params: {\n    sessionId: string | undefined;\n    recentToKeep: number;\n  }): Promise<void> {\n    return this.summaryManager.clearSummarizedEvents(params);\n  }\n\n  // ==================== Branch Management ====================\n\n  /**\n   * Create a new branch from current session state\n   * @param branchName - Name for the new branch\n   * @param fromEventId - Optional event ID to branch from\n   * @returns Promise resolving to branch ID\n   */\n  public async branch(\n    branchName: string,\n    fromEventId?: string\n  ): Promise<string> {\n    return this.branchManager.createBranch(\n      this.sessionId,\n      branchName,\n      fromEventId,\n      () => this.list({ sessionId: this.sessionId })\n    );\n  }\n\n  /**\n   * Switch to a different branch or checkout to a specific event\n   * @param target - Branch name or event ID to checkout\n   * @param options - Optional configuration\n   */\n  public async checkout(\n    target: string,\n    options?: { type?: \"branch\" | \"event\"; sessionId?: string }\n  ): Promise<void> {\n    const sid = options?.sessionId || this.sessionId;\n    const checkoutType =\n      options?.type ||\n      (await this.branchManager.detectCheckoutType(sid, target));\n\n    if (checkoutType === \"event\") {\n      await this.branchManager.checkoutToEvent(sid, target);\n    } else {\n      await this.branchManager.checkoutBranch(sid, target);\n    }\n  }\n\n  /**\n   * Delete a branch\n   * @param branchName - Name of the branch to delete\n   */\n  public async deleteBranch(branchName: string): Promise<void> {\n    return this.branchManager.deleteBranch(this.sessionId, branchName);\n  }\n\n  /**\n   * List all branches\n   * @returns Promise resolving to array of branch information\n   */\n  public async listBranches(): Promise<BranchInfo[]> {\n    const branches = await this.branchManager.listBranches(this.sessionId);\n    const currentBranch = await this.getCurrentBranch();\n\n    return branches.map((branch: any) => ({\n      id: branch.name,\n      name: branch.name,\n      createdAt: branch.createdAt,\n      fromEventId: branch.fromEventId,\n      eventCount: 0, // TODO: Implement event count\n      isActive: branch.name === currentBranch,\n    }));\n  }\n\n  /**\n   * Get current branch name\n   * @returns Promise resolving to current branch name\n   */\n  public async getCurrentBranch(): Promise<string> {\n    return this.branchManager.getCurrentBranch(this.sessionId);\n  }\n\n  /**\n   * Clean up branches, keeping only specified branches and the current active branch\n   * @param keepBranches - Optional list of branch names to keep (in addition to active branch)\n   */\n  public async cleanupBranches(keepBranches?: string[]): Promise<void> {\n    return this.branchManager.cleanupBranches(this.sessionId, keepBranches);\n  }\n\n  // ==================== Utility Methods ====================\n\n  /**\n   * Close MongoDB connection (if managed by this instance)\n   */\n  public async close(): Promise<void> {\n    if (this.client) {\n      try {\n        await this.client.close();\n      } catch (error) {\n        console.error(\"Error closing MongoDB connection:\", error);\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Check if MongoDB connection is ready\n   */\n  public isReady(): boolean {\n    return !!this.db;\n  }\n\n  /**\n   * Get database instance (for advanced usage)\n   */\n  public getDatabase(): Db {\n    if (!this.db) {\n      throw new Error(\"MongoDB not initialized. Call initialize() first.\");\n    }\n    return this.db;\n  }\n\n  /**\n   * Ensure MongoDB is initialized before operations\n   */\n  private ensureInitialized(): void {\n    if (!this.db) {\n      throw new Error(\n        \"MongoDB not initialized. Call initialize() first or provide db in constructor.\"\n      );\n    }\n  }\n}\n","/**\n * MongoDB Query Builder\n *\n * Implements query builder for MongoDB\n */\n\nimport {\n  IQueryBuilder,\n  IUpdateBuilder,\n  ComparisonOperator,\n} from \"../common/query-builder\";\n\n/**\n * MongoDB Query Builder implementation\n */\nexport class MongoDBQueryBuilder implements IQueryBuilder {\n  private query: Record<string, any> = {};\n  private orConditions: any[] = [];\n\n  where(field: string, operator: ComparisonOperator, value: any): this {\n    this.query[field] = this.buildOperator(operator, value);\n    return this;\n  }\n\n  and(field: string, operator: ComparisonOperator, value: any): this {\n    // In MongoDB, multiple conditions at the same level are implicitly AND\n    return this.where(field, operator, value);\n  }\n\n  or(conditions: IQueryBuilder[]): this {\n    this.orConditions = conditions.map((builder) => builder.build());\n    return this;\n  }\n\n  in(field: string, values: any[]): this {\n    this.query[field] = { $in: values };\n    return this;\n  }\n\n  regex(field: string, pattern: string, options?: string): this {\n    this.query[field] = new RegExp(pattern, options || \"i\");\n    return this;\n  }\n\n  build(): any {\n    if (this.orConditions.length > 0) {\n      return { $or: this.orConditions };\n    }\n    return this.query;\n  }\n\n  clone(): IQueryBuilder {\n    const cloned = new MongoDBQueryBuilder();\n    cloned.query = { ...this.query };\n    cloned.orConditions = [...this.orConditions];\n    return cloned;\n  }\n\n  /**\n   * Build MongoDB operator from generic operator\n   */\n  private buildOperator(operator: ComparisonOperator, value: any): any {\n    const operatorMap: Record<ComparisonOperator, string> = {\n      eq: \"$eq\",\n      ne: \"$ne\",\n      gt: \"$gt\",\n      gte: \"$gte\",\n      lt: \"$lt\",\n      lte: \"$lte\",\n      in: \"$in\",\n      nin: \"$nin\",\n    };\n\n    // For equality, MongoDB allows direct value assignment\n    if (operator === \"eq\") {\n      return value;\n    }\n\n    const mongoOp = operatorMap[operator];\n    return { [mongoOp]: value };\n  }\n}\n\n/**\n * MongoDB Update Builder implementation\n */\nexport class MongoDBUpdateBuilder implements IUpdateBuilder {\n  private updates: Record<string, any> = {};\n  private unsets: Record<string, any> = {};\n  private increments: Record<string, any> = {};\n\n  set(field: string, value: any): this {\n    this.updates[field] = value;\n    return this;\n  }\n\n  setMultiple(updates: Record<string, any>): this {\n    Object.assign(this.updates, updates);\n    return this;\n  }\n\n  unset(field: string): this {\n    this.unsets[field] = \"\";\n    return this;\n  }\n\n  increment(field: string, value: number): this {\n    this.increments[field] = value;\n    return this;\n  }\n\n  build(): any {\n    const result: Record<string, any> = {};\n\n    if (Object.keys(this.updates).length > 0) {\n      result.$set = this.updates;\n    }\n\n    if (Object.keys(this.unsets).length > 0) {\n      result.$unset = this.unsets;\n    }\n\n    if (Object.keys(this.increments).length > 0) {\n      result.$inc = this.increments;\n    }\n\n    return result;\n  }\n}\n","/**\n * MongoDB Adapter\n *\n * Implements database operations for MongoDB\n */\n\nimport { Collection, Db, Filter, UpdateFilter } from \"mongodb\";\nimport { IDatabaseAdapter, QueryOptions } from \"../common/types\";\nimport { IQueryBuilder, IUpdateBuilder } from \"../common/query-builder\";\nimport { MongoDBQueryBuilder, MongoDBUpdateBuilder } from \"./mongodb-query-builder\";\n\nexport class MongoDBAdapter implements IDatabaseAdapter {\n  constructor(private db: Db) {}\n\n  getCollection(name: string): Collection {\n    return this.db.collection(name);\n  }\n\n  async find<T = any>(\n    collection: Collection,\n    query: Filter<any>,\n    options?: QueryOptions\n  ): Promise<T[]> {\n    let cursor = collection.find(query);\n\n    if (options?.sort) {\n      cursor = cursor.sort(options.sort);\n    }\n    if (options?.skip) {\n      cursor = cursor.skip(options.skip);\n    }\n    if (options?.limit) {\n      cursor = cursor.limit(options.limit);\n    }\n\n    return cursor.toArray() as Promise<T[]>;\n  }\n\n  async findOne<T = any>(\n    collection: Collection,\n    query: Filter<any>\n  ): Promise<T | null> {\n    return collection.findOne(query) as Promise<T | null>;\n  }\n\n  async insertOne<T = any>(\n    collection: Collection,\n    document: Partial<T>\n  ): Promise<T> {\n    const result = await collection.insertOne(document as any);\n    return { _id: result.insertedId, ...document } as T;\n  }\n\n  async insertMany<T = any>(\n    collection: Collection,\n    documents: Partial<T>[]\n  ): Promise<{ insertedCount: number }> {\n    const result = await collection.insertMany(documents as any[]);\n    return { insertedCount: result.insertedCount };\n  }\n\n  async updateOne(\n    collection: Collection,\n    filter: Filter<any>,\n    update: any\n  ): Promise<{ modifiedCount: number }> {\n    // Check if update already has MongoDB operators\n    const hasOperators = Object.keys(update).some((key) => key.startsWith(\"$\"));\n    const updateDoc = hasOperators ? update : { $set: update };\n    \n    const result = await collection.updateOne(filter, updateDoc);\n    return { modifiedCount: result.modifiedCount };\n  }\n\n  async deleteOne(\n    collection: Collection,\n    filter: Filter<any>\n  ): Promise<{ deletedCount: number }> {\n    const result = await collection.deleteOne(filter);\n    return { deletedCount: result.deletedCount };\n  }\n\n  async deleteMany(\n    collection: Collection,\n    filter: Filter<any>\n  ): Promise<{ deletedCount: number }> {\n    const result = await collection.deleteMany(filter);\n    return { deletedCount: result.deletedCount };\n  }\n\n  async count(collection: Collection, query: Filter<any>): Promise<number> {\n    return collection.countDocuments(query);\n  }\n\n  // Query builder factory methods\n  createQueryBuilder(): IQueryBuilder {\n    return new MongoDBQueryBuilder();\n  }\n\n  createUpdateBuilder(): IUpdateBuilder {\n    return new MongoDBUpdateBuilder();\n  }\n}\n","/**\n * MongoDB Collection Manager\n *\n * Manages MongoDB collections for memory storage\n */\n\nimport { Db, Collection } from \"mongodb\";\nimport { ICollectionManager } from \"../common/types\";\nimport { MongoDBAdapter } from \"./mongodb-adapter\";\n\nexport class MongoDBCollectionManager implements ICollectionManager {\n  private adapter: MongoDBAdapter;\n  private eventsCollection: Collection;\n  private stateCollection: Collection;\n  private summaryCollection: Collection;\n\n  constructor(\n    private db: Db,\n    private collectionName: string,\n    private stateCollectionName: string,\n    private summaryCollectionName: string\n  ) {\n    this.adapter = new MongoDBAdapter(db);\n    this.eventsCollection = db.collection(collectionName);\n    this.stateCollection = db.collection(stateCollectionName);\n    this.summaryCollection = db.collection(summaryCollectionName);\n  }\n\n  getCollection(): Collection {\n    return this.eventsCollection;\n  }\n\n  getStateCollection(): Collection {\n    return this.stateCollection;\n  }\n\n  getSummaryCollection(): Collection {\n    return this.summaryCollection;\n  }\n\n  getDatabase(): Db {\n    return this.db;\n  }\n\n  getAdapter(): MongoDBAdapter {\n    return this.adapter;\n  }\n}\n","/**\n * Document Converter\n *\n * Converts between memory events and database documents\n */\n\nimport { IMemoryEvent } from \"../memory-base\";\nimport { BaseMemoryDocument } from \"./types\";\n\nexport class DocumentConverter {\n  /**\n   * Convert memory event to database document\n   */\n  toDocument(\n    event: IMemoryEvent,\n    sessionId: string,\n    branchPath: string\n  ): Omit<BaseMemoryDocument, \"_id\"> {\n    return {\n      sessionId,\n      messageId: event.message.id,\n      branchPath,\n      role: event.message.role,\n      content: event.message.content,\n      toolCalls: event.message.toolCalls,\n      toolCallId: event.message.toolCallId,\n      state: event.state,\n      createdAt: event.message.timestamp || new Date(),\n      updatedAt: new Date(),\n    };\n  }\n\n  /**\n   * Convert database document to memory event\n   */\n  fromDocument(doc: BaseMemoryDocument): IMemoryEvent {\n    return {\n      message: {\n        id: doc.messageId,\n        role: doc.role as any,\n        content: doc.content,\n        toolCalls: doc.toolCalls,\n        toolCallId: doc.toolCallId,\n        timestamp: doc.createdAt,\n      },\n      state: doc.state,\n    };\n  }\n}\n","/**\n * @fileoverview MySQL Memory implementation for persistent storage\n *\n * MySQL Memory implementation providing persistent storage using TypeORM\n * with MySQL-specific optimizations. Extends TypeORMMemory to provide\n * all advanced features including CRUD operations, session management,\n * branch isolation, context engineering, and soft delete using cursor-based approach.\n *\n * @example\n * ```typescript\n * // Basic usage\n * const memory = MySQLMemory.create({\n *   host: 'localhost',\n *   port: 3306,\n *   username: 'root',\n *   password: 'password',\n *   database: 'myapp',\n *   sessionId: 'user-session-123'\n * });\n *\n * await memory.add({\n *   message: { id: '1', role: 'user', content: 'Hello' },\n *   state: { userId: 'user123' }\n * });\n *\n * const events = await memory.list({ limit: 10 });\n * \n * // Clean up when done\n * await memory.close();\n * ```\n *\n * @example\n * ```typescript\n * // Advanced configuration with connection pooling and context management\n * const memory = new MySQLMemory({\n *   connection: {\n *     host: 'localhost',\n *     port: 3306,\n *     username: 'root',\n *     password: 'password',\n *     database: 'myapp',\n *     pool: {\n *       max: 20,\n *       min: 5,\n *       acquireTimeoutMillis: 30000,\n *       idleTimeoutMillis: 300000\n *     }\n *   },\n *   sessionId: 'user-session-123',\n *   eventTableName: 'custom_events',\n *   stateTableName:\n *     maxTokens: 8000,\n *     targetTokens: 6000,\n *     summaryTokens: 1000\n *   },\n *   enableContextManagement: true\n * });\n * ```\n *\n * @example\n * ```typescript\n * // Using connection string\n * const memory = MySQLMemory.fromConnectionString(\n *   'mysql://user:pass@localhost:3306/mydb',\n *   'session-123',\n *   {\n *     thresholds: { maxTokens: 10000 },\n *     enableContextManagement: true\n *   }\n * );\n * ```\n */\n\nimport { DataSource } from \"typeorm\";\nimport { MysqlConnectionOptions } from \"typeorm/driver/mysql/MysqlConnectionOptions.js\";\nimport { TypeORMMemory } from \"../typeorm/typeorm-memory\";\nimport { createMemoryEventEntity } from \"../typeorm/entities/memory-event.entity\";\nimport { createMemoryStateEntity } from \"../typeorm/entities/memory-state.entity\";\nimport { createMemorySummaryEntity } from \"../typeorm/entities/memory-summary.entity\";\n\n/**\n * MySQL-specific connection configuration\n * Extends TypeORM's MysqlConnectionOptions with additional AG-Kit specific options\n */\nexport interface MySQLConnectionConfig\n  extends Omit<\n    MysqlConnectionOptions,\n    \"type\" | \"entities\" | \"synchronize\" | \"logging\"\n  > {\n  /** MySQL host */\n  host: string;\n  /** MySQL port (default: 3306) */\n  port?: number;\n  /** MySQL username */\n  username: string;\n  /** MySQL password */\n  password: string;\n  /** MySQL database name */\n  database: string;\n}\n\n/**\n * Configuration options for MySQLMemory\n */\n\nexport type MySQLMemoryConfig = {\n  /** Database connection configuration */\n  connection: MySQLConnectionConfig;\n\n  /** Whether to automatically initialize database schema (default: true) */\n  autoInitialize?: boolean;\n\n  /** Enable SQL query logging for debugging (default: false) */\n  enableLogging?: boolean;\n} & Omit<ConstructorParameters<typeof TypeORMMemory>[0], \"dataSource\">;\n\n/**\n * MySQL Memory implementation using TypeORM\n *\n * This class extends TypeORMMemory and provides MySQL-specific configuration\n * and optimizations while leveraging all the advanced features including:\n * - Session-based memory isolation\n * - CRUD operations with soft delete\n * - Branch management and checkout\n * - Context engineering and automatic summarization\n * - Connection pooling and performance optimization\n * - Transaction support\n * - Schema synchronization\n * - Migration support\n * - MySQL-specific query optimizations\n */\nexport class MySQLMemory extends TypeORMMemory {\n  /**\n   * Creates a new MySQLMemory instance\n   * @param config - MySQL-specific configuration options\n   */\n  constructor(config: MySQLMemoryConfig) {\n    const dataSource = MySQLMemory.createMySQLDataSource(config);\n    super({ ...config, dataSource });\n  }\n\n  /**\n   * Create a MySQL DataSource configuration with optimizations\n   */\n  private static createMySQLDataSource(config: MySQLMemoryConfig): DataSource {\n    const options: MysqlConnectionOptions = {\n      // Use TypeORM's MysqlConnectionOptions as base\n      ...config.connection,\n\n      // Override required fields\n      type: \"mysql\",\n\n      // Use dynamic entity creation for table name customization\n      entities: [\n        createMemoryEventEntity(config.eventTableName || \"memory_events\"),\n        createMemoryStateEntity(config.stateTableName || \"memory_state\"),\n        createMemorySummaryEntity(\n          config.summaryTableName || \"memory_summaries\"\n        ),\n      ],\n\n      synchronize: config.autoInitialize !== false,\n      logging: config.enableLogging || false,\n\n      // MySQL-specific optimizations with defaults\n      charset: config.connection.charset || \"utf8mb4\",\n      timezone: config.connection.timezone || \"+00:00\",\n\n      // Enhanced extra options\n      extra: {\n        // Default MySQL optimizations\n        supportBigNumbers: true, // \n        bigNumberStrings: true,\n        multipleStatements: false, // Security: prevent SQL injection\n        dateStrings: false, // Use proper Date objects\n\n        // Merge with user-provided extra options\n        ...config.connection.extra,\n      },\n    };\n\n    return new DataSource(options);\n  }\n\n  /**\n   * Create a MySQL Memory instance with connection string\n   *\n   * @param connectionString - MySQL connection string (mysql://username:password@host:port/database)\n   * @param sessionId - Session identifier for memory isolation\n   * @param options - Additional configuration options\n   * @returns MySQLMemory instance\n   * 'custom_state',\n   *   summaryTableName: 'custom_summaries',\n   *   thresholds: {\n   * @example\n   * ```typescript\n   * const memory = MySQLMemory.fromConnectionString(\n   *   'mysql://user:pass@localhost:3306/mydb',\n   *   'session-123',\n   *   {\n   *     thresholds: { maxTokens: 10000 },\n   *     enableContextManagement: true\n   *   }\n   * );\n   * ```\n   */\n  static fromConnectionString(\n    connectionString: string,\n    sessionId: string,\n    options?: Partial<MySQLMemoryConfig>\n  ): MySQLMemory {\n    // Parse connection string (mysql://username:password@host:port/database)\n    const url = new URL(connectionString);\n\n    if (url.protocol !== \"mysql:\") {\n      throw new Error(\n        \"Invalid MySQL connection string. Must start with 'mysql://'\"\n      );\n    }\n\n    const connection: MySQLConnectionConfig = {\n      host: url.hostname,\n      port: url.port ? parseInt(url.port) : 3306,\n      username: url.username,\n      password: url.password,\n      database: url.pathname.slice(1), // Remove leading slash\n    };\n\n    return new MySQLMemory({\n      connection,\n      sessionId,\n      ...options,\n    });\n  }\n\n  /**\n   * Create a MySQL Memory instance with simple configuration\n   *\n   * @param config - Simple configuration object\n   * @returns MySQLMemory instance\n   *\n   * @example\n   * ```typescript\n   * const memory = MySQLMemory.create({\n   *   host: 'localhost',\n   *   port: 3306,\n   *   username: 'root',\n   *   password: 'password',\n   *   database: 'myapp',\n   *   sessionId: 'user-session-123'\n   * });\n   * ```\n   */\n  static create(config: MySQLMemoryConfig): MySQLMemory {\n    return new MySQLMemory({\n      connection: config.connection,\n      sessionId: config.sessionId,\n      eventTableName: config.eventTableName,\n      stateTableName: config.stateTableName,\n      summaryTableName: config.summaryTableName,\n      autoInitialize: config.autoInitialize,\n      enableContextManagement: config.enableContextManagement,\n      thresholds: config.thresholds,\n      tokenizer: config.tokenizer,\n      summarizer: config.summarizer,\n    });\n  }\n\n  /**\n   * Get MySQL-specific connection information\n   * @returns Connection information object\n   */\n  public getConnectionInfo(): {\n    host: string;\n    port: number;\n    database: string;\n    username: string;\n  } {\n    const options = (this as any).dataSource.options;\n    return {\n      host: options.host,\n      port: options.port,\n      database: options.database,\n      username: options.username,\n    };\n  }\n}\n","/**\n * @fileoverview TypeORM memory implementation for persistent storage\n *\n * TypeORM Memory implementation providing persistent storage using TypeORM\n * with support for CRUD operations, session management, branch isolation,\n * and soft delete using cursor-based approach. Supports multiple databases\n * including MySQL, PostgreSQL, and SQLite.\n *\n * @example\n * ```typescript\n * import { DataSource } from 'typeorm';\n *\n * const dataSource = new DataSource({\n *   type: 'sqlite',\n *   database: ':memory:',\n *   entities: [MemoryEvent, MemoryState, MemorySummary],\n *   synchronize: true\n * });\n * await dataSource.initialize();\n *\n * const memory = new TypeORMMemory({\n *   dataSource,\n *   sessionId: 'user-session-123',\n *   eventTableName: 'memory_events'\n * });\n *\n * await memory.add({\n *   message: { id: '1', role: 'user', content: 'Hello' },\n *   state: { userId: 'user123' }\n * });\n *\n * const events = await memory.list({ limit: 10 });\n * ```\n */\n\nimport { DataSource } from \"typeorm\";\nimport {\n  BaseMemory,\n  IMemoryEvent,\n  ListOptions,\n  AddOptions,\n  DeleteOptions,\n  RetrieveOptions,\n  ClearOptions,\n  StructuredSummary,\n  BranchInfo,\n  IBaseMemoryOptions,\n} from \"../memory-base\";\nimport { TypeORMCollectionManager } from \"./typeorm-collection-manager\";\nimport { DocumentConverter } from \"../common/document-converter\";\nimport { StateManager } from \"../common/state-manager\";\nimport { CursorManager } from \"../common/cursor-manager\";\nimport { BranchManager } from \"../common/branch-manager\";\nimport { SummaryManager } from \"../common/summary-manager\";\nimport { BaseMemoryDocument } from \"../common/types\";\nimport { createMemoryEventEntity } from \"./entities/memory-event.entity\";\nimport { createMemoryStateEntity } from \"./entities/memory-state.entity\";\nimport { createMemorySummaryEntity } from \"./entities/memory-summary.entity\";\nimport { TypeORMQueryBuilder } from \"./typeorm-query-builder\";\n\n/**\n * Configuration options for TypeORMMemory\n */\nexport interface TypeORMMemoryConfig extends IBaseMemoryOptions {\n  // DataSource instance\n  dataSource: DataSource;\n\n  // Table configuration\n  eventTableName?: string;\n  stateTableName?: string;\n  summaryTableName?: string;\n\n  // Session configuration\n  sessionId?: string;\n\n  // Context management\n  enableContextManagement?: boolean;\n\n  // Custom document converter\n  documentConverter?: DocumentConverter;\n}\n\n/**\n * TypeORM Memory implementation for persistent storage\n *\n * Provides persistent storage using TypeORM with support for\n * session-based memory management, CRUD operations, branch isolation, optional context engineering,\n * and efficient soft delete using cursor-based approach.\n */\nexport class TypeORMMemory extends BaseMemory {\n  /** Session identifier for memory isolation */\n  public sessionId: string;\n  /** Whether to enable automatic context management */\n  private enableContextManagement: boolean;\n\n  // Core database components\n  private dataSource: DataSource;\n\n  // Core utilities\n  private collectionManager!: TypeORMCollectionManager;\n  private documentConverter!: DocumentConverter;\n\n  // Managers\n  private stateManager!: StateManager;\n  private cursorManager!: CursorManager;\n  private branchManager!: BranchManager;\n  private summaryManager!: SummaryManager;\n\n  /**\n   * Creates a new TypeORMMemory instance\n   * @param config - Configuration options\n   * @param config.dataSource - TypeORM DataSource instance\n   * @param config.eventTableName - Table name for storing events (default: 'memory_events')\n   * @param config.summaryTableName - Table name for storing summaries (default: 'memory_summaries')\n   * @param config.stateTableName - Table name for storing session state (default: 'memory_state')\n   * @param config.sessionId - Unique session identifier (default: 'default')\n   * @param config.enableContextManagement - Whether to automatically manage context (default: true if thresholds provided)\n   */\n  constructor(config: TypeORMMemoryConfig) {\n    super(config);\n\n    if (!config.dataSource) {\n      throw new Error(\"DataSource instance must be provided\");\n    }\n\n    // Store the DataSource (may not be initialized yet)\n    this.dataSource = config.dataSource;\n\n    this.sessionId = config.sessionId || \"default\";\n    this.enableContextManagement =\n      config.enableContextManagement ?? (config.thresholds ? true : false);\n\n    // Initialize entities and managers asynchronously\n    this._initializationPromise = this._initialize(config);\n  }\n\n  // Promise to track initialization completion\n  private _initializationPromise: Promise<void>;\n\n  /**\n   * Initialize entities and managers asynchronously\n   */\n  private async _initialize(config: TypeORMMemoryConfig): Promise<void> {\n    await this._initializeEntities(config);\n    this._initializeManagers(config);\n  }\n\n  /**\n   * Initialize entities based on table names and ensure DataSource uses them\n   * This approach ensures that the same entity classes are used for both\n   * DataSource registration and repository creation\n   */\n  private async _initializeEntities(\n    config: TypeORMMemoryConfig\n  ): Promise<void> {\n    // Get existing entities from DataSource (if any) and filter out our entity types\n    const existingEntities = this.dataSource.options.entities || [];\n\n    // Set DataSource entities to use our constructed entities\n    // This ensures the module is self-contained and doesn't require users to manage entities\n    this.dataSource.setOptions({\n      ...this.dataSource.options,\n      entities: existingEntities?.length\n        ? existingEntities\n        : [\n            createMemoryEventEntity(config.eventTableName),\n            createMemoryStateEntity(config.stateTableName),\n            createMemorySummaryEntity(config.summaryTableName),\n          ],\n    });\n\n    // Important: If DataSource is already initialized, we need to rebuild metadata and sync\n    // This is necessary when entities are added after initialization\n    if (this.dataSource.isInitialized) {\n      // Force rebuild of entity metadata to recognize new entities\n      (this.dataSource as any).buildMetadatas();\n\n      // If synchronize is enabled, sync the new tables\n      if (this.dataSource.options.synchronize) {\n        try {\n          // Synchronize the database schema to create new tables\n          await this.dataSource.synchronize();\n        } catch (error) {\n          console.warn(\"Failed to synchronize database schema:\", error);\n          // Continue anyway - the tables might already exist or be created later\n        }\n      }\n    }\n  }\n\n  /**\n   * Initialize all manager instances\n   */\n  private _initializeManagers(config: TypeORMMemoryConfig): void {\n    if (!this.dataSource) {\n      throw new Error(\"DataSource instance is required for initialization\");\n    }\n\n    // Initialize core utilities\n    this.collectionManager = new TypeORMCollectionManager(\n      this.dataSource,\n      config.eventTableName || \"memory_events\",\n      config.stateTableName || \"memory_state\",\n      config.summaryTableName || \"memory_summaries\"\n    );\n\n    this.documentConverter = config.documentConverter || new DocumentConverter();\n\n    // Initialize managers\n    this.stateManager = new StateManager(this.collectionManager);\n    this.cursorManager = new CursorManager(\n      this.collectionManager,\n      this.stateManager\n    );\n    this.branchManager = new BranchManager(\n      this.collectionManager,\n      this.stateManager,\n      this.cursorManager\n    );\n    this.summaryManager = new SummaryManager(\n      this.sessionId,\n      this.collectionManager,\n      this.cursorManager\n    );\n  }\n\n  // ==================== CRUD Operations ====================\n\n  /**\n   * Add a single event to TypeORM database\n   * @param event - The memory event to store\n   * @param options - Optional session options\n   */\n  public async add(event: IMemoryEvent, options?: AddOptions): Promise<void> {\n    await this.ensureInitialized();\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      // Ensure timestamp\n      if (!event.message.timestamp) {\n        event.message.timestamp = new Date();\n      }\n\n      // Get current branch path\n      const branchPath = await this.branchManager.getCurrentBranchPath(sid);\n\n      // Create document\n      const doc = this.documentConverter.toDocument(event, sid, branchPath);\n\n      // Use adapter to insert\n      await adapter.insertOne(collection, doc);\n    } catch (error) {\n      console.error(\"Error adding event to TypeORM:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Add multiple events efficiently\n   * @param list - Array of memory events to store\n   * @param options - Optional session options\n   */\n  public async addList(\n    list: IMemoryEvent[],\n    options?: AddOptions\n  ): Promise<void> {\n    if (list.length === 0) return;\n\n    for (const event of list) {\n      await this.add(event, options);\n    }\n  }\n\n  /**\n   * Returns events from TypeORM database with filtering, pagination, and token limiting\n   * Respects branch isolation using branch path and snapshot time\n   * @param options - Optional filtering and pagination options\n   * @returns Promise resolving to filtered array of memory events\n   */\n  public async list(options?: ListOptions): Promise<IMemoryEvent[]> {\n    await this.ensureInitialized();\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      // Get current branch path\n      const currentBranchPath =\n        await this.branchManager.getCurrentBranchPath(sid);\n\n      // Build branch conditions using adapter\n      const branchConditions = await this.branchManager.buildBranchConditions(\n        sid,\n        currentBranchPath\n      );\n\n      // Apply soft delete cursor\n      const startCursor = await this.cursorManager.getStartCursor(sid);\n      let conditions = branchConditions;\n\n      if (startCursor) {\n        conditions = this.branchManager.applyCursorCondition(\n          conditions,\n          startCursor\n        );\n      }\n\n      // Execute query with OR conditions using adapter\n      let whereCondition: any;\n      if (conditions.length > 1) {\n        // Conditions are already built query objects, we need to combine them with OR\n        // Use the adapter's array query handling instead of manually building OR\n        whereCondition = conditions;\n      } else {\n        whereCondition = conditions[0];\n      }\n\n      // Apply ordering\n      const order = options?.order || \"asc\";\n      const queryOptions: any = {\n        sort: { createdAt: order === \"asc\" ? 1 : -1 },\n      };\n\n      if (options?.offset) {\n        queryOptions.skip = options.offset;\n      }\n      if (options?.limit) {\n        queryOptions.limit = options.limit;\n      }\n\n      // Execute query using adapter\n      const result = await adapter.find(\n        collection,\n        whereCondition,\n        queryOptions\n      );\n\n      let events = (order === \"desc\" ? result.reverse() : result).map(\n        (doc: BaseMemoryDocument) => this.documentConverter.fromDocument(doc)\n      );\n\n      // Trigger context management if enabled\n      if (this.enableContextManagement && events.length > 0) {\n        const res = await this.manageContext({ sessionId: sid, events });\n        events = res.events;\n      }\n\n      // Apply token limiting if specified\n      if (options?.maxTokens) {\n        events = this.tokenTrimmer.trimMessages(events, options.maxTokens);\n      }\n\n      return events;\n    } catch (error) {\n      console.error(\"Error listing events from TypeORM:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update an event in TypeORM database\n   * @param params - Update parameters\n   */\n  public async update(params: {\n    sessionId?: string;\n    event: IMemoryEvent;\n  }): Promise<void> {\n    await this.ensureInitialized();\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = params.sessionId || this.sessionId;\n\n      // Build query using adapter\n      const query = adapter\n        .createQueryBuilder()\n        .where(\"sessionId\", \"eq\", sid)\n        .and(\"messageId\", \"eq\", params.event.message.id)\n        .build();\n\n      // Find the document\n      const doc = await adapter.findOne<BaseMemoryDocument>(collection, query);\n\n      if (!doc) {\n        throw new Error(\n          `Event with messageId '${params.event.message.id}' not found in session '${sid}'`\n        );\n      }\n\n      const branchPath = await this.branchManager.getCurrentBranchPath(sid);\n      const updateDoc = this.documentConverter.toDocument(\n        params.event,\n        sid,\n        branchPath\n      );\n\n      // Build update using adapter\n      const update = adapter\n        .createUpdateBuilder()\n        .setMultiple({\n          ...updateDoc,\n          updatedAt: new Date(),\n        })\n        .build();\n\n      // Update using adapter\n      await adapter.updateOne(collection, query, update);\n    } catch (error) {\n      console.error(\"Error updating event in TypeORM:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete an event from TypeORM database\n   * @param idOrIndex - Message ID (string) to delete\n   * @param options - Optional session options\n   */\n  public async delete(\n    idOrIndex: string | number,\n    options?: DeleteOptions\n  ): Promise<void> {\n    await this.ensureInitialized();\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      if (typeof idOrIndex === \"string\") {\n        // Delete by message ID using adapter\n        const query = adapter\n          .createQueryBuilder()\n          .where(\"sessionId\", \"eq\", sid)\n          .and(\"messageId\", \"eq\", idOrIndex)\n          .build();\n\n        await adapter.deleteMany(collection, query);\n      } else {\n        // Delete by index - not recommended for TypeORM\n        console.warn(\n          \"Deleting by index is not efficient in TypeORM. Consider using message ID instead.\"\n        );\n        const events = await this.list({ sessionId: sid });\n        if (idOrIndex >= 0 && idOrIndex < events.length) {\n          const eventToDelete = events[idOrIndex];\n          await this.delete(eventToDelete.message.id, options);\n        }\n      }\n    } catch (error) {\n      console.error(\"Error deleting event from TypeORM:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clear all events from TypeORM database\n   * @param options - Optional session options. If sessionId provided, clears only that session using soft delete.\n   */\n  public async clear(options?: ClearOptions): Promise<void> {\n    await this.ensureInitialized();\n    try {\n      const collection = this.collectionManager.getCollection();\n      const stateCollection = this.collectionManager.getStateCollection();\n      const summaryCollection = this.collectionManager.getSummaryCollection();\n\n      if (options?.sessionId) {\n        // Clear specific session - use soft delete by setting cursor to last event\n        const sid = options.sessionId;\n        const adapter = this.collectionManager.getAdapter();\n\n        // Get the last event in the session\n        const result = await adapter.find<BaseMemoryDocument>(\n          collection,\n          { sessionId: sid },\n          { sort: { createdAt: -1 }, limit: 1 }\n        );\n\n        if (result.length > 0) {\n          const lastEvent = result[0];\n          // Set cursor to the last event's timestamp, effectively hiding all events\n          await this.cursorManager.setStartCursor(sid, lastEvent.createdAt);\n        }\n\n        // Clear summaries for this session\n        await adapter.deleteMany(summaryCollection, { sessionId: sid });\n      } else {\n        // Clear all sessions - hard delete\n        const adapter = this.collectionManager.getAdapter();\n\n        // Delete all documents\n        await adapter.deleteMany(collection, {});\n        await adapter.deleteMany(stateCollection, {});\n        await adapter.deleteMany(summaryCollection, {});\n      }\n\n      // Clear cache\n      this.stateManager.clearCache();\n    } catch (error) {\n      console.error(\"Error clearing events from TypeORM:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Check if the session contains any events (respecting soft delete)\n   * @param options - Optional session options\n   * @returns Promise resolving to true if no events are stored\n   */\n  public async isEmpty(options?: { sessionId?: string }): Promise<boolean> {\n    return (await this.getCount(options)) === 0;\n  }\n\n  /**\n   * Get the current number of events stored in the session (respecting soft delete)\n   * @param options - Optional session options\n   * @returns Promise resolving to the count of stored events\n   */\n  public async getCount(options?: { sessionId?: string }): Promise<number> {\n    await this.ensureInitialized();\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      // Get current branch path\n      const currentBranchPath =\n        await this.branchManager.getCurrentBranchPath(sid);\n\n      // Build branch conditions\n      const branchConditions = await this.branchManager.buildBranchConditions(\n        sid,\n        currentBranchPath\n      );\n\n      // Apply soft delete cursor\n      const startCursor = await this.cursorManager.getStartCursor(sid);\n      let conditions = branchConditions;\n\n      if (startCursor) {\n        conditions = this.branchManager.applyCursorCondition(\n          conditions,\n          startCursor\n        );\n      }\n\n      // Execute count query using adapter\n      let whereCondition: any;\n      if (conditions.length > 1) {\n        // Conditions are already built query objects, we need to combine them with OR\n        // Use the adapter's array query handling instead of manually building OR\n        whereCondition = conditions;\n      } else {\n        whereCondition = conditions[0];\n      }\n\n      const count = await adapter.count(collection, whereCondition);\n      return count;\n    } catch (error) {\n      console.error(\"Error getting count from TypeORM:\", error);\n      return 0;\n    }\n  }\n\n  // ==================== Search Operations ====================\n\n  /**\n   * Retrieve events using content-based search\n   * @param query - Search query text to match against message content\n   * @param options - Optional session options\n   * @returns Promise resolving to array of matching events\n   */\n  public async retrieve(\n    query: string,\n    options?: RetrieveOptions\n  ): Promise<IMemoryEvent[]> {\n    await this.ensureInitialized();\n    try {\n      const collection = this.collectionManager.getCollection();\n      const adapter = this.collectionManager.getAdapter();\n      const sid = options?.sessionId || this.sessionId;\n\n      // Get start cursor for soft delete\n      const startCursor = await this.cursorManager.getStartCursor(sid);\n\n      // Use TypeORM query builder for case-insensitive LIKE search\n      const queryBuilder = new TypeORMQueryBuilder();\n      queryBuilder\n        .where(\"sessionId\", \"=\", sid)\n        .and(\"content\", \"ILIKE\", `%${query}%`);\n\n      // Apply soft delete cursor\n      if (startCursor) {\n        queryBuilder.and(\"createdAt\", \">\", startCursor);\n      }\n\n      const result = await adapter.find<BaseMemoryDocument>(\n        collection,\n        queryBuilder.build()\n      );\n\n      return result.map((doc: BaseMemoryDocument) =>\n        this.documentConverter.fromDocument(doc)\n      );\n    } catch (error) {\n      console.error(\"Error retrieving events from TypeORM:\", error);\n      throw error;\n    }\n  }\n\n  // ==================== Summary Operations ====================\n\n  /**\n   * Get summaries for a session\n   * @param sessionId - Optional session identifier\n   * @returns Array of structured summaries\n   */\n  public async getSummaries(sessionId?: string): Promise<StructuredSummary[]> {\n    const summaries = await this.summaryManager.getSummaries(sessionId);\n\n    // Convert BaseSummaryDocument to StructuredSummary\n    return summaries.map((doc) => ({\n      content: doc.content,\n      count: 1, // Default count since BaseSummaryDocument doesn't have count\n      timeRange: {\n        start: doc.metadata?.timeRangeStart,\n        end: doc.metadata?.timeRangeEnd,\n      },\n      timestamp: doc.createdAt,\n    }));\n  }\n\n  /**\n   * Store summary implementation\n   * @param params - Summary storage parameters\n   */\n  protected async storeSummary(params: {\n    sessionId?: string;\n    summary: StructuredSummary;\n  }): Promise<void> {\n    const summaryId = `summary_${Date.now()}`;\n    const metadata = {\n      count: params.summary.count,\n      timeRangeStart: params.summary.timeRange.start,\n      timeRangeEnd: params.summary.timeRange.end,\n    };\n\n    return this.summaryManager.addSummary(\n      summaryId,\n      params.summary.content,\n      metadata,\n      params.sessionId\n    );\n  }\n\n  /**\n   * Clear summarized events implementation using soft delete\n   * Sets cursor to hide old events without actually deleting them\n   * @param params - Clear parameters\n   */\n  protected async clearSummarizedEvents(params: {\n    sessionId: string | undefined;\n    recentToKeep: number;\n  }): Promise<void> {\n    return this.summaryManager.clearSummarizedEvents(params);\n  }\n\n  // ==================== Branch Management ====================\n\n  /**\n   * Create a new branch from current session state\n   * @param branchName - Name for the new branch\n   * @param fromEventId - Optional event ID to branch from\n   * @returns Promise resolving to branch ID\n   */\n  public async branch(\n    branchName: string,\n    fromEventId?: string\n  ): Promise<string> {\n    await this.ensureInitialized();\n    return this.branchManager.createBranch(\n      this.sessionId,\n      branchName,\n      fromEventId,\n      () => this.list({ sessionId: this.sessionId })\n    );\n  }\n\n  /**\n   * Switch to a different branch or checkout to a specific event\n   * @param target - Branch name or event ID to checkout\n   * @param options - Optional configuration\n   */\n  public async checkout(\n    target: string,\n    options?: { type?: \"branch\" | \"event\"; sessionId?: string }\n  ): Promise<void> {\n    await this.ensureInitialized();\n    const sid = options?.sessionId || this.sessionId;\n    const checkoutType =\n      options?.type ||\n      (await this.branchManager.detectCheckoutType(sid, target));\n\n    if (checkoutType === \"event\") {\n      const collection = this.collectionManager.getCollection();\n      const event = await this.cursorManager.getEventByMessageId(sid, target);\n      const adapter = this.collectionManager.getAdapter();\n\n      if (!event) {\n        throw new Error(`Event '${target}' not found in session '${sid}'`);\n      }\n\n      const currentBranchPath =\n        await this.branchManager.getCurrentBranchPath(sid);\n\n      // Build branch conditions\n      let conditions = await this.branchManager.buildBranchConditions(\n        sid,\n        currentBranchPath\n      );\n\n      conditions = this.branchManager.applyCursorCondition(\n        conditions,\n        event.createdAt\n      );\n\n      let whereCondition: any;\n      if (conditions.length > 1) {\n        // Conditions are already built query objects, we need to combine them with OR\n        // Use the adapter's array query handling instead of manually building OR\n        whereCondition = conditions;\n      } else {\n        whereCondition = conditions[0];\n      }\n\n      await adapter.deleteMany(collection, whereCondition);\n    } else {\n      await this.branchManager.checkoutBranch(sid, target);\n    }\n  }\n\n  /**\n   * Delete a branch\n   * @param branchName - Name of the branch to delete\n   */\n  public async deleteBranch(branchName: string): Promise<void> {\n    await this.ensureInitialized();\n    return this.branchManager.deleteBranch(this.sessionId, branchName);\n  }\n\n  /**\n   * List all branches\n   * @returns Promise resolving to array of branch information\n   */\n  public async listBranches(): Promise<BranchInfo[]> {\n    await this.ensureInitialized();\n    const branches = await this.branchManager.listBranches(this.sessionId);\n    const currentBranch = await this.getCurrentBranch();\n\n    return branches.map((branch: any) => ({\n      id: branch.name,\n      name: branch.name,\n      createdAt: branch.createdAt,\n      fromEventId: branch.fromEventId,\n      eventCount: 0, // TODO: Implement event count\n      isActive: branch.name === currentBranch,\n    }));\n  }\n\n  /**\n   * Get current branch name\n   * @returns Promise resolving to current branch name\n   */\n  public async getCurrentBranch(): Promise<string> {\n    await this.ensureInitialized();\n    return this.branchManager.getCurrentBranch(this.sessionId);\n  }\n\n  /**\n   * Clean up branches, keeping only specified branches and the current active branch\n   * @param keepBranches - Optional list of branch names to keep (in addition to active branch)\n   */\n  public async cleanupBranches(keepBranches?: string[]): Promise<void> {\n    await this.ensureInitialized();\n    return this.branchManager.cleanupBranches(this.sessionId, keepBranches);\n  }\n\n  // ==================== Utility Methods ====================\n\n  /**\n   * Check if TypeORM connection is ready\n   */\n  public isReady(): boolean {\n    return !!this.dataSource && this.dataSource.isInitialized;\n  }\n\n  /**\n   * Close TypeORM DataSource connection and clean up resources\n   * This method should be called when the memory instance is no longer needed\n   * to properly release database connections and prevent connection leaks\n   * \n   * @throws Error if there's an issue closing the connection\n   * \n   * @example\n   * ```typescript\n   * const memory = new TypeORMMemory({ dataSource, sessionId: 'test' });\n   * // ... use memory\n   * await memory.close(); // Clean up when done\n   * ```\n   */\n  public async close(): Promise<void> {\n    if (this.dataSource && this.dataSource.isInitialized) {\n      try {\n        await this.dataSource.destroy();\n      } catch (error) {\n        console.error(\"Error closing TypeORM DataSource connection:\", error);\n        throw error;\n      }\n    }\n  }\n\n  /**\n   * Get DataSource instance (for advanced usage)\n   */\n  public getDataSource(): DataSource {\n    if (!this.dataSource) {\n      throw new Error(\"TypeORM DataSource not initialized.\");\n    }\n    return this.dataSource;\n  }\n\n  /**\n   * Ensure TypeORM is initialized before operations\n   */\n  public async ensureInitialized(): Promise<void> {\n    // Wait for entity and manager initialization to complete\n    await this._initializationPromise;\n\n    if (!this.dataSource) {\n      throw new Error(\"DataSource instance is required\");\n    }\n\n    // Initialize DataSource if not already initialized\n    if (!this.dataSource.isInitialized) {\n      try {\n        await this.dataSource.initialize();\n      } catch (error) {\n        console.error(\"Failed to initialize DataSource:\", error);\n        throw error;\n      }\n    }\n\n    if (!this.collectionManager) {\n      throw new Error(\"TypeORMMemory not properly initialized\");\n    }\n  }\n\n  /**\n   * Create a TypeORM DataSource configuration\n   */\n  static createDataSource(config: {\n    type: \"mysql\" | \"postgres\" | \"sqlite\";\n    host?: string;\n    port?: number;\n    username?: string;\n    password?: string;\n    database?: string;\n    filename?: string; // For SQLite\n    synchronize?: boolean;\n    logging?: boolean;\n  }): DataSource {\n    const baseConfig: any = {\n      type: config.type,\n      synchronize: config.synchronize ?? false,\n      logging: config.logging ?? false,\n      entities: [],\n      migrations: [],\n      subscribers: [],\n    };\n\n    if (config.type === \"sqlite\") {\n      baseConfig.database = config.filename || \":memory:\";\n    } else {\n      baseConfig.host = config.host;\n      baseConfig.port = config.port;\n      baseConfig.username = config.username;\n      baseConfig.password = config.password;\n      baseConfig.database = config.database;\n    }\n\n    return new DataSource(baseConfig);\n  }\n}\n","/**\n * TypeORM Query Builder Implementation\n *\n * Provides type-safe query building for TypeORM with SQL injection protection\n */\n\nimport { IQueryBuilder, IUpdateBuilder } from \"../common/query-builder\";\n\nexport class TypeORMQueryBuilder implements IQueryBuilder {\n  private conditions: any[] = [];\n  private parameters: Record<string, any> = {};\n  private paramCounter = 0;\n  private orConditions: any[] = [];\n\n  where(field: string, operator: any, value: any): this {\n    return this.addCondition(field, operator, value);\n  }\n\n  and(field: string, operator: any, value: any): this {\n    return this.addCondition(field, operator, value);\n  }\n\n  or(conditions: IQueryBuilder[]): this {\n    // Build OR conditions from the provided query builders\n    this.orConditions = conditions.map((builder) => {\n      const built = builder.build();\n      if (built.__typeorm_query__) {\n        return {\n          where: built.where,\n          parameters: built.parameters,\n        };\n      }\n      return built;\n    });\n    return this;\n  }\n\n  in(field: string, values: any[]): this {\n    const paramName = `param_${this.paramCounter++}`;\n    this.conditions.push(`entity.${field} IN (:...${paramName})`);\n    this.parameters[paramName] = values;\n    return this;\n  }\n\n  regex(field: string, pattern: string, options?: string): this {\n    // Convert regex to LIKE pattern for basic compatibility\n    const paramName = `param_${this.paramCounter++}`;\n    const likePattern = pattern\n      .replace(/\\.\\*/g, \"%\")\n      .replace(/\\./g, \"_\")\n      .replace(/^\\^/, \"\")\n      .replace(/\\$$/, \"\");\n\n    this.conditions.push(`entity.${field} LIKE :${paramName}`);\n    this.parameters[paramName] = likePattern;\n    return this;\n  }\n\n  clone(): IQueryBuilder {\n    const cloned = new TypeORMQueryBuilder();\n    cloned.conditions = [...this.conditions];\n    cloned.parameters = { ...this.parameters };\n    cloned.paramCounter = this.paramCounter;\n    cloned.orConditions = [...this.orConditions];\n    return cloned;\n  }\n\n  build(): any {\n    // Handle OR conditions\n    if (this.orConditions.length > 0) {\n      // Combine all parameters from OR conditions with unique names\n      const allParameters: Record<string, any> = { ...this.parameters };\n      let globalParamCounter = this.paramCounter;\n\n      // Build OR clause with parameter renaming to avoid conflicts\n      const orClauses: string[] = [];\n\n      for (const orCondition of this.orConditions) {\n        if (orCondition.where && orCondition.parameters) {\n          let whereClause = orCondition.where;\n\n          // Rename parameters to avoid conflicts\n          for (const [oldParam, value] of Object.entries(\n            orCondition.parameters\n          )) {\n            const newParam = `param_${globalParamCounter++}`;\n            whereClause = whereClause.replace(\n              new RegExp(`:${oldParam}\\\\b`, \"g\"),\n              `:${newParam}`\n            );\n            allParameters[newParam] = value;\n          }\n\n          orClauses.push(`(${whereClause})`);\n        }\n      }\n\n      // Combine AND conditions with OR conditions\n      let finalWhere = \"\";\n      if (this.conditions.length > 0) {\n        finalWhere = this.conditions.join(\" AND \");\n        if (orClauses.length > 0) {\n          finalWhere += ` AND (${orClauses.join(\" OR \")})`;\n        }\n      } else if (orClauses.length > 0) {\n        finalWhere = orClauses.join(\" OR \");\n      }\n\n      return {\n        __typeorm_query__: true,\n        where: finalWhere,\n        parameters: allParameters,\n      };\n    }\n\n    // Handle regular AND conditions\n    if (this.conditions.length === 0) {\n      return {};\n    }\n\n    return {\n      __typeorm_query__: true,\n      where: this.conditions.join(\" AND \"),\n      parameters: this.parameters,\n    };\n  }\n\n  // Helper method to add conditions based on operator\n  private addCondition(field: string, operator: any, value: any): this {\n    const paramName = `param_${this.paramCounter++}`;\n\n    switch (operator) {\n      case \"eq\":\n        this.conditions.push(`entity.${field} = :${paramName}`);\n        break;\n      case \"ne\":\n        this.conditions.push(`entity.${field} != :${paramName}`);\n        break;\n      case \"gt\":\n        this.conditions.push(`entity.${field} > :${paramName}`);\n        break;\n      case \"gte\":\n        this.conditions.push(`entity.${field} >= :${paramName}`);\n        break;\n      case \"lt\":\n        this.conditions.push(`entity.${field} < :${paramName}`);\n        break;\n      case \"lte\":\n        this.conditions.push(`entity.${field} <= :${paramName}`);\n        break;\n      case \"in\":\n        this.conditions.push(`entity.${field} IN (:...${paramName})`);\n        break;\n      case \"nin\":\n        this.conditions.push(`entity.${field} NOT IN (:...${paramName})`);\n        break;\n      case \"LIKE\":\n      case \"like\":\n        this.conditions.push(`entity.${field} LIKE :${paramName}`);\n        break;\n      case \"ILIKE\":\n      case \"ilike\":\n        this.conditions.push(`LOWER(entity.${field}) LIKE LOWER(:${paramName})`);\n        break;\n      default:\n        this.conditions.push(`entity.${field} = :${paramName}`);\n    }\n\n    this.parameters[paramName] = value;\n    return this;\n  }\n}\n\nexport class TypeORMUpdateBuilder implements IUpdateBuilder {\n  private updates: Record<string, any> = {};\n\n  set(field: string, value: any): this {\n    this.updates[field] = value;\n    return this;\n  }\n\n  setMultiple(updates: Record<string, any>): this {\n    Object.assign(this.updates, updates);\n    return this;\n  }\n\n  unset(field: string): this {\n    this.updates[field] = null;\n    return this;\n  }\n\n  increment(field: string, value: number): this {\n    // TypeORM doesn't support increment in update objects directly\n    // This would need to be handled at the adapter level\n    console.warn(\"Increment operations require special handling in TypeORM\");\n    this.updates[field] = value; // Fallback to set\n    return this;\n  }\n\n  build(): any {\n    return { $set: this.updates };\n  }\n}\n","/**\n * Simplified TypeORM Adapter\n *\n * Simple adapter that works with TypeORM repositories\n */\n\nimport { Repository, FindManyOptions, FindOneOptions, SelectQueryBuilder } from \"typeorm\";\nimport { IDatabaseAdapter, QueryOptions } from \"../common/types\";\nimport { IQueryBuilder, IUpdateBuilder } from \"../common/query-builder\";\nimport {\n  TypeORMQueryBuilder,\n  TypeORMUpdateBuilder,\n} from \"./typeorm-query-builder\";\n\nexport class TypeORMAdapter implements IDatabaseAdapter {\n  /**\n   * Get collection (for TypeORM, this is handled by CollectionManager)\n   * This method is required by IDatabaseAdapter but not used directly\n   */\n  getCollection(name: string): any {\n    throw new Error(\"getCollection should not be called directly on TypeORMAdapter. Use TypeORMCollectionManager instead.\");\n  }\n\n  /**\n   * Find documents using TypeORM repository\n   */\n  async find<T = any>(\n    repository: Repository<any>,\n    query: any,\n    options?: QueryOptions\n  ): Promise<T[]> {\n    // Determine query type and delegate to appropriate handler\n    if (this.isComplexQuery(query)) {\n      return this.handleComplexQuery(repository, query, options);\n    } else if (Array.isArray(query)) {\n      return this.handleArrayQuery(repository, query, options);\n    } else {\n      return this.handleSimpleQuery(repository, query, options);\n    }\n  }\n\n  /**\n   * Check if query is a complex query from our query builder\n   */\n  private isComplexQuery(query: any): boolean {\n    return query && query.__typeorm_query__;\n  }\n\n  /**\n   * Handle complex queries with custom where clauses\n   */\n  private async handleComplexQuery<T = any>(\n    repository: Repository<any>,\n    query: any,\n    options?: QueryOptions\n  ): Promise<T[]> {\n    let queryBuilder = repository.createQueryBuilder(\"entity\");\n    queryBuilder = queryBuilder.where(query.where, query.parameters);\n\n    this.applyQueryOptions(queryBuilder, options);\n    return await queryBuilder.getMany();\n  }\n\n  /**\n   * Handle array queries (OR conditions)\n   */\n  private async handleArrayQuery<T = any>(\n    repository: Repository<any>,\n    query: any[],\n    options?: QueryOptions\n  ): Promise<T[]> {\n    const hasComplexQuery = query.some(q => this.isComplexQuery(q));\n\n    if (hasComplexQuery) {\n      return this.handleComplexArrayQuery(repository, query, options);\n    } else {\n      return this.handleSimpleArrayQuery(repository, query, options);\n    }\n  }\n\n  /**\n   * Handle array queries containing complex queries\n   */\n  private async handleComplexArrayQuery<T = any>(\n    repository: Repository<any>,\n    query: any[],\n    options?: QueryOptions\n  ): Promise<T[]> {\n    let queryBuilder = repository.createQueryBuilder(\"entity\");\n\n    const { whereClause, parameters } = this.buildOrConditions(query);\n    if (whereClause) {\n      queryBuilder = queryBuilder.where(whereClause, parameters);\n    }\n\n    this.applyQueryOptions(queryBuilder, options);\n    return await queryBuilder.getMany();\n  }\n\n  /**\n   * Build OR conditions from mixed query array\n   */\n  private buildOrConditions(queries: any[]): { whereClause: string; parameters: Record<string, any> } {\n    const orConditions: string[] = [];\n    const allParameters: Record<string, any> = {};\n    let paramCounter = 0;\n\n    for (const q of queries) {\n      if (this.isComplexQuery(q)) {\n        const { clause, params } = this.processComplexCondition(q, paramCounter);\n        orConditions.push(`(${clause})`);\n        Object.assign(allParameters, params);\n        paramCounter += Object.keys(params).length;\n      } else {\n        const { clause, params } = this.processSimpleCondition(q, paramCounter);\n        if (clause) {\n          orConditions.push(`(${clause})`);\n          Object.assign(allParameters, params);\n          paramCounter += Object.keys(params).length;\n        }\n      }\n    }\n\n    return {\n      whereClause: orConditions.join(' OR '),\n      parameters: allParameters\n    };\n  }\n\n  /**\n   * Process complex query condition\n   */\n  private processComplexCondition(query: any, startParamCounter: number): { clause: string; params: Record<string, any> } {\n    let whereClause = query.where;\n    const params: Record<string, any> = {};\n    let paramCounter = startParamCounter;\n\n    // Rename parameters to avoid conflicts\n    if (query.parameters) {\n      for (const [oldParam, value] of Object.entries(query.parameters)) {\n        const newParam = `param_${paramCounter++}`;\n        whereClause = whereClause.replace(\n          new RegExp(`:${oldParam}\\\\b`, \"g\"),\n          `:${newParam}`\n        );\n        params[newParam] = value;\n      }\n    }\n\n    return { clause: whereClause, params };\n  }\n\n  /**\n   * Process simple query condition\n   */\n  private processSimpleCondition(query: any, startParamCounter: number): { clause: string; params: Record<string, any> } {\n    const conditions: string[] = [];\n    const params: Record<string, any> = {};\n    let paramCounter = startParamCounter;\n\n    for (const [field, value] of Object.entries(query)) {\n      const paramName = `param_${paramCounter++}`;\n      conditions.push(`entity.${field} = :${paramName}`);\n      params[paramName] = value;\n    }\n\n    return {\n      clause: conditions.join(' AND '),\n      params\n    };\n  }\n\n  /**\n   * Handle simple array queries using TypeORM's built-in OR handling\n   */\n  private async handleSimpleArrayQuery<T = any>(\n    repository: Repository<any>,\n    query: any[],\n    options?: QueryOptions\n  ): Promise<T[]> {\n    const findOptions: FindManyOptions = { where: query };\n    this.applyFindOptions(findOptions, options);\n    return await repository.find(findOptions);\n  }\n\n  /**\n   * Handle simple single queries\n   */\n  private async handleSimpleQuery<T = any>(\n    repository: Repository<any>,\n    query: any,\n    options?: QueryOptions\n  ): Promise<T[]> {\n    const findOptions: FindManyOptions = { where: query };\n    this.applyFindOptions(findOptions, options);\n    return await repository.find(findOptions);\n  }\n\n  /**\n   * Apply query options to QueryBuilder\n   */\n  private applyQueryOptions(queryBuilder: SelectQueryBuilder<any>, options?: QueryOptions): void {\n    if (options?.sort) {\n      Object.entries(options.sort).forEach(([field, direction]) => {\n        queryBuilder.addOrderBy(`entity.${field}`, direction === 1 ? \"ASC\" : \"DESC\");\n      });\n    }\n\n    if (options?.skip) {\n      queryBuilder.skip(options.skip);\n    }\n\n    if (options?.limit) {\n      queryBuilder.take(options.limit);\n    }\n  }\n\n  /**\n   * Apply query options to FindManyOptions\n   */\n  private applyFindOptions(findOptions: FindManyOptions, options?: QueryOptions): void {\n    if (options?.sort) {\n      findOptions.order = {};\n      Object.entries(options.sort).forEach(([field, direction]) => {\n        findOptions.order![field] = direction === 1 ? \"ASC\" : \"DESC\";\n      });\n    }\n\n    if (options?.skip) {\n      findOptions.skip = options.skip;\n    }\n\n    if (options?.limit) {\n      findOptions.take = options.limit;\n    }\n  }\n\n  /**\n   * Find one document\n   */\n  async findOne<T = any>(repository: Repository<any>, query: any): Promise<T | null> {\n    // Check if this is a complex query from our query builder\n    if (query && query.__typeorm_query__) {\n      // Use query builder for complex queries\n      return await repository\n        .createQueryBuilder(\"entity\")\n        .where(query.where, query.parameters)\n        .getOne();\n    } else {\n      // Use simple findOne for basic queries\n      const findOptions: FindOneOptions = {\n        where: query,\n      };\n\n      return await repository.findOne(findOptions);\n    }\n  }\n\n  /**\n   * Insert one document\n   */\n  async insertOne<T = any>(repository: Repository<any>, document: Partial<T>): Promise<T> {\n    const entity = repository.create(document);\n    return await repository.save(entity);\n  }\n\n  /**\n   * Insert many documents\n   */\n  async insertMany<T = any>(\n    repository: Repository<any>,\n    documents: Partial<T>[]\n  ): Promise<{ insertedCount: number }> {\n    const entities = repository.create(documents);\n    const result = await repository.save(entities);\n    return { insertedCount: Array.isArray(result) ? result.length : 1 };\n  }\n\n  /**\n   * Update one document\n   */\n  async updateOne(\n    repository: Repository<any>,\n    filter: any,\n    update: any\n  ): Promise<{ modifiedCount: number }> {\n    // Handle $set operator\n    const updateData = update.$set || update;\n\n    // Check if this is a complex query from our query builder\n    if (filter && filter.__typeorm_query__) {\n      // For UPDATE queries, we need to remove the \"entity.\" prefix from the WHERE clause\n      const whereClause = filter.where.replace(/entity\\./g, '');\n\n      // Use query builder for complex queries\n      const result = await repository\n        .createQueryBuilder()\n        .update()\n        .set(updateData)\n        .where(whereClause, filter.parameters)\n        .execute();\n\n      return { modifiedCount: result.affected || 0 };\n    } else {\n      // Use simple update for basic filters\n      const result = await repository.update(filter, updateData);\n      return { modifiedCount: result.affected || 0 };\n    }\n  }\n\n  /**\n   * Delete one document\n   */\n  async deleteOne(repository: Repository<any>, filter: any): Promise<{ deletedCount: number }> {\n    const result = await this.executeDelete(repository, filter);\n    return { deletedCount: result.affected || 0 };\n  }\n\n  /**\n   * Delete many documents\n   */\n  async deleteMany(repository: Repository<any>, filter: any): Promise<{ deletedCount: number }> {\n    const result = await this.executeDelete(repository, filter);\n    return { deletedCount: result.affected || 0 };\n  }\n\n  /**\n   * Execute delete operation with proper query handling\n   */\n  private async executeDelete(repository: Repository<any>, filter: any): Promise<any> {\n    // Handle empty filter - delete all records\n    if (!filter || Object.keys(filter).length === 0) {\n      // Use query builder to delete all records\n      return await repository\n        .createQueryBuilder()\n        .delete()\n        .execute();\n    }\n\n    // Handle array filters (OR conditions)\n    if (Array.isArray(filter)) {\n      const hasComplexQuery = filter.some(q => this.isComplexQuery(q));\n\n      if (hasComplexQuery) {\n        // Build OR conditions for complex array queries\n        const { whereClause, parameters } = this.buildOrConditions(filter);\n        // Remove \"entity.\" prefix for DELETE queries\n        const deleteWhereClause = whereClause.replace(/entity\\./g, '');\n\n        return await repository\n          .createQueryBuilder()\n          .delete()\n          .where(deleteWhereClause, parameters)\n          .execute();\n      } else {\n        // For simple array queries, delete each condition separately\n        let totalAffected = 0;\n        for (const condition of filter) {\n          const result = await repository.delete(condition);\n          totalAffected += result.affected || 0;\n        }\n        return { affected: totalAffected };\n      }\n    }\n\n    // Check if this is a complex query from our query builder\n    if (filter && filter.__typeorm_query__) {\n      // For DELETE queries, we need to remove the \"entity.\" prefix from the WHERE clause\n      // because DELETE queries don't use table aliases\n      const whereClause = filter.where.replace(/entity\\./g, '');\n\n      // Use query builder for complex queries\n      return await repository\n        .createQueryBuilder()\n        .delete()\n        .where(whereClause, filter.parameters)\n        .execute();\n    } else {\n      // Use simple delete for basic filters\n      return await repository.delete(filter);\n    }\n  }\n\n  /**\n   * Count documents\n   */\n  async count(repository: Repository<any>, query: any): Promise<number> {\n    // Check if this is a complex query from our query builder\n    if (query && query.__typeorm_query__) {\n      // Use query builder for complex queries\n      return await repository\n        .createQueryBuilder(\"entity\")\n        .where(query.where, query.parameters)\n        .getCount();\n    } else {\n      // Use simple count for basic queries\n      return await repository.count({ where: query });\n    }\n  }\n\n  /**\n   * Create query builder\n   */\n  createQueryBuilder(): IQueryBuilder {\n    return new TypeORMQueryBuilder();\n  }\n\n  /**\n   * Create update builder\n   */\n  createUpdateBuilder(): IUpdateBuilder {\n    return new TypeORMUpdateBuilder();\n  }\n}","/**\n * TypeORM Collection Manager\n *\n * Implements ICollectionManager interface for TypeORM\n */\n\nimport { DataSource, Repository } from \"typeorm\";\nimport { ICollectionManager } from \"../common/types\";\nimport { TypeORMAdapter } from \"./typeorm-adapter\";\nimport { MemoryEvent } from \"./entities/memory-event.entity\";\nimport { MemoryState } from \"./entities/memory-state.entity\";\nimport { MemorySummary } from \"./entities/memory-summary.entity\";\n\nexport class TypeORMCollectionManager implements ICollectionManager {\n  private adapter: TypeORMAdapter;\n  private eventRepository: Repository<MemoryEvent>;\n  private stateRepository: Repository<MemoryState>;\n  private summaryRepository: Repository<MemorySummary>;\n\n  constructor(\n    private dataSource: DataSource,\n    private eventTableName: string = \"memory_events\",\n    private stateTableName: string = \"memory_state\",\n    private summaryTableName: string = \"memory_summaries\"\n  ) {\n    this.adapter = new TypeORMAdapter();\n\n    // Use provided entities if available, otherwise use default entities\n    // The entities should have been properly initialized by TypeORMMemory\n    this.eventRepository = dataSource.getRepository(eventTableName);\n    this.stateRepository = dataSource.getRepository(stateTableName);\n    this.summaryRepository = dataSource.getRepository(summaryTableName);\n  }\n\n  /**\n   * Get main events collection/repository\n   */\n  getCollection(): Repository<MemoryEvent> {\n    return this.eventRepository;\n  }\n\n  /**\n   * Get state collection/repository\n   */\n  getStateCollection(): Repository<MemoryState> {\n    return this.stateRepository;\n  }\n\n  /**\n   * Get summary collection/repository\n   */\n  getSummaryCollection(): Repository<MemorySummary> {\n    return this.summaryRepository;\n  }\n\n  /**\n   * Get database instance\n   */\n  getDatabase(): DataSource {\n    return this.dataSource;\n  }\n\n  /**\n   * Get database adapter\n   */\n  getAdapter(): TypeORMAdapter {\n    return this.adapter;\n  }\n}\n","/**\n * TypeORM Entity for Memory Events using Decorator Syntax\n *\n * More standard TypeORM approach with better IDE support and type safety\n */\n\nimport \"reflect-metadata\";\nimport {\n  Entity,\n  PrimaryGeneratedColumn,\n  Column,\n  CreateDateColumn,\n  UpdateDateColumn,\n  Index,\n} from \"typeorm\";\nimport { BaseMemoryDocument } from \"../../common/types\";\n\n/**\n * Memory Event Entity using TypeORM decorators\n *\n * This approach provides:\n * - Better IDE support and autocomplete\n * - Type safety at compile time\n * - Standard TypeORM patterns\n * - Wider compatibility across databases\n */\n@Entity(\"memory_events\")\n@Index(\"IDX_SESSION_BRANCH\", [\"sessionId\", \"branchPath\"])\n@Index(\"IDX_SESSION_CREATED\", [\"sessionId\", \"createdAt\"])\n@Index(\"IDX_SESSION_MESSAGE\", [\"sessionId\", \"messageId\"])\nexport class MemoryEvent implements BaseMemoryDocument {\n  @PrimaryGeneratedColumn(\"uuid\")\n  _id!: string;\n\n  @Column({ type: \"varchar\", length: 255 })\n  sessionId!: string;\n\n  @Column({ type: \"varchar\", length: 255 })\n  messageId!: string;\n\n  @Column({ type: \"varchar\", length: 500 })\n  branchPath!: string;\n\n  @Column({ type: \"varchar\", length: 50 })\n  role!: string;\n\n  @Column({ type: \"text\" })\n  content!: string;\n\n  @Column({ type: \"json\", nullable: true })\n  toolCalls?: any[];\n\n  @Column({ type: \"varchar\", length: 255, nullable: true })\n  toolCallId?: string;\n\n  @Column({ type: \"json\" })\n  state!: Record<string, any>;\n\n  @CreateDateColumn()\n  createdAt!: Date;\n\n  @UpdateDateColumn()\n  updatedAt!: Date;\n}\n\n// Type alias for backward compatibility\nexport type MemoryEventEntity = MemoryEvent;\n\n/**\n * Factory function to create entity with custom table name\n * Useful for multi-tenant scenarios or custom table naming\n */\nexport function createMemoryEventEntity(tableName: string = \"memory_events\") {\n  @Entity(tableName)\n  @Index(\"IDX_SESSION_BRANCH\", [\"sessionId\", \"branchPath\"])\n  @Index(\"IDX_SESSION_CREATED\", [\"sessionId\", \"createdAt\"])\n  @Index(\"IDX_SESSION_MESSAGE\", [\"sessionId\", \"messageId\"])\n  class CustomMemoryEvent extends MemoryEvent {}\n\n  return CustomMemoryEvent;\n}\n","/**\n * TypeORM Entity for Memory State\n *\n * Stores session state information including branch management and soft delete cursors\n */\n\nimport \"reflect-metadata\";\nimport {\n  Entity,\n  PrimaryGeneratedColumn,\n  Column,\n  CreateDateColumn,\n  UpdateDateColumn,\n  Index,\n} from \"typeorm\";\nimport { BaseStateDocument, BranchMetadata } from \"../../common/types\";\n\n/**\n * Memory State Entity\n * \n * Manages session state including:\n * - Current active branch\n * - Branch metadata and hierarchy\n * - Soft delete cursors for data management\n */\n@Entity(\"memory_state\")\n@Index(\"IDX_STATE_SESSION\", [\"sessionId\"])\nexport class MemoryState implements BaseStateDocument {\n  @PrimaryGeneratedColumn(\"uuid\")\n  _id!: string;\n\n  @Column({ type: \"varchar\", length: 255, unique: true })\n  sessionId!: string;\n\n  @Column({ type: \"varchar\", length: 500, default: \"main\" })\n  currentBranch!: string;\n\n  @Column({ type: \"datetime\", nullable: true })\n  startCursor?: Date;\n\n  @Column({ type: \"json\" })\n  branches!: Record<string, BranchMetadata>;\n\n  @CreateDateColumn()\n  createdAt!: Date;\n\n  @UpdateDateColumn()\n  updatedAt!: Date;\n}\n\n/**\n * Factory function to create entity with custom table name\n */\nexport function createMemoryStateEntity(tableName: string = \"memory_state\") {\n  @Entity(tableName)\n  @Index(\"IDX_STATE_SESSION\", [\"sessionId\"])\n  class CustomMemoryState extends MemoryState {}\n\n  return CustomMemoryState;\n}","/**\n * TypeORM Entity for Memory Summary\n *\n * Stores summarized content for memory management and context optimization\n */\n\nimport \"reflect-metadata\";\nimport {\n  Entity,\n  PrimaryGeneratedColumn,\n  Column,\n  CreateDateColumn,\n  UpdateDateColumn,\n  Index,\n} from \"typeorm\";\nimport { BaseSummaryDocument } from \"../../common/types\";\n\n/**\n * Memory Summary Entity\n * \n * Stores summarized content including:\n * - Compressed conversation summaries\n * - Metadata for summary management\n * - Timestamps for summary lifecycle\n */\n@Entity(\"memory_summaries\")\n@Index(\"IDX_SUMMARY_SESSION\", [\"sessionId\"])\n@Index(\"IDX_SUMMARY_ID\", [\"sessionId\", \"summaryId\"])\nexport class MemorySummary implements BaseSummaryDocument {\n  @PrimaryGeneratedColumn(\"uuid\")\n  _id!: string;\n\n  @Column({ type: \"varchar\", length: 255 })\n  sessionId!: string;\n\n  @Column({ type: \"varchar\", length: 255 })\n  summaryId!: string;\n\n  @Column({ type: \"text\" })\n  content!: string;\n\n  @Column({ type: \"json\", nullable: true })\n  metadata?: Record<string, any>;\n\n  @CreateDateColumn()\n  createdAt!: Date;\n\n  @UpdateDateColumn()\n  updatedAt!: Date;\n}\n\n/**\n * Factory function to create entity with custom table name\n */\nexport function createMemorySummaryEntity(tableName: string = \"memory_summaries\") {\n  @Entity(tableName)\n  @Index(\"IDX_SUMMARY_SESSION\", [\"sessionId\"])\n  @Index(\"IDX_SUMMARY_ID\", [\"sessionId\", \"summaryId\"])\n  class CustomMemorySummary extends MemorySummary {}\n\n  return CustomMemorySummary;\n}","/**\n * MySQL Memory Storage\n *\n * TypeORM-based MySQL memory implementation\n */\n\nexport {\n  MySQLMemory,\n  MySQLMemoryConfig,\n  MySQLConnectionConfig,\n} from \"./mysql-memory\";\n\n// Re-export TypeORM types for convenience\nexport { DataSource } from \"typeorm\";\n","/**\n * TypeORM Memory Storage\n *\n * Exports all TypeORM-related memory storage components\n */\n\nexport { TypeORMAdapter } from \"./typeorm-adapter\";\nexport { TypeORMMemory, TypeORMMemoryConfig } from \"./typeorm-memory\";\nexport {\n  TypeORMQueryBuilder,\n  TypeORMUpdateBuilder,\n} from \"./typeorm-query-builder\";\nexport {\n  MemoryEvent,\n  MemoryEventEntity,\n  createMemoryEventEntity,\n} from \"./entities/memory-event.entity\";\n\n// Re-export TypeORM types for convenience\nexport { DataSource, Repository } from \"typeorm\";\n","import { Message } from \"../../types\";\n\n/**\n * Memory entity interface representing a stored memory item\n */\nexport interface MemoryEntity {\n  /** Unique identifier for the memory */\n  id: string;\n  /** Memory strategy/category for classification */\n  strategy: string;\n  /** Role of the message creator */\n  role?: \"user\" | \"assistant\";\n  /** Memory content text */\n  content: string;\n  /** Additional metadata for the memory */\n  metadata: Record<string, any>;\n  /** Creation timestamp */\n  createdAt: Date;\n  /** Last update timestamp */\n  updatedAt?: Date;\n}\n\n/**\n * Memory query interface for searching and filtering memories\n */\nexport interface MemoryQuery {\n  /** Semantic query text for content matching */\n  query?: string;\n  /** Strategy filter - single strategy or array of strategies */\n  strategy?: string | string[];\n  /** Maximum number of results to return */\n  limit?: number;\n  /** Number of results to skip for pagination */\n  offset?: number;\n  /** Sorting criteria with field names and directions */\n  orderBy?: Record<string, 1 | -1>;\n  /** Custom filtering conditions - implementers can add any query conditions */\n  [key: string]: any;\n}\n\n/**\n * @fileoverview Abstract base class for long-term memory implementations\n *\n * This base class defines the core interface and common functionality for long-term memory systems.\n * Concrete implementations can be based on different storage backends such as vector databases,\n * graph databases, or other persistent storage solutions.\n *\n * @example\n * ```typescript\n * class CustomLongTermMemory extends BaseLongTermMemory {\n *   async record(memory: MemoryEntity): Promise<void> {\n *     // Custom implementation\n *   }\n *   // ... implement other required methods\n * }\n * ```\n */\nexport abstract class BaseLongTermMemory {\n  /** Configuration object for the memory implementation */\n  protected config: any;\n\n  /**\n   * Creates a new BaseLongTermMemory instance\n   * @param config - Configuration object for the memory implementation\n   */\n  constructor(config: any = {}) {\n    this.config = {\n      ...config,\n    };\n  }\n\n  /**\n   * Record a new memory entity\n   * @param memory - The memory entity to store\n   */\n  abstract record(memory: MemoryEntity): Promise<void>;\n\n  /**\n   * Record multiple memory entities in batch\n   * @param memories - Array of memory entities to store\n   */\n  abstract recordBatch(memories: MemoryEntity[]): Promise<void>;\n\n  /**\n   * Retrieve memories based on query conditions\n   * @param query - Query conditions for filtering and searching\n   */\n  abstract retrieve(query: MemoryQuery): Promise<MemoryEntity[]>;\n\n  /**\n   * Delete memory by ID or query conditions\n   * @param memoryId - Memory ID (string) or query conditions (MemoryQuery)\n   */\n  abstract delete(memoryId: string | MemoryQuery): Promise<void>;\n\n  /**\n   * Update an existing memory entity\n   * @param memoryId - ID of the memory to update\n   * @param updates - Partial memory entity with fields to update\n   */\n  abstract update(\n    memoryId: string,\n    updates: Partial<MemoryEntity>\n  ): Promise<void>;\n\n  /**\n   * Clear all memories for a specific strategy or all memories\n   * @param strategy - Optional strategy filter; if not specified, clears all memories\n   */\n  abstract clear(strategy?: string): Promise<void>;\n\n  // ==================== Advanced Features ====================\n\n  /**\n   * Extract and record memories from conversation messages\n   * @param messages - Array of conversation messages to analyze\n   * @param context - Additional context information for extraction\n   * @returns Promise resolving to array of extracted memory entities\n   */\n  abstract extractAndRecord(\n    messages: Message[],\n    context: Record<string, any>\n  ): Promise<MemoryEntity[]>;\n\n  /**\n   * Perform semantic search on stored memories\n   * @param query - Search query text for semantic matching\n   * @param options - Optional search parameters and filters\n   * @returns Promise resolving to array of semantically similar memories\n   */\n  abstract semanticSearch(\n    query: string,\n    options?: MemoryQuery\n  ): Promise<MemoryEntity[]>;\n\n  /**\n   * Get memories related to a specific memory entity\n   * @param memoryId - ID of the memory to find relations for\n   * @param depth - Relationship depth to traverse, defaults to 1\n   * @returns Promise resolving to array of related memory entities\n   */\n  abstract getRelatedMemories(\n    memoryId: string,\n    depth?: number\n  ): Promise<MemoryEntity[]>;\n\n  /**\n   * Consolidate and optimize stored memories\n   * Includes operations like deduplication, merging, decay, and reinforcement\n   * @returns Promise that resolves when consolidation is complete\n   */\n  abstract consolidate(): Promise<void>;\n\n  // ==================== Helper Methods ====================\n\n  /**\n   * Generate a unique memory ID\n   * Implementers can override this method to customize ID generation strategy\n   * @returns Unique memory identifier string\n   */\n  protected generateMemoryId(): string {\n    return `memory_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n}\n","import {\n  BaseLongTermMemory,\n  MemoryEntity,\n  MemoryQuery,\n} from \"./long-term-memory-base\";\nimport { MemoryClient } from \"../tdaimemory/client\";\nimport { Message } from \"../../types\";\nimport { Order } from \"../tdaimemory\";\n\n/**\n * TDAI \n */\nexport interface TDAILongTermMemoryConfig {\n  client: MemoryClient;\n  sessionId?: string;\n}\n\n/**\n *  TDAI \n *\n *  TDAI  records API \n */\nexport class TDAILongTermMemory extends BaseLongTermMemory {\n  private client: MemoryClient;\n  private sessionId: string;\n\n  constructor(config: TDAILongTermMemoryConfig) {\n    super();\n\n    this.client = config.client;\n    this.sessionId = config.sessionId || \"default\";\n  }\n\n  /**\n   * \n   */\n  async record(\n    memory: Pick<MemoryEntity, \"content\" | \"strategy\" | \"metadata\">\n  ): Promise<void> {\n    try {\n      await this.client.appendRecord({\n        sessionId: this.sessionId,\n        content: memory.content,\n        strategy: memory.strategy,\n        // metadata: memory.metadata\n      });\n    } catch (error) {\n      console.error(\"Error recording memory:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * \n   */\n  async recordBatch(memories: MemoryEntity[]): Promise<void> {\n    const promises = memories.map((memory) => this.record(memory));\n    await Promise.all(promises);\n  }\n\n  /**\n   * \n   */\n  async retrieve(query: MemoryQuery): Promise<MemoryEntity[]> {\n    try {\n      const result = await this.client.queryRecords({\n        sessionId: this.sessionId,\n        limit: query.limit,\n        offset: query.offset,\n        orderBy: query.orderBy,\n        where: query.where,\n      });\n\n      return result.records.map((record) => ({\n        id: record.record_id,\n        strategy: record.strategy_name,\n        content: record.record_content,\n        createdAt: new Date(record.created_at),\n        updatedAt: record.updated_at ? new Date(record.updated_at) : undefined,\n        metadata: {\n          // ...record.metadata,\n          eventIds: record.event_ids,\n        },\n      }));\n    } catch (error) {\n      console.error(\"Error retrieving memories:\", error);\n      return [];\n    }\n  }\n\n  /**\n   * \n   */\n  async delete(recordId: string | MemoryQuery): Promise<void> {\n    try {\n      if (typeof recordId === \"string\") {\n        await this.client.deleteRecord({\n          sessionId: this.sessionId,\n          recordId,\n        });\n      } else {\n        // Delete by query - find and delete matching records\n        const memories = await this.retrieve(recordId);\n        for (const memory of memories) {\n          await this.client.deleteRecord({\n            sessionId: this.sessionId,\n            recordId: memory.id,\n          });\n        }\n      }\n    } catch (error) {\n      console.error(\"Error deleting memory:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * \n   */\n  async update(\n    memoryId: string,\n    updates: Partial<MemoryEntity>\n  ): Promise<void> {\n    try {\n      if (updates.content) {\n        await this.client.updateRecord({\n          sessionId: this.sessionId,\n          recordId: memoryId,\n          content: updates.content,\n        });\n      }\n\n      // For strategy or metadata updates, we need to delete and recreate\n      if (updates.strategy || updates.metadata) {\n        const existing = await this.retrieve({\n          where: { record_id: memoryId },\n          limit: 1,\n        });\n\n        if (existing.length > 0) {\n          await this.delete(memoryId);\n\n          const newMemory: MemoryEntity = {\n            id: memoryId,\n            strategy: updates.strategy || existing[0].strategy,\n            content: updates.content || existing[0].content,\n            createdAt: existing[0].createdAt,\n            updatedAt: new Date(),\n            metadata: { ...existing[0].metadata, ...updates.metadata },\n          };\n          await this.record(newMemory);\n        }\n      }\n    } catch (error) {\n      console.error(\"Error updating memory:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * \n   */\n  async semanticSearch(\n    query: string,\n    options?: MemoryQuery\n  ): Promise<MemoryEntity[]> {\n    try {\n      const result = await this.client.searchRecords({\n        content: query,\n        sessionId: this.sessionId,\n        strategies: options?.strategies,\n        limit: options?.limit,\n        orderBy: options?.orderBy as any,\n        where: options?.where,\n      });\n\n      return result.records.map((record) => ({\n        id: record.record_id,\n        strategy: record.strategy_name,\n        content: record.record_content,\n        createdAt: new Date(record.created_at),\n        updatedAt: record.updated_at ? new Date(record.updated_at) : undefined,\n        metadata: {\n          eventIds: record.event_ids,\n          score: record.score,\n        },\n      }));\n    } catch (error) {\n      console.error(\"Error in semantic search:\", error);\n      return [];\n    }\n  }\n\n  /**\n   * \n   */\n  async clear(strategy?: string): Promise<void> {\n    try {\n      const query: MemoryQuery = strategy ? { strategies: [strategy] } : {};\n      await this.delete(query);\n    } catch (error) {\n      console.error(\"Error clearing memories:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * \n   * TODO:  LLM \n   */\n  async extractAndRecord(\n    messages: Message[],\n    context: Record<string, any>\n  ): Promise<MemoryEntity[]> {\n    const extractedMemories: MemoryEntity[] = [];\n\n    throw new Error(\"Memory extraction not implemented\");\n\n    // try {\n    //   //  -  NLP \n    //   for (const message of messages) {\n    //     if (message.role === \"user\" && message.content.length > 10) {\n    //       const memory: MemoryEntity = {\n    //         id: this.generateMemoryId(),\n    //         strategy: context.strategy || \"session\",\n    //         content: message.content,\n    //         createdAt: message.timestamp\n    //           ? new Date(message.timestamp)\n    //           : new Date(),\n    //         metadata: {\n    //           userId: context.userId,\n    //           sessionId: context.sessionId || this.sessionId,\n    //           messageId: message.id,\n    //           role: message.role,\n    //           ...context,\n    //         },\n    //       };\n\n    //       await this.record(memory);\n    //       extractedMemories.push(memory);\n    //     }\n    //   }\n\n    //   return extractedMemories;\n    // } catch (error) {\n    //   console.error(\"Error extracting and recording memories:\", error);\n    //   return extractedMemories;\n    // }\n  }\n\n  /**\n   * \n   */\n  async getRelatedMemories(\n    memoryId: string,\n    depth: number = 1\n  ): Promise<MemoryEntity[]> {\n    try {\n      const memory = await this.retrieve({\n        where: { record_id: memoryId },\n        limit: 1,\n      });\n\n      if (memory.length === 0) {\n        return [];\n      }\n\n      const targetMemory = memory[0];\n      const relatedQuery: MemoryQuery = {\n        content: targetMemory.content,\n        limit: 10,\n      };\n\n      const related = await this.retrieve(relatedQuery);\n\n      // \n      return related.filter((m) => m.id !== memoryId);\n    } catch (error) {\n      console.error(\"Error getting related memories:\", error);\n      return [];\n    }\n  }\n\n  /**\n   * TODO: imply \n   * \n   * \n   * \n   */\n  async consolidate(): Promise<void> {\n    throw new Error(\"Memory consolidation not implemented\");\n  }\n}\n","import {\n  BaseLongTermMemory,\n  MemoryEntity,\n  MemoryQuery,\n} from \"./long-term-memory-base\";\nimport {\n  MemoryClient,\n  type Memory,\n  type Message,\n  type MemoryOptions,\n  type SearchOptions,\n} from \"mem0ai\";\n\n//  TypeScript  MemoryClient \ntype ClientOptions = ConstructorParameters<typeof MemoryClient>[0];\n\n/**\n * Mem0 Long Term Memory Configuration\n * Based on MemoryClient's ClientOptions with additional agent-specific options\n */\nexport interface Mem0LongTermMemoryConfig extends ClientOptions {\n  /** Default user ID for memory operations */\n  userId?: string;\n  /** Default agent ID for memory operations */\n  agentId?: string;\n  /** Default app ID for memory operations */\n  appId?: string;\n}\n\n/**\n * Mem0LongTermMemory - Implementation using official Mem0 SDK\n *\n * This implementation provides intelligent memory management using Mem0's\n * advanced features including automatic memory extraction, semantic search,\n * and intelligent memory consolidation.\n */\nexport class Mem0LongTermMemory extends BaseLongTermMemory {\n  private client: MemoryClient;\n  private defaultOptions: MemoryOptions;\n\n  constructor(config: Mem0LongTermMemoryConfig) {\n    super(config);\n\n    // Extract ClientOptions from config (excluding agent-specific options)\n    const { userId, agentId, appId, ...clientOptions } = config;\n\n    // Initialize Mem0 client with ClientOptions\n    this.client = new MemoryClient(clientOptions);\n\n    // Set default options for memory operations\n    this.defaultOptions = {\n      user_id: config.userId,\n      agent_id: config.agentId,\n      app_id: config.appId,\n    };\n  }\n\n  /**\n   * Record a new memory entity\n   */\n  async record(memory: MemoryEntity): Promise<void> {\n    try {\n      const messages: Message[] = [\n        {\n          role: memory.role || \"assistant\",\n          content: memory.content,\n        },\n      ];\n\n      const options: MemoryOptions = {\n        ...this.defaultOptions,\n        metadata: {\n          ...memory.metadata,\n          strategy: memory.strategy,\n          id: memory.id,\n        },\n      };\n\n      const result = await this.client.add(messages, options);\n      console.log(`Memory recorded successfully. Mem0 ID: ${result[0]?.id}`);\n    } catch (error) {\n      console.error(\"Error recording memory:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Record multiple memories in batch\n   */\n  async recordBatch(memories: MemoryEntity[]): Promise<void> {\n    try {\n      // Mem0 doesn't have a native batch add, so we'll process sequentially\n      // In production, you might want to implement parallel processing with rate limiting\n      for (const memory of memories) {\n        await this.record(memory);\n      }\n      console.log(`Batch recorded ${memories.length} memories successfully`);\n    } catch (error) {\n      console.error(\"Error recording batch memories:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Retrieve memories based on query\n   */\n  async retrieve(query: MemoryQuery): Promise<MemoryEntity[]> {\n    try {\n      const options: SearchOptions = {\n        ...this.defaultOptions,\n        limit: query.limit,\n        page: query.offset\n          ? Math.floor(query.offset / (query.limit || 10)) + 1\n          : 1,\n        page_size: query.limit,\n        metadata: query.strategy ? { strategy: query.strategy } : undefined,\n        filters: query.filters || {},\n      };\n\n      let memories: Memory[];\n\n      if (query.query) {\n        // Use semantic search if query text is provided\n        memories = await this.client.search(query.query, options);\n      } else {\n        // Use getAll for general retrieval\n        memories = await this.client.getAll(options);\n      }\n\n      return this.convertToMemoryEntities(memories);\n    } catch (error) {\n      console.error(\"Error retrieving memories:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete memory by ID or query\n   */\n  async delete(memoryId: string | MemoryQuery): Promise<void> {\n    try {\n      if (typeof memoryId === \"string\") {\n        // Delete by ID\n        await this.client.delete(memoryId);\n        console.log(`Memory ${memoryId} deleted successfully`);\n      } else {\n        // Delete by query - get matching memories first, then delete them\n        const memories = await this.retrieve(memoryId);\n        for (const memory of memories) {\n          await this.client.delete(memory.id);\n        }\n        console.log(`Deleted ${memories.length} memories matching query`);\n      }\n    } catch (error) {\n      console.error(\"Error deleting memory:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Update memory content or metadata\n   */\n  async update(\n    memoryId: string,\n    updates: Partial<MemoryEntity>\n  ): Promise<void> {\n    try {\n      const updateData: { text?: string; metadata?: Record<string, any> } = {};\n\n      if (updates.content) {\n        updateData.text = updates.content;\n      }\n\n      if (updates.metadata || updates.strategy) {\n        updateData.metadata = {\n          ...updates.metadata,\n          ...(updates.strategy && { strategy: updates.strategy }),\n        };\n      }\n\n      await this.client.update(memoryId, updateData);\n      console.log(`Memory ${memoryId} updated successfully`);\n    } catch (error) {\n      console.error(\"Error updating memory:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Clear memories by strategy\n   */\n  async clear(strategy?: string): Promise<void> {\n    try {\n      if (strategy) {\n        // Delete memories with specific strategy\n        const options: MemoryOptions = {\n          ...this.defaultOptions,\n          filters: { strategy },\n        };\n        await this.client.deleteAll(options);\n        console.log(`Cleared memories with strategy: ${strategy}`);\n      } else {\n        // Delete all memories for the user/agent/app\n        await this.client.deleteAll(this.defaultOptions);\n        console.log(\"Cleared all memories\");\n      }\n    } catch (error) {\n      console.error(\"Error clearing memories:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Extract and record memories from conversation messages\n   */\n  async extractAndRecord(\n    messages: any[],\n    context: Record<string, any>\n  ): Promise<MemoryEntity[]> {\n    try {\n      // Convert messages to Mem0 format\n      const mem0Messages: Message[] = messages.map((msg) => ({\n        role: msg.role || \"user\",\n        content:\n          typeof msg.content === \"string\"\n            ? msg.content\n            : JSON.stringify(msg.content),\n      }));\n\n      const options: MemoryOptions = {\n        ...this.defaultOptions,\n        user_id: context.userId || this.defaultOptions.user_id,\n        agent_id: context.agentId || this.defaultOptions.agent_id,\n        app_id: context.appId || this.defaultOptions.app_id,\n        run_id: context.runId,\n        metadata: context.metadata || {},\n      };\n\n      // Mem0 automatically extracts memories from conversations\n      const extractedMemories = await this.client.add(mem0Messages, options);\n\n      const memoryEntities = extractedMemories.map((memory) =>\n        this.convertMem0ToMemoryEntity(memory)\n      );\n\n      return memoryEntities;\n    } catch (error) {\n      console.error(\"Error extracting memories:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Semantic search using Mem0's intelligent search\n   */\n  async semanticSearch(\n    query: string,\n    options?: MemoryQuery\n  ): Promise<MemoryEntity[]> {\n    try {\n      const searchOptions: SearchOptions = {\n        ...this.defaultOptions,\n        limit: options?.limit || 10,\n        threshold: options?.threshold || 0.7,\n        rerank: true,\n        enable_graph: true,\n        filters: options?.filters || {},\n        ...(options?.strategy && {\n          filters: {\n            ...options.filters,\n            strategy: options.strategy,\n          },\n        }),\n      };\n\n      const memories = await this.client.search(query, searchOptions);\n      return this.convertToMemoryEntities(memories);\n    } catch (error) {\n      console.error(\"Error in semantic search:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get related memories using Mem0's graph-based relationships\n   */\n  async getRelatedMemories(\n    memoryId: string,\n    depth?: number\n  ): Promise<MemoryEntity[]> {\n    try {\n      // Get the original memory first\n      const originalMemory = await this.client.get(memoryId);\n\n      if (!originalMemory.memory) {\n        return [];\n      }\n\n      // Use semantic search to find related memories\n      const searchOptions: SearchOptions = {\n        ...this.defaultOptions,\n        limit: depth || 5,\n        enable_graph: true,\n        rerank: true,\n        threshold: 0.6,\n      };\n\n      const relatedMemories = await this.client.search(\n        originalMemory.memory,\n        searchOptions\n      );\n\n      // Filter out the original memory\n      const filteredMemories = relatedMemories.filter(\n        (memory) => memory.id !== memoryId\n      );\n\n      return this.convertToMemoryEntities(filteredMemories);\n    } catch (error) {\n      console.error(\"Error getting related memories:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Consolidate memories - Mem0 handles this automatically, but we can trigger it\n   */\n  async consolidate(): Promise<void> {\n    try {\n      // Mem0 handles consolidation automatically, but we can simulate it\n      // by retrieving all memories and letting Mem0's intelligence work\n      const allMemories = await this.client.getAll({\n        ...this.defaultOptions,\n        limit: 1000, // Get a large batch for consolidation\n      });\n\n      console.log(\n        `Consolidation check completed for ${allMemories.length} memories`\n      );\n    } catch (error) {\n      console.error(\"Error in consolidation:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get memory history for a specific memory\n   */\n  async getMemoryHistory(memoryId: string): Promise<any[]> {\n    try {\n      const history = await this.client.history(memoryId);\n      return history;\n    } catch (error) {\n      console.error(\"Error getting memory history:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Get all users (if available)\n   */\n  async getUsers(): Promise<any> {\n    try {\n      return await this.client.users();\n    } catch (error) {\n      console.error(\"Error getting users:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Provide feedback on a memory\n   */\n  async provideFeedback(\n    memoryId: string,\n    feedback: \"POSITIVE\" | \"NEGATIVE\" | \"VERY_NEGATIVE\",\n    reason?: string\n  ): Promise<void> {\n    try {\n      await this.client.feedback({\n        memory_id: memoryId,\n        feedback: feedback as any,\n        feedback_reason: reason,\n      });\n      console.log(`Feedback provided for memory ${memoryId}: ${feedback}`);\n    } catch (error) {\n      console.error(\"Error providing feedback:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Test connection to Mem0\n   */\n  async ping(): Promise<void> {\n    try {\n      await this.client.ping();\n      console.log(\"Mem0 connection successful\");\n    } catch (error) {\n      console.error(\"Error pinging Mem0:\", error);\n      throw error;\n    }\n  }\n\n  // Private helper methods\n\n  /**\n   * Convert Mem0 Memory objects to MemoryEntity\n   */\n  private convertToMemoryEntities(mem0Memories: Memory[]): MemoryEntity[] {\n    if (!mem0Memories || !Array.isArray(mem0Memories)) {\n      return [];\n    }\n    return mem0Memories.map((memory) => this.convertMem0ToMemoryEntity(memory));\n  }\n\n  /**\n   * Convert single Mem0 Memory to MemoryEntity\n   */\n  private convertMem0ToMemoryEntity(memory: Memory): MemoryEntity {\n    return {\n      id: memory.id,\n      content: memory.memory || memory.data?.memory || \"\",\n      strategy: memory.metadata?.strategy || \"general\",\n      metadata: {\n        ...memory.metadata,\n        mem0_id: memory.id,\n        categories: memory.categories,\n        score: memory.score,\n        hash: memory.hash,\n        memory_type: memory.memory_type,\n        owner: memory.owner,\n        agent_id: memory.agent_id,\n        app_id: memory.app_id,\n        run_id: memory.run_id,\n      },\n      createdAt: memory.created_at || new Date(),\n      updatedAt: memory.updated_at || new Date(),\n    };\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,mBAIY,WA2VC;AA/Vb;AAAA;AAAA;AAAA,oBAA6B;AAItB,IAAK,YAAL,kBAAKA,eAAL;AAEL,MAAAA,WAAA,wBAAqB;AACrB,MAAAA,WAAA,0BAAuB;AACvB,MAAAA,WAAA,sBAAmB;AACnB,MAAAA,WAAA,qBAAkB;AAClB,MAAAA,WAAA,oBAAiB;AACjB,MAAAA,WAAA,mBAAgB;AAChB,MAAAA,WAAA,oBAAiB;AACjB,MAAAA,WAAA,iBAAc;AACd,MAAAA,WAAA,uBAAoB;AACpB,MAAAA,WAAA,SAAM;AACN,MAAAA,WAAA,YAAS;AACT,MAAAA,WAAA,iBAAc;AACd,MAAAA,WAAA,kBAAe;AACf,MAAAA,WAAA,eAAY;AACZ,MAAAA,WAAA,kBAAe;AACf,MAAAA,WAAA,mBAAgB;AAEhB,MAAAA,WAAA,wBAAqB;AACrB,MAAAA,WAAA,qBAAkB;AAElB,MAAAA,WAAA,sBAAmB;AACnB,MAAAA,WAAA,qBAAkB;AAClB,MAAAA,WAAA,uBAAoB;AACpB,MAAAA,WAAA,4BAAyB;AACzB,MAAAA,WAAA,kBAAe;AACf,MAAAA,WAAA,uBAAoB;AACpB,MAAAA,WAAA,uBAAoB;AACpB,MAAAA,WAAA,0BAAuB;AACvB,MAAAA,WAAA,0BAAuB;AACvB,MAAAA,WAAA,0BAAuB;AACvB,MAAAA,WAAA,2BAAwB;AACxB,MAAAA,WAAA,sBAAmB;AACnB,MAAAA,WAAA,uBAAoB;AAlCV,aAAAA;AAAA,OAAA;AA2VL,IAAM,cAAN,cAA0B,2BAAa;AAAA,MAC5C,cAAc;AACZ,cAAM;AACN,aAAK,gBAAgB,GAAG;AAAA,MAC1B;AAAA;AAAA,MAGA,KAA0B,OAAU,MAA6B;AAC/D,eAAO,MAAM,KAAK,OAAO,EAAE,GAAG,MAAM,WAAW,KAAK,IAAI,EAAE,CAAC;AAAA,MAC7D;AAAA;AAAA,MAGA,GAAwB,OAAU,SAAgC;AAChE,eAAO,MAAM,GAAG,OAAO,OAAO;AAAA,MAChC;AAAA;AAAA,MAGA,KAA0B,OAAU,SAAgC;AAClE,eAAO,MAAM,KAAK,OAAO,OAAO;AAAA,MAClC;AAAA;AAAA,MAGA,IAAyB,OAAU,SAAgC;AACjE,eAAO,MAAM,IAAI,OAAO,OAAO;AAAA,MACjC;AAAA;AAAA,MAGA,mBAAwC,OAAiB;AACvD,eAAO,MAAM,mBAAmB,KAAK;AAAA,MACvC;AAAA;AAAA,MAGA,cAAmC,OAAkB;AACnD,eAAO,MAAM,cAAc,KAAK;AAAA,MAClC;AAAA;AAAA,MAGA,gBAA6B;AAC3B,eAAO,MAAM,WAAW;AAAA,MAC1B;AAAA;AAAA,MAGA,aAAkC,OAAmB;AACnD,eAAO,KAAK,cAAc,KAAK,IAAI;AAAA,MACrC;AAAA;AAAA,MAGA,SAA8B,OAAU,MAA6B;AACnE,YAAI;AACF,iBAAO,KAAK,KAAK,OAAO,IAAI;AAAA,QAC9B,SAAS,OAAO;AACd,kBAAQ,MAAM,wBAAwB,KAAK,KAAK,KAAK;AACrD,iBAAO;AAAA,QACT;AAAA,MACF;AAAA;AAAA,MAGA,QAA6B,OAAU,SAAyC;AAC9E,eAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,gBAAM,YAAY,UAAU,WAAW,MAAM;AAC3C,mBAAO,IAAI,MAAM,6BAA6B,KAAK,EAAE,CAAC;AAAA,UACxD,GAAG,OAAO,IAAI;AAEd,eAAK,KAAK,OAAO,CAAC,SAAS;AACzB,gBAAI,WAAW;AACb,2BAAa,SAAS;AAAA,YACxB;AACA,oBAAQ,IAAI;AAAA,UACd,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAAA;AAAA,MAGA,WAAgC,QAAa,SAA6D;AACxG,eAAO,IAAI,QAAQ,CAAC,SAAS,WAAW;AACtC,gBAAM,YAAY,UAAU,WAAW,MAAM;AAC3C,mBAAO,IAAI,MAAM,sCAAsC,OAAO,KAAK,IAAI,CAAC,EAAE,CAAC;AAAA,UAC7E,GAAG,OAAO,IAAI;AAEd,gBAAM,WAAW,oBAAI,IAAwB;AAE7C,iBAAO,QAAQ,WAAS;AACtB,kBAAM,UAA2B,CAAC,SAAS;AAEzC,qBAAO,QAAQ,OAAK;AAClB,oBAAI,SAAS,IAAI,CAAC,GAAG;AACnB,uBAAK,IAAI,GAAG,SAAS,IAAI,CAAC,CAAE;AAAA,gBAC9B;AAAA,cACF,CAAC;AAED,kBAAI,WAAW;AACb,6BAAa,SAAS;AAAA,cACxB;AAEA,sBAAQ,EAAE,OAAO,KAAK,CAAC;AAAA,YACzB;AAEA,qBAAS,IAAI,OAAO,OAAO;AAC3B,iBAAK,KAAK,OAAO,OAAO;AAAA,UAC1B,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAAA,IACF;AAAA;AAAA;;;ACrcA;AAAA;AAAA;AAAA;AAAA;AAAA,IAWa,sBAmGA;AA9Gb;AAAA;AAAA;AAWO,IAAM,uBAAN,MAAM,sBAA8C;AAAA,MAApD;AACL,aAAQ,aAA2C,CAAC;AAAA;AAAA,MAEpD,MAAM,OAAe,UAA8B,OAAkB;AACnE,cAAM,YAAY,KAAK,eAAe,OAAO,UAAU,KAAK;AAC5D,aAAK,WAAW,KAAK,SAAS;AAC9B,eAAO;AAAA,MACT;AAAA,MAEA,IAAI,OAAe,UAA8B,OAAkB;AACjE,eAAO,KAAK,MAAM,OAAO,UAAU,KAAK;AAAA,MAC1C;AAAA,MAEA,GAAG,YAAmC;AACpC,cAAM,cAAc,CAAC,QAAa;AAChC,iBAAO,WAAW,KAAK,aAAW;AAChC,kBAAM,aAAa,QAAQ,MAAM;AACjC,mBAAO,WAAW,GAAG;AAAA,UACvB,CAAC;AAAA,QACH;AACA,aAAK,WAAW,KAAK,WAAW;AAChC,eAAO;AAAA,MACT;AAAA,MAEA,GAAG,OAAe,QAAqB;AACrC,cAAM,YAAY,CAAC,QAAa;AAC9B,gBAAM,aAAa,KAAK,cAAc,KAAK,KAAK;AAChD,iBAAO,OAAO,SAAS,UAAU;AAAA,QACnC;AACA,aAAK,WAAW,KAAK,SAAS;AAC9B,eAAO;AAAA,MACT;AAAA,MAEA,IAAI,OAAe,QAAqB;AACtC,cAAM,YAAY,CAAC,QAAa;AAC9B,gBAAM,aAAa,KAAK,cAAc,KAAK,KAAK;AAChD,iBAAO,CAAC,OAAO,SAAS,UAAU;AAAA,QACpC;AACA,aAAK,WAAW,KAAK,SAAS;AAC9B,eAAO;AAAA,MACT;AAAA,MAEA,MAAM,OAAe,SAA0B,OAAsB;AACnE,cAAM,QAAQ,OAAO,YAAY,WAAW,IAAI,OAAO,SAAS,KAAK,IAAI;AACzE,cAAM,YAAY,CAAC,QAAa;AAC9B,gBAAM,aAAa,KAAK,cAAc,KAAK,KAAK;AAChD,iBAAO,OAAO,eAAe,YAAY,MAAM,KAAK,UAAU;AAAA,QAChE;AACA,aAAK,WAAW,KAAK,SAAS;AAC9B,eAAO;AAAA,MACT;AAAA,MAEA,QAAuB;AACrB,cAAM,SAAS,IAAI,sBAAqB;AACxC,eAAO,aAAa,CAAC,GAAG,KAAK,UAAU;AACvC,eAAO;AAAA,MACT;AAAA,MAEA,QAA+B;AAC7B,YAAI,KAAK,WAAW,WAAW,GAAG;AAChC,iBAAO,MAAM;AAAA,QACf;AAEA,eAAO,CAAC,QAAa;AACnB,iBAAO,KAAK,WAAW,MAAM,eAAa,UAAU,GAAG,CAAC;AAAA,QAC1D;AAAA,MACF;AAAA,MAEQ,eAAe,OAAe,UAA8B,OAAmC;AACrG,eAAO,CAAC,QAAa;AACnB,gBAAM,aAAa,KAAK,cAAc,KAAK,KAAK;AAEhD,kBAAQ,UAAU;AAAA,YAChB,KAAK;AACH,qBAAO,eAAe;AAAA,YACxB,KAAK;AACH,qBAAO,eAAe;AAAA,YACxB,KAAK;AACH,qBAAO,aAAa;AAAA,YACtB,KAAK;AACH,qBAAO,cAAc;AAAA,YACvB,KAAK;AACH,qBAAO,aAAa;AAAA,YACtB,KAAK;AACH,qBAAO,cAAc;AAAA,YACvB;AACE,oBAAM,IAAI,MAAM,yBAAyB,QAAQ,EAAE;AAAA,UACvD;AAAA,QACF;AAAA,MACF;AAAA,MAEQ,cAAc,KAAU,OAAoB;AAClD,eAAO,MAAM,MAAM,GAAG,EAAE,OAAO,CAAC,KAAK,QAAQ,MAAM,GAAG,GAAG,GAAG;AAAA,MAC9D;AAAA,IACF;AAKO,IAAM,wBAAN,MAAM,uBAAgD;AAAA,MAAtD;AACL,aAAQ,UAA+B,CAAC;AAAA;AAAA,MAExC,IAAI,OAAe,OAAkB;AACnC,aAAK,QAAQ,KAAK,IAAI;AACtB,eAAO;AAAA,MACT;AAAA,MAEA,MAAM,OAAqB;AACzB,aAAK,QAAQ,KAAK,IAAI;AACtB,eAAO;AAAA,MACT;AAAA,MAEA,IAAI,OAAe,OAAqB;AAEtC,aAAK,QAAQ,KAAK,IAAI,EAAE,MAAM,MAAM;AACpC,eAAO;AAAA,MACT;AAAA,MAEA,KAAK,OAAe,OAAkB;AAEpC,aAAK,QAAQ,KAAK,IAAI,EAAE,OAAO,MAAM;AACrC,eAAO;AAAA,MACT;AAAA,MAEA,KAAK,OAAe,OAAkB;AAEpC,aAAK,QAAQ,KAAK,IAAI,EAAE,OAAO,MAAM;AACrC,eAAO;AAAA,MACT;AAAA,MAEA,QAAwB;AACtB,cAAM,SAAS,IAAI,uBAAsB;AACzC,eAAO,UAAU,EAAE,GAAG,KAAK,QAAQ;AACnC,eAAO;AAAA,MACT;AAAA,MAEA,QAA6B;AAC3B,eAAO,EAAE,GAAG,KAAK,QAAQ;AAAA,MAC3B;AAAA,IACF;AAAA;AAAA;;;ACtJA;AAAA;AAAA;AAAA;AAAA,IAca;AAdb;AAAA;AAAA;AAcO,IAAM,kBAAN,MAAkD;AAAA,MACvD,qBAAoC;AAElC,cAAM,EAAE,sBAAAC,sBAAqB,IAAI;AACjC,eAAO,IAAIA,sBAAqB;AAAA,MAClC;AAAA,MAEA,sBAAsC;AAEpC,cAAM,EAAE,uBAAAC,uBAAsB,IAAI;AAClC,eAAO,IAAIA,uBAAsB;AAAA,MACnC;AAAA,MAEA,MAAM,KACJ,YACA,OACA,SACc;AACd,YAAI;AAEJ,YAAI,OAAO,UAAU,YAAY;AAE/B,oBAAU,WAAW,OAAO,KAAK;AAAA,QACnC,OAAO;AAEL,oBAAU,WAAW,OAAO,SAAO,KAAK,aAAa,KAAK,KAAK,CAAC;AAAA,QAClE;AAGA,YAAI,SAAS,MAAM;AACjB,oBAAU,KAAK,aAAa,SAAS,QAAQ,IAAI;AAAA,QACnD;AAGA,YAAI,SAAS,MAAM;AACjB,oBAAU,QAAQ,MAAM,QAAQ,IAAI;AAAA,QACtC;AACA,YAAI,SAAS,OAAO;AAClB,oBAAU,QAAQ,MAAM,GAAG,QAAQ,KAAK;AAAA,QAC1C;AAEA,eAAO;AAAA,MACT;AAAA,MAEA,MAAM,QACJ,YACA,OACmB;AACnB,cAAM,UAAU,MAAM,KAAK,KAAK,YAAY,OAAO,EAAE,OAAO,EAAE,CAAC;AAC/D,eAAO,QAAQ,SAAS,IAAI,QAAQ,CAAC,IAAI;AAAA,MAC3C;AAAA,MAEA,MAAM,UACJ,YACA,UACY;AACZ,cAAM,SAAS;AAAA,UACb,KAAK,KAAK,WAAW;AAAA,UACrB,GAAG;AAAA,QACL;AAEA,mBAAW,KAAK,MAAM;AACtB,eAAO;AAAA,MACT;AAAA,MAEA,MAAM,WACJ,YACA,WACoC;AACpC,YAAI,gBAAgB;AACpB,mBAAW,OAAO,WAAW;AAC3B,gBAAM,KAAK,UAAU,YAAY,GAAG;AACpC;AAAA,QACF;AACA,eAAO,EAAE,cAAc;AAAA,MACzB;AAAA,MAEA,MAAM,UACJ,YACA,QACA,QACoC;AACpC,cAAM,MAAM,MAAM,KAAK,QAAQ,YAAY,MAAM;AACjD,YAAI,CAAC,KAAK;AACR,iBAAO,EAAE,eAAe,EAAE;AAAA,QAC5B;AAEA,aAAK,YAAY,KAAK,MAAM;AAC5B,eAAO,EAAE,eAAe,EAAE;AAAA,MAC5B;AAAA,MAEA,MAAM,UACJ,YACA,QACmC;AACnC,cAAM,QAAQ,WAAW;AAAA,UAAU,SACjC,OAAO,WAAW,aAAa,OAAO,GAAG,IAAI,KAAK,aAAa,KAAK,MAAM;AAAA,QAC5E;AAEA,YAAI,UAAU,IAAI;AAChB,iBAAO,EAAE,cAAc,EAAE;AAAA,QAC3B;AAEA,mBAAW,OAAO,OAAO,CAAC;AAC1B,eAAO,EAAE,cAAc,EAAE;AAAA,MAC3B;AAAA,MAEA,MAAM,WACJ,YACA,QACmC;AACnC,YAAI,eAAe;AAGnB,iBAAS,IAAI,WAAW,SAAS,GAAG,KAAK,GAAG,KAAK;AAC/C,gBAAM,MAAM,WAAW,CAAC;AACxB,gBAAM,UAAU,OAAO,WAAW,aAAa,OAAO,GAAG,IAAI,KAAK,aAAa,KAAK,MAAM;AAE1F,cAAI,SAAS;AACX,uBAAW,OAAO,GAAG,CAAC;AACtB;AAAA,UACF;AAAA,QACF;AAEA,eAAO,EAAE,aAAa;AAAA,MACxB;AAAA,MAEA,MAAM,MACJ,YACA,OACiB;AACjB,cAAM,UAAU,MAAM,KAAK,KAAK,YAAY,KAAK;AACjD,eAAO,QAAQ;AAAA,MACjB;AAAA,MAEQ,aAAa,KAAU,OAAqB;AAClD,YAAI,CAAC,SAAS,OAAO,UAAU,UAAU;AACvC,iBAAO;AAAA,QACT;AAEA,eAAO,OAAO,QAAQ,KAAK,EAAE,MAAM,CAAC,CAAC,OAAO,KAAK,MAAM;AACrD,gBAAM,WAAW,KAAK,cAAc,KAAK,KAAK;AAE9C,cAAI,SAAS,OAAO,UAAU,YAAY,CAAC,MAAM,QAAQ,KAAK,KAAK,EAAE,iBAAiB,OAAO;AAE3F,mBAAO,OAAO,QAAQ,KAAK,EAAE,MAAM,CAAC,CAAC,UAAU,aAAa,MAAM;AAChE,sBAAQ,UAAU;AAAA,gBAChB,KAAK;AACH,yBAAO,WAAW;AAAA,gBACpB,KAAK;AACH,yBAAO,YAAY;AAAA,gBACrB,KAAK;AACH,yBAAO,WAAW;AAAA,gBACpB,KAAK;AACH,yBAAO,YAAY;AAAA,gBACrB,KAAK;AAAA,gBACL,KAAK;AACH,yBAAO,aAAa;AAAA,gBACtB,KAAK;AACH,yBAAO,MAAM,QAAQ,aAAa,KAAK,cAAc,SAAS,QAAQ;AAAA,gBACxE,KAAK;AACH,yBAAO,MAAM,QAAQ,aAAa,KAAK,CAAC,cAAc,SAAS,QAAQ;AAAA,gBACzE,KAAK;AACH,wBAAM,QAAQ,IAAI,OAAO,aAAa;AACtC,yBAAO,OAAO,aAAa,YAAY,MAAM,KAAK,QAAQ;AAAA,gBAC5D;AACE,yBAAO,aAAa;AAAA,cACxB;AAAA,YACF,CAAC;AAAA,UACH;AAEA,iBAAO,aAAa;AAAA,QACtB,CAAC;AAAA,MACH;AAAA,MAEQ,cAAc,KAAU,OAAoB;AAClD,eAAO,MAAM,MAAM,GAAG,EAAE,OAAO,CAAC,KAAK,QAAQ,MAAM,GAAG,GAAG,GAAG;AAAA,MAC9D;AAAA,MAEQ,aAAgB,SAAc,MAAmC;AACvE,eAAO,QAAQ,KAAK,CAAC,GAAG,MAAM;AAC5B,qBAAW,CAAC,OAAO,SAAS,KAAK,OAAO,QAAQ,IAAI,GAAG;AACrD,kBAAM,SAAS,KAAK,cAAc,GAAG,KAAK;AAC1C,kBAAM,SAAS,KAAK,cAAc,GAAG,KAAK;AAE1C,gBAAI,aAAa;AACjB,gBAAI,SAAS,OAAQ,cAAa;AAAA,qBACzB,SAAS,OAAQ,cAAa;AAEvC,gBAAI,eAAe,GAAG;AACpB,qBAAO,cAAc,IAAI,aAAa,CAAC;AAAA,YACzC;AAAA,UACF;AACA,iBAAO;AAAA,QACT,CAAC;AAAA,MACH;AAAA,MAEQ,YAAY,KAAU,QAAmB;AAC/C,eAAO,QAAQ,MAAM,EAAE,QAAQ,CAAC,CAAC,OAAO,KAAK,MAAM;AACjD,cAAI,SAAS,OAAO,UAAU,YAAY,CAAC,MAAM,QAAQ,KAAK,KAAK,EAAE,iBAAiB,OAAO;AAE3F,gBAAI,MAAM,SAAS,QAAW;AAC5B,oBAAM,eAAe,KAAK,cAAc,KAAK,KAAK,KAAK;AACvD,mBAAK,cAAc,KAAK,OAAO,eAAe,MAAM,IAAI;AAAA,YAC1D,WAAW,MAAM,UAAU,QAAW;AACpC,oBAAM,eAAe,KAAK,cAAc,KAAK,KAAK,KAAK,CAAC;AACxD,2BAAa,KAAK,MAAM,KAAK;AAAA,YAC/B,WAAW,MAAM,UAAU,QAAW;AACpC,oBAAM,eAAe,KAAK,cAAc,KAAK,KAAK,KAAK,CAAC;AACxD,oBAAM,QAAQ,aAAa,QAAQ,MAAM,KAAK;AAC9C,kBAAI,QAAQ,IAAI;AACd,6BAAa,OAAO,OAAO,CAAC;AAAA,cAC9B;AAAA,YACF,OAAO;AACL,mBAAK,cAAc,KAAK,OAAO,KAAK;AAAA,YACtC;AAAA,UACF,WAAW,UAAU,QAAW;AAE9B,iBAAK,gBAAgB,KAAK,KAAK;AAAA,UACjC,OAAO;AACL,iBAAK,cAAc,KAAK,OAAO,KAAK;AAAA,UACtC;AAAA,QACF,CAAC;AAAA,MACH;AAAA,MAEQ,cAAc,KAAU,OAAe,OAAkB;AAC/D,cAAM,OAAO,MAAM,MAAM,GAAG;AAC5B,YAAI,UAAU;AAEd,iBAAS,IAAI,GAAG,IAAI,KAAK,SAAS,GAAG,KAAK;AACxC,gBAAM,MAAM,KAAK,CAAC;AAClB,cAAI,EAAE,OAAO,YAAY,OAAO,QAAQ,GAAG,MAAM,UAAU;AACzD,oBAAQ,GAAG,IAAI,CAAC;AAAA,UAClB;AACA,oBAAU,QAAQ,GAAG;AAAA,QACvB;AAEA,gBAAQ,KAAK,KAAK,SAAS,CAAC,CAAC,IAAI;AAAA,MACnC;AAAA,MAEQ,gBAAgB,KAAU,OAAqB;AACrD,cAAM,OAAO,MAAM,MAAM,GAAG;AAC5B,YAAI,UAAU;AAEd,iBAAS,IAAI,GAAG,IAAI,KAAK,SAAS,GAAG,KAAK;AACxC,gBAAM,MAAM,KAAK,CAAC;AAClB,cAAI,EAAE,OAAO,UAAU;AACrB;AAAA,UACF;AACA,oBAAU,QAAQ,GAAG;AAAA,QACvB;AAEA,eAAO,QAAQ,KAAK,KAAK,SAAS,CAAC,CAAC;AAAA,MACtC;AAAA,MAEQ,aAAqB;AAC3B,eAAO,GAAG,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,OAAO,GAAG,CAAC,CAAC;AAAA,MACjE;AAAA,IACF;AAAA;AAAA;;;ACrQA,SAAS,gBAAgB,cAAgC;AACvD,SAAO,aAAa,IAAI,SAAO;AAE7B,QAAI;AACJ,QAAI,IAAI,SAAS,aAAa;AAC5B,aAAO;AAAA,IACT,WAAW,IAAI,SAAS,UAAU,IAAI,SAAS,eAAe,IAAI,SAAS,YAAY,IAAI,SAAS,QAAQ;AAC1G,aAAO,IAAI;AAAA,IACb,OAAO;AAEL,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,MACL,IAAI,IAAI;AAAA,MACR;AAAA,MACA,SAAS,IAAI,WAAW;AAAA,MACxB,WAAW,IAAI;AAAA,MACf,YAAY,IAAI;AAAA,MAChB,WAAW,IAAI,YAAY,IAAI,KAAK,IAAI,SAAS,IAAI,oBAAI,KAAK;AAAA,MAC9D,UAAU,IAAI;AAAA,IAChB;AAAA,EACF,CAAC;AACH;AAlCA,IAIA,eACA,aA+Ba;AApCb;AAAA;AAAA;AAIA,oBAAgF;AAChF,kBAA2B;AAE3B;AA6BO,IAAM,aAAN,cAAyB,4BAAc;AAAA,MAG5C,YAAY,OAAc,QAA+B;AACvD,cAAM;AAAA,UACJ,SAAS,QAAQ,WAAW,MAAM;AAAA,UAClC,aAAa,QAAQ,eAAe,MAAM,eAAe;AAAA,UACzD,UAAU,QAAQ,YAAY;AAAA,UAC9B,GAAG;AAAA,QACL,CAAC;AACD,aAAK,QAAQ;AAAA,MACf;AAAA,MAEA,IAAI,OAA6C;AAC/C,eAAO,IAAI,uBAAsB,CAAC,eAAe;AAC/C,eAAK,KAAK,YAAY,KAAK;AAAA,QAC7B,CAAC;AAAA,MACH;AAAA,MAEA,MAAc,KAAK,YAAiB,OAAqC;AACvE,cAAM,EAAE,UAAU,OAAO,UAAU,OAAO,eAAe,IAAI;AAE7D,YAAI;AACF,qBAAW,KAAK,EAAE,MAAM,wBAAU,aAAa,UAAU,MAAM,CAAC;AAGhE,gBAAM,iBAAiB,OAAO,IAAI,CAAAC,UAAQ;AACxC,gBAAI;AAGJ,gBAAKA,MAAa,YAAY;AAC5B,kBAAI;AACF,sBAAM,aAAa,OAAQA,MAAa,eAAe,WACnD,KAAK,MAAOA,MAAa,UAAU,IAClCA,MAAa;AAGlB,yBAAU;AAAA,cACZ,SAAS,OAAO;AACd,wBAAQ,KAAK,2CAA2C,KAAK;AAC7D,yBAAS;AAAA,cACX;AAAA,YACF;AAEA,mBAAO;AAAA,cACL,MAAMA,MAAK;AAAA,cACX,aAAaA,MAAK;AAAA,cAClB;AAAA;AAAA,cAEA,SAAS;AAAA,YACX;AAAA,UACF,CAAC;AAGD,gBAAM,oBAAoB,gBAAgB,QAAQ;AAGlD,gBAAM,KAAK,MAAM,IAAI,mBAAmB,QAAW;AAAA,YACjD,gBAAgB;AAAA,YAChB;AAAA,YACA,OAAO;AAAA,YACP,GAAG;AAAA;AAAA,YAEH,SAAS,CAAC,UAAU;AAClB,mBAAK,YAAY,YAAY,UAAU,OAAO,KAAK;AAAA,YACrD;AAAA,UACF,CAAC;AAED,qBAAW,SAAS;AAAA,QACtB,SAAS,OAAO;AACd,qBAAW,KAAK;AAAA,YACd,MAAM,wBAAU;AAAA,YAChB;AAAA,YACA;AAAA,YACA,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,YAC9D,MAAM,iBAAiB,QAAQ,MAAM,OAAO;AAAA,UAC9C,CAAC;AACD,qBAAW,MAAM,KAAK;AAAA,QACxB;AAAA,MACF;AAAA;AAAA;AAAA;AAAA;AAAA,MAMQ,YAAY,YAAiB,UAAkB,OAAe,OAAkB;AACtF,gBAAQ,MAAM,MAAM;AAAA,UAClB;AACE,uBAAW,KAAK;AAAA,cACd,MAAM,wBAAU;AAAA,cAChB;AAAA,cACA;AAAA,cACA,WAAW,MAAM;AAAA,cACjB,MAAM,MAAM;AAAA,YACd,CAAC;AACD;AAAA,UAEF;AACE,uBAAW,KAAK;AAAA,cACd,MAAM,wBAAU;AAAA,cAChB;AAAA,cACA;AAAA,cACA,WAAW,MAAM;AAAA,cACjB,OAAO,MAAM;AAAA,YACf,CAAC;AACD;AAAA,UAEF;AACE,uBAAW,KAAK;AAAA,cACd,MAAM,wBAAU;AAAA,cAChB;AAAA,cACA;AAAA,cACA,WAAW,MAAM;AAAA,YACnB,CAAC;AACD;AAAA,UAEF;AACE,uBAAW,KAAK;AAAA,cACd,MAAM,wBAAU;AAAA,cAChB;AAAA,cACA;AAAA,cACA,YAAY,MAAM;AAAA,cAClB,cAAc,MAAM;AAAA,YACtB,CAAC;AACD;AAAA,UAEF;AACE,uBAAW,KAAK;AAAA,cACd,MAAM,wBAAU;AAAA,cAChB;AAAA,cACA;AAAA,cACA,YAAY,MAAM;AAAA,cAClB,OAAO,MAAM;AAAA,YACf,CAAC;AACD;AAAA,UAEF;AACE,uBAAW,KAAK;AAAA,cACd,MAAM,wBAAU;AAAA,cAChB;AAAA,cACA;AAAA,cACA,YAAY,MAAM;AAAA,YACpB,CAAC;AACD;AAAA,UAEF;AACE,uBAAW,KAAK;AAAA,cACd,MAAM,wBAAU;AAAA,cAChB;AAAA,cACA;AAAA,cACA,YAAY,MAAM;AAAA,cAClB,SAAS,MAAM;AAAA,YACjB,CAAC;AACD;AAAA,UAEF;AACE,gBAAI,MAAM,YAAY,aAAa;AACjC,yBAAW,KAAK;AAAA,gBACd,MAAM,wBAAU;AAAA,gBAChB;AAAA,gBACA;AAAA,gBACA,SAAS;AAAA,gBACT,WAAW,MAAM;AAAA,cACnB,CAAC;AAAA,YACH,OAAO;AACL,yBAAW,KAAK;AAAA,gBACd,MAAM,wBAAU;AAAA,gBAChB;AAAA,gBACA;AAAA,gBACA,QAAQ,MAAM;AAAA,cAChB,CAAC;AAAA,YACH;AACA;AAAA;AAAA,UAGF;AACE;AAAA,QACJ;AAAA,MACF;AAAA,MAEA,UAAgB;AACd,aAAK,MAAM,QAAQ;AAAA,MACrB;AAAA,IACF;AAAA;AAAA;;;AC3NA;AAAA;AAAA;AAAA;AAWO,SAAS,YACd,OACA,QACe;AACf,MAAI,iBAAiB,8BAAe;AAClC,WAAO;AAAA,EACT;AACA,SAAO,IAAI,WAAW,OAAO,MAAM;AACrC;AAnBA,IAIAC;AAJA;AAAA;AAAA;AAIA,IAAAA,iBAA2C;AAE3C;AAAA;AAAA;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA,IAAAC,sBAA2B;AAa3B;;;ACRO,IAAe,aAAf,cAAkC,MAAM;AAAA,EAQ7C,YACE,SACA,SACA,OACA;AACA,UAAM,OAAO;AACb,SAAK,OAAO,KAAK,YAAY;AAC7B,SAAK,YAAY,oBAAI,KAAK;AAC1B,SAAK,UAAU;AACf,SAAK,QAAQ;AAGb,QAAI,MAAM,mBAAmB;AAC3B,YAAM,kBAAkB,MAAM,KAAK,WAAW;AAAA,IAChD;AAAA,EACF;AAAA,EAEA,SAAS;AACP,WAAO;AAAA,MACL,MAAM,KAAK;AAAA,MACX,MAAM,KAAK;AAAA,MACX,UAAU,KAAK;AAAA,MACf,SAAS,KAAK;AAAA,MACd,WAAW,KAAK,UAAU,YAAY;AAAA,MACtC,SAAS,KAAK;AAAA,MACd,OAAO,KAAK;AAAA,IACd;AAAA,EACF;AACF;AAGO,IAAK,gBAAL,kBAAKC,mBAAL;AACL,EAAAA,eAAA,mBAAgB;AAChB,EAAAA,eAAA,aAAU;AACV,EAAAA,eAAA,WAAQ;AACR,EAAAA,eAAA,UAAO;AACP,EAAAA,eAAA,gBAAa;AACb,EAAAA,eAAA,aAAU;AACV,EAAAA,eAAA,YAAS;AACT,EAAAA,eAAA,kBAAe;AARL,SAAAA;AAAA,GAAA;AAYL,IAAM,qBAAN,cAAiC,WAAW;AAAA,EAA5C;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,4BAAN,cAAwC,WAAW;AAAA,EAAnD;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,6BAAN,cAAyC,WAAW;AAAA,EAApD;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAGO,IAAM,eAAN,cAA2B,WAAW;AAAA,EAAtC;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,eAAN,cAA2B,WAAW;AAAA,EAAtC;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,iBAAN,cAA6B,WAAW;AAAA,EAAxC;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAGO,IAAM,aAAN,cAAyB,WAAW;AAAA,EAApC;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,qBAAN,cAAiC,WAAW;AAAA,EAA5C;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,kBAAN,cAA8B,WAAW;AAAA,EAAzC;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,4BAAN,cAAwC,WAAW;AAAA,EAAnD;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAGO,IAAM,YAAN,cAAwB,WAAW;AAAA,EAAnC;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,qBAAN,cAAiC,WAAW;AAAA,EAA5C;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,oBAAN,cAAgC,WAAW;AAAA,EAA3C;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,sBAAN,cAAkC,WAAW;AAAA,EAA7C;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAGO,IAAM,kBAAN,cAA8B,WAAW;AAAA,EAAzC;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,wBAAN,cAAoC,WAAW;AAAA,EAA/C;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAGO,IAAM,eAAN,cAA2B,WAAW;AAAA,EAAtC;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,aAAN,cAAyB,WAAW;AAAA,EAApC;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,iBAAN,cAA6B,WAAW;AAAA,EAAxC;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAGO,IAAM,cAAN,cAA0B,WAAW;AAAA,EAArC;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,mBAAN,cAA+B,WAAW;AAAA,EAA1C;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAGO,IAAM,mBAAN,cAA+B,WAAW;AAAA,EAA1C;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AAEO,IAAM,6BAAN,cAAyC,WAAW;AAAA,EAApD;AAAA;AACL,SAAS,OAAO;AAChB,SAAS,WAAW;AAAA;AACtB;AASO,IAAM,sBAAN,MAAkD;AAAA,EACvD,UAAU,OAA4B;AACpC,WAAO;AAAA,EACT;AAAA,EAEA,OAAO,OAAyB;AAC9B,YAAQ,MAAM,IAAI,MAAM,QAAQ,KAAK,MAAM,IAAI,KAAK,MAAM,OAAO,IAAI;AAAA,MACnE,SAAS,MAAM;AAAA,MACf,OAAO,MAAM;AAAA,IACf,CAAC;AAAA,EACH;AACF;AAEO,IAAM,oBAAN,MAAgD;AAAA,EAIrD,YACE,aAAqB,GACrB,sBAAuC;AAAA,IACrC;AAAA,IACA;AAAA,EACF,GACA;AACA,SAAK,aAAa;AAClB,SAAK,sBAAsB,IAAI,IAAI,mBAAmB;AAAA,EACxD;AAAA,EAEA,UAAU,OAA4B;AACpC,WAAO,KAAK,oBAAoB,IAAI,MAAM,QAAQ;AAAA,EACpD;AAAA,EAEA,MAAM,OAAO,OAAkC;AAE7C,YAAQ,KAAK,4BAA4B,MAAM,IAAI,QAAQ;AAAA,EAC7D;AACF;AAQO,IAAM,wBAAN,MAA6D;AAAA,EAClE,WAAW,OAA4B;AACrC,WAAO,iBAAiB,cAAc,iBAAiB;AAAA,EACzD;AAAA,EAEA,MAAM,QAAQ,OAAqC;AAEjD,YAAQ,IAAI,kDAAkD;AAC9D,WAAO;AAAA,EACT;AACF;AAGO,IAAM,sBAAN,MAA0B;AAAA,EAA1B;AACL,SAAQ,UAAmC,CAAC;AAAA;AAAA,EAE5C,YAAY,SAAuB;AACjC,SAAK,QAAQ,UAAU;AACvB,WAAO;AAAA,EACT;AAAA,EAEA,UAAU,OAAqB;AAC7B,SAAK,QAAQ,QAAQ;AACrB,WAAO;AAAA,EACT;AAAA,EAEA,aAAa,UAAwB;AACnC,SAAK,QAAQ,WAAW;AACxB,WAAO;AAAA,EACT;AAAA,EAEA,cAAc,WAAyB;AACrC,SAAK,QAAQ,YAAY;AACzB,WAAO;AAAA,EACT;AAAA,EAEA,eAAe,OAAqB;AAClC,SAAK,QAAQ,aAAa;AAC1B,WAAO;AAAA,EACT;AAAA,EAEA,WAAW,KAAa,OAAsB;AAC5C,SAAK,QAAQ,GAAG,IAAI;AACpB,WAAO;AAAA,EACT;AAAA,EAEA,QAAiC;AAC/B,WAAO,EAAE,GAAG,KAAK,QAAQ;AAAA,EAC3B;AACF;AAGO,SAAS,iBAAiB,OAA4B;AAC3D,QAAM,sBAAsB;AAAA,IAC1B;AAAA,IACA;AAAA,EACF;AACA,SAAO,oBAAoB,SAAS,MAAM,QAAQ;AACpD;AAEO,SAAS,qBAAqB,OAA4B;AAC/D,SAAO,MAAM,aAAa;AAC5B;AAEO,SAAS,YAAY,OAA4B;AACtD,SAAO,MAAM,aAAa;AAC5B;AAEO,SAAS,qBAA0C;AACxD,SAAO,IAAI,oBAAoB;AACjC;;;ACvSA,gBAAkB;AAMlB,SAAS,YAAY;AACnB,SAAO,YAAE,OAAyB,WAAS,OAAO,UAAU,UAAU;AACxE;AAGO,IAAM,sBAAsB,YAAE,OAAO;AAAA,EAC1C,aAAa,YAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,SAAS;AAAA,EAC/C,WAAW,YAAE,OAAO,EAAE,SAAS,EAAE,SAAS;AAAA,EAC1C,MAAM,YAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,SAAS;AAAA,EACxC,kBAAkB,YAAE,OAAO,EAAE,IAAI,EAAE,EAAE,IAAI,CAAC,EAAE,SAAS;AAAA,EACrD,iBAAiB,YAAE,OAAO,EAAE,IAAI,EAAE,EAAE,IAAI,CAAC,EAAE,SAAS;AAAA,EACpD,MAAM,YAAE,MAAM,YAAE,OAAO,CAAC,EAAE,SAAS;AACrC,CAAC;AAIM,IAAM,6BAA6B,YAAE,OAAO;AAAA,EACjD,SAAS,YAAE,QAAQ;AAAA,EACnB,iBAAiB,YAAE,MAAM,YAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EAC9C,eAAe,YAAE,MAAM,YAAE,OAAO,CAAC,EAAE,SAAS;AAAA,EAC5C,SAAS,YAAE,OAAO,EAAE,SAAS,EAAE,SAAS;AAAA,EACxC,eAAe,YAAE,KAAK,CAAC,WAAW,UAAU,OAAO,CAAC,EAAE,SAAS;AACjE,CAAC;AAEM,IAAM,0BAA0B,YAAE,OAAO;AAAA,EAC9C,UAAU,YAAE,OAAO,EAAE,SAAS,EAAE,SAAS;AAAA,EACzC,iBAAiB,YAAE,OAAO,EAAE,YAAY,EAAE,SAAS;AAAA,EACnD,mBAAmB,YAAE,QAAQ,EAAE,SAAS;AAAA,EACxC,eAAe,YAAE,OAAO;AAAA,IACtB,gBAAgB,UAAU;AAAA,IAC1B,gBAAgB,UAAU;AAAA,IAC1B,aAAa,UAAU;AAAA,EACzB,CAAC,EAAE,SAAS;AACd,CAAC;AAEM,IAAM,uBAAuB,YAAE,OAAO;AAAA,EAC3C,MAAM,YAAE,OAAO,EAAE,IAAI,CAAC;AAAA,EACtB,aAAa,YAAE,OAAO,EAAE,SAAS;AAAA,EACjC,QAAQ,YAAE,IAAI,EAAE,SAAS;AAAA,EACzB,QAAQ,UAAU,EAAE,SAAS;AAAA,EAC7B,kBAAkB,YAAE,QAAQ,EAAE,SAAS;AACzC,CAAC;AAEM,IAAM,mBAAmB,YAAE,MAAM;AAAA,EACtC,YAAE,QAAQ,QAAQ;AAAA,EAClB,YAAE,QAAQ,YAAY;AAAA,EACtB,YAAE,OAAO;AAAA,IACP,QAAQ,YAAE,IAAI;AAAA,EAChB,CAAC;AACH,CAAC;AAGM,IAAM,oBAAoB,YAAE,OAAO;AAAA,EACxC,MAAM,YAAE,OAAO,EAAE,IAAI,GAAG,wBAAwB;AAAA,EAChD,aAAa,YAAE,OAAO,EAAE,SAAS;AAAA,EACjC,OAAO,YAAE,MAAM,CAAC,YAAE,OAAO,GAAG,YAAE,IAAI,CAAC,CAAC;AAAA,EACpC,cAAc,YAAE,MAAM,CAAC,YAAE,OAAO,GAAG,UAAU,CAAC,CAAC,EAAE,SAAS;AAAA;AAAA,EAE1D,WAAW,YAAE,IAAI,EAAE,SAAS;AAAA,EAC5B,YAAY,iBAAiB,SAAS;AAAA,EACtC,eAAe,oBAAoB,SAAS;AAAA,EAC5C,OAAO,YAAE,MAAM,oBAAoB,EAAE,SAAS;AAAA,EAC9C,QAAQ,YAAE,IAAI,EAAE,SAAS;AAAA;AAAA,EACzB,gBAAgB,2BAA2B,SAAS;AAAA,EACpD,aAAa,wBAAwB,SAAS;AAChD,CAAC;AAGM,IAAM,mBAAmB,YAAE,OAAO;AAAA,EACvC,OAAO,YAAE,OAAO,YAAE,OAAO,GAAG,YAAE,QAAQ,CAAC,EAAE,SAAS;AAAA,EAClD,gBAAgB,YAAE,OAAO,EAAE,SAAS;AAAA,EACpC,OAAO,YAAE,OAAO,EAAE,SAAS;AAAA,EAC3B,QAAQ,YAAE,OAAO,EAAE,SAAS;AAAA,EAC5B,OAAO,YAAE,OAAO,EAAE,SAAS;AAAA;AAAA,EAC3B,aAAa,YAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,CAAC,EAAE,SAAS;AAAA,EAC/C,WAAW,YAAE,OAAO,EAAE,SAAS,EAAE,SAAS;AAAA,EAC1C,QAAQ,YAAE,QAAQ,EAAE,SAAS;AAAA,EAC7B,OAAO,YAAE,MAAM,oBAAoB,EAAE,SAAS;AAAA;AAAA,EAE9C,gBAAgB,2BAA2B,SAAS;AAAA,EACpD,aAAa,wBAAwB,SAAS;AAChD,CAAC;AAGM,IAAM,kBAAN,MAAM,iBAAgB;AAAA,EAG3B,OAAO,cAA+B;AACpC,QAAI,CAAC,iBAAgB,UAAU;AAC7B,uBAAgB,WAAW,IAAI,iBAAgB;AAAA,IACjD;AACA,WAAO,iBAAgB;AAAA,EACzB;AAAA;AAAA,EAGA,oBACE,QACA,SACG;AACH,QAAI;AAEF,wBAAkB,MAAM,MAAM;AAC9B,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,YAAE,UAAU;AAC/B,cAAM,cAAc,mBAAmB,EACpC,WAAW,oBAAqB,MAAc,MAAM,EACpD,WAAW,UAAU,MAAM,EAC3B,WAAW,WAAW,OAAO,EAC7B,MAAM;AAET,cAAM,IAAI;AAAA,UACR,0CAA0C,KAAK,gBAAiB,MAAc,MAAM,CAAC;AAAA,UACrF;AAAA,UACA;AAAA,QACF;AAAA,MACF;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA,EAGA,mBACE,SACA,SACG;AACH,QAAI;AAEF,uBAAiB,MAAM,OAAO;AAC9B,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,YAAE,UAAU;AAC/B,cAAM,cAAc,mBAAmB,EACpC,WAAW,oBAAqB,MAAc,MAAM,EACpD,WAAW,WAAW,OAAO,EAC7B,WAAW,WAAW,OAAO,EAC7B,MAAM;AAET,cAAM,IAAI;AAAA,UACR,kCAAkC,KAAK,gBAAiB,MAAc,MAAM,CAAC;AAAA,UAC7E;AAAA,UACA;AAAA,QACF;AAAA,MACF;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA,EAGA,sBAAyD,UAAsB;AAC7E,QAAI;AAEF,0BAAoB,MAAM,QAAQ;AAClC,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,YAAE,UAAU;AAC/B,cAAM,cAAc,mBAAmB,EACpC,WAAW,oBAAqB,MAAc,MAAM,EACpD,WAAW,YAAY,QAAQ,EAC/B,MAAM;AAET,cAAM,IAAI;AAAA,UACR,qCAAqC,KAAK,gBAAiB,MAAc,MAAM,CAAC;AAAA,UAChF;AAAA,UACA;AAAA,QACF;AAAA,MACF;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA,EAGA,wBAA6D,OAAmB;AAC9E,QAAI;AAEF,kBAAE,MAAM,oBAAoB,EAAE,MAAM,KAAK;AACzC,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,YAAE,UAAU;AAC/B,cAAM,cAAc,mBAAmB,EACpC,WAAW,oBAAqB,MAAc,MAAM,EACpD,WAAW,SAAS,KAAK,EACzB,MAAM;AAET,cAAM,IAAI;AAAA,UACR,uCAAuC,KAAK,gBAAiB,MAAc,MAAM,CAAC;AAAA,UAClF;AAAA,UACA;AAAA,QACF;AAAA,MACF;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA,EAKA,6BAAgE,QAAoB;AAClF,QAAI;AAEF,iCAA2B,MAAM,MAAM;AACvC,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,YAAE,UAAU;AAC/B,cAAM,cAAc,mBAAmB,EACpC,WAAW,oBAAqB,MAAc,MAAM,EACpD,WAAW,UAAU,MAAM,EAC3B,MAAM;AAET,cAAM,IAAI;AAAA,UACR,sDAAsD,KAAK,gBAAiB,MAAc,MAAM,CAAC;AAAA,UACjG;AAAA,UACA;AAAA,QACF;AAAA,MACF;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA,EAGA,0BAA6D,QAAoB;AAC/E,QAAI;AAEF,8BAAwB,MAAM,MAAM;AACpC,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,YAAE,UAAU;AAC/B,cAAM,cAAc,mBAAmB,EACpC,WAAW,oBAAqB,MAAc,MAAM,EACpD,WAAW,UAAU,MAAM,EAC3B,MAAM;AAET,cAAM,IAAI;AAAA,UACR,iDAAiD,KAAK,gBAAiB,MAAc,MAAM,CAAC;AAAA,UAC5F;AAAA,UACA;AAAA,QACF;AAAA,MACF;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA,EAGA,oBAAoB,QAAiC,gBAAgC;AACnF,UAAM,gBAAgB,eAAe,OAAO,WAAS,EAAE,SAAS,OAAO;AAEvE,QAAI,cAAc,SAAS,GAAG;AAC5B,YAAM,cAAc,mBAAmB,EACpC,WAAW,iBAAiB,aAAa,EACzC,WAAW,UAAU,MAAM,EAC3B,MAAM;AAET,YAAM,IAAI;AAAA,QACR,0CAA0C,cAAc,KAAK,IAAI,CAAC;AAAA,QAClE;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGQ,gBAAgB,QAA0C;AAChE,QAAI,CAAC,UAAU,OAAO,WAAW,GAAG;AAClC,aAAO;AAAA,IACT;AACA,WAAO,OACJ,IAAI,WAAS;AACZ,YAAM,OAAO,MAAM,KAAK,SAAS,IAAI,MAAM,KAAK,KAAK,GAAG,IAAI;AAC5D,aAAO,GAAG,IAAI,KAAK,MAAM,OAAO;AAAA,IAClC,CAAC,EACA,KAAK,IAAI;AAAA,EACd;AAAA;AAAA,EAGA,yBACE,MACA,QACA,cACG;AACH,QAAI;AAEF,aAAO,MAAM,IAAI;AACjB,aAAO;AAAA,IACT,SAAS,OAAO;AACd,UAAI,iBAAiB,YAAE,UAAU;AAC/B,cAAM,cAAc,mBAAmB,EACpC,WAAW,oBAAqB,MAAc,MAAM,EACpD,WAAW,QAAQ,IAAI,EACvB,MAAM;AAET,cAAM,IAAI;AAAA,UACR,GAAG,YAAY,KAAK,KAAK,gBAAiB,MAAc,MAAM,CAAC;AAAA,UAC/D;AAAA,UACA;AAAA,QACF;AAAA,MACF;AACA,YAAM;AAAA,IACR;AAAA,EACF;AACF;AAGO,SAAS,eAAe,QAAqB;AAClD,SAAO,SAAU,QAAa,aAAqB,YAAgC;AACjF,UAAM,iBAAiB,WAAW;AAElC,eAAW,QAAQ,YAAa,MAAa;AAE3C,UAAI,KAAK,SAAS,GAAG;AACnB,cAAM,YAAY,KAAK,CAAC;AACxB,YAAI,cAAc,UAAa,cAAc,MAAM;AACjD,cAAI;AACF,mBAAO,MAAM,SAAS;AAAA,UACxB,SAAS,OAAO;AACd,gBAAI,iBAAiB,YAAE,UAAU;AAC/B,oBAAM,cAAc,mBAAmB,EACpC,WAAW,oBAAqB,MAAc,MAAM,EACpD,WAAW,UAAU,SAAS,EAC9B,MAAM;AAET,oBAAM,IAAI;AAAA,gBACR,oCAAqC,MAAc,OAAO,IAAI,CAAC,MAAW,EAAE,OAAO,EAAE,KAAK,IAAI,CAAC;AAAA,gBAC/F;AAAA,gBACA;AAAA,cACF;AAAA,YACF;AACA,kBAAM;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAEA,aAAO,eAAe,MAAM,MAAM,IAAI;AAAA,IACxC;AAEA,WAAO;AAAA,EACT;AACF;AAGO,IAAM,kBAAkB,gBAAgB,YAAY;AAGpD,SAAS,kBAAkB,MAAuB;AACvD,MAAI,OAAO,SAAS,YAAY,KAAK,KAAK,EAAE,WAAW,GAAG;AACxD,UAAM,IAAI,mBAAmB,uCAAuC;AAAA,EACtE;AACA,SAAO,KAAK,KAAK;AACnB;AAEO,SAAS,sBAAsB,UAAoC;AACxE,MAAI,OAAO,aAAa,YAAY,OAAO,aAAa,UAAU;AAChE,UAAM,IAAI,mBAAmB,2CAA2C;AAAA,EAC1E;AACA,SAAO;AACT;AAEO,SAAS,qBAAqB,cAA0C;AAC7E,MAAI,OAAO,iBAAiB,YAAY,OAAO,iBAAiB,YAAY;AAC1E,UAAM,IAAI,mBAAmB,2CAA2C;AAAA,EAC1E;AACA,SAAO;AACT;;;ACjXA;AAQO,IAAM,YAAN,MAAkE;AAAA,EAKvE,YACE,aACA,SACA;AACA,SAAK,QAAQ,oBAAI,IAAI;AACrB,SAAK,cAAc;AACnB,SAAK,mBAAmB;AAAA,MACtB,WAAW,oBAAI,KAAK;AAAA,MACpB,GAAG;AAAA,IACL;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,aAAaC,OAAmC;AAC9C,QAAI,KAAK,MAAM,IAAIA,MAAK,IAAI,GAAG;AAC7B,YAAM,IAAI,MAAM,SAASA,MAAK,IAAI,yBAAyB;AAAA,IAC7D;AAGA,SAAK,uBAAuBA,KAAI;AAEhC,SAAK,MAAM,IAAIA,MAAK,MAAMA,KAAI;AAG9B,SAAK,YAAY,8CAAgC;AAAA,MAC/C;AAAA,MACA,UAAUA,MAAK;AAAA,MACf,WAAW,KAAK,IAAI;AAAA,IACtB,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe,UAA2B;AACxC,UAAM,UAAU,KAAK,MAAM,OAAO,QAAQ;AAE1C,QAAI,SAAS;AAEX,WAAK,YAAY,kDAAkC;AAAA,QACjD;AAAA,QACA;AAAA,QACA,WAAW,KAAK,IAAI;AAAA,MACtB,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,UAAqD;AAC3D,WAAO,KAAK,MAAM,IAAI,QAAQ;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKA,cAAuC;AACrC,WAAO,MAAM,KAAK,KAAK,MAAM,OAAO,CAAC;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,eAAuB;AACrB,WAAO,KAAK,MAAM;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKA,eAAyB;AACvB,WAAO,MAAM,KAAK,KAAK,MAAM,KAAK,CAAC;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,UAA2B;AACjC,WAAO,KAAK,MAAM,IAAI,QAAQ;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YACJ,UACA,OACA,SACA,OACkB;AAClB,UAAMA,QAAO,KAAK,QAAQ,QAAQ;AAElC,QAAI,CAACA,OAAM;AACT,YAAM,IAAI,mBAAmB,SAAS,QAAQ,eAAe;AAAA,QAC3D;AAAA,QACA;AAAA,QACA,SAAS,KAAK;AAAA,MAChB,CAAC;AAAA,IACH;AAGA,UAAM,gBAA8C;AAAA,MAClD,GAAG,KAAK;AAAA,MACR,GAAG;AAAA,MACH,WAAW,oBAAI,KAAK;AAAA,MACpB;AAAA,IACF;AAIA,QAAI;AAEF,UAAI,CAACA,MAAK,QAAQ;AAChB,cAAM,IAAI;AAAA,UACR,SAAS,QAAQ;AAAA,UACjB;AAAA,YACE;AAAA,YACA;AAAA,YACA,SAAS;AAAA,UACX;AAAA,QACF;AAAA,MACF;AAGA,YAAM,SAAS,MAAMA,MAAK,OAAO,OAAO,aAAa;AAIrD,aAAO;AAAA,IACT,SAAS,OAAO;AAEd,WAAK,YAAY,kCAA0B;AAAA,QACzC;AAAA,QACA,UAAU,cAAc,kBAAkB;AAAA,QAC1C,OAAO,cAAc,SAAS;AAAA,QAC9B,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,QAC9D,MAAM,iBAAiB,QAAQ,MAAM,OAAO;AAAA,MAC9C,CAAC;AAED,YAAM,IAAI;AAAA,QACR,0BAA0B,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,QAChF;AAAA,UACE;AAAA,UACA;AAAA,UACA,SAAS;AAAA,UACT,eAAe;AAAA,QACjB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,qBACJ,YAKA,OACsE;AACtE,UAAM,WAAW,WAAW,IAAI,OAAO,cAAc;AACnD,UAAI;AACF,cAAM,SAAS,MAAM,KAAK;AAAA,UACxB,UAAU;AAAA,UACV,UAAU;AAAA,UACV,UAAU;AAAA,UACV;AAAA,QACF;AACA,eAAO,EAAE,UAAU,UAAU,UAAU,OAAO;AAAA,MAChD,SAAS,OAAO;AACd,eAAO;AAAA,UACL,UAAU,UAAU;AAAA,UACpB,QAAQ;AAAA,UACR,OAAO,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC;AAAA,QACjE;AAAA,MACF;AAAA,IACF,CAAC;AAED,WAAO,QAAQ,IAAI,QAAQ;AAAA,EAC7B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,uBACJ,YAKA,OACsE;AACtE,UAAM,UACJ,CAAC;AAEH,eAAW,aAAa,YAAY;AAClC,UAAI;AACF,cAAM,SAAS,MAAM,KAAK;AAAA,UACxB,UAAU;AAAA,UACV,UAAU;AAAA,UACV,UAAU;AAAA,UACV;AAAA,QACF;AACA,gBAAQ,KAAK,EAAE,UAAU,UAAU,UAAU,OAAO,CAAC;AAAA,MACvD,SAAS,OAAO;AACd,gBAAQ,KAAK;AAAA,UACX,UAAU,UAAU;AAAA,UACpB,QAAQ;AAAA,UACR,OAAO,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC;AAAA,QACjE,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB,UAAkB,OAAyB;AAC3D,UAAMA,QAAO,KAAK,QAAQ,QAAQ;AAElC,QAAI,CAACA,OAAM;AACT,aAAO;AAAA,IACT;AAEA,QAAI,CAACA,MAAK,QAAQ;AAChB,aAAO;AAAA,IACT;AAEA,QAAI;AACF,MAAAA,MAAK,OAAO,MAAM,KAAK;AACvB,aAAO;AAAA,IACT,SAAS,OAAO;AACd,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,UAKP;AACP,UAAMA,QAAO,KAAK,QAAQ,QAAQ;AAElC,QAAI,CAACA,OAAM;AACT,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,MACL,MAAMA,MAAK;AAAA,MACX,aAAaA,MAAK;AAAA,MAClB,WAAW,CAAC,CAACA,MAAK;AAAA,MAClB,kBAAkB,CAAC,CAACA,MAAK;AAAA,IAC3B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,uBAAuB,SAA8C;AACnE,SAAK,mBAAmB;AAAA,MACtB,GAAG,KAAK;AAAA,MACR,GAAG;AAAA,MACH,WAAW,oBAAI,KAAK;AAAA,IACtB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,sBAA4C;AAC1C,WAAO,EAAE,GAAG,KAAK,iBAAiB;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKA,aAAmB;AACjB,UAAM,YAAY,KAAK,aAAa;AAEpC,eAAW,YAAY,WAAW;AAChC,WAAK,eAAe,QAAQ;AAAA,IAC9B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,4BAAqD;AACnD,WAAO,KAAK,YAAY,EAAE,OAAO,CAACA,UAASA,MAAK,gBAAgB;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA,EAKQ,uBAAuBA,OAAmC;AAChE,QAAI,CAACA,MAAK,QAAQ,OAAOA,MAAK,SAAS,UAAU;AAC/C,YAAM,IAAI,MAAM,sCAAsC;AAAA,IACxD;AAEA,QAAIA,MAAK,UAAU,OAAOA,MAAK,OAAO,UAAU,YAAY;AAC1D,YAAM,IAAI,MAAM,wCAAwC;AAAA,IAC1D;AAAA,EACF;AACF;;;AC1UA,yBAA2B;AAG3B;AAKO,IAAM,uBAAN,MAA6E;AAAA,EAClF,YACU,WACA,aAAqB,GACrB,eACR;AAHQ;AACA;AACA;AAAA,EACP;AAAA;AAAA;AAAA;AAAA;AAAA,EAMH,MAAM,iBACJ,cACA,UACA,kBACA,sBACA,aACA,SACA,OACwD;AACxD,QAAI,aAAa;AAEjB,WAAO,cAAc,KAAK,YAAY;AACpC,UAAI;AAEF,cAAM,WAAW,SAAS,SAAS;AACnC,cAAM,YAAY,SAAS,SAAS,YAChC,KAAK,MAAM,SAAS,SAAS,SAAS,IACtC,CAAC;AAGL,YAAI,CAAC,UAAU;AACb,gBAAM,IAAI;AAAA,YACR,oDAAoD,KAAK,UAAU,QAAQ,CAAC;AAAA,UAC9E;AAAA,QACF;AAGA,YAAI,KAAK,eAAe;AACtB,cAAI;AACF,kBAAM,eAAe,MAAM,KAAK,cAAc;AAAA,cAC5C;AAAA,cACA;AAAA,cACA;AAAA,YACF;AAEA,oBAAQ,aAAa,QAAQ;AAAA,cAC3B,KAAK;AAEH;AAAA,cACF,KAAK;AAEH,qBAAK,UAAU,cAAc;AAAA,kBAC3B;AAAA,kBACA;AAAA,kBACA;AAAA,kBACA,UAAU,aAAa;AAAA,kBACvB,gBAAgB,QAAQ;AAAA,kBACxB,OAAO,QAAQ;AAAA,gBACjB,CAAQ;AACR,sBAAM,IAAI;AAAA,kBACR,yCAAyC,aAAa,QAAQ;AAAA,gBAChE;AAAA,cACF,KAAK;AAEH,sBAAM,IAAI;AAAA,kBACR,4BAA4B,aAAa,MAAM;AAAA,gBACjD;AAAA,cACF,KAAK;AAEH,uBAAO,OAAO,WAAW,aAAa,SAAS;AAC/C;AAAA,YACJ;AAAA,UACF,SAAS,OAAO;AACd,oBAAQ,MAAM,2CAA2C,KAAK;AAAA,UAEhE;AAAA,QACF;AAGA,cAAMC,QAAO,KAAK,UAAU,QAAQ,QAAQ;AAC5C,YAAI,CAACA,OAAM,QAAQ;AAKjB,gBAAM,kBAAuB;AAAA,YAC3B,MAAM;AAAA,YACN,cAAc,SAAS;AAAA,YACvB,SAAS,SAAS,QAAQ,8CAA8C,KAAK,UAAU,SAAS,CAAC;AAAA,UACnG;AACA,+BAAqB,KAAK,eAAe;AAGzC,sBAAY,KAAK;AAAA,YACf,QAAI,+BAAW;AAAA,YACf,MAAM;AAAA,YACN,SAAS,SAAS,QAAQ,8CAA8C,KAAK,UAAU,SAAS,CAAC;AAAA,YACjG,YAAY,SAAS;AAAA,YACrB,WAAW,oBAAI,KAAK;AAAA,UACtB,CAAC;AAKD,iBAAO,EAAE,SAAS,MAAM;AAAA,QAC1B;AAGA,cAAM,aAAa,MAAM,KAAK,UAAU;AAAA,UACtC;AAAA,UACA;AAAA,UACA;AAAA,YACE,gBAAgB,QAAQ;AAAA,YACxB,OAAO,QAAQ;AAAA,YACf,WAAW,oBAAI,KAAK;AAAA,YACpB;AAAA;AAAA,UACF;AAAA,UACA;AAAA,QACF;AAGA,cAAM,cAAc;AAGpB,aAAK,UAAU,cAAc;AAAA,UAC3B;AAAA,UACA,YAAY,SAAS;AAAA,UACrB,SAAS,KAAK,UAAU,WAAW;AAAA,QACrC,CAAQ;AAGR,cAAM,oBAAoB;AAAA,UACxB,MAAM;AAAA,UACN,cAAc,SAAS;AAAA,UACvB,SAAS,KAAK,UAAU,WAAW;AAAA,QACrC;AACA,6BAAqB,KAAK,iBAAiB;AAG3C,cAAM,cAAuB;AAAA,UAC3B,QAAI,+BAAW;AAAA,UACf,MAAM;AAAA,UACN,SAAS,KAAK,UAAU,WAAW;AAAA,UACnC,WAAW,oBAAI,KAAK;AAAA,UACpB,YAAY,SAAS;AAAA,UACrB,UAAU;AAAA,YACR,OAAO,KAAK,UAAU,KAAK;AAAA,YAC3B,gBAAgB,QAAQ;AAAA,YACxB,OAAO,QAAQ;AAAA,YACf,QAAQ,QAAQ;AAAA,UAClB;AAAA,QACF;AACA,oBAAY,KAAK,WAAW;AAG5B,eAAO,EAAE,SAAS,MAAM,eAAe,YAAY;AAAA,MACrD,SAAS,OAAO;AACd;AAGA,YAAI,KAAK,eAAe;AACtB,cAAI;AACF,kBAAM,gBAAgB,MAAM,KAAK,cAAc;AAAA,cAC7C;AAAA,cACA;AAAA,cACA;AAAA,YACF;AAEA,oBAAQ,cAAc,QAAQ;AAAA,cAC5B,KAAK;AAEH,oBAAI,cAAc,cAAc,aAAa;AAC3C,0BAAQ;AAAA,oBACN,6BAA6B,SAAS,SAAS,IAAI,eAAe,UAAU,IAAI,cAAc,WAAW;AAAA,oBACzG;AAAA,kBACF;AACA,wBAAM,IAAI;AAAA,oBAAQ,CAAC,YACjB,WAAW,SAAS,MAAO,UAAU;AAAA,kBACvC;AACA;AAAA,gBACF;AACA;AAAA,cACF,KAAK;AAIH;AAAA,cACF,KAAK;AAEH,qBAAK,UAAU,cAAc;AAAA,kBAC3B;AAAA,kBACA,UAAU,SAAS,SAAS;AAAA,kBAC5B,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,kBAC5D,QAAQ,cAAc;AAAA,kBACtB,gBAAgB,QAAQ;AAAA,kBACxB,OAAO,QAAQ;AAAA,gBACjB,CAAQ;AACR,sBAAM,IAAI;AAAA,kBACR,+BAA+B,cAAc,MAAM,KAAK,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AAAA,gBAChH;AAAA,cACF,KAAK;AAEH,sBAAM,IAAI;AAAA,kBACR,2BAA2B,cAAc,MAAM;AAAA,gBACjD;AAAA,YACJ;AAAA,UACF,SAAS,cAAc;AACrB,oBAAQ;AAAA,cACN;AAAA,cACA;AAAA,YACF;AAAA,UAEF;AAAA,QACF;AAEA,YAAI,aAAa,KAAK,YAAY;AAEhC,kBAAQ;AAAA,YACN,6BAA6B,SAAS,SAAS,IAAI,UAAU,KAAK,UAAU;AAAA,YAC5E;AAAA,UACF;AAEA,gBAAM,eAAe,UAAU,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC;AACrF,+BAAqB,KAAK;AAAA,YACxB,MAAM;AAAA,YACN,cAAc,SAAS;AAAA,YACvB,SAAS;AAAA,UACX,CAAC;AAED,sBAAY,KAAK;AAAA,YACf,QAAI,+BAAW;AAAA,YACf,MAAM;AAAA,YACN,SAAS;AAAA,YACT,WAAW,oBAAI,KAAK;AAAA,YACpB,YAAY,SAAS;AAAA,UACvB,CAAC;AAAA,QACH,OAAO;AAEL,kBAAQ;AAAA,YACN,6BAA6B,SAAS,SAAS,IAAI,eAAe,UAAU,IAAI,KAAK,UAAU;AAAA,YAC/F;AAAA,UACF;AAGA,gBAAM,IAAI;AAAA,YAAQ,CAAC,YACjB,WAAW,SAAS,MAAO,UAAU;AAAA,UACvC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGA,WAAO,EAAE,SAAS,MAAM;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKQ,UAAU,cAAmB,OAAkB;AACrD,QAAI,aAAa,MAAM;AAErB,mBAAa,KAAK,KAAK;AAAA,IACzB,WAAW,aAAa,MAAM;AAE5B,mBAAa,KAAK,MAAM,MAAM,KAAK;AAAA,IACrC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,UAAa,KAAW;AAC9B,QAAI,QAAQ,QAAQ,OAAO,QAAQ,UAAU;AAC3C,aAAO;AAAA,IACT;AAEA,QAAI,eAAe,MAAM;AACvB,aAAO,IAAI,KAAK,IAAI,QAAQ,CAAC;AAAA,IAC/B;AAEA,QAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,aAAO,IAAI,IAAI,UAAQ,KAAK,UAAU,IAAI,CAAC;AAAA,IAC7C;AAEA,QAAI,OAAO,QAAQ,UAAU;AAC3B,YAAM,SAAS,CAAC;AAChB,iBAAW,OAAO,KAAK;AACrB,YAAI,IAAI,eAAe,GAAG,GAAG;AAC3B,iBAAO,GAAG,IAAI,KAAK,UAAU,IAAI,GAAG,CAAC;AAAA,QACvC;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACF;;;ACjTA,IAAAC,sBAA2B;AAMpB,IAAM,iBAAN,MAAuE;AAAA;AAAA;AAAA;AAAA,EAI5E,uBACE,MACA,SACA,gBACA,OACA,SAMS;AACT,WAAO;AAAA,MACL,QAAI,gCAAW;AAAA,MACf;AAAA,MACA;AAAA,MACA,WAAW,oBAAI,KAAK;AAAA,MACpB,WAAW,SAAS;AAAA,MACpB,YAAY,SAAS;AAAA,MACrB,UAAU;AAAA,QACR,OAAO,KAAK,UAAU,KAAK;AAAA,QAC3B;AAAA,QACA,OAAO,SAAS;AAAA,QAChB,QAAQ,SAAS;AAAA,MACnB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,qBACE,mBACA,sBACO;AACP,UAAM,WAAkB;AAAA,MACtB,EAAE,MAAM,UAAU,SAAS,kBAAkB;AAAA,IAC/C;AAGA,eAAW,WAAW,sBAAsB;AAC1C,UAAI,QAAQ,SAAS,QAAQ;AAC3B,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,SAAS,QAAQ;AAAA,QACnB,CAAC;AAAA,MACH,WAAW,QAAQ,SAAS,aAAa;AACvC,cAAM,mBAAwB;AAAA,UAC5B,MAAM;AAAA,UACN,SAAS,QAAQ;AAAA,QACnB;AACA,YAAI,QAAQ,aAAa,QAAQ,UAAU,SAAS,GAAG;AACrD,2BAAiB,aAAa,QAAQ;AAAA,QACxC;AACA,iBAAS,KAAK,gBAAgB;AAAA,MAChC,WAAW,QAAQ,SAAS,QAAQ;AAClC,iBAAS,KAAK;AAAA,UACZ,MAAM;AAAA,UACN,cAAc,QAAQ;AAAA,UACtB,SAAS,QAAQ;AAAA,QACnB,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,yBAAyB,UAA6B;AACpD,UAAM,cAAc,SAAS,SAAS,SAAS,CAAC;AAChD,QAAI,aAAa,UAAU,OAAO;AAChC,aAAO,YAAY,SAAS;AAAA,IAC9B;AACA,WAAO,CAAC;AAAA,EACV;AAAA;AAAA;AAAA;AAAA,EAKQ,UAAa,KAAW;AAC9B,QAAI,QAAQ,QAAQ,OAAO,QAAQ,UAAU;AAC3C,aAAO;AAAA,IACT;AAEA,QAAI,eAAe,MAAM;AACvB,aAAO,IAAI,KAAK,IAAI,QAAQ,CAAC;AAAA,IAC/B;AAEA,QAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,aAAO,IAAI,IAAI,UAAQ,KAAK,UAAU,IAAI,CAAC;AAAA,IAC7C;AAEA,QAAI,OAAO,QAAQ,UAAU;AAC3B,YAAM,SAAS,CAAC;AAChB,iBAAW,OAAO,KAAK;AACrB,YAAI,IAAI,eAAe,GAAG,GAAG;AAC3B,iBAAO,GAAG,IAAI,KAAK,UAAU,IAAI,GAAG,CAAC;AAAA,QACvC;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACF;;;ACpHA,IAAAC,sBAA2B;AAW3B;AAGA,IAAAC,aAAkB;AAMX,IAAM,gBAAN,MAGL;AAAA,EACA,YACU,QACA,eACA,sBACA,gBACA,kBACA,aAKA,WACR;AAXQ;AACA;AACA;AACA;AACA;AACA;AAKA;AAAA,EACP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUH,MAAM,QACJ,cACA,SACA,SACA,eAAwB,MACc;AACtC,UAAM,YAAY,KAAK,IAAI;AAC3B,UAAM,gBAAgB,KAAK,OAAO,aAAa;AAC/C,QAAI,YAAY;AAEhB,QAAI;AAEF,WAAK,UAAU,cAAc;AAAA,QAC3B;AAAA,QACA,UAAU;AAAA,MACZ,CAAC;AAED,YAAM,oBAAoB,MAAM,KAAK,qBAAqB,OAAO;AACjE,UAAI,uBAAuB,KAAK,eAAe;AAAA,QAC7C;AAAA,QACA,QAAQ;AAAA,MACV;AAEA,WAAK,UAAU,cAAc;AAAA,QAC3B;AAAA,QACA,UAAU;AAAA,MACZ,CAAC;AAGD,YAAM,aAAa,MAAM,KAAK;AAAA,QAC5B;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,UAAI,WAAW,aAAa;AAC1B,eAAO,eAAe,WAAW,SAAS;AAAA,MAC5C;AAGA,YAAM,aAAa,MAAM,KAAK,gBAAgB,WAAW,aAAa;AAGtE,YAAM,gBAAgB,KAAK,IAAI,IAAI;AACnC,YAAM,SAAS,KAAK;AAAA,QAClB;AAAA,QACA,WAAW;AAAA,QACX;AAAA,QACA;AAAA,QACA,WAAW;AAAA,MACb;AAGA,UAAI,CAAC,cAAc;AACjB,aAAK,UAAU,cAAc;AAAA,UAC3B;AAAA,UACA,UAAU,QAAQ;AAAA,UAClB,OAAO,QAAQ;AAAA,UACf;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAEA,aAAO,eAAe,SAAS;AAAA,IACjC,SAAS,OAAO;AACd,YAAM,gBAAgB,KAAK,IAAI,IAAI;AACnC,WAAK,eAAe,cAAc,SAAS,OAAO,aAAa;AAC/D,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBACZ,cACA,SACA,sBACA,SACA,eACA,WACA,WAOC;AACD,QAAI,gBAAgB;AACpB,QAAI,cAAyB,CAAC;AAC9B,QAAI,kBAAuB;AAC3B,UAAM,gBAAgB,KAAK,OAAO,aAAa;AAE/C,WAAO,kBAAkB,UAAa,YAAY,eAAe;AAC/D;AAGA,UAAI,SAAS,QAAQ,SAAS;AAC5B,cAAM,IAAI;AAAA,UACR,gBAAgB,QAAQ,OAAO,UAAU,yBAAyB;AAAA,QACpE;AAAA,MACF;AAGA,YAAM,gBAAgB,MAAM,KAAK;AAAA,QAC/B;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,UAAI,eAAe;AACjB,eAAO;AAAA,UACL;AAAA,UACA;AAAA,UACA;AAAA,UACA,aAAa;AAAA,UACb,QAAQ;AAAA,QACV;AAAA,MACF;AAGA,WAAK,UAAU,cAAc;AAAA,QAC3B;AAAA,QACA,UAAU,wBAAwB,SAAS;AAAA,MAC7C,CAAC;AAED,YAAM,kBAAkB,MAAM,KAAK;AAAA,QACjC;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,wBAAkB,KAAK;AAAA,QACrB;AAAA,QACA,gBAAgB;AAAA,MAClB;AAEA,WAAK,UAAU,cAAc;AAAA,QAC3B;AAAA,QACA,UAAU,wBAAwB,SAAS;AAAA,MAC7C,CAAC;AAGD,UAAI,gBAAgB,QAAQ;AAC1B,wBAAgB,gBAAgB;AAChC;AAAA,MACF;AAGA,UAAI,CAAC,gBAAgB,iBAAiB;AACpC;AAAA,MACF;AAAA,IACF;AAGA,QAAI,kBAAkB,UAAa,aAAa,eAAe;AAC7D,cAAQ;AAAA,QACN,wDAA8C,aAAa;AAAA,MAC7D;AACA,sBACE,iBACA;AAAA,IACJ;AAEA,WAAO,EAAE,eAAe,aAAa,gBAAgB;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,uBACZ,cACA,SACA,sBACA,SACA,aAMC;AAGD,UAAM,cAAc,MAAM,KAAK;AAAA,MAC7B;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAGA,UAAM,eAAe,MAAM,KAAK;AAAA,MAC9B;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAGA,UAAM,mBAAmB,MAAM,KAAK;AAAA,MAClC,aAAa;AAAA,MACb,aAAa;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAGA,QAAI,aAAa,UAAU,WAAW,GAAG;AACvC,aAAO;AAAA,QACL,SAAS,aAAa;AAAA,QACtB,QAAQ;AAAA,QACR,iBAAiB;AAAA,QACjB,YAAY,aAAa;AAAA,MAC3B;AAAA,IACF;AAGA,UAAM,kBAAkB,MAAM,KAAK;AAAA,MACjC,aAAa;AAAA,MACb;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAEA,WAAO;AAAA,MACL,SAAS,aAAa;AAAA,MACtB,QAAQ;AAAA,MACR;AAAA,MACA,YAAY,aAAa;AAAA,IAC3B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,yBACZ,aACA,cAKC;AACD,QAAI;AACJ,QAAI,UAAU;AACd,QAAI,YAAmB,CAAC;AACxB,QAAI,aAAkB;AAEtB,qBAAiB,SAAS,aAAa;AACrC,YAAM,SAAS,MAAM,UAAU,CAAC;AAChC,UAAI,CAAC,OAAQ;AAGb,UAAI,OAAO,OAAO,QAAQ,CAAC,WAAW;AACpC,wBAAY,gCAAW;AACvB,aAAK,UAAU,cAAc;AAAA,UAC3B;AAAA,UACA;AAAA,UACA,MAAM;AAAA,QACR,CAAC;AAAA,MACH;AAGA,UAAI,OAAO,OAAO,SAAS;AACzB,mBAAW,OAAO,MAAM;AACxB,aAAK,UAAU,cAAc;AAAA,UAC3B;AAAA,UACA;AAAA,UACA,OAAO,OAAO,MAAM;AAAA,QACtB,CAAC;AAAA,MACH;AAGA,UAAI,OAAO,OAAO,YAAY;AAC5B,aAAK;AAAA,UACH,OAAO,MAAM;AAAA,UACb;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAGA,UAAI,MAAM,OAAO;AACf,qBAAa,KAAK,qBAAqB,YAAY,MAAM,KAAK;AAAA,MAChE;AAAA,IACF;AAGA,QAAI,WAAW;AACb,WAAK,UAAU,cAAc;AAAA,QAC3B;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAGA,QAAI,UAAU,SAAS,GAAG;AACxB,iBAAW,YAAY,WAAW;AAChC,aAAK,UAAU,cAAc;AAAA,UAC3B;AAAA,UACA,YAAY,SAAS;AAAA,QACvB,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO,EAAE,SAAS,WAAW,WAAW;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKQ,sBACN,gBACA,WACA,cACM;AACN,eAAW,iBAAiB,gBAAgB;AAC1C,UAAI,gBAAgB,cAAc;AAClC,UAAI,kBAAkB,UAAa,gBAAgB,GAAG;AACpD,wBAAgB,UAAU;AAAA,MAC5B;AAEA,UAAI,CAAC,UAAU,aAAa,GAAG;AAC7B,kBAAU,aAAa,IAAI;AAAA,UACzB,IAAI,cAAc,UAAM,gCAAW;AAAA,UACnC,MAAM,cAAc,QAAQ;AAAA,UAC5B,UAAU;AAAA,YACR,MAAM;AAAA,YACN,WAAW;AAAA,UACb;AAAA,QACF;AAEA,aAAK,UAAU,cAAc;AAAA,UAC3B;AAAA,UACA,YAAY,UAAU,aAAa,EAAE;AAAA,UACrC,cAAc,cAAc,UAAU,QAAQ;AAAA,QAChD,CAAC;AAAA,MACH,OAAO;AACL,YACE,cAAc,MACd,UAAU,aAAa,EAAE,OAAO,cAAc,IAC9C;AACA,oBAAU,aAAa,EAAE,KAAK,cAAc;AAAA,QAC9C;AAAA,MACF;AAEA,UAAI,cAAc,UAAU,MAAM;AAChC,kBAAU,aAAa,EAAE,SAAS,OAAO,cAAc,SAAS;AAAA,MAClE;AAEA,UAAI,cAAc,UAAU,WAAW;AACrC,kBAAU,aAAa,EAAE,SAAS,aAChC,cAAc,SAAS;AAEzB,aAAK,UAAU,cAAc;AAAA,UAC3B;AAAA,UACA,YAAY,UAAU,aAAa,EAAE;AAAA,UACrC,OAAO,cAAc,SAAS;AAAA,QAChC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,qBACZ,SACA,WACA,SACA,aACA,sBACkB;AAClB,UAAM,mBAAmB,KAAK,eAAe;AAAA,MAC3C;AAAA,MACA;AAAA,MACA,QAAQ;AAAA,MACR,KAAK,iBAAiB;AAAA,MACtB;AAAA,QACE,OAAO,QAAQ;AAAA,QACf,QAAQ,QAAQ;AAAA,MAClB;AAAA,IACF;AAEA,QAAI,UAAU,SAAS,GAAG;AACxB,uBAAiB,YAAY,UAAU,IAAI,CAAC,QAAa;AAAA,QACvD,IAAI,GAAG;AAAA,QACP,MAAM,GAAG;AAAA,QACT,UAAU;AAAA,UACR,MAAM,GAAG,SAAS;AAAA,UAClB,WAAW,GAAG,SAAS;AAAA,QACzB;AAAA,MACF,EAAE;AAAA,IACJ;AAEA,gBAAY,KAAK,gBAAgB;AAEjC,UAAM,KAAK;AAAA,MACT,QAAQ;AAAA,MACR,CAAC,gBAAgB;AAAA,MACjB,KAAK,iBAAiB;AAAA,IACxB;AAGA,UAAM,+BAAoC;AAAA,MACxC,MAAM;AAAA,MACN,SAAS,WAAW;AAAA,IACtB;AACA,QAAI,UAAU,SAAS,GAAG;AACxB,mCAA6B,aAAa;AAAA,IAC5C;AACA,yBAAqB,KAAK,4BAA4B;AAEtD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBACZ,WACA,cACA,SACA,sBACA,aACA,kBACkB;AAClB,QAAI,kBAAkB;AAEtB,eAAW,YAAY,WAAW;AAChC,YAAM,SAAS,MAAM,KAAK,qBAAqB;AAAA,QAC7C;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,KAAK,iBAAiB;AAAA,MACxB;AAEA,UAAI,OAAO,eAAe;AACxB,cAAM,KAAK;AAAA,UACT,QAAQ;AAAA,UACR,CAAC,OAAO,aAAa;AAAA,UACrB,KAAK,iBAAiB;AAAA,QACxB;AAGA,YAAI,KAAK,aAAa,OAAO,cAAc,UAAU,OAAO;AAC1D,gBAAM,eAAe,OAAO,cAAc,SAAS;AACnD,eAAK,UAAU,YAAY;AAAA,QAC7B;AAAA,MACF;AAEA,UAAI,CAAC,OAAO,SAAS;AACnB,0BAAkB;AAAA,MACpB;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBACZ,eACA,SACA,cACA,WACA,aACA,iBACsC;AACtC,QAAI,CAAC,cAAe,QAAO;AAE3B,QAAI;AAEF,YAAM,oBAAoB,YACvB,OAAO,CAAC,MAAM,EAAE,SAAS,MAAM,EAC/B,IAAI,GAAG,WAAW;AAGrB,YAAM,QAAQ,KAAK,iBAAiB;AACpC,YAAM,cAAe,OAAe,gBAAgB;AAEpD,YAAM,kBAAkB,MAAM,cAAc;AAAA,QAC1C;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAIA,UAAI,KAAK,WAAW;AAClB,aAAK,UAAU,KAAK;AAAA,MACtB;AAEA,cAAQ,gBAAgB,QAAQ;AAAA,QAC9B,KAAK;AACH,iBAAO;AAAA,QAET,KAAK;AACH,eAAK,UAAU,cAAc;AAAA,YAC3B;AAAA,YACA,QAAQ,gBAAgB;AAAA,YACxB,gBAAgB,QAAQ;AAAA,YACxB,OAAO,QAAQ;AAAA,UACjB,CAAC;AACD,gBAAM,IAAI,MAAM,qBAAqB,gBAAgB,MAAM,EAAE;AAAA,QAE/D,KAAK;AACH,iBAAO,KAAK;AAAA,YACV,gBAAgB;AAAA,YAChB;AAAA,YACA;AAAA,YACA,KAAK,IAAI,IAAI;AAAA,YACb;AAAA,UACF;AAAA,QAEF,KAAK;AACH,eAAK,UAAU,cAAc;AAAA,YAC3B;AAAA,YACA,UAAU,QAAQ;AAAA,YAClB,OAAO,QAAQ;AAAA,YACf,SAAS;AAAA,YACT,WAAW;AAAA,cACT,QAAI,gCAAW;AAAA,cACf,QAAQ,gBAAgB;AAAA,cACxB,SAAS,gBAAgB;AAAA,YAC3B;AAAA,UACF,CAAC;AACD,iBAAO;AAAA,YACL,SAAS;AAAA,YACT,MAAM;AAAA,YACN,UAAU;AAAA,YACV,UAAU;AAAA,cACR,gBAAgB,QAAQ;AAAA,cACxB,OAAO,QAAQ;AAAA,cACf,eAAe,KAAK,IAAI,IAAI;AAAA,cAC5B,YAAY,KAAK,gBAAgB,eAAe;AAAA,cAChD,SAAS;AAAA,cACT,WAAW;AAAA,gBACT,QAAQ,gBAAgB;AAAA,gBACxB,SAAS,gBAAgB;AAAA,cAC3B;AAAA,YACF;AAAA,UACF;AAAA,QAEF,KAAK;AACH,eAAK,UAAU,cAAc;AAAA,YAC3B;AAAA,YACA,QAAQ,gBAAgB;AAAA,YACxB,SAAS,gBAAgB;AAAA,YACzB,gBAAgB,QAAQ;AAAA,YACxB,OAAO,QAAQ;AAAA,UACjB,CAAC;AACD,gBAAM,IAAI;AAAA,YACR,0BAA0B,gBAAgB,MAAM;AAAA,UAClD;AAAA,MACJ;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,sCAAsC,KAAK;AAAA,IAE3D;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,qBACZ,SACiB;AACjB,QAAI,OAAO,KAAK,OAAO,iBAAiB,YAAY;AAClD,aAAO,MAAM,KAAK,OAAO,aAAa,KAAK,iBAAiB,GAAG,OAAO;AAAA,IACxE;AACA,WACE,GAAG,KAAK,OAAO,YAAY,4BAA4B,KAAK,OAAO,QAAQ,SAAS,KAAK,KAAK,OAAO,cAAc,sBAAsB,KAAK,OAAO,WAAW,OAAO,EAAE,OACzK;AAAA,EAEJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,gBAAgB,eAAyC;AACrE,QACE,KAAK,OAAO,cACZ,OAAO,KAAK,OAAO,eAAe,YAClC,YAAY,KAAK,OAAO,YACxB;AACA,YAAM,YAAY,KAAK,OAAO,WAAW;AACzC,UAAI,WAAW;AACb,YAAI;AACF,gBAAM,eAAe,KAAK,MAAM,aAAa;AAC7C,gBAAM,kBAAkB,UAAU,MAAM,YAAY;AACpD,iBAAO;AAAA,QACT,SAAS,OAAO;AACd,kBAAQ,MAAM,6BAA6B,KAAK;AAChD,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,YACN,YACA,aACA,SACA,eACA,iBACsB;AACtB,WAAO;AAAA,MACL,SAAS;AAAA,MACT,MAAM;AAAA,MACN,UAAU;AAAA,MACV,UAAU;AAAA,QACR,gBAAgB,QAAQ;AAAA,QACxB,OAAO,QAAQ;AAAA,QACf;AAAA,QACA,YAAY,KAAK,gBAAgB,eAAe;AAAA,MAClD;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,gBAAgB,iBAItB;AACA,WAAO,kBACH;AAAA,MACE,cAAc,gBAAgB,iBAAiB;AAAA,MAC/C,kBAAkB,gBAAgB,qBAAqB;AAAA,MACvD,aAAa,gBAAgB,gBAAgB;AAAA,IAC/C,IACA;AAAA,MACE,cAAc;AAAA,MACd,kBAAkB;AAAA,MAClB,aAAa;AAAA,IACf;AAAA,EACN;AAAA;AAAA;AAAA;AAAA,EAKQ,qBACN,cACA,UACK;AACL,QAAI,CAAC,SAAU,QAAO;AAEtB,QAAI,CAAC,cAAc;AACjB,aAAO,EAAE,GAAG,SAAS;AAAA,IACvB;AAEA,WAAO;AAAA,MACL,gBACG,aAAa,iBAAiB,MAAM,SAAS,iBAAiB;AAAA,MACjE,oBACG,aAAa,qBAAqB,MAClC,SAAS,qBAAqB;AAAA,MACjC,eACG,aAAa,gBAAgB,MAAM,SAAS,gBAAgB;AAAA,IACjE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,QACZ,UACA,SACA,SACA,SAAkB,OACJ;AACd,QAAI,CAAC,KAAK,eAAe,MAAM;AAC7B,YAAM,IAAI,MAAM,8DAA8D;AAAA,IAChF;AAGA,UAAM,YAAY,KAAK,aAAa,OAAO;AAG3C,UAAM,kBAAkB,KAAK,uBAAuB,OAAO;AAG3D,UAAM,gBAAqB;AAAA,MACzB,OAAO;AAAA,MACP;AAAA,MACA,aACE,SAAS,eAAe,KAAK,OAAO,eAAe,eAAe;AAAA,MACpE,YACE,SAAS,aAAa,KAAK,OAAO,eAAe,aAAa;AAAA,MAChE;AAAA,IACF;AAEA,QAAI,mBAAmB,gBAAgB,SAAS,GAAG;AACjD,oBAAc,QAAQ;AACtB,oBAAc,cAAc;AAAA,IAC9B;AAGA,QAAI,SAAS,QAAQ;AACnB,oBAAc,SAAS,QAAQ;AAAA,IACjC;AAEA,WAAO,KAAK,cAAc,KAAK,YAAY,OAAO,aAAa;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA,EAKQ,aAAa,SAAsC;AACzD,QAAI,SAAS,OAAO;AAClB,aAAO,QAAQ;AAAA,IACjB;AACA,QAAI,OAAO,KAAK,OAAO,UAAU,UAAU;AACzC,aAAO,KAAK,OAAO;AAAA,IACrB;AACA,WAAQ,KAAK,cAAsB,gBAAgB;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA,EAKQ,uBAAuB,SAAiD;AAC9E,UAAM,cAAc,KAAK,OAAO,SAAS,CAAC;AAC1C,UAAM,eAAe,SAAS,SAAS,CAAC;AAExC,QAAI,CAAC,YAAY,UAAU,CAAC,aAAa,OAAQ,QAAO;AAGxD,UAAM,SAAS,oBAAI,IAAiB;AACpC,eAAW,KAAK,YAAa,QAAO,IAAI,EAAE,MAAM,CAAC;AACjD,eAAW,KAAK,aAAc,QAAO,IAAI,EAAE,MAAM,CAAC;AAClD,UAAM,cAAc,MAAM,KAAK,OAAO,OAAO,CAAC;AAE9C,WAAO,YAAY,IAAI,CAACC,UAAS;AAC/B,YAAM,cACJ,CAAC,CAACA,MAAK,UACP,OAAQA,MAAK,OAAe,cAAc;AAE5C,UAAI;AACJ,UAAI,aAAa;AACf,YAAI;AACF,uBAAa,aAAE,aAAaA,MAAK,MAAa;AAAA,QAChD,SAAS,OAAO;AACd,uBAAaA,MAAK;AAAA,QACpB;AAAA,MACF,OAAO;AACL,qBAAaA,MAAK;AAAA,MACpB;AAEA,aAAO;AAAA,QACL,MAAM;AAAA,QACN,UAAU;AAAA,UACR,MAAMA,MAAK;AAAA,UACX,aAAaA,MAAK;AAAA,UAClB;AAAA,QACF;AAAA,MACF;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKQ,UAAU,cAAmB,OAAkB;AACrD,QAAI,aAAa,MAAM;AACrB,mBAAa,KAAK,KAAK;AAAA,IACzB,OAAO;AACL,mBAAa,KAAK,MAAM,MAAM,KAAK;AAAA,IACrC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,eACN,cACA,SACA,OACA,eACM;AACN,SAAK,UAAU,cAAc;AAAA,MAC3B;AAAA,MACA,UAAU,QAAQ;AAAA,MAClB,OAAO,QAAQ;AAAA,MACf,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAC9D,MAAM,iBAAiB,QAAQ,MAAM,OAAO;AAAA,MAC5C,SAAS;AAAA,IACX,CAAC;AAAA,EACH;AACF;;;AC71BA,sBAAyD;AAsBlD,IAAM,oBAAN,MAA8C;AAAA;AAAA;AAAA;AAAA;AAAA,EAQnD,YAAY,eAAiC,cAAc;AACzD,SAAK,eAAW,8BAAa,YAAY;AAAA,EAC3C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,MAA2B;AAChC,WAAO,KAAK,SAAS,OAAO,IAAI;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,OAAO,QAA6B;AAClC,UAAM,UAAU,KAAK,SAAS,OAAO,MAAM;AAC3C,WAAO,OAAO,YAAY,WACtB,UACA,IAAI,YAAY,EAAE,OAAO,OAAO;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY,MAAsB;AAChC,WAAO,KAAK,SAAS,OAAO,IAAI,EAAE;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKA,OAAa;AACX,SAAK,SAAS,KAAK;AAAA,EACrB;AACF;AAuDO,IAAM,eAAN,MAAmB;AAAA;AAAA;AAAA;AAAA;AAAA,EAQxB,YAAY,WAAwB;AAClC,SAAK,YAAY,aAAa,IAAI,kBAAkB;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,mBAAmB,SAAoD;AAErE,UAAM,aAAa,KAAK,UAAU,YAAY,QAAQ,IAAI;AAC1D,UAAM,gBAAgB,KAAK,UAAU,YAAY,QAAQ,OAAO;AAEhE,WAAO,aAAa,gBAAgB;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,aACE,QACA,WACA,WAA4C,gBACvC;AACL,QAAI,aAAa,GAAG;AAClB,aAAO,CAAC;AAAA,IACV;AAEA,UAAM,kBACJ,aAAa,iBAAiB,CAAC,GAAG,MAAM,EAAE,QAAQ,IAAI,CAAC,GAAG,MAAM;AAElE,UAAM,SAAc,CAAC;AACrB,QAAI,cAAc;AAElB,eAAW,SAAS,iBAAiB;AACnC,YAAM,gBAAgB,KAAK,mBAAmB,MAAM,OAAO;AAE3D,UAAI,cAAc,iBAAiB,WAAW;AAC5C,eAAO,KAAK,KAAK;AACjB,uBAAe;AAAA,MACjB,OAAO;AAEL,YAAI,OAAO,WAAW,KAAK,gBAAgB,WAAW;AAEpD,gBAAM,iBAAiB,KAAK,gBAAgB,OAAO,SAAS;AAC5D,cAAI,gBAAgB;AAClB,mBAAO,KAAK,cAAc;AAAA,UAC5B;AAAA,QACF;AACA;AAAA,MACF;AAAA,IACF;AAGA,WAAO,aAAa,iBAAiB,OAAO,QAAQ,IAAI;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,gBAEN,OAAU,WAA6B;AACvC,UAAM,aAAa,KAAK,UAAU,YAAY,MAAM,QAAQ,IAAI;AAChE,UAAM,kBAAkB,YAAY,aAAa;AAEjD,QAAI,mBAAmB,GAAG;AACxB,aAAO;AAAA,IACT;AAGA,QAAI,OAAO;AACX,QAAI,QAAQ,MAAM,QAAQ,QAAQ;AAClC,QAAI,aAAa;AAEjB,WAAO,QAAQ,OAAO;AACpB,YAAM,MAAM,KAAK,OAAO,OAAO,SAAS,CAAC;AACzC,YAAM,mBAAmB,MAAM,QAAQ,QAAQ,UAAU,GAAG,GAAG;AAC/D,YAAM,gBAAgB,KAAK,UAAU,YAAY,gBAAgB;AAEjE,UAAI,iBAAiB,iBAAiB;AACpC,qBAAa;AACb,eAAO,MAAM;AAAA,MACf,OAAO;AACL,gBAAQ,MAAM;AAAA,MAChB;AAAA,IACF;AAEA,QAAI,eAAe,GAAG;AACpB,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,MACL,GAAG;AAAA,MACH,SAAS;AAAA,QACP,GAAG,MAAM;AAAA,QACT,SAAS,MAAM,QAAQ,QAAQ,UAAU,GAAG,UAAU,IAAI;AAAA,MAC5D;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,OAAa;AACX,QAAI,KAAK,qBAAqB,mBAAmB;AAC/C,WAAK,UAAU,KAAK;AAAA,IACtB;AAAA,EACF;AACF;;;AClGO,IAAe,aAAf,MAA0B;AAAA,EAS/B,YAAY,QAA6B;AAJzC;AAAA,SAAU,kBAAkB;AAC5B,SAAU,qBAAqB;AAC/B,SAAU,qBAAqB;AAG7B,SAAK,eAAe,IAAI;AAAA,MACtB,QAAQ,aAAa,IAAI,kBAAkB;AAAA,IAC7C;AAEA,QAAI,QAAQ,YAAY;AACtB,WAAK,aAAa;AAAA,QAChB,iBAAiB,OAAO,WAAW,mBAAmB;AAAA,QACtD,mBAAmB,OAAO,WAAW,qBAAqB;AAAA,QAC1D,sBAAsB,OAAO,WAAW,wBAAwB;AAAA,QAChE,cAAc,OAAO,WAAW,gBAAgB;AAAA,MAClD;AAAA,IACF;AAEA,QAAI,QAAQ,YAAY;AACtB,WAAK,aAAa,OAAO;AAAA,IAC3B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0BA,MAAa,QACX,MACA,SACe;AACf,eAAW,SAAS,MAAM;AACxB,YAAM,KAAK,IAAI,OAAO,OAAO;AAAA,IAC/B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0BO,QAAuB;AAC5B,UAAM,IAAI,MAAM,+BAA+B;AAAA,EACjD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWO,OAAO,YAAoB,aAAuC;AACvE,UAAM,IAAI,MAAM,gCAAgC;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBO,SACL,QACA,SACe;AACf,UAAM,IAAI,MAAM,kCAAkC;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,eAAsC;AAC3C,UAAM,IAAI,MAAM,sCAAsC;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQO,aAAa,YAAmC;AACrD,UAAM,IAAI,MAAM,sCAAsC;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,gBAAgB,cAAwC;AAC7D,UAAM,IAAI,MAAM,yCAAyC;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASO,YAAY,OAA8B;AAC/C,WAAO,MAAM,OAAO,mBAAmB;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,gBAAgB,OAAmC;AACxD,QAAI,CAAC,KAAK,YAAY,KAAK,GAAG;AAC5B,aAAO;AAAA,IACT;AAEA,UAAM,EAAE,gBAAgB,GAAG,SAAS,IAAI,MAAM;AAE9C,WAAO;AAAA,MACL,SAAS;AAAA,QACP,GAAG,MAAM;AAAA,QACT,SAAS,eAAe;AAAA,MAC1B;AAAA,MACA,OAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,iBAAiB,QAAwC;AAC9D,WAAO,OAAO,IAAI,CAAC,MAAM,KAAK,gBAAgB,CAAC,CAAC;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAgB,cAAc;AAAA,IAC5B;AAAA,IACA;AAAA,EACF,GAGwC;AACtC,QAAI,CAAC,KAAK,YAAY;AACpB,aAAO,EAAE,OAAO;AAAA,IAClB;AACA,UAAM,gBAAgB,MAAM,KAAK,qBAAqB,MAAM;AAE5D,UAAM,sBACJ,KAAK,WAAY,kBAAkB,KAAK,WAAY;AACtD,UAAM,yBACJ,KAAK,WAAY,kBAAkB,KAAK,WAAY;AAEtD,QACE,KAAK,YAAY,gBACjB,OAAO,SAAS,KAAK,YAAY,cACjC;AACA,UAAI,iBAAiB,wBAAwB;AAC3C,cAAM,EAAE,QAAQ,gBAAgB,IAAI,MAAM,KAAK,qBAAqB,EAAE,WAAW,OAAO,CAAC;AACzF,eAAO,EAAE,QAAQ,gBAAgB;AAAA,MACnC;AAGA,UAAI,iBAAiB,qBAAqB;AACxC,cAAM,EAAE,QAAQ,iBAAiB,MAAM,mBAAmB,IAAI,MAAM,KAAK,kBAAkB;AAAA,UACzF;AAAA,UACA;AAAA,QACF,CAAC;AAED,YAAI,qBAAqB,KAAK,WAAY,kBAAkB,MAAM;AAChE,iBAAO,EAAE,QAAQ,gBAAgB;AAAA,QACnC;AAEA,cAAM,EAAE,QAAQ,gBAAgB,IAAI,MAAM,KAAK,qBAAqB,EAAE,WAAW,OAAO,CAAC;AACzF,eAAO,EAAE,QAAQ,gBAAgB;AAAA,MACnC;AAAA,IACF;AAEA,WAAO,EAAE,OAAO;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAgB,kBAAkB;AAAA,IAChC;AAAA,IACA;AAAA,EACF,GAGsD;AACpD,UAAM,eAAe,MAAM,KAAK,qBAAqB,MAAM;AAG3D,UAAM,cAAc,OAAO;AAC3B,UAAM,eAAe,KAAK,WAAY;AACtC,UAAM,QAAQ,cAAc;AAE5B,QAAI,SAAS,GAAG;AACd,aAAO,EAAE,QAAQ,MAAM,EAAE;AAAA,IAC3B;AAGA,UAAM,kBAAkB,MAAM,QAAQ,IAAI,OAAO,IAAI,OAAO,OAAO,MAAM;AACvE,UAAI,IAAI,OAAO;AACb,YAAI,CAAC,KAAK,YAAY,KAAK,GAAG;AAC5B,iBAAO,KAAK,aAAa,EAAE,WAAW,MAAM,CAAC;AAAA,QAC/C;AAAA,MACF;AACA,aAAO;AAAA,IACT,CAAC,CAAC;AAEF,UAAM,cAAc,MAAM,KAAK,qBAAqB,eAAe;AACnE,UAAM,OAAO,eAAe;AAE5B,SAAK;AACL,SAAK,qBAAqB;AAE1B,WAAO,EAAE,QAAQ,iBAAiB,KAAK;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAgB,aAAa;AAAA,IAC3B;AAAA,IACA;AAAA,EACF,GAG0B;AACxB,QAAI,CAAC,KAAK,cAAc;AACtB,aAAO;AAAA,IACT;AAGA,UAAM,iBAAiB,MAAM,KAAK,aAAa;AAAA,MAC7C,MAAM;AAAA,IACR;AAGA,UAAM,qBAAyC;AAAA,MAC7C,iBAAiB,MAAM,QAAQ;AAAA,MAC/B;AAAA,MACA,iBAAiB;AAAA,IACnB;AAGA,UAAM,iBAAiB,eAAe,MAAM,QAAQ,IAAI,aAAa,cAAc;AACnF,UAAM,QAAQ,UAAU;AAGxB,UAAM,QAAQ;AAAA,MACZ,GAAG,MAAM;AAAA,MACT,gBAAgB;AAAA,IAClB;AAGA,uBAAmB,kBACjB,MAAM,KAAK,aAAa,mBAAmB,MAAM,OAAO;AAE1D,UAAM,KAAK,OAAO,EAAE,WAAW,MAAM,CAAC;AACtC,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAgB,qBAAqB;AAAA,IACnC;AAAA,IACA;AAAA,EACF,GAGqE;AACnE,UAAM,eAAe,KAAK,WAAY;AAEtC,QAAI,OAAO,UAAU,cAAc;AACjC,aAAO,EAAE,OAAO;AAAA,IAClB;AAGA,UAAM,oBAAoB,OAAO,MAAM,GAAG,CAAC,YAAY;AAGvD,UAAM,qBAAqB,KAAK,iBAAiB,iBAAiB;AAGlE,UAAM,UAAU,MAAM,KAAK,WAAW,kBAAkB;AAGxD,UAAM,KAAK,aAAa,EAAE,WAAW,QAAQ,CAAC;AAG9C,UAAM,KAAK,sBAAsB,EAAE,WAAW,aAAa,CAAC;AAE5D,SAAK;AAEL,WAAO,EAAE,QAAQ,OAAO,MAAM,CAAC,YAAY,GAAG,QAAQ;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAgB,aAAa,QAGX;AAAA,EAElB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAgB,sBAAsB,QAGpB;AAAA,EAElB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAgB,qBACd,QACiB;AACjB,QAAI,CAAC,KAAK,cAAc;AACtB,aAAO;AAAA,IACT;AAEA,QAAI,QAAQ;AAEZ,eAAW,SAAS,QAAQ;AAC1B,UAAI,KAAK,YAAY,KAAK,GAAG;AAC3B,cAAM,iBAAiB,MAAM,MAAM;AACnC,iBAAS,eAAe;AAAA,MAC1B,OAAO;AACL,iBAAS,MAAM,KAAK,aAAa,mBAAmB,MAAM,OAAO;AAAA,MACnE;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,WAAW,QAAoD;AAC1E,WAAO;AAAA,MACL,SAAS;AAAA,MACT,OAAO,OAAO;AAAA,MACd,WAAW;AAAA,QACT,OAAO,OAAO,CAAC,GAAG,QAAQ;AAAA,QAC1B,KAAK,OAAO,OAAO,SAAS,CAAC,GAAG,QAAQ;AAAA,MAC1C;AAAA,MACA,WAAW,oBAAI,KAAK;AAAA,IACtB;AAAA,EACF;AACF;;;ACxjBO,IAAM,oBAAN,MAAsD;AAAA,EAM3D,cAAc;AAEZ,UAAM,EAAE,iBAAAC,iBAAgB,IAAI;AAC5B,SAAK,UAAU,IAAIA,iBAAgB;AACnC,SAAK,mBAAmB,CAAC;AACzB,SAAK,oBAAoB,CAAC;AAC1B,SAAK,kBAAkB,CAAC;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAsD;AACpD,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,uBAAoE;AAClE,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAgE;AAC9D,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,aAA+B;AAC7B,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,cAAmB;AACjB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,WAAiB;AACf,SAAK,iBAAiB,SAAS;AAC/B,SAAK,kBAAkB,SAAS;AAChC,SAAK,gBAAgB,SAAS;AAAA,EAChC;AACF;AAOO,IAAM,oBAAN,MAAwB;AAAA;AAAA;AAAA;AAAA,EAI7B,WACE,OACA,WACA,YACkB;AAClB,WAAO;AAAA,MACL;AAAA,MACA,WAAW,MAAM,QAAQ;AAAA,MACzB;AAAA,MACA,MAAM,MAAM,QAAQ;AAAA,MACpB,SAAS,MAAM,QAAQ;AAAA,MACvB,WAAW,MAAM,QAAQ;AAAA,MACzB,YAAY,MAAM,QAAQ;AAAA,MAC1B,OAAO,MAAM,SAAS,CAAC;AAAA,MACvB,WAAW,MAAM,QAAQ,aAAa,oBAAI,KAAK;AAAA,MAC/C,WAAW,oBAAI,KAAK;AAAA,IACtB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,KAAqC;AAChD,WAAO;AAAA,MACL,SAAS;AAAA,QACP,IAAI,IAAI;AAAA,QACR,MAAM,IAAI;AAAA,QACV,SAAS,IAAI;AAAA,QACb,WAAW,IAAI;AAAA,QACf,YAAY,IAAI;AAAA,QAChB,WAAW,IAAI;AAAA,MACjB;AAAA,MACA,OAAO,IAAI;AAAA,IACb;AAAA,EACF;AACF;;;AChHO,IAAM,eAAN,MAAmB;AAAA,EAIxB,YAAoB,mBAAuC;AAAvC;AAHpB,SAAQ,aAA6C,oBAAI,IAAI;AAC7D,SAAQ,gBAAuD;AAAA,EAEH;AAAA;AAAA;AAAA;AAAA,EAK5D,MAAM,iBAAiB,WAAsD;AAE3E,QAAI,KAAK,WAAW,IAAI,SAAS,GAAG;AAClC,aAAO,KAAK,WAAW,IAAI,SAAS;AAAA,IACtC;AAEA,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,mBAAmB;AAC7D,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAElD,YAAM,QAAQ,MAAM,QAAQ,QAAQ,YAAY,EAAE,UAAU,CAAC;AAE7D,UAAI,OAAO;AACT,aAAK,WAAW,IAAI,WAAW,KAA0B;AACzD,eAAO;AAAA,MACT;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,iCAAiC,KAAK;AACpD,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,oBACJ,WACA,SACe;AACf,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,mBAAmB;AAC7D,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,gBAAgB,MAAM,KAAK,iBAAiB,SAAS;AAE3D,UAAI,iBAAiB,cAAc,KAAK;AAEtC,cAAM,QAAQ;AAAA,UACZ;AAAA,UACA,EAAE,KAAK,cAAc,IAAI;AAAA,UACzB;AAAA,YACE,GAAG;AAAA,YACH,WAAW,oBAAI,KAAK;AAAA,UACtB;AAAA,QACF;AAGA,cAAM,eAAe,MAAM,QAAQ,QAAQ,YAAY,EAAE,UAAU,CAAC;AACpE,YAAI,cAAc;AAChB,eAAK,WAAW,IAAI,WAAW,YAAiC;AAAA,QAClE;AAAA,MACF,OAAO;AAEL,cAAM,WAA2C;AAAA,UAC/C;AAAA,UACA,eAAe;AAAA,UACf,UAAU,CAAC;AAAA,UACX,WAAW,oBAAI,KAAK;AAAA,UACpB,WAAW,oBAAI,KAAK;AAAA,UACpB,GAAG;AAAA,QACL;AAEA,cAAM,SAAS,MAAM,QAAQ,UAAU,YAAY,QAAQ;AAC3D,aAAK,WAAW,IAAI,WAAW,MAA2B;AAAA,MAC5D;AAGA,WAAK,gBAAgB;AAAA,IACvB,SAAS,OAAO;AACd,cAAQ,MAAM,kCAAkC,KAAK;AACrD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,WAAoC;AACzD,UAAM,QAAQ,MAAM,KAAK,iBAAiB,SAAS;AACnD,WAAO,OAAO,iBAAiB;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,kBACJ,WACA,YACe;AACf,UAAM,KAAK,oBAAoB,WAAW,EAAE,eAAe,WAAW,CAAC;AAAA,EACzE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YACJ,WACyC;AAEzC,QAAI,KAAK,eAAe;AACtB,aAAO,KAAK;AAAA,IACd;AAEA,UAAM,QAAQ,MAAM,KAAK,iBAAiB,SAAS;AAEnD,QAAI,CAAC,OAAO;AAEV,YAAM,aAA6B;AAAA,QACjC,MAAM;AAAA,QACN,YAAY;AAAA,QACZ,WAAW,oBAAI,KAAK,CAAC;AAAA;AAAA,QACrB,cAAc,oBAAI,KAAK;AAAA,MACzB;AAEA,YAAM,WAAW,EAAE,MAAM,WAAW;AACpC,YAAM,KAAK,oBAAoB,WAAW,EAAE,SAAS,CAAC;AACtD,WAAK,gBAAgB;AACrB,aAAO;AAAA,IACT;AAEA,SAAK,gBAAgB,MAAM;AAC3B,WAAO,MAAM;AAAA,EACf;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aACJ,WACA,UACe;AACf,UAAM,KAAK,oBAAoB,WAAW,EAAE,SAAS,CAAC;AACtD,SAAK,gBAAgB;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,oBAAoB,UAAgD;AAClE,SAAK,gBAAgB;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAKA,aAAmB;AACjB,SAAK,WAAW,MAAM;AACtB,SAAK,gBAAgB;AAAA,EACvB;AACF;;;AC/JO,IAAM,gBAAN,MAAoB;AAAA,EACzB,YACU,mBACA,cACR;AAFQ;AACA;AAAA,EACP;AAAA;AAAA;AAAA;AAAA,EAKH,MAAM,eAAe,WAA8C;AACjE,UAAM,QAAQ,MAAM,KAAK,aAAa,iBAAiB,SAAS;AAChE,WAAO,OAAO;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,WAAmB,QAA6B;AACnE,UAAM,KAAK,aAAa,oBAAoB,WAAW;AAAA,MACrD,aAAa;AAAA,IACf,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,oBACJ,WACA,WACoC;AACpC,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAElD,YAAM,MAAM,MAAM,QAAQ,QAAQ,YAAY,EAAE,WAAW,UAAU,CAAC;AACtE,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,sCAAsC,KAAK;AACzD,aAAO;AAAA,IACT;AAAA,EACF;AACF;;;ACrCO,IAAM,iBAAN,MAAqB;AAAA,EAC1B,YACU,WACA,mBACA,eACR;AAHQ;AACA;AACA;AAAA,EACN;AAAA;AAAA;AAAA;AAAA,EAKJ,MAAM,WACJ,WACA,SACA,UACA,WACe;AACf,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,qBAAqB;AAC/D,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,aAAa,KAAK;AAE9B,YAAM,UAA4C;AAAA,QAChD,WAAW;AAAA,QACX;AAAA,QACA;AAAA,QACA;AAAA,QACA,WAAW,oBAAI,KAAK;AAAA,QACpB,WAAW,oBAAI,KAAK;AAAA,MACtB;AAEA,YAAM,QAAQ,UAAU,YAAY,OAAO;AAAA,IAC7C,SAAS,OAAO;AACd,cAAQ,MAAM,qCAAqC,KAAK;AACxD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,WAAoD;AACrE,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,qBAAqB;AAC/D,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,aAAa,KAAK;AAE9B,YAAM,YAAY,MAAM,QAAQ;AAAA,QAC9B;AAAA,QACA,EAAE,WAAW,IAAI;AAAA,QACjB,EAAE,MAAM,EAAE,WAAW,EAAE,EAAE;AAAA,MAC3B;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,0CAA0C,KAAK;AAC7D,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,sBAAsB,QAAwC;AAClE,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,OAAO,aAAa,KAAK;AAGrC,YAAM,gBAAgB,MAAM,KAAK,cAAc,eAAe,GAAG;AAEjE,UAAI,iBAAsB,EAAE,WAAW,IAAI;AAG3C,UAAI,eAAe;AACjB,cAAM,eAAe,QAAQ,mBAAmB;AAChD,cAAM,kBAAkB,aAAa,MAAM,aAAa,MAAM,aAAa,EAAE,MAAM;AACnF,yBAAiB,EAAE,GAAG,gBAAgB,GAAG,gBAAgB;AAAA,MAC3D;AAGA,YAAM,SAAS,MAAM,QAAQ;AAAA,QAC3B;AAAA,QACA;AAAA,QACA,EAAE,MAAM,EAAE,WAAW,EAAE,EAAE;AAAA,MAC3B;AAGA,YAAM,cAAc,OAAO;AAC3B,YAAM,iBAAiB,cAAc,OAAO;AAE5C,UAAI,iBAAiB,GAAG;AAEtB,cAAM,mBAAmB,OACvB,iBAAiB,CACnB;AACA,cAAM,KAAK,cAAc;AAAA,UACvB;AAAA,UACA,iBAAiB;AAAA,QACnB;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,mDAAmD,KAAK;AACtE,YAAM;AAAA,IACR;AAAA,EACF;AACF;;;AC7GO,IAAM,gBAAN,MAAoB;AAAA,EACzB,YACU,mBACA,cACA,eACR;AAHQ;AACA;AACA;AAAA,EACN;AAAA;AAAA;AAAA;AAAA,EAKJ,MAAM,qBAAqB,WAAoC;AAC7D,UAAM,gBAAgB,MAAM,KAAK,aAAa,iBAAiB,SAAS;AACxE,UAAM,WAAW,MAAM,KAAK,aAAa,YAAY,SAAS;AAC9D,WAAO,SAAS,aAAa,GAAG,cAAc;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,sBACJ,WACA,mBACgB;AAChB,UAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,UAAM,WAAW,MAAM,KAAK,aAAa,YAAY,SAAS;AAC9D,UAAM,aAAoB,CAAC;AAG3B,UAAM,YAAY,kBAAkB,MAAM,GAAG;AAC7C,aAAS,IAAI,GAAG,KAAK,UAAU,QAAQ,KAAK;AAC1C,YAAM,eAAe,UAAU,MAAM,GAAG,CAAC,EAAE,KAAK,GAAG;AACnD,YAAM,SAAS,OAAO,OAAO,QAAQ,EAAE;AAAA,QACrC,CAAC,MAAM,EAAE,eAAe;AAAA,MAC1B;AAEA,UAAI,QAAQ;AACV,cAAM,eAAe,QAClB,mBAAmB,EACnB,MAAM,aAAa,MAAM,SAAS,EAClC,IAAI,cAAc,MAAM,YAAY;AAGvC,YAAI,IAAI,UAAU,QAAQ;AACxB,gBAAM,cAAc,OAAO,OAAO,QAAQ,EAAE;AAAA,YAC1C,CAAC,MAAM,EAAE,eAAe,UAAU,MAAM,GAAG,IAAI,CAAC,EAAE,KAAK,GAAG;AAAA,UAC5D;AACA,cAAI,aAAa;AACf,yBAAa,IAAI,aAAa,OAAO,YAAY,YAAY;AAAA,UAC/D;AAAA,QACF;AAEA,mBAAW,KAAK,aAAa,MAAM,CAAC;AAAA,MACtC;AAAA,IACF;AAEA,WAAO,WAAW,SAAS,IACvB,aACA;AAAA,MACA,QACG,mBAAmB,EACnB,MAAM,aAAa,MAAM,SAAS,EAClC,IAAI,cAAc,MAAM,MAAM,EAC9B,MAAM;AAAA,IACX;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,qBACE,YACA,YACO;AACP,UAAM,UAAU,KAAK,kBAAkB,WAAW;AAElD,WAAO,WAAW,IAAI,CAAC,SAAS;AAE9B,YAAM,UAAU,QAAQ,mBAAmB;AAG3C,UAAI,QAAQ,KAAK,mBAAmB;AAGlC,cAAM,gBAAgB,KAAK;AAC3B,cAAM,iBAAiB,KAAK;AAI5B,cAAM,kBAAkB,gBAAgB,KAAK,IAAI,CAAC;AAClD,cAAM,gBAAgB,IAAI,aAAa,6BAA6B,eAAe;AACnF,cAAM,iBAAiB,EAAE,GAAG,gBAAgB,CAAC,eAAe,GAAG,WAAW;AAE1E,eAAO;AAAA,UACL,mBAAmB;AAAA,UACnB,OAAO;AAAA,UACP,YAAY;AAAA,QACd;AAAA,MACF,OAAO;AAEL,eAAO,QAAQ,IAAI,EAAE,QAAQ,CAAC,CAAC,OAAO,KAAK,MAAM;AAC/C,cAAI,UAAU,OAAO;AACnB,oBAAQ,MAAM,OAAO,MAAM,KAAK;AAAA,UAClC;AAAA,QACF,CAAC;AAGD,gBAAQ,IAAI,aAAa,MAAM,UAAU;AAEzC,eAAO,QAAQ,MAAM;AAAA,MACvB;AAAA,IACF,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aACJ,WACA,YACA,aACA,YACiB;AACjB,UAAM,WAAW,MAAM,KAAK,aAAa,YAAY,SAAS;AAE9D,QAAI,SAAS,UAAU,GAAG;AACxB,YAAM,IAAI,MAAM,WAAW,UAAU,kBAAkB;AAAA,IACzD;AAGA,UAAM,oBACJ,MAAM,KAAK,aAAa,iBAAiB,SAAS;AACpD,UAAM,oBAAoB,MAAM,KAAK,qBAAqB,SAAS;AAGnE,UAAM,gBAAgB,GAAG,iBAAiB,IAAI,UAAU;AAGxD,QAAI;AACJ,QAAI,aAAa;AACf,YAAM,YAAY,MAAM,KAAK,cAAc;AAAA,QACzC;AAAA,QACA;AAAA,MACF;AACA,UAAI,CAAC,WAAW;AACd,cAAM,IAAI,MAAM,UAAU,WAAW,aAAa;AAAA,MACpD;AACA,qBAAe,UAAU;AAAA,IAC3B,OAAO;AAEL,UAAI,YAAY;AACd,cAAM,SAAS,MAAM,WAAW;AAChC,YAAI,OAAO,SAAS,GAAG;AACrB,gBAAM,YAAY,OAAO,OAAO,SAAS,CAAC;AAC1C,gBAAM,UAAU,MAAM,KAAK,cAAc;AAAA,YACvC;AAAA,YACA,UAAU,QAAQ;AAAA,UACpB;AACA,yBAAe,UAAU,QAAQ,YAAY,oBAAI,KAAK;AAAA,QACxD,OAAO;AAEL,yBAAe,oBAAI,KAAK;AAAA,QAC1B;AAAA,MACF,OAAO;AACL,uBAAe,oBAAI,KAAK;AAAA,MAC1B;AAAA,IACF;AAGA,UAAM,gBAAgB,MAAM,KAAK,cAAc,eAAe,SAAS;AAGvE,aAAS,UAAU,IAAI;AAAA,MACrB,MAAM;AAAA,MACN,cAAc;AAAA,MACd,YAAY;AAAA,MACZ,WAAW,oBAAI,KAAK;AAAA,MACpB;AAAA,MACA;AAAA,MACA,aAAa;AAAA,IACf;AAEA,UAAM,KAAK,aAAa,aAAa,WAAW,QAAQ;AAExD,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eAAe,WAAmB,YAAmC;AACzE,UAAM,WAAW,MAAM,KAAK,aAAa,YAAY,SAAS;AAC9D,UAAM,SAAS,SAAS,UAAU;AAElC,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI,MAAM,WAAW,UAAU,kBAAkB;AAAA,IACzD;AAGA,UAAM,oBACJ,MAAM,KAAK,aAAa,iBAAiB,SAAS;AACpD,UAAM,gBAAgB,MAAM,KAAK,cAAc,eAAe,SAAS;AAEvE,QAAI,SAAS,iBAAiB,GAAG;AAC/B,eAAS,iBAAiB,EAAE,cAAc;AAAA,IAC5C;AAGA,UAAM,UAAe;AAAA,MACnB;AAAA,MACA,eAAe;AAAA,IACjB;AAGA,QAAI,OAAO,gBAAgB,QAAW;AACpC,cAAQ,cAAc,OAAO;AAAA,IAC/B,OAAO;AACL,cAAQ,cAAc;AAAA,IACxB;AAEA,UAAM,KAAK,aAAa,oBAAoB,WAAW,OAAO;AAG9D,SAAK,aAAa,oBAAoB,QAAQ;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBAAgB,WAAmB,SAAgC;AACvE,UAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,UAAM,QAAQ,MAAM,KAAK,cAAc,oBAAoB,WAAW,OAAO;AAC7E,UAAM,UAAU,KAAK,kBAAkB,WAAW;AAElD,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,MAAM,UAAU,OAAO,2BAA2B,SAAS,GAAG;AAAA,IAC1E;AAEA,UAAM,oBACJ,MAAM,KAAK,qBAAqB,SAAS;AAG3C,QAAI,aAAa,MAAM,KAAK;AAAA,MAC1B;AAAA,MACA;AAAA,IACF;AAEA,iBAAa,KAAK;AAAA,MAChB;AAAA,MACA,MAAM;AAAA,IACR;AAEA,QAAI;AACJ,QAAI,WAAW,SAAS,GAAG;AACzB,YAAM,YAAY,QAAQ,mBAAmB;AAC7C,YAAM,oBAAoB,WAAW,IAAI,CAAC,SAAc;AACtD,cAAM,UAAU,QAAQ,mBAAmB;AAC3C,eAAO,QAAQ,IAAI,EAAE,QAAQ,CAAC,CAAC,OAAO,KAAK,MAAM;AAC/C,kBAAQ,MAAM,OAAO,MAAM,KAAK;AAAA,QAClC,CAAC;AACD,eAAO;AAAA,MACT,CAAC;AACD,uBAAiB,UAAU,GAAG,iBAAiB,EAAE,MAAM;AAAA,IACzD,OAAO;AACL,uBAAiB,WAAW,CAAC;AAAA,IAC/B;AAEA,UAAM,QAAQ,WAAW,YAAY,cAAc;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBACJ,WACA,QAC6B;AAC7B,UAAM,WAAW,MAAM,KAAK,aAAa,YAAY,SAAS;AAC9D,WAAO,SAAS,MAAM,IAAI,WAAW;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,WAAmB,YAAmC;AACvE,QAAI,eAAe,QAAQ;AACzB,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AAEA,UAAM,gBAAgB,MAAM,KAAK,aAAa,iBAAiB,SAAS;AACxE,QAAI,kBAAkB,YAAY;AAChC,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,UAAM,WAAW,MAAM,KAAK,aAAa,YAAY,SAAS;AAC9D,QAAI,CAAC,SAAS,UAAU,GAAG;AACzB,YAAM,IAAI,MAAM,WAAW,UAAU,kBAAkB;AAAA,IACzD;AAEA,WAAO,SAAS,UAAU;AAC1B,UAAM,KAAK,aAAa,aAAa,WAAW,QAAQ;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aACJ,WACwD;AACxD,UAAM,WAAW,MAAM,KAAK,aAAa,YAAY,SAAS;AAC9D,UAAM,gBAAgB,MAAM,KAAK,aAAa,iBAAiB,SAAS;AAExE,WAAO,OAAO,OAAO,QAAQ,EAAE,IAAI,CAAC,YAAY;AAAA,MAC9C,GAAG;AAAA,MACH,UAAU,OAAO,SAAS;AAAA,IAC5B,EAAE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,WAAoC;AACzD,WAAO,KAAK,aAAa,iBAAiB,SAAS;AAAA,EACrD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,gBAAgB,WAAmB,eAAyB,CAAC,GAAkB;AACnF,UAAM,WAAW,MAAM,KAAK,aAAa,YAAY,SAAS;AAC9D,UAAM,gBAAgB,MAAM,KAAK,aAAa,iBAAiB,SAAS;AAGxE,UAAM,iBAAiB,oBAAI,IAAI;AAAA,MAC7B;AAAA,MACA;AAAA,MACA,GAAG;AAAA,IACL,CAAC;AAGD,UAAM,mBAAmB,OAAO,KAAK,QAAQ,EAAE;AAAA,MAC7C,gBAAc,CAAC,eAAe,IAAI,UAAU;AAAA,IAC9C;AAGA,eAAW,cAAc,kBAAkB;AACzC,aAAO,SAAS,UAAU;AAAA,IAC5B;AAGA,UAAM,KAAK,aAAa,aAAa,WAAW,QAAQ;AAAA,EAC1D;AACF;;;AC5TO,IAAM,iBAAN,cAA6B,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsB7C,YACE,UAGkD,CAAC,GACnD;AACA,UAAM,OAAO;AAEb,SAAK,YAAY,QAAQ,aAAa;AACtC,SAAK,0BACH,QAAQ,4BAA4B,QAAQ,aAAa,OAAO;AAGlE,SAAK,oBAAoB,IAAI,kBAAkB;AAC/C,SAAK,oBAAoB,IAAI,kBAAkB;AAG/C,SAAK,eAAe,IAAI,aAAa,KAAK,iBAAiB;AAC3D,SAAK,gBAAgB,IAAI;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AACA,SAAK,gBAAgB,IAAI;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AACA,SAAK,iBAAiB,IAAI;AAAA,MACxB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,KAAK,SAAgD;AAChE,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,YAAM,oBACJ,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGnD,YAAM,mBAAmB,MAAM,KAAK,cAAc;AAAA,QAChD;AAAA,QACA;AAAA,MACF;AAGA,YAAM,cAAc,MAAM,KAAK,cAAc,eAAe,GAAG;AAC/D,UAAI,aAAa;AAEjB,UAAI,aAAa;AACf,qBAAa,KAAK,cAAc;AAAA,UAC9B;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAGA,UAAI;AACJ,UAAI,WAAW,SAAS,GAAG;AACzB,yBAAiB,CAAC,QAAa;AAC7B,iBAAO,WAAW,KAAK,CAAC,SAAS;AAC/B,gBAAI,OAAO,SAAS,YAAY;AAC9B,qBAAO,KAAK,GAAG;AAAA,YACjB;AAEA,mBAAO,OAAO,QAAQ,IAAI,EAAE,MAAM,CAAC,CAAC,OAAO,KAAK,MAAM;AACpD,oBAAM,WAAW,MACd,MAAM,GAAG,EACT,OAAO,CAAC,KAAK,QAAQ,MAAM,GAAG,GAAG,GAAG;AACvC,kBACE,SACA,OAAO,UAAU,YACjB,CAAC,MAAM,QAAQ,KAAK,KACpB,EAAE,iBAAiB,OACnB;AACA,uBAAO,OAAO,QAAQ,KAAK,EAAE,MAAM,CAAC,CAAC,IAAI,OAAO,MAAM;AACpD,0BAAQ,IAAI;AAAA,oBACV,KAAK;AACH,6BAAO,WAAW;AAAA,oBACpB,KAAK;AACH,6BAAO,YAAY;AAAA,oBACrB,KAAK;AACH,6BAAO,WAAW;AAAA,oBACpB,KAAK;AACH,6BAAO,YAAY;AAAA,oBACrB,KAAK;AAAA,oBACL,KAAK;AACH,6BAAO,aAAa;AAAA,oBACtB;AACE,6BAAO,aAAa;AAAA,kBACxB;AAAA,gBACF,CAAC;AAAA,cACH;AACA,qBAAO,aAAa;AAAA,YACtB,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAAA,MACF,OAAO;AACL,cAAM,OAAO,WAAW,CAAC;AACzB,YAAI,OAAO,SAAS,YAAY;AAC9B,2BAAiB;AAAA,QACnB,OAAO;AACL,2BAAiB,CAAC,QAAa;AAC7B,mBAAO,OAAO,QAAQ,IAAI,EAAE,MAAM,CAAC,CAAC,OAAO,KAAK,MAAM;AACpD,oBAAM,WAAW,MACd,MAAM,GAAG,EACT,OAAO,CAAC,KAAK,QAAQ,MAAM,GAAG,GAAG,GAAG;AACvC,kBACE,SACA,OAAO,UAAU,YACjB,CAAC,MAAM,QAAQ,KAAK,KACpB,EAAE,iBAAiB,OACnB;AACA,uBAAO,OAAO,QAAQ,KAAK,EAAE,MAAM,CAAC,CAAC,IAAI,OAAO,MAAM;AACpD,0BAAQ,IAAI;AAAA,oBACV,KAAK;AACH,6BAAO,WAAW;AAAA,oBACpB,KAAK;AACH,6BAAO,YAAY;AAAA,oBACrB,KAAK;AACH,6BAAO,WAAW;AAAA,oBACpB,KAAK;AACH,6BAAO,YAAY;AAAA,oBACrB,KAAK;AAAA,oBACL,KAAK;AACH,6BAAO,aAAa;AAAA,oBACtB;AACE,6BAAO,aAAa;AAAA,kBACxB;AAAA,gBACF,CAAC;AAAA,cACH;AACA,qBAAO,aAAa;AAAA,YACtB,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAGA,YAAM,QAAQ,SAAS,SAAS;AAChC,YAAM,eAAoB;AAAA,QACxB,MAAM,EAAE,WAAW,UAAU,QAAQ,IAAI,GAAG;AAAA,MAC9C;AAEA,UAAI,SAAS,QAAQ;AACnB,qBAAa,OAAO,QAAQ;AAAA,MAC9B;AACA,UAAI,SAAS,OAAO;AAClB,qBAAa,QAAQ,QAAQ;AAAA,MAC/B;AAGA,YAAM,SAAS,MAAM,QAAQ;AAAA,QAC3B;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAGA,cAAQ,UAAU,SAAS,OAAO,QAAQ,IAAI,QAAQ;AAAA,QACpD,CAAC,QAA0B,KAAK,kBAAkB,aAAa,GAAG;AAAA,MACpE;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,gDAAgD,KAAK;AACnE,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,IACX,OACA,SACe;AACf,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,YAAM,oBACJ,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGnD,YAAM,WAAW,KAAK,kBAAkB;AAAA,QACtC;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAGA,YAAM,QAAQ,UAAU,YAAY,QAAQ;AAG5C,UAAI,KAAK,2BAA2B,KAAK,YAAY;AACnD,cAAM,SAAS,MAAM,KAAK,KAAK,EAAE,WAAW,IAAI,CAAC;AACjD,cAAM,KAAK,cAAc,EAAE,WAAW,KAAK,OAAO,CAAC;AAAA,MACrD;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,4CAA4C,KAAK;AAC/D,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,QACX,MACA,SACe;AACf,QAAI;AACF,iBAAW,SAAS,MAAM;AACxB,cAAM,KAAK,IAAI,OAAO,OAAO;AAAA,MAC/B;AAAA,IACF,UAAE;AAAA,IAEF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,OAAO,QAGF;AAChB,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAGlD,YAAM,gBAAgB,QAAQ,oBAAoB;AAElD,OAAC,QAAQ,WAAW,aAAa,cAAc,OAAO,EAAE,QAAQ,CAAC,QAAQ;AACvE,YAAK,OAAO,MAAM,QAAgB,GAAG,GAAG;AACtC,wBAAc,IAAI,KAAM,OAAO,MAAM,QAAgB,GAAG,CAAC;AAAA,QAC3D;AAAA,MACF,CAAC;AAED,UAAI,OAAO,MAAM,OAAO;AACtB,sBAAc,IAAI,SAAS,OAAO,MAAM,KAAK;AAAA,MAC/C;AACA,oBAAc,IAAI,aAAa,oBAAI,KAAK,CAAC;AAEzC,YAAM,QAAQ,QACX,mBAAmB,EACnB,MAAM,aAAa,MAAM,OAAO,SAAS,EACzC,IAAI,aAAa,MAAM,OAAO,MAAM,QAAQ,EAAE,EAC9C,MAAM;AAET,YAAM,QAAQ,UAAU,YAAY,OAAO,cAAc,MAAM,CAAC;AAAA,IAClE,SAAS,OAAO;AACd,cAAQ,MAAM,8CAA8C,KAAK;AACjE,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,OACX,QAOA,SACe;AAEf,QAAI,OAAO,WAAW,YAAY,OAAO,WAAW,UAAU;AAC5D,aAAO,KAAK,kBAAkB,QAAQ,OAAO;AAAA,IAC/C;AAGA,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,OAAO,aAAa,KAAK;AAErC,YAAM,QAAQ,QACX,mBAAmB,EACnB,MAAM,aAAa,MAAM,GAAG,EAC5B,IAAI,aAAa,MAAM,OAAO,MAAM,QAAQ,EAAE,EAC9C,MAAM;AAET,YAAM,QAAQ,UAAU,YAAY,KAAK;AAAA,IAC3C,SAAS,OAAO;AACd,cAAQ,MAAM,gDAAgD,KAAK;AACnE,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,kBACX,WACA,SACe;AACf,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAEvC,UAAI,OAAO,cAAc,UAAU;AAEjC,cAAM,QAAQ,QACX,mBAAmB,EACnB,MAAM,aAAa,MAAM,GAAG,EAC5B,IAAI,aAAa,MAAM,SAAS,EAChC,MAAM;AAET,cAAM,QAAQ,UAAU,YAAY,KAAK;AAAA,MAC3C,OAAO;AAEL,cAAM,SAAS,MAAM,KAAK,KAAK,EAAE,WAAW,IAAI,CAAC;AACjD,YAAI,aAAa,KAAK,YAAY,OAAO,QAAQ;AAC/C,gBAAM,gBAAgB,OAAO,SAAS;AACtC,gBAAM,KAAK,OAAO,EAAE,OAAO,eAAe,WAAW,IAAI,CAAC;AAAA,QAC5D;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,cAAQ;AAAA,QACN;AAAA,QACA;AAAA,MACF;AACA,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,MAAM,SAAuC;AACxD,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,kBAAkB,KAAK,kBAAkB,mBAAmB;AAClE,YAAM,oBAAoB,KAAK,kBAAkB,qBAAqB;AACtE,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAElD,UAAI,SAAS,WAAW;AAEtB,cAAM,MAAM,QAAQ;AAGpB,cAAM,SAAS,MAAM,QAAQ;AAAA,UAC3B;AAAA,UACA,EAAE,WAAW,IAAI;AAAA,UACjB,EAAE,MAAM,EAAE,WAAW,GAAG,GAAG,OAAO,EAAE;AAAA,QACtC;AAEA,YAAI,OAAO,SAAS,GAAG;AACrB,gBAAM,YAAY,OAAO,CAAC;AAE1B,gBAAM,KAAK,cAAc,eAAe,KAAK,UAAU,SAAS;AAAA,QAClE;AAGA,cAAM,QAAQ,WAAW,mBAAmB,EAAE,WAAW,IAAI,CAAC;AAAA,MAChE,OAAO;AAEL,cAAM,QAAQ,WAAW,YAAY,CAAC,CAAC;AACvC,cAAM,QAAQ,WAAW,iBAAiB,CAAC,CAAC;AAC5C,cAAM,QAAQ,WAAW,mBAAmB,CAAC,CAAC;AAAA,MAChD;AAGA,WAAK,aAAa,WAAW;AAAA,IAC/B,SAAS,OAAO;AACd,cAAQ,MAAM,iDAAiD,KAAK;AACpE,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,SAAS,SAAmD;AACvE,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,YAAM,oBACJ,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGnD,YAAM,mBAAmB,MAAM,KAAK,cAAc;AAAA,QAChD;AAAA,QACA;AAAA,MACF;AAGA,YAAM,cAAc,MAAM,KAAK,cAAc,eAAe,GAAG;AAC/D,UAAI,aAAa;AAEjB,UAAI,aAAa;AACf,qBAAa,KAAK,cAAc;AAAA,UAC9B;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAGA,UAAI;AACJ,UAAI,WAAW,SAAS,GAAG;AACzB,yBAAiB,CAAC,QAAa;AAC7B,iBAAO,WAAW,KAAK,CAAC,SAAS;AAC/B,gBAAI,OAAO,SAAS,YAAY;AAC9B,qBAAO,KAAK,GAAG;AAAA,YACjB;AACA,mBAAO,OAAO,QAAQ,IAAI,EAAE,MAAM,CAAC,CAAC,OAAO,KAAK,MAAM;AACpD,oBAAM,WAAW,MACd,MAAM,GAAG,EACT,OAAO,CAAC,KAAK,QAAQ,MAAM,GAAG,GAAG,GAAG;AACvC,qBAAO,aAAa;AAAA,YACtB,CAAC;AAAA,UACH,CAAC;AAAA,QACH;AAAA,MACF,OAAO;AACL,cAAM,OAAO,WAAW,CAAC;AACzB,YAAI,OAAO,SAAS,YAAY;AAC9B,2BAAiB;AAAA,QACnB,OAAO;AACL,2BAAiB,CAAC,QAAa;AAC7B,mBAAO,OAAO,QAAQ,IAAI,EAAE,MAAM,CAAC,CAAC,OAAO,KAAK,MAAM;AACpD,oBAAM,WAAW,MACd,MAAM,GAAG,EACT,OAAO,CAAC,KAAK,QAAQ,MAAM,GAAG,GAAG,GAAG;AACvC,qBAAO,aAAa;AAAA,YACtB,CAAC;AAAA,UACH;AAAA,QACF;AAAA,MACF;AAEA,YAAM,QAAQ,MAAM,QAAQ,MAAM,YAAY,cAAc;AAC5D,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,+CAA+C,KAAK;AAClE,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,SACX,OACA,SACyB;AACzB,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,YAAM,oBACJ,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGnD,YAAM,mBAAmB,MAAM,KAAK,cAAc;AAAA,QAChD;AAAA,QACA;AAAA,MACF;AAGA,YAAM,cAAc,MAAM,KAAK,cAAc,eAAe,GAAG;AAC/D,UAAI,aAAa;AAEjB,UAAI,aAAa;AACf,qBAAa,KAAK,cAAc;AAAA,UAC9B;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAGA,YAAM,kBAAkB,CAAC,QAAa;AAEpC,cAAM,gBAAgB,WAAW,KAAK,CAAC,SAAS;AAC9C,cAAI,OAAO,SAAS,YAAY;AAC9B,mBAAO,KAAK,GAAG;AAAA,UACjB;AACA,iBAAO,OAAO,QAAQ,IAAI,EAAE,MAAM,CAAC,CAAC,OAAO,KAAK,MAAM;AACpD,kBAAM,WAAW,MACd,MAAM,GAAG,EACT,OAAO,CAAC,KAAK,QAAQ,MAAM,GAAG,GAAG,GAAG;AACvC,mBAAO,aAAa;AAAA,UACtB,CAAC;AAAA,QACH,CAAC;AAED,YAAI,CAAC,cAAe,QAAO;AAG3B,cAAM,UAAU,IAAI,WAAW;AAC/B,eAAO,QAAQ,YAAY,EAAE,SAAS,MAAM,YAAY,CAAC;AAAA,MAC3D;AAEA,YAAM,SAAS,MAAM,QAAQ;AAAA,QAC3B;AAAA,QACA;AAAA,MACF;AAEA,aAAO,OAAO;AAAA,QAAI,CAAC,QACjB,KAAK,kBAAkB,aAAa,GAAG;AAAA,MACzC;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,mDAAmD,KAAK;AACtE,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAa,aAAa,WAAkD;AAC1E,UAAM,YAAY,MAAM,KAAK,eAAe,aAAa,SAAS;AAGlE,WAAO,UAAU,IAAI,CAAC,SAAS;AAAA,MAC7B,SAAS,IAAI;AAAA,MACb,OAAO;AAAA;AAAA,MACP,WAAW;AAAA,QACT,OAAO,IAAI,UAAU;AAAA,QACrB,KAAK,IAAI,UAAU;AAAA,MACrB;AAAA,MACA,WAAW,IAAI;AAAA,IACjB,EAAE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAgB,aAAa,QAGX;AAChB,UAAM,YAAY,WAAW,KAAK,IAAI,CAAC;AACvC,UAAM,WAAW;AAAA,MACf,OAAO,OAAO,QAAQ;AAAA,MACtB,gBAAgB,OAAO,QAAQ,UAAU;AAAA,MACzC,cAAc,OAAO,QAAQ,UAAU;AAAA,IACzC;AAEA,WAAO,KAAK,eAAe;AAAA,MACzB;AAAA,MACA,OAAO,QAAQ;AAAA,MACf;AAAA,MACA,OAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAgB,sBAAsB,QAGpB;AAChB,WAAO,KAAK,eAAe,sBAAsB;AAAA,MAC/C,WAAW,OAAO;AAAA,MAClB,cAAc,OAAO;AAAA,IACvB,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,OACX,YACA,aACiB;AACjB,WAAO,KAAK,cAAc;AAAA,MACxB,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA,MAAM,KAAK,KAAK,EAAE,WAAW,KAAK,UAAU,CAAC;AAAA,IAC/C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,SACX,QACA,SACe;AACf,UAAM,eACJ,SAAS,QACR,MAAM,KAAK,cAAc;AAAA,MACxB,SAAS,aAAa,KAAK;AAAA,MAC3B;AAAA,IACF;AAEF,UAAM,YAAY,SAAS,aAAa,KAAK;AAE7C,QAAI,iBAAiB,SAAS;AAC5B,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,QAAQ,MAAM,KAAK,cAAc;AAAA,QACrC;AAAA,QACA;AAAA,MACF;AACA,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAElD,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,MAAM,UAAU,MAAM,aAAa;AAAA,MAC/C;AAGA,YAAM,oBACJ,MAAM,KAAK,cAAc,qBAAqB,SAAS;AAGzD,UAAI,aAAa,MAAM,KAAK,cAAc;AAAA,QACxC;AAAA,QACA;AAAA,MACF;AAEA,mBAAa,KAAK,cAAc;AAAA,QAC9B;AAAA,QACA,MAAM;AAAA,MACR;AAEA,YAAM,iBAAiB,CAAC,QAAa;AACnC,eAAO,WAAW,KAAK,CAAC,SAAS;AAC/B,cAAI,OAAO,SAAS,YAAY;AAC9B,mBAAO,KAAK,GAAG;AAAA,UACjB;AACA,iBAAO,OAAO,QAAQ,IAAI,EAAE,MAAM,CAAC,CAAC,OAAO,KAAK,MAAM;AACpD,kBAAM,WAAW,MACd,MAAM,GAAG,EACT,OAAO,CAAC,KAAK,QAAQ,MAAM,GAAG,GAAG,GAAG;AACvC,mBAAO,aAAa;AAAA,UACtB,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAEA,YAAM,QAAQ,WAAW,YAAY,cAAc;AAAA,IACrD,OAAO;AACL,YAAM,KAAK,cAAc,eAAe,WAAW,MAAM;AAAA,IAC3D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,aAAa,YAAmC;AAC3D,WAAO,KAAK,cAAc,aAAa,KAAK,WAAW,UAAU;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,eAAsC;AACjD,UAAM,WAAW,MAAM,KAAK,cAAc,aAAa,KAAK,SAAS;AAGrE,UAAM,cAA4B,CAAC;AACnC,eAAW,UAAU,UAAU;AAC7B,kBAAY,KAAK;AAAA,QACf,MAAM,OAAO;AAAA,QACb,UAAU,OAAO;AAAA,QACjB,WAAW,OAAO;AAAA,QAClB,aAAa,OAAO;AAAA,MACtB,CAAC;AAAA,IACH;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,mBAAoC;AAC/C,WAAO,KAAK,cAAc,iBAAiB,KAAK,SAAS;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,gBAAgB,cAAwC;AACnE,WAAO,KAAK,cAAc,gBAAgB,KAAK,WAAW,YAAY;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,WAAiB;AACtB,SAAK,kBAAkB,SAAS;AAChC,SAAK,aAAa,WAAW;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,QAAQ,SAAoD;AACvE,UAAM,QAAQ,MAAM,KAAK,SAAS,OAAO;AACzC,WAAO,UAAU;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,gBAA0B;AAC/B,UAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,UAAM,aAAa,oBAAI,IAAY;AAEnC,eAAW,OAAO,YAAY;AAC5B,iBAAW,IAAI,IAAI,SAAS;AAAA,IAC9B;AAEA,WAAO,MAAM,KAAK,UAAU;AAAA,EAC9B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,WAAW,WAA4B;AAC5C,WAAO,KAAK,cAAc,EAAE,SAAS,SAAS;AAAA,EAChD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,iBAAiB,WAAmC;AACzD,UAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,UAAM,YAAY,WACf,OAAO,CAAC,QAAQ,IAAI,cAAc,SAAS,EAC3C,IAAI,CAAC,QAAQ,KAAK,kBAAkB,aAAa,GAAG,CAAC,EACrD,KAAK,CAAC,GAAG,MAAM;AACd,YAAM,QAAQ,EAAE,QAAQ,WAAW,QAAQ,KAAK;AAChD,YAAM,QAAQ,EAAE,QAAQ,WAAW,QAAQ,KAAK;AAChD,aAAO,QAAQ;AAAA,IACjB,CAAC;AAEH,WAAO;AAAA,EACT;AACF;;;Ad70BA,IAAI,eAAsC;AAE1C,SAAS,kBAAkC;AACzC,MAAI,CAAC,cAAc;AACjB,mBAAe,IAAI,eAAe;AAAA,EACpC;AACA,SAAO;AACT;AAWO,IAAM,QAAN,MAGL;AAAA,EAyEA,YAAY,QAAsC;AAhElD,SAAQ,YAAqB;AAC7B,SAAQ,WAAoB;AAiE1B,SAAK,SAAS,gBAAgB,oBAAoB,QAAe;AAAA,MAC/D,WAAW,OAAO;AAAA,IACpB,CAAC;AAED,SAAK,cAAc,IAAI,YAAY;AACnC,SAAK,YAAY,IAAI,UAAkB,KAAK,WAAW;AACvD,SAAK,uBAAuB,IAAI;AAAA,MAC9B,KAAK;AAAA,MACL,KAAK,OAAO,aAAa,mBAAmB;AAAA,MAC5C,KAAK,OAAO,aAAa;AAAA,IAC3B;AACA,SAAK,iBAAiB,IAAI,eAAuB;AACjD,SAAK,QAAQ,KAAK,gBAAgB;AAElC,SAAK,SAAU,OAAe,UAAU,gBAAgB;AAGxD,SAAK,gBAAgB,KAAK,wBAAwB;AAGlD,SAAK,gBAAgB;AAGrB,SAAK,yBAAyB;AAG9B,SAAK,gBAAgB,IAAI;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,MACL,MAAM,KAAK,MAAM;AAAA,MACjB,CAAC,gBAAgB,UAAU,UAAU,KAAK,YAAY,gBAAgB,UAAU,KAAK;AAAA;AAAA,MAErF,CAAC,iBAAyB;AACxB,YAAI,KAAK,MAAM,iBAAiB,OAAO,KAAK,MAAM,kBAAkB,YAAY,OAAO,iBAAiB,UAAU;AAChH,iBAAO,OAAO,KAAK,MAAM,eAAsB,YAAmB;AAAA,QACpE,OAAO;AACL,eAAK,MAAM,gBAAgB;AAAA,QAC7B;AAAA,MACF;AAAA,IACF;AAAA,EAGF;AAAA;AAAA;AAAA;AAAA,EAnGQ,uBACN,MACA,SACA,gBACA,OACA,SAMS;AACT,WAAO,KAAK,eAAe;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,wBAAwB,gBAA4C;AAChF,UAAM,SAAS,MAAM,KAAK,OAAO,KAAK;AAAA,MACpC,OAAO;AAAA,MACP,WAAW;AAAA;AAAA,IACb,CAAC;AACD,WAAO,OACJ,IAAI,WAAS,MAAM,OAAO,EAC1B,KAAK,CAAC,GAAG,OAAO,EAAE,WAAW,QAAQ,KAAK,MAAM,EAAE,WAAW,QAAQ,KAAK,EAAE;AAAA,EACjF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,YAAY,gBAAwB,UAAqB,OAA8B;AACnG,UAAM,SAAS,SAAS,IAAI,cAAY;AAAA,MACtC;AAAA,MACA;AAAA,IACF,EAAE;AACF,UAAM,KAAK,OAAO,QAAQ,QAAQ,EAAE,WAAW,eAAe,CAAC;AAAA,EACjE;AAAA;AAAA;AAAA;AAAA,EAKQ,yBAAyB,UAA6B;AAC5D,WAAO,KAAK,eAAe,yBAAyB,QAAQ;AAAA,EAC9D;AAAA;AAAA,EAoDA,MAAM,IACJ,OACA,OACA,SAC+B;AAI/B,UAAM,mBAAmB,UACpB,gBAAgB,mBAAmB,SAAgB;AAAA,MACpD,WAAW,KAAK,OAAO;AAAA,MACvB,WAAW,OAAO;AAAA,IACpB,CAAC,IACC;AAEJ,UAAM,QAAQ,kBAAkB,aAAS,gCAAW;AACpD,UAAM,iBAAiB,SAAS,sBAAkB,gCAAW;AAG7D,UAAM,eAAe;AAAA,MACnB,MAAM,CAAC,MAAiB,UAAe;AACrC,aAAK,YAAY,KAAK,MAAM,KAAK;AAEjC,YAAI,kBAAkB,SAAS;AAC7B,2BAAiB,QAAQ,KAAK;AAAA,QAChC;AAAA,MACF;AAAA,MACA,MAAM,CAAC,UAAe;AACpB,aAAK,YAAY,KAAK,MAAM,MAAM,KAAK;AAEvC,YAAI,kBAAkB,SAAS;AAC7B,2BAAiB,QAAQ,KAAK;AAAA,QAChC;AAAA,MACF;AAAA,IACF;AAGA,QAAI,SAAS,QAAQ,SAAS;AAC5B,YAAM,IAAI;AAAA,QACR;AAAA,QACA,EAAE,QAAQ,QAAQ,OAAO,UAAU,kCAAkC;AAAA,MACvE;AAAA,IACF;AAGA,UAAM,eAAe,MAAM;AACzB,WAAK,YAAY;AACjB,WAAK,MAAM,SAAS;AAAA,IACtB;AACA,aAAS,QAAQ,iBAAiB,SAAS,YAAY;AAGvD,iBAAa,sCAA4B;AAAA,MACvC;AAAA,MACA,UAAU;AAAA;AAAA,MACV;AAAA,MACA;AAAA,MACA,SAAS,WAAW,CAAC;AAAA,IACvB,CAAQ;AAER,QAAI;AACF,WAAK,YAAY;AACjB,WAAK,MAAM,SAAS;AACpB,WAAK,MAAM,QAAQ;AACnB,WAAK,MAAM,iBAAiB;AAG5B,UAAI,SAAS,QAAQ,SAAS;AAC5B,cAAM,IAAI;AAAA,UACR;AAAA,UACA,EAAE,QAAQ,QAAQ,OAAO,UAAU,0BAA0B;AAAA,QAC/D;AAAA,MACF;AAGA,UAAI,SAAS,QAAQ;AACnB,YAAI;AACF,gBAAM,gBAAgB,KAAK,MAAM,QAAQ,OAAO,OAAO;AAEvD,cAAI,KAAK,MAAM,eAAe;AAC5B,mBAAO,OAAO,KAAK,MAAM,eAAe;AAAA,cACtC,cAAc;AAAA,YAChB,CAAC;AAAA,UACH;AAAA,QACF,SAAS,OAAO;AACd,kBAAQ,MAAM,mCAAmC,KAAK;AAAA,QACxD;AAAA,MACF;AAGA,mBAAa,wCAA6B;AAAA,QACxC;AAAA,QACA;AAAA,QACA;AAAA,QACA,OAAO,KAAK;AAAA,MACd,CAAQ;AAGR,YAAM,UAAU,MAAM,KAAK,iBAAiB,OAAO,OAAO,OAAO;AAGjE,UAAI,SAAS,QAAQ,SAAS;AAC5B,cAAM,IAAI;AAAA,UACR;AAAA,UACA,EAAE,QAAQ,QAAQ,OAAO,UAAU,0BAA0B;AAAA,QAC/D;AAAA,MACF;AAGA,YAAM,SAAU,MAAM,KAAK;AAAA,QACzB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAGA,UAAI,SAAS,QAAQ,SAAS;AAC5B,cAAM,IAAI;AAAA,UACR;AAAA,UACA,EAAE,QAAQ,QAAQ,OAAO,UAAU,0BAA0B;AAAA,QAC/D;AAAA,MACF;AAGA,UACE,UACA,OAAO,YACN,OAAO,SAAiB,YAAY,aACrC;AAEA,qBAAa,wCAA6B;AAAA,UACxC;AAAA,UACA,UAAU;AAAA;AAAA,UACV;AAAA,UACA;AAAA,UACA,eACE,KAAK,IAAI,KAAK,KAAK,MAAM,cAAc,QAAQ,KAAK,KAAK,IAAI;AAAA,QACjE,CAAQ;AAAA,MACV;AAEA,WAAK,YAAY;AACjB,WAAK,MAAM,SAAS;AAEpB,aAAO;AAAA,IACT,SAAS,OAAO;AACd,YAAM,aAAa,KAAK,iBAAiB,KAAK;AAG9C,mBAAa,kCAA0B;AAAA,QACrC;AAAA,QACA,UAAU;AAAA;AAAA,QACV;AAAA,QACA,MAAM,WAAW;AAAA,QACjB,SAAS,WAAW;AAAA,QACpB,SAAU,YAAoB;AAAA,QAC9B,eACE,KAAK,IAAI,KAAK,KAAK,MAAM,cAAc,QAAQ,KAAK,KAAK,IAAI;AAAA,MACjE,CAAQ;AAER,WAAK,YAAY;AACjB,WAAK,MAAM,SAAS;AAEpB,YAAM;AAAA,IACR,UAAE;AAEA,UAAI,SAAS,QAAQ;AACnB,gBAAQ,OAAO,oBAAoB,SAAS,YAAY;AAAA,MAC1D;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,OAAO,OACL,OACA,OACA,SACmC;AACnC,UAAM,QAAQ,SAAS,aAAS,gCAAW;AAC3C,UAAM,iBAAiB,SAAS,sBAAkB,gCAAW;AAG7D,UAAM,aAA2B,CAAC;AAClC,QAAI,SAAS;AACb,QAAI,QAAsB;AAG1B,UAAM,iBAAiB,CAAC,UAAsB;AAC5C,iBAAW,KAAK,KAAK;AAAA,IACvB;AAGA,UAAM,kBAAkB,YAAY;AAClC,UAAI;AAEF,uBAAe;AAAA,UACb;AAAA,UACA,UAAU;AAAA,UACV;AAAA,QACF,CAAQ;AAGR,cAAM,UAAU,MAAM,KAAK,iBAAiB,OAAO,OAAO,OAAO;AAGjE,cAAM,gBAAgB;AAAA,UACpB,MAAM,CAAC,MAAc,UAAe,eAAe,KAAK;AAAA,UACxD,MAAM,CAAC,UAAe,eAAe,KAAK;AAAA,QAC5C;AAGA,cAAM,KAAK,iBAAiB,eAAe,SAAS,SAAS,KAAK;AAElE,iBAAS;AAAA,MACX,SAAS,KAAK;AACZ,gBAAQ,eAAe,QAAQ,MAAM,IAAI,MAAM,OAAO,GAAG,CAAC;AAC1D,iBAAS;AAGT,uBAAe;AAAA,UACb;AAAA,UACA,UAAU;AAAA,UACV;AAAA,UACA,SAAS,MAAM;AAAA,UACf,MAAM,MAAM;AAAA,UACZ,eAAe;AAAA,QACjB,CAAQ;AAAA,MACV;AAAA,IACF,GAAG;AAGH,WAAO,CAAC,UAAU,WAAW,SAAS,GAAG;AACvC,UAAI,WAAW,SAAS,GAAG;AACzB,cAAM,WAAW,MAAM;AAAA,MACzB,OAAO;AAEL,cAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,EAAE,CAAC;AAAA,MACxD;AAAA,IACF;AAGA,QAAI,OAAO;AACT,YAAM;AAAA,IACR;AAGA,UAAM;AAAA,EACR;AAAA;AAAA,EAGA,QAAyCC,OAAe;AACtD,SAAK,UAAU,aAAaA,KAAI;AAAA,EAClC;AAAA,EAEA,WAAW,UAA2B;AACpC,WAAO,KAAK,UAAU,eAAe,QAAQ;AAAA,EAC/C;AAAA,EAEA,QAAQ,UAAqD;AAC3D,WAAO,KAAK,UAAU,QAAQ,QAAQ;AAAA,EACxC;AAAA,EAEA,WAAoC;AAClC,WAAO,KAAK,UAAU,YAAY;AAAA,EACpC;AAAA,EAEA,eAAuB;AACrB,WAAO,KAAK,UAAU,aAAa;AAAA,EACrC;AAAA;AAAA,EAGA,QAAQ,UAA2B;AACjC,WAAO,KAAK,UAAU,QAAQ,QAAQ;AAAA,EACxC;AAAA,EAEA,eAAyB;AACvB,WAAO,KAAK,UAAU,aAAa;AAAA,EACrC;AAAA,EAEA,4BAAqD;AACnD,WAAO,KAAK,UAAU,0BAA0B;AAAA,EAClD;AAAA,EAEA,MAAM,YACJ,UACA,OACA,SACkB;AAClB,WAAO,KAAK,UAAU;AAAA,MACpB;AAAA,MACA;AAAA,MACA;AAAA,MACA,KAAK,MAAM;AAAA,IACb;AAAA,EACF;AAAA,EAEA,kBAAkB,UAAkB,OAAyB;AAC3D,WAAO,KAAK,UAAU,kBAAkB,UAAU,KAAK;AAAA,EACzD;AAAA,EAEA,gBAAgB,UAAkB;AAChC,WAAO,KAAK,UAAU,gBAAgB,QAAQ;AAAA,EAChD;AAAA;AAAA,EAGA,MAAM,mBAAmB,QAAiB,QAA4B;AAEpE,UAAM,IAAI,MAAM,6CAA6C;AAAA,EAC/D;AAAA,EAEA,MAAM,gBAAgB,gBAAsC;AAE1D,UAAM,IAAI,MAAM,6CAA6C;AAAA,EAC/D;AAAA,EAEA,MAAM,mBAAmB,gBAAuC;AAE9D,UAAM,IAAI,MAAM,6CAA6C;AAAA,EAC/D;AAAA;AAAA,EAGA,WAA+B;AAC7B,WAAO,EAAE,GAAG,KAAK,MAAM;AAAA,EACzB;AAAA,EAEA,SAAS,OAA0C;AACjD,SAAK,QAAQ,EAAE,GAAG,KAAK,OAAO,GAAG,MAAM;AACvC,SAAK,MAAM,eAAe,oBAAI,KAAK;AAGnC,SAAK,YAAY,wCAA6B;AAAA,MAC5C;AAAA,MACA,OAAO,KAAK;AAAA,MACZ,gBAAgB,KAAK,MAAM,kBAAkB;AAAA,MAC7C,OAAO,KAAK,MAAM,SAAS;AAAA,IAC7B,CAAQ;AAAA,EACV;AAAA;AAAA,EAGA,MAAM,QAAuB;AAC3B,QAAI,KAAK,WAAW;AAClB,YAAM,IAAI,MAAM,0BAA0B;AAAA,IAC5C;AACA,SAAK,YAAY;AACjB,SAAK,MAAM,SAAS;AAAA,EACtB;AAAA,EAEA,MAAM,QAAuB;AAC3B,QAAI,CAAC,KAAK,WAAW;AACnB,YAAM,IAAI,MAAM,sBAAsB;AAAA,IACxC;AACA,SAAK,WAAW;AAChB,SAAK,MAAM,SAAS;AAGpB,SAAK,YAAY,gDAAiC;AAAA,MAChD;AAAA,MACA,QAAQ;AAAA,MACR,gBAAgB,KAAK,MAAM,kBAAkB;AAAA,MAC7C,OAAO,KAAK,MAAM,SAAS;AAAA,IAC7B,CAAQ;AAAA,EACV;AAAA,EAEA,MAAM,OAAO,YAAiC;AAC5C,QAAI,CAAC,KAAK,UAAU;AAClB,YAAM,IAAI,MAAM,qBAAqB;AAAA,IACvC;AACA,SAAK,WAAW;AAChB,SAAK,MAAM,SAAS;AAGpB,SAAK,YAAY,kDAAkC;AAAA,MACjD;AAAA,MACA;AAAA,MACA,gBAAgB,KAAK,MAAM,kBAAkB;AAAA,MAC7C,OAAO,KAAK,MAAM,SAAS;AAAA,IAC7B,CAAQ;AAAA,EACV;AAAA,EAEA,MAAM,OAAsB;AAC1B,SAAK,YAAY;AACjB,SAAK,WAAW;AAChB,SAAK,MAAM,SAAS;AAAA,EACtB;AAAA;AAAA,EAGA,GAAwB,OAAU,SAAoC;AACpE,SAAK,YAAY,GAAG,OAAO,OAAO;AAAA,EACpC;AAAA,EAEA,IAAyB,OAAU,SAAoC;AACrE,SAAK,YAAY,IAAI,OAAO,OAAO;AAAA,EACrC;AAAA;AAAA,EAGQ,kBAAsC;AAC5C,WAAO;AAAA,MACL,eAAe,KAAK,OAAO,YACvB,IAAK,KAAK,OAAO,UAAkB,IAClC,CAAC;AAAA,MACN,SAAS,CAAC;AAAA,MACV,QAAQ;AAAA,MACR,cAAc,oBAAI,KAAK;AAAA,IACzB;AAAA,EACF;AAAA,EAEQ,0BAAyC;AAC/C,QAAI,OAAO,KAAK,OAAO,UAAU,UAAU;AAEzC,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AACA,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EAEQ,kBAAwB;AAC9B,QAAI,KAAK,OAAO,OAAO;AACrB,iBAAWA,SAAQ,KAAK,OAAO,OAAO;AACpC,aAAK,UAAU,aAAaA,KAAI;AAAA,MAClC;AAAA,IACF;AAAA,EACF;AAAA,EAEQ,2BAAiC;AAEvC,SAAK,YAAY,gCAAwB,CAAC,UAAU;AAClD,cAAQ,MAAM,gBAAgB,MAAM,OAAO;AAAA,IAC7C,CAAC;AAAA,EACH;AAAA,EAEA,MAAc,iBACZ,OACA,OACA,SAC6B;AAC7B,UAAM,QAAQ,SAAS,aAAS,gCAAW;AAC3C,UAAM,iBAAiB,SAAS,sBAAkB,gCAAW;AAG7D,QAAI,WAAW,MAAM,KAAK,wBAAwB,cAAc;AAGhE,UAAM,kBACJ,OAAO,UAAU,WACb;AAAA,MACA,KAAK;AAAA,QACH;AAAA,QACA;AAAA,QACA;AAAA,QACA,KAAK,MAAM;AAAA,QACX,EAAE,OAAO,QAAQ,SAAS,OAAO;AAAA,MACnC;AAAA,IACF,IACE;AAGN,UAAM,KAAK,YAAY,gBAAgB,iBAAiB,KAAK,MAAM,aAAuB;AAC1F,eAAW,MAAM,KAAK,wBAAwB,cAAc;AAG5D,QAAI,SAAS,QAAQ;AACnB,UAAI;AACF,cAAM,gBAAgB,KAAK,MAAM,QAAQ,OAAO,OAAO;AACvD,cAAM,gBAAgB,KAAK;AAAA,UACzB;AAAA,UACA,WAAW,KAAK,UAAU,aAAa,CAAC;AAAA,UACxC;AAAA,UACA,KAAK,MAAM;AAAA,UACX,EAAE,OAAO,QAAQ,SAAS,OAAO;AAAA,QACnC;AACA,cAAM,KAAK,YAAY,gBAAgB,CAAC,aAAa,GAAG,KAAK,MAAM,aAAuB;AAC1F,mBAAW,MAAM,KAAK,wBAAwB,cAAc;AAAA,MAC9D,SAAS,OAAO;AACd,gBAAQ,MAAM,mCAAmC,KAAK;AAAA,MACxD;AAAA,IACF;AAGA,UAAM,eAAe,KAAK,yBAAyB,QAAQ;AAG3D,QAAI,gBAAgB,OAAO,iBAAiB,UAAU;AACpD,UAAI,KAAK,MAAM,eAAe;AAC5B,eAAO,OAAO,KAAK,MAAM,eAAsB,YAAmB;AAAA,MACpE,OAAO;AACL,aAAK,MAAM,gBAAgB;AAAA,MAC7B;AAAA,IACF;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA,QAAQ,SAAS;AAAA,MACjB,eAAW,gCAAW;AAAA,MACtB;AAAA,MACA,OAAO;AAAA,MACP,UAAU,SAAS;AAAA,IACrB;AAAA,EACF;AAAA;AAAA,EAGQ,UAAU,cAAmB,OAAkB;AACrD,QAAI,aAAa,MAAM;AAErB,mBAAa,KAAK,KAAK;AAAA,IACzB,OAAO;AAEL,mBAAa,KAAK,MAAM,MAAM,KAAK;AAAA,IACrC;AAAA,EACF;AAAA;AAAA,EAGA,MAAc,iBACZ,cACA,SACA,SACA,eAAwB,MACc;AACtC,QAAI;AACF,aAAO,MAAM,KAAK,cAAc;AAAA,QAC9B;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,YAAM,KAAK,iBAAiB,KAAK;AAAA,IACnC;AAAA,EACF;AAAA,EAEQ,iBAAiB,OAAwB;AAC/C,WAAO,IAAI;AAAA,MACT,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MACrD,EAAE,eAAe,MAAM;AAAA,MACvB,iBAAiB,QAAQ,QAAQ;AAAA,IACnC;AAAA,EACF;AAAA;AAAA,EAGA,IAAI,OAAe;AACjB,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EAEA,IAAI,cAAkC;AACpC,WAAO,KAAK,OAAO;AAAA,EACrB;AAAA,EAEA,IAAI,WAAoB;AACtB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,IAAI,gBAAyB;AAC3B,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA,EAKO,cAAmB;AAExB,UAAM,EAAE,aAAAC,aAAY,IAAI;AACxB,WAAOA,aAAY,IAAI;AAAA,EACzB;AAAA;AAAA,EAGO,UAAgB;AAErB,SAAK,YAAY,mBAAmB;AAAA,EACtC;AACF;;;Ae3tBA,IAAAC,aAAkB;AAIX,SAAS,kBAAkB,OAA0C;AAC1E,SAAO,OAAO,UAAU,YAAY,UAAU,QAAQ,CAAC,MAAM,QAAQ,KAAK;AAC5E;AAEO,SAAS,mBAAmB,OAA2C;AAC5E,SACE,OAAO,UAAU,YAChB,OAAO,UAAU,YAAY,UAAU,QACxC,MAAM,QAAQ,KAAK;AAEvB;AAGO,IAAM,wBAAwB,aAAE,OAAO,aAAE,OAAO,GAAG,aAAE,QAAQ,CAAC;AAC9D,IAAM,yBAAyB,aAAE,MAAM;AAAA,EAC5C,aAAE,OAAO;AAAA,EACT,aAAE,OAAO,aAAE,OAAO,GAAG,aAAE,QAAQ,CAAC;AAAA,EAChC,aAAE,MAAM,aAAE,QAAQ,CAAC;AACrB,CAAC;AAGM,SAAS,cACd,OACA,QACG;AACH,MAAI,CAAC,kBAAkB,KAAK,GAAG;AAC7B,UAAM,IAAI,MAAM,uCAAuC;AAAA,EACzD;AAEA,MAAI,QAAQ;AACV,WAAO,OAAO,MAAM,KAAK;AAAA,EAC3B;AAEA,SAAO;AACT;AAGO,SAAS,eACd,OACA,QACG;AACH,MAAI,CAAC,mBAAmB,KAAK,GAAG;AAC9B,UAAM,IAAI,MAAM,wCAAwC;AAAA,EAC1D;AAEA,MAAI,QAAQ;AACV,WAAO,OAAO,MAAM,KAAK;AAAA,EAC3B;AAEA,SAAO;AACT;AAGO,IAAM,cAAN,MAAM,aAAY;AAAA,EAGvB,OAAO,cAA2B;AAChC,QAAI,CAAC,aAAY,UAAU;AACzB,mBAAY,WAAW,IAAI,aAAY;AAAA,IACzC;AACA,WAAO,aAAY;AAAA,EACrB;AAAA;AAAA,EAGA,UAAa,OAAgB,UAA8B;AACzD,YAAQ,UAAU;AAAA,MAChB,KAAK;AACH,eAAO,OAAO,UAAU;AAAA,MAC1B,KAAK;AACH,eAAO,OAAO,UAAU;AAAA,MAC1B,KAAK;AACH,eAAO,OAAO,UAAU;AAAA,MAC1B,KAAK;AACH,eAAO,OAAO,UAAU,YAAY,UAAU;AAAA,MAChD,KAAK;AACH,eAAO,MAAM,QAAQ,KAAK;AAAA,MAC5B,KAAK;AACH,eAAO,OAAO,UAAU;AAAA,MAC1B;AACE,eAAO;AAAA,IACX;AAAA,EACF;AAAA;AAAA,EAGA,wBACE,KACA,cACA,eAAyB,CAAC,GACM;AAChC,QAAI,CAAC,kBAAkB,GAAG,GAAG;AAC3B,aAAO;AAAA,IACT;AAEA,UAAM,OAAO,OAAO,KAAK,GAAG;AAG5B,eAAW,OAAO,cAAc;AAC9B,UAAI,CAAC,KAAK,SAAS,GAAG,GAAG;AACvB,eAAO;AAAA,MACT;AAAA,IACF;AAGA,eAAW,OAAO,MAAM;AACtB,UAAI,CAAC,aAAa,SAAS,GAAG,KAAK,CAAC,aAAa,SAAS,GAAG,GAAG;AAC9D,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,iBAAiB,OAAgB,cAA+B;AAC9D,QAAI;AACF,cAAQ,cAAc;AAAA,QACpB,KAAK;AACH,iBAAO,kBAAkB,KAAK;AAAA,QAChC,KAAK;AACH,iBAAO,mBAAmB,KAAK;AAAA,QACjC;AACE,iBAAO,KAAK,UAAU,OAAO,YAAY;AAAA,MAC7C;AAAA,IACF,QAAQ;AACN,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAGO,SAAS,oBACd,cACG;AACH,MAAI,CAAC,kBAAkB,YAAY,GAAG;AACpC,UAAM,IAAI,MAAM,gDAAgD;AAAA,EAClE;AACA,SAAO;AACT;AAEO,SAAS,qBACd,QACG;AACH,MAAI,CAAC,mBAAmB,MAAM,GAAG;AAC/B,UAAM,IAAI,MAAM,0CAA0C;AAAA,EAC5D;AACA,SAAO;AACT;AAGO,SAAS,cACd,aACA,cACA;AACA,SAAO,SACL,QACA,aACA,YACA;AACA,UAAM,iBAAiB,WAAW;AAElC,eAAW,QAAQ,YAAa,MAAa;AAE3C,UAAI,eAAe,KAAK,SAAS,GAAG;AAClC,cAAM,WAAW,KAAK,CAAC;AACvB,YAAI,aAAa,UAAa,aAAa,MAAM;AAC/C,wBAAc,UAAU,WAAW;AAAA,QACrC;AAAA,MACF;AAGA,YAAM,SAAS,eAAe,MAAM,MAAM,IAAI;AAG9C,UAAI,gBAAgB,kBAAkB,SAAS;AAC7C,eAAO,OAAO,KAAK,CAAC,WAAW;AAC7B,cAAI,WAAW,UAAa,WAAW,MAAM;AAC3C,mBAAO,eAAe,QAAQ,YAAY;AAAA,UAC5C;AACA,iBAAO;AAAA,QACT,CAAC;AAAA,MACH,WAAW,gBAAgB,WAAW,UAAa,WAAW,MAAM;AAClE,eAAO,eAAe,QAAQ,YAAY;AAAA,MAC5C;AAEA,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACF;AAGO,IAAM,cAAc,YAAY,YAAY;;;ACtLnD;;;ACdA,IAAAC,iBAA6B;AA6FtB,IAAM,uBAAN,cAAmC,4BAAa;AAAA,EAOrD,YAAY,UAA2C,CAAC,GAAG;AACzD,UAAM;AAPR,SAAQ,aAAwC,CAAC;AAEjD,SAAQ,qBAAqB,oBAAI,IAAmB;AAEpD,SAAQ,eAAe;AAIrB,SAAK,gBAAgB,GAAI;AAEzB,SAAK,UAAU;AAAA,MACb,WAAW;AAAA,MACX,cAAc;AAAA;AAAA,MACd,uBAAuB;AAAA,MACvB,gBAAgB;AAAA,MAChB,uBAAuB;AAAA,MACvB,GAAG;AAAA,IACL;AAAA,EACF;AAAA;AAAA,EAGA,KAA0B,OAAU,MAA6B;AAC/D,UAAM,YAAY,KAAK,IAAI;AAC3B,UAAM,WAAW,KAAK,iBAAiB,KAAK;AAE5C,UAAM,eAAgC;AAAA,MACpC,MAAM;AAAA,MACN,MAAM,EAAE,GAAG,MAAM,UAAU;AAAA,MAC3B;AAAA,MACA;AAAA,IACF;AAEA,QAAI,KAAK,QAAQ,gBAAgB;AAC/B,WAAK,WAAW,YAAY;AAC5B,aAAO;AAAA,IACT,OAAO;AACL,aAAO,KAAK,wBAAwB,YAAY;AAAA,IAClD;AAAA,EACF;AAAA,EAEQ,WAAgC,OAA8B;AAEpE,UAAM,cAAc,KAAK,WAAW,UAAU,OAAK,EAAE,WAAW,MAAM,QAAQ;AAC9E,QAAI,gBAAgB,IAAI;AACtB,WAAK,WAAW,KAAK,KAAK;AAAA,IAC5B,OAAO;AACL,WAAK,WAAW,OAAO,aAAa,GAAG,KAAK;AAAA,IAC9C;AAGA,QAAI,KAAK,WAAW,UAAU,KAAK,QAAQ,WAAW;AACpD,WAAK,aAAa;AAAA,IACpB,WAAW,CAAC,KAAK,YAAY;AAE3B,WAAK,aAAa,WAAW,MAAM;AACjC,aAAK,aAAa;AAAA,MACpB,GAAG,KAAK,QAAQ,YAAY;AAAA,IAC9B;AAAA,EACF;AAAA,EAEA,MAAc,eAA8B;AAC1C,QAAI,KAAK,YAAY;AACnB,mBAAa,KAAK,UAAU;AAC5B,WAAK,aAAa;AAAA,IACpB;AAEA,QAAI,KAAK,WAAW,WAAW,EAAG;AAElC,UAAM,QAAQ,KAAK,WAAW,OAAO,GAAG,KAAK,QAAQ,SAAS;AAE9D,QAAI,KAAK,QAAQ,uBAAuB;AAEtC,WAAK,kBAAkB,KAAK;AAAA,IAC9B,OAAO;AAEL,WAAK,iBAAiB,KAAK;AAAA,IAC7B;AAAA,EACF;AAAA,EAEA,MAAc,kBAAkB,OAAiD;AAE/E,QAAI,KAAK,mBAAmB,QAAQ,KAAK,QAAQ,uBAAuB;AAEtE,WAAK,WAAW,QAAQ,GAAG,KAAK;AAChC;AAAA,IACF;AAEA,UAAM,oBAAoB,KAAK,iBAAiB,KAAK;AACrD,SAAK,mBAAmB,IAAI,iBAAiB;AAE7C,QAAI;AACF,YAAM;AAAA,IACR,UAAE;AACA,WAAK,mBAAmB,OAAO,iBAAiB;AAAA,IAClD;AAAA,EACF;AAAA,EAEA,MAAc,iBAAiB,OAAiD;AAE9E,UAAM,eAAe,oBAAI,IAA0C;AAEnE,eAAW,SAAS,OAAO;AACzB,UAAI,CAAC,aAAa,IAAI,MAAM,IAAI,GAAG;AACjC,qBAAa,IAAI,MAAM,MAAM,CAAC,CAAC;AAAA,MACjC;AACA,mBAAa,IAAI,MAAM,IAAI,EAAG,KAAK,KAAK;AAAA,IAC1C;AAGA,UAAM,WAA4B,CAAC;AAEnC,eAAW,CAAC,WAAW,MAAM,KAAK,cAAc;AAC9C,YAAM,WAAW,KAAK,UAAU,SAAS;AAEzC,iBAAW,WAAW,UAAU;AAC9B,mBAAW,SAAS,QAAQ;AAC1B,cAAI;AACF,kBAAM,SAAS,QAAQ,MAAM,IAAI;AACjC,gBAAI,kBAAkB,SAAS;AAC7B,uBAAS,KAAK,MAAM;AAAA,YACtB;AAAA,UACF,SAAS,OAAO;AACd,oBAAQ,MAAM,8BAA8B,SAAS,KAAK,KAAK;AAAA,UACjE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAGA,QAAI,SAAS,SAAS,GAAG;AACvB,YAAM,QAAQ,WAAW,QAAQ;AAAA,IACnC;AAAA,EACF;AAAA,EAEQ,wBAA6C,OAAiC;AACpF,QAAI;AACF,aAAO,MAAM,KAAK,MAAM,MAAM,MAAM,IAAI;AAAA,IAC1C,SAAS,OAAO;AACd,cAAQ,MAAM,wBAAwB,MAAM,IAAI,KAAK,KAAK;AAC1D,aAAO;AAAA,IACT;AAAA,EACF;AAAA,EAEQ,iBAAiB,WAA8B;AAErD,UAAM,aAAwC;AAAA,MAC5C,CAAC,mBAAe,GAAG;AAAA,MACnB,CAAC,6BAAoB,GAAG;AAAA,MACxB,CAAC,2CAA2B,GAAG;AAAA,MAC/B,CAAC,yCAA0B,GAAG;AAAA,MAC9B,CAAC,2CAA2B,GAAG;AAAA,MAC/B,CAAC,+BAAqB,GAAG;AAAA,MACzB,CAAC,iCAAsB,GAAG;AAAA,MAC1B,CAAC,uCAAyB,GAAG;AAAA,MAC7B,CAAC,mCAAuB,GAAG;AAAA,MAC3B,CAAC,yCAA0B,GAAG;AAAA,MAC9B,CAAC,iCAAsB,GAAG;AAAA,MAC1B,CAAC,6CAA4B,GAAG;AAAA,MAChC,CAAC,yCAA0B,GAAG;AAAA,MAC9B,CAAC,iDAA8B,GAAG;AAAA,MAClC,CAAC,2CAA2B,GAAG;AAAA,MAC/B,CAAC,iDAA8B,GAAG;AAAA,MAClC,CAAC,iDAA8B,GAAG;AAAA,MAClC,CAAC,iDAA8B,GAAG;AAAA,MAClC,CAAC,mDAA+B,GAAG;AAAA,MACnC,CAAC,qCAAwB,GAAG;AAAA,MAC5B,CAAC,2CAA2B,GAAG;AAAA,IACjC;AAEA,WAAO,WAAW,SAAS,KAAK;AAAA,EAClC;AAAA;AAAA,EAGA,GAAwB,OAAU,SAAgC;AAChE,WAAO,MAAM,GAAG,OAAO,OAAO;AAAA,EAChC;AAAA;AAAA,EAGA,KAA0B,OAAU,SAAgC;AAClE,WAAO,MAAM,KAAK,OAAO,OAAO;AAAA,EAClC;AAAA;AAAA,EAGA,wBAIE;AACA,WAAO;AAAA,MACL,WAAW,KAAK,WAAW;AAAA,MAC3B,oBAAoB,KAAK,mBAAmB;AAAA,MAC5C,cAAc,KAAK;AAAA,IACrB;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,QAAuB;AAC3B,QAAI,KAAK,YAAY;AACnB,mBAAa,KAAK,UAAU;AAC5B,WAAK,aAAa;AAAA,IACpB;AAEA,WAAO,KAAK,WAAW,SAAS,GAAG;AACjC,YAAM,KAAK,aAAa;AAAA,IAC1B;AAGA,UAAM,QAAQ,WAAW,MAAM,KAAK,KAAK,kBAAkB,CAAC;AAAA,EAC9D;AAAA;AAAA,EAGA,UAAgB;AACd,QAAI,KAAK,YAAY;AACnB,mBAAa,KAAK,UAAU;AAAA,IAC9B;AAEA,SAAK,aAAa,CAAC;AACnB,SAAK,mBAAmB,MAAM;AAC9B,SAAK,mBAAmB;AAAA,EAC1B;AACF;AAGO,SAAS,2BAA2B,SAAiE;AAC1G,SAAO,IAAI,qBAAqB,OAAO;AACzC;AAGO,IAAM,uBAAuB,IAAI,qBAAqB;;;AChMtD,IAAe,oBAAf,MAA0D;AAAA,EAI/D,YAAY,QAA6B;AACvC,SAAK,SAAS;AACd,SAAK,eAAe,OAAO,gBAAgB,KAAK,gBAAgB;AAAA,EAClE;AAAA;AAAA,EAgBA,gBAAyB;AACvB,WAAO;AAAA,EACT;AAAA,EAEA,oBAA6B;AAC3B,WAAO;AAAA,EACT;AAAA,EAEA,eAAe,QAAsB;AACnC,WAAO,CAAC,EAAE,OAAO,UAAU,OAAO,OAAO,KAAK,EAAE,SAAS;AAAA,EAC3D;AAAA;AAAA,EAGU,YAAY,SAAiB,MAAkC,SAAmC;AAC1G,UAAM,QAAQ,IAAI,MAAM,OAAO;AAC/B,UAAM,OAAO;AAEb,QAAI,SAAS;AACX,UAAI,QAAQ,WAAW,QAAQ,QAAQ,QAAQ,OAAO;AAEpD,cAAM,UAAU;AAAA,MAClB,OAAO;AAEL,cAAM,UAAU;AAAA,UACd,SAAS,QAAQ,WAAW;AAAA,UAC5B,MAAM,QAAQ,QAAQ;AAAA,UACtB,OAAO,QAAQ,SAAS;AAAA,QAC1B;AAAA,MACF;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA,EAEA,MAAgB,UACd,WACA,aAAqB,KAAK,OAAO,cAAc,GAC/C,QAAgB,KAAK,OAAO,cAAc,KAC9B;AACZ,QAAI;AAEJ,aAAS,UAAU,GAAG,WAAW,YAAY,WAAW;AACtD,UAAI;AACF,eAAO,MAAM,UAAU;AAAA,MACzB,SAAS,OAAO;AACd,oBAAY;AAGZ,YAAI,iBAAiB,SAAS,KAAK,oBAAoB,KAAK,GAAG;AAE7D,gBAAMC,cAAa,IAAI,MAAM,MAAM,OAAO;AAC1C,UAAAA,YAAW,OAAO,MAAM;AACxB,UAAAA,YAAW,QAAQ,MAAM;AACzB,gBAAMA;AAAA,QACR;AAGA,YAAI,YAAY,YAAY;AAC1B;AAAA,QACF;AAGA,cAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,QAAQ,KAAK,IAAI,GAAG,OAAO,CAAC,CAAC;AAAA,MAChF;AAAA,IACF;AAGA,UAAM,aAAa,IAAI,MAAM,UAAW,OAAO;AAC/C,eAAW,OAAO,UAAW;AAC7B,eAAW,QAAQ,UAAW;AAC9B,UAAM;AAAA,EACR;AAAA,EAEU,oBAAoB,OAAuB;AAEnD,UAAM,oBAAoB,CAAC,kBAAkB,iBAAiB;AAC9D,WAAO,kBAAkB,SAAU,MAA6B,IAAI;AAAA,EACtE;AAAA,EAEU,eAAe,UAA4B;AACnD,WAAO,SAAS,IAAI,SAAO;AACzB,YAAM,YAAiB;AAAA,QACrB,MAAM,IAAI;AAAA,QACV,SAAS,IAAI;AAAA,MACf;AAGA,UAAI,IAAI,aAAa,IAAI,UAAU,SAAS,GAAG;AAC7C,kBAAU,aAAa,IAAI;AAAA,MAC7B;AAGA,UAAI,IAAI,SAAS,UAAU,IAAI,YAAY;AACzC,kBAAU,eAAe,IAAI;AAAA,MAC/B;AAEA,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AAAA,EAEU,cAAc,UAA0B;AAChD,UAAM,WAAsB,CAAC;AAE7B,QAAI,SAAS,WAAW,SAAS,QAAQ,SAAS,GAAG;AACnD,YAAM,SAAS,SAAS,QAAQ,CAAC;AACjC,UAAI,OAAO,SAAS;AAClB,iBAAS,KAAK;AAAA,UACZ,IAAI,SAAS,MAAM,OAAO,KAAK,IAAI,CAAC;AAAA,UACpC,MAAM,OAAO,QAAQ;AAAA,UACrB,SAAS,OAAO,QAAQ,WAAW;AAAA,UACnC,WAAW,OAAO,QAAQ;AAAA,UAC1B,WAAW,oBAAI,KAAK;AAAA,QACtB,CAAC;AAAA,MACH;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;AAGO,IAAM,wBAAN,MAA4B;AAAA,EAA5B;AACL,SAAQ,YAAY,oBAAI,IAA2B;AAAA;AAAA;AAAA,EAInD,SAAS,MAAc,UAA+B;AACpD,SAAK,UAAU,IAAI,MAAM,QAAQ;AACjC,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,WAAW,MAAuB;AAChC,WAAO,KAAK,UAAU,OAAO,IAAI;AAAA,EACnC;AAAA;AAAA,EAGA,IAAI,MAAyC;AAC3C,WAAO,KAAK,UAAU,IAAI,IAAI;AAAA,EAChC;AAAA;AAAA,EAGA,SAAqC;AACnC,WAAO,IAAI,IAAI,KAAK,SAAS;AAAA,EAC/B;AAAA;AAAA,EAGA,WAAW,MAAoB;AAC7B,QAAI,CAAC,KAAK,UAAU,IAAI,IAAI,GAAG;AAC7B,YAAM,IAAI,MAAM,aAAa,IAAI,qBAAqB;AAAA,IACxD;AACA,SAAK,kBAAkB;AACvB,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,aAAwC;AACtC,QAAI,KAAK,iBAAiB;AACxB,aAAO,KAAK,UAAU,IAAI,KAAK,eAAe;AAAA,IAChD;AACA,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,YAAsB;AACpB,WAAO,MAAM,KAAK,KAAK,UAAU,KAAK,CAAC;AAAA,EACzC;AAAA;AAAA,EAGA,IAAI,MAAuB;AACzB,WAAO,KAAK,UAAU,IAAI,IAAI;AAAA,EAChC;AAAA;AAAA,EAGA,QAAc;AACZ,SAAK,UAAU,MAAM;AACrB,SAAK,kBAAkB;AAAA,EACzB;AACF;AAGO,IAAM,wBAAwB,IAAI,sBAAsB;;;ACjV/D,oBAAmB;AA6BZ,IAAM,iBAAN,cAA6B,kBAA2C;AAAA,EAI7E,YAAY,QAA8B;AACxC,UAAM,MAAM;AACZ,SAAK,SAAS;AAEd,QAAI,CAAC,KAAK,eAAe,MAAM,GAAG;AAChC,YAAM,KAAK,YAAY,gCAAgC,mBAAmB,MAAM;AAAA,IAClF;AAEA,SAAK,SAAS,IAAI,cAAAC,QAAO;AAAA,MACvB,QAAQ,OAAO;AAAA,MACf,SAAS,OAAO;AAAA,MAChB,cAAc,OAAO;AAAA,MACrB,SAAS,OAAO;AAAA,MAChB,SAAS,OAAO,WAAW;AAAA,MAC3B,cAAc,OAAO;AAAA,IACvB,CAAC;AAAA,EACH;AAAA,EAEA,IAAI,OAAO;AACT,WAAO;AAAA,MACL,aAAa;AAAA,QACX,QAAQ,KAAK,iBAAiB,KAAK,IAAI;AAAA,QACvC,QAAQ,KAAK,aAAa,KAAK,IAAI;AAAA,MACrC;AAAA,IACF;AAAA,EACF;AAAA,EAEA,kBAA0B;AACxB,WAAO;AAAA,EACT;AAAA,EAEA,kBAA0B;AACxB,WAAO,KAAK,OAAO,gBAAgB;AAAA,EACrC;AAAA,EAEA,eAAe,QAAsB;AACnC,WAAO,MAAM,eAAe,MAAM,KAC3B,OAAO,OAAO,WAAW,YACzB,OAAO,OAAO,SAAS;AAAA,EAChC;AAAA,EAEA,YAAY,OAAgC;AAC1C,WAAO;AAAA,EACT;AAAA,EAEA,eAAe,UAAsC;AACnD,UAAM,YAAwB,CAAC;AAE/B,QAAI,SAAS,WAAW,SAAS,QAAQ,SAAS,GAAG;AACnD,YAAM,SAAS,SAAS,QAAQ,CAAC;AACjC,UAAI,OAAO,QAAQ,YAAY;AAC7B,mBAAW,YAAY,OAAO,QAAQ,YAAY;AAChD,oBAAU,KAAK;AAAA,YACb,IAAI,SAAS;AAAA,YACb,UAAU;AAAA,cACR,MAAM,SAAS,SAAS;AAAA,cACxB,WAAW,SAAS,SAAS;AAAA,YAC/B;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,MAAM,iBAAiB,QAAuD;AAC5E,QAAI;AACF,YAAM,eAAe,KAAK,sBAAsB,MAAM;AAGtD,YAAM,iBAAsB,CAAC;AAC7B,UAAI,OAAO,QAAQ;AACjB,uBAAe,SAAS,OAAO;AAAA,MACjC;AAEA,YAAM,WAAW,MAAM,KAAK,UAAU,YAAY;AAChD,eAAO,MAAM,KAAK,OAAO,KAAK,YAAY,OAAO,cAAc,cAAc;AAAA,MAC/E,CAAC;AAGD,aAAO,KAAK,0BAA0B,QAAQ;AAAA,IAChD,SAAS,OAAO;AAEd,YAAM,aAAa,IAAI,MAAO,MAAgB,OAAO;AACrD,iBAAW,OAAQ,MAAgB;AACnC,iBAAW,QAAS,MAAgB;AACpC,YAAM,KAAK,kBAAkB,UAAU;AAAA,IACzC;AAAA,EACF;AAAA;AAAA,EAGA,OAAO,aAAa,QAAkE;AAEpF,QAAI;AACF,YAAM,eAAe,KAAK,sBAAsB,MAAM;AAGtD,YAAM,iBAAsB,CAAC;AAC7B,UAAI,OAAO,QAAQ;AACjB,uBAAe,SAAS,OAAO;AAAA,MACjC;AAEA,YAAM,SAAS,MAAM,KAAK,OAAO,KAAK,YAAY,OAAO;AAAA,QACvD,GAAG;AAAA,QACH,QAAQ;AAAA,MACV,GAAG,cAAc;AAEjB,UAAI,OAAO,iBAAiB,QAAQ;AAClC,yBAAiB,SAAS,QAAe;AACvC,gBAAM,KAAK,uBAAuB,KAAK;AAAA,QACzC;AAAA,MACF,OAAO;AACL,cAAM,IAAI,MAAM,uDAAuD;AAAA,MACzE;AAAA,IACF,SAAS,OAAO;AACd,YAAM,KAAK,kBAAkB,KAAK;AAAA,IACpC;AAAA,EACF;AAAA;AAAA,EAGQ,sBAAsB,QAAmC;AAC/D,UAAM,eAAoB;AAAA,MACxB,OAAO,OAAO;AAAA,MACd,UAAU,OAAO;AAAA;AAAA,MACjB,aAAa,OAAO;AAAA,MACpB,YAAY,OAAO;AAAA,MACnB,OAAO,OAAO;AAAA,MACd,mBAAmB,OAAO;AAAA,MAC1B,kBAAkB,OAAO;AAAA,MACzB,MAAM,OAAO;AAAA,IACf;AAGA,QAAI,OAAO,SAAS,OAAO,MAAM,SAAS,GAAG;AAC3C,mBAAa,QAAQ,KAAK,YAAY,OAAO,KAAK;AAClD,mBAAa,cAAc,OAAO,eAAe;AAAA,IACnD;AAEA,WAAO;AAAA,EACT;AAAA;AAAA,EAGQ,0BAA0B,UAA+B;AAE/D,WAAO;AAAA,MACL,IAAI,SAAS;AAAA,MACb,QAAQ,SAAS;AAAA,MACjB,SAAS,SAAS;AAAA,MAClB,OAAO,SAAS;AAAA,MAChB,SAAS,SAAS,QAAQ,IAAI,CAAC,YAAiB;AAAA,QAC9C,OAAO,OAAO;AAAA,QACd,SAAS;AAAA,UACP,MAAM,OAAO,QAAQ;AAAA,UACrB,SAAS,OAAO,QAAQ;AAAA,UACxB,YAAY,OAAO,QAAQ;AAAA,QAC7B;AAAA,QACA,eAAe,OAAO;AAAA,MACxB,EAAE;AAAA,MACF,OAAO,SAAS;AAAA,IAClB;AAAA,EACF;AAAA;AAAA,EAGQ,uBAAuB,OAAiC;AAC9D,WAAO;AAAA,MACL,IAAI,MAAM;AAAA,MACV,QAAQ,MAAM;AAAA,MACd,SAAS,MAAM;AAAA,MACf,OAAO,MAAM;AAAA,MACb,SAAS,MAAM,QAAQ,IAAI,CAAC,YAAiB;AAAA,QAC3C,OAAO,OAAO;AAAA,QACd,OAAO,OAAO;AAAA,QACd,eAAe,OAAO;AAAA,MACxB,EAAE;AAAA,IACJ;AAAA,EACF;AAAA;AAAA,EAGQ,kBAAkB,OAAgC;AACxD,QAAI,iBAAiB,OAAO;AAE1B,UAAI,MAAM,SAAS,gBAAgB,MAAM,QAAQ,SAAS,OAAO,GAAG;AAClE,eAAO,KAAK,YAAY,mBAAmB,WAAW,KAAK;AAAA,MAC7D;AAGA,UAAI,MAAM,QAAQ,SAAS,KAAK,KAAK,MAAM,QAAQ,SAAS,cAAc,GAAG;AAC3E,eAAO,KAAK,YAAY,mBAAmB,kBAAkB,KAAK;AAAA,MACpE;AAEA,UAAI,MAAM,QAAQ,SAAS,KAAK,KAAK,MAAM,QAAQ,SAAS,YAAY,GAAG;AACzE,eAAO,KAAK,YAAY,uBAAuB,cAAc,KAAK;AAAA,MACpE;AAEA,UAAI,MAAM,QAAQ,SAAS,OAAO,KAAK,MAAM,QAAQ,SAAS,SAAS,GAAG;AACxE,eAAO,KAAK,YAAY,kBAAkB,kBAAkB,KAAK;AAAA,MACnE;AAEA,UAAI,MAAM,QAAQ,SAAS,KAAK,KAAK,MAAM,QAAQ,SAAS,aAAa,GAAG;AAC1E,eAAO,KAAK,YAAY,mBAAmB,mBAAmB,KAAK;AAAA,MACrE;AAEA,UAAI,MAAM,QAAQ,SAAS,KAAK,KAAK,MAAM,QAAQ,SAAS,uBAAuB,GAAG;AACpF,eAAO,KAAK,YAAY,gBAAgB,gBAAgB,KAAK;AAAA,MAC/D;AAEA,UAAI,MAAM,QAAQ,SAAS,SAAS,GAAG;AACrC,eAAO,KAAK,YAAY,mBAAmB,WAAW,KAAK;AAAA,MAC7D;AAAA,IACF;AAEA,WAAO,KAAK;AAAA,MACV,MAAM,WAAW;AAAA,MACjB;AAAA,MACA;AAAA,QACE,SAAS,MAAM;AAAA,QACf,MAAM,MAAM;AAAA,QACZ,OAAO,MAAM;AAAA,MACf;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,qBAAwC;AAC5C,QAAI;AACF,YAAM,WAAW,MAAM,KAAK,OAAO,OAAO,KAAK;AAC/C,aAAO,SAAS,KACb,OAAO,WAAS,MAAM,GAAG,SAAS,KAAK,CAAC,EACxC,IAAI,WAAS,MAAM,EAAE;AAAA,IAC1B,SAAS,OAAO;AACd,cAAQ,KAAK,qCAAqC,KAAK;AACvD,aAAO,CAAC,SAAS,eAAe,eAAe;AAAA,IACjD;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,iBAAiB,OAAiC;AACtD,QAAI;AACF,YAAM,SAAS,MAAM,KAAK,mBAAmB;AAC7C,aAAO,OAAO,SAAS,KAAK;AAAA,IAC9B,SAAS,OAAO;AACd,cAAQ,KAAK,uCAAuC,KAAK;AACzD,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,aAAa,OAA6B;AAC9C,QAAI;AACF,YAAM,WAAW,MAAM,KAAK,OAAO,OAAO,SAAS,KAAK;AACxD,aAAO;AAAA,QACL,IAAI,SAAS;AAAA,QACb,QAAQ,SAAS;AAAA,QACjB,SAAS,SAAS;AAAA,QAClB,UAAW,SAAiB;AAAA,QAC5B,YAAa,SAAiB;AAAA,QAC9B,MAAO,SAAiB;AAAA,QACxB,QAAS,SAAiB;AAAA,MAC5B;AAAA,IACF,SAAS,OAAO;AACd,YAAM,KAAK,kBAAkB,KAAK;AAAA,IACpC;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,eAAe,QAA+C;AAGlE,UAAM,OAAO,OAAO,SAAS,IAAI,SAAO,IAAI,OAAO,EAAE,KAAK,GAAG;AAC7D,WAAO,KAAK,KAAK,KAAK,SAAS,CAAC;AAAA,EAClC;AAAA;AAAA,EAGA,MAAM,SAAS,WAAkB,SAA8B;AAC7D,QAAI;AACF,YAAM,SAAc,CAAC;AACrB,UAAI,UAAW,QAAO,aAAa,UAAU,YAAY,EAAE,MAAM,GAAG,EAAE,CAAC;AACvE,UAAI,QAAS,QAAO,WAAW,QAAQ,YAAY,EAAE,MAAM,GAAG,EAAE,CAAC;AAGjE,YAAM,IAAI,MAAM,sDAAsD;AAAA,IACxE,SAAS,OAAO;AACd,YAAM,KAAK,kBAAkB,KAAK;AAAA,IACpC;AAAA,EACF;AACF;AAGO,SAAS,qBAAqB,QAA8C;AACjF,SAAO,IAAI,eAAe,MAAM;AAClC;AAGO,SAAS,4BAA4B,QAAgB,SAAyD;AACnH,SAAO,IAAI,eAAe;AAAA,IACxB;AAAA,IACA,cAAc;AAAA,IACd,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,YAAY;AAAA,IACZ,GAAG;AAAA,EACL,CAAC;AACH;;;ACjVA,iBAAsB;AAoBf,IAAM,oBAAN,cAAgC,kBAA2C;AAAA,EAIhF,YAAY,QAAiC;AAC3C,UAAM,MAAM;AACZ,SAAK,SAAS;AAEd,QAAI,CAAC,KAAK,eAAe,MAAM,GAAG;AAChC,YAAM,KAAK,YAAY,mCAAmC,mBAAmB,MAAM;AAAA,IACrF;AAEA,SAAK,SAAS,IAAI,WAAAC,QAAU;AAAA,MAC1B,QAAQ,OAAO;AAAA,MACf,SAAS,OAAO;AAAA,MAChB,SAAS,OAAO,WAAW;AAAA,IAC7B,CAAC;AAAA,EACH;AAAA,EAEA,IAAI,OAAO;AACT,WAAO;AAAA,MACL,aAAa;AAAA,QACX,QAAQ,KAAK,iBAAiB,KAAK,IAAI;AAAA,QACvC,QAAQ,KAAK,aAAa,KAAK,IAAI;AAAA,MACrC;AAAA,IACF;AAAA,EACF;AAAA,EAEA,kBAA0B;AACxB,WAAO;AAAA,EACT;AAAA,EAEA,kBAA0B;AACxB,WAAO,KAAK,OAAO,gBAAgB;AAAA,EACrC;AAAA,EAEA,eAAe,QAAsB;AACnC,WAAO,MAAM,eAAe,MAAM,KAC3B,OAAO,OAAO,WAAW,YACzB,OAAO,OAAO,SAAS;AAAA,EAChC;AAAA,EAEA,YAAY,OAAgC;AAC1C,WAAO,MAAM,IAAI,CAAAC,WAAS;AAAA,MACxB,MAAM;AAAA,MACN,UAAU;AAAA,QACR,MAAMA,MAAK;AAAA,QACX,aAAaA,MAAK;AAAA,QAClB,YAAYA,MAAK,UAAU,CAAC;AAAA,MAC9B;AAAA,IACF,EAAE;AAAA,EACJ;AAAA,EAEA,eAAe,UAAsC;AACnD,UAAM,YAAwB,CAAC;AAE/B,QAAI,SAAS,WAAW,SAAS,QAAQ,SAAS,GAAG;AACnD,YAAM,SAAS,SAAS,QAAQ,CAAC;AACjC,UAAI,OAAO,QAAQ,YAAY;AAC7B,mBAAW,YAAY,OAAO,QAAQ,YAAY;AAChD,oBAAU,KAAK;AAAA,YACb,IAAI,SAAS;AAAA,YACb,UAAU;AAAA,cACR,MAAM,SAAS,SAAS;AAAA,cACxB,WAAW,SAAS,SAAS;AAAA,YAC/B;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,MAAM,iBAAiB,QAAuD;AAC5E,QAAI;AACF,YAAM,kBAAkB,KAAK,yBAAyB,MAAM;AAG5D,YAAM,iBAAsB,CAAC;AAC7B,UAAI,OAAO,QAAQ;AACjB,uBAAe,SAAS,OAAO;AAAA,MACjC;AAEA,YAAM,WAAW,MAAM,KAAK,UAAU,YAAY;AAChD,eAAO,MAAM,KAAK,OAAO,SAAS,OAAO,iBAAiB,cAAc;AAAA,MAC1E,CAAC;AAED,aAAO,KAAK,6BAA6B,UAAU,OAAO,KAAK;AAAA,IACjE,SAAS,OAAO;AAEd,YAAM,aAAa,IAAI,MAAO,MAAgB,OAAO;AACrD,iBAAW,OAAQ,MAAgB;AACnC,iBAAW,QAAS,MAAgB;AACpC,YAAM,KAAK,qBAAqB,UAAU;AAAA,IAC5C;AAAA,EACF;AAAA;AAAA,EAGA,OAAO,aAAa,QAAkE;AACpF,QAAI;AACF,YAAM,kBAAkB,KAAK,yBAAyB,MAAM;AAC5D,sBAAgB,SAAS;AAGzB,YAAM,iBAAsB,CAAC;AAC7B,UAAI,OAAO,QAAQ;AACjB,uBAAe,SAAS,OAAO;AAAA,MACjC;AAEA,YAAM,SAAS,MAAM,KAAK,OAAO,SAAS,OAAO,iBAAiB,cAAc;AAEhF,UAAI,OAAO,iBAAiB,QAAQ;AAClC,yBAAiB,SAAS,QAAe;AACvC,gBAAM,KAAK,0BAA0B,OAAO,OAAO,KAAK;AAAA,QAC1D;AAAA,MACF,OAAO;AACL,cAAM,IAAI,MAAM,0DAA0D;AAAA,MAC5E;AAAA,IACF,SAAS,OAAO;AACd,YAAM,KAAK,qBAAqB,KAAK;AAAA,IACvC;AAAA,EACF;AAAA;AAAA,EAGQ,yBAAyB,QAAmC;AAClE,UAAM,kBAAuB;AAAA,MAC3B,OAAO,OAAO;AAAA,MACd,YAAY,OAAO,cAAc;AAAA,MACjC,aAAa,OAAO;AAAA,MACpB,OAAO,OAAO;AAAA,MACd,gBAAgB,OAAO;AAAA,IACzB;AAGA,UAAM,iBAA2B,CAAC;AAClC,UAAM,WAAkB,CAAC;AAEzB,eAAW,WAAW,OAAO,UAAU;AACrC,UAAI,QAAQ,SAAS,UAAU;AAC7B,uBAAe,KAAK,QAAQ,OAAO;AAAA,MACrC,OAAO;AACL,iBAAS,KAAK;AAAA,UACZ,MAAM,QAAQ,SAAS,cAAc,cAAc;AAAA,UACnD,SAAS,QAAQ;AAAA,QACnB,CAAC;AAAA,MACH;AAAA,IACF;AAEA,QAAI,eAAe,SAAS,GAAG;AAC7B,sBAAgB,SAAS,eAAe,KAAK,IAAI;AAAA,IACnD;AAEA,oBAAgB,WAAW;AAG3B,QAAI,OAAO,SAAS,OAAO,MAAM,SAAS,GAAG;AAC3C,sBAAgB,QAAQ,KAAK,YAAY,OAAO,KAAK;AAAA,IACvD;AAEA,WAAO;AAAA,EACT;AAAA;AAAA,EAGQ,6BAA6B,UAAe,OAA+B;AACjF,UAAM,SAAS;AAAA,MACb,OAAO;AAAA,MACP,SAAS;AAAA,QACP,MAAM;AAAA,QACN,SAAS,SAAS,QAAQ,CAAC,GAAG,QAAQ;AAAA,QACtC,YAAY,SAAS,QAClB,OAAO,CAAC,SAAc,KAAK,SAAS,UAAU,EAC9C,IAAI,CAAC,UAAe;AAAA,UACnB,IAAI,KAAK;AAAA,UACT,UAAU;AAAA,YACR,MAAM,KAAK;AAAA,YACX,WAAW,KAAK,UAAU,KAAK,KAAK;AAAA,UACtC;AAAA,QACF,EAAE;AAAA,MACN;AAAA,MACA,eAAe,KAAK,gBAAgB,SAAS,WAAW;AAAA,IAC1D;AAEA,WAAO;AAAA,MACL,IAAI,SAAS;AAAA,MACb,QAAQ;AAAA,MACR,SAAS,KAAK,IAAI;AAAA,MAClB;AAAA,MACA,SAAS,CAAC,MAAM;AAAA,MAChB,OAAO;AAAA,QACL,eAAe,SAAS,OAAO,gBAAgB;AAAA,QAC/C,mBAAmB,SAAS,OAAO,iBAAiB;AAAA,QACpD,eAAe,SAAS,OAAO,gBAAgB,MAAM,SAAS,OAAO,iBAAiB;AAAA,MACxF;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGQ,0BAA0B,OAAY,OAAoC;AAChF,UAAM,SAAS;AAAA,MACb,OAAO;AAAA,MACP,OAAO;AAAA,QACL,SAAS,MAAM,OAAO,QAAQ;AAAA,QAC9B,MAAM;AAAA,MACR;AAAA,MACA,eAAe,MAAM,SAAS,iBAAiB,SAAS;AAAA,IAC1D;AAEA,WAAO;AAAA,MACL,IAAI,MAAM,MAAM,SAAS,KAAK,IAAI,CAAC;AAAA,MACnC,QAAQ;AAAA,MACR,SAAS,KAAK,IAAI;AAAA,MAClB;AAAA,MACA,SAAS,CAAC,MAAa;AAAA,IACzB;AAAA,EACF;AAAA;AAAA,EAGQ,gBAAgB,YAAyE;AAC/F,YAAQ,YAAY;AAAA,MAClB,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT,KAAK;AACH,eAAO;AAAA,MACT;AACE,eAAO;AAAA,IACX;AAAA,EACF;AAAA;AAAA,EAGQ,qBAAqB,OAAgC;AAC3D,QAAI,iBAAiB,OAAO;AAE1B,UAAI,MAAM,SAAS,gBAAgB,MAAM,QAAQ,SAAS,OAAO,GAAG;AAClE,eAAO,KAAK,YAAY,mBAAmB,WAAW,KAAK;AAAA,MAC7D;AAGA,UAAI,MAAM,QAAQ,SAAS,KAAK,KAAK,MAAM,QAAQ,SAAS,cAAc,GAAG;AAC3E,eAAO,KAAK,YAAY,mBAAmB,kBAAkB,KAAK;AAAA,MACpE;AAEA,UAAI,MAAM,QAAQ,SAAS,KAAK,KAAK,MAAM,QAAQ,SAAS,YAAY,GAAG;AACzE,eAAO,KAAK,YAAY,uBAAuB,cAAc,KAAK;AAAA,MACpE;AAEA,UAAI,MAAM,QAAQ,SAAS,OAAO,KAAK,MAAM,QAAQ,SAAS,SAAS,GAAG;AACxE,eAAO,KAAK,YAAY,kBAAkB,kBAAkB,KAAK;AAAA,MACnE;AAEA,UAAI,MAAM,QAAQ,SAAS,KAAK,KAAK,MAAM,QAAQ,SAAS,aAAa,GAAG;AAC1E,eAAO,KAAK,YAAY,mBAAmB,mBAAmB,KAAK;AAAA,MACrE;AAEA,UAAI,MAAM,QAAQ,SAAS,KAAK,KAAK,MAAM,QAAQ,SAAS,uBAAuB,GAAG;AACpF,eAAO,KAAK,YAAY,gBAAgB,gBAAgB,KAAK;AAAA,MAC/D;AAEA,UAAI,MAAM,QAAQ,SAAS,SAAS,GAAG;AACrC,eAAO,KAAK,YAAY,mBAAmB,WAAW,KAAK;AAAA,MAC7D;AAAA,IACF;AAEA,WAAO,KAAK;AAAA,MACV,MAAM,WAAW;AAAA,MACjB;AAAA,MACA;AAAA,QACE,SAAS,MAAM;AAAA,QACf,MAAM,MAAM;AAAA,QACZ,OAAO,MAAM;AAAA,MACf;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,qBAAwC;AAE5C,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,iBAAiB,OAAiC;AACtD,UAAM,SAAS,MAAM,KAAK,mBAAmB;AAC7C,WAAO,OAAO,SAAS,KAAK;AAAA,EAC9B;AAAA;AAAA,EAGA,MAAM,aAAa,OAA6B;AAE9C,WAAO;AAAA,MACL,IAAI;AAAA,MACJ,QAAQ;AAAA,MACR,SAAS,KAAK,IAAI;AAAA,MAClB,UAAU;AAAA,IACZ;AAAA,EACF;AAAA;AAAA,EAGA,MAAM,eAAe,QAA+C;AAElE,UAAM,OAAO,OAAO,SAAS,IAAI,SAAO,IAAI,OAAO,EAAE,KAAK,GAAG;AAC7D,WAAO,KAAK,KAAK,KAAK,SAAS,CAAC;AAAA,EAClC;AAAA;AAAA,EAGA,MAAM,SAAS,WAAkB,SAA8B;AAC7D,UAAM,KAAK,YAAY,gDAAgD,iBAAiB;AAAA,EAC1F;AACF;AAGO,SAAS,wBAAwB,QAAoD;AAC1F,SAAO,IAAI,kBAAkB,MAAM;AACrC;AAGO,SAAS,+BAA+B,QAAgB,SAA+D;AAC5H,SAAO,IAAI,kBAAkB;AAAA,IAC3B;AAAA,IACA,cAAc;AAAA,IACd,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,YAAY;AAAA,IACZ,GAAG;AAAA,EACL,CAAC;AACH;;;AC9UO,IAAM,kBAAN,MAAsD;AAAA,EAG3D,YAAY,WAAkC,uBAAuB;AACnE,SAAK,WAAW;AAAA,EAClB;AAAA;AAAA,EAGA,aAAa,QAA4C;AACvD,UAAM,eAAqC;AAAA,MACzC,GAAG;AAAA;AAAA,MAEH,cAAc,OAAO,gBAAgB;AAAA,MACrC,SAAS,OAAO,WAAW;AAAA,MAC3B,YAAY,OAAO,cAAc;AAAA,MACjC,YAAY,OAAO,cAAc;AAAA,IACnC;AAEA,UAAM,WAAW,qBAAqB,YAAY;AAClD,SAAK,SAAS,SAAS,UAAU,QAAQ;AACzC,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,gBAAgB,QAA4C;AAC1D,UAAM,kBAA2C;AAAA,MAC/C,GAAG;AAAA;AAAA,MAEH,cAAc,OAAO,gBAAgB;AAAA,MACrC,SAAS,OAAO,WAAW;AAAA,MAC3B,YAAY,OAAO,cAAc;AAAA,MACjC,YAAY,OAAO,cAAc;AAAA,IACnC;AAEA,UAAM,WAAW,wBAAwB,eAAe;AACxD,SAAK,SAAS,SAAS,aAAa,QAAQ;AAC5C,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,aAAa,QAAuE;AAClF,UAAM,EAAE,cAAc,GAAG,WAAW,IAAI;AAExC,YAAQ,aAAa,YAAY,GAAG;AAAA,MAClC,KAAK;AACH,eAAO,KAAK,aAAa,UAAU;AAAA,MACrC,KAAK;AACH,eAAO,KAAK,gBAAgB,UAAU;AAAA,MACxC;AACE,cAAM,IAAI,MAAM,8BAA8B,YAAY,EAAE;AAAA,IAChE;AAAA,EACF;AAAA;AAAA,EAGA,cAAc,eAAuB,UAAyB;AAC5D,UAAM,SAA8B;AAAA,MAClC,QAAQ,KAAK,iBAAiB,YAAY;AAAA,MAC1C,SAAS,KAAK,kBAAkB,YAAY;AAAA,MAC5C,cAAc,KAAK,uBAAuB,YAAY;AAAA,MACtD,SAAS,KAAK,kBAAkB;AAAA,MAChC,YAAY,KAAK,qBAAqB;AAAA,MACtC,YAAY,KAAK,qBAAqB;AAAA,IACxC;AAEA,WAAO,KAAK,aAAa,EAAE,GAAG,QAAQ,aAAa,CAAC;AAAA,EACtD;AAAA;AAAA,EAGQ,iBAAiB,cAA8B;AACrD,UAAM,SAAS,aAAa,YAAY,IAAI;AAC5C,UAAM,SAAS,QAAQ,IAAI,MAAM;AAEjC,QAAI,CAAC,QAAQ;AACX,YAAM,IAAI,MAAM,8CAA8C,MAAM,EAAE;AAAA,IACxE;AAEA,WAAO;AAAA,EACT;AAAA;AAAA,EAGQ,kBAAkB,cAA0C;AAClE,UAAM,SAAS,aAAa,YAAY,IAAI;AAC5C,WAAO,QAAQ,IAAI,MAAM;AAAA,EAC3B;AAAA;AAAA,EAGQ,uBAAuB,cAA0C;AACvE,UAAM,SAAS,aAAa,YAAY,IAAI;AAC5C,WAAO,QAAQ,IAAI,MAAM;AAAA,EAC3B;AAAA;AAAA,EAGQ,oBAAwC;AAC9C,UAAM,UAAU,QAAQ,IAAI;AAC5B,WAAO,UAAU,SAAS,SAAS,EAAE,IAAI;AAAA,EAC3C;AAAA;AAAA,EAGQ,uBAA2C;AACjD,UAAM,aAAa,QAAQ,IAAI;AAC/B,WAAO,aAAa,SAAS,YAAY,EAAE,IAAI;AAAA,EACjD;AAAA;AAAA,EAGQ,uBAA2C;AACjD,UAAM,aAAa,QAAQ,IAAI;AAC/B,WAAO,aAAa,SAAS,YAAY,EAAE,IAAI;AAAA,EACjD;AAAA;AAAA,EAGA,qBAAqB,QAAuE;AAC1F,SAAK,eAAe,MAAM;AAC1B,WAAO,KAAK,aAAa,MAAM;AAAA,EACjC;AAAA;AAAA,EAGQ,eAAe,QAA8D;AACnF,QAAI,CAAC,OAAO,QAAQ;AAClB,YAAM,IAAI,MAAM,qBAAqB;AAAA,IACvC;AAEA,QAAI,CAAC,OAAO,cAAc;AACxB,YAAM,IAAI,MAAM,2BAA2B;AAAA,IAC7C;AAEA,UAAM,qBAAqB,CAAC,UAAU,WAAW;AACjD,QAAI,CAAC,mBAAmB,SAAS,OAAO,aAAa,YAAY,CAAC,GAAG;AACnE,YAAM,IAAI,MAAM,8BAA8B,OAAO,YAAY,sBAAsB,mBAAmB,KAAK,IAAI,CAAC,EAAE;AAAA,IACxH;AAGA,YAAQ,OAAO,aAAa,YAAY,GAAG;AAAA,MACzC,KAAK;AACH,YAAI,CAAC,OAAO,OAAO,WAAW,KAAK,GAAG;AACpC,gBAAM,IAAI,MAAM,+BAA+B;AAAA,QACjD;AACA;AAAA,MACF,KAAK;AACH,YAAI,CAAC,OAAO,OAAO,WAAW,SAAS,GAAG;AACxC,gBAAM,IAAI,MAAM,kCAAkC;AAAA,QACpD;AACA;AAAA,IACJ;AAAA,EACF;AAAA;AAAA,EAGA,cAAqC;AACnC,WAAO,KAAK;AAAA,EACd;AACF;AAGO,SAAS,8BAA6C;AAC3D,QAAM,UAAU,IAAI,gBAAgB;AACpC,SAAO,QAAQ,cAAc,QAAQ;AACvC;AAEO,SAAS,iCAAgD;AAC9D,QAAM,UAAU,IAAI,gBAAgB;AACpC,SAAO,QAAQ,cAAc,WAAW;AAC1C;AAEO,SAAS,yBAAyB,QAQvB;AAChB,QAAM,UAAU,IAAI,gBAAgB;AACpC,SAAO,QAAQ,aAAa;AAAA,IAC1B,cAAc,OAAO;AAAA,IACrB,QAAQ,OAAO;AAAA,IACf,SAAS,OAAO;AAAA,IAChB,cAAc,OAAO;AAAA,IACrB,SAAS,OAAO;AAAA,IAChB,YAAY,OAAO;AAAA,IACnB,YAAY,OAAO;AAAA,EACrB,CAAC;AACH;AAGO,SAAS,yBAAyB,QAAgB,SAAuD;AAC9G,QAAM,UAAU,IAAI,gBAAgB;AAEpC,MAAI,OAAO,WAAW,KAAK,KAAK,CAAC,OAAO,WAAW,SAAS,GAAG;AAE7D,WAAO,QAAQ,aAAa;AAAA,MAC1B;AAAA,MACA,GAAG;AAAA,IACL,CAAC;AAAA,EACH,WAAW,OAAO,WAAW,SAAS,GAAG;AAEvC,WAAO,QAAQ,gBAAgB;AAAA,MAC7B;AAAA,MACA,GAAG;AAAA,IACL,CAAC;AAAA,EACH,OAAO;AACL,UAAM,IAAI,MAAM,oDAAoD;AAAA,EACtE;AACF;AAGO,IAAM,kBAAkB;AAAA;AAAA,EAE7B,QAAQ;AAAA,IACN,MAAM,CAAC,WAAmB,yBAAyB;AAAA,MACjD,MAAM;AAAA,MACN;AAAA,MACA,cAAc;AAAA,IAChB,CAAC;AAAA,IACD,WAAW,CAAC,WAAmB,yBAAyB;AAAA,MACtD,MAAM;AAAA,MACN;AAAA,MACA,cAAc;AAAA,IAChB,CAAC;AAAA,IACD,YAAY,CAAC,WAAmB,yBAAyB;AAAA,MACvD,MAAM;AAAA,MACN;AAAA,MACA,cAAc;AAAA,IAChB,CAAC;AAAA,EACH;AAAA;AAAA,EAGA,WAAW;AAAA,IACT,aAAa,CAAC,WAAmB,yBAAyB;AAAA,MACxD,MAAM;AAAA,MACN;AAAA,MACA,cAAc;AAAA,IAChB,CAAC;AAAA,IACD,eAAe,CAAC,WAAmB,yBAAyB;AAAA,MAC1D,MAAM;AAAA,MACN;AAAA,MACA,cAAc;AAAA,IAChB,CAAC;AAAA,IACD,cAAc,CAAC,WAAmB,yBAAyB;AAAA,MACzD,MAAM;AAAA,MACN;AAAA,MACA,cAAc;AAAA,IAChB,CAAC;AAAA,EACH;AACF;AAGO,IAAM,kBAAkB,IAAI,gBAAgB;;;AC3QnD,IAAAC,aAAkB;AAGlB,yBAAqD;AASrD,SAAS,WACP,MACA,aACA,SAIA,SAIA;AACA,MAAI,CAAC,QAAQ,OAAO,SAAS,UAAU;AACrC,UAAM,IAAI,oBAAoB,sCAAsC;AAAA,EACtE;AAEA,MAAI,CAAC,eAAe,OAAO,gBAAgB,UAAU;AACnD,UAAM,IAAI;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAEA,MAAI,CAAC,WAAW,OAAO,YAAY,YAAY;AAC7C,UAAM,IAAI,oBAAoB,iCAAiC;AAAA,EACjE;AAEA,aAAO,yBAAK,SAAgB;AAAA,IAC1B;AAAA,IACA;AAAA,IACA,QAAQ,SAAS,UAAW,aAAE,OAAO,CAAC,CAAC;AAAA,IACvC,kBAAkB,SAAS,oBAAoB;AAAA,EACjD,CAAC;AACH;AAKO,SAAS,gBAId,MACA,aACA,QACA,SAIA,SAGA;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,OACE,OACA,YACG;AAEH,YAAM,iBAAiB,OAAO,MAAM,KAAK;AACzC,aAAO,QAAQ,gBAA0B,OAAO;AAAA,IAClD;AAAA,IACA;AAAA,MACE;AAAA,MACA,kBAAkB,SAAS;AAAA,IAC7B;AAAA,EACF;AACF;AAKO,SAAS,iBAGd,MACA,aACA,SAIA,SAKuB;AACvB,QAAM,WAAW,SAAS,YAAY;AAEtC,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,OACE,OACA,YACG;AACH,YAAM,YAAY,KAAK,IAAI;AAE3B,UAAI;AACF,YAAI,aAAa,WAAW,aAAa,QAAQ;AAC/C,kBAAQ,IAAI,IAAI,IAAI,YAAY,KAAK;AAAA,QACvC;AAEA,cAAM,SAAS,MAAM,QAAQ,OAAO,OAAO;AAE3C,cAAM,gBAAgB,KAAK,IAAI,IAAI;AAEnC,YAAI,aAAa,WAAW,aAAa,QAAQ;AAC/C,kBAAQ,IAAI,IAAI,IAAI,aAAa,MAAM;AACvC,kBAAQ,IAAI,IAAI,IAAI,qBAAqB,aAAa,IAAI;AAAA,QAC5D;AAEA,eAAO;AAAA,MACT,SAAS,OAAO;AACd,cAAM,gBAAgB,KAAK,IAAI,IAAI;AAEnC,YAAI,aAAa,WAAW,aAAa,QAAQ;AAC/C,kBAAQ,MAAM,IAAI,IAAI,iBAAiB,aAAa,OAAO,KAAK;AAAA,QAClE;AAEA,cAAM;AAAA,MACR;AAAA,IACF;AAAA,IACA;AAAA,EACF;AACF;AAKO,SAAS,gBAGd,MACA,aACA,SAIA,SAOuB;AACvB,QAAM,aAAa,SAAS,cAAc;AAC1C,QAAM,aAAa,SAAS,cAAc;AAC1C,QAAM,iBAAiB,SAAS,mBAAmB,MAAM;AAEzD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,OACE,OACA,YACG;AACH,UAAI;AAEJ,eAAS,UAAU,GAAG,WAAW,YAAY,WAAW;AACtD,YAAI;AACF,iBAAO,MAAM,QAAQ,OAAO,OAAO;AAAA,QACrC,SAAS,OAAO;AACd,sBAAY,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC;AAEpE,cAAI,YAAY,cAAc,CAAC,eAAe,SAAS,GAAG;AACxD,kBAAM;AAAA,UACR;AAGA,gBAAM,IAAI;AAAA,YAAQ,CAAC,YACjB,WAAW,SAAS,cAAc,UAAU,EAAE;AAAA,UAChD;AAAA,QACF;AAAA,MACF;AAEA,YAAM;AAAA,IACR;AAAA,IACA;AAAA,EACF;AACF;AAKO,SAAS,kBAGd,MACA,aACA,SAIA,SAKuB;AACvB,QAAM,UAAU,SAAS,WAAW;AAEpC,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,OACE,OACA,YACG;AACH,aAAO,QAAQ,KAAK;AAAA,QAClB,QAAQ,OAAO,OAAO;AAAA,QACtB,IAAI,QAAQ,CAAC,GAAG,WAAW;AACzB,qBAAW,MAAM;AACf,mBAAO,IAAI,MAAM,SAAS,IAAI,qBAAqB,OAAO,IAAI,CAAC;AAAA,UACjE,GAAG,OAAO;AAAA,QACZ,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAAA,IACA;AAAA,EACF;AACF;AAKO,SAAS,oBAGd,MACA,aACA,OACA,SAIuB;AACvB,QAAM,gBAAgB,SAAS,iBAAiB;AAEhD,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,OACE,OACA,YACG;AACH,UAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AACzB,cAAM,IAAI;AAAA,UACR;AAAA,QACF;AAAA,MACF;AAEA,YAAM,UAAqB,CAAC;AAE5B,UAAI,kBAAkB,YAAY;AAChC,cAAM,WAAW,MAAM,IAAI,OAAO,cAAmB;AACnD,gBAAM,WAAW,UAAU;AAC3B,gBAAMC,QAAO,MAAM,KAAK,CAAC,MAAM,EAAE,SAAS,QAAQ;AAElD,cAAI,CAACA,OAAM;AACT,kBAAM,IAAI,MAAM,SAAS,QAAQ,+BAA+B;AAAA,UAClE;AAEA,cAAI,CAACA,MAAK,QAAQ;AAChB,kBAAM,IAAI;AAAA,cACR,SAAS,QAAQ;AAAA,YACnB;AAAA,UACF;AAEA,iBAAOA,MAAK,OAAO,UAAU,OAAO,OAAO;AAAA,QAC7C,CAAC;AAED,cAAM,kBAAkB,MAAM,QAAQ,IAAI,QAAQ;AAClD,gBAAQ,KAAK,GAAG,eAAe;AAAA,MACjC,OAAO;AACL,mBAAW,aAAa,OAAO;AAC7B,gBAAM,WAAW,UAAU;AAC3B,gBAAMA,QAAO,MAAM,KAAK,CAAC,MAAM,EAAE,SAAS,QAAQ;AAElD,cAAI,CAACA,OAAM;AACT,kBAAM,IAAI,MAAM,SAAS,QAAQ,+BAA+B;AAAA,UAClE;AAEA,cAAI,CAACA,MAAK,QAAQ;AAChB,kBAAM,IAAI;AAAA,cACR,SAAS,QAAQ;AAAA,YACnB;AAAA,UACF;AAEA,gBAAM,SAAS,MAAMA,MAAK,OAAO,UAAU,OAAO,OAAO;AACzD,kBAAQ,KAAK,MAAM;AAAA,QACrB;AAAA,MACF;AAEA,aAAO;AAAA,IACT;AAAA,IACA;AAAA,MACE,kBACE,SAAS,oBAAoB,MAAM,KAAK,CAAC,MAAM,EAAE,gBAAgB;AAAA,IACrE;AAAA,EACF;AACF;;;AC1TA,IAAAC,sBAA2B;AAMpB,IAAM,sBAAN,MAA4E;AAAA,EAA5E;AACL,SAAO,gBAAwC,oBAAI,IAAI;AACvD,SAAQ,eAAoC,oBAAI,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA,EAKpD,uBACE,MACA,SACA,gBACA,SAMS;AACT,UAAM,eAAe,KAAK,aAAa,IAAI,cAAc,KAAM,CAAC;AAEhE,WAAO;AAAA,MACL,QAAI,gCAAW;AAAA,MACf;AAAA,MACA;AAAA,MACA,WAAW,oBAAI,KAAK;AAAA,MACpB,WAAW,SAAS;AAAA,MACpB,YAAY,SAAS;AAAA,MACrB,UAAU;AAAA,QACR,OAAO,KAAK,UAAU,YAAY;AAAA,QAClC;AAAA,QACA,OAAO,SAAS;AAAA,QAChB,QAAQ,SAAS;AAAA,MACnB;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,yBAAyB,UAA6B;AACpD,UAAM,cAAc,SAAS,SAAS,SAAS,CAAC;AAChD,QAAI,aAAa,UAAU,OAAO;AAChC,aAAO,YAAY,SAAS;AAAA,IAC9B;AACA,WAAO,CAAC;AAAA,EACV;AAAA;AAAA;AAAA;AAAA,EAKA,wBAAwB,gBAAmC;AACzD,WAAO,KAAK,cAAc,IAAI,cAAc,KAAK,CAAC;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,gBAAwB,UAA2B;AAC7D,UAAM,WAAW,KAAK,cAAc,IAAI,cAAc,KAAK,CAAC;AAC5D,SAAK,cAAc,IAAI,gBAAgB,CAAC,GAAG,UAAU,GAAG,QAAQ,CAAC;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,gBAAgC;AAC9C,WAAO,KAAK,aAAa,IAAI,cAAc,KAAM,CAAC;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,gBAAwB,cAAqC;AACvE,UAAM,UAAU,KAAK,aAAa,IAAI,cAAc,KAAM,CAAC;AAC3D,SAAK,aAAa,IAAI,gBAAgB,EAAE,GAAG,SAAS,GAAG,aAAa,CAAC;AAAA,EACvE;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB,gBAA8B;AAC9C,SAAK,cAAc,OAAO,cAAc;AACxC,SAAK,aAAa,OAAO,cAAc;AAAA,EACzC;AAAA;AAAA;AAAA;AAAA,EAKQ,UAAa,KAAW;AAC9B,QAAI,QAAQ,QAAQ,OAAO,QAAQ,UAAU;AAC3C,aAAO;AAAA,IACT;AAEA,QAAI,eAAe,MAAM;AACvB,aAAO,IAAI,KAAK,IAAI,QAAQ,CAAC;AAAA,IAC/B;AAEA,QAAI,MAAM,QAAQ,GAAG,GAAG;AACtB,aAAO,IAAI,IAAI,UAAQ,KAAK,UAAU,IAAI,CAAC;AAAA,IAC7C;AAEA,QAAI,OAAO,QAAQ,UAAU;AAC3B,YAAM,SAAS,CAAC;AAChB,iBAAW,OAAO,KAAK;AACrB,YAAI,IAAI,eAAe,GAAG,GAAG;AAC3B,iBAAO,GAAG,IAAI,KAAK,UAAU,IAAI,GAAG,CAAC;AAAA,QACvC;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AACF;;;ACvHA;AACA;;;ACEO,IAAM,aAAN,cAAyB,MAAM;AAAA,EACpC,YAAY,SAAiB;AAC3B,UAAM,OAAO;AACb,SAAK,OAAO;AAAA,EACd;AACF;AAKO,IAAM,gBAAN,cAA4B,MAAM;AAAA,EAKvC,YAAY,MAAqE,WAAoB;AACnG,UAAM,KAAK,OAAO;AAClB,SAAK,OAAO;AACZ,SAAK,OAAO,KAAK;AACjB,SAAK,UAAU,KAAK,WAAW;AAC/B,SAAK,YAAY,aAAa,KAAK;AAAA,EACrC;AAAA,EAEA,WAAmB;AACjB,QAAI,KAAK,WAAW;AAClB,aAAO,IAAI,KAAK,YAAY,IAAI,WAAW,KAAK,IAAI,aAAa,KAAK,OAAO,gBAAgB,KAAK,SAAS;AAAA,IAC7G,OAAO;AACL,aAAO,IAAI,KAAK,YAAY,IAAI,WAAW,KAAK,IAAI,aAAa,KAAK,OAAO;AAAA,IAC/E;AAAA,EACF;AACF;;;AC5BO,IAAe,OAAf,MAAoB;AAG3B;AAeO,IAAM,WAAN,cAAuB,KAAK;AAAA,EAKjC,YAAY,SAA0B;AACpC,UAAM;AACN,SAAK,WAAW,QAAQ;AACxB,SAAK,UAAU,QAAQ,WAAW;AAClC,SAAK,UAAU;AAAA,MACb,qBAAqB,QAAQ;AAAA,MAC7B,iBAAiB,UAAU,QAAQ,MAAM;AAAA,MACzC,gBAAgB;AAAA,IAClB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KAAK,MAAc,MAA2B,SAAgC;AAClF,UAAM,iBAAiB,UAAU,UAAU,MAAO,KAAK;AACvD,UAAM,MAAM,GAAG,KAAK,QAAQ,GAAG,IAAI;AAEnC,QAAI;AACF,YAAM,aAAa,IAAI,gBAAgB;AACvC,YAAM,YAAY,WAAW,MAAM,WAAW,MAAM,GAAG,cAAc;AAErE,YAAM,WAAW,MAAM,MAAM,KAAK;AAAA,QAChC,QAAQ;AAAA,QACR,SAAS,KAAK;AAAA,QACd,MAAM,KAAK,UAAU,IAAI;AAAA,QACzB,QAAQ,WAAW;AAAA,MACrB,CAAC;AAED,mBAAa,SAAS;AAEtB,UAAI,CAAC,SAAS,IAAI;AAChB,cAAM,IAAI,MAAM,uBAAuB,SAAS,MAAM,EAAE;AAAA,MAC1D;AAEA,YAAM,eAAe,MAAM,SAAS,KAAK;AAEzC,YAAM,OAAO,KAAK,MAAM,YAAY;AAEpC,UAAI,KAAK,SAAS,GAAG;AACnB,cAAM,YAAY,SAAS,QAAQ,IAAI,yBAAyB;AAChE,cAAM,IAAI,cAAc,MAAM,aAAa,MAAS;AAAA,MACtD;AAEA,aAAO,KAAK;AAAA,IACd,SAAS,OAAO;AACd,UAAI,iBAAiB,eAAe;AAClC,cAAM;AAAA,MACR;AACA,YAAM,IAAI,MAAM,mBAAmB,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK,CAAC,EAAE;AAAA,IAC7F;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,QAAc;AAAA,EAEd;AACF;;;AC/DO,IAAM,eAAN,MAAmB;AAAA,EAKxB,YAAY,SAA+B;AACzC,SAAK,kBAAkB,QAAQ;AAC/B,SAAK,iBAAiB,QAAQ;AAE9B,QAAI,QAAQ,MAAM;AAChB,WAAK,OAAO,QAAQ;AAAA,IACtB,OAAO;AACL,WAAK,OAAO,IAAI,SAAS;AAAA,QACvB,UAAU,QAAQ,YAAY;AAAA,QAC9B,QAAQ,QAAQ;AAAA,QAChB,WAAW,QAAQ;AAAA,QACnB,SAAS,QAAQ;AAAA,MACnB,CAAC;AAAA,IACH;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,QAAc;AACZ,SAAK,KAAK,MAAM;AAAA,EAClB;AAAA,EAEQ,YAAY,UAA2B;AAC7C,WAAO,YAAY,KAAK;AAAA,EAC1B;AAAA,EAEQ,WAAW,SAA0B;AAC3C,QAAI,SAAS;AACX,aAAO;AAAA,IACT;AACA,QAAI,KAAK,gBAAgB;AACvB,aAAO,KAAK;AAAA,IACd;AACA,UAAM,IAAI,WAAW,sBAAsB;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cACJ,UAII,CAAC,GACS;AACd,UAAM,cAAmC;AAAA,MACvC,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,IAC3C;AAEA,QAAI,QAAQ,SAAS,QAAW;AAC9B,kBAAY,OAAO,QAAQ;AAAA,IAC7B;AAEA,WAAO,KAAK,KAAK,KAAK,6BAA6B,WAAW;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cACJ,UAGmB,CAAC,GACN;AACd,UAAM,cAAmC;AAAA,MACvC,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,IAC3C;AAEA,QAAI,QAAQ,YAAY,QAAW;AACjC,kBAAY,WAAW,QAAQ;AAAA,IACjC;AACA,QAAI,QAAQ,UAAU,QAAW;AAC/B,kBAAY,QAAQ,QAAQ;AAAA,IAC9B;AACA,QAAI,QAAQ,WAAW,QAAW;AAChC,kBAAY,SAAS,QAAQ;AAAA,IAC/B;AAEA,WAAO,KAAK,KAAK,KAAK,4BAA4B,WAAW;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAc,SAKH;AACf,UAAM,cAAc;AAAA,MAClB,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,MACzC,YAAY,QAAQ;AAAA,MACpB,MAAM,QAAQ;AAAA,IAChB;AAEA,WAAO,KAAK,KAAK,KAAK,6BAA6B,WAAW;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAAc,SAIH;AACf,UAAM,cAAc;AAAA,MAClB,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,MACzC,YAAY,QAAQ;AAAA,IACtB;AAEA,WAAO,KAAK,KAAK,KAAK,6BAA6B,WAAW;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eACJ,SAKc;AACd,UAAM,cAAmC;AAAA,MACvC,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,MACzC,SAAS,QAAQ;AAAA,IACnB;AAEA,QAAI,QAAQ,YAAY,QAAW;AACjC,kBAAY,WAAW,QAAQ;AAAA,IACjC;AACA,QAAI,QAAQ,UAAU,QAAW;AAC/B,kBAAY,QAAQ,QAAQ;AAAA,IAC9B;AAEA,WAAO,KAAK,KAAK,KAAK,6BAA6B,WAAW;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,SAKgB;AAChC,UAAM,cAAc;AAAA,MAClB,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,MACzC,YAAY,QAAQ;AAAA,MACpB,UAAU,QAAQ;AAAA,IACpB;AAEA,WAAO,KAAK,KAAK,KAAK,2BAA2B,WAAW;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YACJ,UAKmB,CAAC,GACgC;AACpD,UAAM,cAAmC;AAAA,MACvC,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,IAC3C;AAEA,QAAI,QAAQ,cAAc,QAAW;AACnC,kBAAY,aAAa,QAAQ;AAAA,IACnC;AACA,QAAI,QAAQ,UAAU,QAAW;AAC/B,kBAAY,QAAQ,QAAQ;AAAA,IAC9B;AACA,QAAI,QAAQ,YAAY,QAAW;AACjC,kBAAY,WAAW,QAAQ;AAAA,IACjC;AACA,QAAI,QAAQ,UAAU,QAAW;AAC/B,kBAAY,QAAQ,QAAQ;AAAA,IAC9B;AACA,QAAI,QAAQ,WAAW,QAAW;AAChC,kBAAY,SAAS,QAAQ;AAAA,IAC/B;AAEA,WAAO,KAAK,KAAK,KAAK,0BAA0B,WAAW;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,SAKD;AACf,UAAM,cAAc;AAAA,MAClB,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,MACzC,YAAY,QAAQ;AAAA,MACpB,UAAU,QAAQ;AAAA,IACpB;AAEA,WAAO,KAAK,KAAK,KAAK,2BAA2B,WAAW;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAS,SAKE;AACf,UAAM,cAAc;AAAA,MAClB,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,MACzC,YAAY,QAAQ;AAAA,MACpB,OAAO,QAAQ;AAAA,IACjB;AAEA,WAAO,KAAK,KAAK,KAAK,wBAAwB,WAAW;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU,SAKC;AACf,UAAM,cAAc;AAAA,MAClB,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,MACzC,YAAY,QAAQ;AAAA,MACpB,MAAM,QAAQ;AAAA,IAChB;AAEA,WAAO,KAAK,KAAK,KAAK,wBAAwB,WAAW;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,SAIF;AACf,UAAM,cAAc;AAAA,MAClB,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,MACzC,YAAY,QAAQ;AAAA,IACtB;AAEA,WAAO,KAAK,KAAK,KAAK,4BAA4B,WAAW;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,SAKF;AACf,UAAM,cAAc;AAAA,MAClB,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,MACzC,YAAY,QAAQ;AAAA,MACpB,MAAM,QAAQ;AAAA,IAChB;AAEA,WAAO,KAAK,KAAK,KAAK,2BAA2B,WAAW;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,SAID;AACf,UAAM,cAAc;AAAA,MAClB,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,MACzC,YAAY,QAAQ;AAAA,IACtB;AAEA,WAAO,KAAK,KAAK,KAAK,0BAA0B,WAAW;AAAA,EAC7D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,SAMF;AACf,UAAM,cAAc;AAAA,MAClB,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,MACzC,YAAY,QAAQ;AAAA,MACpB,SAAS,QAAQ;AAAA,MACjB,UAAU,QAAQ;AAAA,IACpB;AAEA,WAAO,KAAK,KAAK,KAAK,4BAA4B,WAAW;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aACJ,UAMmB,CAAC,GAYnB;AACD,UAAM,cAAmC;AAAA,MACvC,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,IAC3C;AAEA,QAAI,QAAQ,cAAc,QAAW;AACnC,kBAAY,aAAa,QAAQ;AAAA,IACnC;AACA,QAAI,QAAQ,eAAe,QAAW;AACpC,kBAAY,aAAa,QAAQ;AAAA,IACnC;AACA,QAAI,QAAQ,UAAU,QAAW;AAC/B,kBAAY,QAAQ,QAAQ;AAAA,IAC9B;AACA,QAAI,QAAQ,YAAY,QAAW;AACjC,kBAAY,WAAW,QAAQ;AAAA,IACjC;AACA,QAAI,QAAQ,UAAU,QAAW;AAC/B,kBAAY,QAAQ,QAAQ;AAAA,IAC9B;AACA,QAAI,QAAQ,WAAW,QAAW;AAChC,kBAAY,SAAS,QAAQ;AAAA,IAC/B;AAEA,WAAO,KAAK,KAAK,KAAK,2BAA2B,WAAW;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,SAMF;AACf,UAAM,cAAc;AAAA,MAClB,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,MACzC,YAAY,QAAQ;AAAA,MACpB,WAAW,QAAQ;AAAA,MACnB,SAAS,QAAQ;AAAA,IACnB;AAEA,WAAO,KAAK,KAAK,KAAK,4BAA4B,WAAW;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAAa,SAKF;AACf,UAAM,cAAc;AAAA,MAClB,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,MACzC,YAAY,QAAQ;AAAA,MACpB,WAAW,QAAQ;AAAA,IACrB;AAEA,WAAO,KAAK,KAAK,KAAK,4BAA4B,WAAW;AAAA,EAC/D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cACJ,SAmBC;AACD,UAAM,cAAmC;AAAA,MACvC,WAAW,KAAK,YAAY,QAAQ,QAAQ;AAAA,MAC5C,UAAU,KAAK,WAAW,QAAQ,OAAO;AAAA,MACzC,SAAS,QAAQ;AAAA,IACnB;AAEA,QAAI,QAAQ,cAAc,QAAW;AACnC,kBAAY,aAAa,QAAQ;AAAA,IACnC;AACA,QAAI,QAAQ,eAAe,QAAW;AACpC,kBAAY,aAAa,QAAQ;AAAA,IACnC;AACA,QAAI,QAAQ,UAAU,QAAW;AAC/B,kBAAY,QAAQ,QAAQ;AAAA,IAC9B;AACA,QAAI,QAAQ,YAAY,QAAW;AACjC,kBAAY,WAAW,QAAQ;AAAA,IACjC;AACA,QAAI,QAAQ,UAAU,QAAW;AAC/B,kBAAY,QAAQ,QAAQ;AAAA,IAC9B;AAEA,WAAO,KAAK,KAAK,KAAK,4BAA4B,WAAW;AAAA,EAC/D;AACF;;;AClfO,IAAM,QAAN,MAAY;AAMnB;AAAA;AANa,MAEK,YAAY;AAAA;AAFjB,MAKK,aAAa;;;ACyBxB,IAAM,aAAN,cAAyB,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAqBzC,YACE,SAOA;AACA,UAAM,OAAO;AACb,QAAI,CAAC,QAAQ,UAAU,CAAC,QAAQ,eAAe;AAC7C,YAAM,IAAI,MAAM,iDAAiD;AAAA,IACnE;AACA,SAAK,SACH,QAAQ,UACR,IAAI,aAAa,QAAQ,aAAqC;AAChE,SAAK,YAAY,QAAQ;AACzB,SAAK,YAAY,oBAAI,IAAiB;AACtC,SAAK,WAAW,QAAQ,YAAY;AACpC,SAAK,0BAA0B,QAAQ,2BAA2B,QAAQ,aAAa,OAAO;AAAA,EAChG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,KAAK,SAAgD;AAChE,QAAI;AAEF,YAAM,cAAoD;AAAA,QACxD,WAAW,KAAK;AAAA,MAClB;AAGA,UAAI,SAAS,OAAO;AAClB,oBAAY,QAAQ,QAAQ;AAAA,MAC9B;AACA,UAAI,SAAS,QAAQ;AACnB,oBAAY,SAAS,QAAQ;AAAA,MAC/B;AAGA,UAAI,SAAS,OAAO;AAClB,oBAAY,UAAU;AAAA,UACpB,YACE,QAAQ,UAAU,SAAS,MAAM,aAAa,MAAM;AAAA,QACxD;AAAA,MACF;AAEA,YAAM,EAAE,SAAS,CAAC,GAAG,YAAY,IAC/B,MAAM,KAAK,OAAO,YAAY,WAAW;AAE3C,UAAI,eAAe,KAAK,gCAAgC,MAAM;AAG9D,UAAI,KAAK,yBAAyB;AAChC,cAAM,KAAK,cAAc;AAAA,UACvB,WAAW,KAAK;AAAA,UAChB,QAAQ;AAAA,QACV,CAAC;AAAA,MACH;AAGA,UAAI,SAAS,WAAW;AACtB,uBAAe,KAAK,aAAa;AAAA,UAC/B;AAAA,UACA,QAAQ;AAAA,QACV;AAAA,MACF;AAGA,UAAI,KAAK,UAAU;AACjB,aAAK,UAAU,IAAI,UAAU,MAAM;AACnC,aAAK,UAAU,IAAI,eAAe,WAAW;AAAA,MAC/C;AAEA,aAAO,SAAS,UAAU,SAAS,aAAa,QAAQ,IAAI;AAAA,IAC9D,SAAS,OAAO;AACd,cAAQ,MAAM,yBAAyB,KAAK;AAC5C,aAAO,CAAC;AAAA,IACV;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,IAAI,OAAqB,SAAqC;AACzE,QAAI;AACF,YAAM,KAAK,OAAO,YAAY;AAAA,QAC5B,WAAW,KAAK;AAAA,QAChB,UAAU;AAAA,UACR,MAAM,MAAM,QAAQ;AAAA,UACpB,SAAS,MAAM,QAAQ;AAAA,UACvB,UAAU;AAAA,YACR,GAAG,MAAM;AAAA,YACT,WAAW,MAAM,QAAQ;AAAA,YACzB,WAAW,MAAM,QAAQ,WAAW,YAAY;AAAA,YAChD,WAAW,MAAM,QAAQ;AAAA,YACzB,YAAY,MAAM,QAAQ;AAAA,UAC5B;AAAA,QACF;AAAA,MACF,CAAC;AACD,WAAK,UAAU,MAAM;AAAA,IACvB,SAAS,OAAO;AACd,cAAQ,MAAM,uBAAuB,KAAK;AAC1C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,QAAQ,MAAsB,SAAqC;AAE9E,UAAM,4BAA4B,KAAK;AACvC,SAAK,0BAA0B;AAE/B,QAAI;AACF,iBAAW,SAAS,MAAM;AACxB,cAAM,KAAK,IAAI,OAAO,OAAO;AAAA,MAC/B;AAAA,IACF,UAAE;AAEA,WAAK,0BAA0B;AAAA,IACjC;AAAA,EACF;AAAA;AAAA,EAIA,MAAa,OAAO,EAAE,WAAW,MAAM,GAAgD;AAAA,EAEvF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,OAAO,WAA2C;AAC7D,QAAI,OAAO,cAAc,UAAU;AAEjC,YAAM,KAAK,OAAO,YAAY;AAAA,QAC5B,WAAW,KAAK;AAAA,QAChB,SAAS;AAAA,MACX,CAAC;AACD,WAAK,UAAU,MAAM;AAAA,IACvB,OAAO;AAEL,cAAQ,KAAK,4CAA4C,SAAS;AAClE,YAAM,IAAI,MAAM,0CAA0C;AAe1D,WAAK,UAAU,MAAM;AAAA,IACvB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,SAAS,OAAyC;AAC7D,QAAI,CAAC,OAAO;AACV,aAAO,KAAK,KAAK;AAAA,IACnB;AAEA,UAAM,EAAE,SAAS,CAAC,EAAE,IAAI,MAAM,KAAK,OAAO,YAAY;AAAA,MACpD,WAAW,KAAK;AAAA,MAChB,OAAO;AAAA,QACL,SAAS;AAAA;AAAA,UAEP,KAAK;AAAA,QACP;AAAA,MACF;AAAA,IACF,CAAC;AACD,WAAO,KAAK,gCAAgC,MAAM;AAAA,EACpD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAa,UAA4B;AACvC,WAAQ,MAAM,KAAK,SAAS,MAAO;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,WAA4B;AACvC,QAAI,KAAK,YAAY,KAAK,UAAU,IAAI,aAAa,MAAM,QAAW;AACpE,aAAO,KAAK,UAAU,IAAI,aAAa;AAAA,IACzC,OAAO;AACL,YAAM,EAAE,YAAY,IAAI,MAAM,KAAK,OAAO,YAAY;AAAA,QACpD,WAAW,KAAK;AAAA,MAClB,CAAC;AACD,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,gCACN,QACgB;AAChB,WAAO,OAAO,IAAI,CAAC,WAAW;AAAA,MAC5B,SAAS;AAAA,QACP,IACE,MAAM,UAAU,aAAa,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,OAAO,GAAG,CAAC;AAAA,QACrE,MAAM,MAAM,QAAQ;AAAA,QACpB,SAAS,MAAM,WAAW;AAAA,QAC1B,WAAW,MAAM,UAAU,YACvB,IAAI,KAAK,MAAM,SAAS,SAAS,IACjC,oBAAI,KAAK;AAAA,QACb,WAAW,MAAM,UAAU;AAAA,QAC3B,YAAY,MAAM,UAAU;AAAA,MAC9B;AAAA,MACA,OAAO;AAAA,QACL,GAAG,KAAK,yBAAyB,MAAM,YAAY,CAAC,CAAC;AAAA,QACrD,GAAI,MAAM,UAAU,UAAa,EAAE,OAAO,MAAM,MAAM;AAAA,MACxD;AAAA,IACF,EAAE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,yBACN,UACqB;AACrB,UAAM,EAAE,WAAW,WAAW,WAAW,YAAY,GAAG,MAAM,IAAI;AAClE,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,gBAAgB,cAAwC;AACnE,UAAM,IAAI,MAAM,oDAAoD;AAAA,EACtE;AACF;;;ACrTO,IAAM,wBAAN,MAAM,uBAA+C;AAAA,EAK1D,YAAY,IAAS;AAJrB,SAAQ,aAAkC,CAAC;AAC3C,SAAQ,eAAsB,CAAC;AAI7B,SAAK,KAAK;AAAA,EACZ;AAAA,EAEA,MAAM,OAAe,UAA8B,OAAkB;AACnE,SAAK,WAAW,KAAK,IAAI,KAAK,cAAc,UAAU,KAAK;AAC3D,WAAO;AAAA,EACT;AAAA,EAEA,IAAI,OAAe,UAA8B,OAAkB;AAEjE,WAAO,KAAK,MAAM,OAAO,UAAU,KAAK;AAAA,EAC1C;AAAA,EAEA,GAAG,YAAmC;AACpC,SAAK,eAAe,WAAW,IAAI,CAAC,YAAY,QAAQ,MAAM,CAAC;AAC/D,WAAO;AAAA,EACT;AAAA,EAEA,GAAG,OAAe,QAAqB;AACrC,UAAM,IAAI,KAAK,GAAG;AAClB,SAAK,WAAW,KAAK,IAAI,EAAE,GAAG,MAAM;AACpC,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,OAAe,SAAiB,SAAwB;AAC5D,SAAK,WAAW,KAAK,IAAI,KAAK,GAAG,OAAO;AAAA,MACtC,QAAQ;AAAA,MACR,SAAS,WAAW;AAAA,IACtB,CAAC;AACD,WAAO;AAAA,EACT;AAAA,EAEA,QAAa;AACX,QAAI,KAAK,aAAa,SAAS,GAAG;AAChC,YAAM,IAAI,KAAK,GAAG;AAClB,aAAO,EAAE,GAAG,KAAK,YAAY;AAAA,IAC/B;AACA,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,QAAuB;AACrB,UAAM,SAAS,IAAI,uBAAsB,KAAK,EAAE;AAChD,WAAO,aAAa,EAAE,GAAG,KAAK,WAAW;AACzC,WAAO,eAAe,CAAC,GAAG,KAAK,YAAY;AAC3C,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,cAAc,UAA8B,OAAiB;AACnE,UAAM,IAAI,KAAK,GAAG;AAElB,UAAM,cAA2D;AAAA,MAC/D,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC;AAAA,MACjB,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC;AAAA,MAClB,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC;AAAA,MACjB,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC;AAAA,MACnB,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC;AAAA,MACjB,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC;AAAA,MACnB,IAAI,CAAC,MAAM,EAAE,GAAG,CAAC;AAAA,MACjB,KAAK,CAAC,MAAM,EAAE,IAAI,CAAC;AAAA,IACrB;AAGA,QAAI,aAAa,MAAM;AACrB,aAAO;AAAA,IACT;AAEA,UAAM,UAAU,YAAY,QAAQ;AACpC,WAAO,UAAU,QAAQ,KAAK,IAAI;AAAA,EACpC;AACF;AAKO,IAAM,yBAAN,MAAuD;AAAA,EAAvD;AACL,SAAQ,UAA+B,CAAC;AACxC,SAAQ,UAAoB,CAAC;AAC7B,SAAQ,aAAqC,CAAC;AAAA;AAAA,EAE9C,IAAI,OAAe,OAAkB;AACnC,SAAK,QAAQ,KAAK,IAAI;AACtB,WAAO;AAAA,EACT;AAAA,EAEA,YAAY,SAAoC;AAC9C,WAAO,OAAO,KAAK,SAAS,OAAO;AACnC,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,OAAqB;AACzB,SAAK,QAAQ,KAAK,KAAK;AACvB,WAAO;AAAA,EACT;AAAA,EAEA,UAAU,OAAe,OAAqB;AAC5C,SAAK,WAAW,KAAK,IAAI;AACzB,WAAO;AAAA,EACT;AAAA,EAEA,QAAa;AAEX,UAAM,SAA8B,EAAE,GAAG,KAAK,QAAQ;AAKtD,WAAO,QAAQ,KAAK,UAAU,EAAE,QAAQ,CAAC,CAAC,OAAO,KAAK,MAAM;AAE1D,aAAO,SAAS,KAAK,EAAE,IAAI;AAAA,IAC7B,CAAC;AAGD,SAAK,QAAQ,QAAQ,CAAC,UAAU;AAC9B,aAAO,KAAK,IAAI;AAAA,IAClB,CAAC;AAED,WAAO;AAAA,EACT;AACF;;;ACnIO,IAAM,mBAAN,MAAmD;AAAA,EACxD,YAAoB,IAAuB;AAAvB;AAAA,EAAwB;AAAA,EAE5C,cAAc,MAAmC;AAC/C,WAAO,KAAK,GAAG,WAAW,IAAI;AAAA,EAChC;AAAA,EAEA,MAAM,KACJ,YACA,OACA,SACc;AACd,QAAI,eAAe,WAAW,MAAM,KAAK;AAEzC,QAAI,SAAS,MAAM;AAEjB,YAAM,YAAY,OAAO,KAAK,QAAQ,IAAI,EAAE,CAAC;AAC7C,YAAM,YAAY,QAAQ,KAAK,SAAS,MAAM,IAAI,QAAQ;AAC1D,qBAAe,aAAa,QAAQ,WAAW,SAAS;AAAA,IAC1D;AAEA,QAAI,SAAS,MAAM;AACjB,qBAAe,aAAa,KAAK,QAAQ,IAAI;AAAA,IAC/C;AAEA,QAAI,SAAS,OAAO;AAClB,qBAAe,aAAa,MAAM,QAAQ,KAAK;AAAA,IACjD;AAEA,UAAM,SAAS,MAAM,aAAa,IAAI;AACtC,WAAO,OAAO;AAAA,EAChB;AAAA,EAEA,MAAM,QACJ,YACA,OACmB;AACnB,UAAM,SAAS,MAAM,WAAW,MAAM,KAAK,EAAE,MAAM,CAAC,EAAE,IAAI;AAC1D,WAAO,OAAO,KAAK,SAAS,IAAK,OAAO,KAAK,CAAC,IAAU;AAAA,EAC1D;AAAA,EAEA,MAAM,UACJ,YACA,UACY;AACZ,UAAM,SAAS,MAAM,WAAW,IAAI,QAAQ;AAC5C,WAAO,EAAE,KAAK,OAAO,IAAI,GAAG,SAAS;AAAA,EACvC;AAAA,EAEA,MAAM,WACJ,YACA,WACoC;AACpC,QAAI,gBAAgB;AACpB,eAAW,OAAO,WAAW;AAC3B,YAAM,WAAW,IAAI,GAAG;AACxB;AAAA,IACF;AACA,WAAO,EAAE,cAAc;AAAA,EACzB;AAAA,EAEA,MAAM,UACJ,YACA,QACA,QACoC;AAEpC,UAAM,SAAS,MAAM,WAAW,MAAM,MAAM,EAAE,MAAM,CAAC,EAAE,IAAI;AAE3D,QAAI,OAAO,KAAK,WAAW,GAAG;AAC5B,aAAO,EAAE,eAAe,EAAE;AAAA,IAC5B;AAEA,UAAM,QAAQ,OAAO,KAAK,CAAC,EAAE;AAG7B,UAAM,aAAa,EAAE,GAAG,OAAO;AAC/B,UAAM,kBAA0C,CAAC;AAEjD,WAAO,KAAK,UAAU,EAAE,QAAQ,CAAC,QAAQ;AACvC,UAAI,IAAI,WAAW,QAAQ,GAAG;AAC5B,cAAM,QAAQ,IAAI,UAAU,CAAC;AAC7B,wBAAgB,KAAK,IAAI,WAAW,GAAG;AACvC,eAAO,WAAW,GAAG;AAAA,MACvB;AAAA,IACF,CAAC;AAGD,QAAI,OAAO,KAAK,eAAe,EAAE,SAAS,GAAG;AAC3C,YAAM,aAAa,OAAO,KAAK,CAAC;AAChC,aAAO,QAAQ,eAAe,EAAE,QAAQ,CAAC,CAAC,OAAO,KAAK,MAAM;AAC1D,mBAAW,KAAK,KAAK,WAAW,KAAK,KAAK,KAAK;AAAA,MACjD,CAAC;AAAA,IACH;AAEA,UAAM,WAAW,IAAI,KAAK,EAAE,OAAO,UAAU;AAC7C,WAAO,EAAE,eAAe,EAAE;AAAA,EAC5B;AAAA,EAEA,MAAM,UACJ,YACA,QACmC;AACnC,UAAM,SAAS,MAAM,WAAW,MAAM,MAAM,EAAE,MAAM,CAAC,EAAE,IAAI;AAE3D,QAAI,OAAO,KAAK,WAAW,GAAG;AAC5B,aAAO,EAAE,cAAc,EAAE;AAAA,IAC3B;AAEA,UAAM,QAAQ,OAAO,KAAK,CAAC,EAAE;AAC7B,UAAM,WAAW,IAAI,KAAK,EAAE,OAAO;AACnC,WAAO,EAAE,cAAc,EAAE;AAAA,EAC3B;AAAA,EAEA,MAAM,WACJ,YACA,QACmC;AACnC,UAAM,SAAS,MAAM,WAAW,MAAM,MAAM,EAAE,OAAO;AACrD,WAAO,EAAE,cAAc,OAAO,WAAW,EAAE;AAAA,EAC7C;AAAA,EAEA,MAAM,MAAM,YAAiC,OAA6B;AACxE,UAAM,SAAS,MAAM,WAAW,MAAM,KAAK,EAAE,MAAM;AACnD,WAAO,OAAO;AAAA,EAChB;AAAA;AAAA,EAGA,qBAAoC;AAClC,WAAO,IAAI,sBAAsB,KAAK,EAAE;AAAA,EAC1C;AAAA,EAEA,sBAAsC;AACpC,WAAO,IAAI,uBAAuB;AAAA,EACpC;AACF;;;AC7HO,IAAMC,qBAAN,MAAsD;AAAA,EAG3D,YACU,KACA,gBACA,uBACA,qBACR;AAJQ;AACA;AACA;AACA;AAER,SAAK,UAAU,IAAI,iBAAiB,KAAK,IAAI,SAAS,CAAC;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAqC;AACnC,WAAO,KAAK,IAAI,SAAS,EAAE,WAAW,KAAK,cAAc;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA,EAKA,uBAA4C;AAC1C,WAAO,KAAK,IAAI,SAAS,EAAE,WAAW,KAAK,qBAAqB;AAAA,EAClE;AAAA;AAAA;AAAA;AAAA,EAKA,qBAA0C;AACxC,WAAO,KAAK,IAAI,SAAS,EAAE,WAAW,KAAK,mBAAmB;AAAA,EAChE;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc;AACZ,WAAO,KAAK,IAAI,SAAS;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,aAA+B;AAC7B,WAAO,KAAK;AAAA,EACd;AACF;AAOO,IAAMC,qBAAN,MAAwB;AAAA;AAAA;AAAA;AAAA,EAI7B,WACE,OACA,WACA,YACyB;AACzB,WAAO;AAAA,MACL;AAAA,MACA,WAAW,MAAM,QAAQ;AAAA,MACzB;AAAA,MACA,MAAM,MAAM,QAAQ;AAAA,MACpB,SAAS,MAAM,QAAQ;AAAA,MACvB,WAAW,MAAM,QAAQ;AAAA,MACzB,YAAY,MAAM,QAAQ;AAAA,MAC1B,OAAO,MAAM,SAAS,CAAC;AAAA,MACvB,WAAW,MAAM,QAAQ,aAAa,oBAAI,KAAK;AAAA,MAC/C,WAAW,oBAAI,KAAK;AAAA,IACtB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,KAA4C;AACvD,WAAO;AAAA,MACL,SAAS;AAAA,QACP,IAAI,IAAI;AAAA,QACR,MAAM,IAAI;AAAA,QACV,SAAS,IAAI;AAAA,QACb,WAAW,IAAI;AAAA,QACf,YAAY,IAAI;AAAA,QAChB,WAAW,IAAI;AAAA,MACjB;AAAA,MACA,OAAO,IAAI;AAAA,IACb;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,kBACE,SACA,WAC0B;AAC1B,WAAO;AAAA,MACL;AAAA,MACA,WAAW,QAAQ;AAAA,MACnB,SAAS,QAAQ;AAAA,MACjB,UAAU,QAAQ;AAAA,MAClB,WAAW,oBAAI,KAAK;AAAA,MACpB,WAAW,oBAAI,KAAK;AAAA,IACtB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,oBAAoB,KAIlB;AACA,WAAO;AAAA,MACL,IAAI,IAAI;AAAA,MACR,SAAS,IAAI;AAAA,MACb,UAAU,IAAI;AAAA,IAChB;AAAA,EACF;AACF;;;AClFO,IAAM,kBAAN,cAA8B,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0B9C,YACE,SAQA;AACA,UAAM,OAAO;AAEb,QAAI,CAAC,QAAQ,KAAK;AAChB,YAAM,IAAI,MAAM,oCAAoC;AAAA,IACtD;AAEA,SAAK,YAAY,QAAQ,aAAa;AACtC,SAAK,0BACH,QAAQ,4BAA4B,QAAQ,aAAa,OAAO;AAGlE,SAAK,oBAAoB,IAAIC;AAAA,MAC3B,QAAQ;AAAA,MACR,QAAQ,kBAAkB;AAAA,MAC1B,QAAQ,yBAAyB;AAAA,MACjC,QAAQ,uBAAuB;AAAA,IACjC;AAEA,SAAK,oBAAoB,IAAIC,mBAAkB;AAG/C,SAAK,eAAe,IAAI,aAAa,KAAK,iBAAiB;AAC3D,SAAK,gBAAgB,IAAI;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AACA,SAAK,gBAAgB,IAAI;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AACA,SAAK,iBAAiB,IAAI;AAAA,MACxB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,KAAK,SAAgD;AAChE,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,KAAK,KAAK,kBAAkB,YAAY;AAC9C,YAAM,IAAI,GAAG;AACb,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,YAAM,oBACJ,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGnD,YAAM,mBAAmB,MAAM,KAAK,cAAc;AAAA,QAChD;AAAA,QACA;AAAA,MACF;AAGA,YAAM,cAAc,MAAM,KAAK,cAAc,eAAe,GAAG;AAC/D,UAAI,aAAa;AAEjB,UAAI,aAAa;AACf,qBAAa,KAAK,cAAc;AAAA,UAC9B;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAGA,UAAI;AACJ,UAAI,WAAW,SAAS,GAAG;AACzB,yBAAiB,EAAE,GAAG,UAAU;AAAA,MAClC,OAAO;AACL,yBAAiB,WAAW,CAAC;AAAA,MAC/B;AAGA,YAAM,QAAQ,SAAS,SAAS;AAChC,YAAM,eAAoB;AAAA,QACxB,MAAM,EAAE,WAAW,UAAU,QAAQ,IAAI,GAAG;AAAA,MAC9C;AAEA,UAAI,SAAS,QAAQ;AACnB,qBAAa,OAAO,QAAQ;AAAA,MAC9B;AACA,UAAI,SAAS,OAAO;AAClB,qBAAa,QAAQ,QAAQ;AAAA,MAC/B;AAGA,YAAM,SAAS,MAAM,QAAQ;AAAA,QAC3B;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,UAAI,UAAU,UAAU,SAAS,OAAO,QAAQ,IAAI,QAAQ;AAAA,QAC1D,CAAC,QACC,KAAK,kBAAkB,aAAa,GAAG;AAAA,MAC3C;AAGA,UAAI,KAAK,2BAA2B,OAAO,SAAS,GAAG;AACrD,cAAM,MAAM,MAAM,KAAK,cAAc,EAAE,WAAW,KAAK,OAAO,CAAC;AAC/D,iBAAS,IAAI;AAAA,MACf;AAGA,UAAI,SAAS,WAAW;AACtB,iBAAS,KAAK,aAAa,aAAa,QAAQ,QAAQ,SAAS;AAAA,MACnE;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,wCAAwC,KAAK;AAC3D,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,IAAI,OAAqB,SAAqC;AACzE,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,UAAI,CAAC,MAAM,QAAQ,WAAW;AAC5B,cAAM,QAAQ,YAAY,oBAAI,KAAK;AAAA,MACrC;AAGA,YAAM,aAAa,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGpE,YAAM,MAAM,KAAK,kBAAkB,WAAW,OAAO,KAAK,UAAU;AAGpE,YAAM,QAAQ,UAAU,YAAY,GAAG;AAAA,IAEzC,SAAS,OAAO;AACd,cAAQ,MAAM,oCAAoC,KAAK;AACvD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,QACX,MACA,SACe;AAGf,eAAW,SAAS,MAAM;AACxB,YAAM,KAAK,IAAI,OAAO,OAAO;AAAA,IAC/B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,OAAO,QAGF;AAChB,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,OAAO,aAAa,KAAK;AAGrC,YAAM,QAAQ,QACX,mBAAmB,EACnB,MAAM,aAAa,MAAM,GAAG,EAC5B,IAAI,aAAa,MAAM,OAAO,MAAM,QAAQ,EAAE,EAC9C,MAAM;AAGT,YAAM,MAAM,MAAM,QAAQ;AAAA,QACxB;AAAA,QACA;AAAA,MACF;AAEA,UAAI,CAAC,KAAK;AACR,cAAM,IAAI;AAAA,UACR,yBAAyB,OAAO,MAAM,QAAQ,EAAE,2BAA2B,GAAG;AAAA,QAChF;AAAA,MACF;AAEA,YAAM,aAAa,MAAM,KAAK,cAAc,qBAAqB,GAAG;AACpE,YAAM,YAAY,KAAK,kBAAkB;AAAA,QACvC,OAAO;AAAA,QACP;AAAA,QACA;AAAA,MACF;AAGA,YAAM,SAAS,QACZ,oBAAoB,EACpB,YAAY;AAAA,QACX,GAAG;AAAA,QACH,WAAW,oBAAI,KAAK;AAAA,MACtB,CAAC,EACA,MAAM;AAGT,YAAM,QAAQ,UAAU,YAAY,OAAO,MAAM;AAAA,IACnD,SAAS,OAAO;AACd,cAAQ,MAAM,sCAAsC,KAAK;AACzD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,OACX,WACA,SACe;AACf,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAEvC,UAAI,OAAO,cAAc,UAAU;AAEjC,cAAM,QAAQ,QACX,mBAAmB,EACnB,MAAM,aAAa,MAAM,GAAG,EAC5B,IAAI,aAAa,MAAM,SAAS,EAChC,MAAM;AAET,cAAM,QAAQ,WAAW,YAAY,KAAK;AAAA,MAC5C,OAAO;AAEL,gBAAQ;AAAA,UACN;AAAA,QACF;AACA,cAAM,SAAS,MAAM,KAAK,KAAK,EAAE,WAAW,IAAI,CAAC;AACjD,YAAI,aAAa,KAAK,YAAY,OAAO,QAAQ;AAC/C,gBAAM,gBAAgB,OAAO,SAAS;AACtC,gBAAM,KAAK,OAAO,cAAc,QAAQ,IAAI,OAAO;AAAA,QACrD;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,wCAAwC,KAAK;AAC3D,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,MAAM,SAAuC;AACxD,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,kBAAkB,KAAK,kBAAkB,mBAAmB;AAClE,YAAM,oBAAoB,KAAK,kBAAkB,qBAAqB;AAEtE,UAAI,SAAS,WAAW;AAEtB,cAAM,MAAM,QAAQ;AACpB,cAAM,UAAU,KAAK,kBAAkB,WAAW;AAGlD,cAAM,SAAS,MAAM,QAAQ;AAAA,UAC3B;AAAA,UACA,EAAE,WAAW,IAAI;AAAA,UACjB,EAAE,MAAM,EAAE,WAAW,GAAG,GAAG,OAAO,EAAE;AAAA,QACtC;AAEA,YAAI,OAAO,SAAS,GAAG;AACrB,gBAAM,YAAY,OAAO,CAAC;AAE1B,gBAAM,KAAK,cAAc,eAAe,KAAK,UAAU,SAAS;AAAA,QAClE;AAGA,cAAM,QAAQ,WAAW,mBAAmB,EAAE,WAAW,IAAI,CAAC;AAAA,MAChE,OAAO;AAEL,cAAM,UAAU,KAAK,kBAAkB,WAAW;AAGlD,cAAM,QAAQ,WAAW,YAAY,CAAC,CAAC;AACvC,cAAM,QAAQ,WAAW,iBAAiB,CAAC,CAAC;AAC5C,cAAM,QAAQ,WAAW,mBAAmB,CAAC,CAAC;AAAA,MAChD;AAGA,WAAK,aAAa,WAAW;AAAA,IAC/B,SAAS,OAAO;AACd,cAAQ,MAAM,yCAAyC,KAAK;AAC5D,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,QAAQ,SAAoD;AACvE,WAAQ,MAAM,KAAK,SAAS,OAAO,MAAO;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,SAAS,SAAmD;AACvE,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,KAAK,KAAK,kBAAkB,YAAY;AAC9C,YAAM,IAAI,GAAG;AACb,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,YAAM,oBACJ,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGnD,YAAM,mBAAmB,MAAM,KAAK,cAAc;AAAA,QAChD;AAAA,QACA;AAAA,MACF;AAGA,YAAM,cAAc,MAAM,KAAK,cAAc,eAAe,GAAG;AAC/D,UAAI,aAAa;AAEjB,UAAI,aAAa;AACf,qBAAa,KAAK,cAAc;AAAA,UAC9B;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAGA,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,UAAI;AACJ,UAAI,WAAW,SAAS,GAAG;AACzB,yBAAiB,EAAE,GAAG,UAAU;AAAA,MAClC,OAAO;AACL,yBAAiB,WAAW,CAAC;AAAA,MAC/B;AAEA,YAAM,QAAQ,MAAM,QAAQ,MAAM,YAAY,cAAc;AAC5D,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,uCAAuC,KAAK;AAC1D,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,SACX,OACA,SACyB;AACzB,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,KAAK,KAAK,kBAAkB,YAAY;AAC9C,YAAM,IAAI,GAAG;AACb,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,YAAM,cAAc,MAAM,KAAK,cAAc,eAAe,GAAG;AAG/D,UAAI,iBAAsB;AAAA,QACxB,WAAW;AAAA,QACX,SAAS,GAAG,OAAO;AAAA,UACjB,QAAQ;AAAA,UACR,SAAS;AAAA;AAAA,QACX,CAAC;AAAA,MACH;AAGA,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,UAAI,aAAa;AACf,cAAM,eAAe,QAAQ,mBAAmB;AAChD,cAAM,kBAAkB,aAAa,MAAM,aAAa,MAAM,WAAW,EAAE,MAAM;AACjF,yBAAiB,EAAE,GAAG,gBAAgB,GAAG,gBAAgB;AAAA,MAC3D;AAEA,YAAM,SAAS,MAAM,QAAQ;AAAA,QAC3B;AAAA,QACA;AAAA,MACF;AAEA,aAAO,OAAO;AAAA,QAAI,CAAC,QACjB,KAAK,kBAAkB,aAAa,GAAG;AAAA,MACzC;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,2CAA2C,KAAK;AAC9D,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAa,aAAa,WAAkD;AAC1E,UAAM,YAAY,MAAM,KAAK,eAAe,aAAa,SAAS;AAGlE,WAAO,UAAU,IAAI,UAAQ;AAAA,MAC3B,SAAS,IAAI;AAAA,MACb,OAAO;AAAA;AAAA,MACP,WAAW;AAAA,QACT,OAAO,IAAI,UAAU;AAAA,QACrB,KAAK,IAAI,UAAU;AAAA,MACrB;AAAA,MACA,WAAW,IAAI;AAAA,IACjB,EAAE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAgB,aAAa,QAGX;AAChB,UAAM,YAAY,WAAW,KAAK,IAAI,CAAC;AACvC,UAAM,WAAW;AAAA,MACf,OAAO,OAAO,QAAQ;AAAA,MACtB,gBAAgB,OAAO,QAAQ,UAAU;AAAA,MACzC,cAAc,OAAO,QAAQ,UAAU;AAAA,IACzC;AAEA,WAAO,KAAK,eAAe;AAAA,MACzB;AAAA,MACA,OAAO,QAAQ;AAAA,MACf;AAAA,MACA,OAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAgB,sBAAsB,QAGpB;AAChB,WAAO,KAAK,eAAe,sBAAsB,MAAM;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,OACX,YACA,aACiB;AACjB,WAAO,KAAK,cAAc;AAAA,MACxB,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA,MAAM,KAAK,KAAK,EAAE,WAAW,KAAK,UAAU,CAAC;AAAA,IAC/C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,SACX,QACA,SACe;AACf,UAAM,MAAM,SAAS,aAAa,KAAK;AACvC,UAAM,eACJ,SAAS,QACR,MAAM,KAAK,cAAc,mBAAmB,KAAK,MAAM;AAE1D,QAAI,iBAAiB,SAAS;AAC5B,YAAM,KAAK,cAAc,gBAAgB,KAAK,MAAM;AAAA,IACtD,OAAO;AACL,YAAM,KAAK,cAAc,eAAe,KAAK,MAAM;AAAA,IACrD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,aAAa,YAAmC;AAC3D,WAAO,KAAK,cAAc,aAAa,KAAK,WAAW,UAAU;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,eAAsC;AACjD,UAAM,WAAW,MAAM,KAAK,cAAc,aAAa,KAAK,SAAS;AACrE,UAAM,gBAAgB,MAAM,KAAK,iBAAiB;AAElD,WAAO,SAAS,IAAI,CAAC,YAA4B;AAAA,MAC/C,IAAI,OAAO;AAAA,MACX,MAAM,OAAO;AAAA,MACb,WAAW,OAAO;AAAA,MAClB,aAAa,OAAO;AAAA,MACpB,UAAU,OAAO,SAAS;AAAA,IAC5B,EAAE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,mBAAoC;AAC/C,WAAO,KAAK,cAAc,iBAAiB,KAAK,SAAS;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,gBAAgB,cAAwC;AACnE,WAAO,KAAK,cAAc,gBAAgB,KAAK,WAAW,YAAY;AAAA,EACxE;AACF;;;AC3nBA,qBAAoD;;;ACf7C,IAAM,sBAAN,MAAM,qBAA6C;AAAA,EAAnD;AACL,SAAQ,QAA6B,CAAC;AACtC,SAAQ,eAAsB,CAAC;AAAA;AAAA,EAE/B,MAAM,OAAe,UAA8B,OAAkB;AACnE,SAAK,MAAM,KAAK,IAAI,KAAK,cAAc,UAAU,KAAK;AACtD,WAAO;AAAA,EACT;AAAA,EAEA,IAAI,OAAe,UAA8B,OAAkB;AAEjE,WAAO,KAAK,MAAM,OAAO,UAAU,KAAK;AAAA,EAC1C;AAAA,EAEA,GAAG,YAAmC;AACpC,SAAK,eAAe,WAAW,IAAI,CAAC,YAAY,QAAQ,MAAM,CAAC;AAC/D,WAAO;AAAA,EACT;AAAA,EAEA,GAAG,OAAe,QAAqB;AACrC,SAAK,MAAM,KAAK,IAAI,EAAE,KAAK,OAAO;AAClC,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,OAAe,SAAiB,SAAwB;AAC5D,SAAK,MAAM,KAAK,IAAI,IAAI,OAAO,SAAS,WAAW,GAAG;AACtD,WAAO;AAAA,EACT;AAAA,EAEA,QAAa;AACX,QAAI,KAAK,aAAa,SAAS,GAAG;AAChC,aAAO,EAAE,KAAK,KAAK,aAAa;AAAA,IAClC;AACA,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,QAAuB;AACrB,UAAM,SAAS,IAAI,qBAAoB;AACvC,WAAO,QAAQ,EAAE,GAAG,KAAK,MAAM;AAC/B,WAAO,eAAe,CAAC,GAAG,KAAK,YAAY;AAC3C,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,cAAc,UAA8B,OAAiB;AACnE,UAAM,cAAkD;AAAA,MACtD,IAAI;AAAA,MACJ,IAAI;AAAA,MACJ,IAAI;AAAA,MACJ,KAAK;AAAA,MACL,IAAI;AAAA,MACJ,KAAK;AAAA,MACL,IAAI;AAAA,MACJ,KAAK;AAAA,IACP;AAGA,QAAI,aAAa,MAAM;AACrB,aAAO;AAAA,IACT;AAEA,UAAM,UAAU,YAAY,QAAQ;AACpC,WAAO,EAAE,CAAC,OAAO,GAAG,MAAM;AAAA,EAC5B;AACF;AAKO,IAAM,uBAAN,MAAqD;AAAA,EAArD;AACL,SAAQ,UAA+B,CAAC;AACxC,SAAQ,SAA8B,CAAC;AACvC,SAAQ,aAAkC,CAAC;AAAA;AAAA,EAE3C,IAAI,OAAe,OAAkB;AACnC,SAAK,QAAQ,KAAK,IAAI;AACtB,WAAO;AAAA,EACT;AAAA,EAEA,YAAY,SAAoC;AAC9C,WAAO,OAAO,KAAK,SAAS,OAAO;AACnC,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,OAAqB;AACzB,SAAK,OAAO,KAAK,IAAI;AACrB,WAAO;AAAA,EACT;AAAA,EAEA,UAAU,OAAe,OAAqB;AAC5C,SAAK,WAAW,KAAK,IAAI;AACzB,WAAO;AAAA,EACT;AAAA,EAEA,QAAa;AACX,UAAM,SAA8B,CAAC;AAErC,QAAI,OAAO,KAAK,KAAK,OAAO,EAAE,SAAS,GAAG;AACxC,aAAO,OAAO,KAAK;AAAA,IACrB;AAEA,QAAI,OAAO,KAAK,KAAK,MAAM,EAAE,SAAS,GAAG;AACvC,aAAO,SAAS,KAAK;AAAA,IACvB;AAEA,QAAI,OAAO,KAAK,KAAK,UAAU,EAAE,SAAS,GAAG;AAC3C,aAAO,OAAO,KAAK;AAAA,IACrB;AAEA,WAAO;AAAA,EACT;AACF;;;ACrHO,IAAM,iBAAN,MAAiD;AAAA,EACtD,YAAoB,IAAQ;AAAR;AAAA,EAAS;AAAA,EAE7B,cAAc,MAA0B;AACtC,WAAO,KAAK,GAAG,WAAW,IAAI;AAAA,EAChC;AAAA,EAEA,MAAM,KACJ,YACA,OACA,SACc;AACd,QAAI,SAAS,WAAW,KAAK,KAAK;AAElC,QAAI,SAAS,MAAM;AACjB,eAAS,OAAO,KAAK,QAAQ,IAAI;AAAA,IACnC;AACA,QAAI,SAAS,MAAM;AACjB,eAAS,OAAO,KAAK,QAAQ,IAAI;AAAA,IACnC;AACA,QAAI,SAAS,OAAO;AAClB,eAAS,OAAO,MAAM,QAAQ,KAAK;AAAA,IACrC;AAEA,WAAO,OAAO,QAAQ;AAAA,EACxB;AAAA,EAEA,MAAM,QACJ,YACA,OACmB;AACnB,WAAO,WAAW,QAAQ,KAAK;AAAA,EACjC;AAAA,EAEA,MAAM,UACJ,YACA,UACY;AACZ,UAAM,SAAS,MAAM,WAAW,UAAU,QAAe;AACzD,WAAO,EAAE,KAAK,OAAO,YAAY,GAAG,SAAS;AAAA,EAC/C;AAAA,EAEA,MAAM,WACJ,YACA,WACoC;AACpC,UAAM,SAAS,MAAM,WAAW,WAAW,SAAkB;AAC7D,WAAO,EAAE,eAAe,OAAO,cAAc;AAAA,EAC/C;AAAA,EAEA,MAAM,UACJ,YACA,QACA,QACoC;AAEpC,UAAM,eAAe,OAAO,KAAK,MAAM,EAAE,KAAK,CAAC,QAAQ,IAAI,WAAW,GAAG,CAAC;AAC1E,UAAM,YAAY,eAAe,SAAS,EAAE,MAAM,OAAO;AAEzD,UAAM,SAAS,MAAM,WAAW,UAAU,QAAQ,SAAS;AAC3D,WAAO,EAAE,eAAe,OAAO,cAAc;AAAA,EAC/C;AAAA,EAEA,MAAM,UACJ,YACA,QACmC;AACnC,UAAM,SAAS,MAAM,WAAW,UAAU,MAAM;AAChD,WAAO,EAAE,cAAc,OAAO,aAAa;AAAA,EAC7C;AAAA,EAEA,MAAM,WACJ,YACA,QACmC;AACnC,UAAM,SAAS,MAAM,WAAW,WAAW,MAAM;AACjD,WAAO,EAAE,cAAc,OAAO,aAAa;AAAA,EAC7C;AAAA,EAEA,MAAM,MAAM,YAAwB,OAAqC;AACvE,WAAO,WAAW,eAAe,KAAK;AAAA,EACxC;AAAA;AAAA,EAGA,qBAAoC;AAClC,WAAO,IAAI,oBAAoB;AAAA,EACjC;AAAA,EAEA,sBAAsC;AACpC,WAAO,IAAI,qBAAqB;AAAA,EAClC;AACF;;;AC5FO,IAAM,2BAAN,MAA6D;AAAA,EAMlE,YACU,IACA,gBACA,qBACA,uBACR;AAJQ;AACA;AACA;AACA;AAER,SAAK,UAAU,IAAI,eAAe,EAAE;AACpC,SAAK,mBAAmB,GAAG,WAAW,cAAc;AACpD,SAAK,kBAAkB,GAAG,WAAW,mBAAmB;AACxD,SAAK,oBAAoB,GAAG,WAAW,qBAAqB;AAAA,EAC9D;AAAA,EAEA,gBAA4B;AAC1B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,qBAAiC;AAC/B,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,uBAAmC;AACjC,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,cAAkB;AAChB,WAAO,KAAK;AAAA,EACd;AAAA,EAEA,aAA6B;AAC3B,WAAO,KAAK;AAAA,EACd;AACF;;;ACtCO,IAAMC,qBAAN,MAAwB;AAAA;AAAA;AAAA;AAAA,EAI7B,WACE,OACA,WACA,YACiC;AACjC,WAAO;AAAA,MACL;AAAA,MACA,WAAW,MAAM,QAAQ;AAAA,MACzB;AAAA,MACA,MAAM,MAAM,QAAQ;AAAA,MACpB,SAAS,MAAM,QAAQ;AAAA,MACvB,WAAW,MAAM,QAAQ;AAAA,MACzB,YAAY,MAAM,QAAQ;AAAA,MAC1B,OAAO,MAAM;AAAA,MACb,WAAW,MAAM,QAAQ,aAAa,oBAAI,KAAK;AAAA,MAC/C,WAAW,oBAAI,KAAK;AAAA,IACtB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,aAAa,KAAuC;AAClD,WAAO;AAAA,MACL,SAAS;AAAA,QACP,IAAI,IAAI;AAAA,QACR,MAAM,IAAI;AAAA,QACV,SAAS,IAAI;AAAA,QACb,WAAW,IAAI;AAAA,QACf,YAAY,IAAI;AAAA,QAChB,WAAW,IAAI;AAAA,MACjB;AAAA,MACA,OAAO,IAAI;AAAA,IACb;AAAA,EACF;AACF;;;AJkCO,IAAM,gBAAN,cAA4B,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgC5C,YAAY,QAA6B;AACvC,UAAM,MAAM;AA1Bd;AAAA,SAAQ,KAAgB;AA4BtB,QAAI,CAAC,OAAO,MAAM,CAAC,OAAO,kBAAkB;AAC1C,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,SAAK,YAAY,OAAO,aAAa;AACrC,SAAK,0BACH,OAAO,4BAA4B,OAAO,aAAa,OAAO;AAEhE,QAAI,OAAO,IAAI;AAEb,WAAK,KAAK,OAAO;AACjB,WAAK,oBAAoB,MAAM;AAAA,IACjC;AAAA,EAEF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WAAW,QAA4C;AAC3D,QAAI,KAAK,IAAI;AACX;AAAA,IACF;AAEA,QAAI,CAAC,OAAO,kBAAkB;AAC5B,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACpE;AAEA,QAAI;AACF,WAAK,SAAS,IAAI,2BAAY,OAAO,kBAAkB;AAAA,QACrD,GAAG,OAAO;AAAA,MACZ,CAAC;AAED,YAAM,KAAK,OAAO,QAAQ;AAE1B,YAAM,eAAe,OAAO,gBAAgB;AAC5C,WAAK,KAAK,KAAK,OAAO,GAAG,YAAY;AAErC,WAAK,oBAAoB,MAAM;AAAA,IACjC,SAAS,OAAO;AACd,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAAoB,QAAmC;AAC7D,QAAI,CAAC,KAAK,IAAI;AACZ,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACpE;AAGA,SAAK,oBAAoB,IAAI;AAAA,MAC3B,KAAK;AAAA,MACL,OAAO,kBAAkB;AAAA,MACzB,OAAO,uBAAuB;AAAA,MAC9B,OAAO,yBAAyB;AAAA,IAClC;AAEA,SAAK,oBAAoB,IAAIC,mBAAkB;AAG/C,SAAK,eAAe,IAAI,aAAa,KAAK,iBAAiB;AAC3D,SAAK,gBAAgB,IAAI;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AACA,SAAK,gBAAgB,IAAI;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AACA,SAAK,iBAAiB,IAAI;AAAA,MACxB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAa,IAAI,OAAqB,SAAqC;AACzE,SAAK,kBAAkB;AACvB,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,UAAI,CAAC,MAAM,QAAQ,WAAW;AAC5B,cAAM,QAAQ,YAAY,oBAAI,KAAK;AAAA,MACrC;AAGA,YAAM,aAAa,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGpE,YAAM,MAAM,KAAK,kBAAkB,WAAW,OAAO,KAAK,UAAU;AAGpE,YAAM,QAAQ,UAAU,YAAY,GAAG;AAAA,IACzC,SAAS,OAAO;AACd,cAAQ,MAAM,kCAAkC,KAAK;AACrD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,QACX,MACA,SACe;AACf,QAAI,KAAK,WAAW,EAAG;AAGvB,eAAW,SAAS,MAAM;AACxB,YAAM,KAAK,IAAI,OAAO,OAAO;AAAA,IAC/B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAa,KAAK,SAAgD;AAChE,SAAK,kBAAkB;AACvB,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,YAAM,oBACJ,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGnD,YAAM,mBAAmB,MAAM,KAAK,cAAc;AAAA,QAChD;AAAA,QACA;AAAA,MACF;AAGA,YAAM,cAAc,MAAM,KAAK,cAAc,eAAe,GAAG;AAC/D,UAAI,aAAa;AAEjB,UAAI,aAAa;AACf,qBAAa,KAAK,cAAc;AAAA,UAC9B;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAGA,UAAI;AACJ,UAAI,WAAW,SAAS,GAAG;AACzB,cAAM,YAAY,QAAQ,mBAAmB;AAC7C,cAAM,oBAAoB,WAAW,IAAI,CAAC,SAAc;AACtD,gBAAM,UAAU,QAAQ,mBAAmB;AAC3C,iBAAO,QAAQ,IAAI,EAAE,QAAQ,CAAC,CAAC,OAAO,KAAK,MAAM;AAC/C,oBAAQ,MAAM,OAAO,MAAM,KAAK;AAAA,UAClC,CAAC;AACD,iBAAO;AAAA,QACT,CAAC;AACD,yBAAiB,UAAU,GAAG,iBAAiB,EAAE,MAAM;AAAA,MACzD,OAAO;AACL,yBAAiB,WAAW,CAAC;AAAA,MAC/B;AAGA,YAAM,QAAQ,SAAS,SAAS;AAChC,YAAM,eAAoB;AAAA,QACxB,MAAM,EAAE,WAAW,UAAU,QAAQ,IAAI,GAAG;AAAA,MAC9C;AAEA,UAAI,SAAS,QAAQ;AACnB,qBAAa,OAAO,QAAQ;AAAA,MAC9B;AACA,UAAI,SAAS,OAAO;AAClB,qBAAa,QAAQ,QAAQ;AAAA,MAC/B;AAGA,YAAM,SAAS,MAAM,QAAQ;AAAA,QAC3B;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,UAAI,UAAU,UAAU,SAAS,OAAO,QAAQ,IAAI,QAAQ;AAAA,QAC1D,CAAC,QAA4B,KAAK,kBAAkB,aAAa,GAAG;AAAA,MACtE;AAGA,UAAI,KAAK,2BAA2B,OAAO,SAAS,GAAG;AACrD,cAAM,MAAM,MAAM,KAAK,cAAc,EAAE,WAAW,KAAK,OAAO,CAAC;AAC/D,iBAAS,IAAI;AAAA,MACf;AAGA,UAAI,SAAS,WAAW;AACtB,iBAAS,KAAK,aAAa,aAAa,QAAQ,QAAQ,SAAS;AAAA,MACnE;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,sCAAsC,KAAK;AACzD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,OAAO,QAGF;AAChB,SAAK,kBAAkB;AACvB,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,OAAO,aAAa,KAAK;AAErC,YAAM,EAAE,MAAM,IAAI;AAGlB,YAAM,oBACJ,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGnD,YAAM,WAAW,KAAK,kBAAkB;AAAA,QACtC;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,YAAM,QAAQ;AAAA,QACZ;AAAA,QACA,EAAE,WAAW,KAAK,WAAW,MAAM,QAAQ,GAAG;AAAA,QAC9C;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,oCAAoC,KAAK;AACvD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAM,OAAO,WAAkC;AAC7C,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,KAAK;AAEjB,YAAM,QAAQ,UAAU,YAAY;AAAA,QAClC,WAAW;AAAA,QACX;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,cAAQ,MAAM,sCAAsC,KAAK;AACzD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,MAAM,SAAuC;AACxD,SAAK,kBAAkB;AACvB,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,kBAAkB,KAAK,kBAAkB,mBAAmB;AAClE,YAAM,oBAAoB,KAAK,kBAAkB,qBAAqB;AAEtE,UAAI,SAAS,WAAW;AAEtB,cAAM,MAAM,QAAQ;AACpB,cAAM,UAAU,KAAK,kBAAkB,WAAW;AAGlD,cAAM,SAAS,MAAM,QAAQ;AAAA,UAC3B;AAAA,UACA,EAAE,WAAW,IAAI;AAAA,UACjB,EAAE,MAAM,EAAE,WAAW,GAAG,GAAG,OAAO,EAAE;AAAA,QACtC;AAEA,YAAI,OAAO,SAAS,GAAG;AACrB,gBAAM,YAAY,OAAO,CAAC;AAE1B,gBAAM,KAAK,cAAc,eAAe,KAAK,UAAU,SAAS;AAAA,QAClE;AAGA,cAAM,QAAQ,WAAW,mBAAmB,EAAE,WAAW,IAAI,CAAC;AAAA,MAChE,OAAO;AAEL,cAAM,UAAU,KAAK,kBAAkB,WAAW;AAGlD,cAAM,QAAQ,WAAW,YAAY,CAAC,CAAC;AACvC,cAAM,QAAQ,WAAW,iBAAiB,CAAC,CAAC;AAC5C,cAAM,QAAQ,WAAW,mBAAmB,CAAC,CAAC;AAAA,MAChD;AAGA,WAAK,aAAa,WAAW;AAAA,IAC/B,SAAS,OAAO;AACd,cAAQ,MAAM,uCAAuC,KAAK;AAC1D,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,QAAQ,SAAoD;AACvE,WAAQ,MAAM,KAAK,SAAS,OAAO,MAAO;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,SAAS,SAAmD;AACvE,SAAK,kBAAkB;AACvB,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,YAAM,oBACJ,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGnD,YAAM,mBAAmB,MAAM,KAAK,cAAc;AAAA,QAChD;AAAA,QACA;AAAA,MACF;AAGA,YAAM,cAAc,MAAM,KAAK,cAAc,eAAe,GAAG;AAC/D,UAAI,aAAa;AAEjB,UAAI,aAAa;AACf,qBAAa,KAAK,cAAc;AAAA,UAC9B;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAGA,UAAI;AACJ,UAAI,WAAW,SAAS,GAAG;AACzB,cAAM,YAAY,QAAQ,mBAAmB;AAC7C,cAAM,oBAAoB,WAAW,IAAI,CAAC,SAAc;AACtD,gBAAM,UAAU,QAAQ,mBAAmB;AAC3C,iBAAO,QAAQ,IAAI,EAAE,QAAQ,CAAC,CAAC,OAAO,KAAK,MAAM;AAC/C,oBAAQ,MAAM,OAAO,MAAM,KAAK;AAAA,UAClC,CAAC;AACD,iBAAO;AAAA,QACT,CAAC;AACD,yBAAiB,UAAU,GAAG,iBAAiB,EAAE,MAAM;AAAA,MACzD,OAAO;AACL,yBAAiB,WAAW,CAAC;AAAA,MAC/B;AAEA,YAAM,QAAQ,MAAM,QAAQ,MAAM,YAAY,cAAc;AAC5D,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,qCAAqC,KAAK;AACxD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,SACX,OACA,SACyB;AACzB,SAAK,kBAAkB;AACvB,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,YAAM,cAAc,MAAM,KAAK,cAAc,eAAe,GAAG;AAG/D,YAAM,eAAe,QAClB,mBAAmB,EACnB,MAAM,aAAa,MAAM,GAAG,EAC5B,MAAM,WAAW,OAAO,GAAG;AAG9B,UAAI,aAAa;AACf,qBAAa,IAAI,aAAa,MAAM,WAAW;AAAA,MACjD;AAEA,YAAM,iBAAiB,aAAa,MAAM;AAE1C,YAAM,SAAS,MAAM,QAAQ;AAAA,QAC3B;AAAA,QACA;AAAA,MACF;AAEA,aAAO,OAAO;AAAA,QAAI,CAAC,QACjB,KAAK,kBAAkB,aAAa,GAAG;AAAA,MACzC;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,yCAAyC,KAAK;AAC5D,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAa,aAAa,WAAkD;AAC1E,UAAM,YAAY,MAAM,KAAK,eAAe,aAAa,SAAS;AAGlE,WAAO,UAAU,IAAI,CAAC,SAAS;AAAA,MAC7B,SAAS,IAAI;AAAA,MACb,OAAO;AAAA;AAAA,MACP,WAAW;AAAA,QACT,OAAO,IAAI,UAAU;AAAA,QACrB,KAAK,IAAI,UAAU;AAAA,MACrB;AAAA,MACA,WAAW,IAAI;AAAA,IACjB,EAAE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAgB,aAAa,QAGX;AAChB,UAAM,YAAY,WAAW,KAAK,IAAI,CAAC;AACvC,UAAM,WAAW;AAAA,MACf,OAAO,OAAO,QAAQ;AAAA,MACtB,gBAAgB,OAAO,QAAQ,UAAU;AAAA,MACzC,cAAc,OAAO,QAAQ,UAAU;AAAA,IACzC;AAEA,WAAO,KAAK,eAAe;AAAA,MACzB;AAAA,MACA,OAAO,QAAQ;AAAA,MACf;AAAA,MACA,OAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAgB,sBAAsB,QAGpB;AAChB,WAAO,KAAK,eAAe,sBAAsB,MAAM;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,OACX,YACA,aACiB;AACjB,WAAO,KAAK,cAAc;AAAA,MACxB,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA,MAAM,KAAK,KAAK,EAAE,WAAW,KAAK,UAAU,CAAC;AAAA,IAC/C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,SACX,QACA,SACe;AACf,UAAM,MAAM,SAAS,aAAa,KAAK;AACvC,UAAM,eACJ,SAAS,QACR,MAAM,KAAK,cAAc,mBAAmB,KAAK,MAAM;AAE1D,QAAI,iBAAiB,SAAS;AAC5B,YAAM,KAAK,cAAc,gBAAgB,KAAK,MAAM;AAAA,IACtD,OAAO;AACL,YAAM,KAAK,cAAc,eAAe,KAAK,MAAM;AAAA,IACrD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,aAAa,YAAmC;AAC3D,WAAO,KAAK,cAAc,aAAa,KAAK,WAAW,UAAU;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,eAAsC;AACjD,UAAM,WAAW,MAAM,KAAK,cAAc,aAAa,KAAK,SAAS;AACrE,UAAM,gBAAgB,MAAM,KAAK,iBAAiB;AAElD,WAAO,SAAS,IAAI,CAAC,YAAiB;AAAA,MACpC,IAAI,OAAO;AAAA,MACX,MAAM,OAAO;AAAA,MACb,WAAW,OAAO;AAAA,MAClB,aAAa,OAAO;AAAA,MACpB,YAAY;AAAA;AAAA,MACZ,UAAU,OAAO,SAAS;AAAA,IAC5B,EAAE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,mBAAoC;AAC/C,WAAO,KAAK,cAAc,iBAAiB,KAAK,SAAS;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,gBAAgB,cAAwC;AACnE,WAAO,KAAK,cAAc,gBAAgB,KAAK,WAAW,YAAY;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,QAAuB;AAClC,QAAI,KAAK,QAAQ;AACf,UAAI;AACF,cAAM,KAAK,OAAO,MAAM;AAAA,MAC1B,SAAS,OAAO;AACd,gBAAQ,MAAM,qCAAqC,KAAK;AACxD,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,UAAmB;AACxB,WAAO,CAAC,CAAC,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKO,cAAkB;AACvB,QAAI,CAAC,KAAK,IAAI;AACZ,YAAM,IAAI,MAAM,mDAAmD;AAAA,IACrE;AACA,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAA0B;AAChC,QAAI,CAAC,KAAK,IAAI;AACZ,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACF;;;AKjqBA,IAAAC,kBAA2B;;;ACtC3B,IAAAC,kBAA2B;;;AC3BpB,IAAM,sBAAN,MAAM,qBAA6C;AAAA,EAAnD;AACL,SAAQ,aAAoB,CAAC;AAC7B,SAAQ,aAAkC,CAAC;AAC3C,SAAQ,eAAe;AACvB,SAAQ,eAAsB,CAAC;AAAA;AAAA,EAE/B,MAAM,OAAe,UAAe,OAAkB;AACpD,WAAO,KAAK,aAAa,OAAO,UAAU,KAAK;AAAA,EACjD;AAAA,EAEA,IAAI,OAAe,UAAe,OAAkB;AAClD,WAAO,KAAK,aAAa,OAAO,UAAU,KAAK;AAAA,EACjD;AAAA,EAEA,GAAG,YAAmC;AAEpC,SAAK,eAAe,WAAW,IAAI,CAAC,YAAY;AAC9C,YAAM,QAAQ,QAAQ,MAAM;AAC5B,UAAI,MAAM,mBAAmB;AAC3B,eAAO;AAAA,UACL,OAAO,MAAM;AAAA,UACb,YAAY,MAAM;AAAA,QACpB;AAAA,MACF;AACA,aAAO;AAAA,IACT,CAAC;AACD,WAAO;AAAA,EACT;AAAA,EAEA,GAAG,OAAe,QAAqB;AACrC,UAAM,YAAY,SAAS,KAAK,cAAc;AAC9C,SAAK,WAAW,KAAK,UAAU,KAAK,YAAY,SAAS,GAAG;AAC5D,SAAK,WAAW,SAAS,IAAI;AAC7B,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,OAAe,SAAiB,SAAwB;AAE5D,UAAM,YAAY,SAAS,KAAK,cAAc;AAC9C,UAAM,cAAc,QACjB,QAAQ,SAAS,GAAG,EACpB,QAAQ,OAAO,GAAG,EAClB,QAAQ,OAAO,EAAE,EACjB,QAAQ,OAAO,EAAE;AAEpB,SAAK,WAAW,KAAK,UAAU,KAAK,UAAU,SAAS,EAAE;AACzD,SAAK,WAAW,SAAS,IAAI;AAC7B,WAAO;AAAA,EACT;AAAA,EAEA,QAAuB;AACrB,UAAM,SAAS,IAAI,qBAAoB;AACvC,WAAO,aAAa,CAAC,GAAG,KAAK,UAAU;AACvC,WAAO,aAAa,EAAE,GAAG,KAAK,WAAW;AACzC,WAAO,eAAe,KAAK;AAC3B,WAAO,eAAe,CAAC,GAAG,KAAK,YAAY;AAC3C,WAAO;AAAA,EACT;AAAA,EAEA,QAAa;AAEX,QAAI,KAAK,aAAa,SAAS,GAAG;AAEhC,YAAM,gBAAqC,EAAE,GAAG,KAAK,WAAW;AAChE,UAAI,qBAAqB,KAAK;AAG9B,YAAM,YAAsB,CAAC;AAE7B,iBAAW,eAAe,KAAK,cAAc;AAC3C,YAAI,YAAY,SAAS,YAAY,YAAY;AAC/C,cAAI,cAAc,YAAY;AAG9B,qBAAW,CAAC,UAAU,KAAK,KAAK,OAAO;AAAA,YACrC,YAAY;AAAA,UACd,GAAG;AACD,kBAAM,WAAW,SAAS,oBAAoB;AAC9C,0BAAc,YAAY;AAAA,cACxB,IAAI,OAAO,IAAI,QAAQ,OAAO,GAAG;AAAA,cACjC,IAAI,QAAQ;AAAA,YACd;AACA,0BAAc,QAAQ,IAAI;AAAA,UAC5B;AAEA,oBAAU,KAAK,IAAI,WAAW,GAAG;AAAA,QACnC;AAAA,MACF;AAGA,UAAI,aAAa;AACjB,UAAI,KAAK,WAAW,SAAS,GAAG;AAC9B,qBAAa,KAAK,WAAW,KAAK,OAAO;AACzC,YAAI,UAAU,SAAS,GAAG;AACxB,wBAAc,SAAS,UAAU,KAAK,MAAM,CAAC;AAAA,QAC/C;AAAA,MACF,WAAW,UAAU,SAAS,GAAG;AAC/B,qBAAa,UAAU,KAAK,MAAM;AAAA,MACpC;AAEA,aAAO;AAAA,QACL,mBAAmB;AAAA,QACnB,OAAO;AAAA,QACP,YAAY;AAAA,MACd;AAAA,IACF;AAGA,QAAI,KAAK,WAAW,WAAW,GAAG;AAChC,aAAO,CAAC;AAAA,IACV;AAEA,WAAO;AAAA,MACL,mBAAmB;AAAA,MACnB,OAAO,KAAK,WAAW,KAAK,OAAO;AAAA,MACnC,YAAY,KAAK;AAAA,IACnB;AAAA,EACF;AAAA;AAAA,EAGQ,aAAa,OAAe,UAAe,OAAkB;AACnE,UAAM,YAAY,SAAS,KAAK,cAAc;AAE9C,YAAQ,UAAU;AAAA,MAChB,KAAK;AACH,aAAK,WAAW,KAAK,UAAU,KAAK,OAAO,SAAS,EAAE;AACtD;AAAA,MACF,KAAK;AACH,aAAK,WAAW,KAAK,UAAU,KAAK,QAAQ,SAAS,EAAE;AACvD;AAAA,MACF,KAAK;AACH,aAAK,WAAW,KAAK,UAAU,KAAK,OAAO,SAAS,EAAE;AACtD;AAAA,MACF,KAAK;AACH,aAAK,WAAW,KAAK,UAAU,KAAK,QAAQ,SAAS,EAAE;AACvD;AAAA,MACF,KAAK;AACH,aAAK,WAAW,KAAK,UAAU,KAAK,OAAO,SAAS,EAAE;AACtD;AAAA,MACF,KAAK;AACH,aAAK,WAAW,KAAK,UAAU,KAAK,QAAQ,SAAS,EAAE;AACvD;AAAA,MACF,KAAK;AACH,aAAK,WAAW,KAAK,UAAU,KAAK,YAAY,SAAS,GAAG;AAC5D;AAAA,MACF,KAAK;AACH,aAAK,WAAW,KAAK,UAAU,KAAK,gBAAgB,SAAS,GAAG;AAChE;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AACH,aAAK,WAAW,KAAK,UAAU,KAAK,UAAU,SAAS,EAAE;AACzD;AAAA,MACF,KAAK;AAAA,MACL,KAAK;AACH,aAAK,WAAW,KAAK,gBAAgB,KAAK,iBAAiB,SAAS,GAAG;AACvE;AAAA,MACF;AACE,aAAK,WAAW,KAAK,UAAU,KAAK,OAAO,SAAS,EAAE;AAAA,IAC1D;AAEA,SAAK,WAAW,SAAS,IAAI;AAC7B,WAAO;AAAA,EACT;AACF;AAEO,IAAM,uBAAN,MAAqD;AAAA,EAArD;AACL,SAAQ,UAA+B,CAAC;AAAA;AAAA,EAExC,IAAI,OAAe,OAAkB;AACnC,SAAK,QAAQ,KAAK,IAAI;AACtB,WAAO;AAAA,EACT;AAAA,EAEA,YAAY,SAAoC;AAC9C,WAAO,OAAO,KAAK,SAAS,OAAO;AACnC,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,OAAqB;AACzB,SAAK,QAAQ,KAAK,IAAI;AACtB,WAAO;AAAA,EACT;AAAA,EAEA,UAAU,OAAe,OAAqB;AAG5C,YAAQ,KAAK,0DAA0D;AACvE,SAAK,QAAQ,KAAK,IAAI;AACtB,WAAO;AAAA,EACT;AAAA,EAEA,QAAa;AACX,WAAO,EAAE,MAAM,KAAK,QAAQ;AAAA,EAC9B;AACF;;;AC5LO,IAAM,iBAAN,MAAiD;AAAA;AAAA;AAAA;AAAA;AAAA,EAKtD,cAAc,MAAmB;AAC/B,UAAM,IAAI,MAAM,sGAAsG;AAAA,EACxH;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KACJ,YACA,OACA,SACc;AAEd,QAAI,KAAK,eAAe,KAAK,GAAG;AAC9B,aAAO,KAAK,mBAAmB,YAAY,OAAO,OAAO;AAAA,IAC3D,WAAW,MAAM,QAAQ,KAAK,GAAG;AAC/B,aAAO,KAAK,iBAAiB,YAAY,OAAO,OAAO;AAAA,IACzD,OAAO;AACL,aAAO,KAAK,kBAAkB,YAAY,OAAO,OAAO;AAAA,IAC1D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAe,OAAqB;AAC1C,WAAO,SAAS,MAAM;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,mBACZ,YACA,OACA,SACc;AACd,QAAI,eAAe,WAAW,mBAAmB,QAAQ;AACzD,mBAAe,aAAa,MAAM,MAAM,OAAO,MAAM,UAAU;AAE/D,SAAK,kBAAkB,cAAc,OAAO;AAC5C,WAAO,MAAM,aAAa,QAAQ;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,iBACZ,YACA,OACA,SACc;AACd,UAAM,kBAAkB,MAAM,KAAK,OAAK,KAAK,eAAe,CAAC,CAAC;AAE9D,QAAI,iBAAiB;AACnB,aAAO,KAAK,wBAAwB,YAAY,OAAO,OAAO;AAAA,IAChE,OAAO;AACL,aAAO,KAAK,uBAAuB,YAAY,OAAO,OAAO;AAAA,IAC/D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,wBACZ,YACA,OACA,SACc;AACd,QAAI,eAAe,WAAW,mBAAmB,QAAQ;AAEzD,UAAM,EAAE,aAAa,WAAW,IAAI,KAAK,kBAAkB,KAAK;AAChE,QAAI,aAAa;AACf,qBAAe,aAAa,MAAM,aAAa,UAAU;AAAA,IAC3D;AAEA,SAAK,kBAAkB,cAAc,OAAO;AAC5C,WAAO,MAAM,aAAa,QAAQ;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA,EAKQ,kBAAkB,SAA0E;AAClG,UAAM,eAAyB,CAAC;AAChC,UAAM,gBAAqC,CAAC;AAC5C,QAAI,eAAe;AAEnB,eAAW,KAAK,SAAS;AACvB,UAAI,KAAK,eAAe,CAAC,GAAG;AAC1B,cAAM,EAAE,QAAQ,OAAO,IAAI,KAAK,wBAAwB,GAAG,YAAY;AACvE,qBAAa,KAAK,IAAI,MAAM,GAAG;AAC/B,eAAO,OAAO,eAAe,MAAM;AACnC,wBAAgB,OAAO,KAAK,MAAM,EAAE;AAAA,MACtC,OAAO;AACL,cAAM,EAAE,QAAQ,OAAO,IAAI,KAAK,uBAAuB,GAAG,YAAY;AACtE,YAAI,QAAQ;AACV,uBAAa,KAAK,IAAI,MAAM,GAAG;AAC/B,iBAAO,OAAO,eAAe,MAAM;AACnC,0BAAgB,OAAO,KAAK,MAAM,EAAE;AAAA,QACtC;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,MACL,aAAa,aAAa,KAAK,MAAM;AAAA,MACrC,YAAY;AAAA,IACd;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,wBAAwB,OAAY,mBAA4E;AACtH,QAAI,cAAc,MAAM;AACxB,UAAM,SAA8B,CAAC;AACrC,QAAI,eAAe;AAGnB,QAAI,MAAM,YAAY;AACpB,iBAAW,CAAC,UAAU,KAAK,KAAK,OAAO,QAAQ,MAAM,UAAU,GAAG;AAChE,cAAM,WAAW,SAAS,cAAc;AACxC,sBAAc,YAAY;AAAA,UACxB,IAAI,OAAO,IAAI,QAAQ,OAAO,GAAG;AAAA,UACjC,IAAI,QAAQ;AAAA,QACd;AACA,eAAO,QAAQ,IAAI;AAAA,MACrB;AAAA,IACF;AAEA,WAAO,EAAE,QAAQ,aAAa,OAAO;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKQ,uBAAuB,OAAY,mBAA4E;AACrH,UAAM,aAAuB,CAAC;AAC9B,UAAM,SAA8B,CAAC;AACrC,QAAI,eAAe;AAEnB,eAAW,CAAC,OAAO,KAAK,KAAK,OAAO,QAAQ,KAAK,GAAG;AAClD,YAAM,YAAY,SAAS,cAAc;AACzC,iBAAW,KAAK,UAAU,KAAK,OAAO,SAAS,EAAE;AACjD,aAAO,SAAS,IAAI;AAAA,IACtB;AAEA,WAAO;AAAA,MACL,QAAQ,WAAW,KAAK,OAAO;AAAA,MAC/B;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,uBACZ,YACA,OACA,SACc;AACd,UAAM,cAA+B,EAAE,OAAO,MAAM;AACpD,SAAK,iBAAiB,aAAa,OAAO;AAC1C,WAAO,MAAM,WAAW,KAAK,WAAW;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,kBACZ,YACA,OACA,SACc;AACd,UAAM,cAA+B,EAAE,OAAO,MAAM;AACpD,SAAK,iBAAiB,aAAa,OAAO;AAC1C,WAAO,MAAM,WAAW,KAAK,WAAW;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKQ,kBAAkB,cAAuC,SAA8B;AAC7F,QAAI,SAAS,MAAM;AACjB,aAAO,QAAQ,QAAQ,IAAI,EAAE,QAAQ,CAAC,CAAC,OAAO,SAAS,MAAM;AAC3D,qBAAa,WAAW,UAAU,KAAK,IAAI,cAAc,IAAI,QAAQ,MAAM;AAAA,MAC7E,CAAC;AAAA,IACH;AAEA,QAAI,SAAS,MAAM;AACjB,mBAAa,KAAK,QAAQ,IAAI;AAAA,IAChC;AAEA,QAAI,SAAS,OAAO;AAClB,mBAAa,KAAK,QAAQ,KAAK;AAAA,IACjC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,iBAAiB,aAA8B,SAA8B;AACnF,QAAI,SAAS,MAAM;AACjB,kBAAY,QAAQ,CAAC;AACrB,aAAO,QAAQ,QAAQ,IAAI,EAAE,QAAQ,CAAC,CAAC,OAAO,SAAS,MAAM;AAC3D,oBAAY,MAAO,KAAK,IAAI,cAAc,IAAI,QAAQ;AAAA,MACxD,CAAC;AAAA,IACH;AAEA,QAAI,SAAS,MAAM;AACjB,kBAAY,OAAO,QAAQ;AAAA,IAC7B;AAEA,QAAI,SAAS,OAAO;AAClB,kBAAY,OAAO,QAAQ;AAAA,IAC7B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAiB,YAA6B,OAA+B;AAEjF,QAAI,SAAS,MAAM,mBAAmB;AAEpC,aAAO,MAAM,WACV,mBAAmB,QAAQ,EAC3B,MAAM,MAAM,OAAO,MAAM,UAAU,EACnC,OAAO;AAAA,IACZ,OAAO;AAEL,YAAM,cAA8B;AAAA,QAClC,OAAO;AAAA,MACT;AAEA,aAAO,MAAM,WAAW,QAAQ,WAAW;AAAA,IAC7C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAmB,YAA6B,UAAkC;AACtF,UAAM,SAAS,WAAW,OAAO,QAAQ;AACzC,WAAO,MAAM,WAAW,KAAK,MAAM;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WACJ,YACA,WACoC;AACpC,UAAM,WAAW,WAAW,OAAO,SAAS;AAC5C,UAAM,SAAS,MAAM,WAAW,KAAK,QAAQ;AAC7C,WAAO,EAAE,eAAe,MAAM,QAAQ,MAAM,IAAI,OAAO,SAAS,EAAE;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UACJ,YACA,QACA,QACoC;AAEpC,UAAM,aAAa,OAAO,QAAQ;AAGlC,QAAI,UAAU,OAAO,mBAAmB;AAEtC,YAAM,cAAc,OAAO,MAAM,QAAQ,aAAa,EAAE;AAGxD,YAAM,SAAS,MAAM,WAClB,mBAAmB,EACnB,OAAO,EACP,IAAI,UAAU,EACd,MAAM,aAAa,OAAO,UAAU,EACpC,QAAQ;AAEX,aAAO,EAAE,eAAe,OAAO,YAAY,EAAE;AAAA,IAC/C,OAAO;AAEL,YAAM,SAAS,MAAM,WAAW,OAAO,QAAQ,UAAU;AACzD,aAAO,EAAE,eAAe,OAAO,YAAY,EAAE;AAAA,IAC/C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU,YAA6B,QAAgD;AAC3F,UAAM,SAAS,MAAM,KAAK,cAAc,YAAY,MAAM;AAC1D,WAAO,EAAE,cAAc,OAAO,YAAY,EAAE;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WAAW,YAA6B,QAAgD;AAC5F,UAAM,SAAS,MAAM,KAAK,cAAc,YAAY,MAAM;AAC1D,WAAO,EAAE,cAAc,OAAO,YAAY,EAAE;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAc,cAAc,YAA6B,QAA2B;AAElF,QAAI,CAAC,UAAU,OAAO,KAAK,MAAM,EAAE,WAAW,GAAG;AAE/C,aAAO,MAAM,WACV,mBAAmB,EACnB,OAAO,EACP,QAAQ;AAAA,IACb;AAGA,QAAI,MAAM,QAAQ,MAAM,GAAG;AACzB,YAAM,kBAAkB,OAAO,KAAK,OAAK,KAAK,eAAe,CAAC,CAAC;AAE/D,UAAI,iBAAiB;AAEnB,cAAM,EAAE,aAAa,WAAW,IAAI,KAAK,kBAAkB,MAAM;AAEjE,cAAM,oBAAoB,YAAY,QAAQ,aAAa,EAAE;AAE7D,eAAO,MAAM,WACV,mBAAmB,EACnB,OAAO,EACP,MAAM,mBAAmB,UAAU,EACnC,QAAQ;AAAA,MACb,OAAO;AAEL,YAAI,gBAAgB;AACpB,mBAAW,aAAa,QAAQ;AAC9B,gBAAM,SAAS,MAAM,WAAW,OAAO,SAAS;AAChD,2BAAiB,OAAO,YAAY;AAAA,QACtC;AACA,eAAO,EAAE,UAAU,cAAc;AAAA,MACnC;AAAA,IACF;AAGA,QAAI,UAAU,OAAO,mBAAmB;AAGtC,YAAM,cAAc,OAAO,MAAM,QAAQ,aAAa,EAAE;AAGxD,aAAO,MAAM,WACV,mBAAmB,EACnB,OAAO,EACP,MAAM,aAAa,OAAO,UAAU,EACpC,QAAQ;AAAA,IACb,OAAO;AAEL,aAAO,MAAM,WAAW,OAAO,MAAM;AAAA,IACvC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAM,YAA6B,OAA6B;AAEpE,QAAI,SAAS,MAAM,mBAAmB;AAEpC,aAAO,MAAM,WACV,mBAAmB,QAAQ,EAC3B,MAAM,MAAM,OAAO,MAAM,UAAU,EACnC,SAAS;AAAA,IACd,OAAO;AAEL,aAAO,MAAM,WAAW,MAAM,EAAE,OAAO,MAAM,CAAC;AAAA,IAChD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAoC;AAClC,WAAO,IAAI,oBAAoB;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAKA,sBAAsC;AACpC,WAAO,IAAI,qBAAqB;AAAA,EAClC;AACF;;;AChZO,IAAM,2BAAN,MAA6D;AAAA,EAMlE,YACU,YACA,iBAAyB,iBACzB,iBAAyB,gBACzB,mBAA2B,oBACnC;AAJQ;AACA;AACA;AACA;AAER,SAAK,UAAU,IAAI,eAAe;AAIlC,SAAK,kBAAkB,WAAW,cAAc,cAAc;AAC9D,SAAK,kBAAkB,WAAW,cAAc,cAAc;AAC9D,SAAK,oBAAoB,WAAW,cAAc,gBAAgB;AAAA,EACpE;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAyC;AACvC,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,qBAA8C;AAC5C,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,uBAAkD;AAChD,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,cAA0B;AACxB,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,aAA6B;AAC3B,WAAO,KAAK;AAAA,EACd;AACF;;;AC9DA,8BAAO;AACP,qBAOO;AAgBA,IAAM,cAAN,MAAgD;AAiCvD;AA/BE;AAAA,MADC,uCAAuB,MAAM;AAAA,GADnB,YAEX;AAGA;AAAA,MADC,uBAAO,EAAE,MAAM,WAAW,QAAQ,IAAI,CAAC;AAAA,GAJ7B,YAKX;AAGA;AAAA,MADC,uBAAO,EAAE,MAAM,WAAW,QAAQ,IAAI,CAAC;AAAA,GAP7B,YAQX;AAGA;AAAA,MADC,uBAAO,EAAE,MAAM,WAAW,QAAQ,IAAI,CAAC;AAAA,GAV7B,YAWX;AAGA;AAAA,MADC,uBAAO,EAAE,MAAM,WAAW,QAAQ,GAAG,CAAC;AAAA,GAb5B,YAcX;AAGA;AAAA,MADC,uBAAO,EAAE,MAAM,OAAO,CAAC;AAAA,GAhBb,YAiBX;AAGA;AAAA,MADC,uBAAO,EAAE,MAAM,QAAQ,UAAU,KAAK,CAAC;AAAA,GAnB7B,YAoBX;AAGA;AAAA,MADC,uBAAO,EAAE,MAAM,WAAW,QAAQ,KAAK,UAAU,KAAK,CAAC;AAAA,GAtB7C,YAuBX;AAGA;AAAA,MADC,uBAAO,EAAE,MAAM,OAAO,CAAC;AAAA,GAzBb,YA0BX;AAGA;AAAA,MADC,iCAAiB;AAAA,GA5BP,YA6BX;AAGA;AAAA,MADC,iCAAiB;AAAA,GA/BP,YAgCX;AAhCW,cAAN;AAAA,MAJN,uBAAO,eAAe;AAAA,MACtB,sBAAM,sBAAsB,CAAC,aAAa,YAAY,CAAC;AAAA,MACvD,sBAAM,uBAAuB,CAAC,aAAa,WAAW,CAAC;AAAA,MACvD,sBAAM,uBAAuB,CAAC,aAAa,WAAW,CAAC;AAAA,GAC3C;AA0CN,SAAS,wBAAwB,YAAoB,iBAAiB;AAK3E,MAAM,oBAAN,cAAgC,YAAY;AAAA,EAAC;AAAvC,sBAAN;AAAA,QAJC,uBAAO,SAAS;AAAA,QAChB,sBAAM,sBAAsB,CAAC,aAAa,YAAY,CAAC;AAAA,QACvD,sBAAM,uBAAuB,CAAC,aAAa,WAAW,CAAC;AAAA,QACvD,sBAAM,uBAAuB,CAAC,aAAa,WAAW,CAAC;AAAA,KAClD;AAEN,SAAO;AACT;;;AC1EA,IAAAC,2BAAO;AACP,IAAAC,kBAOO;AAaA,IAAM,cAAN,MAA+C;AAqBtD;AAnBE;AAAA,MADC,wCAAuB,MAAM;AAAA,GADnB,YAEX;AAGA;AAAA,MADC,wBAAO,EAAE,MAAM,WAAW,QAAQ,KAAK,QAAQ,KAAK,CAAC;AAAA,GAJ3C,YAKX;AAGA;AAAA,MADC,wBAAO,EAAE,MAAM,WAAW,QAAQ,KAAK,SAAS,OAAO,CAAC;AAAA,GAP9C,YAQX;AAGA;AAAA,MADC,wBAAO,EAAE,MAAM,YAAY,UAAU,KAAK,CAAC;AAAA,GAVjC,YAWX;AAGA;AAAA,MADC,wBAAO,EAAE,MAAM,OAAO,CAAC;AAAA,GAbb,YAcX;AAGA;AAAA,MADC,kCAAiB;AAAA,GAhBP,YAiBX;AAGA;AAAA,MADC,kCAAiB;AAAA,GAnBP,YAoBX;AApBW,cAAN;AAAA,MAFN,wBAAO,cAAc;AAAA,MACrB,uBAAM,qBAAqB,CAAC,WAAW,CAAC;AAAA,GAC5B;AA0BN,SAAS,wBAAwB,YAAoB,gBAAgB;AAG1E,MAAM,oBAAN,cAAgC,YAAY;AAAA,EAAC;AAAvC,sBAAN;AAAA,QAFC,wBAAO,SAAS;AAAA,QAChB,uBAAM,qBAAqB,CAAC,WAAW,CAAC;AAAA,KACnC;AAEN,SAAO;AACT;;;ACrDA,IAAAC,2BAAO;AACP,IAAAC,kBAOO;AAcA,IAAM,gBAAN,MAAmD;AAqB1D;AAnBE;AAAA,MADC,wCAAuB,MAAM;AAAA,GADnB,cAEX;AAGA;AAAA,MADC,wBAAO,EAAE,MAAM,WAAW,QAAQ,IAAI,CAAC;AAAA,GAJ7B,cAKX;AAGA;AAAA,MADC,wBAAO,EAAE,MAAM,WAAW,QAAQ,IAAI,CAAC;AAAA,GAP7B,cAQX;AAGA;AAAA,MADC,wBAAO,EAAE,MAAM,OAAO,CAAC;AAAA,GAVb,cAWX;AAGA;AAAA,MADC,wBAAO,EAAE,MAAM,QAAQ,UAAU,KAAK,CAAC;AAAA,GAb7B,cAcX;AAGA;AAAA,MADC,kCAAiB;AAAA,GAhBP,cAiBX;AAGA;AAAA,MADC,kCAAiB;AAAA,GAnBP,cAoBX;AApBW,gBAAN;AAAA,MAHN,wBAAO,kBAAkB;AAAA,MACzB,uBAAM,uBAAuB,CAAC,WAAW,CAAC;AAAA,MAC1C,uBAAM,kBAAkB,CAAC,aAAa,WAAW,CAAC;AAAA,GACtC;AA0BN,SAAS,0BAA0B,YAAoB,oBAAoB;AAIhF,MAAM,sBAAN,cAAkC,cAAc;AAAA,EAAC;AAA3C,wBAAN;AAAA,QAHC,wBAAO,SAAS;AAAA,QAChB,uBAAM,uBAAuB,CAAC,WAAW,CAAC;AAAA,QAC1C,uBAAM,kBAAkB,CAAC,aAAa,WAAW,CAAC;AAAA,KAC7C;AAEN,SAAO;AACT;;;AN4BO,IAAM,gBAAN,cAA4B,WAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6B5C,YAAY,QAA6B;AACvC,UAAM,MAAM;AAEZ,QAAI,CAAC,OAAO,YAAY;AACtB,YAAM,IAAI,MAAM,sCAAsC;AAAA,IACxD;AAGA,SAAK,aAAa,OAAO;AAEzB,SAAK,YAAY,OAAO,aAAa;AACrC,SAAK,0BACH,OAAO,4BAA4B,OAAO,aAAa,OAAO;AAGhE,SAAK,yBAAyB,KAAK,YAAY,MAAM;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAQA,MAAc,YAAY,QAA4C;AACpE,UAAM,KAAK,oBAAoB,MAAM;AACrC,SAAK,oBAAoB,MAAM;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAc,oBACZ,QACe;AAEf,UAAM,mBAAmB,KAAK,WAAW,QAAQ,YAAY,CAAC;AAI9D,SAAK,WAAW,WAAW;AAAA,MACzB,GAAG,KAAK,WAAW;AAAA,MACnB,UAAU,kBAAkB,SACxB,mBACA;AAAA,QACE,wBAAwB,OAAO,cAAc;AAAA,QAC7C,wBAAwB,OAAO,cAAc;AAAA,QAC7C,0BAA0B,OAAO,gBAAgB;AAAA,MACnD;AAAA,IACN,CAAC;AAID,QAAI,KAAK,WAAW,eAAe;AAEjC,MAAC,KAAK,WAAmB,eAAe;AAGxC,UAAI,KAAK,WAAW,QAAQ,aAAa;AACvC,YAAI;AAEF,gBAAM,KAAK,WAAW,YAAY;AAAA,QACpC,SAAS,OAAO;AACd,kBAAQ,KAAK,0CAA0C,KAAK;AAAA,QAE9D;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,oBAAoB,QAAmC;AAC7D,QAAI,CAAC,KAAK,YAAY;AACpB,YAAM,IAAI,MAAM,oDAAoD;AAAA,IACtE;AAGA,SAAK,oBAAoB,IAAI;AAAA,MAC3B,KAAK;AAAA,MACL,OAAO,kBAAkB;AAAA,MACzB,OAAO,kBAAkB;AAAA,MACzB,OAAO,oBAAoB;AAAA,IAC7B;AAEA,SAAK,oBAAoB,OAAO,qBAAqB,IAAIC,mBAAkB;AAG3E,SAAK,eAAe,IAAI,aAAa,KAAK,iBAAiB;AAC3D,SAAK,gBAAgB,IAAI;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AACA,SAAK,gBAAgB,IAAI;AAAA,MACvB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AACA,SAAK,iBAAiB,IAAI;AAAA,MACxB,KAAK;AAAA,MACL,KAAK;AAAA,MACL,KAAK;AAAA,IACP;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAa,IAAI,OAAqB,SAAqC;AACzE,UAAM,KAAK,kBAAkB;AAC7B,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,UAAI,CAAC,MAAM,QAAQ,WAAW;AAC5B,cAAM,QAAQ,YAAY,oBAAI,KAAK;AAAA,MACrC;AAGA,YAAM,aAAa,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGpE,YAAM,MAAM,KAAK,kBAAkB,WAAW,OAAO,KAAK,UAAU;AAGpE,YAAM,QAAQ,UAAU,YAAY,GAAG;AAAA,IACzC,SAAS,OAAO;AACd,cAAQ,MAAM,kCAAkC,KAAK;AACrD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,QACX,MACA,SACe;AACf,QAAI,KAAK,WAAW,EAAG;AAEvB,eAAW,SAAS,MAAM;AACxB,YAAM,KAAK,IAAI,OAAO,OAAO;AAAA,IAC/B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAa,KAAK,SAAgD;AAChE,UAAM,KAAK,kBAAkB;AAC7B,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,YAAM,oBACJ,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGnD,YAAM,mBAAmB,MAAM,KAAK,cAAc;AAAA,QAChD;AAAA,QACA;AAAA,MACF;AAGA,YAAM,cAAc,MAAM,KAAK,cAAc,eAAe,GAAG;AAC/D,UAAI,aAAa;AAEjB,UAAI,aAAa;AACf,qBAAa,KAAK,cAAc;AAAA,UAC9B;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAGA,UAAI;AACJ,UAAI,WAAW,SAAS,GAAG;AAGzB,yBAAiB;AAAA,MACnB,OAAO;AACL,yBAAiB,WAAW,CAAC;AAAA,MAC/B;AAGA,YAAM,QAAQ,SAAS,SAAS;AAChC,YAAM,eAAoB;AAAA,QACxB,MAAM,EAAE,WAAW,UAAU,QAAQ,IAAI,GAAG;AAAA,MAC9C;AAEA,UAAI,SAAS,QAAQ;AACnB,qBAAa,OAAO,QAAQ;AAAA,MAC9B;AACA,UAAI,SAAS,OAAO;AAClB,qBAAa,QAAQ,QAAQ;AAAA,MAC/B;AAGA,YAAM,SAAS,MAAM,QAAQ;AAAA,QAC3B;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAEA,UAAI,UAAU,UAAU,SAAS,OAAO,QAAQ,IAAI,QAAQ;AAAA,QAC1D,CAAC,QAA4B,KAAK,kBAAkB,aAAa,GAAG;AAAA,MACtE;AAGA,UAAI,KAAK,2BAA2B,OAAO,SAAS,GAAG;AACrD,cAAM,MAAM,MAAM,KAAK,cAAc,EAAE,WAAW,KAAK,OAAO,CAAC;AAC/D,iBAAS,IAAI;AAAA,MACf;AAGA,UAAI,SAAS,WAAW;AACtB,iBAAS,KAAK,aAAa,aAAa,QAAQ,QAAQ,SAAS;AAAA,MACnE;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,sCAAsC,KAAK;AACzD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,OAAO,QAGF;AAChB,UAAM,KAAK,kBAAkB;AAC7B,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,OAAO,aAAa,KAAK;AAGrC,YAAM,QAAQ,QACX,mBAAmB,EACnB,MAAM,aAAa,MAAM,GAAG,EAC5B,IAAI,aAAa,MAAM,OAAO,MAAM,QAAQ,EAAE,EAC9C,MAAM;AAGT,YAAM,MAAM,MAAM,QAAQ,QAA4B,YAAY,KAAK;AAEvE,UAAI,CAAC,KAAK;AACR,cAAM,IAAI;AAAA,UACR,yBAAyB,OAAO,MAAM,QAAQ,EAAE,2BAA2B,GAAG;AAAA,QAChF;AAAA,MACF;AAEA,YAAM,aAAa,MAAM,KAAK,cAAc,qBAAqB,GAAG;AACpE,YAAM,YAAY,KAAK,kBAAkB;AAAA,QACvC,OAAO;AAAA,QACP;AAAA,QACA;AAAA,MACF;AAGA,YAAM,SAAS,QACZ,oBAAoB,EACpB,YAAY;AAAA,QACX,GAAG;AAAA,QACH,WAAW,oBAAI,KAAK;AAAA,MACtB,CAAC,EACA,MAAM;AAGT,YAAM,QAAQ,UAAU,YAAY,OAAO,MAAM;AAAA,IACnD,SAAS,OAAO;AACd,cAAQ,MAAM,oCAAoC,KAAK;AACvD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,OACX,WACA,SACe;AACf,UAAM,KAAK,kBAAkB;AAC7B,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAEvC,UAAI,OAAO,cAAc,UAAU;AAEjC,cAAM,QAAQ,QACX,mBAAmB,EACnB,MAAM,aAAa,MAAM,GAAG,EAC5B,IAAI,aAAa,MAAM,SAAS,EAChC,MAAM;AAET,cAAM,QAAQ,WAAW,YAAY,KAAK;AAAA,MAC5C,OAAO;AAEL,gBAAQ;AAAA,UACN;AAAA,QACF;AACA,cAAM,SAAS,MAAM,KAAK,KAAK,EAAE,WAAW,IAAI,CAAC;AACjD,YAAI,aAAa,KAAK,YAAY,OAAO,QAAQ;AAC/C,gBAAM,gBAAgB,OAAO,SAAS;AACtC,gBAAM,KAAK,OAAO,cAAc,QAAQ,IAAI,OAAO;AAAA,QACrD;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,sCAAsC,KAAK;AACzD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,MAAM,SAAuC;AACxD,UAAM,KAAK,kBAAkB;AAC7B,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,kBAAkB,KAAK,kBAAkB,mBAAmB;AAClE,YAAM,oBAAoB,KAAK,kBAAkB,qBAAqB;AAEtE,UAAI,SAAS,WAAW;AAEtB,cAAM,MAAM,QAAQ;AACpB,cAAM,UAAU,KAAK,kBAAkB,WAAW;AAGlD,cAAM,SAAS,MAAM,QAAQ;AAAA,UAC3B;AAAA,UACA,EAAE,WAAW,IAAI;AAAA,UACjB,EAAE,MAAM,EAAE,WAAW,GAAG,GAAG,OAAO,EAAE;AAAA,QACtC;AAEA,YAAI,OAAO,SAAS,GAAG;AACrB,gBAAM,YAAY,OAAO,CAAC;AAE1B,gBAAM,KAAK,cAAc,eAAe,KAAK,UAAU,SAAS;AAAA,QAClE;AAGA,cAAM,QAAQ,WAAW,mBAAmB,EAAE,WAAW,IAAI,CAAC;AAAA,MAChE,OAAO;AAEL,cAAM,UAAU,KAAK,kBAAkB,WAAW;AAGlD,cAAM,QAAQ,WAAW,YAAY,CAAC,CAAC;AACvC,cAAM,QAAQ,WAAW,iBAAiB,CAAC,CAAC;AAC5C,cAAM,QAAQ,WAAW,mBAAmB,CAAC,CAAC;AAAA,MAChD;AAGA,WAAK,aAAa,WAAW;AAAA,IAC/B,SAAS,OAAO;AACd,cAAQ,MAAM,uCAAuC,KAAK;AAC1D,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,QAAQ,SAAoD;AACvE,WAAQ,MAAM,KAAK,SAAS,OAAO,MAAO;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,SAAS,SAAmD;AACvE,UAAM,KAAK,kBAAkB;AAC7B,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,YAAM,oBACJ,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGnD,YAAM,mBAAmB,MAAM,KAAK,cAAc;AAAA,QAChD;AAAA,QACA;AAAA,MACF;AAGA,YAAM,cAAc,MAAM,KAAK,cAAc,eAAe,GAAG;AAC/D,UAAI,aAAa;AAEjB,UAAI,aAAa;AACf,qBAAa,KAAK,cAAc;AAAA,UAC9B;AAAA,UACA;AAAA,QACF;AAAA,MACF;AAGA,UAAI;AACJ,UAAI,WAAW,SAAS,GAAG;AAGzB,yBAAiB;AAAA,MACnB,OAAO;AACL,yBAAiB,WAAW,CAAC;AAAA,MAC/B;AAEA,YAAM,QAAQ,MAAM,QAAQ,MAAM,YAAY,cAAc;AAC5D,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,qCAAqC,KAAK;AACxD,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,SACX,OACA,SACyB;AACzB,UAAM,KAAK,kBAAkB;AAC7B,QAAI;AACF,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAClD,YAAM,MAAM,SAAS,aAAa,KAAK;AAGvC,YAAM,cAAc,MAAM,KAAK,cAAc,eAAe,GAAG;AAG/D,YAAM,eAAe,IAAI,oBAAoB;AAC7C,mBACG,MAAM,aAAa,KAAK,GAAG,EAC3B,IAAI,WAAW,SAAS,IAAI,KAAK,GAAG;AAGvC,UAAI,aAAa;AACf,qBAAa,IAAI,aAAa,KAAK,WAAW;AAAA,MAChD;AAEA,YAAM,SAAS,MAAM,QAAQ;AAAA,QAC3B;AAAA,QACA,aAAa,MAAM;AAAA,MACrB;AAEA,aAAO,OAAO;AAAA,QAAI,CAAC,QACjB,KAAK,kBAAkB,aAAa,GAAG;AAAA,MACzC;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,yCAAyC,KAAK;AAC5D,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,MAAa,aAAa,WAAkD;AAC1E,UAAM,YAAY,MAAM,KAAK,eAAe,aAAa,SAAS;AAGlE,WAAO,UAAU,IAAI,CAAC,SAAS;AAAA,MAC7B,SAAS,IAAI;AAAA,MACb,OAAO;AAAA;AAAA,MACP,WAAW;AAAA,QACT,OAAO,IAAI,UAAU;AAAA,QACrB,KAAK,IAAI,UAAU;AAAA,MACrB;AAAA,MACA,WAAW,IAAI;AAAA,IACjB,EAAE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAgB,aAAa,QAGX;AAChB,UAAM,YAAY,WAAW,KAAK,IAAI,CAAC;AACvC,UAAM,WAAW;AAAA,MACf,OAAO,OAAO,QAAQ;AAAA,MACtB,gBAAgB,OAAO,QAAQ,UAAU;AAAA,MACzC,cAAc,OAAO,QAAQ,UAAU;AAAA,IACzC;AAEA,WAAO,KAAK,eAAe;AAAA,MACzB;AAAA,MACA,OAAO,QAAQ;AAAA,MACf;AAAA,MACA,OAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAgB,sBAAsB,QAGpB;AAChB,WAAO,KAAK,eAAe,sBAAsB,MAAM;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAa,OACX,YACA,aACiB;AACjB,UAAM,KAAK,kBAAkB;AAC7B,WAAO,KAAK,cAAc;AAAA,MACxB,KAAK;AAAA,MACL;AAAA,MACA;AAAA,MACA,MAAM,KAAK,KAAK,EAAE,WAAW,KAAK,UAAU,CAAC;AAAA,IAC/C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAa,SACX,QACA,SACe;AACf,UAAM,KAAK,kBAAkB;AAC7B,UAAM,MAAM,SAAS,aAAa,KAAK;AACvC,UAAM,eACJ,SAAS,QACR,MAAM,KAAK,cAAc,mBAAmB,KAAK,MAAM;AAE1D,QAAI,iBAAiB,SAAS;AAC5B,YAAM,aAAa,KAAK,kBAAkB,cAAc;AACxD,YAAM,QAAQ,MAAM,KAAK,cAAc,oBAAoB,KAAK,MAAM;AACtE,YAAM,UAAU,KAAK,kBAAkB,WAAW;AAElD,UAAI,CAAC,OAAO;AACV,cAAM,IAAI,MAAM,UAAU,MAAM,2BAA2B,GAAG,GAAG;AAAA,MACnE;AAEA,YAAM,oBACJ,MAAM,KAAK,cAAc,qBAAqB,GAAG;AAGnD,UAAI,aAAa,MAAM,KAAK,cAAc;AAAA,QACxC;AAAA,QACA;AAAA,MACF;AAEA,mBAAa,KAAK,cAAc;AAAA,QAC9B;AAAA,QACA,MAAM;AAAA,MACR;AAEA,UAAI;AACJ,UAAI,WAAW,SAAS,GAAG;AAGzB,yBAAiB;AAAA,MACnB,OAAO;AACL,yBAAiB,WAAW,CAAC;AAAA,MAC/B;AAEA,YAAM,QAAQ,WAAW,YAAY,cAAc;AAAA,IACrD,OAAO;AACL,YAAM,KAAK,cAAc,eAAe,KAAK,MAAM;AAAA,IACrD;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,aAAa,YAAmC;AAC3D,UAAM,KAAK,kBAAkB;AAC7B,WAAO,KAAK,cAAc,aAAa,KAAK,WAAW,UAAU;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,eAAsC;AACjD,UAAM,KAAK,kBAAkB;AAC7B,UAAM,WAAW,MAAM,KAAK,cAAc,aAAa,KAAK,SAAS;AACrE,UAAM,gBAAgB,MAAM,KAAK,iBAAiB;AAElD,WAAO,SAAS,IAAI,CAAC,YAAiB;AAAA,MACpC,IAAI,OAAO;AAAA,MACX,MAAM,OAAO;AAAA,MACb,WAAW,OAAO;AAAA,MAClB,aAAa,OAAO;AAAA,MACpB,YAAY;AAAA;AAAA,MACZ,UAAU,OAAO,SAAS;AAAA,IAC5B,EAAE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,mBAAoC;AAC/C,UAAM,KAAK,kBAAkB;AAC7B,WAAO,KAAK,cAAc,iBAAiB,KAAK,SAAS;AAAA,EAC3D;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAa,gBAAgB,cAAwC;AACnE,UAAM,KAAK,kBAAkB;AAC7B,WAAO,KAAK,cAAc,gBAAgB,KAAK,WAAW,YAAY;AAAA,EACxE;AAAA;AAAA;AAAA;AAAA;AAAA,EAOO,UAAmB;AACxB,WAAO,CAAC,CAAC,KAAK,cAAc,KAAK,WAAW;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBA,MAAa,QAAuB;AAClC,QAAI,KAAK,cAAc,KAAK,WAAW,eAAe;AACpD,UAAI;AACF,cAAM,KAAK,WAAW,QAAQ;AAAA,MAChC,SAAS,OAAO;AACd,gBAAQ,MAAM,gDAAgD,KAAK;AACnE,cAAM;AAAA,MACR;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKO,gBAA4B;AACjC,QAAI,CAAC,KAAK,YAAY;AACpB,YAAM,IAAI,MAAM,qCAAqC;AAAA,IACvD;AACA,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,MAAa,oBAAmC;AAE9C,UAAM,KAAK;AAEX,QAAI,CAAC,KAAK,YAAY;AACpB,YAAM,IAAI,MAAM,iCAAiC;AAAA,IACnD;AAGA,QAAI,CAAC,KAAK,WAAW,eAAe;AAClC,UAAI;AACF,cAAM,KAAK,WAAW,WAAW;AAAA,MACnC,SAAS,OAAO;AACd,gBAAQ,MAAM,oCAAoC,KAAK;AACvD,cAAM;AAAA,MACR;AAAA,IACF;AAEA,QAAI,CAAC,KAAK,mBAAmB;AAC3B,YAAM,IAAI,MAAM,wCAAwC;AAAA,IAC1D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,iBAAiB,QAUT;AACb,UAAM,aAAkB;AAAA,MACtB,MAAM,OAAO;AAAA,MACb,aAAa,OAAO,eAAe;AAAA,MACnC,SAAS,OAAO,WAAW;AAAA,MAC3B,UAAU,CAAC;AAAA,MACX,YAAY,CAAC;AAAA,MACb,aAAa,CAAC;AAAA,IAChB;AAEA,QAAI,OAAO,SAAS,UAAU;AAC5B,iBAAW,WAAW,OAAO,YAAY;AAAA,IAC3C,OAAO;AACL,iBAAW,OAAO,OAAO;AACzB,iBAAW,OAAO,OAAO;AACzB,iBAAW,WAAW,OAAO;AAC7B,iBAAW,WAAW,OAAO;AAC7B,iBAAW,WAAW,OAAO;AAAA,IAC/B;AAEA,WAAO,IAAI,2BAAW,UAAU;AAAA,EAClC;AACF;;;AD1vBO,IAAM,cAAN,MAAM,qBAAoB,cAAc;AAAA;AAAA;AAAA;AAAA;AAAA,EAK7C,YAAY,QAA2B;AACrC,UAAM,aAAa,aAAY,sBAAsB,MAAM;AAC3D,UAAM,EAAE,GAAG,QAAQ,WAAW,CAAC;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA,EAKA,OAAe,sBAAsB,QAAuC;AAC1E,UAAM,UAAkC;AAAA;AAAA,MAEtC,GAAG,OAAO;AAAA;AAAA,MAGV,MAAM;AAAA;AAAA,MAGN,UAAU;AAAA,QACR,wBAAwB,OAAO,kBAAkB,eAAe;AAAA,QAChE,wBAAwB,OAAO,kBAAkB,cAAc;AAAA,QAC/D;AAAA,UACE,OAAO,oBAAoB;AAAA,QAC7B;AAAA,MACF;AAAA,MAEA,aAAa,OAAO,mBAAmB;AAAA,MACvC,SAAS,OAAO,iBAAiB;AAAA;AAAA,MAGjC,SAAS,OAAO,WAAW,WAAW;AAAA,MACtC,UAAU,OAAO,WAAW,YAAY;AAAA;AAAA,MAGxC,OAAO;AAAA;AAAA,QAEL,mBAAmB;AAAA;AAAA,QACnB,kBAAkB;AAAA,QAClB,oBAAoB;AAAA;AAAA,QACpB,aAAa;AAAA;AAAA;AAAA,QAGb,GAAG,OAAO,WAAW;AAAA,MACvB;AAAA,IACF;AAEA,WAAO,IAAI,2BAAW,OAAO;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwBA,OAAO,qBACL,kBACA,WACA,SACa;AAEb,UAAM,MAAM,IAAI,IAAI,gBAAgB;AAEpC,QAAI,IAAI,aAAa,UAAU;AAC7B,YAAM,IAAI;AAAA,QACR;AAAA,MACF;AAAA,IACF;AAEA,UAAM,aAAoC;AAAA,MACxC,MAAM,IAAI;AAAA,MACV,MAAM,IAAI,OAAO,SAAS,IAAI,IAAI,IAAI;AAAA,MACtC,UAAU,IAAI;AAAA,MACd,UAAU,IAAI;AAAA,MACd,UAAU,IAAI,SAAS,MAAM,CAAC;AAAA;AAAA,IAChC;AAEA,WAAO,IAAI,aAAY;AAAA,MACrB;AAAA,MACA;AAAA,MACA,GAAG;AAAA,IACL,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoBA,OAAO,OAAO,QAAwC;AACpD,WAAO,IAAI,aAAY;AAAA,MACrB,YAAY,OAAO;AAAA,MACnB,WAAW,OAAO;AAAA,MAClB,gBAAgB,OAAO;AAAA,MACvB,gBAAgB,OAAO;AAAA,MACvB,kBAAkB,OAAO;AAAA,MACzB,gBAAgB,OAAO;AAAA,MACvB,yBAAyB,OAAO;AAAA,MAChC,YAAY,OAAO;AAAA,MACnB,WAAW,OAAO;AAAA,MAClB,YAAY,OAAO;AAAA,IACrB,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA;AAAA,EAMO,oBAKL;AACA,UAAM,UAAW,KAAa,WAAW;AACzC,WAAO;AAAA,MACL,MAAM,QAAQ;AAAA,MACd,MAAM,QAAQ;AAAA,MACd,UAAU,QAAQ;AAAA,MAClB,UAAU,QAAQ;AAAA,IACpB;AAAA,EACF;AACF;;;AQjRA,IAAAC,kBAA2B;;;ACM3B,IAAAC,kBAAuC;;;ACsChC,IAAe,qBAAf,MAAkC;AAAA;AAAA;AAAA;AAAA;AAAA,EAQvC,YAAY,SAAc,CAAC,GAAG;AAC5B,SAAK,SAAS;AAAA,MACZ,GAAG;AAAA,IACL;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA2FU,mBAA2B;AACnC,WAAO,UAAU,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,OAAO,GAAG,CAAC,CAAC;AAAA,EACxE;AACF;;;AC7IO,IAAM,qBAAN,cAAiC,mBAAmB;AAAA,EAIzD,YAAY,QAAkC;AAC5C,UAAM;AAEN,SAAK,SAAS,OAAO;AACrB,SAAK,YAAY,OAAO,aAAa;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OACJ,QACe;AACf,QAAI;AACF,YAAM,KAAK,OAAO,aAAa;AAAA,QAC7B,WAAW,KAAK;AAAA,QAChB,SAAS,OAAO;AAAA,QAChB,UAAU,OAAO;AAAA;AAAA,MAEnB,CAAC;AAAA,IACH,SAAS,OAAO;AACd,cAAQ,MAAM,2BAA2B,KAAK;AAC9C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,UAAyC;AACzD,UAAM,WAAW,SAAS,IAAI,CAAC,WAAW,KAAK,OAAO,MAAM,CAAC;AAC7D,UAAM,QAAQ,IAAI,QAAQ;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAS,OAA6C;AAC1D,QAAI;AACF,YAAM,SAAS,MAAM,KAAK,OAAO,aAAa;AAAA,QAC5C,WAAW,KAAK;AAAA,QAChB,OAAO,MAAM;AAAA,QACb,QAAQ,MAAM;AAAA,QACd,SAAS,MAAM;AAAA,QACf,OAAO,MAAM;AAAA,MACf,CAAC;AAED,aAAO,OAAO,QAAQ,IAAI,CAAC,YAAY;AAAA,QACrC,IAAI,OAAO;AAAA,QACX,UAAU,OAAO;AAAA,QACjB,SAAS,OAAO;AAAA,QAChB,WAAW,IAAI,KAAK,OAAO,UAAU;AAAA,QACrC,WAAW,OAAO,aAAa,IAAI,KAAK,OAAO,UAAU,IAAI;AAAA,QAC7D,UAAU;AAAA;AAAA,UAER,UAAU,OAAO;AAAA,QACnB;AAAA,MACF,EAAE;AAAA,IACJ,SAAS,OAAO;AACd,cAAQ,MAAM,8BAA8B,KAAK;AACjD,aAAO,CAAC;AAAA,IACV;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO,UAA+C;AAC1D,QAAI;AACF,UAAI,OAAO,aAAa,UAAU;AAChC,cAAM,KAAK,OAAO,aAAa;AAAA,UAC7B,WAAW,KAAK;AAAA,UAChB;AAAA,QACF,CAAC;AAAA,MACH,OAAO;AAEL,cAAM,WAAW,MAAM,KAAK,SAAS,QAAQ;AAC7C,mBAAW,UAAU,UAAU;AAC7B,gBAAM,KAAK,OAAO,aAAa;AAAA,YAC7B,WAAW,KAAK;AAAA,YAChB,UAAU,OAAO;AAAA,UACnB,CAAC;AAAA,QACH;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,0BAA0B,KAAK;AAC7C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OACJ,UACA,SACe;AACf,QAAI;AACF,UAAI,QAAQ,SAAS;AACnB,cAAM,KAAK,OAAO,aAAa;AAAA,UAC7B,WAAW,KAAK;AAAA,UAChB,UAAU;AAAA,UACV,SAAS,QAAQ;AAAA,QACnB,CAAC;AAAA,MACH;AAGA,UAAI,QAAQ,YAAY,QAAQ,UAAU;AACxC,cAAM,WAAW,MAAM,KAAK,SAAS;AAAA,UACnC,OAAO,EAAE,WAAW,SAAS;AAAA,UAC7B,OAAO;AAAA,QACT,CAAC;AAED,YAAI,SAAS,SAAS,GAAG;AACvB,gBAAM,KAAK,OAAO,QAAQ;AAE1B,gBAAM,YAA0B;AAAA,YAC9B,IAAI;AAAA,YACJ,UAAU,QAAQ,YAAY,SAAS,CAAC,EAAE;AAAA,YAC1C,SAAS,QAAQ,WAAW,SAAS,CAAC,EAAE;AAAA,YACxC,WAAW,SAAS,CAAC,EAAE;AAAA,YACvB,WAAW,oBAAI,KAAK;AAAA,YACpB,UAAU,EAAE,GAAG,SAAS,CAAC,EAAE,UAAU,GAAG,QAAQ,SAAS;AAAA,UAC3D;AACA,gBAAM,KAAK,OAAO,SAAS;AAAA,QAC7B;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,0BAA0B,KAAK;AAC7C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eACJ,OACA,SACyB;AACzB,QAAI;AACF,YAAM,SAAS,MAAM,KAAK,OAAO,cAAc;AAAA,QAC7C,SAAS;AAAA,QACT,WAAW,KAAK;AAAA,QAChB,YAAY,SAAS;AAAA,QACrB,OAAO,SAAS;AAAA,QAChB,SAAS,SAAS;AAAA,QAClB,OAAO,SAAS;AAAA,MAClB,CAAC;AAED,aAAO,OAAO,QAAQ,IAAI,CAAC,YAAY;AAAA,QACrC,IAAI,OAAO;AAAA,QACX,UAAU,OAAO;AAAA,QACjB,SAAS,OAAO;AAAA,QAChB,WAAW,IAAI,KAAK,OAAO,UAAU;AAAA,QACrC,WAAW,OAAO,aAAa,IAAI,KAAK,OAAO,UAAU,IAAI;AAAA,QAC7D,UAAU;AAAA,UACR,UAAU,OAAO;AAAA,UACjB,OAAO,OAAO;AAAA,QAChB;AAAA,MACF,EAAE;AAAA,IACJ,SAAS,OAAO;AACd,cAAQ,MAAM,6BAA6B,KAAK;AAChD,aAAO,CAAC;AAAA,IACV;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAM,UAAkC;AAC5C,QAAI;AACF,YAAM,QAAqB,WAAW,EAAE,YAAY,CAAC,QAAQ,EAAE,IAAI,CAAC;AACpE,YAAM,KAAK,OAAO,KAAK;AAAA,IACzB,SAAS,OAAO;AACd,cAAQ,MAAM,4BAA4B,KAAK;AAC/C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,iBACJ,UACA,SACyB;AACzB,UAAM,oBAAoC,CAAC;AAE3C,UAAM,IAAI,MAAM,mCAAmC;AAAA,EAgCrD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBACJ,UACA,QAAgB,GACS;AACzB,QAAI;AACF,YAAM,SAAS,MAAM,KAAK,SAAS;AAAA,QACjC,OAAO,EAAE,WAAW,SAAS;AAAA,QAC7B,OAAO;AAAA,MACT,CAAC;AAED,UAAI,OAAO,WAAW,GAAG;AACvB,eAAO,CAAC;AAAA,MACV;AAEA,YAAM,eAAe,OAAO,CAAC;AAC7B,YAAM,eAA4B;AAAA,QAChC,SAAS,aAAa;AAAA,QACtB,OAAO;AAAA,MACT;AAEA,YAAM,UAAU,MAAM,KAAK,SAAS,YAAY;AAGhD,aAAO,QAAQ,OAAO,CAAC,MAAM,EAAE,OAAO,QAAQ;AAAA,IAChD,SAAS,OAAO;AACd,cAAQ,MAAM,mCAAmC,KAAK;AACtD,aAAO,CAAC;AAAA,IACV;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,cAA6B;AACjC,UAAM,IAAI,MAAM,sCAAsC;AAAA,EACxD;AACF;;;AC/RA,oBAMO;AAyBA,IAAM,qBAAN,cAAiC,mBAAmB;AAAA,EAIzD,YAAY,QAAkC;AAC5C,UAAM,MAAM;AAGZ,UAAM,EAAE,QAAQ,SAAS,OAAO,GAAG,cAAc,IAAI;AAGrD,SAAK,SAAS,IAAI,2BAAa,aAAa;AAG5C,SAAK,iBAAiB;AAAA,MACpB,SAAS,OAAO;AAAA,MAChB,UAAU,OAAO;AAAA,MACjB,QAAQ,OAAO;AAAA,IACjB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO,QAAqC;AAChD,QAAI;AACF,YAAM,WAAsB;AAAA,QAC1B;AAAA,UACE,MAAM,OAAO,QAAQ;AAAA,UACrB,SAAS,OAAO;AAAA,QAClB;AAAA,MACF;AAEA,YAAM,UAAyB;AAAA,QAC7B,GAAG,KAAK;AAAA,QACR,UAAU;AAAA,UACR,GAAG,OAAO;AAAA,UACV,UAAU,OAAO;AAAA,UACjB,IAAI,OAAO;AAAA,QACb;AAAA,MACF;AAEA,YAAM,SAAS,MAAM,KAAK,OAAO,IAAI,UAAU,OAAO;AACtD,cAAQ,IAAI,0CAA0C,OAAO,CAAC,GAAG,EAAE,EAAE;AAAA,IACvE,SAAS,OAAO;AACd,cAAQ,MAAM,2BAA2B,KAAK;AAC9C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,YAAY,UAAyC;AACzD,QAAI;AAGF,iBAAW,UAAU,UAAU;AAC7B,cAAM,KAAK,OAAO,MAAM;AAAA,MAC1B;AACA,cAAQ,IAAI,kBAAkB,SAAS,MAAM,wBAAwB;AAAA,IACvE,SAAS,OAAO;AACd,cAAQ,MAAM,mCAAmC,KAAK;AACtD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAS,OAA6C;AAC1D,QAAI;AACF,YAAM,UAAyB;AAAA,QAC7B,GAAG,KAAK;AAAA,QACR,OAAO,MAAM;AAAA,QACb,MAAM,MAAM,SACR,KAAK,MAAM,MAAM,UAAU,MAAM,SAAS,GAAG,IAAI,IACjD;AAAA,QACJ,WAAW,MAAM;AAAA,QACjB,UAAU,MAAM,WAAW,EAAE,UAAU,MAAM,SAAS,IAAI;AAAA,QAC1D,SAAS,MAAM,WAAW,CAAC;AAAA,MAC7B;AAEA,UAAI;AAEJ,UAAI,MAAM,OAAO;AAEf,mBAAW,MAAM,KAAK,OAAO,OAAO,MAAM,OAAO,OAAO;AAAA,MAC1D,OAAO;AAEL,mBAAW,MAAM,KAAK,OAAO,OAAO,OAAO;AAAA,MAC7C;AAEA,aAAO,KAAK,wBAAwB,QAAQ;AAAA,IAC9C,SAAS,OAAO;AACd,cAAQ,MAAM,8BAA8B,KAAK;AACjD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO,UAA+C;AAC1D,QAAI;AACF,UAAI,OAAO,aAAa,UAAU;AAEhC,cAAM,KAAK,OAAO,OAAO,QAAQ;AACjC,gBAAQ,IAAI,UAAU,QAAQ,uBAAuB;AAAA,MACvD,OAAO;AAEL,cAAM,WAAW,MAAM,KAAK,SAAS,QAAQ;AAC7C,mBAAW,UAAU,UAAU;AAC7B,gBAAM,KAAK,OAAO,OAAO,OAAO,EAAE;AAAA,QACpC;AACA,gBAAQ,IAAI,WAAW,SAAS,MAAM,0BAA0B;AAAA,MAClE;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,0BAA0B,KAAK;AAC7C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OACJ,UACA,SACe;AACf,QAAI;AACF,YAAM,aAAgE,CAAC;AAEvE,UAAI,QAAQ,SAAS;AACnB,mBAAW,OAAO,QAAQ;AAAA,MAC5B;AAEA,UAAI,QAAQ,YAAY,QAAQ,UAAU;AACxC,mBAAW,WAAW;AAAA,UACpB,GAAG,QAAQ;AAAA,UACX,GAAI,QAAQ,YAAY,EAAE,UAAU,QAAQ,SAAS;AAAA,QACvD;AAAA,MACF;AAEA,YAAM,KAAK,OAAO,OAAO,UAAU,UAAU;AAC7C,cAAQ,IAAI,UAAU,QAAQ,uBAAuB;AAAA,IACvD,SAAS,OAAO;AACd,cAAQ,MAAM,0BAA0B,KAAK;AAC7C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAM,UAAkC;AAC5C,QAAI;AACF,UAAI,UAAU;AAEZ,cAAM,UAAyB;AAAA,UAC7B,GAAG,KAAK;AAAA,UACR,SAAS,EAAE,SAAS;AAAA,QACtB;AACA,cAAM,KAAK,OAAO,UAAU,OAAO;AACnC,gBAAQ,IAAI,mCAAmC,QAAQ,EAAE;AAAA,MAC3D,OAAO;AAEL,cAAM,KAAK,OAAO,UAAU,KAAK,cAAc;AAC/C,gBAAQ,IAAI,sBAAsB;AAAA,MACpC;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,4BAA4B,KAAK;AAC/C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBACJ,UACA,SACyB;AACzB,QAAI;AAEF,YAAM,eAA0B,SAAS,IAAI,CAAC,SAAS;AAAA,QACrD,MAAM,IAAI,QAAQ;AAAA,QAClB,SACE,OAAO,IAAI,YAAY,WACnB,IAAI,UACJ,KAAK,UAAU,IAAI,OAAO;AAAA,MAClC,EAAE;AAEF,YAAM,UAAyB;AAAA,QAC7B,GAAG,KAAK;AAAA,QACR,SAAS,QAAQ,UAAU,KAAK,eAAe;AAAA,QAC/C,UAAU,QAAQ,WAAW,KAAK,eAAe;AAAA,QACjD,QAAQ,QAAQ,SAAS,KAAK,eAAe;AAAA,QAC7C,QAAQ,QAAQ;AAAA,QAChB,UAAU,QAAQ,YAAY,CAAC;AAAA,MACjC;AAGA,YAAM,oBAAoB,MAAM,KAAK,OAAO,IAAI,cAAc,OAAO;AAErE,YAAM,iBAAiB,kBAAkB;AAAA,QAAI,CAAC,WAC5C,KAAK,0BAA0B,MAAM;AAAA,MACvC;AAEA,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,8BAA8B,KAAK;AACjD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,eACJ,OACA,SACyB;AACzB,QAAI;AACF,YAAM,gBAA+B;AAAA,QACnC,GAAG,KAAK;AAAA,QACR,OAAO,SAAS,SAAS;AAAA,QACzB,WAAW,SAAS,aAAa;AAAA,QACjC,QAAQ;AAAA,QACR,cAAc;AAAA,QACd,SAAS,SAAS,WAAW,CAAC;AAAA,QAC9B,GAAI,SAAS,YAAY;AAAA,UACvB,SAAS;AAAA,YACP,GAAG,QAAQ;AAAA,YACX,UAAU,QAAQ;AAAA,UACpB;AAAA,QACF;AAAA,MACF;AAEA,YAAM,WAAW,MAAM,KAAK,OAAO,OAAO,OAAO,aAAa;AAC9D,aAAO,KAAK,wBAAwB,QAAQ;AAAA,IAC9C,SAAS,OAAO;AACd,cAAQ,MAAM,6BAA6B,KAAK;AAChD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBACJ,UACA,OACyB;AACzB,QAAI;AAEF,YAAM,iBAAiB,MAAM,KAAK,OAAO,IAAI,QAAQ;AAErD,UAAI,CAAC,eAAe,QAAQ;AAC1B,eAAO,CAAC;AAAA,MACV;AAGA,YAAM,gBAA+B;AAAA,QACnC,GAAG,KAAK;AAAA,QACR,OAAO,SAAS;AAAA,QAChB,cAAc;AAAA,QACd,QAAQ;AAAA,QACR,WAAW;AAAA,MACb;AAEA,YAAM,kBAAkB,MAAM,KAAK,OAAO;AAAA,QACxC,eAAe;AAAA,QACf;AAAA,MACF;AAGA,YAAM,mBAAmB,gBAAgB;AAAA,QACvC,CAAC,WAAW,OAAO,OAAO;AAAA,MAC5B;AAEA,aAAO,KAAK,wBAAwB,gBAAgB;AAAA,IACtD,SAAS,OAAO;AACd,cAAQ,MAAM,mCAAmC,KAAK;AACtD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,cAA6B;AACjC,QAAI;AAGF,YAAM,cAAc,MAAM,KAAK,OAAO,OAAO;AAAA,QAC3C,GAAG,KAAK;AAAA,QACR,OAAO;AAAA;AAAA,MACT,CAAC;AAED,cAAQ;AAAA,QACN,qCAAqC,YAAY,MAAM;AAAA,MACzD;AAAA,IACF,SAAS,OAAO;AACd,cAAQ,MAAM,2BAA2B,KAAK;AAC9C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,UAAkC;AACvD,QAAI;AACF,YAAM,UAAU,MAAM,KAAK,OAAO,QAAQ,QAAQ;AAClD,aAAO;AAAA,IACT,SAAS,OAAO;AACd,cAAQ,MAAM,iCAAiC,KAAK;AACpD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WAAyB;AAC7B,QAAI;AACF,aAAO,MAAM,KAAK,OAAO,MAAM;AAAA,IACjC,SAAS,OAAO;AACd,cAAQ,MAAM,wBAAwB,KAAK;AAC3C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,gBACJ,UACA,UACA,QACe;AACf,QAAI;AACF,YAAM,KAAK,OAAO,SAAS;AAAA,QACzB,WAAW;AAAA,QACX;AAAA,QACA,iBAAiB;AAAA,MACnB,CAAC;AACD,cAAQ,IAAI,gCAAgC,QAAQ,KAAK,QAAQ,EAAE;AAAA,IACrE,SAAS,OAAO;AACd,cAAQ,MAAM,6BAA6B,KAAK;AAChD,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAsB;AAC1B,QAAI;AACF,YAAM,KAAK,OAAO,KAAK;AACvB,cAAQ,IAAI,4BAA4B;AAAA,IAC1C,SAAS,OAAO;AACd,cAAQ,MAAM,uBAAuB,KAAK;AAC1C,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAOQ,wBAAwB,cAAwC;AACtE,QAAI,CAAC,gBAAgB,CAAC,MAAM,QAAQ,YAAY,GAAG;AACjD,aAAO,CAAC;AAAA,IACV;AACA,WAAO,aAAa,IAAI,CAAC,WAAW,KAAK,0BAA0B,MAAM,CAAC;AAAA,EAC5E;AAAA;AAAA;AAAA;AAAA,EAKQ,0BAA0B,QAA8B;AAC9D,WAAO;AAAA,MACL,IAAI,OAAO;AAAA,MACX,SAAS,OAAO,UAAU,OAAO,MAAM,UAAU;AAAA,MACjD,UAAU,OAAO,UAAU,YAAY;AAAA,MACvC,UAAU;AAAA,QACR,GAAG,OAAO;AAAA,QACV,SAAS,OAAO;AAAA,QAChB,YAAY,OAAO;AAAA,QACnB,OAAO,OAAO;AAAA,QACd,MAAM,OAAO;AAAA,QACb,aAAa,OAAO;AAAA,QACpB,OAAO,OAAO;AAAA,QACd,UAAU,OAAO;AAAA,QACjB,QAAQ,OAAO;AAAA,QACf,QAAQ,OAAO;AAAA,MACjB;AAAA,MACA,WAAW,OAAO,cAAc,oBAAI,KAAK;AAAA,MACzC,WAAW,OAAO,cAAc,oBAAI,KAAK;AAAA,IAC3C;AAAA,EACF;AACF;","names":["EventType","InMemoryQueryBuilder","InMemoryUpdateBuilder","tool","import_client","import_node_crypto","ErrorCategory","tool","tool","import_node_crypto","import_node_crypto","import_v4","tool","InMemoryAdapter","tool","toAGUIAgent","import_v4","import_events","cleanError","OpenAI","Anthropic","tool","import_v4","tool","import_node_crypto","CollectionManager","DocumentConverter","CollectionManager","DocumentConverter","DocumentConverter","DocumentConverter","import_typeorm","import_typeorm","import_reflect_metadata","import_typeorm","import_reflect_metadata","import_typeorm","DocumentConverter","import_typeorm","import_typeorm"]}