/**
 * Copy from https://github.com/souche-koumakan/crc64_ecma182.js/blob/master/crc64_ecma182.js
 *
 * Modify by annexwu, add CRC64TransformStream and getCRC64FromBuffer methods
 *
 * Kaidi ZHU <zhukaidi@souche.com> created at 2017-09-07 16:02:19 with ‚ù§
 * Copyright (c) 2017 Souche.com, all rights reserved.
 */
'use strict';

const { Transform } = require('stream');
const binding = require('./crc');

const raw = {
  crc64: binding.cwrap('crc64', 'null', ['number', 'number', 'number']),
  crc64Init: binding.cwrap('crc64_init', 'null', []),
  strToUint64Ptr: binding.cwrap('str_to_uint64', 'null', ['number', 'number']),
  uint64PtrToStr: binding.cwrap('uint64_to_str', 'null', ['number', 'number']),
};

raw.crc64Init();

function strToUint64Ptr(str) {
  const strPtr = binding._malloc(str.length + 1);
  binding.stringToUTF8(str, strPtr, str.length + 1);

  const uint64Ptr = binding._malloc(8);
  raw.strToUint64Ptr(strPtr, uint64Ptr);
  binding._free(strPtr);

  return uint64Ptr;
}

function uint64PtrToStr(uint64Ptr) {
  const strPtr = binding._malloc(32);
  raw.uint64PtrToStr(strPtr, uint64Ptr);
  const str = binding.UTF8ToString(strPtr);
  binding._free(strPtr);
  return str;
}

function buffToPtr(buff) {
  if (typeof buff === 'string') {
    buff = new Buffer(buff);
  } else if (!Buffer.isBuffer(buff)) {
    throw new Error('Invalid buffer type.');
  }
  const buffPtr = binding._malloc(buff.length);
  binding.writeArrayToMemory(buff, buffPtr);
  return buffPtr;
}

class CRC64TransformStream extends Transform {
  constructor(...args) {
    super(...args);
    this.crcPtr = strToUint64Ptr('0');
    this.crcPtrFreed = false;
  }
  _transform(chunk, encoding, callback) {
    const buffPtr = buffToPtr(chunk);
    raw.crc64(this.crcPtr, buffPtr, chunk.length);
    binding._free(buffPtr);
    callback(null, chunk);
  }
  _flush(callback) {
    const ret = uint64PtrToStr(this.crcPtr);
    if (!this.crcPtrFreed) {
      binding._free(this.crcPtr);
      this.crcPtrFreed = true;
    }
    this.emit('hash', ret);
    callback();
  }
}

function getCRC64FromBuffer(buff, prev) {
  if (!prev) prev = '0';
  if (typeof prev !== 'string' || !/\d+/.test(prev)) {
    throw new Error('Invlid previous value.');
  }
  const prevPtr = strToUint64Ptr(prev);
  const buffPtr = buffToPtr(buff);
  raw.crc64(prevPtr, buffPtr, buff.length);
  const ret = uint64PtrToStr(prevPtr);
  binding._free(prevPtr);
  binding._free(buffPtr);
  return ret;
}

module.exports = {
  CRC64TransformStream,
  getCRC64FromBuffer,
};
