{"version":3,"file":"last_value.cjs","names":["BaseChannel","InvalidUpdateError","EmptyChannelError"],"sources":["../../src/channels/last_value.ts"],"sourcesContent":["import { EmptyChannelError, InvalidUpdateError } from \"../errors.js\";\nimport { BaseChannel } from \"./base.js\";\n\n/**\n * Stores the last value received, can receive at most one value per step.\n *\n * Since `update` is only called once per step and value can only be of length 1,\n * LastValue always stores the last value of a single node. If multiple nodes attempt to\n * write to this channel in a single step, an error will be thrown.\n * @internal\n */\nexport class LastValue<Value> extends BaseChannel<Value, Value, Value> {\n  lc_graph_name = \"LastValue\";\n\n  // value is an array so we don't misinterpret an update to undefined as no write\n  value: [Value] | [] = [];\n\n  constructor(protected initialValueFactory?: () => Value) {\n    super();\n    if (initialValueFactory) {\n      this.value = [initialValueFactory()];\n    }\n  }\n\n  fromCheckpoint(checkpoint?: Value) {\n    const empty = new LastValue<Value>(this.initialValueFactory);\n    if (typeof checkpoint !== \"undefined\") {\n      empty.value = [checkpoint];\n    }\n\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    if (values.length === 0) {\n      return false;\n    }\n    if (values.length !== 1) {\n      throw new InvalidUpdateError(\n        \"LastValue can only receive one value per step.\",\n        { lc_error_code: \"INVALID_CONCURRENT_GRAPH_UPDATE\" }\n      );\n    }\n\n    // eslint-disable-next-line prefer-destructuring\n    this.value = [values[values.length - 1]];\n    return true;\n  }\n\n  get(): Value {\n    if (this.value.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  checkpoint(): Value {\n    if (this.value.length === 0) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  isAvailable(): boolean {\n    return this.value.length !== 0;\n  }\n}\n\n/**\n * Stores the last value received, but only made available after finish().\n * Once made available, clears the value.\n */\nexport class LastValueAfterFinish<Value> extends BaseChannel<\n  Value,\n  Value,\n  [Value, boolean]\n> {\n  lc_graph_name = \"LastValueAfterFinish\";\n\n  // value is an array so we don't misinterpret an update to undefined as no write\n  value: [Value] | [] = [];\n\n  finished: boolean = false;\n\n  fromCheckpoint(checkpoint?: [Value, boolean]) {\n    const empty = new LastValueAfterFinish<Value>();\n    if (typeof checkpoint !== \"undefined\") {\n      const [value, finished] = checkpoint;\n      empty.value = [value];\n      empty.finished = finished;\n    }\n    return empty as this;\n  }\n\n  update(values: Value[]): boolean {\n    if (values.length === 0) {\n      return false;\n    }\n\n    this.finished = false;\n    // eslint-disable-next-line prefer-destructuring\n    this.value = [values[values.length - 1]];\n    return true;\n  }\n\n  get(): Value {\n    if (this.value.length === 0 || !this.finished) {\n      throw new EmptyChannelError();\n    }\n    return this.value[0];\n  }\n\n  checkpoint(): [Value, boolean] | undefined {\n    if (this.value.length === 0) return undefined;\n    return [this.value[0], this.finished];\n  }\n\n  consume(): boolean {\n    if (this.finished) {\n      this.finished = false;\n      this.value = [];\n      return true;\n    }\n    return false;\n  }\n\n  finish(): boolean {\n    if (!this.finished && this.value.length > 0) {\n      this.finished = true;\n      return true;\n    }\n    return false;\n  }\n\n  isAvailable(): boolean {\n    return this.value.length !== 0 && this.finished;\n  }\n}\n"],"mappings":";;;;;;;;;;;;AAWA,IAAa,YAAb,MAAa,kBAAyBA,yBAAiC;CACrE,gBAAgB;CAGhB,QAAsB,EAAE;CAExB,YAAY,AAAU,qBAAmC;AACvD,SAAO;EADa;AAEpB,MAAI,oBACF,MAAK,QAAQ,CAAC,qBAAqB,CAAC;;CAIxC,eAAe,YAAoB;EACjC,MAAM,QAAQ,IAAI,UAAiB,KAAK,oBAAoB;AAC5D,MAAI,OAAO,eAAe,YACxB,OAAM,QAAQ,CAAC,WAAW;AAG5B,SAAO;;CAGT,OAAO,QAA0B;AAC/B,MAAI,OAAO,WAAW,EACpB,QAAO;AAET,MAAI,OAAO,WAAW,EACpB,OAAM,IAAIC,kCACR,kDACA,EAAE,eAAe,mCAAmC,CACrD;AAIH,OAAK,QAAQ,CAAC,OAAO,OAAO,SAAS,GAAG;AACxC,SAAO;;CAGT,MAAa;AACX,MAAI,KAAK,MAAM,WAAW,EACxB,OAAM,IAAIC,kCAAmB;AAE/B,SAAO,KAAK,MAAM;;CAGpB,aAAoB;AAClB,MAAI,KAAK,MAAM,WAAW,EACxB,OAAM,IAAIA,kCAAmB;AAE/B,SAAO,KAAK,MAAM;;CAGpB,cAAuB;AACrB,SAAO,KAAK,MAAM,WAAW;;;;;;;AAQjC,IAAa,uBAAb,MAAa,6BAAoCF,yBAI/C;CACA,gBAAgB;CAGhB,QAAsB,EAAE;CAExB,WAAoB;CAEpB,eAAe,YAA+B;EAC5C,MAAM,QAAQ,IAAI,sBAA6B;AAC/C,MAAI,OAAO,eAAe,aAAa;GACrC,MAAM,CAAC,OAAO,YAAY;AAC1B,SAAM,QAAQ,CAAC,MAAM;AACrB,SAAM,WAAW;;AAEnB,SAAO;;CAGT,OAAO,QAA0B;AAC/B,MAAI,OAAO,WAAW,EACpB,QAAO;AAGT,OAAK,WAAW;AAEhB,OAAK,QAAQ,CAAC,OAAO,OAAO,SAAS,GAAG;AACxC,SAAO;;CAGT,MAAa;AACX,MAAI,KAAK,MAAM,WAAW,KAAK,CAAC,KAAK,SACnC,OAAM,IAAIE,kCAAmB;AAE/B,SAAO,KAAK,MAAM;;CAGpB,aAA2C;AACzC,MAAI,KAAK,MAAM,WAAW,EAAG,QAAO;AACpC,SAAO,CAAC,KAAK,MAAM,IAAI,KAAK,SAAS;;CAGvC,UAAmB;AACjB,MAAI,KAAK,UAAU;AACjB,QAAK,WAAW;AAChB,QAAK,QAAQ,EAAE;AACf,UAAO;;AAET,SAAO;;CAGT,SAAkB;AAChB,MAAI,CAAC,KAAK,YAAY,KAAK,MAAM,SAAS,GAAG;AAC3C,QAAK,WAAW;AAChB,UAAO;;AAET,SAAO;;CAGT,cAAuB;AACrB,SAAO,KAAK,MAAM,WAAW,KAAK,KAAK"}