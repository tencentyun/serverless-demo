{"version":3,"file":"event_source_parse.d.cts","names":["IterableReadableStream","EventStreamContentType","EventSourceMessage","getBytes","Uint8Array","ReadableStream","AsyncIterable","Promise","getLines","ArrayBufferLike","getMessages","convertEventStreamToIterableReadableDataStream"],"sources":["../../src/utils/event_source_parse.d.ts"],"sourcesContent":["import { IterableReadableStream } from \"./stream.js\";\nexport declare const EventStreamContentType = \"text/event-stream\";\n/**\n * Represents a message sent in an event stream\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events#Event_stream_format\n */\nexport interface EventSourceMessage {\n    /** The event ID to set the EventSource object's last event ID value. */\n    id: string;\n    /** A string identifying the type of event described. */\n    event: string;\n    /** The event data */\n    data: string;\n    /** The reconnection interval (in milliseconds) to wait before retrying the connection */\n    retry?: number;\n}\n/**\n * Converts a ReadableStream into a callback pattern.\n * @param stream The input ReadableStream.\n * @param onChunk A function that will be called on each new byte chunk in the stream.\n * @returns {Promise<void>} A promise that will be resolved when the stream closes.\n */\nexport declare function getBytes(stream: ReadableStream<Uint8Array> | AsyncIterable<any>, onChunk: (arr: Uint8Array, flush?: boolean) => void): Promise<void>;\n/**\n * Parses arbitary byte chunks into EventSource line buffers.\n * Each line should be of the format \"field: value\" and ends with \\r, \\n, or \\r\\n.\n * @param onLine A function that will be called on each new EventSource line.\n * @returns A function that should be called for each incoming byte chunk.\n */\nexport declare function getLines(onLine: (line: Uint8Array, fieldLength: number, flush?: boolean) => void): (arr: Uint8Array<ArrayBufferLike>, flush?: boolean | undefined) => void;\n/**\n * Parses line buffers into EventSourceMessages.\n * @param onId A function that will be called on each `id` field.\n * @param onRetry A function that will be called on each `retry` field.\n * @param onMessage A function that will be called on each message.\n * @returns A function that should be called for each incoming line buffer.\n */\nexport declare function getMessages(onMessage?: (msg: EventSourceMessage) => void, onId?: (id: string) => void, onRetry?: (retry: number) => void): (line: Uint8Array<ArrayBufferLike>, fieldLength: number, flush?: boolean | undefined) => void;\nexport declare function convertEventStreamToIterableReadableDataStream(stream: ReadableStream, onMetadataEvent?: (e: unknown) => unknown): IterableReadableStream<any>;\n//# sourceMappingURL=event_source_parse.d.ts.map"],"mappings":";;;cACqBC,sBAAAA;;AAArB;AAKA;AAgBA;AAAwDG,UAhBvCF,kBAAAA,CAgBuCE;EAAfC;EAA6BC,EAAAA,EAAAA,MAAAA;EAAmCF;EAAuCG,KAAAA,EAAAA,MAAAA;EAAO;EAO/HC,IAAAA,EAAAA,MAAQ;EAAgBJ;EAA6EK,KAAAA,CAAAA,EAAAA,MAAAA;;AAAD;AAQ5H;;;;AAAqK;AAC7IE,iBAhBAR,QAAAA,CAgBAQ,MAAAA,EAhBiBN,cAgB6B,CAhBdD,UAgBuBC,CAAAA,GAhBTC,aAgBqEN,CAAAA,GAAAA,CAAAA,EAAAA,OAAAA,EAAAA,CAAAA,GAAAA,EAhBlCI,UAgBwD,EAAA,KAAA,CAAA,EAAA,OAAA,EAAA,GAAA,IAAA,CAAA,EAhBjBG,OAgBiB,CAAA,IAAA,CAAA;;;;;;;iBATzIC,QAAAA,gBAAwBJ,kEAAkEA,WAAWK;;;;;;;;iBAQrGC,WAAAA,mBAA8BR,qGAAqGE,WAAWK;iBAC9IE,8CAAAA,SAAuDN,4DAA4DL"}