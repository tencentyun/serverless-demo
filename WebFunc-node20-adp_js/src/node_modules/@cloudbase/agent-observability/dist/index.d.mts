import * as _opentelemetry_api from '@opentelemetry/api';
import { Span, TimeInput, Attributes, TracerProvider, SpanContext } from '@opentelemetry/api';

/**
 * Types of observations (spans) supported by AG-Kit observability.
 *
 * These types align with OpenInference semantic conventions:
 * https://github.com/Arize-ai/openinference/tree/main/spec
 *
 * - `span`: General-purpose operations (OpenInference: internal/span)
 * - `llm`: Language model calls (OpenInference: LLM)
 * - `embedding`: Text embedding operations (OpenInference: EMBEDDING)
 * - `agent`: AI agent workflows (OpenInference: AGENT)
 * - `tool`: Tool/function calls (OpenInference: TOOL)
 * - `chain`: Multi-step workflows (OpenInference: CHAIN)
 * - `retriever`: Document retrieval (OpenInference: RETRIEVER)
 * - `reranker`: Result reranking (OpenInference: RERANKER)
 * - `guardrail`: Safety checks (OpenInference: GUARDRAIL)
 * - `evaluator`: Quality assessment (OpenInference: EVALUATOR)
 *
 * @public
 */
type ObservationType = "span" | "llm" | "embedding" | "agent" | "tool" | "chain" | "retriever" | "reranker" | "guardrail" | "evaluator";
/**
 * Severity levels for observations.
 *
 * @public
 */
type ObservationLevel = "DEBUG" | "DEFAULT" | "WARNING" | "ERROR";
/**
 * Token usage details for LLM calls.
 *
 * Follows OpenInference semantic convention:
 * - llm.token_count.prompt
 * - llm.token_count.completion
 * - llm.token_count.total
 *
 * @public
 */
type TokenUsage = {
    /** Number of tokens in the prompt */
    promptTokens?: number;
    /** Number of tokens in the completion */
    completionTokens?: number;
    /** Total number of tokens */
    totalTokens?: number;
};
/**
 * Base attributes for all observation types.
 *
 * Uses OpenInference semantic conventions where applicable:
 * - input.value: Input data
 * - output.value: Output data
 *
 * @public
 */
type BaseSpanAttributes = {
    /** Input data for the operation */
    input?: unknown;
    /** Output data from the operation */
    output?: unknown;
    /** Additional metadata as key-value pairs */
    metadata?: Record<string, unknown>;
    /** Severity level of the observation */
    level?: ObservationLevel;
    /** Human-readable status message */
    statusMessage?: string;
    /** Version identifier for the code/model being tracked */
    version?: string;
    /** Environment where the operation is running (e.g., 'production', 'staging') */
    environment?: string;
};
/**
 * LLM-specific attributes following OpenInference semantic conventions.
 *
 * Uses attributes like:
 * - llm.model_name
 * - llm.parameters.*
 * - llm.token_count.*
 * - llm.invocation_parameters
 *
 * @public
 */
type LLMAttributes = BaseSpanAttributes & {
    /** Timestamp when the model started generating completion */
    completionStartTime?: Date;
    /** Name of the language model (e.g., 'gpt-4', 'claude-3-opus') */
    model?: string;
    /** Parameters passed to the model (temperature, max_tokens, etc.) */
    modelParameters?: Record<string, string | number>;
    /** Token usage metrics */
    usageDetails?: TokenUsage | Record<string, number>;
};
/**
 * Embedding-specific attributes following OpenInference semantic conventions.
 *
 * Uses attributes like:
 * - embedding.model_name
 * - embedding.embeddings.*
 *
 * @public
 */
type EmbeddingAttributes = LLMAttributes;
/**
 * Tool-specific attributes following OpenInference semantic conventions.
 *
 * Uses attributes like:
 * - tool.name
 * - tool.description
 * - tool.parameters
 *
 * @public
 */
type ToolAttributes = BaseSpanAttributes;
/**
 * Agent-specific attributes following OpenInference semantic conventions.
 *
 * Uses attributes like:
 * - agent.name
 * - agent.* (various agent-specific metadata)
 *
 * @public
 */
type AgentAttributes = BaseSpanAttributes;
/**
 * Chain-specific attributes following OpenInference semantic conventions.
 *
 * Uses attributes like:
 * - chain.name
 * - chain.* (various chain-specific metadata)
 *
 * @public
 */
type ChainAttributes = BaseSpanAttributes;
/**
 * Retriever-specific attributes following OpenInference semantic conventions.
 *
 * Uses attributes like:
 * - retriever.name
 * - retriever.query
 * - retriever.*
 *
 * @public
 */
type RetrieverAttributes = BaseSpanAttributes;
/**
 * Reranker-specific attributes following OpenInference semantic conventions.
 *
 * Uses attributes like:
 * - reranker.model_name
 * - reranker.top_k
 * - reranker.*
 *
 * @public
 */
type RerankerAttributes = BaseSpanAttributes;
/**
 * Evaluator-specific attributes.
 *
 * @public
 */
type EvaluatorAttributes = BaseSpanAttributes;
/**
 * Guardrail-specific attributes following OpenInference semantic conventions.
 *
 * Uses attributes like:
 * - guardrail.name
 * - guardrail.*
 *
 * @public
 */
type GuardrailAttributes = BaseSpanAttributes;
/**
 * Union type for all observation attributes.
 *
 * @public
 */
type ObservationAttributes = BaseSpanAttributes & LLMAttributes & ToolAttributes & AgentAttributes & ChainAttributes & RetrieverAttributes & RerankerAttributes & EvaluatorAttributes & GuardrailAttributes;
/**
 * Attributes for traces.
 *
 * Traces are the top-level containers that group related observations together.
 * Uses OpenInference semantic conventions where applicable.
 *
 * @public
 */
type TraceAttributes = {
    /** Human-readable name for the trace */
    name?: string;
    /** Identifier for the user associated with this trace */
    userId?: string;
    /** Session identifier for grouping related traces */
    sessionId?: string;
    /** Version identifier for the code/application */
    version?: string;
    /** Release identifier for deployment tracking */
    release?: string;
    /** Input data that initiated the trace */
    input?: unknown;
    /** Final output data from the trace */
    output?: unknown;
    /** Additional metadata for the trace */
    metadata?: unknown;
    /** Tags for categorizing and filtering traces */
    tags?: string[];
    /** Whether this trace should be publicly visible */
    public?: boolean;
    /** Environment where the trace was captured */
    environment?: string;
};

/**
 * Union type representing any observation wrapper.
 *
 * @public
 */
type Observation = ObservationSpan | ObservationLLM | ObservationEmbedding | ObservationAgent | ObservationTool | ObservationChain | ObservationRetriever | ObservationReranker | ObservationEvaluator | ObservationGuardrail;
/**
 * Parameters for creating an observation wrapper.
 *
 * @internal
 */
type ObservationParams = {
    otelSpan: Span;
    type: ObservationType;
    attributes?: BaseSpanAttributes | LLMAttributes;
};
/**
 * Base class for all observation wrappers.
 *
 * Provides common functionality for all observation types including:
 * - OpenTelemetry span integration
 * - Unique identification (span ID, trace ID)
 * - Lifecycle management (update, end)
 * - Trace context management
 * - Child observation creation
 *
 * @internal
 */
declare abstract class BaseObservation {
    /** The underlying OpenTelemetry span */
    readonly otelSpan: Span;
    /** The observation type */
    readonly type: ObservationType;
    /** The span ID from the OpenTelemetry span context */
    id: string;
    /** The trace ID from the OpenTelemetry span context */
    traceId: string;
    constructor(params: ObservationParams);
    /** Gets the AG-Kit OpenTelemetry tracer instance */
    protected get tracer(): _opentelemetry_api.Tracer;
    /**
     * Ends the observation, marking it as complete.
     *
     * @param endTime - Optional end time, defaults to current time
     */
    end(endTime?: TimeInput): void;
    /**
     * Updates the OTEL span attributes.
     *
     * @param attributes - Attributes to update
     * @internal
     */
    updateOtelSpanAttributes(attributes: ObservationAttributes): void;
    /**
     * Updates the parent trace with new attributes.
     *
     * @param attributes - Trace attributes to set
     * @returns This observation for method chaining
     */
    updateTrace(attributes: TraceAttributes): this;
    /**
     * Creates a new child observation within this observation's context.
     *
     * @param name - Name for the child observation
     * @param attributes - Type-specific attributes
     * @param options - Configuration including observation type
     * @returns Child observation instance
     */
    startObservation(name: string, attributes: LLMAttributes, options: {
        asType: "llm";
    }): ObservationLLM;
    startObservation(name: string, attributes: EmbeddingAttributes, options: {
        asType: "embedding";
    }): ObservationEmbedding;
    startObservation(name: string, attributes: AgentAttributes, options: {
        asType: "agent";
    }): ObservationAgent;
    startObservation(name: string, attributes: ToolAttributes, options: {
        asType: "tool";
    }): ObservationTool;
    startObservation(name: string, attributes: ChainAttributes, options: {
        asType: "chain";
    }): ObservationChain;
    startObservation(name: string, attributes: RetrieverAttributes, options: {
        asType: "retriever";
    }): ObservationRetriever;
    startObservation(name: string, attributes: RerankerAttributes, options: {
        asType: "reranker";
    }): ObservationReranker;
    startObservation(name: string, attributes: EvaluatorAttributes, options: {
        asType: "evaluator";
    }): ObservationEvaluator;
    startObservation(name: string, attributes: GuardrailAttributes, options: {
        asType: "guardrail";
    }): ObservationGuardrail;
    startObservation(name: string, attributes?: BaseSpanAttributes, options?: {
        asType?: "span";
    }): ObservationSpan;
}
type ObservationSpanParams = {
    otelSpan: Span;
    attributes?: BaseSpanAttributes;
};
/**
 * General-purpose observation for tracking operations.
 *
 * @public
 */
declare class ObservationSpan extends BaseObservation {
    constructor(params: ObservationSpanParams);
    update(attributes: BaseSpanAttributes): ObservationSpan;
}
type ObservationLLMParams = {
    otelSpan: Span;
    attributes?: LLMAttributes;
};
/**
 * LLM observation for tracking language model calls.
 *
 * @public
 */
declare class ObservationLLM extends BaseObservation {
    constructor(params: ObservationLLMParams);
    update(attributes: LLMAttributes): ObservationLLM;
}
type ObservationEmbeddingParams = {
    otelSpan: Span;
    attributes?: EmbeddingAttributes;
};
/**
 * Embedding observation for tracking embedding operations.
 *
 * @public
 */
declare class ObservationEmbedding extends BaseObservation {
    constructor(params: ObservationEmbeddingParams);
    update(attributes: EmbeddingAttributes): ObservationEmbedding;
}
type ObservationAgentParams = {
    otelSpan: Span;
    attributes?: AgentAttributes;
};
/**
 * Agent observation for tracking AI agent workflows.
 *
 * @public
 */
declare class ObservationAgent extends BaseObservation {
    constructor(params: ObservationAgentParams);
    update(attributes: AgentAttributes): ObservationAgent;
}
type ObservationToolParams = {
    otelSpan: Span;
    attributes?: ToolAttributes;
};
/**
 * Tool observation for tracking tool calls.
 *
 * @public
 */
declare class ObservationTool extends BaseObservation {
    constructor(params: ObservationToolParams);
    update(attributes: ToolAttributes): ObservationTool;
}
type ObservationChainParams = {
    otelSpan: Span;
    attributes?: ChainAttributes;
};
/**
 * Chain observation for tracking multi-step workflows.
 *
 * @public
 */
declare class ObservationChain extends BaseObservation {
    constructor(params: ObservationChainParams);
    update(attributes: ChainAttributes): ObservationChain;
}
type ObservationRetrieverParams = {
    otelSpan: Span;
    attributes?: RetrieverAttributes;
};
/**
 * Retriever observation for tracking document retrieval.
 *
 * @public
 */
declare class ObservationRetriever extends BaseObservation {
    constructor(params: ObservationRetrieverParams);
    update(attributes: RetrieverAttributes): ObservationRetriever;
}
type ObservationRerankerParams = {
    otelSpan: Span;
    attributes?: RerankerAttributes;
};
/**
 * Reranker observation for tracking reranking operations.
 *
 * @public
 */
declare class ObservationReranker extends BaseObservation {
    constructor(params: ObservationRerankerParams);
    update(attributes: RerankerAttributes): ObservationReranker;
}
type ObservationEvaluatorParams = {
    otelSpan: Span;
    attributes?: EvaluatorAttributes;
};
/**
 * Evaluator observation for tracking evaluation operations.
 *
 * @public
 */
declare class ObservationEvaluator extends BaseObservation {
    constructor(params: ObservationEvaluatorParams);
    update(attributes: EvaluatorAttributes): ObservationEvaluator;
}
type ObservationGuardrailParams = {
    otelSpan: Span;
    attributes?: GuardrailAttributes;
};
/**
 * Guardrail observation for tracking safety checks.
 *
 * @public
 */
declare class ObservationGuardrail extends BaseObservation {
    constructor(params: ObservationGuardrailParams);
    update(attributes: GuardrailAttributes): ObservationGuardrail;
}

/**
 * Creates OpenTelemetry attributes from trace attributes.
 *
 * Converts user-friendly trace attributes into OpenTelemetry attribute format
 * using OpenInference semantic conventions where applicable.
 *
 * @param attributes - Trace attributes to convert
 * @returns OpenTelemetry attributes object
 *
 * @example
 * ```typescript
 * const otelAttributes = createTraceAttributes({
 *   name: 'user-workflow',
 *   userId: 'user-123',
 *   sessionId: 'session-456',
 *   tags: ['checkout', 'payment']
 * });
 * ```
 *
 * @public
 */
declare function createTraceAttributes({ name, userId, sessionId, version, release, input, output, metadata, tags, environment, public: isPublic, }?: TraceAttributes): Attributes;
/**
 * Creates OpenTelemetry attributes from observation attributes.
 *
 * Maps observation attributes to OpenInference semantic conventions:
 * - Uses `openinference.span.kind` for span type
 * - Uses `llm.*` for LLM-specific attributes
 * - Uses `tool.*` for tool-specific attributes
 * - Falls back to `agkit.observation.*` for non-standard attributes
 *
 * @param type - Observation type (llm, tool, chain, etc.)
 * @param attributes - Observation attributes to convert
 * @returns OpenTelemetry attributes object
 *
 * @public
 */
declare function createObservationAttributes(type: ObservationType, attributes: ObservationAttributes): Attributes;

/**
 * Sets an isolated TracerProvider for tracing tracing operations.
 *
 * This allows tracing to use its own TracerProvider instance, separate from
 * the global OpenTelemetry TracerProvider.
 *
 * Note: While this isolates span processing and export, it does NOT provide
 * complete trace isolation. OpenTelemetry context (trace IDs, parent spans)
 * is still shared between the global and isolated providers.
 *
 * @param provider - The TracerProvider instance to use, or null to clear
 *
 * @example
 * ```typescript
 * import { NodeTracerProvider } from '@opentelemetry/sdk-trace-node';
 * import { setTracerProvider } from './observability';
 *
 * const provider = new NodeTracerProvider();
 * setTracerProvider(provider);
 * ```
 *
 * @public
 */
declare function setTracerProvider(provider: TracerProvider | null): void;
/**
 * Gets the TracerProvider for tracing tracing operations.
 *
 * Returns the isolated TracerProvider if one has been set via setTracerProvider(),
 * otherwise falls back to the global OpenTelemetry TracerProvider.
 *
 * @returns The TracerProvider instance to use for tracing tracing
 *
 * @example
 * ```typescript
 * import { getTracerProvider } from './observability';
 *
 * const provider = getTracerProvider();
 * const tracer = provider.getTracer('my-tracer', '1.0.0');
 * ```
 *
 * @public
 */
declare function getTracerProvider(): TracerProvider;
/**
 * Gets the OpenTelemetry tracer instance for tracing.
 *
 * Returns a tracer specifically configured for tracing with the correct
 * tracer name and version.
 *
 * @returns The tracing OpenTelemetry tracer instance
 *
 * @example
 * ```typescript
 * import { getTracer } from './observability';
 *
 * const tracer = getTracer();
 * const span = tracer.startSpan('my-operation');
 * ```
 *
 * @public
 */
declare function getTracer(): _opentelemetry_api.Tracer;

/**
 * Observability - OpenTelemetry-based tracing with OpenInference semantic conventions
 *
 * @packageDocumentation
 */

/**
 * Options for starting observations (spans).
 *
 * @public
 */
type StartObservationOptions = {
    /** Custom start time for the observation */
    startTime?: Date;
    /** Parent span context to attach this observation to */
    parentSpanContext?: SpanContext;
};
/**
 * Options for startObservation function.
 *
 * @public
 */
type StartObservationOpts = StartObservationOptions & {
    /** Type of observation to create. Defaults to 'span' */
    asType?: ObservationType;
};
declare function startObservation(name: string, attributes?: BaseSpanAttributes, options?: StartObservationOpts & {
    asType?: ObservationType;
}): Observation;
declare function startObservation(name: string, attributes: LLMAttributes, options: StartObservationOpts & {
    asType: "llm";
}): ObservationLLM;
declare function startObservation(name: string, attributes: EmbeddingAttributes, options: StartObservationOpts & {
    asType: "embedding";
}): ObservationEmbedding;
declare function startObservation(name: string, attributes: AgentAttributes, options: StartObservationOpts & {
    asType: "agent";
}): ObservationAgent;
declare function startObservation(name: string, attributes: ToolAttributes, options: StartObservationOpts & {
    asType: "tool";
}): ObservationTool;
declare function startObservation(name: string, attributes: ChainAttributes, options: StartObservationOpts & {
    asType: "chain";
}): ObservationChain;
declare function startObservation(name: string, attributes: RetrieverAttributes, options: StartObservationOpts & {
    asType: "retriever";
}): ObservationRetriever;
declare function startObservation(name: string, attributes: RerankerAttributes, options: StartObservationOpts & {
    asType: "reranker";
}): ObservationReranker;
declare function startObservation(name: string, attributes: EvaluatorAttributes, options: StartObservationOpts & {
    asType: "evaluator";
}): ObservationEvaluator;
declare function startObservation(name: string, attributes: GuardrailAttributes, options: StartObservationOpts & {
    asType: "guardrail";
}): ObservationGuardrail;
declare function startObservation(name: string, attributes?: BaseSpanAttributes, options?: StartObservationOpts & {
    asType?: "span";
}): ObservationSpan;
/**
 * Updates the currently active trace with new attributes.
 *
 * @param attributes - Trace attributes to set
 *
 * @example
 * ```typescript
 * import { updateActiveTrace } from './observability';
 *
 * updateActiveTrace({
 *   name: 'user-workflow',
 *   userId: 'user-123',
 *   tags: ['production']
 * });
 * ```
 *
 * @public
 */
declare function updateActiveTrace(attributes: TraceAttributes): void;
/**
 * Gets the current active trace ID.
 *
 * @returns The trace ID of the currently active span, or undefined
 *
 * @public
 */
declare function getActiveTraceId(): string | undefined;
/**
 * Gets the current active observation ID.
 *
 * @returns The span ID of the currently active span, or undefined
 *
 * @public
 */
declare function getActiveSpanId(): string | undefined;
/**
 * Options for startActiveObservation.
 *
 * @public
 */
type StartActiveObservationOpts = StartObservationOpts & {
    /** Whether to automatically end the observation when the function exits. Default: true */
    endOnExit?: boolean;
};
declare function startActiveObservation<F extends (observation: ObservationSpan) => unknown>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;
declare function startActiveObservation<F extends (observation: ObservationLLM) => unknown>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;
declare function startActiveObservation<F extends (observation: ObservationEmbedding) => unknown>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;
declare function startActiveObservation<F extends (observation: ObservationAgent) => unknown>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;
declare function startActiveObservation<F extends (observation: ObservationTool) => unknown>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;
declare function startActiveObservation<F extends (observation: ObservationChain) => unknown>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;
declare function startActiveObservation<F extends (observation: ObservationRetriever) => unknown>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;
declare function startActiveObservation<F extends (observation: ObservationReranker) => unknown>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;
declare function startActiveObservation<F extends (observation: ObservationEvaluator) => unknown>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;
declare function startActiveObservation<F extends (observation: ObservationGuardrail) => unknown>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;
/**
 * Updates the currently active observation with new attributes.
 *
 * @param attributes - Observation attributes to set
 *
 * @example
 * ```typescript
 * import { updateActiveObservation } from './observability';
 *
 * // Within an active observation context
 * updateActiveObservation({
 *   metadata: { stage: 'processing' }
 * });
 * ```
 *
 * @public
 */
declare function updateActiveObservation(attributes: BaseSpanAttributes): void;
/**
 * Options for the observe decorator.
 *
 * @public
 */
type ObserveOptions = Omit<StartObservationOpts, "name"> & {
    /** Whether to capture function arguments as input. Default: true */
    captureInput?: boolean;
    /** Whether to capture return value as output. Default: true */
    captureOutput?: boolean;
};
/**
 * Decorator function to add observability to any function.
 *
 * Wraps a function with automatic observation creation, input/output capture,
 * and lifecycle management. The observation is automatically ended when the
 * function completes.
 *
 * @param fn - Function to wrap
 * @param options - Configuration options
 * @returns Wrapped function with observability
 *
 * @example
 * ```typescript
 * import { observe } from './observability';
 *
 * // Wrap an existing function
 * const fetchData = observe(async (url: string) => {
 *   const response = await fetch(url);
 *   return response.json();
 * }, { asType: 'tool' });
 *
 * // Wrap with custom name
 * const processPayment = observe(
 *   async (amount: number, currency: string) => {
 *     return await paymentGateway.charge(amount, currency);
 *   },
 *   { name: 'payment-gateway-call', asType: 'tool' }
 * );
 *
 * // Class method decoration
 * class UserService {
 *   @observe({ asType: 'chain' })
 *   async getUser(id: string) {
 *     return await db.users.find(id);
 *   }
 * }
 * ```
 *
 * @public
 */
declare function observe<T extends (...args: any[]) => any>(fn: T, options?: ObserveOptions): T;

export { type AgentAttributes, type BaseSpanAttributes, type ChainAttributes, type EmbeddingAttributes, type EvaluatorAttributes, type GuardrailAttributes, type LLMAttributes, type Observation, ObservationAgent, type ObservationAttributes, ObservationChain, ObservationEmbedding, ObservationEvaluator, ObservationGuardrail, ObservationLLM, type ObservationLevel, ObservationReranker, ObservationRetriever, ObservationSpan, ObservationTool, type ObservationType, type ObserveOptions, type RerankerAttributes, type RetrieverAttributes, type StartActiveObservationOpts, type StartObservationOptions, type StartObservationOpts, type ToolAttributes, type TraceAttributes, createObservationAttributes, createTraceAttributes, getActiveSpanId, getActiveTraceId, getTracer, getTracerProvider, observe, setTracerProvider, startActiveObservation, startObservation, updateActiveObservation, updateActiveTrace };
