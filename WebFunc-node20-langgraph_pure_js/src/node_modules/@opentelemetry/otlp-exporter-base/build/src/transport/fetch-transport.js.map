{"version":3,"file":"fetch-transport.js","sourceRoot":"","sources":["../../../src/transport/fetch-transport.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;AAIH,4CAA0C;AAC1C,gEAGgC;AAQhC,MAAM,cAAc;IACV,WAAW,CAA2B;IAE9C,YAAY,UAAoC;QAC9C,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC;IAChC,CAAC;IAED,KAAK,CAAC,IAAI,CAAC,IAAgB,EAAE,aAAqB;QAChD,MAAM,eAAe,GAAG,IAAI,eAAe,EAAE,CAAC;QAC9C,MAAM,OAAO,GAAG,UAAU,CAAC,GAAG,EAAE,CAAC,eAAe,CAAC,KAAK,EAAE,EAAE,aAAa,CAAC,CAAC;QACzE,IAAI;YACF,MAAM,oBAAoB,GAAG,CAAC,CAAC,UAAU,CAAC,QAAQ,CAAC;YACnD,MAAM,GAAG,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,CAAC;YAC1C,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,GAAG,CAAC,IAAI,EAAE;gBACrC,MAAM,EAAE,MAAM;gBACd,OAAO,EAAE,MAAM,IAAI,CAAC,WAAW,CAAC,OAAO,EAAE;gBACzC,IAAI,EAAE,IAAI;gBACV,MAAM,EAAE,eAAe,CAAC,MAAM;gBAC9B,SAAS,EAAE,oBAAoB;gBAC/B,IAAI,EAAE,oBAAoB;oBACxB,CAAC,CAAC,UAAU,CAAC,QAAQ,EAAE,MAAM,KAAK,GAAG,CAAC,MAAM;wBAC1C,CAAC,CAAC,aAAa;wBACf,CAAC,CAAC,MAAM;oBACV,CAAC,CAAC,SAAS;aACd,CAAC,CAAC;YAEH,IAAI,QAAQ,CAAC,MAAM,IAAI,GAAG,IAAI,QAAQ,CAAC,MAAM,IAAI,GAAG,EAAE;gBACpD,UAAI,CAAC,KAAK,CAAC,kBAAkB,CAAC,CAAC;gBAC/B,OAAO,EAAE,MAAM,EAAE,SAAS,EAAE,CAAC;aAC9B;iBAAM,IAAI,IAAA,gDAA0B,EAAC,QAAQ,CAAC,MAAM,CAAC,EAAE;gBACtD,MAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;gBACvD,MAAM,aAAa,GAAG,IAAA,4CAAsB,EAAC,UAAU,CAAC,CAAC;gBACzD,OAAO,EAAE,MAAM,EAAE,WAAW,EAAE,aAAa,EAAE,CAAC;aAC/C;YACD,OAAO;gBACL,MAAM,EAAE,SAAS;gBACjB,KAAK,EAAE,IAAI,KAAK,CAAC,gDAAgD,CAAC;aACnE,CAAC;SACH;QAAC,OAAO,KAAK,EAAE;YACd,IAAI,4BAA4B,CAAC,KAAK,CAAC,EAAE;gBACvC,OAAO;oBACL,MAAM,EAAE,WAAW;oBACnB,KAAK,EAAE,IAAI,KAAK,CAAC,2CAA2C,EAAE;wBAC5D,KAAK,EAAE,KAAK;qBACb,CAAC;iBACH,CAAC;aACH;YACD,OAAO;gBACL,MAAM,EAAE,SAAS;gBACjB,KAAK,EAAE,IAAI,KAAK,CAAC,uBAAuB,EAAE,EAAE,KAAK,EAAE,KAAK,EAAE,CAAC;aAC5D,CAAC;SACH;gBAAS;YACR,YAAY,CAAC,OAAO,CAAC,CAAC;SACvB;IACH,CAAC;IAED,QAAQ;QACN,2CAA2C;IAC7C,CAAC;CACF;AAED;;;GAGG;AACH,SAAgB,oBAAoB,CAClC,UAAoC;IAEpC,OAAO,IAAI,cAAc,CAAC,UAAU,CAAC,CAAC;AACxC,CAAC;AAJD,oDAIC;AAED,SAAS,4BAA4B,CAAC,KAAc;IAClD,OAAO,KAAK,YAAY,SAAS,IAAI,CAAC,KAAK,CAAC,KAAK,CAAC;AACpD,CAAC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IExporterTransport } from '../exporter-transport';\nimport { ExportResponse } from '../export-response';\nimport { diag } from '@opentelemetry/api';\nimport {\n  isExportHTTPErrorRetryable,\n  parseRetryAfterToMills,\n} from '../is-export-retryable';\nimport { HeadersFactory } from '../configuration/otlp-http-configuration';\n\nexport interface FetchTransportParameters {\n  url: string;\n  headers: HeadersFactory;\n}\n\nclass FetchTransport implements IExporterTransport {\n  private _parameters: FetchTransportParameters;\n\n  constructor(parameters: FetchTransportParameters) {\n    this._parameters = parameters;\n  }\n\n  async send(data: Uint8Array, timeoutMillis: number): Promise<ExportResponse> {\n    const abortController = new AbortController();\n    const timeout = setTimeout(() => abortController.abort(), timeoutMillis);\n    try {\n      const isBrowserEnvironment = !!globalThis.location;\n      const url = new URL(this._parameters.url);\n      const response = await fetch(url.href, {\n        method: 'POST',\n        headers: await this._parameters.headers(),\n        body: data,\n        signal: abortController.signal,\n        keepalive: isBrowserEnvironment,\n        mode: isBrowserEnvironment\n          ? globalThis.location?.origin === url.origin\n            ? 'same-origin'\n            : 'cors'\n          : 'no-cors',\n      });\n\n      if (response.status >= 200 && response.status <= 299) {\n        diag.debug('response success');\n        return { status: 'success' };\n      } else if (isExportHTTPErrorRetryable(response.status)) {\n        const retryAfter = response.headers.get('Retry-After');\n        const retryInMillis = parseRetryAfterToMills(retryAfter);\n        return { status: 'retryable', retryInMillis };\n      }\n      return {\n        status: 'failure',\n        error: new Error('Fetch request failed with non-retryable status'),\n      };\n    } catch (error) {\n      if (isFetchNetworkErrorRetryable(error)) {\n        return {\n          status: 'retryable',\n          error: new Error('Fetch request encountered a network error', {\n            cause: error,\n          }),\n        };\n      }\n      return {\n        status: 'failure',\n        error: new Error('Fetch request errored', { cause: error }),\n      };\n    } finally {\n      clearTimeout(timeout);\n    }\n  }\n\n  shutdown() {\n    // Intentionally left empty, nothing to do.\n  }\n}\n\n/**\n * Creates an exporter transport that uses `fetch` to send the data\n * @param parameters applied to each request made by transport\n */\nexport function createFetchTransport(\n  parameters: FetchTransportParameters\n): IExporterTransport {\n  return new FetchTransport(parameters);\n}\n\nfunction isFetchNetworkErrorRetryable(error: unknown): boolean {\n  return error instanceof TypeError && !error.cause;\n}\n"]}