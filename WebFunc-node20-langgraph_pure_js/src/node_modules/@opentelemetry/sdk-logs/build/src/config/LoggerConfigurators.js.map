{"version":3,"file":"LoggerConfigurators.js","sourceRoot":"","sources":["../../../src/config/LoggerConfigurators.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;AAGH,sDAAyD;AAGzD;;;;GAIG;AACH,MAAM,qBAAqB,GAA2B;IACpD,QAAQ,EAAE,KAAK;IACf,eAAe,EAAE,yBAAc,CAAC,WAAW;IAC3C,UAAU,EAAE,KAAK;CAClB,CAAC;AAyBF;;;;;;;;;;;;;;;;;;;;GAoBG;AACH,SAAgB,wBAAwB,CACtC,QAAyB;IAEzB,OAAO,CAAC,WAAiC,EAA0B,EAAE;QACnE,MAAM,UAAU,GAAG,WAAW,CAAC,IAAI,CAAC;QAEpC,kCAAkC;QAClC,KAAK,MAAM,EAAE,OAAO,EAAE,MAAM,EAAE,IAAI,QAAQ,EAAE;YAC1C,IAAI,cAAc,CAAC,UAAU,EAAE,OAAO,CAAC,EAAE;gBACvC,mDAAmD;gBACnD,OAAO;oBACL,QAAQ,EAAE,MAAM,CAAC,QAAQ,IAAI,qBAAqB,CAAC,QAAQ;oBAC3D,eAAe,EACb,MAAM,CAAC,eAAe,IAAI,qBAAqB,CAAC,eAAe;oBACjE,UAAU,EAAE,MAAM,CAAC,UAAU,IAAI,qBAAqB,CAAC,UAAU;iBAClE,CAAC;aACH;SACF;QAED,4CAA4C;QAC5C,OAAO,EAAE,GAAG,qBAAqB,EAAE,CAAC;IACtC,CAAC,CAAC;AACJ,CAAC;AAtBD,4DAsBC;AAED;;;;;;;GAOG;AACH,SAAS,cAAc,CAAC,IAAY,EAAE,OAAe;IACnD,cAAc;IACd,IAAI,OAAO,KAAK,IAAI,EAAE;QACpB,OAAO,IAAI,CAAC;KACb;IAED,mBAAmB;IACnB,IAAI,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,EAAE;QACzB,MAAM,YAAY,GAAG,OAAO;aACzB,KAAK,CAAC,GAAG,CAAC;aACV,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,OAAO,CAAC,qBAAqB,EAAE,MAAM,CAAC,CAAC;aACxD,IAAI,CAAC,IAAI,CAAC,CAAC;QACd,MAAM,KAAK,GAAG,IAAI,MAAM,CAAC,IAAI,YAAY,GAAG,CAAC,CAAC;QAC9C,OAAO,KAAK,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;KACzB;IAED,OAAO,KAAK,CAAC;AACf,CAAC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { InstrumentationScope } from '@opentelemetry/core';\nimport { SeverityNumber } from '@opentelemetry/api-logs';\nimport type { LoggerConfig, LoggerConfigurator } from '../types';\n\n/**\n * Default LoggerConfig used when no pattern matches\n *\n * @experimental This feature is in development as per the OpenTelemetry specification.\n */\nconst DEFAULT_LOGGER_CONFIG: Required<LoggerConfig> = {\n  disabled: false,\n  minimumSeverity: SeverityNumber.UNSPECIFIED,\n  traceBased: false,\n};\n\n/**\n * Configuration for a specific logger pattern\n *\n * @experimental This feature is in development as per the OpenTelemetry specification.\n */\nexport interface LoggerPattern {\n  /**\n   * The logger name or pattern to match.\n   * Use '*' for wildcard matching.\n   *\n   * @experimental This feature is in development as per the OpenTelemetry specification.\n   */\n  pattern: string;\n\n  /**\n   * The configuration to apply to matching loggers.\n   * Partial config is allowed; unspecified properties will use defaults.\n   *\n   * @experimental This feature is in development as per the OpenTelemetry specification.\n   */\n  config: LoggerConfig;\n}\n\n/**\n * Creates a LoggerConfigurator from an array of logger patterns.\n * Patterns are evaluated in order, and the first matching pattern's config is used.\n * Supports exact matching and simple wildcard patterns with '*'.\n *\n * The returned configurator computes a complete LoggerConfig by merging the matched\n * pattern's config with default values for any unspecified properties.\n *\n * @param patterns - Array of logger patterns with their configurations\n * @returns A LoggerConfigurator function that computes complete LoggerConfig\n * @experimental This feature is in development as per the OpenTelemetry specification.\n *\n * @example\n * ```typescript\n * const configurator = createLoggerConfigurator([\n *   { pattern: 'debug-logger', config: { minimumSeverity: SeverityNumber.DEBUG } },\n *   { pattern: 'prod-*', config: { minimumSeverity: SeverityNumber.WARN } },\n *   { pattern: '*', config: { minimumSeverity: SeverityNumber.INFO } },\n * ]);\n * ```\n */\nexport function createLoggerConfigurator(\n  patterns: LoggerPattern[]\n): LoggerConfigurator {\n  return (loggerScope: InstrumentationScope): Required<LoggerConfig> => {\n    const loggerName = loggerScope.name;\n\n    // Find the first matching pattern\n    for (const { pattern, config } of patterns) {\n      if (matchesPattern(loggerName, pattern)) {\n        // Compute complete config by merging with defaults\n        return {\n          disabled: config.disabled ?? DEFAULT_LOGGER_CONFIG.disabled,\n          minimumSeverity:\n            config.minimumSeverity ?? DEFAULT_LOGGER_CONFIG.minimumSeverity,\n          traceBased: config.traceBased ?? DEFAULT_LOGGER_CONFIG.traceBased,\n        };\n      }\n    }\n\n    // No pattern matched, return default config\n    return { ...DEFAULT_LOGGER_CONFIG };\n  };\n}\n\n/**\n * Matches a logger name against a pattern.\n * Supports simple wildcard matching with '*'.\n *\n * @param name - The logger name to match\n * @param pattern - The pattern to match against (supports '*' wildcard)\n * @returns true if the name matches the pattern\n */\nfunction matchesPattern(name: string, pattern: string): boolean {\n  // Exact match\n  if (pattern === name) {\n    return true;\n  }\n\n  // Wildcard pattern\n  if (pattern.includes('*')) {\n    const regexPattern = pattern\n      .split('*')\n      .map(part => part.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'))\n      .join('.*');\n    const regex = new RegExp(`^${regexPattern}$`);\n    return regex.test(name);\n  }\n\n  return false;\n}\n"]}