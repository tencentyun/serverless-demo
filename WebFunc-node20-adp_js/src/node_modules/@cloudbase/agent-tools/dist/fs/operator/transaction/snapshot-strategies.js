"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxSnapshotStrategy = exports.MemorySnapshotStrategy = exports.LocalSnapshotStrategy = exports.SnapshotStrategy = void 0;
const fs = __importStar(require("fs"));
const memfs_1 = require("memfs");
class SnapshotStrategy {
}
exports.SnapshotStrategy = SnapshotStrategy;
class LocalSnapshotStrategy extends SnapshotStrategy {
    constructor() {
        super(...arguments);
        this.backupDir = "";
        this.backupPaths = new Map();
        this.createdPaths = new Set();
    }
    async initialize() {
        this.backupDir = `/tmp/transaction-backup-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
        await fs.promises.mkdir(this.backupDir, { recursive: true });
        return { backupDir: this.backupDir, backupPaths: this.backupPaths };
    }
    async saveFile(path, fileState) {
        if (fileState.exists) {
            if (!fileState.isDirectory) {
                // 备份已存在的文件
                const backupPath = `${this.backupDir}/${path.replace(/\//g, "_")}`;
                try {
                    await fs.promises.copyFile(path, backupPath);
                    this.backupPaths.set(path, backupPath);
                }
                catch (error) {
                    console.warn(`Failed to backup ${path}:`, error);
                }
            }
        }
        else {
            // 标记为新创建的路径，回滚时需要删除
            this.createdPaths.add(path);
        }
    }
    async rollback(operations) {
        // 按操作顺序反向处理
        const reversedOperations = [...operations].reverse();
        for (const operation of reversedOperations) {
            try {
                await this.rollbackOperation(operation);
            }
            catch (error) {
                console.warn(`Failed to rollback operation ${operation.type} on ${operation.path}:`, error);
            }
        }
        // 恢复备份的文件
        const restorePromises = Array.from(this.backupPaths.entries()).map(([originalPath, backupPath]) => this.restoreFile(originalPath, backupPath));
        await Promise.all(restorePromises);
    }
    async rollbackOperation(operation) {
        switch (operation.type) {
            case "write":
                if (this.createdPaths.has(operation.path)) {
                    // 删除新创建的文件
                    await fs.promises.unlink(operation.path);
                }
                // 已存在文件的恢复在后面统一处理
                break;
            case "mkdir":
                if (this.createdPaths.has(operation.path)) {
                    // 删除新创建的目录
                    await fs.promises.rmdir(operation.path);
                }
                break;
            case "unlink":
                // 文件删除的恢复在后面统一处理
                break;
            case "rmdir":
                // 目录删除的恢复比较复杂，这里简化处理
                break;
            case "rename":
                if (operation.oldPath) {
                    try {
                        // 尝试反向重命名
                        await fs.promises.rename(operation.path, operation.oldPath);
                    }
                    catch (error) {
                        // 如果反向重命名失败，记录警告
                        console.warn(`Failed to reverse rename from ${operation.path} to ${operation.oldPath}:`, error);
                    }
                }
                break;
        }
    }
    async restoreFile(originalPath, backupPath) {
        try {
            await fs.promises.copyFile(backupPath, originalPath);
        }
        catch (error) {
            console.warn(`Failed to restore ${originalPath}:`, error);
        }
    }
    async cleanup() {
        try {
            await fs.promises.rm(this.backupDir, { recursive: true, force: true });
        }
        catch (error) {
            console.warn("Failed to cleanup backup directory:", error);
        }
    }
}
exports.LocalSnapshotStrategy = LocalSnapshotStrategy;
class MemorySnapshotStrategy extends SnapshotStrategy {
    constructor(operator) {
        super();
        this.operator = operator;
        this.vol =
            operator.fileSystem.__vol ||
                (operator.fileSystem instanceof memfs_1.Volume ? operator.fileSystem : undefined);
        this.fs = operator.fileSystem;
        if (!this.vol) {
            throw new Error("MemorySnapshotStrategy requires an InMemoryFileOperator with a memfs Volume");
        }
    }
    async initialize() {
        // this.snapshot = toBinarySnapshotSync({ fs: this.fs, path: "/" });
        this.snapshot = this.vol.toJSON();
        return { snapshot: this.snapshot };
    }
    async saveFile(path, fileState) { }
    async rollback(operations) {
        try {
            if (this.snapshot) {
                this.vol.reset();
                // fromBinarySnapshotSync(this.snapshot, { fs: this.fs, path: "/" });
                this.vol.fromJSON(this.snapshot, "/");
            }
        }
        catch (error) {
            console.warn("Failed to restore memfs state:", error);
        }
    }
    async cleanup() {
        this.snapshot = undefined;
    }
}
exports.MemorySnapshotStrategy = MemorySnapshotStrategy;
class SandboxSnapshotStrategy extends SnapshotStrategy {
    constructor(operator) {
        super();
        this.operator = operator;
        this.fileSnapshots = new Map();
        this.createdPaths = new Set();
    }
    async initialize() {
        return {
            fileSnapshots: this.fileSnapshots,
            createdPaths: this.createdPaths,
        };
    }
    async saveFile(path, fileState) {
        if (fileState.exists) {
            // 保存已存在文件的内容
            if (!fileState.isDirectory && fileState.contentLoader) {
                try {
                    const content = await fileState.contentLoader();
                    this.fileSnapshots.set(path, content);
                }
                catch (error) {
                    this.fileSnapshots.set(path, null);
                }
            }
        }
        else {
            // 标记为新创建的路径
            this.createdPaths.add(path);
        }
    }
    async rollback(operations) {
        // 按操作顺序反向处理
        const reversedOperations = [...operations].reverse();
        for (const operation of reversedOperations) {
            try {
                await this.rollbackOperation(operation);
            }
            catch (error) {
                console.warn(`Failed to rollback operation ${operation.type} on ${operation.path}:`, error);
            }
        }
        // 恢复已存在文件的原始内容
        const restorePromises = Array.from(this.fileSnapshots.entries()).map(([filePath, originalContent]) => this.restoreFile(filePath, originalContent));
        await Promise.all(restorePromises);
    }
    async rollbackOperation(operation) {
        switch (operation.type) {
            case "write":
                if (this.createdPaths.has(operation.path)) {
                    // 删除新创建的文件
                    if (await this.operator.exists(operation.path)) {
                        await this.operator.unlink(operation.path);
                    }
                }
                // 已存在文件的恢复在后面统一处理
                break;
            case "mkdir":
                if (this.createdPaths.has(operation.path)) {
                    // 删除新创建的目录
                    if (await this.operator.exists(operation.path)) {
                        await this.operator.rmdir(operation.path);
                    }
                }
                break;
            case "unlink":
                // 文件删除的恢复在后面统一处理
                break;
            case "rmdir":
                // 目录删除的恢复比较复杂，这里简化处理
                break;
            case "rename":
                if (operation.oldPath) {
                    try {
                        // 尝试反向重命名
                        if (await this.operator.exists(operation.path)) {
                            await this.operator.rename(operation.path, operation.oldPath);
                        }
                    }
                    catch (error) {
                        console.warn(`Failed to reverse rename from ${operation.path} to ${operation.oldPath}:`, error);
                    }
                }
                break;
        }
    }
    async restoreFile(filePath, originalContent) {
        try {
            if (originalContent !== null && originalContent !== undefined) {
                await this.operator.writeFile(filePath, originalContent);
            }
        }
        catch (error) {
            console.warn(`Failed to restore file ${filePath}:`, error);
        }
    }
    async cleanup() {
        this.createdPaths.clear();
        this.fileSnapshots.clear();
    }
}
exports.SandboxSnapshotStrategy = SandboxSnapshotStrategy;
//# sourceMappingURL=snapshot-strategies.js.map