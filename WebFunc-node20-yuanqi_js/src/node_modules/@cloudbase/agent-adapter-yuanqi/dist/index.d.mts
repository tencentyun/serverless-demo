import { AbstractAgent, AgentConfig, RunAgentInput, BaseEvent, Message, EventType } from '@ag-ui/client';
import OpenAI from 'openai';
import { Observable, Subscriber } from 'rxjs';
import tcb from '@cloudbase/node-sdk';

interface YuanqiConfig {
    request?: {
        baseUrl?: string;
        body?: Partial<YuanqiChatRequest>;
        headers?: Record<string, string>;
    };
    appId?: string;
    appKey?: string;
    envId?: string;
    credential?: {
        secretId?: string;
        secretKey?: string;
        token?: string;
    };
    historyCount?: number;
}
type ChatMessage = OpenAI.Chat.Completions.ChatCompletionMessageParam;
interface YuanqiChatRequest {
    assistantId: string;
    userId: string;
    messages: ChatMessage[];
    stream?: boolean;
    customVariables?: Record<string, string>;
    version?: number;
    chatType?: "published" | "preview";
    [key: string]: any;
}

declare class YuanqiAgentError extends Error {
    code?: string;
    constructor(message: string, code?: string);
}
declare class YuanqiAgent extends AbstractAgent {
    protected yuanqiConfig: YuanqiConfig;
    private finalAppId;
    private finalCloudCredential;
    private model;
    constructor(config: AgentConfig & {
        yuanqiConfig: YuanqiConfig;
    });
    generateRequestBody({ messages, input, }: {
        messages: ChatMessage[];
        input: RunAgentInput;
    }): YuanqiChatRequest;
    run(input: RunAgentInput): Observable<BaseEvent>;
    private _run;
    protected getChatHistory(subscriber: Subscriber<BaseEvent>, latestUserMessage: Message): Promise<OpenAI.Chat.Completions.ChatCompletionMessageParam[]>;
    protected saveChatHistory(subscriber: Subscriber<BaseEvent>, input: RunAgentInput, userRecordId: string, assistantRecordId: string, userContent: string, assistantContent: string): Promise<void>;
    private getTcbClient;
    private checkIsDatabaseReady;
}
/**
 * Convert AGUI messages to OpenAI chat completion format
 */
declare function convertMessagesToOpenAI(messages: Message[], systemPrompt?: string): ChatMessage[];

interface StreamContext {
    threadId: string;
    runId: string;
    messageId: string;
}
interface StreamState {
    hasStarted: boolean;
    fullContent: string;
    toolCallsMap: Map<string, {
        name: string;
        args: string;
    }>;
}
type Delta = OpenAI.Chat.Completions.ChatCompletionChunk["choices"][number]["delta"] & {
    reasoning_content?: string;
};
declare function processYuanqiStream(stream: AsyncIterable<OpenAI.Chat.Completions.ChatCompletionChunk>, context: StreamContext): AsyncGenerator<{
    type: EventType;
    threadId: string;
    runId: string;
    toolCallId: any;
    content?: undefined;
    messageId?: undefined;
    role?: undefined;
    delta?: undefined;
    toolCallName?: undefined;
} | {
    type: EventType;
    threadId: string;
    runId: string;
    toolCallId: any;
    content: string;
    messageId?: undefined;
    role?: undefined;
    delta?: undefined;
    toolCallName?: undefined;
} | {
    type: EventType;
    threadId: string;
    runId: string;
    messageId: string;
    toolCallId?: undefined;
    content?: undefined;
    role?: undefined;
    delta?: undefined;
    toolCallName?: undefined;
} | {
    type: EventType;
    threadId: string;
    runId: string;
    messageId: string;
    role: string;
    toolCallId?: undefined;
    content?: undefined;
    delta?: undefined;
    toolCallName?: undefined;
} | {
    type: EventType;
    threadId: string;
    runId: string;
    messageId: string;
    delta: string;
    toolCallId?: undefined;
    content?: undefined;
    role?: undefined;
    toolCallName?: undefined;
} | {
    type: EventType;
    threadId: string;
    runId: string;
    toolCallId: string;
    toolCallName: string;
    content?: undefined;
    messageId?: undefined;
    role?: undefined;
    delta?: undefined;
} | {
    type: EventType;
    threadId: string;
    runId: string;
    toolCallId: string;
    delta: string;
    content?: undefined;
    messageId?: undefined;
    role?: undefined;
    toolCallName?: undefined;
}, void, unknown>;

declare function createChatHistory({ tcbClient, chatHistoryEntity, }: {
    tcbClient: tcb.CloudBase;
    chatHistoryEntity: ChatHistoryEntity;
}): Promise<string | undefined>;
declare function updateChatHistoryByRecordId({ tcbClient, recordId, chatHistoryEntity, }: {
    tcbClient: tcb.CloudBase;
    recordId: string;
    chatHistoryEntity: ChatHistoryEntity;
}): Promise<string | undefined>;
declare function describeChatHistory({ tcbClient, botId, sort, pageSize, pageNumber, conversation, startCreatedAt, triggerSrc, }: {
    tcbClient: tcb.CloudBase;
    botId: string;
    sort: "asc" | "desc";
    pageSize?: number;
    pageNumber?: number;
    conversation?: string;
    startCreatedAt?: number;
    triggerSrc?: string;
}): Promise<[ChatHistoryEntity[], number]>;
declare function transDataToChatEntity(item: ChatHistoryData): ChatHistoryEntity;
declare function queryForLLM({ tcbClient, botId, pageSize, startCreatedAt, triggerSrc, }: {
    tcbClient: tcb.CloudBase;
    botId: string;
    pageSize?: number;
    startCreatedAt?: number;
    triggerSrc?: string;
}): Promise<{
    role: string;
    content: string;
}[]>;
interface ChatHistoryData {
    bot_id: string;
    record_id: string;
    role: string;
    status: string;
    content: string;
    sender: string;
    conversation: string;
    type: string;
    trigger_src: string;
    origin_msg: string;
    reply_to: string;
    reply: string;
    trace_id: string;
    need_async_reply: boolean;
    async_reply: string;
    createdAt: number;
    updatedAt: number;
}
declare class ChatHistoryEntity {
    id: number;
    botId: string;
    recordId: string;
    role: string;
    content: string;
    recommendQuestions: string[];
    sender: string;
    conversation: string;
    type: string;
    /**
     * 消息状态，pending done error cancel
     */
    status: string;
    image: string;
    triggerSrc: string;
    originMsg: string;
    replyTo: string;
    reply: string;
    traceId: string;
    needAsyncReply: boolean;
    asyncReply: string;
    createTime: string;
    updateTime: string;
    createdAt: number;
    updatedAt: number;
    event: string;
}

export { type ChatHistoryData, ChatHistoryEntity, type ChatMessage, type Delta, type StreamContext, type StreamState, YuanqiAgent, YuanqiAgentError, type YuanqiChatRequest, type YuanqiConfig, convertMessagesToOpenAI, createChatHistory, describeChatHistory, processYuanqiStream, queryForLLM, transDataToChatEntity, updateChatHistoryByRecordId };
