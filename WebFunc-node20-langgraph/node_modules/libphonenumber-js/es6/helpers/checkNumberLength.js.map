{"version":3,"file":"checkNumberLength.js","names":["Metadata","mergeArrays","checkNumberLength","nationalNumber","country","metadata","checkNumberLengthForType","undefined","type","selectNumberingPlan","type_info","possible_lengths","possibleLengths","mobile_type","actual_length","length","minimum_length","indexOf"],"sources":["../../source/helpers/checkNumberLength.js"],"sourcesContent":["import Metadata from '../metadata.js'\r\nimport mergeArrays from './mergeArrays.js'\r\n\r\nexport default function checkNumberLength(nationalNumber, country, metadata) {\r\n\treturn checkNumberLengthForType(nationalNumber, country, undefined, metadata)\r\n}\r\n\r\n// Checks whether a number is possible for a certain `country` based on the number length.\r\n//\r\n// This function is not supported by metadata generated with ancient versions of\r\n// `libphonenumber-js` (before version `1.0.18`) which didn't include \"possible lengths\".\r\n//\r\n// There was also a known issue with `checkNumberLength()` function:\r\n// if a number is possible only in a certain `country` among several `countries`\r\n// that share the same \"country calling code\", that function would check\r\n// the possibility of the phone number only in the \"main\" `country` for the \"country calling code\"\r\n// and would not check if it's actually be possible in the speciifc `country`.\r\n//\r\n// For example, \"+1310xxxx\" numbers are valid in Canada.\r\n// However, they are not possible in the US due to being too short.\r\n// Since Canada and the US share the same country calling code — \"+1\" —\r\n// `checkNumberLength()` function used to return not \"IS_POSSIBLE\" for \"+1310xxxx\" numbers.\r\n//\r\n// In such cases, when using \"/max\" metadata, `isValid()` could output `true`\r\n// but at the same time `isPossible()` could output `false`, which was contradictory.\r\n//\r\n// See https://issuetracker.google.com/issues/335892662 for the discusson in Google's issues.\r\n//\r\n// The solution suggested by Google was implemented: an optional `country` argument\r\n// was added to `checkNumberLength()` function. If present, that `country` will be used\r\n// to check phone number length for that specific `country` rather than the \"main\" country\r\n// for the shared \"country calling code\".\r\n//\r\nexport function checkNumberLengthForType(nationalNumber, country, type, metadata) {\r\n\t// If the exact `country` is specified, it's no necessarily already selected in `metadata`.\r\n\t// Most likely, in cases when there're multiple countries corresponding to the same\r\n\t// \"country calling code\", the \"main\" country for that \"country calling code\" will be selected.\r\n\tif (country) {\r\n\t\tmetadata = new Metadata(metadata.metadata)\r\n\t\tmetadata.selectNumberingPlan(country)\r\n\t}\r\n\r\n\tconst type_info = metadata.type(type)\r\n\r\n\t// There should always be \"<possiblePengths/>\" set for every type element.\r\n\t// This is declared in the XML schema.\r\n\t// For size efficiency, where a sub-description (e.g. fixed-line)\r\n\t// has the same \"<possiblePengths/>\" as the \"general description\", this is missing,\r\n\t// so we fall back to the \"general description\". Where no numbers of the type\r\n\t// exist at all, there is one possible length (-1) which is guaranteed\r\n\t// not to match the length of any real phone number.\r\n\tlet possible_lengths = type_info && type_info.possibleLengths() || metadata.possibleLengths()\r\n\t// let local_lengths = type_info && type.possibleLengthsLocal() || metadata.possibleLengthsLocal()\r\n\r\n\t// Metadata before version `1.0.18` didn't contain `possible_lengths`.\r\n\tif (!possible_lengths) {\r\n\t\treturn 'IS_POSSIBLE'\r\n\t}\r\n\r\n\tif (type === 'FIXED_LINE_OR_MOBILE') {\r\n\t\t// No such country in metadata.\r\n\t\t/* istanbul ignore next */\r\n\t\tif (!metadata.type('FIXED_LINE')) {\r\n\t\t\t// The rare case has been encountered where no fixedLine data is available\r\n\t\t\t// (true for some non-geographic entities), so we just check mobile.\r\n\t\t\treturn checkNumberLengthForType(nationalNumber, country, 'MOBILE', metadata)\r\n\t\t}\r\n\r\n\t\tconst mobile_type = metadata.type('MOBILE')\r\n\t\tif (mobile_type) {\r\n\t\t\t// Merge the mobile data in if there was any. \"Concat\" creates a new\r\n\t\t\t// array, it doesn't edit possible_lengths in place, so we don't need a copy.\r\n\t\t\t// Note that when adding the possible lengths from mobile, we have\r\n\t\t\t// to again check they aren't empty since if they are this indicates\r\n\t\t\t// they are the same as the general desc and should be obtained from there.\r\n\t\t\tpossible_lengths = mergeArrays(possible_lengths, mobile_type.possibleLengths())\r\n\t\t\t// The current list is sorted; we need to merge in the new list and\r\n\t\t\t// re-sort (duplicates are okay). Sorting isn't so expensive because\r\n\t\t\t// the lists are very small.\r\n\r\n\t\t\t// if (local_lengths) {\r\n\t\t\t// \tlocal_lengths = mergeArrays(local_lengths, mobile_type.possibleLengthsLocal())\r\n\t\t\t// } else {\r\n\t\t\t// \tlocal_lengths = mobile_type.possibleLengthsLocal()\r\n\t\t\t// }\r\n\t\t}\r\n\t}\r\n\t// If the type doesn't exist then return 'INVALID_LENGTH'.\r\n\telse if (type && !type_info) {\r\n\t\treturn 'INVALID_LENGTH'\r\n\t}\r\n\r\n\tconst actual_length = nationalNumber.length\r\n\r\n\t// In `libphonenumber-js` all \"local-only\" formats are dropped for simplicity.\r\n\t// // This is safe because there is never an overlap beween the possible lengths\r\n\t// // and the local-only lengths; this is checked at build time.\r\n\t// if (local_lengths && local_lengths.indexOf(nationalNumber.length) >= 0)\r\n\t// {\r\n\t// \treturn 'IS_POSSIBLE_LOCAL_ONLY'\r\n\t// }\r\n\r\n\tconst minimum_length = possible_lengths[0]\r\n\r\n\tif (minimum_length === actual_length) {\r\n\t\treturn 'IS_POSSIBLE'\r\n\t}\r\n\r\n\tif (minimum_length > actual_length) {\r\n\t\treturn 'TOO_SHORT'\r\n\t}\r\n\r\n\tif (possible_lengths[possible_lengths.length - 1] < actual_length) {\r\n\t\treturn 'TOO_LONG'\r\n\t}\r\n\r\n\t// We skip the first element since we've already checked it.\r\n\treturn possible_lengths.indexOf(actual_length, 1) >= 0 ? 'IS_POSSIBLE' : 'INVALID_LENGTH'\r\n}"],"mappings":"AAAA,OAAOA,QAAQ,MAAM,gBAAgB;AACrC,OAAOC,WAAW,MAAM,kBAAkB;AAE1C,eAAe,SAASC,iBAAiBA,CAACC,cAAc,EAAEC,OAAO,EAAEC,QAAQ,EAAE;EAC5E,OAAOC,wBAAwB,CAACH,cAAc,EAAEC,OAAO,EAAEG,SAAS,EAAEF,QAAQ,CAAC;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,wBAAwBA,CAACH,cAAc,EAAEC,OAAO,EAAEI,IAAI,EAAEH,QAAQ,EAAE;EACjF;EACA;EACA;EACA,IAAID,OAAO,EAAE;IACZC,QAAQ,GAAG,IAAIL,QAAQ,CAACK,QAAQ,CAACA,QAAQ,CAAC;IAC1CA,QAAQ,CAACI,mBAAmB,CAACL,OAAO,CAAC;EACtC;EAEA,IAAMM,SAAS,GAAGL,QAAQ,CAACG,IAAI,CAACA,IAAI,CAAC;;EAErC;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAIG,gBAAgB,GAAGD,SAAS,IAAIA,SAAS,CAACE,eAAe,CAAC,CAAC,IAAIP,QAAQ,CAACO,eAAe,CAAC,CAAC;EAC7F;;EAEA;EACA,IAAI,CAACD,gBAAgB,EAAE;IACtB,OAAO,aAAa;EACrB;EAEA,IAAIH,IAAI,KAAK,sBAAsB,EAAE;IACpC;IACA;IACA,IAAI,CAACH,QAAQ,CAACG,IAAI,CAAC,YAAY,CAAC,EAAE;MACjC;MACA;MACA,OAAOF,wBAAwB,CAACH,cAAc,EAAEC,OAAO,EAAE,QAAQ,EAAEC,QAAQ,CAAC;IAC7E;IAEA,IAAMQ,WAAW,GAAGR,QAAQ,CAACG,IAAI,CAAC,QAAQ,CAAC;IAC3C,IAAIK,WAAW,EAAE;MAChB;MACA;MACA;MACA;MACA;MACAF,gBAAgB,GAAGV,WAAW,CAACU,gBAAgB,EAAEE,WAAW,CAACD,eAAe,CAAC,CAAC,CAAC;MAC/E;MACA;MACA;;MAEA;MACA;MACA;MACA;MACA;IACD;EACD;EACA;EAAA,KACK,IAAIJ,IAAI,IAAI,CAACE,SAAS,EAAE;IAC5B,OAAO,gBAAgB;EACxB;EAEA,IAAMI,aAAa,GAAGX,cAAc,CAACY,MAAM;;EAE3C;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,IAAMC,cAAc,GAAGL,gBAAgB,CAAC,CAAC,CAAC;EAE1C,IAAIK,cAAc,KAAKF,aAAa,EAAE;IACrC,OAAO,aAAa;EACrB;EAEA,IAAIE,cAAc,GAAGF,aAAa,EAAE;IACnC,OAAO,WAAW;EACnB;EAEA,IAAIH,gBAAgB,CAACA,gBAAgB,CAACI,MAAM,GAAG,CAAC,CAAC,GAAGD,aAAa,EAAE;IAClE,OAAO,UAAU;EAClB;;EAEA;EACA,OAAOH,gBAAgB,CAACM,OAAO,CAACH,aAAa,EAAE,CAAC,CAAC,IAAI,CAAC,GAAG,aAAa,GAAG,gBAAgB;AAC1F","ignoreList":[]}