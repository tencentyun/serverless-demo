{"version":3,"file":"pipeline.cjs","names":["BasePromptTemplate","input: PipelinePromptTemplateInput<PromptTemplateType>","allValues: InputValues","requiredValueNames: string[]","values: InputValues","ChatPromptTemplate","values: PartialValues"],"sources":["../../src/prompts/pipeline.ts"],"sourcesContent":["import type { InputValues, PartialValues } from \"../utils/types/index.js\";\nimport type { SerializedBasePromptTemplate } from \"./serde.js\";\nimport { BasePromptTemplate, type BasePromptTemplateInput } from \"./base.js\";\nimport { ChatPromptTemplate } from \"./chat.js\";\n\n/**\n * Type that includes the name of the prompt and the prompt itself.\n */\nexport type PipelinePromptParams<\n  PromptTemplateType extends BasePromptTemplate,\n> = {\n  name: string;\n  prompt: PromptTemplateType;\n};\n\n/**\n * Type that extends the BasePromptTemplateInput type, excluding the\n * inputVariables property. It includes an array of pipelinePrompts and a\n * finalPrompt.\n */\nexport type PipelinePromptTemplateInput<\n  PromptTemplateType extends BasePromptTemplate,\n> = Omit<BasePromptTemplateInput, \"inputVariables\"> & {\n  pipelinePrompts: PipelinePromptParams<PromptTemplateType>[];\n  finalPrompt: PromptTemplateType;\n};\n\n/**\n * Class that handles a sequence of prompts, each of which may require\n * different input variables. Includes methods for formatting these\n * prompts, extracting required input values, and handling partial\n * prompts.\n * @example\n * ```typescript\n * const composedPrompt = new PipelinePromptTemplate({\n *   pipelinePrompts: [\n *     {\n *       name: \"introduction\",\n *       prompt: PromptTemplate.fromTemplate(`You are impersonating {person}.`),\n *     },\n *     {\n *       name: \"example\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Here's an example of an interaction:\n * Q: {example_q}\n * A: {example_a}`,\n *       ),\n *     },\n *     {\n *       name: \"start\",\n *       prompt: PromptTemplate.fromTemplate(\n *         `Now, do this for real!\n * Q: {input}\n * A:`,\n *       ),\n *     },\n *   ],\n *   finalPrompt: PromptTemplate.fromTemplate(\n *     `{introduction}\n * {example}\n * {start}`,\n *   ),\n * });\n *\n * const formattedPrompt = await composedPrompt.format({\n *   person: \"Elon Musk\",\n *   example_q: `What's your favorite car?`,\n *   example_a: \"Tesla\",\n *   input: `What's your favorite social media site?`,\n * });\n * ```\n */\nexport class PipelinePromptTemplate<\n  PromptTemplateType extends BasePromptTemplate,\n> extends BasePromptTemplate {\n  static lc_name() {\n    return \"PipelinePromptTemplate\";\n  }\n\n  pipelinePrompts: PipelinePromptParams<PromptTemplateType>[];\n\n  finalPrompt: PromptTemplateType;\n\n  constructor(input: PipelinePromptTemplateInput<PromptTemplateType>) {\n    super({ ...input, inputVariables: [] });\n    this.pipelinePrompts = input.pipelinePrompts;\n    this.finalPrompt = input.finalPrompt;\n    this.inputVariables = this.computeInputValues();\n  }\n\n  /**\n   * Computes the input values required by the pipeline prompts.\n   * @returns Array of input values required by the pipeline prompts.\n   */\n  protected computeInputValues() {\n    const intermediateValues = this.pipelinePrompts.map(\n      (pipelinePrompt) => pipelinePrompt.name\n    );\n    const inputValues = this.pipelinePrompts\n      .map((pipelinePrompt) =>\n        pipelinePrompt.prompt.inputVariables.filter(\n          (inputValue) => !intermediateValues.includes(inputValue)\n        )\n      )\n      .flat();\n    return [...new Set(inputValues)];\n  }\n\n  protected static extractRequiredInputValues(\n    allValues: InputValues,\n    requiredValueNames: string[]\n  ) {\n    return requiredValueNames.reduce((requiredValues, valueName) => {\n      requiredValues[valueName] = allValues[valueName];\n      return requiredValues;\n    }, {} as InputValues);\n  }\n\n  /**\n   * Formats the pipeline prompts based on the provided input values.\n   * @param values Input values to format the pipeline prompts.\n   * @returns Promise that resolves with the formatted input values.\n   */\n  protected async formatPipelinePrompts(\n    values: InputValues\n  ): Promise<InputValues> {\n    const allValues = await this.mergePartialAndUserVariables(values);\n    for (const { name: pipelinePromptName, prompt: pipelinePrompt } of this\n      .pipelinePrompts) {\n      const pipelinePromptInputValues =\n        PipelinePromptTemplate.extractRequiredInputValues(\n          allValues,\n          pipelinePrompt.inputVariables\n        );\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      if (pipelinePrompt instanceof ChatPromptTemplate) {\n        allValues[pipelinePromptName] = await pipelinePrompt.formatMessages(\n          pipelinePromptInputValues\n        );\n      } else {\n        allValues[pipelinePromptName] = await pipelinePrompt.format(\n          pipelinePromptInputValues\n        );\n      }\n    }\n    return PipelinePromptTemplate.extractRequiredInputValues(\n      allValues,\n      this.finalPrompt.inputVariables\n    );\n  }\n\n  /**\n   * Formats the final prompt value based on the provided input values.\n   * @param values Input values to format the final prompt value.\n   * @returns Promise that resolves with the formatted final prompt value.\n   */\n  async formatPromptValue(\n    values: InputValues\n  ): Promise<PromptTemplateType[\"PromptValueReturnType\"]> {\n    return this.finalPrompt.formatPromptValue(\n      await this.formatPipelinePrompts(values)\n    );\n  }\n\n  async format(values: InputValues): Promise<string> {\n    return this.finalPrompt.format(await this.formatPipelinePrompts(values));\n  }\n\n  /**\n   * Handles partial prompts, which are prompts that have been partially\n   * filled with input values.\n   * @param values Partial input values.\n   * @returns Promise that resolves with a new PipelinePromptTemplate instance with updated input variables.\n   */\n  async partial(\n    values: PartialValues\n  ): Promise<PipelinePromptTemplate<PromptTemplateType>> {\n    const promptDict = { ...this };\n    promptDict.inputVariables = this.inputVariables.filter(\n      (iv) => !(iv in values)\n    );\n    promptDict.partialVariables = {\n      ...(this.partialVariables ?? {}),\n      ...values,\n    };\n    return new PipelinePromptTemplate<PromptTemplateType>(promptDict);\n  }\n\n  serialize(): SerializedBasePromptTemplate {\n    throw new Error(\"Not implemented.\");\n  }\n\n  _getPromptType(): string {\n    return \"pipeline\";\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAwEA,IAAa,yBAAb,MAAa,+BAEHA,gCAAmB;CAC3B,OAAO,UAAU;AACf,SAAO;CACR;CAED;CAEA;CAEA,YAAYC,OAAwD;EAClE,MAAM;GAAE,GAAG;GAAO,gBAAgB,CAAE;EAAE,EAAC;EACvC,KAAK,kBAAkB,MAAM;EAC7B,KAAK,cAAc,MAAM;EACzB,KAAK,iBAAiB,KAAK,oBAAoB;CAChD;;;;;CAMD,AAAU,qBAAqB;EAC7B,MAAM,qBAAqB,KAAK,gBAAgB,IAC9C,CAAC,mBAAmB,eAAe,KACpC;EACD,MAAM,cAAc,KAAK,gBACtB,IAAI,CAAC,mBACJ,eAAe,OAAO,eAAe,OACnC,CAAC,eAAe,CAAC,mBAAmB,SAAS,WAAW,CACzD,CACF,CACA,MAAM;AACT,SAAO,CAAC,GAAG,IAAI,IAAI,YAAa;CACjC;CAED,OAAiB,2BACfC,WACAC,oBACA;AACA,SAAO,mBAAmB,OAAO,CAAC,gBAAgB,cAAc;GAC9D,eAAe,aAAa,UAAU;AACtC,UAAO;EACR,GAAE,CAAE,EAAgB;CACtB;;;;;;CAOD,MAAgB,sBACdC,QACsB;EACtB,MAAM,YAAY,MAAM,KAAK,6BAA6B,OAAO;AACjE,OAAK,MAAM,EAAE,MAAM,oBAAoB,QAAQ,gBAAgB,IAAI,KAChE,iBAAiB;GAClB,MAAM,4BACJ,uBAAuB,2BACrB,WACA,eAAe,eAChB;AAEH,OAAI,0BAA0BC,iCAC5B,UAAU,sBAAsB,MAAM,eAAe,eACnD,0BACD;QAED,UAAU,sBAAsB,MAAM,eAAe,OACnD,0BACD;EAEJ;AACD,SAAO,uBAAuB,2BAC5B,WACA,KAAK,YAAY,eAClB;CACF;;;;;;CAOD,MAAM,kBACJD,QACsD;AACtD,SAAO,KAAK,YAAY,kBACtB,MAAM,KAAK,sBAAsB,OAAO,CACzC;CACF;CAED,MAAM,OAAOA,QAAsC;AACjD,SAAO,KAAK,YAAY,OAAO,MAAM,KAAK,sBAAsB,OAAO,CAAC;CACzE;;;;;;;CAQD,MAAM,QACJE,QACqD;EACrD,MAAM,aAAa,EAAE,GAAG,KAAM;EAC9B,WAAW,iBAAiB,KAAK,eAAe,OAC9C,CAAC,OAAO,EAAE,MAAM,QACjB;EACD,WAAW,mBAAmB;GAC5B,GAAI,KAAK,oBAAoB,CAAE;GAC/B,GAAG;EACJ;AACD,SAAO,IAAI,uBAA2C;CACvD;CAED,YAA0C;AACxC,QAAM,IAAI,MAAM;CACjB;CAED,iBAAyB;AACvB,SAAO;CACR;AACF"}