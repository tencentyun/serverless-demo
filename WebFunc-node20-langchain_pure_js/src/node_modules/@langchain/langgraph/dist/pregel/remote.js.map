{"version":3,"file":"remote.js","names":["DrawableGraph"],"sources":["../../src/pregel/remote.ts"],"sourcesContent":["import {\n  Client,\n  type Checkpoint,\n  type ThreadState,\n} from \"@langchain/langgraph-sdk\";\nimport {\n  Graph as DrawableGraph,\n  Node as DrawableNode,\n} from \"@langchain/core/runnables/graph\";\nimport {\n  mergeConfigs,\n  Runnable,\n  RunnableConfig,\n} from \"@langchain/core/runnables\";\nimport {\n  All,\n  CheckpointListOptions,\n  CheckpointMetadata,\n} from \"@langchain/langgraph-checkpoint\";\nimport { StreamEvent } from \"@langchain/core/tracers/log_stream\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport { isBaseMessage } from \"@langchain/core/messages\";\n\nimport {\n  BaseChannel,\n  GraphInterrupt,\n  LangGraphRunnableConfig,\n  RemoteException,\n} from \"../web.js\";\nimport { StrRecord } from \"./algo.js\";\nimport { PregelInputType, PregelOptions, PregelOutputType } from \"./index.js\";\nimport { PregelNode } from \"./read.js\";\nimport {\n  PregelParams,\n  PregelInterface,\n  PregelTaskDescription,\n  StateSnapshot,\n  StreamMode,\n} from \"./types.js\";\nimport {\n  CHECKPOINT_NAMESPACE_SEPARATOR,\n  CONFIG_KEY_STREAM,\n  INTERRUPT,\n  isCommand,\n} from \"../constants.js\";\n\nexport type RemoteGraphParams = Omit<\n  PregelParams<StrRecord<string, PregelNode>, StrRecord<string, BaseChannel>>,\n  \"channels\" | \"nodes\" | \"inputChannels\" | \"outputChannels\"\n> & {\n  graphId: string;\n  client?: Client;\n  url?: string;\n  apiKey?: string;\n  headers?: Record<string, string>;\n  streamResumable?: boolean;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst _serializeInputs = (obj: any): any => {\n  if (obj === null || typeof obj !== \"object\") {\n    return obj;\n  }\n\n  if (Array.isArray(obj)) {\n    return obj.map(_serializeInputs);\n  }\n\n  // Handle BaseMessage instances by converting them to a serializable format\n  if (isBaseMessage(obj)) {\n    const dict = obj.toDict();\n    return {\n      ...dict.data,\n      role: obj.getType(),\n    };\n  }\n\n  return Object.fromEntries(\n    Object.entries(obj).map(([key, value]) => [key, _serializeInputs(value)])\n  );\n};\n\n/**\n * Return a tuple of the final list of stream modes sent to the\n * remote graph and a boolean flag indicating if only one stream mode was\n * originally requested and whether stream mode 'updates'\n * was present in the original list of stream modes.\n *\n * 'updates' mode is always added to the list of stream modes so that interrupts\n * can be detected in the remote graph.\n */\nconst getStreamModes = (\n  streamMode?: StreamMode | StreamMode[],\n  defaultStreamMode: StreamMode = \"updates\"\n) => {\n  const updatedStreamModes: StreamMode[] = [];\n  let reqUpdates = false;\n  let reqSingle = true;\n\n  if (\n    streamMode !== undefined &&\n    (typeof streamMode === \"string\" ||\n      (Array.isArray(streamMode) && streamMode.length > 0))\n  ) {\n    reqSingle = typeof streamMode === \"string\";\n    const mapped = Array.isArray(streamMode) ? streamMode : [streamMode];\n    updatedStreamModes.push(...mapped);\n  } else {\n    updatedStreamModes.push(defaultStreamMode);\n  }\n  if (updatedStreamModes.includes(\"updates\")) {\n    reqUpdates = true;\n  } else {\n    updatedStreamModes.push(\"updates\");\n  }\n  return {\n    updatedStreamModes,\n    reqUpdates,\n    reqSingle,\n  };\n};\n\n/**\n * The `RemoteGraph` class is a client implementation for calling remote\n * APIs that implement the LangGraph Server API specification.\n *\n * For example, the `RemoteGraph` class can be used to call APIs from deployments\n * on LangSmith Deployment.\n *\n * `RemoteGraph` behaves the same way as a `StateGraph` and can be used directly as\n * a node in another `StateGraph`.\n *\n * @example\n * ```ts\n * import { RemoteGraph } from \"@langchain/langgraph/remote\";\n *\n * // Can also pass a LangGraph SDK client instance directly\n * const remoteGraph = new RemoteGraph({\n *   graphId: process.env.LANGGRAPH_REMOTE_GRAPH_ID!,\n *   apiKey: process.env.LANGGRAPH_REMOTE_GRAPH_API_KEY,\n *   url: process.env.LANGGRAPH_REMOTE_GRAPH_API_URL,\n * });\n *\n * const input = {\n *   messages: [\n *     {\n *       role: \"human\",\n *       content: \"Hello world!\",\n *     },\n *   ],\n * };\n *\n * const config = {\n *   configurable: { thread_id: \"threadId1\" },\n * };\n *\n * await remoteGraph.invoke(input, config);\n * ```\n */\nexport class RemoteGraph<\n    Nn extends StrRecord<string, PregelNode> = StrRecord<string, PregelNode>,\n    Cc extends StrRecord<string, BaseChannel> = StrRecord<string, BaseChannel>,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ContextType extends Record<string, any> = StrRecord<string, any>\n  >\n  extends Runnable<\n    PregelInputType,\n    PregelOutputType,\n    PregelOptions<Nn, Cc, ContextType>\n  >\n  implements PregelInterface<Nn, Cc, ContextType>\n{\n  static lc_name() {\n    return \"RemoteGraph\";\n  }\n\n  lc_namespace = [\"langgraph\", \"pregel\"];\n\n  lg_is_pregel = true;\n\n  config?: RunnableConfig;\n\n  graphId: string;\n\n  protected client: Client;\n\n  protected interruptBefore?: Array<keyof Nn> | All;\n\n  protected interruptAfter?: Array<keyof Nn> | All;\n\n  protected streamResumable?: boolean;\n\n  constructor(params: RemoteGraphParams) {\n    super(params);\n\n    this.graphId = params.graphId;\n    this.client =\n      params.client ??\n      new Client({\n        apiUrl: params.url,\n        apiKey: params.apiKey,\n        defaultHeaders: params.headers,\n      });\n    this.config = params.config;\n    this.interruptBefore = params.interruptBefore;\n    this.interruptAfter = params.interruptAfter;\n    this.streamResumable = params.streamResumable;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n  // @ts-ignore Remove ignore when we remove support for 0.2 versions of core\n  override withConfig(config: RunnableConfig): typeof this {\n    const mergedConfig = mergeConfigs(this.config, config);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return new (this.constructor as any)({ ...this, config: mergedConfig });\n  }\n\n  protected _sanitizeConfig(config: RunnableConfig) {\n    const reservedConfigurableKeys = new Set([\n      \"callbacks\",\n      \"checkpoint_map\",\n      \"checkpoint_id\",\n      \"checkpoint_ns\",\n    ]);\n\n    const sanitizeObj = <T>(obj: T): T => {\n      try {\n        // This will only throw if we're trying to serialize a circular reference\n        // or trying to serialize a BigInt...\n        JSON.stringify(obj);\n        return obj;\n      } catch {\n        const seen = new WeakSet();\n        return JSON.parse(\n          JSON.stringify(obj, (_, value) => {\n            if (typeof value === \"object\" && value != null) {\n              if (seen.has(value)) return \"[Circular]\";\n              seen.add(value);\n            }\n\n            if (typeof value === \"bigint\") return value.toString();\n            return value;\n          })\n        );\n      }\n    };\n\n    // Remove non-JSON serializable fields from the config\n    const sanitizedConfig = sanitizeObj(config);\n\n    // Only include configurable keys that are not reserved and\n    // not starting with \"__pregel_\" prefix\n    const newConfigurable = Object.fromEntries(\n      Object.entries(sanitizedConfig.configurable ?? {}).filter(\n        ([k]) => !reservedConfigurableKeys.has(k) && !k.startsWith(\"__pregel_\")\n      )\n    );\n\n    return {\n      tags: sanitizedConfig.tags ?? [],\n      metadata: sanitizedConfig.metadata ?? {},\n      configurable: newConfigurable,\n      recursion_limit: sanitizedConfig.recursionLimit,\n    };\n  }\n\n  protected _getConfig(checkpoint: Record<string, unknown>): RunnableConfig {\n    return {\n      configurable: {\n        thread_id: checkpoint.thread_id,\n        checkpoint_ns: checkpoint.checkpoint_ns,\n        checkpoint_id: checkpoint.checkpoint_id,\n        checkpoint_map: checkpoint.checkpoint_map ?? {},\n      },\n    };\n  }\n\n  protected _getCheckpoint(config?: RunnableConfig): Checkpoint | undefined {\n    if (config?.configurable === undefined) {\n      return undefined;\n    }\n\n    const checkpointKeys = [\n      \"thread_id\",\n      \"checkpoint_ns\",\n      \"checkpoint_id\",\n      \"checkpoint_map\",\n    ] as const;\n\n    const checkpoint = Object.fromEntries(\n      checkpointKeys\n        .map((key) => [key, config.configurable![key]])\n        .filter(([_, value]) => value !== undefined)\n    );\n\n    return Object.keys(checkpoint).length > 0 ? checkpoint : undefined;\n  }\n\n  protected _createStateSnapshot(state: ThreadState): StateSnapshot {\n    const tasks: PregelTaskDescription[] = state.tasks.map((task) => {\n      return {\n        id: task.id,\n        name: task.name,\n        error: task.error ? { message: task.error } : undefined,\n        // TODO: remove in LangGraph.js 0.4\n        interrupts: task.interrupts.map(({ id, ...rest }) => ({\n          interrupt_id: id,\n          ...rest,\n        })),\n        // eslint-disable-next-line no-nested-ternary\n        state: task.state\n          ? this._createStateSnapshot(task.state)\n          : task.checkpoint\n          ? { configurable: task.checkpoint }\n          : undefined,\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        result: (task as any).result,\n      };\n    });\n\n    return {\n      values: state.values,\n      next: state.next ? [...state.next] : [],\n      config: {\n        configurable: {\n          thread_id: state.checkpoint.thread_id,\n          checkpoint_ns: state.checkpoint.checkpoint_ns,\n          checkpoint_id: state.checkpoint.checkpoint_id,\n          checkpoint_map: state.checkpoint.checkpoint_map ?? {},\n        },\n      },\n      metadata: state.metadata\n        ? (state.metadata as CheckpointMetadata)\n        : undefined,\n      createdAt: state.created_at ?? undefined,\n      parentConfig: state.parent_checkpoint\n        ? {\n            configurable: {\n              thread_id: state.parent_checkpoint.thread_id,\n              checkpoint_ns: state.parent_checkpoint.checkpoint_ns,\n              checkpoint_id: state.parent_checkpoint.checkpoint_id,\n              checkpoint_map: state.parent_checkpoint.checkpoint_map ?? {},\n            },\n          }\n        : undefined,\n      tasks,\n    };\n  }\n\n  override async invoke(\n    input: PregelInputType,\n    options?: Partial<PregelOptions<Nn, Cc, ContextType>>\n  ): Promise<PregelOutputType> {\n    let lastValue;\n    const stream = await this.stream(input, {\n      ...options,\n      streamMode: \"values\",\n    });\n    for await (const chunk of stream) {\n      lastValue = chunk;\n    }\n    return lastValue;\n  }\n\n  override streamEvents(\n    input: PregelInputType,\n    options: Partial<PregelOptions<Nn, Cc, ContextType>> & {\n      version: \"v1\" | \"v2\";\n    }\n  ): IterableReadableStream<StreamEvent>;\n\n  override streamEvents(\n    input: PregelInputType,\n    options: Partial<PregelOptions<Nn, Cc, ContextType>> & {\n      version: \"v1\" | \"v2\";\n      encoding: never;\n    }\n  ): IterableReadableStream<never>;\n\n  override streamEvents(\n    _input: PregelInputType,\n    _options: Partial<PregelOptions<Nn, Cc, ContextType>> & {\n      version: \"v1\" | \"v2\";\n      encoding?: never;\n    }\n  ): IterableReadableStream<StreamEvent> {\n    throw new Error(\"Not implemented.\");\n  }\n\n  override async *_streamIterator(\n    input: PregelInputType,\n    options?: Partial<PregelOptions<Nn, Cc, ContextType>>\n  ): AsyncGenerator<PregelOutputType> {\n    const mergedConfig = mergeConfigs(this.config, options);\n    const sanitizedConfig = this._sanitizeConfig(mergedConfig);\n\n    const streamProtocolInstance = options?.configurable?.[CONFIG_KEY_STREAM];\n\n    const streamSubgraphs =\n      options?.subgraphs ?? streamProtocolInstance !== undefined;\n\n    const interruptBefore = options?.interruptBefore ?? this.interruptBefore;\n    const interruptAfter = options?.interruptAfter ?? this.interruptAfter;\n\n    const { updatedStreamModes, reqSingle, reqUpdates } = getStreamModes(\n      options?.streamMode\n    );\n\n    const extendedStreamModes = [\n      ...new Set([\n        ...updatedStreamModes,\n        ...(streamProtocolInstance?.modes ?? new Set()),\n      ]),\n    ].map((mode) => {\n      if (mode === \"messages\") return \"messages-tuple\";\n      return mode;\n    });\n\n    let command;\n    let serializedInput;\n    if (isCommand(input)) {\n      // TODO: Remove cast when SDK type fix gets merged\n      command = input.toJSON() as Record<string, unknown>;\n      serializedInput = undefined;\n    } else {\n      serializedInput = _serializeInputs(input);\n    }\n\n    for await (const chunk of this.client.runs.stream(\n      sanitizedConfig.configurable.thread_id as string,\n      this.graphId,\n      {\n        command,\n        input: serializedInput,\n        config: sanitizedConfig,\n        streamMode: extendedStreamModes,\n        interruptBefore: interruptBefore as string[],\n        interruptAfter: interruptAfter as string[],\n        streamSubgraphs,\n        ifNotExists: \"create\",\n        signal: mergedConfig.signal,\n        streamResumable: this.streamResumable,\n      }\n    )) {\n      let mode;\n      let namespace: string[];\n      if (chunk.event.includes(CHECKPOINT_NAMESPACE_SEPARATOR)) {\n        const eventComponents = chunk.event.split(\n          CHECKPOINT_NAMESPACE_SEPARATOR\n        );\n        // eslint-disable-next-line prefer-destructuring\n        mode = eventComponents[0];\n        namespace = eventComponents.slice(1);\n      } else {\n        mode = chunk.event;\n        namespace = [];\n      }\n      const callerNamespace = options?.configurable?.checkpoint_ns;\n      if (typeof callerNamespace === \"string\") {\n        namespace = callerNamespace\n          .split(CHECKPOINT_NAMESPACE_SEPARATOR)\n          .concat(namespace);\n      }\n      if (\n        streamProtocolInstance !== undefined &&\n        streamProtocolInstance.modes?.has(chunk.event)\n      ) {\n        streamProtocolInstance.push([namespace, mode, chunk.data]);\n      }\n      if (chunk.event.startsWith(\"updates\")) {\n        if (\n          typeof chunk.data === \"object\" &&\n          chunk.data?.[INTERRUPT] !== undefined\n        ) {\n          throw new GraphInterrupt(chunk.data[INTERRUPT]);\n        }\n        if (!reqUpdates) {\n          continue;\n        }\n      } else if (chunk.event?.startsWith(\"error\")) {\n        throw new RemoteException(\n          typeof chunk.data === \"string\"\n            ? chunk.data\n            : JSON.stringify(chunk.data)\n        );\n      }\n      if (\n        !updatedStreamModes.includes(\n          chunk.event.split(CHECKPOINT_NAMESPACE_SEPARATOR)[0] as StreamMode\n        )\n      ) {\n        continue;\n      }\n      if (options?.subgraphs) {\n        if (reqSingle) {\n          yield [namespace, chunk.data];\n        } else {\n          yield [namespace, mode, chunk.data];\n        }\n      } else if (reqSingle) {\n        yield chunk.data;\n      } else {\n        yield [mode, chunk.data];\n      }\n    }\n  }\n\n  async updateState(\n    inputConfig: LangGraphRunnableConfig,\n    values: Record<string, unknown>,\n    asNode?: string\n  ): Promise<RunnableConfig> {\n    const mergedConfig = mergeConfigs(this.config, inputConfig);\n    const response = await this.client.threads.updateState(\n      mergedConfig.configurable?.thread_id,\n      { values, asNode, checkpoint: this._getCheckpoint(mergedConfig) }\n    );\n    // TODO: Fix SDK typing\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return this._getConfig((response as any).checkpoint);\n  }\n\n  async *getStateHistory(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncIterableIterator<StateSnapshot> {\n    const mergedConfig = mergeConfigs(this.config, config);\n    const states = await this.client.threads.getHistory(\n      mergedConfig.configurable?.thread_id,\n      {\n        limit: options?.limit ?? 10,\n        // TODO: Fix type\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        before: this._getCheckpoint(options?.before) as any,\n        metadata: options?.filter,\n        checkpoint: this._getCheckpoint(mergedConfig),\n      }\n    );\n    for (const state of states) {\n      yield this._createStateSnapshot(state);\n    }\n  }\n\n  protected _getDrawableNodes(\n    nodes: Array<{\n      id: string | number;\n      name?: string;\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      data?: Record<string, any> | string;\n      metadata?: unknown;\n    }>\n  ): Record<string, DrawableNode> {\n    const nodesMap: Record<string, DrawableNode> = {};\n    for (const node of nodes) {\n      const nodeId = node.id;\n      nodesMap[nodeId] = {\n        id: nodeId.toString(),\n        name: typeof node.data === \"string\" ? node.data : node.data?.name ?? \"\",\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        data: (node.data as any) ?? {},\n        metadata:\n          typeof node.data !== \"string\" ? node.data?.metadata ?? {} : {},\n      };\n    }\n    return nodesMap;\n  }\n\n  async getState(\n    config: RunnableConfig,\n    options?: { subgraphs?: boolean }\n  ): Promise<StateSnapshot> {\n    const mergedConfig = mergeConfigs(this.config, config);\n\n    const state = await this.client.threads.getState(\n      mergedConfig.configurable?.thread_id,\n      this._getCheckpoint(mergedConfig),\n      options\n    );\n    return this._createStateSnapshot(state);\n  }\n\n  /** @deprecated Use getGraphAsync instead. The async method will become the default in the next minor release. */\n  override getGraph(\n    _?: RunnableConfig & { xray?: boolean | number }\n  ): DrawableGraph {\n    throw new Error(\n      `The synchronous \"getGraph\" is not supported for this graph. Call \"getGraphAsync\" instead.`\n    );\n  }\n\n  /**\n   * Returns a drawable representation of the computation graph.\n   */\n  async getGraphAsync(config?: RunnableConfig & { xray?: boolean | number }) {\n    const graph = await this.client.assistants.getGraph(this.graphId, {\n      xray: config?.xray,\n    });\n    return new DrawableGraph({\n      nodes: this._getDrawableNodes(graph.nodes),\n      edges: graph.edges,\n    });\n  }\n\n  /** @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release. */\n  getSubgraphs(): Generator<[string, PregelInterface<Nn, Cc, ContextType>]> {\n    throw new Error(\n      `The synchronous \"getSubgraphs\" method is not supported for this graph. Call \"getSubgraphsAsync\" instead.`\n    );\n  }\n\n  async *getSubgraphsAsync(\n    namespace?: string,\n    recurse = false\n  ): AsyncGenerator<[string, PregelInterface<Nn, Cc, ContextType>]> {\n    const subgraphs = await this.client.assistants.getSubgraphs(this.graphId, {\n      namespace,\n      recurse,\n    });\n\n    for (const [ns, graphSchema] of Object.entries(subgraphs)) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const remoteSubgraph = new (this.constructor as any)({\n        ...this,\n        graphId: graphSchema.graph_id,\n      });\n      yield [ns, remoteSubgraph];\n    }\n  }\n}\n"],"mappings":"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"}