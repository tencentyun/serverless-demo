"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AgentRunner: () => AgentRunner,
  CopilotRuntime: () => CopilotRuntime,
  InMemoryAgentRunner: () => InMemoryAgentRunner,
  TranscriptionService: () => TranscriptionService,
  VERSION: () => VERSION,
  createCopilotEndpoint: () => createCopilotEndpoint,
  createCopilotEndpointSingleRoute: () => createCopilotEndpointSingleRoute,
  finalizeRunEvents: () => import_shared6.finalizeRunEvents
});
module.exports = __toCommonJS(index_exports);

// package.json
var package_default = {
  name: "@copilotkitnext/runtime",
  version: "1.51.3",
  description: "Server-side runtime package for CopilotKit2",
  main: "dist/index.js",
  types: "dist/index.d.ts",
  exports: {
    ".": {
      types: "./dist/index.d.ts",
      import: "./dist/index.mjs",
      require: "./dist/index.js"
    },
    "./express": {
      types: "./dist/express.d.ts",
      import: "./dist/express.mjs",
      require: "./dist/express.js"
    }
  },
  publishConfig: {
    access: "public"
  },
  scripts: {
    build: "tsup",
    dev: "tsup --watch",
    lint: "eslint .",
    "check-types": "tsc --noEmit",
    clean: "rm -rf dist",
    test: "vitest run",
    "test:watch": "vitest",
    "test:coverage": "vitest run --coverage"
  },
  devDependencies: {
    "@copilotkitnext/eslint-config": "workspace:*",
    "@copilotkitnext/typescript-config": "workspace:*",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/node": "^22.15.3",
    eslint: "^9.30.0",
    supertest: "^7.1.1",
    tsup: "^8.5.0",
    typescript: "5.8.2",
    vitest: "^3.0.5"
  },
  dependencies: {
    "@ag-ui/client": "0.0.42",
    "@ag-ui/core": "0.0.42",
    "@ag-ui/encoder": "0.0.42",
    "@copilotkitnext/shared": "workspace:*",
    cors: "^2.8.5",
    express: "^4.21.2",
    hono: "^4.11.4",
    rxjs: "7.8.1"
  },
  peerDependencies: {
    "@ag-ui/client": "0.0.42",
    "@ag-ui/core": "0.0.42",
    "@ag-ui/encoder": "0.0.42",
    "@copilotkitnext/shared": "workspace:*"
  },
  peerDependenciesMeta: {},
  engines: {
    node: ">=18"
  }
};

// src/runner/agent-runner.ts
var AgentRunner = class {
};

// src/runner/in-memory.ts
var import_rxjs = require("rxjs");
var import_client = require("@ag-ui/client");
var import_shared = require("@copilotkitnext/shared");
var InMemoryEventStore = class {
  constructor(threadId) {
    this.threadId = threadId;
  }
  /** The subject that current consumers subscribe to. */
  subject = null;
  /** True while a run is actively producing events. */
  isRunning = false;
  /** Current run ID */
  currentRunId = null;
  /** Historic completed runs */
  historicRuns = [];
  /** Currently running agent instance (if any). */
  agent = null;
  /** Subject returned from run() while the run is active. */
  runSubject = null;
  /** True once stop() has been requested but the run has not yet finalized. */
  stopRequested = false;
  /** Reference to the events emitted in the current run. */
  currentEvents = null;
};
var GLOBAL_STORE_KEY = /* @__PURE__ */ Symbol.for("@copilotkitnext/runtime/in-memory-store");
function getGlobalStore() {
  const globalAny = globalThis;
  if (!globalAny[GLOBAL_STORE_KEY]) {
    globalAny[GLOBAL_STORE_KEY] = {
      stores: /* @__PURE__ */ new Map(),
      historicRunsBackup: /* @__PURE__ */ new Map()
    };
  }
  const data = globalAny[GLOBAL_STORE_KEY];
  if (data.stores.size === 0 && data.historicRunsBackup.size > 0) {
    for (const [threadId, historicRuns] of data.historicRunsBackup) {
      const store = new InMemoryEventStore(threadId);
      store.historicRuns = historicRuns;
      data.stores.set(threadId, store);
    }
  }
  return data.stores;
}
function backupHistoricRuns(threadId, historicRuns) {
  const globalAny = globalThis;
  if (globalAny[GLOBAL_STORE_KEY]) {
    globalAny[GLOBAL_STORE_KEY].historicRunsBackup.set(threadId, historicRuns);
  }
}
var GLOBAL_STORE = getGlobalStore();
var InMemoryAgentRunner = class extends AgentRunner {
  run(request) {
    let existingStore = GLOBAL_STORE.get(request.threadId);
    if (!existingStore) {
      existingStore = new InMemoryEventStore(request.threadId);
      GLOBAL_STORE.set(request.threadId, existingStore);
    }
    const store = existingStore;
    if (store.isRunning) {
      throw new Error("Thread already running");
    }
    store.isRunning = true;
    store.currentRunId = request.input.runId;
    store.agent = request.agent;
    store.stopRequested = false;
    const seenMessageIds = /* @__PURE__ */ new Set();
    const currentRunEvents = [];
    store.currentEvents = currentRunEvents;
    const historicMessageIds = /* @__PURE__ */ new Set();
    for (const run of store.historicRuns) {
      for (const event of run.events) {
        if ("messageId" in event && typeof event.messageId === "string") {
          historicMessageIds.add(event.messageId);
        }
        if (event.type === import_client.EventType.RUN_STARTED) {
          const runStarted = event;
          const messages = runStarted.input?.messages ?? [];
          for (const message of messages) {
            historicMessageIds.add(message.id);
          }
        }
      }
    }
    const nextSubject = new import_rxjs.ReplaySubject(Infinity);
    const prevSubject = store.subject;
    store.subject = nextSubject;
    const runSubject = new import_rxjs.ReplaySubject(Infinity);
    store.runSubject = runSubject;
    const runAgent = async () => {
      const lastRun = store.historicRuns[store.historicRuns.length - 1];
      const parentRunId = lastRun?.runId ?? null;
      try {
        await request.agent.runAgent(request.input, {
          onEvent: ({ event }) => {
            let processedEvent = event;
            if (event.type === import_client.EventType.RUN_STARTED) {
              const runStartedEvent = event;
              if (!runStartedEvent.input) {
                const sanitizedMessages = request.input.messages ? request.input.messages.filter(
                  (message) => !historicMessageIds.has(message.id)
                ) : void 0;
                const updatedInput = {
                  ...request.input,
                  ...sanitizedMessages !== void 0 ? { messages: sanitizedMessages } : {}
                };
                processedEvent = {
                  ...runStartedEvent,
                  input: updatedInput
                };
              }
            }
            runSubject.next(processedEvent);
            nextSubject.next(processedEvent);
            currentRunEvents.push(processedEvent);
          },
          onNewMessage: ({ message }) => {
            if (!seenMessageIds.has(message.id)) {
              seenMessageIds.add(message.id);
            }
          },
          onRunStartedEvent: () => {
            if (request.input.messages) {
              for (const message of request.input.messages) {
                if (!seenMessageIds.has(message.id)) {
                  seenMessageIds.add(message.id);
                }
              }
            }
          }
        });
        const appendedEvents = (0, import_shared.finalizeRunEvents)(currentRunEvents, {
          stopRequested: store.stopRequested
        });
        for (const event of appendedEvents) {
          runSubject.next(event);
          nextSubject.next(event);
        }
        if (store.currentRunId) {
          const compactedEvents = (0, import_client.compactEvents)(currentRunEvents);
          store.historicRuns.push({
            threadId: request.threadId,
            runId: store.currentRunId,
            parentRunId,
            events: compactedEvents,
            createdAt: Date.now()
          });
          backupHistoricRuns(request.threadId, store.historicRuns);
        }
        store.currentEvents = null;
        store.currentRunId = null;
        store.agent = null;
        store.runSubject = null;
        store.stopRequested = false;
        store.isRunning = false;
        runSubject.complete();
        nextSubject.complete();
      } catch {
        const appendedEvents = (0, import_shared.finalizeRunEvents)(currentRunEvents, {
          stopRequested: store.stopRequested
        });
        for (const event of appendedEvents) {
          runSubject.next(event);
          nextSubject.next(event);
        }
        if (store.currentRunId && currentRunEvents.length > 0) {
          const compactedEvents = (0, import_client.compactEvents)(currentRunEvents);
          store.historicRuns.push({
            threadId: request.threadId,
            runId: store.currentRunId,
            parentRunId,
            events: compactedEvents,
            createdAt: Date.now()
          });
          backupHistoricRuns(request.threadId, store.historicRuns);
        }
        store.currentEvents = null;
        store.currentRunId = null;
        store.agent = null;
        store.runSubject = null;
        store.stopRequested = false;
        store.isRunning = false;
        runSubject.complete();
        nextSubject.complete();
      }
    };
    if (prevSubject) {
      prevSubject.subscribe({
        next: (e) => nextSubject.next(e),
        error: (err) => nextSubject.error(err),
        complete: () => {
        }
      });
    }
    runAgent();
    return runSubject.asObservable();
  }
  connect(request) {
    const store = GLOBAL_STORE.get(request.threadId);
    const connectionSubject = new import_rxjs.ReplaySubject(Infinity);
    if (!store) {
      connectionSubject.complete();
      return connectionSubject.asObservable();
    }
    const allHistoricEvents = [];
    for (const run of store.historicRuns) {
      allHistoricEvents.push(...run.events);
    }
    const compactedEvents = (0, import_client.compactEvents)(allHistoricEvents);
    const emittedMessageIds = /* @__PURE__ */ new Set();
    for (const event of compactedEvents) {
      connectionSubject.next(event);
      if ("messageId" in event && typeof event.messageId === "string") {
        emittedMessageIds.add(event.messageId);
      }
    }
    if (store.subject && (store.isRunning || store.stopRequested)) {
      store.subject.subscribe({
        next: (event) => {
          if ("messageId" in event && typeof event.messageId === "string" && emittedMessageIds.has(event.messageId)) {
            return;
          }
          connectionSubject.next(event);
        },
        complete: () => connectionSubject.complete(),
        error: (err) => connectionSubject.error(err)
      });
    } else {
      connectionSubject.complete();
    }
    return connectionSubject.asObservable();
  }
  isRunning(request) {
    const store = GLOBAL_STORE.get(request.threadId);
    return Promise.resolve(store?.isRunning ?? false);
  }
  stop(request) {
    const store = GLOBAL_STORE.get(request.threadId);
    if (!store || !store.isRunning) {
      return Promise.resolve(false);
    }
    if (store.stopRequested) {
      return Promise.resolve(false);
    }
    store.stopRequested = true;
    store.isRunning = false;
    const agent = store.agent;
    if (!agent) {
      store.stopRequested = false;
      store.isRunning = false;
      return Promise.resolve(false);
    }
    try {
      agent.abortRun();
      return Promise.resolve(true);
    } catch (error) {
      console.error("Failed to abort agent run", error);
      store.stopRequested = false;
      store.isRunning = true;
      return Promise.resolve(false);
    }
  }
};

// src/runtime.ts
var VERSION = package_default.version;
var CopilotRuntime = class {
  agents;
  transcriptionService;
  beforeRequestMiddleware;
  afterRequestMiddleware;
  runner;
  constructor({
    agents,
    transcriptionService,
    beforeRequestMiddleware,
    afterRequestMiddleware,
    runner
  }) {
    this.agents = agents;
    this.transcriptionService = transcriptionService;
    this.beforeRequestMiddleware = beforeRequestMiddleware;
    this.afterRequestMiddleware = afterRequestMiddleware;
    this.runner = runner ?? new InMemoryAgentRunner();
  }
};

// src/endpoints/hono.ts
var import_hono = require("hono");
var import_cors = require("hono/cors");

// src/handlers/handle-run.ts
var import_client2 = require("@ag-ui/client");
var import_encoder = require("@ag-ui/encoder");

// src/handlers/header-utils.ts
function shouldForwardHeader(headerName) {
  const lower = headerName.toLowerCase();
  return lower === "authorization" || lower.startsWith("x-");
}
function extractForwardableHeaders(request) {
  const forwardableHeaders = {};
  request.headers.forEach((value, key) => {
    if (shouldForwardHeader(key)) {
      forwardableHeaders[key] = value;
    }
  });
  return forwardableHeaders;
}

// src/handlers/handle-run.ts
async function handleRunAgent({
  runtime,
  request,
  agentId
}) {
  try {
    const agents = await runtime.agents;
    if (!agents[agentId]) {
      return new Response(
        JSON.stringify({
          error: "Agent not found",
          message: `Agent '${agentId}' does not exist`
        }),
        {
          status: 404,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    const registeredAgent = agents[agentId];
    const agent = registeredAgent.clone();
    if (agent && "headers" in agent) {
      const forwardableHeaders = extractForwardableHeaders(request);
      agent.headers = {
        ...agent.headers,
        ...forwardableHeaders
      };
    }
    const stream = new TransformStream();
    const writer = stream.writable.getWriter();
    const encoder = new import_encoder.EventEncoder();
    let streamClosed = false;
    (async () => {
      let input;
      try {
        const requestBody = await request.json();
        input = import_client2.RunAgentInputSchema.parse(requestBody);
      } catch {
        return new Response(
          JSON.stringify({
            error: "Invalid request body"
          }),
          { status: 400 }
        );
      }
      agent.setMessages(input.messages);
      agent.setState(input.state);
      agent.threadId = input.threadId;
      runtime.runner.run({
        threadId: input.threadId,
        agent,
        input
      }).subscribe({
        next: async (event) => {
          if (!request.signal.aborted && !streamClosed) {
            try {
              await writer.write(encoder.encode(event));
            } catch (error) {
              if (error instanceof Error && error.name === "AbortError") {
                streamClosed = true;
              }
            }
          }
        },
        error: async (error) => {
          console.error("Error running agent:", error);
          if (!streamClosed) {
            try {
              await writer.close();
              streamClosed = true;
            } catch {
            }
          }
        },
        complete: async () => {
          if (!streamClosed) {
            try {
              await writer.close();
              streamClosed = true;
            } catch {
            }
          }
        }
      });
    })().catch((error) => {
      console.error("Error running agent:", error);
      console.error(
        "Error stack:",
        error instanceof Error ? error.stack : "No stack trace"
      );
      console.error("Error details:", {
        name: error instanceof Error ? error.name : "Unknown",
        message: error instanceof Error ? error.message : String(error),
        cause: error instanceof Error ? error.cause : void 0
      });
      if (!streamClosed) {
        try {
          writer.close();
          streamClosed = true;
        } catch {
        }
      }
    });
    return new Response(stream.readable, {
      status: 200,
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive"
      }
    });
  } catch (error) {
    console.error("Error running agent:", error);
    console.error(
      "Error stack:",
      error instanceof Error ? error.stack : "No stack trace"
    );
    console.error("Error details:", {
      name: error instanceof Error ? error.name : "Unknown",
      message: error instanceof Error ? error.message : String(error),
      cause: error instanceof Error ? error.cause : void 0
    });
    return new Response(
      JSON.stringify({
        error: "Failed to run agent",
        message: error instanceof Error ? error.message : "Unknown error"
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}

// src/handlers/get-runtime-info.ts
async function handleGetRuntimeInfo({
  runtime
}) {
  try {
    const agents = await runtime.agents;
    const agentsDict = Object.entries(agents).reduce(
      (acc, [name, agent]) => {
        acc[name] = {
          name,
          description: agent.description,
          className: agent.constructor.name
        };
        return acc;
      },
      {}
    );
    const runtimeInfo = {
      version: VERSION,
      agents: agentsDict,
      audioFileTranscriptionEnabled: !!runtime.transcriptionService
    };
    return new Response(JSON.stringify(runtimeInfo), {
      status: 200,
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    return new Response(
      JSON.stringify({
        error: "Failed to retrieve runtime information",
        message: error instanceof Error ? error.message : "Unknown error"
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}

// src/handlers/handle-transcribe.ts
var import_shared2 = require("@copilotkitnext/shared");
var ERROR_STATUS_CODES = {
  [import_shared2.TranscriptionErrorCode.SERVICE_NOT_CONFIGURED]: 503,
  [import_shared2.TranscriptionErrorCode.INVALID_AUDIO_FORMAT]: 400,
  [import_shared2.TranscriptionErrorCode.AUDIO_TOO_LONG]: 400,
  [import_shared2.TranscriptionErrorCode.AUDIO_TOO_SHORT]: 400,
  [import_shared2.TranscriptionErrorCode.RATE_LIMITED]: 429,
  [import_shared2.TranscriptionErrorCode.AUTH_FAILED]: 401,
  [import_shared2.TranscriptionErrorCode.PROVIDER_ERROR]: 500,
  [import_shared2.TranscriptionErrorCode.NETWORK_ERROR]: 502,
  [import_shared2.TranscriptionErrorCode.INVALID_REQUEST]: 400
};
var VALID_AUDIO_TYPES = [
  "audio/mpeg",
  "audio/mp3",
  "audio/mp4",
  "audio/wav",
  "audio/webm",
  "audio/ogg",
  "audio/flac",
  "audio/aac"
];
function isValidAudioType(type) {
  const baseType = type.split(";")[0]?.trim() ?? "";
  return VALID_AUDIO_TYPES.includes(baseType) || baseType === "" || baseType === "application/octet-stream";
}
function createErrorResponse(errorResponse) {
  const status = ERROR_STATUS_CODES[errorResponse.error] ?? 500;
  return new Response(JSON.stringify(errorResponse), {
    status,
    headers: { "Content-Type": "application/json" }
  });
}
function base64ToFile(base64, mimeType, filename) {
  const base64Data = base64.includes(",") ? base64.split(",")[1] ?? base64 : base64;
  const binaryString = atob(base64Data);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return new File([bytes], filename, { type: mimeType });
}
async function extractAudioFromFormData(request) {
  const formData = await request.formData();
  const audioFile = formData.get("audio");
  if (!audioFile || !(audioFile instanceof File)) {
    const err = import_shared2.TranscriptionErrors.invalidRequest(
      "No audio file found in form data. Please include an 'audio' field."
    );
    return { error: createErrorResponse(err) };
  }
  if (!isValidAudioType(audioFile.type)) {
    const err = import_shared2.TranscriptionErrors.invalidAudioFormat(audioFile.type, VALID_AUDIO_TYPES);
    return { error: createErrorResponse(err) };
  }
  return { file: audioFile };
}
async function extractAudioFromJson(request) {
  let body;
  try {
    body = await request.json();
  } catch {
    const err = import_shared2.TranscriptionErrors.invalidRequest("Request body must be valid JSON");
    return { error: createErrorResponse(err) };
  }
  if (!body.audio || typeof body.audio !== "string") {
    const err = import_shared2.TranscriptionErrors.invalidRequest(
      "Request must include 'audio' field with base64-encoded audio data"
    );
    return { error: createErrorResponse(err) };
  }
  if (!body.mimeType || typeof body.mimeType !== "string") {
    const err = import_shared2.TranscriptionErrors.invalidRequest(
      "Request must include 'mimeType' field (e.g., 'audio/webm')"
    );
    return { error: createErrorResponse(err) };
  }
  if (!isValidAudioType(body.mimeType)) {
    const err = import_shared2.TranscriptionErrors.invalidAudioFormat(body.mimeType, VALID_AUDIO_TYPES);
    return { error: createErrorResponse(err) };
  }
  try {
    const filename = body.filename || "recording.webm";
    const file = base64ToFile(body.audio, body.mimeType, filename);
    return { file };
  } catch {
    const err = import_shared2.TranscriptionErrors.invalidRequest("Failed to decode base64 audio data");
    return { error: createErrorResponse(err) };
  }
}
function categorizeProviderError(error) {
  const message = error instanceof Error ? error.message : "Unknown error occurred";
  const errorStr = String(error).toLowerCase();
  if (errorStr.includes("rate") || errorStr.includes("429") || errorStr.includes("too many")) {
    return import_shared2.TranscriptionErrors.rateLimited();
  }
  if (errorStr.includes("auth") || errorStr.includes("401") || errorStr.includes("api key") || errorStr.includes("unauthorized")) {
    return import_shared2.TranscriptionErrors.authFailed();
  }
  if (errorStr.includes("too long") || errorStr.includes("duration") || errorStr.includes("length")) {
    return import_shared2.TranscriptionErrors.audioTooLong();
  }
  return import_shared2.TranscriptionErrors.providerError(message);
}
async function handleTranscribe({
  runtime,
  request
}) {
  try {
    if (!runtime.transcriptionService) {
      const err = import_shared2.TranscriptionErrors.serviceNotConfigured();
      return createErrorResponse(err);
    }
    const contentType = request.headers.get("content-type") || "";
    let extractResult;
    if (contentType.includes("multipart/form-data")) {
      extractResult = await extractAudioFromFormData(request);
    } else if (contentType.includes("application/json")) {
      extractResult = await extractAudioFromJson(request);
    } else {
      const err = import_shared2.TranscriptionErrors.invalidRequest(
        "Request must be multipart/form-data or application/json with base64 audio"
      );
      return createErrorResponse(err);
    }
    if ("error" in extractResult) {
      return extractResult.error;
    }
    const audioFile = extractResult.file;
    const transcription = await runtime.transcriptionService.transcribeFile({
      audioFile,
      mimeType: audioFile.type,
      size: audioFile.size
    });
    return new Response(
      JSON.stringify({
        text: transcription,
        size: audioFile.size,
        type: audioFile.type
      }),
      {
        status: 200,
        headers: { "Content-Type": "application/json" }
      }
    );
  } catch (error) {
    return createErrorResponse(categorizeProviderError(error));
  }
}

// src/endpoints/hono.ts
var import_shared4 = require("@copilotkitnext/shared");

// src/middleware.ts
var import_shared3 = require("@copilotkitnext/shared");
async function callBeforeRequestMiddleware({
  runtime,
  request,
  path
}) {
  const mw = runtime.beforeRequestMiddleware;
  if (!mw) return;
  if (typeof mw === "function") {
    return mw({ runtime, request, path });
  }
  import_shared3.logger.warn({ mw }, "Unsupported beforeRequestMiddleware value \u2013 skipped");
  return;
}
async function callAfterRequestMiddleware({
  runtime,
  response,
  path
}) {
  const mw = runtime.afterRequestMiddleware;
  if (!mw) return;
  if (typeof mw === "function") {
    return mw({ runtime, response, path });
  }
  import_shared3.logger.warn({ mw }, "Unsupported afterRequestMiddleware value \u2013 skipped");
}

// src/handlers/handle-connect.ts
var import_client3 = require("@ag-ui/client");
var import_encoder2 = require("@ag-ui/encoder");
async function handleConnectAgent({
  runtime,
  request,
  agentId
}) {
  try {
    const agents = await runtime.agents;
    if (!agents[agentId]) {
      return new Response(
        JSON.stringify({
          error: "Agent not found",
          message: `Agent '${agentId}' does not exist`
        }),
        {
          status: 404,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    const stream = new TransformStream();
    const writer = stream.writable.getWriter();
    const encoder = new import_encoder2.EventEncoder();
    let streamClosed = false;
    (async () => {
      let input;
      try {
        const requestBody = await request.json();
        input = import_client3.RunAgentInputSchema.parse(requestBody);
      } catch {
        return new Response(
          JSON.stringify({
            error: "Invalid request body"
          }),
          { status: 400 }
        );
      }
      const forwardableHeaders = extractForwardableHeaders(request);
      runtime.runner.connect({
        threadId: input.threadId,
        headers: forwardableHeaders
      }).subscribe({
        next: async (event) => {
          if (!request.signal.aborted && !streamClosed) {
            try {
              await writer.write(encoder.encode(event));
            } catch (error) {
              if (error instanceof Error && error.name === "AbortError") {
                streamClosed = true;
              }
            }
          }
        },
        error: async (error) => {
          console.error("Error running agent:", error);
          if (!streamClosed) {
            try {
              await writer.close();
              streamClosed = true;
            } catch {
            }
          }
        },
        complete: async () => {
          if (!streamClosed) {
            try {
              await writer.close();
              streamClosed = true;
            } catch {
            }
          }
        }
      });
    })().catch((error) => {
      console.error("Error running agent:", error);
      console.error(
        "Error stack:",
        error instanceof Error ? error.stack : "No stack trace"
      );
      console.error("Error details:", {
        name: error instanceof Error ? error.name : "Unknown",
        message: error instanceof Error ? error.message : String(error),
        cause: error instanceof Error ? error.cause : void 0
      });
      if (!streamClosed) {
        try {
          writer.close();
          streamClosed = true;
        } catch {
        }
      }
    });
    return new Response(stream.readable, {
      status: 200,
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive"
      }
    });
  } catch (error) {
    console.error("Error running agent:", error);
    console.error(
      "Error stack:",
      error instanceof Error ? error.stack : "No stack trace"
    );
    console.error("Error details:", {
      name: error instanceof Error ? error.name : "Unknown",
      message: error instanceof Error ? error.message : String(error),
      cause: error instanceof Error ? error.cause : void 0
    });
    return new Response(
      JSON.stringify({
        error: "Failed to run agent",
        message: error instanceof Error ? error.message : "Unknown error"
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}

// src/handlers/handle-stop.ts
var import_client4 = require("@ag-ui/client");
async function handleStopAgent({
  runtime,
  request,
  agentId,
  threadId
}) {
  try {
    const agents = await runtime.agents;
    if (!agents[agentId]) {
      return new Response(
        JSON.stringify({
          error: "Agent not found",
          message: `Agent '${agentId}' does not exist`
        }),
        {
          status: 404,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    const stopped = await runtime.runner.stop({ threadId });
    if (!stopped) {
      return new Response(
        JSON.stringify({
          stopped: false,
          message: `No active run for thread '${threadId}'.`
        }),
        {
          status: 200,
          headers: { "Content-Type": "application/json" }
        }
      );
    }
    return new Response(
      JSON.stringify({
        stopped: true,
        interrupt: {
          type: import_client4.EventType.RUN_ERROR,
          message: "Run stopped by user",
          code: "STOPPED"
        }
      }),
      {
        status: 200,
        headers: { "Content-Type": "application/json" }
      }
    );
  } catch (error) {
    console.error("Error stopping agent run:", error);
    return new Response(
      JSON.stringify({
        error: "Failed to stop agent",
        message: error instanceof Error ? error.message : "Unknown error"
      }),
      {
        status: 500,
        headers: { "Content-Type": "application/json" }
      }
    );
  }
}

// src/endpoints/hono.ts
function createCopilotEndpoint({ runtime, basePath, cors: corsConfig }) {
  const app = new import_hono.Hono();
  return app.basePath(basePath).use(
    "*",
    (0, import_cors.cors)({
      origin: corsConfig?.origin ?? "*",
      allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH", "OPTIONS"],
      allowHeaders: ["*"],
      credentials: corsConfig?.credentials ?? false
    })
  ).use("*", async (c, next) => {
    const request = c.req.raw;
    const path = c.req.path;
    try {
      const maybeModifiedRequest = await callBeforeRequestMiddleware({
        runtime,
        request,
        path
      });
      if (maybeModifiedRequest) {
        c.set("modifiedRequest", maybeModifiedRequest);
      }
    } catch (error) {
      import_shared4.logger.error({ err: error, url: request.url, path }, "Error running before request middleware");
      if (error instanceof Response) {
        return error;
      }
      throw error;
    }
    await next();
  }).use("*", async (c, next) => {
    await next();
    const response = c.res;
    const path = c.req.path;
    callAfterRequestMiddleware({
      runtime,
      response,
      path
    }).catch((error) => {
      import_shared4.logger.error({ err: error, url: c.req.url, path }, "Error running after request middleware");
    });
  }).post("/agent/:agentId/run", async (c) => {
    const agentId = c.req.param("agentId");
    const request = c.get("modifiedRequest") || c.req.raw;
    try {
      return await handleRunAgent({
        runtime,
        request,
        agentId
      });
    } catch (error) {
      import_shared4.logger.error({ err: error, url: request.url, path: c.req.path }, "Error running request handler");
      throw error;
    }
  }).post("/agent/:agentId/connect", async (c) => {
    const agentId = c.req.param("agentId");
    const request = c.get("modifiedRequest") || c.req.raw;
    try {
      return await handleConnectAgent({
        runtime,
        request,
        agentId
      });
    } catch (error) {
      import_shared4.logger.error({ err: error, url: request.url, path: c.req.path }, "Error running request handler");
      throw error;
    }
  }).post("/agent/:agentId/stop/:threadId", async (c) => {
    const agentId = c.req.param("agentId");
    const threadId = c.req.param("threadId");
    const request = c.get("modifiedRequest") || c.req.raw;
    try {
      return await handleStopAgent({
        runtime,
        request,
        agentId,
        threadId
      });
    } catch (error) {
      import_shared4.logger.error({ err: error, url: request.url, path: c.req.path }, "Error running request handler");
      throw error;
    }
  }).get("/info", async (c) => {
    const request = c.get("modifiedRequest") || c.req.raw;
    try {
      return await handleGetRuntimeInfo({
        runtime,
        request
      });
    } catch (error) {
      import_shared4.logger.error({ err: error, url: request.url, path: c.req.path }, "Error running request handler");
      throw error;
    }
  }).post("/transcribe", async (c) => {
    const request = c.get("modifiedRequest") || c.req.raw;
    try {
      return await handleTranscribe({
        runtime,
        request
      });
    } catch (error) {
      import_shared4.logger.error({ err: error, url: request.url, path: c.req.path }, "Error running request handler");
      throw error;
    }
  }).notFound((c) => {
    return c.json({ error: "Not found" }, 404);
  });
}

// src/endpoints/hono-single.ts
var import_hono2 = require("hono");
var import_cors2 = require("hono/cors");
var import_shared5 = require("@copilotkitnext/shared");

// src/endpoints/single-route-helpers.ts
var METHOD_NAMES = [
  "agent/run",
  "agent/connect",
  "agent/stop",
  "info",
  "transcribe"
];
async function parseMethodCall(request) {
  const contentType = request.headers.get("content-type") || "";
  if (!contentType.includes("application/json")) {
    throw createResponseError("Single-route endpoint expects JSON payloads", 415);
  }
  let jsonEnvelope;
  try {
    jsonEnvelope = await request.clone().json();
  } catch (error) {
    throw createResponseError("Invalid JSON payload", 400);
  }
  const method = validateMethod(jsonEnvelope.method);
  return {
    method,
    params: jsonEnvelope.params,
    body: jsonEnvelope.body
  };
}
function expectString(params, key) {
  const value = params?.[key];
  if (typeof value === "string" && value.trim().length > 0) {
    return value;
  }
  throw createResponseError(`Missing or invalid parameter '${key}'`, 400);
}
function createJsonRequest(base, body) {
  if (body === void 0 || body === null) {
    throw createResponseError("Missing request body for JSON handler", 400);
  }
  const headers = new Headers(base.headers);
  headers.set("content-type", "application/json");
  headers.delete("content-length");
  const serializedBody = serializeJsonBody(body);
  return new Request(base.url, {
    method: "POST",
    headers,
    body: serializedBody,
    signal: base.signal
  });
}
function createResponseError(message, status) {
  return new Response(
    JSON.stringify({
      error: "invalid_request",
      message
    }),
    {
      status,
      headers: {
        "Content-Type": "application/json"
      }
    }
  );
}
function validateMethod(method) {
  if (!method) {
    throw createResponseError("Missing method field", 400);
  }
  if (METHOD_NAMES.includes(method)) {
    return method;
  }
  throw createResponseError(`Unsupported method '${method}'`, 400);
}
function serializeJsonBody(body) {
  if (typeof body === "string") {
    return body;
  }
  if (body instanceof Blob || body instanceof ArrayBuffer || body instanceof Uint8Array) {
    return body;
  }
  if (body instanceof FormData || body instanceof URLSearchParams) {
    return body;
  }
  return JSON.stringify(body);
}

// src/endpoints/hono-single.ts
function createCopilotEndpointSingleRoute({ runtime, basePath, cors: corsConfig }) {
  const app = new import_hono2.Hono();
  const routePath = normalizePath(basePath);
  return app.basePath(routePath).use(
    "*",
    (0, import_cors2.cors)({
      origin: corsConfig?.origin ?? "*",
      allowMethods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH", "OPTIONS"],
      allowHeaders: ["*"],
      credentials: corsConfig?.credentials ?? false
    })
  ).use("*", async (c, next) => {
    const request = c.req.raw;
    const path = c.req.path;
    try {
      const maybeModifiedRequest = await callBeforeRequestMiddleware({
        runtime,
        request,
        path
      });
      if (maybeModifiedRequest) {
        c.set("modifiedRequest", maybeModifiedRequest);
      }
    } catch (error) {
      import_shared5.logger.error({ err: error, url: request.url, path }, "Error running before request middleware");
      if (error instanceof Response) {
        return error;
      }
      throw error;
    }
    await next();
  }).use("*", async (c, next) => {
    await next();
    const response = c.res;
    const path = c.req.path;
    callAfterRequestMiddleware({
      runtime,
      response,
      path
    }).catch((error) => {
      import_shared5.logger.error({ err: error, url: c.req.url, path }, "Error running after request middleware");
    });
  }).post("/", async (c) => {
    const request = c.get("modifiedRequest") || c.req.raw;
    let methodCall;
    try {
      methodCall = await parseMethodCall(request);
    } catch (error) {
      if (error instanceof Response) {
        import_shared5.logger.warn({ url: request.url }, "Invalid single-route payload");
        return error;
      }
      import_shared5.logger.warn({ err: error, url: request.url }, "Invalid single-route payload");
      return c.json(
        {
          error: "invalid_request",
          message: error instanceof Error ? error.message : "Invalid request payload"
        },
        400
      );
    }
    try {
      switch (methodCall.method) {
        case "agent/run": {
          const agentId = expectString(methodCall.params, "agentId");
          const handlerRequest = createJsonRequest(request, methodCall.body);
          return await handleRunAgent({ runtime, request: handlerRequest, agentId });
        }
        case "agent/connect": {
          const agentId = expectString(methodCall.params, "agentId");
          const handlerRequest = createJsonRequest(request, methodCall.body);
          return await handleConnectAgent({ runtime, request: handlerRequest, agentId });
        }
        case "agent/stop": {
          const agentId = expectString(methodCall.params, "agentId");
          const threadId = expectString(methodCall.params, "threadId");
          return await handleStopAgent({ runtime, request, agentId, threadId });
        }
        case "info": {
          return await handleGetRuntimeInfo({ runtime, request });
        }
        case "transcribe": {
          const handlerRequest = createJsonRequest(request, methodCall.body);
          return await handleTranscribe({ runtime, request: handlerRequest });
        }
        default: {
          const exhaustiveCheck = methodCall.method;
          return exhaustiveCheck;
        }
      }
    } catch (error) {
      if (error instanceof Response) {
        return error;
      }
      import_shared5.logger.error({ err: error, url: request.url, method: methodCall.method }, "Error running single-route handler");
      throw error;
    }
  }).notFound((c) => {
    return c.json({ error: "Not found" }, 404);
  });
}
function normalizePath(path) {
  if (!path) {
    throw new Error("basePath must be provided for single-route endpoint");
  }
  if (!path.startsWith("/")) {
    return `/${path}`;
  }
  if (path.length > 1 && path.endsWith("/")) {
    return path.slice(0, -1);
  }
  return path;
}

// src/runner/index.ts
var import_shared6 = require("@copilotkitnext/shared");

// src/transcription-service/transcription-service.ts
var TranscriptionService = class {
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AgentRunner,
  CopilotRuntime,
  InMemoryAgentRunner,
  TranscriptionService,
  VERSION,
  createCopilotEndpoint,
  createCopilotEndpointSingleRoute,
  finalizeRunEvents
});
//# sourceMappingURL=index.js.map