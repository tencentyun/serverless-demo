{"version":3,"file":"client.js","names":["iter: Iterable<(HeaderValue | HeaderValue | null[])[]>","entries: [string, string][]","headerEntries: [string, string][]","timeoutSignal: AbortSignal | null","stream: ReadableStream<T>","json: Record<string, unknown>","threadId: string","params: Record<string, unknown>"],"sources":["../src/client.ts"],"sourcesContent":["import {\n  Assistant,\n  AssistantGraph,\n  AssistantSortBy,\n  AssistantSelectField,\n  AssistantVersion,\n  AssistantsSearchResponse,\n  CancelAction,\n  Checkpoint,\n  Config,\n  Cron,\n  CronSelectField,\n  CronCreateForThreadResponse,\n  CronCreateResponse,\n  CronSortBy,\n  DefaultValues,\n  GraphSchema,\n  Item,\n  ListNamespaceResponse,\n  Metadata,\n  Run,\n  RunSelectField,\n  RunStatus,\n  SearchItemsResponse,\n  SortOrder,\n  Subgraphs,\n  Thread,\n  ThreadSelectField,\n  ThreadSortBy,\n  ThreadState,\n  ThreadStatus,\n  ThreadValuesFilter,\n} from \"./schema.js\";\nimport type {\n  Command,\n  CronsCreatePayload,\n  OnConflictBehavior,\n  RunsCreatePayload,\n  RunsStreamPayload,\n  RunsWaitPayload,\n  StreamEvent,\n} from \"./types.js\";\nimport type {\n  StreamMode,\n  ThreadStreamMode,\n  TypedAsyncGenerator,\n} from \"./types.stream.js\";\nimport { AsyncCaller, AsyncCallerParams } from \"./utils/async_caller.js\";\nimport { getEnvironmentVariable } from \"./utils/env.js\";\nimport { mergeSignals } from \"./utils/signals.js\";\nimport { BytesLineDecoder, SSEDecoder } from \"./utils/sse.js\";\nimport { streamWithRetry, StreamRequestParams } from \"./utils/stream.js\";\n\ntype HeaderValue = string | undefined | null;\n\nfunction* iterateHeaders(\n  headers: HeadersInit | Record<string, HeaderValue>\n): IterableIterator<[string, string | null]> {\n  let iter: Iterable<(HeaderValue | HeaderValue | null[])[]>;\n  let shouldClear = false;\n\n  // eslint-disable-next-line no-instanceof/no-instanceof\n  if (headers instanceof Headers) {\n    const entries: [string, string][] = [];\n    headers.forEach((value, name) => {\n      entries.push([name, value]);\n    });\n    iter = entries;\n  } else if (Array.isArray(headers)) {\n    iter = headers;\n  } else {\n    shouldClear = true;\n    iter = Object.entries(headers ?? {});\n  }\n\n  for (const item of iter) {\n    const name = item[0];\n    if (typeof name !== \"string\")\n      throw new TypeError(\n        `Expected header name to be a string, got ${typeof name}`\n      );\n    const values = Array.isArray(item[1]) ? item[1] : [item[1]];\n    let didClear = false;\n\n    for (const value of values) {\n      if (value === undefined) continue;\n\n      // New object keys should always overwrite older headers\n      // Yield a null to clear the header in the headers object\n      // before adding the new value\n      if (shouldClear && !didClear) {\n        didClear = true;\n        yield [name, null];\n      }\n      yield [name, value];\n    }\n  }\n}\n\nfunction mergeHeaders(\n  ...headerObjects: (\n    | HeadersInit\n    | Record<string, HeaderValue>\n    | undefined\n    | null\n  )[]\n) {\n  const outputHeaders = new Headers();\n  for (const headers of headerObjects) {\n    if (!headers) continue;\n    for (const [name, value] of iterateHeaders(headers)) {\n      if (value === null) outputHeaders.delete(name);\n      else outputHeaders.append(name, value);\n    }\n  }\n  const headerEntries: [string, string][] = [];\n  outputHeaders.forEach((value, name) => {\n    headerEntries.push([name, value]);\n  });\n  return Object.fromEntries(headerEntries);\n}\n\n/**\n * Get the API key from the environment.\n * Precedence:\n *   1. explicit argument (if string)\n *   2. LANGGRAPH_API_KEY\n *   3. LANGSMITH_API_KEY\n *   4. LANGCHAIN_API_KEY\n *\n * @param apiKey - API key provided as an argument. If null, skips environment lookup. If undefined, tries environment.\n * @returns The API key if found, otherwise undefined\n */\nexport function getApiKey(apiKey?: string | null): string | undefined {\n  // If explicitly set to null, skip auto-loading\n  if (apiKey === null) {\n    return undefined;\n  }\n\n  // If a string value is provided, use it\n  if (apiKey) {\n    return apiKey;\n  }\n\n  // If undefined, try to load from environment\n  const prefixes = [\"LANGGRAPH\", \"LANGSMITH\", \"LANGCHAIN\"];\n\n  for (const prefix of prefixes) {\n    const envKey = getEnvironmentVariable(`${prefix}_API_KEY`);\n    if (envKey) {\n      // Remove surrounding quotes\n      return envKey.trim().replace(/^[\"']|[\"']$/g, \"\");\n    }\n  }\n\n  return undefined;\n}\n\nconst REGEX_RUN_METADATA =\n  /(\\/threads\\/(?<thread_id>.+))?\\/runs\\/(?<run_id>.+)/;\n\nfunction getRunMetadataFromResponse(\n  response: Response\n): { run_id: string; thread_id?: string } | undefined {\n  const contentLocation = response.headers.get(\"Content-Location\");\n  if (!contentLocation) return undefined;\n\n  const match = REGEX_RUN_METADATA.exec(contentLocation);\n\n  if (!match?.groups?.run_id) return undefined;\n  return {\n    run_id: match.groups.run_id,\n    thread_id: match.groups.thread_id || undefined,\n  };\n}\n\nexport type RequestHook = (\n  url: URL,\n  init: RequestInit\n) => Promise<RequestInit> | RequestInit;\n\nexport interface ClientConfig {\n  apiUrl?: string;\n  /**\n   * API key for authentication.\n   * - If a string is provided, that key will be used\n   * - If undefined (default), the key will be auto-loaded from environment variables (LANGGRAPH_API_KEY, LANGSMITH_API_KEY, or LANGCHAIN_API_KEY)\n   * - If null, no API key will be set (skips auto-loading)\n   */\n  apiKey?: string | null;\n  callerOptions?: AsyncCallerParams;\n  timeoutMs?: number;\n  defaultHeaders?: Record<string, HeaderValue>;\n  onRequest?: RequestHook;\n}\n\nclass BaseClient {\n  protected asyncCaller: AsyncCaller;\n\n  protected timeoutMs: number | undefined;\n\n  protected apiUrl: string;\n\n  protected defaultHeaders: Record<string, HeaderValue>;\n\n  protected onRequest?: RequestHook;\n\n  constructor(config?: ClientConfig) {\n    const callerOptions = {\n      maxRetries: 4,\n      maxConcurrency: 4,\n      ...config?.callerOptions,\n    };\n\n    let defaultApiUrl = \"http://localhost:8123\";\n    if (\n      !config?.apiUrl &&\n      typeof globalThis === \"object\" &&\n      globalThis != null\n    ) {\n      const fetchSmb = Symbol.for(\"langgraph_api:fetch\");\n      const urlSmb = Symbol.for(\"langgraph_api:url\");\n\n      const global = globalThis as unknown as {\n        [fetchSmb]?: typeof fetch;\n        [urlSmb]?: string;\n      };\n\n      if (global[fetchSmb]) callerOptions.fetch ??= global[fetchSmb];\n      if (global[urlSmb]) defaultApiUrl = global[urlSmb];\n    }\n\n    this.asyncCaller = new AsyncCaller(callerOptions);\n    this.timeoutMs = config?.timeoutMs;\n\n    // default limit being capped by Chrome\n    // https://github.com/nodejs/undici/issues/1373\n    // Regex to remove trailing slash, if present\n    this.apiUrl = config?.apiUrl?.replace(/\\/$/, \"\") || defaultApiUrl;\n    this.defaultHeaders = config?.defaultHeaders || {};\n    this.onRequest = config?.onRequest;\n    const apiKey = getApiKey(config?.apiKey);\n    if (apiKey) {\n      this.defaultHeaders[\"x-api-key\"] = apiKey;\n    }\n  }\n\n  protected prepareFetchOptions(\n    path: string,\n    options?: RequestInit & {\n      json?: unknown;\n      params?: Record<string, unknown>;\n      timeoutMs?: number | null;\n      withResponse?: boolean;\n    }\n  ): [url: URL, init: RequestInit] {\n    const mutatedOptions = {\n      ...options,\n      headers: mergeHeaders(this.defaultHeaders, options?.headers),\n    };\n\n    if (mutatedOptions.json) {\n      mutatedOptions.body = JSON.stringify(mutatedOptions.json);\n      mutatedOptions.headers = mergeHeaders(mutatedOptions.headers, {\n        \"content-type\": \"application/json\",\n      });\n      delete mutatedOptions.json;\n    }\n\n    if (mutatedOptions.withResponse) {\n      delete mutatedOptions.withResponse;\n    }\n\n    let timeoutSignal: AbortSignal | null = null;\n    if (typeof options?.timeoutMs !== \"undefined\") {\n      if (options.timeoutMs != null) {\n        timeoutSignal = AbortSignal.timeout(options.timeoutMs);\n      }\n    } else if (this.timeoutMs != null) {\n      timeoutSignal = AbortSignal.timeout(this.timeoutMs);\n    }\n\n    mutatedOptions.signal = mergeSignals(timeoutSignal, mutatedOptions.signal);\n    const targetUrl = new URL(`${this.apiUrl}${path}`);\n\n    if (mutatedOptions.params) {\n      for (const [key, value] of Object.entries(mutatedOptions.params)) {\n        if (value == null) continue;\n\n        const strValue =\n          typeof value === \"string\" || typeof value === \"number\"\n            ? value.toString()\n            : JSON.stringify(value);\n\n        targetUrl.searchParams.append(key, strValue);\n      }\n      delete mutatedOptions.params;\n    }\n\n    return [targetUrl, mutatedOptions];\n  }\n\n  protected async fetch<T>(\n    path: string,\n    options: RequestInit & {\n      json?: unknown;\n      params?: Record<string, unknown>;\n      timeoutMs?: number | null;\n      signal: AbortSignal | undefined;\n      withResponse: true;\n    }\n  ): Promise<[T, Response]>;\n\n  protected async fetch<T>(\n    path: string,\n    options?: RequestInit & {\n      json?: unknown;\n      params?: Record<string, unknown>;\n      timeoutMs?: number | null;\n      signal: AbortSignal | undefined;\n      withResponse?: false;\n    }\n  ): Promise<T>;\n\n  protected async fetch<T>(\n    path: string,\n    options?: RequestInit & {\n      json?: unknown;\n      params?: Record<string, unknown>;\n      timeoutMs?: number | null;\n      signal: AbortSignal | undefined;\n      withResponse?: boolean;\n    }\n  ): Promise<T | [T, Response]> {\n    const [url, init] = this.prepareFetchOptions(path, options);\n\n    let finalInit = init;\n    if (this.onRequest) {\n      finalInit = await this.onRequest(url, init);\n    }\n\n    const response = await this.asyncCaller.fetch(url, finalInit);\n\n    const body = (() => {\n      if (response.status === 202 || response.status === 204) {\n        return undefined as T;\n      }\n      return response.json() as Promise<T>;\n    })();\n\n    if (options?.withResponse) {\n      return [await body, response];\n    }\n\n    return body;\n  }\n\n  /**\n   * Protected helper for streaming with automatic retry logic.\n   * Handles both initial requests and reconnections with SSE.\n   */\n  protected async *streamWithRetry<\n    T extends { id?: string; event: string; data: unknown }\n  >(config: {\n    endpoint: string;\n    method?: string;\n    signal?: AbortSignal;\n    headers?: Record<string, string>;\n    params?: Record<string, unknown>;\n    json?: unknown;\n    maxRetries?: number;\n    onReconnect?: (options: {\n      attempt: number;\n      lastEventId?: string;\n      cause: unknown;\n    }) => void;\n    onInitialResponse?: (response: Response) => void | Promise<void>;\n  }): AsyncGenerator<T> {\n    const makeRequest = async (reconnectParams?: StreamRequestParams) => {\n      // Determine endpoint - use reconnectPath if provided, otherwise original endpoint\n      const requestEndpoint = reconnectParams?.reconnectPath || config.endpoint;\n\n      // Determine method and options based on whether this is a reconnection\n      const isReconnect = !!reconnectParams?.lastEventId;\n      const method = isReconnect ? \"GET\" : config.method || \"GET\";\n\n      // Build headers - add Last-Event-ID for reconnections\n      const requestHeaders =\n        isReconnect && reconnectParams?.lastEventId\n          ? { ...config.headers, \"Last-Event-ID\": reconnectParams.lastEventId }\n          : config.headers;\n\n      // Prepare fetch options\n      let [url, init] = this.prepareFetchOptions(requestEndpoint, {\n        method,\n        timeoutMs: null,\n        signal: config.signal,\n        headers: requestHeaders,\n        params: config.params,\n        json: isReconnect ? undefined : config.json, // Only send body on initial request\n      });\n\n      // Apply onRequest hook if present\n      if (this.onRequest != null) {\n        init = await this.onRequest(url, init);\n      }\n\n      // Make the request\n      const response = await this.asyncCaller.fetch(url, init);\n\n      // Call onInitialResponse callback for the first request\n      if (!isReconnect && config.onInitialResponse) {\n        await config.onInitialResponse(response);\n      }\n\n      // Process the response body through SSE decoders\n      const stream: ReadableStream<T> = (\n        response.body || new ReadableStream({ start: (ctrl) => ctrl.close() })\n      )\n        .pipeThrough(BytesLineDecoder())\n        .pipeThrough(SSEDecoder()) as ReadableStream<T>;\n\n      return { response, stream };\n    };\n\n    // Use the utility function with our request maker\n    yield* streamWithRetry(makeRequest, {\n      maxRetries: config.maxRetries ?? 5,\n      signal: config.signal,\n      onReconnect: config.onReconnect,\n    });\n  }\n}\n\nexport class CronsClient extends BaseClient {\n  /**\n   *\n   * @param threadId The ID of the thread.\n   * @param assistantId Assistant ID to use for this cron job.\n   * @param payload Payload for creating a cron job.\n   * @returns The created background run.\n   */\n  async createForThread(\n    threadId: string,\n    assistantId: string,\n    payload?: CronsCreatePayload\n  ): Promise<CronCreateForThreadResponse> {\n    const json: Record<string, unknown> = {\n      schedule: payload?.schedule,\n      input: payload?.input,\n      config: payload?.config,\n      context: payload?.context,\n      metadata: payload?.metadata,\n      assistant_id: assistantId,\n      interrupt_before: payload?.interruptBefore,\n      interrupt_after: payload?.interruptAfter,\n      webhook: payload?.webhook,\n      multitask_strategy: payload?.multitaskStrategy,\n      if_not_exists: payload?.ifNotExists,\n      checkpoint_during: payload?.checkpointDuring,\n      durability: payload?.durability,\n    };\n    return this.fetch<CronCreateForThreadResponse>(\n      `/threads/${threadId}/runs/crons`,\n      {\n        method: \"POST\",\n        json,\n        signal: payload?.signal,\n      }\n    );\n  }\n\n  /**\n   *\n   * @param assistantId Assistant ID to use for this cron job.\n   * @param payload Payload for creating a cron job.\n   * @returns\n   */\n  async create(\n    assistantId: string,\n    payload?: CronsCreatePayload\n  ): Promise<CronCreateResponse> {\n    const json: Record<string, unknown> = {\n      schedule: payload?.schedule,\n      input: payload?.input,\n      config: payload?.config,\n      context: payload?.context,\n      metadata: payload?.metadata,\n      assistant_id: assistantId,\n      interrupt_before: payload?.interruptBefore,\n      interrupt_after: payload?.interruptAfter,\n      webhook: payload?.webhook,\n      multitask_strategy: payload?.multitaskStrategy,\n      if_not_exists: payload?.ifNotExists,\n      checkpoint_during: payload?.checkpointDuring,\n      durability: payload?.durability,\n    };\n    return this.fetch<CronCreateResponse>(`/runs/crons`, {\n      method: \"POST\",\n      json,\n      signal: payload?.signal,\n    });\n  }\n\n  /**\n   *\n   * @param cronId Cron ID of Cron job to delete.\n   */\n  async delete(\n    cronId: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<void> {\n    await this.fetch<void>(`/runs/crons/${cronId}`, {\n      method: \"DELETE\",\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   *\n   * @param query Query options.\n   * @returns List of crons.\n   */\n  async search(query?: {\n    assistantId?: string;\n    threadId?: string;\n    limit?: number;\n    offset?: number;\n    sortBy?: CronSortBy;\n    sortOrder?: SortOrder;\n    select?: CronSelectField[];\n    signal?: AbortSignal;\n  }): Promise<Cron[]> {\n    return this.fetch<Cron[]>(\"/runs/crons/search\", {\n      method: \"POST\",\n      json: {\n        assistant_id: query?.assistantId ?? undefined,\n        thread_id: query?.threadId ?? undefined,\n        limit: query?.limit ?? 10,\n        offset: query?.offset ?? 0,\n        sort_by: query?.sortBy ?? undefined,\n        sort_order: query?.sortOrder ?? undefined,\n        select: query?.select ?? undefined,\n      },\n      signal: query?.signal,\n    });\n  }\n\n  /**\n   * Count cron jobs matching filters.\n   *\n   * @param query.assistantId Assistant ID to filter by.\n   * @param query.threadId Thread ID to filter by.\n   * @returns Number of cron jobs matching the criteria.\n   */\n  async count(query?: {\n    assistantId?: string;\n    threadId?: string;\n    signal?: AbortSignal;\n  }): Promise<number> {\n    return this.fetch<number>(`/runs/crons/count`, {\n      method: \"POST\",\n      json: {\n        assistant_id: query?.assistantId ?? undefined,\n        thread_id: query?.threadId ?? undefined,\n      },\n      signal: query?.signal,\n    });\n  }\n}\n\nexport class AssistantsClient extends BaseClient {\n  /**\n   * Get an assistant by ID.\n   *\n   * @param assistantId The ID of the assistant.\n   * @returns Assistant\n   */\n  async get(\n    assistantId: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<Assistant> {\n    return this.fetch<Assistant>(`/assistants/${assistantId}`, {\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * Get the JSON representation of the graph assigned to a runnable\n   * @param assistantId The ID of the assistant.\n   * @param options.xray Whether to include subgraphs in the serialized graph representation. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.\n   * @returns Serialized graph\n   */\n  async getGraph(\n    assistantId: string,\n    options?: { xray?: boolean | number; signal?: AbortSignal }\n  ): Promise<AssistantGraph> {\n    return this.fetch<AssistantGraph>(`/assistants/${assistantId}/graph`, {\n      params: { xray: options?.xray },\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * Get the state and config schema of the graph assigned to a runnable\n   * @param assistantId The ID of the assistant.\n   * @returns Graph schema\n   */\n  async getSchemas(\n    assistantId: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<GraphSchema> {\n    return this.fetch<GraphSchema>(`/assistants/${assistantId}/schemas`, {\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * Get the schemas of an assistant by ID.\n   *\n   * @param assistantId The ID of the assistant to get the schema of.\n   * @param options Additional options for getting subgraphs, such as namespace or recursion extraction.\n   * @returns The subgraphs of the assistant.\n   */\n  async getSubgraphs(\n    assistantId: string,\n    options?: {\n      namespace?: string;\n      recurse?: boolean;\n      signal?: AbortSignal;\n    }\n  ): Promise<Subgraphs> {\n    if (options?.namespace) {\n      return this.fetch<Subgraphs>(\n        `/assistants/${assistantId}/subgraphs/${options.namespace}`,\n        { params: { recurse: options?.recurse }, signal: options?.signal }\n      );\n    }\n    return this.fetch<Subgraphs>(`/assistants/${assistantId}/subgraphs`, {\n      params: { recurse: options?.recurse },\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * Create a new assistant.\n   * @param payload Payload for creating an assistant.\n   * @returns The created assistant.\n   */\n  async create(payload: {\n    graphId: string;\n    config?: Config;\n    context?: unknown;\n    metadata?: Metadata;\n    assistantId?: string;\n    ifExists?: OnConflictBehavior;\n    name?: string;\n    description?: string;\n    signal?: AbortSignal;\n  }): Promise<Assistant> {\n    return this.fetch<Assistant>(\"/assistants\", {\n      method: \"POST\",\n      json: {\n        graph_id: payload.graphId,\n        config: payload.config,\n        context: payload.context,\n        metadata: payload.metadata,\n        assistant_id: payload.assistantId,\n        if_exists: payload.ifExists,\n        name: payload.name,\n        description: payload.description,\n      },\n      signal: payload.signal,\n    });\n  }\n\n  /**\n   * Update an assistant.\n   * @param assistantId ID of the assistant.\n   * @param payload Payload for updating the assistant.\n   * @returns The updated assistant.\n   */\n  async update(\n    assistantId: string,\n    payload: {\n      graphId?: string;\n      config?: Config;\n      context?: unknown;\n      metadata?: Metadata;\n      name?: string;\n      description?: string;\n      signal?: AbortSignal;\n    }\n  ): Promise<Assistant> {\n    return this.fetch<Assistant>(`/assistants/${assistantId}`, {\n      method: \"PATCH\",\n      json: {\n        graph_id: payload.graphId,\n        config: payload.config,\n        context: payload.context,\n        metadata: payload.metadata,\n        name: payload.name,\n        description: payload.description,\n      },\n      signal: payload.signal,\n    });\n  }\n\n  /**\n   * Delete an assistant.\n   *\n   * @param assistantId ID of the assistant.\n   */\n  async delete(\n    assistantId: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<void> {\n    return this.fetch<void>(`/assistants/${assistantId}`, {\n      method: \"DELETE\",\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * List assistants.\n   * @param query Query options.\n   * @returns List of assistants or, when includePagination is true, a mapping with the assistants and next cursor.\n   */\n  async search(query: {\n    graphId?: string;\n    name?: string;\n    metadata?: Metadata;\n    limit?: number;\n    offset?: number;\n    sortBy?: AssistantSortBy;\n    sortOrder?: SortOrder;\n    select?: AssistantSelectField[];\n    includePagination: true;\n    signal?: AbortSignal;\n  }): Promise<AssistantsSearchResponse>;\n\n  async search(query?: {\n    graphId?: string;\n    name?: string;\n    metadata?: Metadata;\n    limit?: number;\n    offset?: number;\n    sortBy?: AssistantSortBy;\n    sortOrder?: SortOrder;\n    select?: AssistantSelectField[];\n    includePagination?: false;\n    signal?: AbortSignal;\n  }): Promise<Assistant[]>;\n\n  async search(query?: {\n    graphId?: string;\n    name?: string;\n    metadata?: Metadata;\n    limit?: number;\n    offset?: number;\n    sortBy?: AssistantSortBy;\n    sortOrder?: SortOrder;\n    select?: AssistantSelectField[];\n    includePagination?: boolean;\n    signal?: AbortSignal;\n  }): Promise<Assistant[] | AssistantsSearchResponse> {\n    const json = {\n      graph_id: query?.graphId ?? undefined,\n      name: query?.name ?? undefined,\n      metadata: query?.metadata ?? undefined,\n      limit: query?.limit ?? 10,\n      offset: query?.offset ?? 0,\n      sort_by: query?.sortBy ?? undefined,\n      sort_order: query?.sortOrder ?? undefined,\n      select: query?.select ?? undefined,\n    };\n    const [assistants, response] = await this.fetch<Assistant[]>(\n      \"/assistants/search\",\n      {\n        method: \"POST\",\n        json,\n        withResponse: true,\n        signal: query?.signal,\n      }\n    );\n\n    if (query?.includePagination) {\n      const next = response.headers.get(\"X-Pagination-Next\");\n      return { assistants, next };\n    }\n\n    return assistants;\n  }\n\n  /**\n   * Count assistants matching filters.\n   *\n   * @param query.metadata Metadata to filter by. Exact match for each key/value.\n   * @param query.graphId Optional graph id to filter by.\n   * @param query.name Optional name to filter by.\n   * @returns Number of assistants matching the criteria.\n   */\n  async count(query?: {\n    metadata?: Metadata;\n    graphId?: string;\n    name?: string;\n    signal?: AbortSignal;\n  }): Promise<number> {\n    return this.fetch<number>(`/assistants/count`, {\n      method: \"POST\",\n      json: {\n        metadata: query?.metadata ?? undefined,\n        graph_id: query?.graphId ?? undefined,\n        name: query?.name ?? undefined,\n      },\n      signal: query?.signal,\n    });\n  }\n\n  /**\n   * List all versions of an assistant.\n   *\n   * @param assistantId ID of the assistant.\n   * @returns List of assistant versions.\n   */\n  async getVersions(\n    assistantId: string,\n    payload?: {\n      metadata?: Metadata;\n      limit?: number;\n      offset?: number;\n      signal?: AbortSignal;\n    }\n  ): Promise<AssistantVersion[]> {\n    return this.fetch<AssistantVersion[]>(\n      `/assistants/${assistantId}/versions`,\n      {\n        method: \"POST\",\n        json: {\n          metadata: payload?.metadata ?? undefined,\n          limit: payload?.limit ?? 10,\n          offset: payload?.offset ?? 0,\n        },\n        signal: payload?.signal,\n      }\n    );\n  }\n\n  /**\n   * Change the version of an assistant.\n   *\n   * @param assistantId ID of the assistant.\n   * @param version The version to change to.\n   * @returns The updated assistant.\n   */\n  async setLatest(\n    assistantId: string,\n    version: number,\n    options?: { signal?: AbortSignal }\n  ): Promise<Assistant> {\n    return this.fetch<Assistant>(`/assistants/${assistantId}/latest`, {\n      method: \"POST\",\n      json: { version },\n      signal: options?.signal,\n    });\n  }\n}\n\nexport class ThreadsClient<\n  TStateType = DefaultValues,\n  TUpdateType = TStateType\n> extends BaseClient {\n  /**\n   * Get a thread by ID.\n   *\n   * @param threadId ID of the thread.\n   * @returns The thread.\n   */\n  async get<ValuesType = TStateType>(\n    threadId: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<Thread<ValuesType>> {\n    return this.fetch<Thread<ValuesType>>(`/threads/${threadId}`, {\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * Create a new thread.\n   *\n   * @param payload Payload for creating a thread.\n   * @returns The created thread.\n   */\n  async create(payload?: {\n    /**\n     * Metadata for the thread.\n     */\n    metadata?: Metadata;\n    /**\n     * ID of the thread to create.\n     *\n     * If not provided, a random UUID will be generated.\n     */\n    threadId?: string;\n    /**\n     * How to handle duplicate creation.\n     *\n     * @default \"raise\"\n     */\n    ifExists?: OnConflictBehavior;\n    /**\n     * Graph ID to associate with the thread.\n     */\n    graphId?: string;\n    /**\n     * Apply a list of supersteps when creating a thread, each containing a sequence of updates.\n     *\n     * Used for copying a thread between deployments.\n     */\n    supersteps?: Array<{\n      updates: Array<{ values: unknown; command?: Command; asNode: string }>;\n    }>;\n    /**\n     * Optional time-to-live in minutes for the thread.\n     * If a number is provided, it is treated as minutes and defaults to strategy \"delete\".\n     * You may also provide an object { ttl: number, strategy?: \"delete\" }.\n     */\n    ttl?: number | { ttl: number; strategy?: \"delete\" };\n\n    /**\n     * Signal to abort the request.\n     */\n    signal?: AbortSignal;\n  }): Promise<Thread<TStateType>> {\n    // Normalize ttl to an object if a number is provided\n    const ttlPayload =\n      typeof payload?.ttl === \"number\"\n        ? { ttl: payload.ttl, strategy: \"delete\" as const }\n        : payload?.ttl;\n\n    return this.fetch<Thread<TStateType>>(`/threads`, {\n      method: \"POST\",\n      json: {\n        metadata: {\n          ...payload?.metadata,\n          graph_id: payload?.graphId,\n        },\n        thread_id: payload?.threadId,\n        if_exists: payload?.ifExists,\n        supersteps: payload?.supersteps?.map((s) => ({\n          updates: s.updates.map((u) => ({\n            values: u.values,\n            command: u.command,\n            as_node: u.asNode,\n          })),\n        })),\n        ttl: ttlPayload,\n      },\n      signal: payload?.signal,\n    });\n  }\n\n  /**\n   * Copy an existing thread\n   * @param threadId ID of the thread to be copied\n   * @returns Newly copied thread\n   */\n  async copy(\n    threadId: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<Thread<TStateType>> {\n    return this.fetch<Thread<TStateType>>(`/threads/${threadId}/copy`, {\n      method: \"POST\",\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * Update a thread.\n   *\n   * @param threadId ID of the thread.\n   * @param payload Payload for updating the thread.\n   * @returns The updated thread.\n   */\n  async update(\n    threadId: string,\n    payload?: {\n      /**\n       * Metadata for the thread.\n       */\n      metadata?: Metadata;\n      /**\n       * Optional time-to-live in minutes for the thread.\n       * If a number is provided, it is treated as minutes and defaults to strategy \"delete\".\n       * You may also provide an object { ttl: number, strategy?: \"delete\" }.\n       */\n      ttl?: number | { ttl: number; strategy?: \"delete\" };\n      /**\n       * Signal to abort the request.\n       */\n      signal?: AbortSignal;\n    }\n  ): Promise<Thread> {\n    const ttlPayload =\n      typeof payload?.ttl === \"number\"\n        ? { ttl: payload.ttl, strategy: \"delete\" as const }\n        : payload?.ttl;\n\n    return this.fetch<Thread>(`/threads/${threadId}`, {\n      method: \"PATCH\",\n      json: { metadata: payload?.metadata, ttl: ttlPayload },\n      signal: payload?.signal,\n    });\n  }\n\n  /**\n   * Delete a thread.\n   *\n   * @param threadId ID of the thread.\n   */\n  async delete(\n    threadId: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<void> {\n    return this.fetch<void>(`/threads/${threadId}`, {\n      method: \"DELETE\",\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * List threads\n   *\n   * @param query Query options\n   * @returns List of threads\n   */\n  async search<ValuesType = TStateType>(query?: {\n    /**\n     * Metadata to filter threads by.\n     */\n    metadata?: Metadata;\n    /**\n     * Filter by specific thread IDs.\n     */\n    ids?: string[];\n    /**\n     * Maximum number of threads to return.\n     * Defaults to 10\n     */\n    limit?: number;\n    /**\n     * Offset to start from.\n     */\n    offset?: number;\n    /**\n     * Thread status to filter on.\n     */\n    status?: ThreadStatus;\n    /**\n     * Sort by.\n     */\n    sortBy?: ThreadSortBy;\n    /**\n     * Sort order.\n     * Must be one of 'asc' or 'desc'.\n     */\n    sortOrder?: SortOrder;\n    /**\n     * Array of fields to select.\n     * Elements or array must be one of 'thread_id, 'created_at', 'updated_at', 'metadata', 'config', 'context', 'status', 'values', or 'interrupts'.\n     */\n    select?: ThreadSelectField[];\n    /**\n     * Values to filter threads by.\n     */\n    values?: ThreadValuesFilter;\n\n    /**\n     * Signal to abort the request.\n     */\n    signal?: AbortSignal;\n  }): Promise<Thread<ValuesType>[]> {\n    return this.fetch<Thread<ValuesType>[]>(\"/threads/search\", {\n      method: \"POST\",\n      json: {\n        metadata: query?.metadata ?? undefined,\n        ids: query?.ids ?? undefined,\n        limit: query?.limit ?? 10,\n        offset: query?.offset ?? 0,\n        status: query?.status,\n        sort_by: query?.sortBy,\n        sort_order: query?.sortOrder,\n        select: query?.select ?? undefined,\n        values: query?.values ?? undefined,\n      },\n      signal: query?.signal,\n    });\n  }\n\n  /**\n   * Count threads matching filters.\n   *\n   * @param query.metadata Thread metadata to filter on.\n   * @param query.values State values to filter on.\n   * @param query.status Thread status to filter on.\n   * @returns Number of threads matching the criteria.\n   */\n  async count<ValuesType = TStateType>(query?: {\n    metadata?: Metadata;\n    values?: ValuesType;\n    status?: ThreadStatus;\n    signal?: AbortSignal;\n  }): Promise<number> {\n    return this.fetch<number>(`/threads/count`, {\n      method: \"POST\",\n      json: {\n        metadata: query?.metadata ?? undefined,\n        values: query?.values ?? undefined,\n        status: query?.status ?? undefined,\n      },\n      signal: query?.signal,\n    });\n  }\n\n  /**\n   * Get state for a thread.\n   *\n   * @param threadId ID of the thread.\n   * @returns Thread state.\n   */\n  async getState<ValuesType = TStateType>(\n    threadId: string,\n    checkpoint?: Checkpoint | string,\n    options?: { subgraphs?: boolean; signal?: AbortSignal }\n  ): Promise<ThreadState<ValuesType>> {\n    if (checkpoint != null) {\n      if (typeof checkpoint !== \"string\") {\n        return this.fetch<ThreadState<ValuesType>>(\n          `/threads/${threadId}/state/checkpoint`,\n          {\n            method: \"POST\",\n            json: { checkpoint, subgraphs: options?.subgraphs },\n            signal: options?.signal,\n          }\n        );\n      }\n\n      // deprecated\n      return this.fetch<ThreadState<ValuesType>>(\n        `/threads/${threadId}/state/${checkpoint}`,\n        { params: { subgraphs: options?.subgraphs }, signal: options?.signal }\n      );\n    }\n\n    return this.fetch<ThreadState<ValuesType>>(`/threads/${threadId}/state`, {\n      params: { subgraphs: options?.subgraphs },\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * Add state to a thread.\n   *\n   * @param threadId The ID of the thread.\n   * @returns\n   */\n  async updateState<ValuesType = TUpdateType>(\n    threadId: string,\n    options: {\n      values: ValuesType;\n      checkpoint?: Checkpoint;\n      checkpointId?: string;\n      asNode?: string;\n      signal?: AbortSignal;\n    }\n  ): Promise<Pick<Config, \"configurable\">> {\n    return this.fetch<Pick<Config, \"configurable\">>(\n      `/threads/${threadId}/state`,\n      {\n        method: \"POST\",\n        json: {\n          values: options.values,\n          checkpoint_id: options.checkpointId,\n          checkpoint: options.checkpoint,\n          as_node: options?.asNode,\n        },\n        signal: options?.signal,\n      }\n    );\n  }\n\n  /**\n   * Patch the metadata of a thread.\n   *\n   * @param threadIdOrConfig Thread ID or config to patch the state of.\n   * @param metadata Metadata to patch the state with.\n   */\n  async patchState(\n    threadIdOrConfig: string | Config,\n    metadata: Metadata,\n    options?: { signal?: AbortSignal }\n  ): Promise<void> {\n    let threadId: string;\n\n    if (typeof threadIdOrConfig !== \"string\") {\n      if (typeof threadIdOrConfig.configurable?.thread_id !== \"string\") {\n        throw new Error(\n          \"Thread ID is required when updating state with a config.\"\n        );\n      }\n      threadId = threadIdOrConfig.configurable.thread_id;\n    } else {\n      threadId = threadIdOrConfig;\n    }\n\n    return this.fetch<void>(`/threads/${threadId}/state`, {\n      method: \"PATCH\",\n      json: { metadata },\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * Get all past states for a thread.\n   *\n   * @param threadId ID of the thread.\n   * @param options Additional options.\n   * @returns List of thread states.\n   */\n  async getHistory<ValuesType = TStateType>(\n    threadId: string,\n    options?: {\n      limit?: number;\n      before?: Config;\n      checkpoint?: Partial<Omit<Checkpoint, \"thread_id\">>;\n      metadata?: Metadata;\n      signal?: AbortSignal;\n    }\n  ): Promise<ThreadState<ValuesType>[]> {\n    return this.fetch<ThreadState<ValuesType>[]>(\n      `/threads/${threadId}/history`,\n      {\n        method: \"POST\",\n        json: {\n          limit: options?.limit ?? 10,\n          before: options?.before,\n          metadata: options?.metadata,\n          checkpoint: options?.checkpoint,\n        },\n        signal: options?.signal,\n      }\n    );\n  }\n\n  async *joinStream(\n    threadId: string,\n    options?: {\n      lastEventId?: string;\n      streamMode?: ThreadStreamMode | ThreadStreamMode[];\n      signal?: AbortSignal;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): AsyncGenerator<{ id?: string; event: StreamEvent; data: any }> {\n    yield* this.streamWithRetry({\n      endpoint: `/threads/${threadId}/stream`,\n      method: \"GET\",\n      signal: options?.signal,\n      headers: options?.lastEventId\n        ? { \"Last-Event-ID\": options.lastEventId }\n        : undefined,\n      params: options?.streamMode\n        ? { stream_mode: options.streamMode }\n        : undefined,\n    });\n  }\n}\n\nexport class RunsClient<\n  TStateType = DefaultValues,\n  TUpdateType = TStateType,\n  TCustomEventType = unknown\n> extends BaseClient {\n  stream<\n    TStreamMode extends StreamMode | StreamMode[] = StreamMode,\n    TSubgraphs extends boolean = false\n  >(\n    threadId: null,\n    assistantId: string,\n    payload?: Omit<\n      RunsStreamPayload<TStreamMode, TSubgraphs>,\n      \"multitaskStrategy\" | \"onCompletion\"\n    >\n  ): TypedAsyncGenerator<\n    TStreamMode,\n    TSubgraphs,\n    TStateType,\n    TUpdateType,\n    TCustomEventType\n  >;\n\n  stream<\n    TStreamMode extends StreamMode | StreamMode[] = StreamMode,\n    TSubgraphs extends boolean = false\n  >(\n    threadId: string,\n    assistantId: string,\n    payload?: RunsStreamPayload<TStreamMode, TSubgraphs>\n  ): TypedAsyncGenerator<\n    TStreamMode,\n    TSubgraphs,\n    TStateType,\n    TUpdateType,\n    TCustomEventType\n  >;\n\n  /**\n   * Create a run and stream the results.\n   *\n   * @param threadId The ID of the thread.\n   * @param assistantId Assistant ID to use for this run.\n   * @param payload Payload for creating a run.\n   */\n  async *stream<\n    TStreamMode extends StreamMode | StreamMode[] = StreamMode,\n    TSubgraphs extends boolean = false\n  >(\n    threadId: string | null,\n    assistantId: string,\n    payload?: RunsStreamPayload<TStreamMode, TSubgraphs>\n  ): TypedAsyncGenerator<\n    TStreamMode,\n    TSubgraphs,\n    TStateType,\n    TUpdateType,\n    TCustomEventType\n  > {\n    const json: Record<string, unknown> = {\n      input: payload?.input,\n      command: payload?.command,\n      config: payload?.config,\n      context: payload?.context,\n      metadata: payload?.metadata,\n      stream_mode: payload?.streamMode,\n      stream_subgraphs: payload?.streamSubgraphs,\n      stream_resumable: payload?.streamResumable,\n      feedback_keys: payload?.feedbackKeys,\n      assistant_id: assistantId,\n      interrupt_before: payload?.interruptBefore,\n      interrupt_after: payload?.interruptAfter,\n      checkpoint: payload?.checkpoint,\n      checkpoint_id: payload?.checkpointId,\n      webhook: payload?.webhook,\n      multitask_strategy: payload?.multitaskStrategy,\n      on_completion: payload?.onCompletion,\n      on_disconnect: payload?.onDisconnect,\n      after_seconds: payload?.afterSeconds,\n      if_not_exists: payload?.ifNotExists,\n      checkpoint_during: payload?.checkpointDuring,\n      durability: payload?.durability,\n    };\n\n    yield* this.streamWithRetry({\n      endpoint:\n        threadId == null ? `/runs/stream` : `/threads/${threadId}/runs/stream`,\n      method: \"POST\",\n      json,\n      signal: payload?.signal,\n      onInitialResponse: (response) => {\n        const runMetadata = getRunMetadataFromResponse(response);\n        if (runMetadata) payload?.onRunCreated?.(runMetadata);\n      },\n    }) as TypedAsyncGenerator<\n      TStreamMode,\n      TSubgraphs,\n      TStateType,\n      TUpdateType,\n      TCustomEventType\n    >;\n  }\n\n  /**\n   * Create a run.\n   *\n   * @param threadId The ID of the thread.\n   * @param assistantId Assistant ID to use for this run.\n   * @param payload Payload for creating a run.\n   * @returns The created run.\n   */\n  async create(\n    threadId: string | null,\n    assistantId: string,\n    payload?: RunsCreatePayload\n  ): Promise<Run> {\n    const json: Record<string, unknown> = {\n      input: payload?.input,\n      command: payload?.command,\n      config: payload?.config,\n      context: payload?.context,\n      metadata: payload?.metadata,\n      stream_mode: payload?.streamMode,\n      stream_subgraphs: payload?.streamSubgraphs,\n      stream_resumable: payload?.streamResumable,\n      assistant_id: assistantId,\n      interrupt_before: payload?.interruptBefore,\n      interrupt_after: payload?.interruptAfter,\n      webhook: payload?.webhook,\n      checkpoint: payload?.checkpoint,\n      checkpoint_id: payload?.checkpointId,\n      multitask_strategy: payload?.multitaskStrategy,\n      after_seconds: payload?.afterSeconds,\n      if_not_exists: payload?.ifNotExists,\n      checkpoint_during: payload?.checkpointDuring,\n      durability: payload?.durability,\n      langsmith_tracer: payload?._langsmithTracer\n        ? {\n            project_name: payload?._langsmithTracer?.projectName,\n            example_id: payload?._langsmithTracer?.exampleId,\n          }\n        : undefined,\n    };\n\n    const endpoint = threadId === null ? \"/runs\" : `/threads/${threadId}/runs`;\n    const [run, response] = await this.fetch<Run>(endpoint, {\n      method: \"POST\",\n      json,\n      signal: payload?.signal,\n      withResponse: true,\n    });\n\n    const runMetadata = getRunMetadataFromResponse(response);\n    if (runMetadata) payload?.onRunCreated?.(runMetadata);\n\n    return run;\n  }\n\n  /**\n   * Create a batch of stateless background runs.\n   *\n   * @param payloads An array of payloads for creating runs.\n   * @returns An array of created runs.\n   */\n  async createBatch(\n    payloads: (Omit<RunsCreatePayload, \"signal\"> & { assistantId: string })[],\n    options?: { signal?: AbortSignal }\n  ): Promise<Run[]> {\n    const filteredPayloads = payloads\n      .map((payload) => ({ ...payload, assistant_id: payload.assistantId }))\n      .map((payload) => {\n        return Object.fromEntries(\n          Object.entries(payload).filter(([_, v]) => v !== undefined)\n        );\n      });\n\n    return this.fetch<Run[]>(\"/runs/batch\", {\n      method: \"POST\",\n      json: filteredPayloads,\n      signal: options?.signal,\n    });\n  }\n\n  async wait(\n    threadId: null,\n    assistantId: string,\n    payload?: Omit<RunsWaitPayload, \"multitaskStrategy\" | \"onCompletion\">\n  ): Promise<ThreadState[\"values\"]>;\n\n  async wait(\n    threadId: string,\n    assistantId: string,\n    payload?: RunsWaitPayload\n  ): Promise<ThreadState[\"values\"]>;\n\n  /**\n   * Create a run and wait for it to complete.\n   *\n   * @param threadId The ID of the thread.\n   * @param assistantId Assistant ID to use for this run.\n   * @param payload Payload for creating a run.\n   * @returns The last values chunk of the thread.\n   */\n  async wait(\n    threadId: string | null,\n    assistantId: string,\n    payload?: RunsWaitPayload\n  ): Promise<ThreadState[\"values\"]> {\n    const json: Record<string, unknown> = {\n      input: payload?.input,\n      command: payload?.command,\n      config: payload?.config,\n      context: payload?.context,\n      metadata: payload?.metadata,\n      assistant_id: assistantId,\n      interrupt_before: payload?.interruptBefore,\n      interrupt_after: payload?.interruptAfter,\n      checkpoint: payload?.checkpoint,\n      checkpoint_id: payload?.checkpointId,\n      webhook: payload?.webhook,\n      multitask_strategy: payload?.multitaskStrategy,\n      on_completion: payload?.onCompletion,\n      on_disconnect: payload?.onDisconnect,\n      after_seconds: payload?.afterSeconds,\n      if_not_exists: payload?.ifNotExists,\n      checkpoint_during: payload?.checkpointDuring,\n      durability: payload?.durability,\n      langsmith_tracer: payload?._langsmithTracer\n        ? {\n            project_name: payload?._langsmithTracer?.projectName,\n            example_id: payload?._langsmithTracer?.exampleId,\n          }\n        : undefined,\n    };\n    const endpoint =\n      threadId == null ? `/runs/wait` : `/threads/${threadId}/runs/wait`;\n    const [run, response] = await this.fetch<ThreadState[\"values\"]>(endpoint, {\n      method: \"POST\",\n      json,\n      timeoutMs: null,\n      signal: payload?.signal,\n      withResponse: true,\n    });\n\n    const runMetadata = getRunMetadataFromResponse(response);\n    if (runMetadata) payload?.onRunCreated?.(runMetadata);\n\n    const raiseError =\n      payload?.raiseError !== undefined ? payload.raiseError : true;\n    if (\n      raiseError &&\n      \"__error__\" in run &&\n      typeof run.__error__ === \"object\" &&\n      run.__error__ &&\n      \"error\" in run.__error__ &&\n      \"message\" in run.__error__\n    ) {\n      throw new Error(`${run.__error__?.error}: ${run.__error__?.message}`);\n    }\n    return run;\n  }\n\n  /**\n   * List all runs for a thread.\n   *\n   * @param threadId The ID of the thread.\n   * @param options Filtering and pagination options.\n   * @returns List of runs.\n   */\n  async list(\n    threadId: string,\n    options?: {\n      /**\n       * Maximum number of runs to return.\n       * Defaults to 10\n       */\n      limit?: number;\n\n      /**\n       * Offset to start from.\n       * Defaults to 0.\n       */\n      offset?: number;\n\n      /**\n       * Status of the run to filter by.\n       */\n      status?: RunStatus;\n      select?: RunSelectField[];\n\n      /**\n       * Signal to abort the request.\n       */\n      signal?: AbortSignal;\n    }\n  ): Promise<Run[]> {\n    return this.fetch<Run[]>(`/threads/${threadId}/runs`, {\n      params: {\n        limit: options?.limit ?? 10,\n        offset: options?.offset ?? 0,\n        status: options?.status ?? undefined,\n        select: options?.select ?? undefined,\n      },\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * Get a run by ID.\n   *\n   * @param threadId The ID of the thread.\n   * @param runId The ID of the run.\n   * @returns The run.\n   */\n  async get(\n    threadId: string,\n    runId: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<Run> {\n    return this.fetch<Run>(`/threads/${threadId}/runs/${runId}`, {\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * Cancel a run.\n   *\n   * @param threadId The ID of the thread.\n   * @param runId The ID of the run.\n   * @param wait Whether to block when canceling\n   * @param action Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. Default is `interrupt`.\n   * @returns\n   */\n  async cancel(\n    threadId: string,\n    runId: string,\n    wait: boolean = false,\n    action: CancelAction = \"interrupt\",\n    options: { signal?: AbortSignal } = {}\n  ): Promise<void> {\n    return this.fetch<void>(`/threads/${threadId}/runs/${runId}/cancel`, {\n      method: \"POST\",\n      params: { wait: wait ? \"1\" : \"0\", action },\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * Block until a run is done.\n   *\n   * @param threadId The ID of the thread.\n   * @param runId The ID of the run.\n   * @returns\n   */\n  async join(\n    threadId: string,\n    runId: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<TStateType> {\n    return this.fetch<TStateType>(`/threads/${threadId}/runs/${runId}/join`, {\n      timeoutMs: null,\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * Stream output from a run in real-time, until the run is done.\n   *\n   * @param threadId The ID of the thread. Can be set to `null` | `undefined` for stateless runs.\n   * @param runId The ID of the run.\n   * @param options Additional options for controlling the stream behavior:\n   *   - signal: An AbortSignal that can be used to cancel the stream request\n   *   - lastEventId: The ID of the last event received. Can be used to reconnect to a stream without losing events.\n   *   - cancelOnDisconnect: When true, automatically cancels the run if the client disconnects from the stream\n   *   - streamMode: Controls what types of events to receive from the stream (can be a single mode or array of modes)\n   *        Must be a subset of the stream modes passed when creating the run. Background runs default to having the union of all\n   *        stream modes enabled.\n   * @returns An async generator yielding stream parts.\n   */\n  async *joinStream(\n    threadId: string | undefined | null,\n    runId: string,\n    options?:\n      | {\n          signal?: AbortSignal;\n          cancelOnDisconnect?: boolean;\n          lastEventId?: string;\n          streamMode?: StreamMode | StreamMode[];\n        }\n      | AbortSignal\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): AsyncGenerator<{ id?: string; event: StreamEvent; data: any }> {\n    const opts =\n      typeof options === \"object\" &&\n      options != null &&\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      options instanceof AbortSignal\n        ? { signal: options }\n        : options;\n\n    yield* this.streamWithRetry({\n      endpoint:\n        threadId != null\n          ? `/threads/${threadId}/runs/${runId}/stream`\n          : `/runs/${runId}/stream`,\n      method: \"GET\",\n      signal: opts?.signal,\n      headers: opts?.lastEventId\n        ? { \"Last-Event-ID\": opts.lastEventId }\n        : undefined,\n      params: {\n        cancel_on_disconnect: opts?.cancelOnDisconnect ? \"1\" : \"0\",\n        stream_mode: opts?.streamMode,\n      },\n    });\n  }\n\n  /**\n   * Delete a run.\n   *\n   * @param threadId The ID of the thread.\n   * @param runId The ID of the run.\n   * @returns\n   */\n  async delete(\n    threadId: string,\n    runId: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<void> {\n    return this.fetch<void>(`/threads/${threadId}/runs/${runId}`, {\n      method: \"DELETE\",\n      signal: options?.signal,\n    });\n  }\n}\n\ninterface APIItem {\n  namespace: string[];\n  key: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  value: Record<string, any>;\n  created_at: string;\n  updated_at: string;\n}\ninterface APISearchItemsResponse {\n  items: APIItem[];\n}\n\nexport class StoreClient extends BaseClient {\n  /**\n   * Store or update an item.\n   *\n   * @param namespace A list of strings representing the namespace path.\n   * @param key The unique identifier for the item within the namespace.\n   * @param value A dictionary containing the item's data.\n   * @param options.index Controls search indexing - null (use defaults), false (disable), or list of field paths to index.\n   * @param options.ttl Optional time-to-live in minutes for the item, or null for no expiration.\n   * @returns Promise<void>\n   *\n   * @example\n   * ```typescript\n   * await client.store.putItem(\n   *   [\"documents\", \"user123\"],\n   *   \"item456\",\n   *   { title: \"My Document\", content: \"Hello World\" },\n   *   { ttl: 60 } // expires in 60 minutes\n   * );\n   * ```\n   */\n  async putItem(\n    namespace: string[],\n    key: string,\n    value: Record<string, unknown>,\n    options?: {\n      index?: false | string[] | null;\n      ttl?: number | null;\n      signal?: AbortSignal;\n    }\n  ): Promise<void> {\n    namespace.forEach((label) => {\n      if (label.includes(\".\")) {\n        throw new Error(\n          `Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`\n        );\n      }\n    });\n\n    const payload = {\n      namespace,\n      key,\n      value,\n      index: options?.index,\n      ttl: options?.ttl,\n    };\n\n    return this.fetch<void>(\"/store/items\", {\n      method: \"PUT\",\n      json: payload,\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * Retrieve a single item.\n   *\n   * @param namespace A list of strings representing the namespace path.\n   * @param key The unique identifier for the item.\n   * @param options.refreshTtl Whether to refresh the TTL on this read operation. If null, uses the store's default behavior.\n   * @returns Promise<Item>\n   *\n   * @example\n   * ```typescript\n   * const item = await client.store.getItem(\n   *   [\"documents\", \"user123\"],\n   *   \"item456\",\n   *   { refreshTtl: true }\n   * );\n   * console.log(item);\n   * // {\n   * //   namespace: [\"documents\", \"user123\"],\n   * //   key: \"item456\",\n   * //   value: { title: \"My Document\", content: \"Hello World\" },\n   * //   createdAt: \"2024-07-30T12:00:00Z\",\n   * //   updatedAt: \"2024-07-30T12:00:00Z\"\n   * // }\n   * ```\n   */\n  async getItem(\n    namespace: string[],\n    key: string,\n    options?: {\n      refreshTtl?: boolean | null;\n      signal?: AbortSignal;\n    }\n  ): Promise<Item | null> {\n    namespace.forEach((label) => {\n      if (label.includes(\".\")) {\n        throw new Error(\n          `Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`\n        );\n      }\n    });\n\n    const params: Record<string, unknown> = {\n      namespace: namespace.join(\".\"),\n      key,\n    };\n\n    if (options?.refreshTtl !== undefined) {\n      params.refresh_ttl = options.refreshTtl;\n    }\n\n    const response = await this.fetch<APIItem>(\"/store/items\", {\n      params,\n      signal: options?.signal,\n    });\n\n    return response\n      ? {\n          ...response,\n          createdAt: response.created_at,\n          updatedAt: response.updated_at,\n        }\n      : null;\n  }\n\n  /**\n   * Delete an item.\n   *\n   * @param namespace A list of strings representing the namespace path.\n   * @param key The unique identifier for the item.\n   * @returns Promise<void>\n   */\n  async deleteItem(\n    namespace: string[],\n    key: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<void> {\n    namespace.forEach((label) => {\n      if (label.includes(\".\")) {\n        throw new Error(\n          `Invalid namespace label '${label}'. Namespace labels cannot contain periods ('.')`\n        );\n      }\n    });\n\n    return this.fetch<void>(\"/store/items\", {\n      method: \"DELETE\",\n      json: { namespace, key },\n      signal: options?.signal,\n    });\n  }\n\n  /**\n   * Search for items within a namespace prefix.\n   *\n   * @param namespacePrefix List of strings representing the namespace prefix.\n   * @param options.filter Optional dictionary of key-value pairs to filter results.\n   * @param options.limit Maximum number of items to return (default is 10).\n   * @param options.offset Number of items to skip before returning results (default is 0).\n   * @param options.query Optional search query.\n   * @param options.refreshTtl Whether to refresh the TTL on items returned by this search. If null, uses the store's default behavior.\n   * @returns Promise<SearchItemsResponse>\n   *\n   * @example\n   * ```typescript\n   * const results = await client.store.searchItems(\n   *   [\"documents\"],\n   *   {\n   *     filter: { author: \"John Doe\" },\n   *     limit: 5,\n   *     refreshTtl: true\n   *   }\n   * );\n   * console.log(results);\n   * // {\n   * //   items: [\n   * //     {\n   * //       namespace: [\"documents\", \"user123\"],\n   * //       key: \"item789\",\n   * //       value: { title: \"Another Document\", author: \"John Doe\" },\n   * //       createdAt: \"2024-07-30T12:00:00Z\",\n   * //       updatedAt: \"2024-07-30T12:00:00Z\"\n   * //     },\n   * //     // ... additional items ...\n   * //   ]\n   * // }\n   * ```\n   */\n  async searchItems(\n    namespacePrefix: string[],\n    options?: {\n      filter?: Record<string, unknown>;\n      limit?: number;\n      offset?: number;\n      query?: string;\n      refreshTtl?: boolean | null;\n      signal?: AbortSignal;\n    }\n  ): Promise<SearchItemsResponse> {\n    const payload = {\n      namespace_prefix: namespacePrefix,\n      filter: options?.filter,\n      limit: options?.limit ?? 10,\n      offset: options?.offset ?? 0,\n      query: options?.query,\n      refresh_ttl: options?.refreshTtl,\n    };\n\n    const response = await this.fetch<APISearchItemsResponse>(\n      \"/store/items/search\",\n      {\n        method: \"POST\",\n        json: payload,\n        signal: options?.signal,\n      }\n    );\n    return {\n      items: response.items.map((item) => ({\n        ...item,\n        createdAt: item.created_at,\n        updatedAt: item.updated_at,\n      })),\n    };\n  }\n\n  /**\n   * List namespaces with optional match conditions.\n   *\n   * @param options.prefix Optional list of strings representing the prefix to filter namespaces.\n   * @param options.suffix Optional list of strings representing the suffix to filter namespaces.\n   * @param options.maxDepth Optional integer specifying the maximum depth of namespaces to return.\n   * @param options.limit Maximum number of namespaces to return (default is 100).\n   * @param options.offset Number of namespaces to skip before returning results (default is 0).\n   * @returns Promise<ListNamespaceResponse>\n   */\n  async listNamespaces(options?: {\n    prefix?: string[];\n    suffix?: string[];\n    maxDepth?: number;\n    limit?: number;\n    offset?: number;\n    signal?: AbortSignal;\n  }): Promise<ListNamespaceResponse> {\n    const payload = {\n      prefix: options?.prefix,\n      suffix: options?.suffix,\n      max_depth: options?.maxDepth,\n      limit: options?.limit ?? 100,\n      offset: options?.offset ?? 0,\n    };\n\n    return this.fetch<ListNamespaceResponse>(\"/store/namespaces\", {\n      method: \"POST\",\n      json: payload,\n      signal: options?.signal,\n    });\n  }\n}\n\nclass UiClient extends BaseClient {\n  private static promiseCache: Record<string, Promise<unknown> | undefined> =\n    {};\n\n  private static getOrCached<T>(key: string, fn: () => Promise<T>): Promise<T> {\n    if (UiClient.promiseCache[key] != null) {\n      return UiClient.promiseCache[key] as Promise<T>;\n    }\n\n    const promise = fn();\n    UiClient.promiseCache[key] = promise;\n    return promise;\n  }\n\n  async getComponent(assistantId: string, agentName: string): Promise<string> {\n    return UiClient.getOrCached(\n      `${this.apiUrl}-${assistantId}-${agentName}`,\n      async () => {\n        let [url, init] = this.prepareFetchOptions(`/ui/${assistantId}`, {\n          headers: {\n            Accept: \"text/html\",\n            \"Content-Type\": \"application/json\",\n          },\n          method: \"POST\",\n          json: { name: agentName },\n        });\n        if (this.onRequest != null) init = await this.onRequest(url, init);\n\n        const response = await this.asyncCaller.fetch(url, init);\n        return response.text();\n      }\n    );\n  }\n}\n\nexport class Client<\n  TStateType = DefaultValues,\n  TUpdateType = TStateType,\n  TCustomEventType = unknown\n> {\n  /**\n   * The client for interacting with assistants.\n   */\n  public assistants: AssistantsClient;\n\n  /**\n   * The client for interacting with threads.\n   */\n  public threads: ThreadsClient<TStateType, TUpdateType>;\n\n  /**\n   * The client for interacting with runs.\n   */\n  public runs: RunsClient<TStateType, TUpdateType, TCustomEventType>;\n\n  /**\n   * The client for interacting with cron runs.\n   */\n  public crons: CronsClient;\n\n  /**\n   * The client for interacting with the KV store.\n   */\n  public store: StoreClient;\n\n  /**\n   * The client for interacting with the UI.\n   * @internal Used by LoadExternalComponent and the API might change in the future.\n   */\n  public \"~ui\": UiClient;\n\n  /**\n   * @internal Used to obtain a stable key representing the client.\n   */\n  private \"~configHash\": string | undefined;\n\n  constructor(config?: ClientConfig) {\n    this[\"~configHash\"] = (() =>\n      JSON.stringify({\n        apiUrl: config?.apiUrl,\n        apiKey: config?.apiKey,\n        timeoutMs: config?.timeoutMs,\n        defaultHeaders: config?.defaultHeaders,\n\n        maxConcurrency: config?.callerOptions?.maxConcurrency,\n        maxRetries: config?.callerOptions?.maxRetries,\n\n        callbacks: {\n          onFailedResponseHook:\n            config?.callerOptions?.onFailedResponseHook != null,\n          onRequest: config?.onRequest != null,\n          fetch: config?.callerOptions?.fetch != null,\n        },\n      }))();\n\n    this.assistants = new AssistantsClient(config);\n    this.threads = new ThreadsClient(config);\n    this.runs = new RunsClient(config);\n    this.crons = new CronsClient(config);\n    this.store = new StoreClient(config);\n    this[\"~ui\"] = new UiClient(config);\n  }\n}\n\n/**\n * @internal Used to obtain a stable key representing the client.\n */\nexport function getClientConfigHash(client: Client): string | undefined {\n  return client[\"~configHash\"];\n}\n"],"mappings":"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"}