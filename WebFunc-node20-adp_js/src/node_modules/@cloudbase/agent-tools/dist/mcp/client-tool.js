"use strict";
/**
 * MCP Client Tool - Wraps MCP tools to work within AG-Kit's tool system
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.MCPClientTool = void 0;
const v4_1 = require("zod/v4");
const utils_1 = require("../utils");
const mcp_adapter_1 = require("./mcp-adapter");
/**
 * MCPClientTool wraps an external MCP tool to work within AG-Kit's tool system
 */
class MCPClientTool extends utils_1.BaseTool {
    constructor(mcpClient, mcpToolMetadata, config = {}, adapterConfig = {}) {
        // Workaround for MCP SDK not consistently providing properties
        // This ensures the schema always has a properties object
        const inputSchema = { ...mcpToolMetadata.inputSchema };
        if (!inputSchema.properties) {
            inputSchema.properties = {};
        }
        // Dereference $defs/$ref in the schema to support Pydantic v2 schemas
        // and other JSON schemas that use $defs for nested type definitions
        const dereferencedSchema = (0, mcp_adapter_1.dereferenceJsonSchema)(inputSchema);
        // Convert MCP input schema to zod schema for AG-Kit compatibility
        const zodSchema = MCPClientTool.convertMCPSchemaToZod(dereferencedSchema);
        super({
            name: config.name || mcpToolMetadata.name,
            description: config.description ||
                mcpToolMetadata.description ||
                `MCP tool: ${mcpToolMetadata.name}`,
            schema: zodSchema,
        });
        this.mcpClient = mcpClient;
        this.mcpToolMetadata = mcpToolMetadata;
        this.config = { timeout: 30000, retries: 1, ...config };
        this.adapterConfig = { includeMetadata: true, ...adapterConfig };
    }
    /**
     * Convert MCP JSON Schema to Zod schema with full recursive support
     * Handles nested objects, arrays, enums, and various JSON Schema features
     */
    static convertMCPSchemaToZod(mcpSchema) {
        return MCPClientTool.jsonSchemaToZod(mcpSchema, true);
    }
    /**
     * Recursively convert JSON Schema to Zod schema
     * @param jsonSchema - JSON Schema object
     * @param isRequired - Whether this field is required
     * @returns Zod schema
     */
    static jsonSchemaToZod(jsonSchema, isRequired) {
        if (!jsonSchema || typeof jsonSchema !== "object") {
            return isRequired ? v4_1.z.any() : v4_1.z.any().optional();
        }
        let zodType;
        switch (jsonSchema.type) {
            case "object": {
                const properties = jsonSchema.properties || {};
                const required = Array.isArray(jsonSchema.required)
                    ? jsonSchema.required
                    : [];
                // Handle empty object
                if (Object.keys(properties).length === 0) {
                    zodType = v4_1.z.record(v4_1.z.string(), v4_1.z.any());
                }
                else {
                    const shape = {};
                    for (const [key, propSchema] of Object.entries(properties)) {
                        const isPropRequired = required.includes(key);
                        shape[key] = MCPClientTool.jsonSchemaToZod(propSchema, isPropRequired);
                    }
                    zodType = v4_1.z.object(shape);
                }
                break;
            }
            case "array": {
                if (jsonSchema.items) {
                    const itemSchema = MCPClientTool.jsonSchemaToZod(jsonSchema.items, true);
                    zodType = v4_1.z.array(itemSchema);
                }
                else {
                    zodType = v4_1.z.array(v4_1.z.any());
                }
                // Handle array constraints
                if (jsonSchema.minItems !== undefined) {
                    zodType = zodType.min(jsonSchema.minItems);
                }
                if (jsonSchema.maxItems !== undefined) {
                    zodType = zodType.max(jsonSchema.maxItems);
                }
                break;
            }
            case "string": {
                // Handle enum first (before creating string type)
                if (Array.isArray(jsonSchema.enum) && jsonSchema.enum.length > 0) {
                    zodType = v4_1.z.enum(jsonSchema.enum);
                }
                else {
                    zodType = v4_1.z.string();
                    // Handle string constraints
                    if (jsonSchema.minLength !== undefined) {
                        zodType = zodType.min(jsonSchema.minLength);
                    }
                    if (jsonSchema.maxLength !== undefined) {
                        zodType = zodType.max(jsonSchema.maxLength);
                    }
                    if (jsonSchema.pattern) {
                        zodType = zodType.regex(new RegExp(jsonSchema.pattern));
                    }
                    // Handle format
                    if (jsonSchema.format === "email") {
                        zodType = zodType.email();
                    }
                    else if (jsonSchema.format === "url") {
                        zodType = zodType.url();
                    }
                    else if (jsonSchema.format === "uuid") {
                        zodType = zodType.uuid();
                    }
                }
                break;
            }
            case "number":
            case "integer": {
                zodType =
                    jsonSchema.type === "integer" ? v4_1.z.number().int() : v4_1.z.number();
                // Handle numeric constraints
                if (jsonSchema.minimum !== undefined) {
                    zodType = zodType.min(jsonSchema.minimum);
                }
                if (jsonSchema.maximum !== undefined) {
                    zodType = zodType.max(jsonSchema.maximum);
                }
                if (jsonSchema.exclusiveMinimum !== undefined) {
                    zodType = zodType.gt(jsonSchema.exclusiveMinimum);
                }
                if (jsonSchema.exclusiveMaximum !== undefined) {
                    zodType = zodType.lt(jsonSchema.exclusiveMaximum);
                }
                if (jsonSchema.multipleOf !== undefined) {
                    zodType = zodType.multipleOf(jsonSchema.multipleOf);
                }
                break;
            }
            case "boolean": {
                zodType = v4_1.z.boolean();
                break;
            }
            case "null": {
                zodType = v4_1.z.null();
                break;
            }
            default: {
                // Handle anyOf, oneOf, allOf
                if (Array.isArray(jsonSchema.anyOf) && jsonSchema.anyOf.length > 0) {
                    const schemas = jsonSchema.anyOf.map((s) => MCPClientTool.jsonSchemaToZod(s, true));
                    zodType = v4_1.z.union(schemas);
                }
                else if (Array.isArray(jsonSchema.oneOf) &&
                    jsonSchema.oneOf.length > 0) {
                    const schemas = jsonSchema.oneOf.map((s) => MCPClientTool.jsonSchemaToZod(s, true));
                    zodType = v4_1.z.union(schemas);
                }
                else if (Array.isArray(jsonSchema.allOf) &&
                    jsonSchema.allOf.length > 0) {
                    // For allOf, we merge the schemas (simplified approach)
                    const schemas = jsonSchema.allOf.map((s) => MCPClientTool.jsonSchemaToZod(s, true));
                    zodType = v4_1.z.intersection(schemas[0], schemas[1]);
                    for (let i = 2; i < schemas.length; i++) {
                        zodType = v4_1.z.intersection(zodType, schemas[i]);
                    }
                }
                else {
                    // Fallback to any
                    zodType = v4_1.z.any();
                }
            }
        }
        // Add description if present (unified handling for all types)
        if (jsonSchema.description) {
            zodType = zodType.describe(jsonSchema.description);
        }
        // Handle default value
        if (jsonSchema.default !== undefined) {
            zodType = zodType.default(jsonSchema.default);
        }
        // Make optional if not required
        return isRequired ? zodType : zodType.optional();
    }
    /**
     * Execute the MCP tool
     */
    async _invoke(input, context) {
        const startTime = Date.now();
        try {
            // Transform input if configured
            const transformedInput = this.adapterConfig.transformInput
                ? this.adapterConfig.transformInput(input)
                : input;
            // Call the MCP tool with retry logic
            let lastError = null;
            let result = null;
            for (let attempt = 0; attempt <= this.config.retries; attempt++) {
                try {
                    // Create timeout promise
                    const timeoutPromise = new Promise((_, reject) => {
                        setTimeout(() => reject(new Error("MCP tool call timeout")), this.config.timeout);
                    });
                    // Call MCP tool
                    const callPromise = this.mcpClient.callTool({
                        name: this.mcpToolMetadata.name,
                        arguments: transformedInput,
                    });
                    result = (await Promise.race([
                        callPromise,
                        timeoutPromise,
                    ]));
                    break; // Success, exit retry loop
                }
                catch (error) {
                    lastError = error instanceof Error ? error : new Error(String(error));
                    if (attempt < this.config.retries) {
                        // Wait before retry
                        await new Promise((resolve) => setTimeout(resolve, 1000 * (attempt + 1)));
                    }
                }
            }
            if (!result) {
                throw lastError || new Error("MCP tool call failed after retries");
            }
            // Handle MCP error response
            if (result.isError) {
                const errorText = result.content
                    .filter((c) => c.type === "text")
                    .map((c) => c.text)
                    .join("\n");
                if (this.adapterConfig.errorHandler) {
                    return this.adapterConfig.errorHandler(new Error(errorText));
                }
                return (0, utils_1.handleToolError)(new Error(errorText), `MCP tool '${this.mcpToolMetadata.name}' execution`, "execution");
            }
            // Process successful result
            const textContent = result.content
                .filter((c) => c.type === "text")
                .map((c) => c.text)
                .join("\n");
            let processedOutput = textContent;
            // Try to parse JSON if it looks like JSON
            if (textContent.trim().startsWith("{") ||
                textContent.trim().startsWith("[")) {
                try {
                    processedOutput = JSON.parse(textContent);
                }
                catch {
                    // Keep as text if JSON parsing fails
                }
            }
            // Transform output if configured
            if (this.adapterConfig.transformOutput) {
                processedOutput = this.adapterConfig.transformOutput(processedOutput);
            }
            // Include metadata if configured
            const resultData = this.adapterConfig.includeMetadata
                ? {
                    output: processedOutput,
                    metadata: {
                        mcpTool: this.mcpToolMetadata.name,
                        executionTime: Date.now() - startTime,
                        contentTypes: result.content.map((c) => c.type),
                    },
                }
                : processedOutput;
            return new utils_1.ToolResult({
                success: true,
                data: resultData,
                executionTime: Date.now() - startTime,
            });
        }
        catch (error) {
            if (this.adapterConfig.errorHandler) {
                return this.adapterConfig.errorHandler(error instanceof Error ? error : new Error(String(error)));
            }
            return (0, utils_1.handleToolError)(error, `MCP tool '${this.mcpToolMetadata.name}' execution`, "execution", {
                mcpTool: this.mcpToolMetadata.name,
                input: input,
                executionTime: Date.now() - startTime,
            });
        }
    }
    /**
     * Get display information for the tool
     */
    getDisplay(params) {
        return `> Using MCP tool '${this.mcpToolMetadata.name}': ${JSON.stringify(params.input)}`;
    }
    /**
     * Get MCP-specific metadata
     */
    getMCPMetadata() {
        return { ...this.mcpToolMetadata };
    }
    /**
     * Get combined metadata (AG-Kit + MCP)
     */
    getMetadata() {
        const baseMetadata = super.getMetadata();
        return {
            ...baseMetadata,
            mcp: {
                originalName: this.mcpToolMetadata.name,
                originalDescription: this.mcpToolMetadata.description,
                inputSchema: this.mcpToolMetadata.inputSchema,
                config: this.config,
                adapterConfig: this.adapterConfig,
            },
        };
    }
    /**
     * Check if the MCP client is connected
     */
    isConnected() {
        // This would depend on the MCP client implementation
        return this.mcpClient && typeof this.mcpClient.callTool === "function";
    }
    /**
     * Update tool configuration
     */
    updateConfig(newConfig) {
        this.config = { ...this.config, ...newConfig };
    }
    /**
     * Update adapter configuration
     */
    updateAdapterConfig(newAdapterConfig) {
        this.adapterConfig = { ...this.adapterConfig, ...newAdapterConfig };
    }
}
exports.MCPClientTool = MCPClientTool;
//# sourceMappingURL=client-tool.js.map