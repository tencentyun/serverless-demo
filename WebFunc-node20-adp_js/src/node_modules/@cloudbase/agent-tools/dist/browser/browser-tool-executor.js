"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BrowserToolExecutor = void 0;
/**
 * Shared browser tool executor
 * Handles all Playwright operations regardless of connection method
 */
class BrowserToolExecutor {
    constructor(pageProvider) {
        this.pageProvider = pageProvider;
    }
    /**
     * Get list of available tools
     */
    listTools() {
        return [
            { name: 'browser_navigate', description: 'Navigate to a URL' },
            { name: 'browser_click', description: 'Click an element' },
            { name: 'browser_snapshot', description: 'Take a snapshot of the page' },
            { name: 'browser_type', description: 'Type text into an element' },
            { name: 'browser_take_screenshot', description: 'Take a screenshot' },
            { name: 'browser_wait_for', description: 'Wait for an element or condition' },
            { name: 'browser_tabs', description: 'Manage browser tabs' },
            { name: 'browser_fill_form', description: 'Fill a form' },
            { name: 'browser_evaluate', description: 'Execute JavaScript' },
            { name: 'browser_scroll', description: 'Scroll the page' },
            { name: 'browser_upload', description: 'Upload a file' },
            { name: 'browser_download', description: 'Download a file' },
        ];
    }
    /**
     * Execute a browser tool
     */
    async executeTool(toolCall) {
        try {
            const result = await this.executePlaywrightTool(toolCall);
            return {
                content: [{
                        type: 'text',
                        text: JSON.stringify(result, null, 2)
                    }],
                isError: false
            };
        }
        catch (error) {
            const errorMessage = error instanceof Error ? error.message : String(error);
            console.error(`Failed to execute tool ${toolCall.name}:`, error);
            return {
                content: [{
                        type: 'text',
                        text: `Error executing ${toolCall.name}: ${errorMessage}`
                    }],
                isError: true
            };
        }
    }
    /**
     * Execute Playwright tool operations
     */
    async executePlaywrightTool(toolCall) {
        const { name, arguments: args = {} } = toolCall;
        switch (name) {
            case 'browser_navigate': {
                const page = this.pageProvider.getPage(args.pageIndex || 0);
                await page.goto(args.url, {
                    timeout: args.timeout,
                    waitUntil: args.waitUntil || 'load',
                });
                return {
                    url: page.url(),
                    title: await page.title(),
                };
            }
            case 'browser_click': {
                const page = this.pageProvider.getPage(args.pageIndex || 0);
                await page.click(args.selector || args.element, { timeout: args.timeout });
                return { success: true };
            }
            case 'browser_type': {
                const page = this.pageProvider.getPage(args.pageIndex || 0);
                await page.fill(args.selector || args.element, args.text, { timeout: args.timeout });
                return { success: true };
            }
            case 'browser_take_screenshot':
            case 'browser_snapshot': {
                const page = this.pageProvider.getPage(args.pageIndex || 0);
                const screenshot = await page.screenshot({
                    fullPage: args.fullPage ?? true,
                    type: args.type || 'png',
                });
                return {
                    screenshot: screenshot.toString('base64'),
                    mimeType: 'image/png'
                };
            }
            case 'browser_wait_for': {
                if (args.selector) {
                    const page = this.pageProvider.getPage(args.pageIndex || 0);
                    await page.waitForSelector(args.selector, {
                        timeout: args.timeout,
                        state: args.state,
                    });
                }
                return { success: true };
            }
            case 'browser_tabs':
                return await this.handleTabsOperation(args);
            case 'browser_evaluate': {
                const page = this.pageProvider.getPage(args.pageIndex || 0);
                const result = await page.evaluate((js) => {
                    const func = new Function(js);
                    return func();
                }, args.script || args.javascript);
                return result;
            }
            case 'browser_scroll': {
                const page = this.pageProvider.getPage(args.pageIndex || 0);
                if (args.selector) {
                    await page.locator(args.selector).scrollIntoViewIfNeeded({ timeout: args.timeout });
                }
                else {
                    await page.evaluate(() => {
                        window.scrollTo(0, document.body.scrollHeight);
                    });
                }
                return { success: true };
            }
            case 'browser_upload': {
                const page = this.pageProvider.getPage(args.pageIndex || 0);
                await page.setInputFiles(args.selector, args.filePath, { timeout: args.timeout });
                return { success: true };
            }
            case 'browser_download': {
                const page = this.pageProvider.getPage(args.pageIndex || 0);
                const downloadPromise = page.waitForEvent('download', { timeout: args.timeout });
                if (args.selector) {
                    await page.click(args.selector);
                }
                const download = await downloadPromise;
                const downloadPath = `/tmp/${download.suggestedFilename()}`;
                await download.saveAs(downloadPath);
                return {
                    filePath: downloadPath,
                    filename: download.suggestedFilename(),
                };
            }
            case 'browser_fill_form': {
                if (args.fields && Array.isArray(args.fields)) {
                    const page = this.pageProvider.getPage(args.pageIndex || 0);
                    for (const field of args.fields) {
                        await page.fill(field.selector || field.element, field.value);
                    }
                }
                return { success: true };
            }
            default:
                throw new Error(`Unknown tool: ${name}`);
        }
    }
    /**
     * Handle tabs operations
     */
    async handleTabsOperation(args) {
        switch (args.action) {
            case 'list': {
                const pages = this.pageProvider.getPages();
                return {
                    tabs: pages.map((page, index) => ({
                        index,
                        url: page.url(),
                        title: page.isClosed() ? 'Closed' : 'Active'
                    }))
                };
            }
            case 'create': {
                const newPage = await this.pageProvider.createPage();
                if (args.url) {
                    await newPage.goto(args.url);
                }
                return {
                    success: true,
                    pageIndex: this.pageProvider.getPages().length - 1
                };
            }
            case 'close': {
                if (typeof args.index === 'number') {
                    await this.pageProvider.closePage(args.index);
                }
                return { success: true };
            }
            case 'select': {
                // Note: Playwright doesn't have a direct "select tab" concept
                // The pageIndex parameter in other operations handles this
                return {
                    success: true,
                    message: 'Use pageIndex parameter in other operations to target specific tabs'
                };
            }
            default:
                throw new Error(`Unknown tabs action: ${args.action}`);
        }
    }
}
exports.BrowserToolExecutor = BrowserToolExecutor;
//# sourceMappingURL=browser-tool-executor.js.map