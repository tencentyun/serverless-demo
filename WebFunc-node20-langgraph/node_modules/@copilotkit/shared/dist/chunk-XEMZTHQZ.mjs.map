{"version":3,"sources":["../src/utils/requests.ts"],"sourcesContent":["/**\n * Safely read a Response/Request body with sensible defaults:\n * - clones the response/request to avoid consuming the original response/request\n * - Skips GET/HEAD\n * - Tries JSON first regardless of content-type\n * - Falls back to text and optionally parses when it \"looks\" like JSON\n */\nexport async function readBody<T extends Response | Request>(r: T): Promise<unknown> {\n  // skip GET/HEAD requests (unchanged)\n  const method = \"method\" in r ? r.method.toUpperCase() : undefined;\n  if (method === \"GET\" || method === \"HEAD\") {\n    return undefined;\n  }\n\n  // no body at all â†’ undefined (unchanged)\n  if (!(\"body\" in r) || r.body == null) {\n    return undefined;\n  }\n\n  // 1) try JSON (unchanged)\n  try {\n    return await r.clone().json();\n  } catch {\n    // 2) try text (unchanged + your whitespace/JSON-heuristic)\n    try {\n      const text = await r.clone().text();\n      const trimmed = text.trim();\n\n      if (trimmed.length === 0) return text;\n\n      if (trimmed.startsWith(\"{\") || trimmed.startsWith(\"[\")) {\n        try {\n          return JSON.parse(trimmed);\n        } catch {\n          return text;\n        }\n      }\n      return text;\n    } catch {\n      // 3) FINAL FALLBACK: manual read that accepts string or bytes\n      try {\n        const c = r.clone();\n        const stream: ReadableStream | null = c.body ?? null;\n        if (!stream) return undefined;\n\n        const reader = stream.getReader();\n        const decoder = new TextDecoder();\n        let out = \"\";\n\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n          if (typeof value === \"string\") {\n            out += value; // accept string chunks\n          } else {\n            out += decoder.decode(value, { stream: true }); // bytes\n          }\n        }\n        out += decoder.decode(); // flush\n\n        const trimmed = out.trim();\n        if (trimmed.length === 0) return out;\n\n        if (trimmed.startsWith(\"{\") || trimmed.startsWith(\"[\")) {\n          try {\n            return JSON.parse(trimmed);\n          } catch {\n            return out;\n          }\n        }\n        return out;\n      } catch {\n        return undefined; // same \"give up\" behavior you had\n      }\n    }\n  }\n}\n"],"mappings":";AAOA,eAAsB,SAAuC,GAAwB;AAEnF,QAAM,SAAS,YAAY,IAAI,EAAE,OAAO,YAAY,IAAI;AACxD,MAAI,WAAW,SAAS,WAAW,QAAQ;AACzC,WAAO;AAAA,EACT;AAGA,MAAI,EAAE,UAAU,MAAM,EAAE,QAAQ,MAAM;AACpC,WAAO;AAAA,EACT;AAGA,MAAI;AACF,WAAO,MAAM,EAAE,MAAM,EAAE,KAAK;AAAA,EAC9B,QAAE;AAEA,QAAI;AACF,YAAM,OAAO,MAAM,EAAE,MAAM,EAAE,KAAK;AAClC,YAAM,UAAU,KAAK,KAAK;AAE1B,UAAI,QAAQ,WAAW;AAAG,eAAO;AAEjC,UAAI,QAAQ,WAAW,GAAG,KAAK,QAAQ,WAAW,GAAG,GAAG;AACtD,YAAI;AACF,iBAAO,KAAK,MAAM,OAAO;AAAA,QAC3B,QAAE;AACA,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO;AAAA,IACT,QAAE;AAEA,UAAI;AACF,cAAM,IAAI,EAAE,MAAM;AAClB,cAAM,SAAgC,EAAE,QAAQ;AAChD,YAAI,CAAC;AAAQ,iBAAO;AAEpB,cAAM,SAAS,OAAO,UAAU;AAChC,cAAM,UAAU,IAAI,YAAY;AAChC,YAAI,MAAM;AAEV,eAAO,MAAM;AACX,gBAAM,EAAE,MAAM,MAAM,IAAI,MAAM,OAAO,KAAK;AAC1C,cAAI;AAAM;AACV,cAAI,OAAO,UAAU,UAAU;AAC7B,mBAAO;AAAA,UACT,OAAO;AACL,mBAAO,QAAQ,OAAO,OAAO,EAAE,QAAQ,KAAK,CAAC;AAAA,UAC/C;AAAA,QACF;AACA,eAAO,QAAQ,OAAO;AAEtB,cAAM,UAAU,IAAI,KAAK;AACzB,YAAI,QAAQ,WAAW;AAAG,iBAAO;AAEjC,YAAI,QAAQ,WAAW,GAAG,KAAK,QAAQ,WAAW,GAAG,GAAG;AACtD,cAAI;AACF,mBAAO,KAAK,MAAM,OAAO;AAAA,UAC3B,QAAE;AACA,mBAAO;AAAA,UACT;AAAA,QACF;AACA,eAAO;AAAA,MACT,QAAE;AACA,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACF;","names":[]}