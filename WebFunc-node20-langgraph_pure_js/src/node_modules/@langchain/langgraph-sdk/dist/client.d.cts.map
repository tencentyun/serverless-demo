{"version":3,"file":"client.d.cts","names":["Assistant","AssistantGraph","AssistantSortBy","AssistantSelectField","AssistantVersion","AssistantsSearchResponse","CancelAction","Checkpoint","Config","Cron","CronSelectField","CronCreateForThreadResponse","CronCreateResponse","CronSortBy","DefaultValues","GraphSchema","Item","ListNamespaceResponse","Metadata","Run","RunSelectField","RunStatus","SearchItemsResponse","SortOrder","Subgraphs","Thread","ThreadSelectField","ThreadSortBy","ThreadState","ThreadStatus","ThreadValuesFilter","Command","CronsCreatePayload","CronsUpdatePayload","OnConflictBehavior","RunsCreatePayload","RunsStreamPayload","RunsWaitPayload","StreamEvent","StreamMode","ThreadStreamMode","TypedAsyncGenerator","AsyncCaller","AsyncCallerParams","HeaderValue","getApiKey","RequestHook","URL","RequestInit","Promise","ClientConfig","Record","BaseClient","AbortSignal","T","Response","AsyncGenerator","CronsClient","AssistantsClient","ThreadsClient","TStateType","ValuesType","Array","TUpdateType","Pick","Omit","Partial","RunsClient","TStreamMode","TSubgraphs","TCustomEventType","StoreClient","UiClient","Client","getClientConfigHash"],"sources":["../src/client.d.ts"],"sourcesContent":["import { Assistant, AssistantGraph, AssistantSortBy, AssistantSelectField, AssistantVersion, AssistantsSearchResponse, CancelAction, Checkpoint, Config, Cron, CronSelectField, CronCreateForThreadResponse, CronCreateResponse, CronSortBy, DefaultValues, GraphSchema, Item, ListNamespaceResponse, Metadata, Run, RunSelectField, RunStatus, SearchItemsResponse, SortOrder, Subgraphs, Thread, ThreadSelectField, ThreadSortBy, ThreadState, ThreadStatus, ThreadValuesFilter } from \"./schema.js\";\nimport type { Command, CronsCreatePayload, CronsUpdatePayload, OnConflictBehavior, RunsCreatePayload, RunsStreamPayload, RunsWaitPayload, StreamEvent } from \"./types.js\";\nimport type { StreamMode, ThreadStreamMode, TypedAsyncGenerator } from \"./types.stream.js\";\nimport { AsyncCaller, AsyncCallerParams } from \"./utils/async_caller.js\";\ntype HeaderValue = string | undefined | null;\n/**\n * Get the API key from the environment.\n * Precedence:\n *   1. explicit argument (if string)\n *   2. LANGGRAPH_API_KEY\n *   3. LANGSMITH_API_KEY\n *   4. LANGCHAIN_API_KEY\n *\n * @param apiKey - API key provided as an argument. If null, skips environment lookup. If undefined, tries environment.\n * @returns The API key if found, otherwise undefined\n */\nexport declare function getApiKey(apiKey?: string | null): string | undefined;\nexport type RequestHook = (url: URL, init: RequestInit) => Promise<RequestInit> | RequestInit;\nexport interface ClientConfig {\n    apiUrl?: string;\n    /**\n     * API key for authentication.\n     * - If a string is provided, that key will be used\n     * - If undefined (default), the key will be auto-loaded from environment variables (LANGGRAPH_API_KEY, LANGSMITH_API_KEY, or LANGCHAIN_API_KEY)\n     * - If null, no API key will be set (skips auto-loading)\n     */\n    apiKey?: string | null;\n    callerOptions?: AsyncCallerParams;\n    timeoutMs?: number;\n    defaultHeaders?: Record<string, HeaderValue>;\n    onRequest?: RequestHook;\n}\ndeclare class BaseClient {\n    protected asyncCaller: AsyncCaller;\n    protected timeoutMs: number | undefined;\n    protected apiUrl: string;\n    protected defaultHeaders: Record<string, HeaderValue>;\n    protected onRequest?: RequestHook;\n    constructor(config?: ClientConfig);\n    protected prepareFetchOptions(path: string, options?: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        withResponse?: boolean;\n    }): [url: URL, init: RequestInit];\n    protected fetch<T>(path: string, options: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        signal: AbortSignal | undefined;\n        withResponse: true;\n    }): Promise<[T, Response]>;\n    protected fetch<T>(path: string, options?: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        signal: AbortSignal | undefined;\n        withResponse?: false;\n    }): Promise<T>;\n    /**\n     * Protected helper for streaming with automatic retry logic.\n     * Handles both initial requests and reconnections with SSE.\n     */\n    protected streamWithRetry<T extends {\n        id?: string;\n        event: string;\n        data: unknown;\n    }>(config: {\n        endpoint: string;\n        method?: string;\n        signal?: AbortSignal;\n        headers?: Record<string, string>;\n        params?: Record<string, unknown>;\n        json?: unknown;\n        maxRetries?: number;\n        onReconnect?: (options: {\n            attempt: number;\n            lastEventId?: string;\n            cause: unknown;\n        }) => void;\n        onInitialResponse?: (response: Response) => void | Promise<void>;\n    }): AsyncGenerator<T>;\n}\nexport declare class CronsClient extends BaseClient {\n    /**\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns The created background run.\n     */\n    createForThread(threadId: string, assistantId: string, payload?: CronsCreatePayload): Promise<CronCreateForThreadResponse>;\n    /**\n     *\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns\n     */\n    create(assistantId: string, payload?: CronsCreatePayload): Promise<CronCreateResponse>;\n    /**\n     * Update a cron job by ID.\n     *\n     * @param cronId The cron ID to update.\n     * @param payload Payload for updating a cron job.\n     * @returns The updated cron job.\n     * ```\n     */\n    update(cronId: string, payload?: CronsUpdatePayload): Promise<Cron>;\n    /**\n     * Delete a cron job by ID.\n     *\n     * @param cronId Cron ID of Cron job to delete.\n     * @param options Optional parameters for the request.\n     */\n    delete(cronId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     *\n     * @param query Query options.\n     * @returns List of crons.\n     */\n    search(query?: {\n        assistantId?: string;\n        threadId?: string;\n        enabled?: boolean;\n        limit?: number;\n        offset?: number;\n        sortBy?: CronSortBy;\n        sortOrder?: SortOrder;\n        select?: CronSelectField[];\n        signal?: AbortSignal;\n    }): Promise<Cron[]>;\n    /**\n     * Count cron jobs matching filters.\n     *\n     * @param query.assistantId Assistant ID to filter by.\n     * @param query.threadId Thread ID to filter by.\n     * @returns Number of cron jobs matching the criteria.\n     */\n    count(query?: {\n        assistantId?: string;\n        threadId?: string;\n        signal?: AbortSignal;\n    }): Promise<number>;\n}\nexport declare class AssistantsClient extends BaseClient {\n    /**\n     * Get an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant.\n     * @returns Assistant\n     */\n    get(assistantId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<Assistant>;\n    /**\n     * Get the JSON representation of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @param options.xray Whether to include subgraphs in the serialized graph representation. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.\n     * @returns Serialized graph\n     */\n    getGraph(assistantId: string, options?: {\n        xray?: boolean | number;\n        signal?: AbortSignal;\n    }): Promise<AssistantGraph>;\n    /**\n     * Get the state and config schema of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @returns Graph schema\n     */\n    getSchemas(assistantId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<GraphSchema>;\n    /**\n     * Get the schemas of an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant to get the schema of.\n     * @param options Additional options for getting subgraphs, such as namespace or recursion extraction.\n     * @returns The subgraphs of the assistant.\n     */\n    getSubgraphs(assistantId: string, options?: {\n        namespace?: string;\n        recurse?: boolean;\n        signal?: AbortSignal;\n    }): Promise<Subgraphs>;\n    /**\n     * Create a new assistant.\n     * @param payload Payload for creating an assistant.\n     * @returns The created assistant.\n     */\n    create(payload: {\n        graphId: string;\n        config?: Config;\n        context?: unknown;\n        metadata?: Metadata;\n        assistantId?: string;\n        ifExists?: OnConflictBehavior;\n        name?: string;\n        description?: string;\n        signal?: AbortSignal;\n    }): Promise<Assistant>;\n    /**\n     * Update an assistant.\n     * @param assistantId ID of the assistant.\n     * @param payload Payload for updating the assistant.\n     * @returns The updated assistant.\n     */\n    update(assistantId: string, payload: {\n        graphId?: string;\n        config?: Config;\n        context?: unknown;\n        metadata?: Metadata;\n        name?: string;\n        description?: string;\n        signal?: AbortSignal;\n    }): Promise<Assistant>;\n    /**\n     * Delete an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @param deleteThreads If true, delete all threads with `metadata.assistant_id` equal to `assistantId`. Defaults to false.\n     */\n    delete(assistantId: string, options?: {\n        signal?: AbortSignal;\n        deleteThreads?: boolean;\n    }): Promise<void>;\n    /**\n     * List assistants.\n     * @param query Query options.\n     * @returns List of assistants or, when includePagination is true, a mapping with the assistants and next cursor.\n     */\n    search(query: {\n        graphId?: string;\n        name?: string;\n        metadata?: Metadata;\n        limit?: number;\n        offset?: number;\n        sortBy?: AssistantSortBy;\n        sortOrder?: SortOrder;\n        select?: AssistantSelectField[];\n        includePagination: true;\n        signal?: AbortSignal;\n    }): Promise<AssistantsSearchResponse>;\n    search(query?: {\n        graphId?: string;\n        name?: string;\n        metadata?: Metadata;\n        limit?: number;\n        offset?: number;\n        sortBy?: AssistantSortBy;\n        sortOrder?: SortOrder;\n        select?: AssistantSelectField[];\n        includePagination?: false;\n        signal?: AbortSignal;\n    }): Promise<Assistant[]>;\n    /**\n     * Count assistants matching filters.\n     *\n     * @param query.metadata Metadata to filter by. Exact match for each key/value.\n     * @param query.graphId Optional graph id to filter by.\n     * @param query.name Optional name to filter by.\n     * @returns Number of assistants matching the criteria.\n     */\n    count(query?: {\n        metadata?: Metadata;\n        graphId?: string;\n        name?: string;\n        signal?: AbortSignal;\n    }): Promise<number>;\n    /**\n     * List all versions of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @returns List of assistant versions.\n     */\n    getVersions(assistantId: string, payload?: {\n        metadata?: Metadata;\n        limit?: number;\n        offset?: number;\n        signal?: AbortSignal;\n    }): Promise<AssistantVersion[]>;\n    /**\n     * Change the version of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @param version The version to change to.\n     * @returns The updated assistant.\n     */\n    setLatest(assistantId: string, version: number, options?: {\n        signal?: AbortSignal;\n    }): Promise<Assistant>;\n}\nexport declare class ThreadsClient<TStateType = DefaultValues, TUpdateType = TStateType> extends BaseClient {\n    /**\n     * Get a thread by ID.\n     *\n     * @param threadId ID of the thread.\n     * @returns The thread.\n     */\n    get<ValuesType = TStateType>(threadId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<Thread<ValuesType>>;\n    /**\n     * Create a new thread.\n     *\n     * @param payload Payload for creating a thread.\n     * @returns The created thread.\n     */\n    create(payload?: {\n        /**\n         * Metadata for the thread.\n         */\n        metadata?: Metadata;\n        /**\n         * ID of the thread to create.\n         *\n         * If not provided, a random UUID will be generated.\n         */\n        threadId?: string;\n        /**\n         * How to handle duplicate creation.\n         *\n         * @default \"raise\"\n         */\n        ifExists?: OnConflictBehavior;\n        /**\n         * Graph ID to associate with the thread.\n         */\n        graphId?: string;\n        /**\n         * Apply a list of supersteps when creating a thread, each containing a sequence of updates.\n         *\n         * Used for copying a thread between deployments.\n         */\n        supersteps?: Array<{\n            updates: Array<{\n                values: unknown;\n                command?: Command;\n                asNode: string;\n            }>;\n        }>;\n        /**\n         * Optional time-to-live in minutes for the thread.\n         * If a number is provided, it is treated as minutes and defaults to strategy \"delete\".\n         * You may also provide an object { ttl: number, strategy?: \"delete\" }.\n         */\n        ttl?: number | {\n            ttl: number;\n            strategy?: \"delete\";\n        };\n        /**\n         * Signal to abort the request.\n         */\n        signal?: AbortSignal;\n    }): Promise<Thread<TStateType>>;\n    /**\n     * Copy an existing thread\n     * @param threadId ID of the thread to be copied\n     * @returns Newly copied thread\n     */\n    copy(threadId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<Thread<TStateType>>;\n    /**\n     * Update a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param payload Payload for updating the thread.\n     * @returns The updated thread.\n     */\n    update(threadId: string, payload?: {\n        /**\n         * Metadata for the thread.\n         */\n        metadata?: Metadata;\n        /**\n         * Optional time-to-live in minutes for the thread.\n         * If a number is provided, it is treated as minutes and defaults to strategy \"delete\".\n         * You may also provide an object { ttl: number, strategy?: \"delete\" }.\n         */\n        ttl?: number | {\n            ttl: number;\n            strategy?: \"delete\";\n        };\n        /**\n         * Signal to abort the request.\n         */\n        signal?: AbortSignal;\n    }): Promise<Thread>;\n    /**\n     * Delete a thread.\n     *\n     * @param threadId ID of the thread.\n     */\n    delete(threadId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * List threads\n     *\n     * @param query Query options\n     * @returns List of threads\n     */\n    search<ValuesType = TStateType>(query?: {\n        /**\n         * Metadata to filter threads by.\n         */\n        metadata?: Metadata;\n        /**\n         * Filter by specific thread IDs.\n         */\n        ids?: string[];\n        /**\n         * Maximum number of threads to return.\n         * Defaults to 10\n         */\n        limit?: number;\n        /**\n         * Offset to start from.\n         */\n        offset?: number;\n        /**\n         * Thread status to filter on.\n         */\n        status?: ThreadStatus;\n        /**\n         * Sort by.\n         */\n        sortBy?: ThreadSortBy;\n        /**\n         * Sort order.\n         * Must be one of 'asc' or 'desc'.\n         */\n        sortOrder?: SortOrder;\n        /**\n         * Array of fields to select.\n         * Elements or array must be one of 'thread_id, 'created_at', 'updated_at', 'metadata', 'config', 'context', 'status', 'values', or 'interrupts'.\n         */\n        select?: ThreadSelectField[];\n        /**\n         * Values to filter threads by.\n         */\n        values?: ThreadValuesFilter;\n        /**\n         * Signal to abort the request.\n         */\n        signal?: AbortSignal;\n    }): Promise<Thread<ValuesType>[]>;\n    /**\n     * Count threads matching filters.\n     *\n     * @param query.metadata Thread metadata to filter on.\n     * @param query.values State values to filter on.\n     * @param query.status Thread status to filter on.\n     * @returns Number of threads matching the criteria.\n     */\n    count<ValuesType = TStateType>(query?: {\n        metadata?: Metadata;\n        values?: ValuesType;\n        status?: ThreadStatus;\n        signal?: AbortSignal;\n    }): Promise<number>;\n    /**\n     * Get state for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @returns Thread state.\n     */\n    getState<ValuesType = TStateType>(threadId: string, checkpoint?: Checkpoint | string, options?: {\n        subgraphs?: boolean;\n        signal?: AbortSignal;\n    }): Promise<ThreadState<ValuesType>>;\n    /**\n     * Add state to a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @returns\n     */\n    updateState<ValuesType = TUpdateType>(threadId: string, options: {\n        values: ValuesType;\n        checkpoint?: Checkpoint;\n        checkpointId?: string;\n        asNode?: string;\n        signal?: AbortSignal;\n    }): Promise<Pick<Config, \"configurable\">>;\n    /**\n     * Patch the metadata of a thread.\n     *\n     * @param threadIdOrConfig Thread ID or config to patch the state of.\n     * @param metadata Metadata to patch the state with.\n     */\n    patchState(threadIdOrConfig: string | Config, metadata: Metadata, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * Get all past states for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param options Additional options.\n     * @returns List of thread states.\n     */\n    getHistory<ValuesType = TStateType>(threadId: string, options?: {\n        limit?: number;\n        before?: Config;\n        checkpoint?: Partial<Omit<Checkpoint, \"thread_id\">>;\n        metadata?: Metadata;\n        signal?: AbortSignal;\n    }): Promise<ThreadState<ValuesType>[]>;\n    joinStream(threadId: string, options?: {\n        lastEventId?: string;\n        streamMode?: ThreadStreamMode | ThreadStreamMode[];\n        signal?: AbortSignal;\n    }): AsyncGenerator<{\n        id?: string;\n        event: StreamEvent;\n        data: any;\n    }>;\n}\nexport declare class RunsClient<TStateType = DefaultValues, TUpdateType = TStateType, TCustomEventType = unknown> extends BaseClient {\n    stream<TStreamMode extends StreamMode | StreamMode[] = StreamMode, TSubgraphs extends boolean = false>(threadId: null, assistantId: string, payload?: Omit<RunsStreamPayload<TStreamMode, TSubgraphs>, \"multitaskStrategy\" | \"onCompletion\">): TypedAsyncGenerator<TStreamMode, TSubgraphs, TStateType, TUpdateType, TCustomEventType>;\n    stream<TStreamMode extends StreamMode | StreamMode[] = StreamMode, TSubgraphs extends boolean = false>(threadId: string, assistantId: string, payload?: RunsStreamPayload<TStreamMode, TSubgraphs>): TypedAsyncGenerator<TStreamMode, TSubgraphs, TStateType, TUpdateType, TCustomEventType>;\n    /**\n     * Create a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The created run.\n     */\n    create(threadId: string | null, assistantId: string, payload?: RunsCreatePayload): Promise<Run>;\n    /**\n     * Create a batch of stateless background runs.\n     *\n     * @param payloads An array of payloads for creating runs.\n     * @returns An array of created runs.\n     */\n    createBatch(payloads: (Omit<RunsCreatePayload, \"signal\"> & {\n        assistantId: string;\n    })[], options?: {\n        signal?: AbortSignal;\n    }): Promise<Run[]>;\n    wait(threadId: null, assistantId: string, payload?: Omit<RunsWaitPayload, \"multitaskStrategy\" | \"onCompletion\">): Promise<ThreadState[\"values\"]>;\n    wait(threadId: string, assistantId: string, payload?: RunsWaitPayload): Promise<ThreadState[\"values\"]>;\n    /**\n     * List all runs for a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @param options Filtering and pagination options.\n     * @returns List of runs.\n     */\n    list(threadId: string, options?: {\n        /**\n         * Maximum number of runs to return.\n         * Defaults to 10\n         */\n        limit?: number;\n        /**\n         * Offset to start from.\n         * Defaults to 0.\n         */\n        offset?: number;\n        /**\n         * Status of the run to filter by.\n         */\n        status?: RunStatus;\n        select?: RunSelectField[];\n        /**\n         * Signal to abort the request.\n         */\n        signal?: AbortSignal;\n    }): Promise<Run[]>;\n    /**\n     * Get a run by ID.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns The run.\n     */\n    get(threadId: string, runId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<Run>;\n    /**\n     * Cancel a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @param wait Whether to block when canceling\n     * @param action Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. Default is `interrupt`.\n     * @returns\n     */\n    cancel(threadId: string, runId: string, wait?: boolean, action?: CancelAction, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * Block until a run is done.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    join(threadId: string, runId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<TStateType>;\n    /**\n     * Stream output from a run in real-time, until the run is done.\n     *\n     * @param threadId The ID of the thread. Can be set to `null` | `undefined` for stateless runs.\n     * @param runId The ID of the run.\n     * @param options Additional options for controlling the stream behavior:\n     *   - signal: An AbortSignal that can be used to cancel the stream request\n     *   - lastEventId: The ID of the last event received. Can be used to reconnect to a stream without losing events.\n     *   - cancelOnDisconnect: When true, automatically cancels the run if the client disconnects from the stream\n     *   - streamMode: Controls what types of events to receive from the stream (can be a single mode or array of modes)\n     *        Must be a subset of the stream modes passed when creating the run. Background runs default to having the union of all\n     *        stream modes enabled.\n     * @returns An async generator yielding stream parts.\n     */\n    joinStream(threadId: string | undefined | null, runId: string, options?: {\n        signal?: AbortSignal;\n        cancelOnDisconnect?: boolean;\n        lastEventId?: string;\n        streamMode?: StreamMode | StreamMode[];\n    } | AbortSignal): AsyncGenerator<{\n        id?: string;\n        event: StreamEvent;\n        data: any;\n    }>;\n    /**\n     * Delete a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    delete(threadId: string, runId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n}\nexport declare class StoreClient extends BaseClient {\n    /**\n     * Store or update an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item within the namespace.\n     * @param value A dictionary containing the item's data.\n     * @param options.index Controls search indexing - null (use defaults), false (disable), or list of field paths to index.\n     * @param options.ttl Optional time-to-live in minutes for the item, or null for no expiration.\n     * @returns Promise<void>\n     *\n     * @example\n     * ```typescript\n     * await client.store.putItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { title: \"My Document\", content: \"Hello World\" },\n     *   { ttl: 60 } // expires in 60 minutes\n     * );\n     * ```\n     */\n    putItem(namespace: string[], key: string, value: Record<string, unknown>, options?: {\n        index?: false | string[] | null;\n        ttl?: number | null;\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * Retrieve a single item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @param options.refreshTtl Whether to refresh the TTL on this read operation. If null, uses the store's default behavior.\n     * @returns Promise<Item>\n     *\n     * @example\n     * ```typescript\n     * const item = await client.store.getItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { refreshTtl: true }\n     * );\n     * console.log(item);\n     * // {\n     * //   namespace: [\"documents\", \"user123\"],\n     * //   key: \"item456\",\n     * //   value: { title: \"My Document\", content: \"Hello World\" },\n     * //   createdAt: \"2024-07-30T12:00:00Z\",\n     * //   updatedAt: \"2024-07-30T12:00:00Z\"\n     * // }\n     * ```\n     */\n    getItem(namespace: string[], key: string, options?: {\n        refreshTtl?: boolean | null;\n        signal?: AbortSignal;\n    }): Promise<Item | null>;\n    /**\n     * Delete an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @returns Promise<void>\n     */\n    deleteItem(namespace: string[], key: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * Search for items within a namespace prefix.\n     *\n     * @param namespacePrefix List of strings representing the namespace prefix.\n     * @param options.filter Optional dictionary of key-value pairs to filter results.\n     * @param options.limit Maximum number of items to return (default is 10).\n     * @param options.offset Number of items to skip before returning results (default is 0).\n     * @param options.query Optional search query.\n     * @param options.refreshTtl Whether to refresh the TTL on items returned by this search. If null, uses the store's default behavior.\n     * @returns Promise<SearchItemsResponse>\n     *\n     * @example\n     * ```typescript\n     * const results = await client.store.searchItems(\n     *   [\"documents\"],\n     *   {\n     *     filter: { author: \"John Doe\" },\n     *     limit: 5,\n     *     refreshTtl: true\n     *   }\n     * );\n     * console.log(results);\n     * // {\n     * //   items: [\n     * //     {\n     * //       namespace: [\"documents\", \"user123\"],\n     * //       key: \"item789\",\n     * //       value: { title: \"Another Document\", author: \"John Doe\" },\n     * //       createdAt: \"2024-07-30T12:00:00Z\",\n     * //       updatedAt: \"2024-07-30T12:00:00Z\"\n     * //     },\n     * //     // ... additional items ...\n     * //   ]\n     * // }\n     * ```\n     */\n    searchItems(namespacePrefix: string[], options?: {\n        filter?: Record<string, unknown>;\n        limit?: number;\n        offset?: number;\n        query?: string;\n        refreshTtl?: boolean | null;\n        signal?: AbortSignal;\n    }): Promise<SearchItemsResponse>;\n    /**\n     * List namespaces with optional match conditions.\n     *\n     * @param options.prefix Optional list of strings representing the prefix to filter namespaces.\n     * @param options.suffix Optional list of strings representing the suffix to filter namespaces.\n     * @param options.maxDepth Optional integer specifying the maximum depth of namespaces to return.\n     * @param options.limit Maximum number of namespaces to return (default is 100).\n     * @param options.offset Number of namespaces to skip before returning results (default is 0).\n     * @returns Promise<ListNamespaceResponse>\n     */\n    listNamespaces(options?: {\n        prefix?: string[];\n        suffix?: string[];\n        maxDepth?: number;\n        limit?: number;\n        offset?: number;\n        signal?: AbortSignal;\n    }): Promise<ListNamespaceResponse>;\n}\ndeclare class UiClient extends BaseClient {\n    private static promiseCache;\n    private static getOrCached;\n    getComponent(assistantId: string, agentName: string): Promise<string>;\n}\nexport declare class Client<TStateType = DefaultValues, TUpdateType = TStateType, TCustomEventType = unknown> {\n    /**\n     * The client for interacting with assistants.\n     */\n    assistants: AssistantsClient;\n    /**\n     * The client for interacting with threads.\n     */\n    threads: ThreadsClient<TStateType, TUpdateType>;\n    /**\n     * The client for interacting with runs.\n     */\n    runs: RunsClient<TStateType, TUpdateType, TCustomEventType>;\n    /**\n     * The client for interacting with cron runs.\n     */\n    crons: CronsClient;\n    /**\n     * The client for interacting with the KV store.\n     */\n    store: StoreClient;\n    /**\n     * The client for interacting with the UI.\n     * @internal Used by LoadExternalComponent and the API might change in the future.\n     */\n    \"~ui\": UiClient;\n    /**\n     * @internal Used to obtain a stable key representing the client.\n     */\n    private \"~configHash\";\n    constructor(config?: ClientConfig);\n}\n/**\n * @internal Used to obtain a stable key representing the client.\n */\nexport declare function getClientConfigHash(client: Client): string | undefined;\nexport {};\n"],"mappings":";;;;;;KAIK4C,WAAAA;;AADoE;AAazE;AACA;;;;;;;;AACiBM,iBAFOL,SAAAA,CAEK,MAAA,CAAA,EAAA,MAAA,GAAA,IAAA,CAAA,EAAA,MAAA,GAAA,SAAA;AAAA,KADjBC,WAAAA,GACiB,CAAA,GAAA,EADGC,GACH,EAAA,IAAA,EADcC,WACd,EAAA,GAD8BC,OAC9B,CADsCD,WACtC,CAAA,GADqDA,WACrD;AASTL,UATHO,YAAAA,CASGP;QAEgBC,CAAAA,EAAAA,MAAAA;;;;AAEnC;;;QAK4CA,CAAAA,EAAAA,MAAAA,GAAAA,IAAAA;eAAfO,CAAAA,EATVR,iBASUQ;WACJL,CAAAA,EAAAA,MAAAA;gBACDI,CAAAA,EATJC,MASID,CAAAA,MAAAA,EATWN,WASXM,CAAAA;WACiCF,CAAAA,EAT1CF,WAS0CE;;cAP5CI,UAAAA,CAYAL;YAAWC,WAAAA,EAXEN,WAWFM;YACqBA,SAAAA,EAAAA,MAAAA,GAAAA,SAAAA;YAE7BG,MAAAA,EAAAA,MAAAA;YAEDE,cAAAA,EAbcF,MAadE,CAAAA,MAAAA,EAb6BT,WAa7BS,CAAAA;YAECC,SAAAA,CAAAA,EAdSR,WAcTQ;aAAGC,CAAAA,MAAAA,CAAAA,EAbKL,YAaLK;YAAZN,mBAAAA,CAAAA,IAAAA,EAAAA,MAAAA,EAAAA,QAAAA,EAZkDD,WAYlDC,GAAAA;IACuCD,IAAAA,CAAAA,EAAAA,OAAAA;IAE9BG,MAAAA,CAAAA,EAbAA,MAaAA,CAAAA,MAAAA,EAAAA,OAAAA,CAAAA;IAEDE,SAAAA,CAAAA,EAAAA,MAAAA,GAAAA,IAAAA;IAEAC,YAAAA,CAAAA,EAAAA,OAAAA;MAARL,CAAAA,GAAAA,EAdMF,GAcNE,EAAAA,IAAAA,EAdiBD,WAcjBC,CAAAA;YAYSI,KAAAA,CAAAA,CAAAA,CAAAA,CAAAA,IAAAA,EAAAA,MAAAA,EAAAA,OAAAA,EAzB6BL,WAyB7BK,GAAAA;IACCF,IAAAA,CAAAA,EAAAA,OAAAA;IACDA,MAAAA,CAAAA,EAzBAA,MAyBAA,CAAAA,MAAAA,EAAAA,OAAAA,CAAAA;IAQsBI,SAAAA,CAAAA,EAAAA,MAAAA,GAAAA,IAAAA;IAAoBN,MAAAA,EA/B3CI,WA+B2CJ,GAAAA,SAAAA;IACpCK,YAAAA,EAAAA,IAAAA;MA9BfL,OA8BAO,CAAAA,CA9BSF,CA8BTE,EA9BYD,QA8BZC,CAAAA,CAAAA;EAAc,UAAA,KAAA,CAAA,CAAA,CAAA,CAAA,IAAA,EAAA,MAAA,EAAA,QAAA,EA7ByBR,WA6BzB,GAAA;IAEDS,IAAAA,CAAAA,EAAAA,OAAW;IAAA,MAAA,CAAA,EA7BfN,MA6Be,CAAA,MAAA,EAAA,OAAA,CAAA;IAQqCnB,SAAAA,CAAAA,EAAAA,MAAAA,GAAAA,IAAAA;IAA6BrB,MAAAA,EAnClF0C,WAmCkF1C,GAAAA,SAAAA;IAARsC,YAAAA,CAAAA,EAAAA,KAAAA;MAjClFA,OAwCkCjB,CAxC1BsB,CAwC0BtB,CAAAA;;;;;YASgBiB,eAAAA,CAAAA,UAAAA;IAQzCI,EAAAA,CAAAA,EAAAA,MAAAA;IACTJ,KAAAA,EAAAA,MAAAA;IAYSpC,IAAAA,EAAAA,OAAAA;KACGU,MAAAA,EAAAA;IACHb,QAAAA,EAAAA,MAAAA;IACA2C,MAAAA,CAAAA,EAAAA,MAAAA;IACD5C,MAAAA,CAAAA,EA9DC4C,WA8DD5C;IAARwC,OAAAA,CAAAA,EA7DUE,MA6DVF,CAAAA,MAAAA,EAAAA,MAAAA,CAAAA;IAWSI,MAAAA,CAAAA,EAvEAF,MAuEAE,CAAAA,MAAAA,EAAAA,OAAAA,CAAAA;IACTJ,IAAAA,CAAAA,EAAAA,OAAAA;IA7DiCG,UAAAA,CAAAA,EAAAA,MAAAA;IAAU,WAAA,CAAA,EAAA,CAAA,OAAA,EAAA;MA+D9BM,OAAAA,EAAAA,MAAgB;MAAA,WAAA,CAAA,EAAA,MAAA;MAQpBL,KAAAA,EAAAA,OAAAA;IACDrD,CAAAA,EAAAA,GAAAA,IAAAA;IAARiD,iBAAAA,CAAAA,EAAAA,CAAAA,QAAAA,EA3E+BM,QA2E/BN,EAAAA,GAAAA,IAAAA,GA3EmDA,OA2EnDA,CAAAA,IAAAA,CAAAA;MA1EAO,cAmFSH,CAnFMC,CAmFND,CAAAA;;AACTJ,cAlFaQ,WAAAA,SAAoBL,UAAAA,CAkFjCH;;;;;;;;iBA8BW/B,CAAAA,QAAAA,EAAAA,MAAAA,EAAAA,WAAAA,EAAAA,MAAAA,EAAAA,OAAAA,CAAAA,EAxGkDc,kBAwGlDd,CAAAA,EAxGuE+B,OAwGvE/B,CAxG+EP,2BAwG/EO,CAAAA;;;;;;;QAoBFmC,CAAAA,WAAAA,EAAAA,MAAAA,EAAAA,OAAAA,CAAAA,EArHyBrB,kBAqHzBqB,CAAAA,EArH8CJ,OAqH9CI,CArHsDzC,kBAqHtDyC,CAAAA;;;;;;;;;QA2BAA,CAAAA,MAAAA,EAAAA,MAAAA,EAAAA,OAAAA,CAAAA,EAvIoBpB,kBAuIpBoB,CAAAA,EAvIyCJ,OAuIzCI,CAvIiD5C,IAuIjD4C,CAAAA;;;;;;;QAYAA,CAAAA,MAAAA,EAAAA,MAAAA,EAAAA,QAAAA,EAAAA;IACDrD,MAAAA,CAAAA,EA5ICqD,WA4IDrD;MA3IRiD,OA2IAA,CAAAA,IAAAA,CAAAA;;;;;;QA0BQ7C,CAAAA,MAAAA,EAAAA;IAAR6C,WAAAA,CAAAA,EAAAA,MAAAA;IASSI,QAAAA,CAAAA,EAAAA,MAAAA;IACDrD,OAAAA,CAAAA,EAAAA,OAAAA;IAARiD,KAAAA,CAAAA,EAAAA,MAAAA;IAjJsCG,MAAAA,CAAAA,EAAAA,MAAAA;IAAU,MAAA,CAAA,EAlBvCvC,UAkBuC;IAmJnC8C,SAAAA,CAAAA,EApKDpC,SAoKc;IAAA,MAAA,CAAA,EAnKjBb,eAmKiB,EAAA;IAAcI,MAAAA,CAAAA,EAlK/BuC,WAkK+BvC;MAjKxCmC,OAiKqEW,CAjK7DnD,IAiK6DmD,EAAAA,CAAAA;;;;;;;;OA6CnD7B,CAAAA,MAAAA,EAAAA;IAFL+B,WAAAA,CAAAA,EAAAA,MAAAA;IADAA,QAAAA,CAAAA,EAAAA,MAAAA;IAmBJT,MAAAA,CAAAA,EAnNAA,WAmNAA;MAlNTJ,OAmNeW,CAAAA,MAAAA,CAAAA;;AAAfX,cAjNaS,gBAAAA,SAAyBN,UAAAA,CAiNtCH;;;;;;;KAkCQxB,CAAAA,WAAAA,EAAAA,MAAAA,EAAAA,QAAAA,EAAAA;IAARwB,MAAAA,CAAAA,EA3OSI,WA2OTJ;MA1OAA,OAiPSI,CAjPDrD,SAiPCqD,CAAAA;;;;;;;UA2CA3B,CAAAA,WAAAA,EAAAA,MAAAA,EAAAA,QAAAA,EAAAA;IAIAI,IAAAA,CAAAA,EAAAA,OAAAA,GAAAA,MAAAA;IAIAuB,MAAAA,CAAAA,EA3RAA,WA2RAA;MA1RTJ,OA2ReY,CA3RP5D,cA2RO4D,CAAAA;;;;;;YAYNhC,CAAAA,WAAAA,EAAAA,MAAAA,EAAAA,QAAAA,EAAAA;IACAwB,MAAAA,CAAAA,EAjSAA,WAiSAA;MAhSTJ,OAiSAA,CAjSQlC,WAiSRkC,CAAAA;;;;;;;;cAkBQY,CAAAA,WAAAA,EAAAA,MAAAA,EAAAA,QAAAA,EAAAA;IACKtD,SAAAA,CAAAA,EAAAA,MAAAA;IAGJ8C,OAAAA,CAAAA,EAAAA,OAAAA;IACI7C,MAAAA,CAAAA,EA7SJ6C,WA6SI7C;MA5SbyC,OA4SQe,CA5SAxC,SA4SAwC,CAAAA;;;;;;QAiBYJ,CAAAA,OAAAA,EAAAA;IAEXpD,OAAAA,EAAAA,MAAAA;IACiBD,MAAAA,CAAAA,EAxTjBC,MAwTiBD;IAAL0D,OAAAA,CAAAA,EAAAA,OAAAA;IAARC,QAAAA,CAAAA,EAtTFhD,QAsTEgD;IACFhD,WAAAA,CAAAA,EAAAA,MAAAA;IACFmC,QAAAA,CAAAA,EAtTEnB,kBAsTFmB;IACWQ,IAAAA,CAAAA,EAAAA,MAAAA;IAAZjC,WAAAA,CAAAA,EAAAA,MAAAA;IAARqB,MAAAA,CAAAA,EApTSI,WAoTTJ;MAnTAA,OAsTaT,CAtTLxC,SAsTKwC,CAAAA;;;;;;;EAQA2B,MAAAA,CAAAA,WAAU,EAAA,MAAA,EAAA,OAAA,EAAA;IAAA,OAAA,CAAA,EAAA,MAAA;IAAcrD,MAAAA,CAAAA,EArT5BN,MAqT4BM;IAA6B8C,OAAAA,CAAAA,EAAAA,OAAAA;IAC3CrB,QAAAA,CAAAA,EApTZrB,QAoTYqB;IAAaA,IAAAA,CAAAA,EAAAA,MAAAA;IAAeA,WAAAA,CAAAA,EAAAA,MAAAA;IAAsH6B,MAAAA,CAAAA,EAjThKf,WAiTgKe;MAhTzKnB,OAgTsLoB,CAhT9KrE,SAgT8KqE,CAAAA;;;;;;;QAA2HC,CAAAA,WAAAA,EAAAA,MAAAA,EAAAA,QAAAA,EAAAA;IAAtE7B,MAAAA,CAAAA,EAxSlOY,WAwSkOZ;IACpNF,aAAAA,CAAAA,EAAAA,OAAAA;MAvSvBU,OAuSoCV,CAAAA,IAAAA,CAAAA;;;;;;QAA8L8B,CAAAA,KAAAA,EAAAA;IAAYT,OAAAA,CAAAA,EAAAA,MAAAA;IAAYG,IAAAA,CAAAA,EAAAA,MAAAA;IAAaO,QAAAA,CAAAA,EA9R5PpD,QA8R4PoD;IAAtE7B,KAAAA,CAAAA,EAAAA,MAAAA;IAStIN,MAAAA,CAAAA,EAAAA,MAAAA;IAA4BhB,MAAAA,CAAAA,EApS9EjB,eAoS8EiB;IAAR8B,SAAAA,CAAAA,EAnSnE1B,SAmSmE0B;IAOvDd,MAAAA,CAAAA,EAzSfhC,oBAySegC,EAAAA;IAAL8B,iBAAAA,EAAAA,IAAAA;IAGVZ,MAAAA,CAAAA,EA1SAA,WA0SAA;MAzSTJ,OA0SQ9B,CA1SAd,wBA0SAc,CAAAA;QAAR8B,CAAAA,MAAAA,EAAAA;IACqDZ,OAAAA,CAAAA,EAAAA,MAAAA;IAAL4B,IAAAA,CAAAA,EAAAA,MAAAA;IAAsErC,QAAAA,CAAAA,EAvS3GV,QAuS2GU;IAARqB,KAAAA,CAAAA,EAAAA,MAAAA;IAC5DZ,MAAAA,CAAAA,EAAAA,MAAAA;IAA0BT,MAAAA,CAAAA,EArSnE1B,eAqSmE0B;IAARqB,SAAAA,CAAAA,EApSxD1B,SAoSwD0B;IAsB3D5B,MAAAA,CAAAA,EAzTAlB,oBAyTAkB,EAAAA;IACAD,iBAAAA,CAAAA,EAAAA,KAAAA;IAIAiC,MAAAA,CAAAA,EA5TAA,WA4TAA;MA3TTJ,OA4TQ9B,CA5TAnB,SA4TAmB,EAAAA,CAAAA;;;;;;;;;OAgCAyC,CAAAA,MAAAA,EAAAA;IAARX,QAAAA,CAAAA,EAlVW/B,QAkVX+B;IAgBSI,OAAAA,CAAAA,EAAAA,MAAAA;IAGId,IAAAA,CAAAA,EAAAA,MAAAA;IAAaA,MAAAA,CAAAA,EAlWjBc,WAkWiBd;MAjW1BU,OAkWAI,CAAAA,MAAAA,CAAAA;;;;;;;EAgBakB,WAAAA,CAAAA,WAAW,EAAA,MAAA,EAAA,QAAA,EAAA;IAAA,QAAA,CAAA,EA1WbrD,QA0Wa;IAqBqBiC,KAAAA,CAAAA,EAAAA,MAAAA;IAGpCE,MAAAA,CAAAA,EAAAA,MAAAA;IACTJ,MAAAA,CAAAA,EAhYSI,WAgYTJ;MA/XAA,OA2ZSI,CA3ZDjD,gBA2ZCiD,EAAAA,CAAAA;;;;;;;;WAuDTJ,CAAAA,WAAAA,EAAAA,MAAAA,EAAAA,OAAAA,EAAAA,MAAAA,EAAAA,QAAAA,EAAAA;IAiBSI,MAAAA,CAAAA,EA1dAA,WA0dAA;MAzdTJ,OA0dQhC,CA1dAjB,SA0dAiB,CAAAA;;AA9HyBmC,cA1VpBO,aA0VoBP,CAAAA,aA1VOtC,aA0VPsC,EAAAA,cA1VoCQ,UA0VpCR,CAAAA,SA1VwDA,UAAAA,CA0VxDA;EAAU;AA+HlD;;;;;EAMoBqB,GAAAA,CAAAA,aAxdAb,UAwdM,CAAA,CAAA,QAAA,EAAA,MAAA,EAAA,QAAA,EAAA;IAAA,MAAA,CAAA,EAvdVP,WAudU;MAtdnBJ,OAsdiCnC,CAtdzBW,MAsdyBX,CAtdlB+C,UAsdkB/C,CAAAA,CAAAA;;;;;;;QAYRiD,CAAAA,QAAAA,EAAAA;IAAaO;;;IAQnCC,QAAAA,CAAAA,EA/dQrD,QA+dRqD;IAKAC;;;AAUX;;;;;;;;eAlemBtC;;;;;;;;;;iBAUE4B;eACAA;;kBAEK/B;;;;;;;;;;;;;;;;aAgBTsB;MACTJ,QAAQxB,OAAOmC;;;;;;;aAONP;MACTJ,QAAQxB,OAAOmC;;;;;;;;;;;;eAYJ1C;;;;;;;;;;;;;aAaFmC;MACTJ,QAAQxB;;;;;;;aAOC4B;MACTJ;;;;;;;sBAOgBW;;;;eAIL1C;;;;;;;;;;;;;;;;;aAiBFW;;;;aAIAF;;;;;gBAKGJ;;;;;aAKHG;;;;aAIAI;;;;aAIAuB;MACTJ,QAAQxB,OAAOoC;;;;;;;;;qBASAD;eACJ1C;aACF2C;aACAhC;aACAwB;MACTJ;;;;;;;wBAOkBW,2CAA2CrD;;aAEpD8C;MACTJ,QAAQrB,YAAYiC;;;;;;;2BAOCE;YACbF;iBACKtD;;;aAGJ8C;MACTJ,QAAQe,KAAKxD;;;;;;;wCAOqBA,kBAAkBU;aAC3CmC;MACTJ;;;;;;;;0BAQoBW;;aAEXpD;iBACI0D,QAAQD,KAAK1D;eACfW;aACFmC;MACTJ,QAAQrB,YAAYiC;;;iBAGPrB,mBAAmBA;aACvBa;MACTG;;WAEOlB;;;;cAIM6B,wBAAwBrD,6BAA6B8C,gDAAgDR,UAAAA;6BAC3Fb,aAAaA,eAAeA,+FAA+F0B,KAAK7B,kBAAkBgC,aAAaC,qDAAqD5B,oBAAoB2B,aAAaC,YAAYT,YAAYG,aAAaO;6BAC1R/B,aAAaA,eAAeA,iGAAiGH,kBAAkBgC,aAAaC,cAAc5B,oBAAoB2B,aAAaC,YAAYT,YAAYG,aAAaO;;;;;;;;;iEAS5MnC,oBAAoBc,QAAQ9B;;;;;;;yBAOpE8C,KAAK9B;;;aAGfkB;MACTJ,QAAQ9B;sDACwC8C,KAAK5B,yDAAyDY,QAAQrB;wDACpES,kBAAkBY,QAAQrB;;;;;;;;;;;;;;;;;;;;;;aAsBnEP;aACAD;;;;aAIAiC;MACTJ,QAAQ9B;;;;;;;;;aASCkC;MACTJ,QAAQ9B;;;;;;;;;;mEAUqDb;aACpD+C;MACTJ;;;;;;;;;aASSI;MACTJ,QAAQW;;;;;;;;;;;;;;;;aAgBCP;;;iBAGId,aAAaA;MAC1Bc,cAAcG;;WAEPlB;;;;;;;;;;;aAWEe;MACTJ;;cAEasB,WAAAA,SAAoBnB,UAAAA;;;;;;;;;;;;;;;;;;;;;mDAqBYD;;;aAGpCE;MACTJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;aA4BSI;MACTJ,QAAQjC;;;;;;;;;aASCqC;MACTJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;aAsCSE;;;;;aAKAE;MACTJ,QAAQ3B;;;;;;;;;;;;;;;;;aAiBC+B;MACTJ,QAAQhC;;cAEFuD,QAAAA,SAAiBpB,UAAAA;;;wDAG2BH;;cAErCwB,oBAAoB3D,6BAA6B8C;;;;cAItDF;;;;WAIHC,cAAcC,YAAYG;;;;QAI7BI,WAAWP,YAAYG,aAAaO;;;;SAInCb;;;;SAIAc;;;;;SAKAC;;;;;uBAKctB;;;;;iBAKDwB,mBAAAA,SAA4BD"}