{"version":3,"sources":["../src/agent.ts","../src/util.ts","../src/checkpoint.ts","../src/store/tdai-store.ts"],"sourcesContent":["import {\n  RunAgentInput,\n  Message,\n  ToolCall,\n  BaseEvent,\n  EventType,\n  RunStartedEvent,\n  RunFinishedEvent,\n  RunErrorEvent,\n  TextMessageStartEvent,\n  TextMessageContentEvent,\n  TextMessageEndEvent,\n  ToolCallStartEvent,\n  ToolCallArgsEvent,\n  ToolCallEndEvent,\n  ToolCallResultEvent,\n  AbstractAgent,\n  AgentConfig,\n} from \"@ag-ui/client\";\n\nimport { Message as LangGraphMessage } from \"@langchain/langgraph-sdk\";\n\nimport { Observable, Subscriber } from \"rxjs\";\n\nimport {\n  Annotation,\n  AnnotationRoot,\n  StateDefinition,\n  StateGraph,\n  MessagesAnnotation,\n  Command,\n} from \"@langchain/langgraph\";\nimport { InteropZodObject } from \"@langchain/core/utils/types\";\nimport { convertActionsToDynamicStructuredTools } from \"./util\";\n\ntype SDZod = StateDefinition | InteropZodObject;\n\ntype CompiledStateGraph<SD extends SDZod> = ReturnType<\n  StateGraph<SD>[\"compile\"]\n>;\n\ntype AnnotationInside<T> = T extends AnnotationRoot<infer U> ? U : never;\n\ntype ClientStateDefinition = AnnotationInside<typeof ClientStateAnnotation>;\n\nexport const ClientPropertiesAnnotation = Annotation.Root({\n  tools: Annotation<any[]>,\n});\n\nexport const ClientStateAnnotation = Annotation.Root({\n  client: Annotation<typeof ClientPropertiesAnnotation.State>,\n  ...MessagesAnnotation.spec,\n});\n\nexport type ClientState = typeof ClientStateAnnotation.State;\n\nexport class LanggraphAgent extends AbstractAgent {\n  compiledWorkflow?: CompiledStateGraph<ClientStateDefinition>;\n\n  constructor(\n    agentConfig: AgentConfig & {\n      compiledWorkflow: any;\n    }\n  ) {\n    super(agentConfig);\n    this.compiledWorkflow =\n      agentConfig.compiledWorkflow as CompiledStateGraph<ClientStateDefinition>;\n  }\n\n  run(input: RunAgentInput) {\n    return new Observable<BaseEvent>((subscriber) => {\n      this._run(subscriber, input);\n    });\n  }\n\n  async _run(subscriber: Subscriber<BaseEvent>, input: RunAgentInput) {\n    const { messages, runId, threadId } = input;\n\n    subscriber.next({\n      type: EventType.RUN_STARTED,\n      threadId,\n      runId,\n    } as RunStartedEvent);\n\n    const streamEventInput = input.forwardedProps?.resume\n      ? new Command<unknown, Partial<ClientState>, \"__start__\">({\n          resume: JSON.stringify(input.forwardedProps?.resume?.payload),\n        })\n      : {\n          messages: aguiMessagesToLangChain(messages),\n          client: {\n            tools: convertActionsToDynamicStructuredTools(\n              input.tools.map((x) => ({\n                ...x,\n                parameters:\n                  typeof x.parameters === \"string\"\n                    ? JSON.parse(x.parameters)\n                    : x.parameters,\n              }))\n            ),\n          },\n        };\n\n    const stream = this.compiledWorkflow!.streamEvents(streamEventInput, {\n      version: \"v2\",\n      runId,\n      configurable: {\n        thread_id: threadId,\n      },\n    });\n\n    const chatModelRuns: Array<{ runId: string; messageId?: string }> = [];\n\n    // Pre-populate handledToolCallIds with tool call IDs from INPUT messages.\n    // This prevents emitting duplicate TOOL_CALL_RESULT events for tool results\n    // that were already processed in a previous run and are now being sent back\n    // by the client as part of the message history.\n    const handledToolCallIds: Set<string> = new Set();\n    for (const msg of messages) {\n      if (msg.role === \"tool\" && msg.toolCallId) {\n        handledToolCallIds.add(msg.toolCallId);\n      }\n    }\n\n    let interrupt:\n      | undefined\n      | {\n          id: string;\n          reason: string;\n          payload: unknown;\n        };\n\n    let currentToolCall: { name: string; args: string; id: string } | null =\n      null;\n\n    for await (const event of stream) {\n      if (event.event.startsWith(\"ChannelWrite<\")) {\n        continue;\n      }\n\n      if (event.event === \"on_chat_model_start\") {\n        chatModelRuns.push({ runId: event.run_id });\n        continue;\n      }\n\n      if (event.event === \"on_chat_model_stream\") {\n        if (\n          Array.isArray(event.data.chunk?.tool_call_chunks) &&\n          event.data.chunk?.tool_call_chunks?.length > 0\n        ) {\n          (\n            event.data.chunk.tool_call_chunks as Array<{\n              name: string;\n              args: unknown;\n              id: string;\n            }>\n          )\n            .map((x) => ({\n              ...x,\n              args:\n                typeof x.args === \"string\"\n                  ? x.args\n                  : x.args\n                    ? JSON.stringify(x.args)\n                    : \"\",\n            }))\n            .forEach((toolCall) => {\n              if (currentToolCall) {\n                if (toolCall.id && currentToolCall.id !== toolCall.id) {\n                  // end the current tool call\n                  subscriber.next({\n                    toolCallId: currentToolCall.id,\n                    type: EventType.TOOL_CALL_END,\n                  } as ToolCallEndEvent);\n\n                  // set the new tool call as the current tool call\n                  if (toolCall.name && toolCall.id) {\n                    currentToolCall = toolCall;\n                    subscriber.next({\n                      toolCallId: currentToolCall.id,\n                      toolCallName: currentToolCall.name,\n                      type: EventType.TOOL_CALL_START,\n                    } as ToolCallStartEvent);\n                    if (currentToolCall.args) {\n                      subscriber.next({\n                        toolCallId: currentToolCall.id,\n                        delta: currentToolCall.args,\n                        type: EventType.TOOL_CALL_ARGS,\n                      } as ToolCallArgsEvent);\n\n                      if (isValidJson(currentToolCall.args)) {\n                        // args is valid json, tool call streaming ends\n                        subscriber.next({\n                          toolCallId: currentToolCall.id,\n                          type: EventType.TOOL_CALL_END,\n                        } as ToolCallEndEvent);\n                        currentToolCall = null;\n                      }\n                    }\n                  }\n                } else {\n                  // update the current tool call\n                  if (toolCall.args) {\n                    currentToolCall.args += toolCall.args;\n                    subscriber.next({\n                      toolCallId: currentToolCall.id,\n                      delta: toolCall.args,\n                      type: EventType.TOOL_CALL_ARGS,\n                    } as ToolCallArgsEvent);\n\n                    if (isValidJson(currentToolCall.args)) {\n                      // args is valid json, tool call streaming ends\n                      subscriber.next({\n                        toolCallId: currentToolCall.id,\n                        type: EventType.TOOL_CALL_END,\n                      } as ToolCallEndEvent);\n                      currentToolCall = null;\n                    }\n                  }\n                }\n              } else {\n                if (toolCall.name && toolCall.id) {\n                  currentToolCall = toolCall;\n                  subscriber.next({\n                    toolCallId: toolCall.id,\n                    toolCallName: toolCall.name,\n                    type: EventType.TOOL_CALL_START,\n                  } as ToolCallStartEvent);\n                  if (toolCall.args) {\n                    subscriber.next({\n                      toolCallId: toolCall.id,\n                      delta: toolCall.args,\n                      type: EventType.TOOL_CALL_ARGS,\n                    } as ToolCallArgsEvent);\n\n                    if (isValidJson(toolCall.args)) {\n                      // args is valid json, tool call streaming ends\n                      subscriber.next({\n                        toolCallId: toolCall.id,\n                        type: EventType.TOOL_CALL_END,\n                      } as ToolCallEndEvent);\n                      currentToolCall = null;\n                    }\n                  }\n                }\n              }\n            });\n        }\n\n        const chatModelRun = chatModelRuns.find(\n          (run) => run.runId === event.run_id\n        );\n        if (!chatModelRun) {\n          subscriber.next({\n            type: EventType.RUN_ERROR,\n            message: `Received a message from an unknown chat model run. Run Id: ${event.run_id}`,\n          } as RunErrorEvent);\n          continue;\n        }\n\n        if (!chatModelRun.messageId) {\n          const messageId = event.data.chunk.id;\n          chatModelRun.messageId = messageId;\n          subscriber.next({\n            messageId,\n            type: EventType.TEXT_MESSAGE_START,\n            role: \"assistant\",\n          } as TextMessageStartEvent);\n\n          const delta = event.data.chunk.content;\n\n          typeof delta === \"string\" &&\n            delta &&\n            subscriber.next({\n              messageId: chatModelRun.messageId,\n              type: EventType.TEXT_MESSAGE_CONTENT,\n              delta,\n            } as TextMessageContentEvent);\n\n          continue;\n        } else {\n          if (chatModelRun.messageId !== event.data.chunk.id) {\n            subscriber.next({\n              type: EventType.RUN_ERROR,\n              message: `Received a message of unknown message id from current run. Run Id: ${event.run_id} Message Id from current run: ${chatModelRun.messageId} Message Id from received message: ${event.data.chunk.id}`,\n            } as RunErrorEvent);\n            continue;\n          }\n\n          const delta = event.data.chunk.content;\n\n          typeof delta === \"string\" &&\n            delta &&\n            subscriber.next({\n              messageId: chatModelRun.messageId,\n              type: EventType.TEXT_MESSAGE_CONTENT,\n              delta,\n            } as TextMessageContentEvent);\n\n          continue;\n        }\n      }\n\n      if (event.event === \"on_chat_model_end\") {\n        const chatModelRun = chatModelRuns.find(\n          (run) => run.runId === event.run_id\n        );\n\n        if (!chatModelRun) {\n          subscriber.next({\n            type: EventType.RUN_ERROR,\n            message: `Received a on_chat_model_end event from an unknown chat model run. Run Id: ${event.run_id}`,\n          } as RunErrorEvent);\n          continue;\n        }\n\n        subscriber.next({\n          type: EventType.TEXT_MESSAGE_END,\n          messageId: chatModelRun.messageId,\n        } as TextMessageEndEvent);\n\n        continue;\n      }\n\n      if (event.event === \"on_chain_end\") {\n        const messages = event.data.output?.messages;\n        if (Array.isArray(messages)) {\n          const inputMessages = event.data.input?.messages;\n          const lastInputMessage = inputMessages?.[inputMessages?.length - 1];\n\n          const messageId = lastInputMessage?.id as string;\n\n          const toolCallMessages = messages\n            .filter((x) => x.id)\n            .filter((x) => x?.tool_call_id);\n\n          toolCallMessages.forEach((x) => {\n            if (handledToolCallIds.has(x.tool_call_id)) {\n              return;\n            }\n\n            subscriber.next({\n              toolCallId: x.tool_call_id,\n              type: EventType.TOOL_CALL_RESULT,\n              content: x.content,\n              messageId,\n            } as ToolCallResultEvent);\n\n            handledToolCallIds.add(x.tool_call_id);\n          });\n\n          continue;\n        }\n      }\n\n      if (\n        event.event === \"on_chain_stream\" &&\n        event.data.chunk?.__interrupt__ &&\n        Array.isArray(event.data.chunk.__interrupt__) &&\n        event.data.chunk.__interrupt__.length > 0\n      ) {\n        const rawInterrupt = event.data.chunk.__interrupt__[0];\n\n        // TODO: check if the interrupt is already set\n        interrupt = {\n          id: rawInterrupt.id,\n          // TODO: replace with actual reason\n          reason: \"agent requested interrupt\",\n          payload: rawInterrupt.value,\n        };\n      }\n    }\n\n    if (interrupt) {\n      subscriber.next({\n        type: EventType.RUN_FINISHED,\n        threadId,\n        runId,\n        outcome: \"interrupt\",\n        interrupt,\n      } as RunFinishedEvent);\n    } else {\n      subscriber.next({\n        type: EventType.RUN_FINISHED,\n        threadId,\n        runId,\n      } as RunFinishedEvent);\n    }\n\n    subscriber.complete();\n  }\n\n  clone() {\n    const workflow = this.compiledWorkflow;\n    this.compiledWorkflow = undefined;\n\n    const cloned = super.clone();\n\n    this.compiledWorkflow = workflow;\n    cloned.compiledWorkflow = workflow;\n\n    return cloned;\n  }\n}\n\nfunction aguiMessagesToLangChain(messages: Message[]): LangGraphMessage[] {\n  return messages.map((message, index) => {\n    switch (message.role) {\n      case \"user\":\n        if (typeof message.content === \"string\") {\n          return {\n            id: message.id,\n            role: message.role,\n            content: message.content,\n            type: \"human\",\n          };\n        } else {\n          return {\n            id: message.id,\n            role: message.role,\n            content: message.content.filter((m) => m.type === \"text\"),\n            type: \"human\",\n          };\n        }\n\n      case \"assistant\":\n        return {\n          id: message.id,\n          type: \"ai\",\n          role: message.role,\n          content: message.content ?? \"\",\n          tool_calls: (message.toolCalls ?? []).map((tc: ToolCall) => ({\n            id: tc.id,\n            name: tc.function.name,\n            args: JSON.parse(tc.function.arguments),\n            type: \"tool_call\",\n          })),\n        };\n      case \"system\":\n        return {\n          id: message.id,\n          role: message.role,\n          content: message.content,\n          type: \"system\",\n        };\n      case \"tool\":\n        return {\n          content: message.content,\n          role: message.role,\n          type: message.role,\n          tool_call_id: message.toolCallId,\n          id: message.id,\n        };\n      default:\n        console.error(`Message role ${message.role} is not implemented`);\n        throw new Error(\"message role is not supported.\");\n    }\n  });\n}\n\nfunction isValidJson(json: string) {\n  try {\n    JSON.parse(json);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n","import { RunAgentInput } from \"@ag-ui/client\";\nimport { DynamicStructuredTool } from \"@langchain/core/tools\";\nimport z from \"zod/v4\";\n\nexport function convertActionsToDynamicStructuredTools(\n  tools: RunAgentInput[\"tools\"]\n): DynamicStructuredTool<any>[] {\n  return tools.map(convertActionToDynamicStructuredTool);\n}\n\nexport function convertActionToDynamicStructuredTool(\n  actionInput: RunAgentInput[\"tools\"][number]\n): DynamicStructuredTool<any> {\n  return new DynamicStructuredTool({\n    name: actionInput.name,\n    description: actionInput.description,\n    schema: convertJsonSchemaToZodSchema(actionInput.parameters, true),\n    func: async () => {\n      return \"\";\n    },\n  });\n}\n\nexport function convertJsonSchemaToZodSchema(\n  jsonSchema: any,\n  required: boolean\n): z.ZodSchema {\n  if (jsonSchema.type === \"object\") {\n    const spec: { [key: string]: z.ZodSchema } = {};\n\n    if (!jsonSchema.properties || !Object.keys(jsonSchema.properties).length) {\n      return !required ? z.object(spec).optional() : z.object(spec);\n    }\n\n    for (const [key, value] of Object.entries(jsonSchema.properties)) {\n      spec[key] = convertJsonSchemaToZodSchema(\n        value,\n        jsonSchema.required ? jsonSchema.required.includes(key) : false\n      );\n    }\n    let schema = z.object(spec).describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"string\") {\n    let schema = z.string().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"number\") {\n    let schema = z.number().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"boolean\") {\n    let schema = z.boolean().describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  } else if (jsonSchema.type === \"array\") {\n    let itemSchema = convertJsonSchemaToZodSchema(jsonSchema.items, true);\n    let schema = z.array(itemSchema).describe(jsonSchema.description);\n    return required ? schema : schema.optional();\n  }\n  throw new Error(\"Invalid JSON schema\");\n}\n","import {\n  BaseCheckpointSaver,\n  Checkpoint,\n  CheckpointMetadata,\n  CheckpointTuple,\n} from \"@langchain/langgraph\";\nimport type { RunnableConfig } from \"@langchain/core/runnables\";\nimport {\n  MemoryClient,\n  IMemoryClientOptions,\n  Order,\n} from \"@cloudbase/agent-agents\";\n\n// Define types locally if not available from langgraph\ntype PendingWrite = [string, any];\ntype CheckpointPendingWrite = [string, string, any];\n\ninterface CheckpointListOptions {\n  limit?: number;\n  before?: RunnableConfig;\n  filter?: Record<string, any>;\n}\n\nexport interface TDAISaverConfig extends IMemoryClientOptions {\n  checkpointType?: string;\n  checkpointWritesType?: string;\n}\n\n/**\n * TDAISaver - LangGraph checkpoint saver implementation using TDAI Memory\n *\n * Storage Strategy:\n * - Events (NoSQL): Store checkpoint data and pending writes in separate collections\n * - Supports namespaces and parent checkpoint relationships\n */\nexport class TDAISaver extends BaseCheckpointSaver {\n  private memoryClient: MemoryClient;\n  private checkpointType: string;\n  private checkpointWritesType: string;\n\n  constructor(config: TDAISaverConfig) {\n    super();\n    const {\n      checkpointType = \"checkpoints\",\n      checkpointWritesType = \"checkpoint_writes\",\n      ...clientConfig\n    } = config;\n\n    this.memoryClient = new MemoryClient(clientConfig);\n    this.checkpointType = checkpointType;\n    this.checkpointWritesType = checkpointWritesType;\n  }\n\n  /**\n   * Retrieves a checkpoint from TDAI Memory based on the provided config.\n   * If the config contains a \"checkpoint_id\" key, the checkpoint with the matching\n   * thread ID and checkpoint ID is retrieved. Otherwise, the latest checkpoint\n   * for the given thread ID is retrieved.\n   */\n  async getTuple(config: RunnableConfig): Promise<CheckpointTuple | undefined> {\n    try {\n      const {\n        thread_id,\n        checkpoint_ns = \"\",\n        checkpoint_id,\n      } = config.configurable ?? {};\n\n      if (!thread_id) {\n        return undefined;\n      }\n\n      const query: Record<string, any> = {\n        collection: this.checkpointType,\n        checkpoint_ns,\n      };\n\n      if (checkpoint_id) {\n        query.checkpoint_id = checkpoint_id;\n      }\n\n      // Query events for checkpoint data\n      const { events = [] } = await this.memoryClient.queryEvents({\n        sessionId: thread_id,\n        where: query,\n        orderBy: { checkpoint_id: Order.DESCENDING },\n        limit: 1,\n      });\n\n      if (events.length === 0) {\n        return undefined;\n      }\n\n      const doc = events[0];\n      const configurableValues = {\n        checkpoint_ns,\n        checkpoint_id: doc.checkpoint_id,\n      };\n\n      // Get checkpoint data (stored as JSON)\n      const checkpoint: Checkpoint = doc.checkpoint;\n\n      // Get pending writes\n      const { events: serializedWrites = [] } =\n        await this.memoryClient.queryEvents({\n          sessionId: thread_id,\n          where: {\n            collection: this.checkpointWritesType,\n            ...configurableValues,\n          },\n        });\n\n      const pendingWrites: CheckpointPendingWrite[] = serializedWrites.map(\n        (serializedWrite: any) => {\n          return [\n            serializedWrite.task_id,\n            serializedWrite.channel,\n            serializedWrite.value,\n          ] as CheckpointPendingWrite;\n        }\n      );\n\n      // Get metadata (stored as JSON)\n      const metadata: CheckpointMetadata = doc.metadata || {};\n\n      return {\n        config: { configurable: configurableValues },\n        checkpoint,\n        pendingWrites,\n        metadata,\n        parentConfig:\n          doc.parent_checkpoint_id != null\n            ? {\n                configurable: {\n                  thread_id,\n                  checkpoint_ns,\n                  checkpoint_id: doc.parent_checkpoint_id,\n                },\n              }\n            : undefined,\n      };\n    } catch (error) {\n      console.error(\"Error getting checkpoint:\", error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Retrieve a list of checkpoint tuples from TDAI Memory based on the provided config.\n   * The checkpoints are ordered by checkpoint ID in descending order (newest first).\n   */\n  async *list(\n    config: RunnableConfig,\n    options?: CheckpointListOptions\n  ): AsyncGenerator<CheckpointTuple> {\n    const { limit, before, filter } = options ?? {};\n\n    if (!config?.configurable?.thread_id) {\n      throw new Error(\"Thread ID is required\");\n    }\n\n    const query: Record<string, any> = {\n      collection: this.checkpointType,\n    };\n\n    if (\n      config?.configurable?.checkpoint_ns !== undefined &&\n      config?.configurable?.checkpoint_ns !== null\n    ) {\n      query.checkpoint_ns = config.configurable.checkpoint_ns;\n    }\n\n    // Apply metadata filters\n    if (filter) {\n      Object.entries(filter).forEach(([key, value]) => {\n        query[`metadata.${key}`] = value;\n      });\n    }\n\n    // Apply before filter\n    if (before) {\n      query.checkpoint_id = { $lt: before.configurable?.checkpoint_id };\n    }\n\n    // Query events\n    const { events = [] } = await this.memoryClient.queryEvents({\n      sessionId: config?.configurable?.thread_id || \"default\",\n      where: query,\n      orderBy: { checkpoint_id: Order.DESCENDING },\n      limit: limit,\n    });\n\n    for (const doc of events) {\n      // Get checkpoint and metadata (stored directly without serialization)\n      const checkpoint: Checkpoint = doc.checkpoint;\n      const metadata: CheckpointMetadata = doc.metadata || {};\n\n      yield {\n        config: {\n          configurable: {\n            thread_id: doc.thread_id,\n            checkpoint_ns: doc.checkpoint_ns,\n            checkpoint_id: doc.checkpoint_id,\n          },\n        },\n        checkpoint,\n        metadata,\n        parentConfig: doc.parent_checkpoint_id\n          ? {\n              configurable: {\n                thread_id: doc.thread_id,\n                checkpoint_ns: doc.checkpoint_ns,\n                checkpoint_id: doc.parent_checkpoint_id,\n              },\n            }\n          : undefined,\n      };\n    }\n  }\n\n  /**\n   * Saves a checkpoint to TDAI Memory. The checkpoint is associated with the\n   * provided config and its parent config (if any).\n   */\n  async put(\n    config: RunnableConfig,\n    checkpoint: Checkpoint,\n    metadata: CheckpointMetadata\n  ): Promise<RunnableConfig> {\n    try {\n      const thread_id = config.configurable?.thread_id;\n      const checkpoint_ns = config.configurable?.checkpoint_ns ?? \"\";\n      const checkpoint_id = checkpoint.id;\n\n      if (thread_id === undefined) {\n        throw new Error(\n          `The provided config must contain a configurable field with a \"thread_id\" field.`\n        );\n      }\n\n      // Prepare document for storage (store as JSON)\n      const doc = {\n        collection: this.checkpointType,\n        checkpoint_ns,\n        checkpoint_id,\n        parent_checkpoint_id: config.configurable?.checkpoint_id,\n        checkpoint: checkpoint,\n        metadata: metadata,\n      };\n\n      const { events = [] } = await this.memoryClient.queryEvents({\n        sessionId: thread_id,\n        where: {\n          collection: this.checkpointType,\n          checkpoint_ns,\n          checkpoint_id,\n        },\n      });\n\n      if (events[0]) {\n        this.memoryClient.deleteEvent({\n          sessionId: thread_id,\n          eventId: events[0].id,\n          //   messages: doc,\n        });\n      } else {\n        await this.memoryClient.appendEvent({\n          sessionId: thread_id,\n          messages: doc,\n        });\n      }\n\n      return {\n        configurable: {\n          thread_id,\n          checkpoint_ns,\n          checkpoint_id,\n        },\n      };\n    } catch (error) {\n      console.error(\"Error saving checkpoint:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Saves intermediate writes associated with a checkpoint to TDAI Memory.\n   */\n  async putWrites(\n    config: RunnableConfig,\n    writes: PendingWrite[],\n    taskId: string\n  ): Promise<void> {\n    try {\n      const thread_id = config.configurable?.thread_id;\n      const checkpoint_ns = config.configurable?.checkpoint_ns;\n      const checkpoint_id = config.configurable?.checkpoint_id;\n\n      if (\n        thread_id === undefined ||\n        checkpoint_ns === undefined ||\n        checkpoint_id === undefined\n      ) {\n        throw new Error(\n          `The provided config must contain a configurable field with \"thread_id\", \"checkpoint_ns\" and \"checkpoint_id\" fields.`\n        );\n      }\n\n      // Process writes in parallel\n      const writePromises = writes.map(async ([channel, value], idx) => {\n        const writeDoc = {\n          collection: this.checkpointWritesType,\n          checkpoint_ns,\n          checkpoint_id,\n          task_id: taskId,\n          idx,\n          channel,\n          value: value, // Store directly as JSON\n        };\n\n        return this.memoryClient.appendEvent({\n          sessionId: thread_id,\n          messages: writeDoc,\n        });\n      });\n\n      await Promise.all(writePromises);\n    } catch (error) {\n      console.error(\"Error storing writes:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Delete all checkpoints and writes for a thread from TDAI Memory.\n   */\n  async deleteThread(threadId: string): Promise<void> {\n    try {\n      // Delete the entire session which will remove all data\n      await this.memoryClient.deleteSession({\n        sessionId: threadId,\n      });\n    } catch (error) {\n      console.error(\"Error deleting thread:\", error);\n      throw error;\n    }\n  }\n\n  /**\n   * Close the memory client connection\n   */\n  close(): void {\n    this.memoryClient.close();\n  }\n}\n\n","import {\n  BaseStore,\n  type Operation,\n  type OperationResults,\n  type ListNamespacesOperation,\n  type PutOperation,\n  type GetOperation,\n  type Item,\n  type MatchCondition,\n} from \"@langchain/langgraph\";\n\nimport { MemoryClient } from \"@cloudbase/agent-agents\";\n\n/**\n * TDAI Store configuration\n */\nexport interface TDAIStoreConfig {\n  /**\n   * TDAI Memory Client instance for long-term storage\n   */\n  memoryClient: MemoryClient;\n\n  /**\n   * Session ID for storing records\n   */\n  sessionId: string;\n\n  /**\n   * Optional namespace prefix for all operations\n   */\n  namespacePrefix?: string[];\n\n  /**\n   * TTL configuration for records\n   */\n  ttl?: {\n    defaultTtlSeconds?: number;\n    sweepIntervalMinutes?: number;\n  };\n\n  /**\n   * Whether to ensure tables/collections exist on startup\n   */\n  ensureTables?: boolean;\n\n  /**\n   * Default strategy for storing records\n   */\n  defaultStrategy?: string;\n}\n\n/**\n * Filter operators for advanced filtering\n */\nexport interface FilterOperators {\n  $eq?: unknown;\n  $ne?: unknown;\n  $gt?: number | Date;\n  $gte?: number | Date;\n  $lt?: number | Date;\n  $lte?: number | Date;\n  $in?: unknown[];\n  $nin?: unknown[];\n  $exists?: boolean;\n  $regex?: string;\n}\n\n/**\n * TDAI implementation of the BaseStore interface.\n * Uses TDAI Memory Client for long-term record storage.\n */\nexport class TDAIStore extends BaseStore {\n  private client: MemoryClient;\n  private namespacePrefix: string[];\n  private ttlConfig?: TDAIStoreConfig[\"ttl\"];\n  private ensureTables: boolean;\n  private isSetup: boolean = false;\n  private isClosed: boolean = false;\n  private sweepInterval?: NodeJS.Timeout;\n  private sessionId: string;\n  private defaultStrategy: string;\n\n  constructor(config: TDAIStoreConfig) {\n    super();\n\n    this.client = config.memoryClient;\n    this.namespacePrefix = config.namespacePrefix || [];\n    this.ttlConfig = config.ttl;\n    this.ensureTables = config.ensureTables ?? true;\n    this.sessionId = config.sessionId || \"default_session\";\n    this.defaultStrategy = config.defaultStrategy || \"store\";\n  }\n\n  /**\n   * Create a storage key from namespace and key\n   */\n  private createStorageKey(namespace: string[], key: string): string {\n    const fullNamespace = [...this.namespacePrefix, ...namespace];\n    return `${fullNamespace.join(\":\")}:${key}`;\n  }\n\n  /**\n   * Parse a storage key back to namespace and key\n   */\n  private parseStorageKey(storageKey: string): {\n    namespace: string[];\n    key: string;\n  } {\n    const parts = storageKey.split(\":\");\n    const prefixLength = this.namespacePrefix.length;\n\n    // Remove the prefix from the namespace\n    const namespace = parts.slice(prefixLength, -1);\n    const key = parts[parts.length - 1];\n\n    return { namespace, key };\n  }\n\n  /**\n   * Put an item with optional TTL.\n   */\n  async put(\n    namespace: string[],\n    key: string,\n    value: Record<string, unknown>,\n    index?: false | string[],\n    options?: { ttl?: number }\n  ): Promise<void> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    const storageKey = this.createStorageKey(namespace, key);\n\n    // Prepare the content with metadata\n    const content = JSON.stringify({\n      storageKey,\n      namespace,\n      key,\n      value,\n      index,\n      ttl: options?.ttl || this.ttlConfig?.defaultTtlSeconds,\n    });\n\n    await this.client.appendRecord({\n      sessionId: this.sessionId,\n      content,\n      strategy: this.defaultStrategy,\n    });\n  }\n\n  /**\n   * Get an item by namespace and key.\n   */\n  async get(namespace: string[], key: string): Promise<Item | null> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    const storageKey = this.createStorageKey(namespace, key);\n\n    try {\n      const { records = [] } = await this.client.searchRecords({\n        content: storageKey,\n        sessionId: this.sessionId,\n        limit: 1,\n      });\n\n      if (!records.length) {\n        return null;\n      }\n\n      const record = records[0];\n      const data = JSON.parse(record.record_content);\n\n      // Check TTL if present\n      if (data.ttl && record.created_at) {\n        const createdTime = new Date(record.created_at).getTime();\n        const now = Date.now();\n        if (now > createdTime + data.ttl * 1000) {\n          // Item has expired, delete it\n          await this.delete(namespace, key);\n          return null;\n        }\n      }\n\n      return {\n        namespace,\n        key,\n        value: data.value,\n        createdAt: new Date(record.created_at || Date.now()),\n        updatedAt: new Date(record.updated_at || Date.now()),\n      };\n    } catch (error) {\n      return null;\n    }\n  }\n\n  /**\n   * Delete an item by namespace and key.\n   */\n  async delete(namespace: string[], key: string): Promise<void> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    const storageKey = this.createStorageKey(namespace, key);\n\n    try {\n      const { records = [] } = await this.client.searchRecords({\n        content: storageKey,\n        sessionId: this.sessionId,\n        limit: 1,\n      });\n\n      const record = records[0];\n      if (record) {\n        await this.client.deleteRecord({\n          sessionId: this.sessionId,\n          recordId: record.record_id,\n        });\n      }\n    } catch (error) {\n      // Ignore errors if item doesn't exist\n    }\n  }\n\n  /**\n   * List namespaces with optional filtering.\n   */\n  async listNamespaces(\n    options: {\n      prefix?: string[];\n      suffix?: string[];\n      maxDepth?: number;\n      limit?: number;\n      offset?: number;\n    } = {}\n  ): Promise<string[][]> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    const { prefix, suffix, maxDepth, limit = 100, offset = 0 } = options;\n\n    try {\n      // Get all records to extract namespaces\n      const { records = [] } = await this.client.queryRecords({\n        limit: 1000, // Large limit to get all records\n      });\n\n      const namespaceSet = new Set<string>();\n\n      for (const record of records) {\n        try {\n          const data = JSON.parse(record.record_content);\n          if (data.namespace) {\n            const namespace = data.namespace;\n\n            // Apply prefix filter if specified\n            if (prefix && prefix.length > 0) {\n              const hasPrefix = prefix.every((p, i) => namespace[i] === p);\n              if (!hasPrefix) continue;\n            }\n\n            // Apply suffix filter if specified\n            if (suffix && suffix.length > 0) {\n              const namespaceSuffix = namespace.slice(-suffix.length);\n              if (JSON.stringify(namespaceSuffix) !== JSON.stringify(suffix)) {\n                continue;\n              }\n            }\n\n            // Apply maxDepth filter if specified\n            if (maxDepth !== undefined && namespace.length > maxDepth) {\n              continue;\n            }\n\n            namespaceSet.add(JSON.stringify(namespace));\n          }\n        } catch (error) {\n          // Skip invalid records\n        }\n      }\n\n      // Convert back to arrays and apply pagination\n      const namespaces = Array.from(namespaceSet)\n        .map((ns) => JSON.parse(ns))\n        .sort()\n        .slice(offset, offset + limit);\n\n      return namespaces;\n    } catch (error) {\n      return [];\n    }\n  }\n\n  /**\n   * Execute multiple operations in a single batch.\n   */\n  async batch<Op extends Operation[]>(\n    operations: Op\n  ): Promise<OperationResults<Op>> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    const results: unknown[] = [];\n\n    for (const operation of operations) {\n      if (\"namespacePrefix\" in operation) {\n        // SearchOperation\n        results.push(await this.executeSearch(operation));\n      } else if (\"key\" in operation && !(\"value\" in operation)) {\n        // GetOperation\n        const getOp = operation as GetOperation;\n        results.push(await this.get(getOp.namespace, getOp.key));\n      } else if (\"value\" in operation) {\n        // PutOperation\n        const putOp = operation as PutOperation & {\n          options?: { ttl?: number };\n        };\n        if (putOp.value !== null) {\n          await this.put(\n            putOp.namespace,\n            putOp.key,\n            putOp.value,\n            putOp.index,\n            putOp.options\n          );\n        }\n        results.push(undefined);\n      } else if (\"matchConditions\" in operation) {\n        // ListNamespacesOperation\n        const listOp = operation as ListNamespacesOperation;\n        results.push(await this.executeListNamespaces(listOp));\n      } else {\n        throw new Error(\n          `Unsupported operation type: ${JSON.stringify(operation)}`\n        );\n      }\n    }\n\n    return results as OperationResults<Op>;\n  }\n\n  /**\n   * Execute search operation\n   */\n  private async executeSearch(operation: any): Promise<Item[]> {\n    const { namespacePrefix, ...searchOptions } = operation;\n    return this.search(namespacePrefix, searchOptions);\n  }\n\n  /**\n   * Execute list namespaces operation\n   */\n  private async executeListNamespaces(\n    operation: ListNamespacesOperation\n  ): Promise<string[][]> {\n    const { matchConditions, maxDepth, limit = 100, offset = 0 } = operation;\n\n    // Convert match conditions to prefix/suffix filters\n    let prefix: string[] | undefined;\n    let suffix: string[] | undefined;\n\n    if (matchConditions && matchConditions.length > 0) {\n      for (const condition of matchConditions) {\n        if (condition.matchType === \"prefix\") {\n          prefix = condition.path;\n        } else if (condition.matchType === \"suffix\") {\n          suffix = condition.path;\n        }\n      }\n    }\n\n    return this.listNamespaces({\n      prefix,\n      suffix,\n      maxDepth,\n      limit,\n      offset,\n    });\n  }\n\n  /**\n   * Initialize the store.\n   */\n  async setup(): Promise<void> {\n    if (this.isSetup) return;\n\n    // Start TTL sweeper if configured\n    if (this.ttlConfig?.sweepIntervalMinutes) {\n      const intervalMs = this.ttlConfig.sweepIntervalMinutes * 60 * 1000;\n      this.sweepInterval = setInterval(async () => {\n        try {\n          await this.sweepExpiredItems();\n        } catch (error) {\n          console.error(\"Error during TTL sweep:\", error);\n        }\n      }, intervalMs);\n    }\n\n    this.isSetup = true;\n  }\n\n  /**\n   * Start the store.\n   */\n  async start(): Promise<void> {\n    if (this.ensureTables && !this.isSetup) {\n      await this.setup();\n    }\n  }\n\n  /**\n   * Stop the store and close all connections.\n   */\n  async stop(): Promise<void> {\n    if (this.isClosed) return;\n\n    if (this.sweepInterval) {\n      clearInterval(this.sweepInterval);\n      this.sweepInterval = undefined;\n    }\n\n    this.client.close();\n    this.isClosed = true;\n  }\n\n  /**\n   * Manually sweep expired items from the store.\n   */\n  async sweepExpiredItems(): Promise<number> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    try {\n      const { records = [] } = await this.client.queryRecords({\n        limit: 1000,\n      });\n\n      let cleanedCount = 0;\n      const now = Date.now();\n\n      for (const record of records) {\n        try {\n          const data = JSON.parse(record.record_content);\n          if (data.ttl && data.createdAt) {\n            const createdTime = new Date(data.createdAt).getTime();\n            if (now > createdTime + data.ttl * 1000) {\n              await this.client.deleteRecord({\n                sessionId: this.sessionId,\n                recordId: record.record_id,\n              });\n              cleanedCount++;\n            }\n          }\n        } catch (error) {\n          // Skip invalid records\n        }\n      }\n\n      return cleanedCount;\n    } catch (error) {\n      return 0;\n    }\n  }\n\n  /**\n   * Get statistics about the store.\n   */\n  async getStats(): Promise<{\n    totalItems: number;\n    expiredItems: number;\n    namespaceCount: number;\n    oldestItem: Date | null;\n    newestItem: Date | null;\n  }> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    try {\n      const { records = [] } = await this.client.queryRecords({\n        limit: 1000,\n      });\n\n      let totalItems = 0;\n      let expiredItems = 0;\n      const namespaces = new Set<string>();\n      const dates: Date[] = [];\n      const now = Date.now();\n\n      for (const record of records) {\n        try {\n          const data = JSON.parse(record.record_content);\n          totalItems++;\n\n          if (data.namespace) {\n            namespaces.add(data.namespace.join(\":\"));\n          }\n\n          if (data.createdAt) {\n            dates.push(new Date(data.createdAt));\n          }\n\n          if (data.ttl && data.createdAt) {\n            const createdTime = new Date(data.createdAt).getTime();\n            if (now > createdTime + data.ttl * 1000) {\n              expiredItems++;\n            }\n          }\n        } catch (error) {\n          // Skip invalid records\n        }\n      }\n\n      const oldestItem =\n        dates.length > 0\n          ? new Date(Math.min(...dates.map((d) => d.getTime())))\n          : null;\n      const newestItem =\n        dates.length > 0\n          ? new Date(Math.max(...dates.map((d) => d.getTime())))\n          : null;\n\n      return {\n        totalItems,\n        expiredItems,\n        namespaceCount: namespaces.size,\n        oldestItem,\n        newestItem,\n      };\n    } catch (error) {\n      return {\n        totalItems: 0,\n        expiredItems: 0,\n        namespaceCount: 0,\n        oldestItem: null,\n        newestItem: null,\n      };\n    }\n  }\n\n  /**\n   * Search for items in the store with support for text search and filtering.\n   */\n  async search(\n    namespacePrefix: string[],\n    options: {\n      /**\n       * Filter conditions with support for advanced operators.\n       */\n      filter?: Record<\n        string,\n        string | number | boolean | null | FilterOperators\n      >;\n\n      /**\n       * Natural language search query.\n       */\n      query?: string;\n\n      /**\n       * Maximum number of results to return.\n       * @default 10\n       */\n      limit?: number;\n\n      /**\n       * Number of results to skip for pagination.\n       * @default 0\n       */\n      offset?: number;\n\n      /**\n       * Whether to refresh TTL for returned items.\n       */\n      refreshTtl?: boolean;\n    } = {}\n  ): Promise<Item[]> {\n    if (!this.isSetup && this.ensureTables) {\n      await this.setup();\n    }\n\n    const { filter, query, limit = 10, offset = 0, refreshTtl } = options;\n\n    try {\n      // Build search query\n      const namespaceKey = [...this.namespacePrefix, ...namespacePrefix].join(\n        \":\"\n      );\n\n      let searchResult;\n      if (query) {\n        searchResult = await this.client.searchRecords({\n          content: query,\n          limit: limit + offset,\n        });\n      } else {\n        searchResult = await this.client.queryRecords({\n          limit: limit + offset,\n        });\n      }\n\n      const items: Item[] = [];\n      const now = Date.now();\n\n      if (searchResult.records) {\n        for (const record of searchResult.records.slice(\n          offset,\n          offset + limit\n        )) {\n          try {\n            const data = JSON.parse(record.record_content);\n\n            // Filter by namespace prefix\n            if (namespaceKey && !data.storageKey?.startsWith(namespaceKey)) {\n              continue;\n            }\n\n            // Check TTL\n            if (data.ttl && data.createdAt) {\n              const createdTime = new Date(data.createdAt).getTime();\n              if (now > createdTime + data.ttl * 1000) {\n                continue; // Skip expired items\n              }\n            }\n\n            // Apply filters (basic implementation)\n            if (filter) {\n              let matches = true;\n              for (const [key, value] of Object.entries(filter)) {\n                if (data.value[key] !== value) {\n                  matches = false;\n                  break;\n                }\n              }\n              if (!matches) continue;\n            }\n\n            const item: Item = {\n              namespace: data.namespace,\n              key: data.key,\n              value: data.value,\n              createdAt: new Date(record.created_at || Date.now()),\n              updatedAt: new Date(record.updated_at || Date.now()),\n            };\n\n            items.push(item);\n\n            // Refresh TTL if requested\n            if (refreshTtl && this.ttlConfig?.defaultTtlSeconds) {\n              await this.put(data.namespace, data.key, data.value, undefined, {\n                ttl: this.ttlConfig.defaultTtlSeconds,\n              });\n            }\n          } catch (error) {\n            // Skip invalid records\n          }\n        }\n      }\n\n      return items;\n    } catch (error) {\n      return [];\n    }\n  }\n}\n\n"],"mappings":"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","names":["messages"]}