import { MemoryClient, IMemoryClientOptions } from '@cloudbase/agent-agents';
import { BaseStore } from '@langchain/core/stores';
import * as _cloudbase_agent_tools from '@cloudbase/agent-tools';
import { BaseTool } from '@cloudbase/agent-tools';
import * as langchain from 'langchain';
import { createAgent } from 'langchain';
import { StructuredTool } from '@langchain/core/tools';
import { z } from 'zod/v4';
import { AgentConfig } from '@ag-ui/client';
import { LanggraphAgent } from '@cloudbase/agent-adapter-langgraph';
import { BaseListChatMessageHistory } from '@langchain/core/chat_history';
import { BaseMessage } from '@langchain/core/messages';

/**
 * Configuration options for TDAIStore
 */
interface TDAIStoreInput {
    /**
     * The TDAI Memory Client instance
     */
    client: MemoryClient;
    /**
     * The amount of keys to retrieve per batch when yielding keys.
     * @default 1000
     */
    yieldKeysScanBatchSize?: number;
    /**
     * The namespace to use for the keys in the database.
     */
    namespace?: string;
    /**
     * Default session ID for storing records
     */
    defaultSessionId?: string;
    /**
     * Default strategy for storing records
     */
    defaultStrategy?: string;
    /**
     * TTL for records in seconds
     */
    ttlSeconds?: number;
}
/**
 * TDAI implementation of the BaseStore for key-value caching.
 * Uses TDAI Memory Client for persistent storage.
 *
 * @example
 * ```typescript
 * const client = new MemoryClient({
 *   endpoint: "https://memory.tdai.tencentyun.com",
 *   apiKey: "your-api-key",
 *   memoryId: "your-memory-id",
 * });
 *
 * const store = new TDAIStore({
 *   client,
 *   namespace: "cache",
 * });
 *
 * const encoder = new TextEncoder();
 * await store.mset([
 *   ["key1", encoder.encode("value1")],
 *   ["key2", encoder.encode("value2")],
 * ]);
 *
 * const values = await store.mget(["key1", "key2"]);
 * ```
 */
declare class TDAIStore extends BaseStore<string, Uint8Array> {
    lc_namespace: string[];
    protected client: MemoryClient;
    protected namespace?: string;
    protected yieldKeysScanBatchSize: number;
    protected defaultSessionId: string;
    protected defaultStrategy: string;
    protected ttlSeconds?: number;
    private sessionCache?;
    constructor(fields: TDAIStoreInput);
    /**
     * Get prefixed key with namespace
     */
    private _getPrefixedKey;
    /**
     * Remove prefix from key
     */
    private _getDeprefixedKey;
    /**
     * Get or create session for the store
     */
    private _getSession;
    /**
     * Create record content for storage
     */
    private _createRecordContent;
    /**
     * Parse record content from storage
     */
    private _parseRecordContent;
    /**
     * Gets multiple keys from the TDAI store.
     * @param keys Array of keys to be retrieved.
     * @returns An array of retrieved values.
     */
    mget(keys: string[]): Promise<(Uint8Array | undefined)[]>;
    /**
     * Sets multiple keys in the TDAI store.
     * @param keyValuePairs Array of key-value pairs to be set.
     * @returns Promise that resolves when all keys have been set.
     */
    mset(keyValuePairs: [string, Uint8Array][]): Promise<void>;
    /**
     * Deletes multiple keys from the TDAI store.
     * @param keys Array of keys to be deleted.
     * @returns Promise that resolves when all keys have been deleted.
     */
    mdelete(keys: string[]): Promise<void>;
    /**
     * Yields keys from the TDAI store.
     * @param prefix Optional prefix to filter the keys.
     * @returns An AsyncGenerator that yields keys from the TDAI store.
     */
    yieldKeys(prefix?: string): AsyncGenerator<string>;
    /**
     * Close the TDAI client connection
     */
    close(): void;
}

/**
 * Convert AG-Kit BaseTool to LangChain DynamicStructuredTool
 *
 * @param agkitTool - AG-Kit BaseTool instance
 * @param implFunc - Optional custom implementation function
 * @returns LangChain DynamicStructuredTool instance
 */
declare function convert2LangChain(agkitTool: BaseTool, implFunc?: (tool: BaseTool) => Function): langchain.DynamicTool<any>;
/**
 * Convert LangChain Tool to AG-Kit DynamicTool
 *
 * @param langchainTool - LangChain tool instance (DynamicStructuredTool or StructuredTool)
 * @returns AG-Kit DynamicTool instance
 */
declare function convertLangChain2AGKit(langchainTool: StructuredTool): _cloudbase_agent_tools.DynamicTool<any, Record<string, unknown>, any>;

declare class LangchainAgent extends LanggraphAgent {
    constructor(config: AgentConfig & {
        agent: ReturnType<typeof createAgent>;
    });
}
declare function clientTools(): langchain.AgentMiddleware<z.ZodObject<{
    client: z.ZodObject<{
        tools: z.ZodArray<z.ZodObject<{
            name: z.ZodString;
            description: z.ZodString;
            schema: z.ZodAny;
        }, z.core.$strip>>;
    }, z.core.$strip>;
}, z.core.$strip>, undefined, any>;

declare class TDAIChatHistory extends BaseListChatMessageHistory {
    lc_namespace: string[];
    client: MemoryClient;
    private sessionId;
    constructor(options: IMemoryClientOptions & {
        sessionId: string;
    });
    getMessages(): Promise<BaseMessage[]>;
    /**
     * Method to add a new message to the Firestore collection. The message is
     * passed as a BaseMessage object.
     * @param message The message to be added as a BaseMessage object.
     */
    addMessage(message: BaseMessage): Promise<void>;
    private appendMessage;
    /**
     * Method to delete all messages from the Firestore collection associated
     * with the current session.
     */
    clear(): Promise<void>;
}

export { LangchainAgent, TDAIChatHistory, TDAIStore, type TDAIStoreInput, clientTools, convert2LangChain, convertLangChain2AGKit };
