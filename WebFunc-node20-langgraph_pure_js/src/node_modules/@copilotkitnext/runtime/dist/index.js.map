{"version":3,"sources":["../src/index.ts","../package.json","../src/runner/agent-runner.ts","../src/runner/in-memory.ts","../src/runtime.ts","../src/endpoints/hono.ts","../src/handlers/handle-run.ts","../src/handlers/header-utils.ts","../src/handlers/get-runtime-info.ts","../src/handlers/handle-transcribe.ts","../src/middleware.ts","../src/handlers/handle-connect.ts","../src/handlers/handle-stop.ts","../src/endpoints/hono-single.ts","../src/endpoints/single-route-helpers.ts","../src/runner/index.ts","../src/transcription-service/transcription-service.ts"],"sourcesContent":["export * from \"./runtime\";\nexport * from \"./endpoints\";\n\n// Export agent runners and base types\nexport * from \"./runner\";\n\n// Export transcription services\nexport * from \"./transcription-service/transcription-service\";\n","{\n  \"name\": \"@copilotkitnext/runtime\",\n  \"version\": \"1.51.3\",\n  \"description\": \"Server-side runtime package for CopilotKit2\",\n  \"main\": \"dist/index.js\",\n  \"types\": \"dist/index.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.mjs\",\n      \"require\": \"./dist/index.js\"\n    },\n    \"./express\": {\n      \"types\": \"./dist/express.d.ts\",\n      \"import\": \"./dist/express.mjs\",\n      \"require\": \"./dist/express.js\"\n    }\n  },\n  \"publishConfig\": {\n    \"access\": \"public\"\n  },\n  \"scripts\": {\n    \"build\": \"tsup\",\n    \"dev\": \"tsup --watch\",\n    \"lint\": \"eslint .\",\n    \"check-types\": \"tsc --noEmit\",\n    \"clean\": \"rm -rf dist\",\n    \"test\": \"vitest run\",\n    \"test:watch\": \"vitest\",\n    \"test:coverage\": \"vitest run --coverage\"\n  },\n  \"devDependencies\": {\n    \"@copilotkitnext/eslint-config\": \"workspace:*\",\n    \"@copilotkitnext/typescript-config\": \"workspace:*\",\n    \"@types/cors\": \"^2.8.17\",\n    \"@types/express\": \"^4.17.21\",\n    \"@types/node\": \"^22.15.3\",\n    \"eslint\": \"^9.30.0\",\n    \"supertest\": \"^7.1.1\",\n    \"tsup\": \"^8.5.0\",\n    \"typescript\": \"5.8.2\",\n    \"vitest\": \"^3.0.5\"\n  },\n  \"dependencies\": {\n    \"@ag-ui/client\": \"0.0.42\",\n    \"@ag-ui/core\": \"0.0.42\",\n    \"@ag-ui/encoder\": \"0.0.42\",\n    \"@copilotkitnext/shared\": \"workspace:*\",\n    \"cors\": \"^2.8.5\",\n    \"express\": \"^4.21.2\",\n    \"hono\": \"^4.11.4\",\n    \"rxjs\": \"7.8.1\"\n  },\n  \"peerDependencies\": {\n    \"@ag-ui/client\": \"0.0.42\",\n    \"@ag-ui/core\": \"0.0.42\",\n    \"@ag-ui/encoder\": \"0.0.42\",\n    \"@copilotkitnext/shared\": \"workspace:*\"\n  },\n  \"peerDependenciesMeta\": {},\n  \"engines\": {\n    \"node\": \">=18\"\n  }\n}\n","import { AbstractAgent, BaseEvent, RunAgentInput } from \"@ag-ui/client\";\nimport { Observable } from \"rxjs\";\n\nexport interface AgentRunnerRunRequest {\n  threadId: string;\n  agent: AbstractAgent;\n  input: RunAgentInput;\n}\n\nexport interface AgentRunnerConnectRequest {\n  threadId: string;\n  headers?: Record<string, string>;\n}\n\nexport interface AgentRunnerIsRunningRequest {\n  threadId: string;\n}\n\nexport interface AgentRunnerStopRequest {\n  threadId: string;\n}\n\nexport abstract class AgentRunner {\n  abstract run(request: AgentRunnerRunRequest): Observable<BaseEvent>;\n  abstract connect(request: AgentRunnerConnectRequest): Observable<BaseEvent>;\n  abstract isRunning(request: AgentRunnerIsRunningRequest): Promise<boolean>;\n  abstract stop(request: AgentRunnerStopRequest): Promise<boolean | undefined>;\n}\n","import {\n  AgentRunner,\n  AgentRunnerConnectRequest,\n  AgentRunnerIsRunningRequest,\n  AgentRunnerRunRequest,\n  type AgentRunnerStopRequest,\n} from \"./agent-runner\";\nimport { Observable, ReplaySubject } from \"rxjs\";\nimport {\n  AbstractAgent,\n  BaseEvent,\n  EventType,\n  MessagesSnapshotEvent,\n  RunStartedEvent,\n  compactEvents,\n} from \"@ag-ui/client\";\nimport { finalizeRunEvents } from \"@copilotkitnext/shared\";\n\ninterface HistoricRun {\n  threadId: string;\n  runId: string;\n  parentRunId: string | null;\n  events: BaseEvent[];\n  createdAt: number;\n}\n\nclass InMemoryEventStore {\n  constructor(public threadId: string) {}\n\n  /** The subject that current consumers subscribe to. */\n  subject: ReplaySubject<BaseEvent> | null = null;\n\n  /** True while a run is actively producing events. */\n  isRunning = false;\n\n  /** Current run ID */\n  currentRunId: string | null = null;\n\n  /** Historic completed runs */\n  historicRuns: HistoricRun[] = [];\n\n  /** Currently running agent instance (if any). */\n  agent: AbstractAgent | null = null;\n\n  /** Subject returned from run() while the run is active. */\n  runSubject: ReplaySubject<BaseEvent> | null = null;\n\n  /** True once stop() has been requested but the run has not yet finalized. */\n  stopRequested = false;\n\n  /** Reference to the events emitted in the current run. */\n  currentEvents: BaseEvent[] | null = null;\n}\n\n// Use a symbol key on globalThis to survive hot reloads in development\nconst GLOBAL_STORE_KEY = Symbol.for(\"@copilotkitnext/runtime/in-memory-store\");\n\ninterface GlobalStoreData {\n  stores: Map<string, InMemoryEventStore>;\n  historicRunsBackup: Map<string, HistoricRun[]>;\n}\n\nfunction getGlobalStore(): Map<string, InMemoryEventStore> {\n  const globalAny = globalThis as unknown as Record<symbol, GlobalStoreData>;\n\n  if (!globalAny[GLOBAL_STORE_KEY]) {\n    globalAny[GLOBAL_STORE_KEY] = {\n      stores: new Map<string, InMemoryEventStore>(),\n      historicRunsBackup: new Map<string, HistoricRun[]>(),\n    };\n  }\n\n  const data = globalAny[GLOBAL_STORE_KEY];\n\n  // Restore historic runs from backup after hot reload\n  // (when stores map is empty but backup has data)\n  if (data.stores.size === 0 && data.historicRunsBackup.size > 0) {\n    for (const [threadId, historicRuns] of data.historicRunsBackup) {\n      const store = new InMemoryEventStore(threadId);\n      store.historicRuns = historicRuns;\n      data.stores.set(threadId, store);\n    }\n  }\n\n  return data.stores;\n}\n\nfunction backupHistoricRuns(threadId: string, historicRuns: HistoricRun[]): void {\n  const globalAny = globalThis as unknown as Record<symbol, GlobalStoreData>;\n  if (globalAny[GLOBAL_STORE_KEY]) {\n    globalAny[GLOBAL_STORE_KEY].historicRunsBackup.set(threadId, historicRuns);\n  }\n}\n\nconst GLOBAL_STORE = getGlobalStore();\n\nexport class InMemoryAgentRunner extends AgentRunner {\n  run(request: AgentRunnerRunRequest): Observable<BaseEvent> {\n    let existingStore = GLOBAL_STORE.get(request.threadId);\n    if (!existingStore) {\n      existingStore = new InMemoryEventStore(request.threadId);\n      GLOBAL_STORE.set(request.threadId, existingStore);\n    }\n    const store = existingStore; // Now store is const and non-null\n\n    if (store.isRunning) {\n      throw new Error(\"Thread already running\");\n    }\n    store.isRunning = true;\n    store.currentRunId = request.input.runId;\n    store.agent = request.agent;\n    store.stopRequested = false;\n\n    // Track seen message IDs and current run events for this run\n    const seenMessageIds = new Set<string>();\n    const currentRunEvents: BaseEvent[] = [];\n    store.currentEvents = currentRunEvents;\n\n    // Get all previously seen message IDs from historic runs\n    const historicMessageIds = new Set<string>();\n    for (const run of store.historicRuns) {\n      for (const event of run.events) {\n        if (\"messageId\" in event && typeof event.messageId === \"string\") {\n          historicMessageIds.add(event.messageId);\n        }\n        if (event.type === EventType.RUN_STARTED) {\n          const runStarted = event as RunStartedEvent;\n          const messages = runStarted.input?.messages ?? [];\n          for (const message of messages) {\n            historicMessageIds.add(message.id);\n          }\n        }\n      }\n    }\n\n    const nextSubject = new ReplaySubject<BaseEvent>(Infinity);\n    const prevSubject = store.subject;\n\n    // Update the store's subject immediately\n    store.subject = nextSubject;\n\n    // Create a subject for run() return value\n    const runSubject = new ReplaySubject<BaseEvent>(Infinity);\n    store.runSubject = runSubject;\n\n    // Helper function to run the agent and handle errors\n    const runAgent = async () => {\n      // Get parent run ID for chaining\n      const lastRun = store.historicRuns[store.historicRuns.length - 1];\n      const parentRunId = lastRun?.runId ?? null;\n\n      try {\n        await request.agent.runAgent(request.input, {\n          onEvent: ({ event }) => {\n            let processedEvent: BaseEvent = event;\n            if (event.type === EventType.RUN_STARTED) {\n              const runStartedEvent = event as RunStartedEvent;\n              if (!runStartedEvent.input) {\n                const sanitizedMessages = request.input.messages\n                  ? request.input.messages.filter(\n                      (message) => !historicMessageIds.has(message.id),\n                    )\n                  : undefined;\n                const updatedInput = {\n                  ...request.input,\n                  ...(sanitizedMessages !== undefined\n                    ? { messages: sanitizedMessages }\n                    : {}),\n                };\n                processedEvent = {\n                  ...runStartedEvent,\n                  input: updatedInput,\n                } as RunStartedEvent;\n              }\n            }\n\n            runSubject.next(processedEvent); // For run() return - only agent events\n            nextSubject.next(processedEvent); // For connect() / store - all events\n            currentRunEvents.push(processedEvent); // Accumulate for storage\n          },\n          onNewMessage: ({ message }) => {\n            // Called for each new message\n            if (!seenMessageIds.has(message.id)) {\n              seenMessageIds.add(message.id);\n            }\n          },\n          onRunStartedEvent: () => {\n            // Mark any messages from the input as seen so they aren't emitted twice\n            if (request.input.messages) {\n              for (const message of request.input.messages) {\n                if (!seenMessageIds.has(message.id)) {\n                  seenMessageIds.add(message.id);\n                }\n              }\n            }\n          },\n        });\n\n        const appendedEvents = finalizeRunEvents(currentRunEvents, {\n          stopRequested: store.stopRequested,\n        });\n        for (const event of appendedEvents) {\n          runSubject.next(event);\n          nextSubject.next(event);\n        }\n\n        // Store the completed run in memory with ONLY its events\n        if (store.currentRunId) {\n          // Compact the events before storing (like SQLite does)\n          const compactedEvents = compactEvents(currentRunEvents);\n\n          store.historicRuns.push({\n            threadId: request.threadId,\n            runId: store.currentRunId,\n            parentRunId,\n            events: compactedEvents,\n            createdAt: Date.now(),\n          });\n\n          // Backup for hot reload survival\n          backupHistoricRuns(request.threadId, store.historicRuns);\n        }\n\n        // Complete the run\n        store.currentEvents = null;\n        store.currentRunId = null;\n        store.agent = null;\n        store.runSubject = null;\n        store.stopRequested = false;\n        store.isRunning = false;\n        runSubject.complete();\n        nextSubject.complete();\n      } catch {\n        const appendedEvents = finalizeRunEvents(currentRunEvents, {\n          stopRequested: store.stopRequested,\n        });\n        for (const event of appendedEvents) {\n          runSubject.next(event);\n          nextSubject.next(event);\n        }\n\n        // Store the run even if it failed (partial events)\n        if (store.currentRunId && currentRunEvents.length > 0) {\n          // Compact the events before storing (like SQLite does)\n          const compactedEvents = compactEvents(currentRunEvents);\n          store.historicRuns.push({\n            threadId: request.threadId,\n            runId: store.currentRunId,\n            parentRunId,\n            events: compactedEvents,\n            createdAt: Date.now(),\n          });\n\n          // Backup for hot reload survival\n          backupHistoricRuns(request.threadId, store.historicRuns);\n        }\n\n        // Complete the run\n        store.currentEvents = null;\n        store.currentRunId = null;\n        store.agent = null;\n        store.runSubject = null;\n        store.stopRequested = false;\n        store.isRunning = false;\n        runSubject.complete();\n        nextSubject.complete();\n      }\n    };\n\n    // Bridge previous events if they exist\n    if (prevSubject) {\n      prevSubject.subscribe({\n        next: (e) => nextSubject.next(e),\n        error: (err) => nextSubject.error(err),\n        complete: () => {\n          // Don't complete nextSubject here - it needs to stay open for new events\n        },\n      });\n    }\n\n    // Start the agent execution immediately (not lazily)\n    runAgent();\n\n    // Return the run subject (only agent events, no injected messages)\n    return runSubject.asObservable();\n  }\n\n  connect(request: AgentRunnerConnectRequest): Observable<BaseEvent> {\n    const store = GLOBAL_STORE.get(request.threadId);\n    const connectionSubject = new ReplaySubject<BaseEvent>(Infinity);\n\n    if (!store) {\n      // No store means no events\n      connectionSubject.complete();\n      return connectionSubject.asObservable();\n    }\n\n    // Collect all historic events from memory\n    const allHistoricEvents: BaseEvent[] = [];\n    for (const run of store.historicRuns) {\n      allHistoricEvents.push(...run.events);\n    }\n\n    // Apply compaction to all historic events together (like SQLite)\n    const compactedEvents = compactEvents(allHistoricEvents);\n\n    // Emit compacted events and track message IDs\n    const emittedMessageIds = new Set<string>();\n    for (const event of compactedEvents) {\n      connectionSubject.next(event);\n      if (\"messageId\" in event && typeof event.messageId === \"string\") {\n        emittedMessageIds.add(event.messageId);\n      }\n    }\n\n    // Bridge active run to connection if exists\n    if (store.subject && (store.isRunning || store.stopRequested)) {\n      store.subject.subscribe({\n        next: (event) => {\n          // Skip message events that we've already emitted from historic\n          if (\n            \"messageId\" in event &&\n            typeof event.messageId === \"string\" &&\n            emittedMessageIds.has(event.messageId)\n          ) {\n            return;\n          }\n          connectionSubject.next(event);\n        },\n        complete: () => connectionSubject.complete(),\n        error: (err) => connectionSubject.error(err),\n      });\n    } else {\n      // No active run, complete after historic events\n      connectionSubject.complete();\n    }\n\n    return connectionSubject.asObservable();\n  }\n\n  isRunning(request: AgentRunnerIsRunningRequest): Promise<boolean> {\n    const store = GLOBAL_STORE.get(request.threadId);\n    return Promise.resolve(store?.isRunning ?? false);\n  }\n\n  stop(request: AgentRunnerStopRequest): Promise<boolean | undefined> {\n    const store = GLOBAL_STORE.get(request.threadId);\n    if (!store || !store.isRunning) {\n      return Promise.resolve(false);\n    }\n    if (store.stopRequested) {\n      return Promise.resolve(false);\n    }\n\n    store.stopRequested = true;\n    store.isRunning = false;\n\n    const agent = store.agent;\n    if (!agent) {\n      store.stopRequested = false;\n      store.isRunning = false;\n      return Promise.resolve(false);\n    }\n\n    try {\n      agent.abortRun();\n      return Promise.resolve(true);\n    } catch (error) {\n      console.error(\"Failed to abort agent run\", error);\n      store.stopRequested = false;\n      store.isRunning = true;\n      return Promise.resolve(false);\n    }\n  }\n}\n","import { MaybePromise, NonEmptyRecord } from \"@copilotkitnext/shared\";\nimport { AbstractAgent } from \"@ag-ui/client\";\nimport pkg from \"../package.json\";\nimport type {\n  BeforeRequestMiddleware,\n  AfterRequestMiddleware,\n} from \"./middleware\";\nimport { TranscriptionService } from \"./transcription-service/transcription-service\";\nimport { AgentRunner } from \"./runner/agent-runner\";\nimport { InMemoryAgentRunner } from \"./runner/in-memory\";\n\nexport const VERSION = pkg.version;\n\n/**\n * Options used to construct a `CopilotRuntime` instance.\n */\nexport interface CopilotRuntimeOptions {\n  /** Map of available agents (loaded lazily is fine). */\n  agents: MaybePromise<NonEmptyRecord<Record<string, AbstractAgent>>>;\n  /** The runner to use for running agents. */\n  runner?: AgentRunner;\n  /** Optional transcription service for audio processing. */\n  transcriptionService?: TranscriptionService;\n  /** Optional *before* middleware – callback function or webhook URL. */\n  beforeRequestMiddleware?: BeforeRequestMiddleware;\n  /** Optional *after* middleware – callback function or webhook URL. */\n  afterRequestMiddleware?: AfterRequestMiddleware;\n}\n\n/**\n * Central runtime object passed to all request handlers.\n */\nexport class CopilotRuntime {\n  public agents: CopilotRuntimeOptions[\"agents\"];\n  public transcriptionService: CopilotRuntimeOptions[\"transcriptionService\"];\n  public beforeRequestMiddleware: CopilotRuntimeOptions[\"beforeRequestMiddleware\"];\n  public afterRequestMiddleware: CopilotRuntimeOptions[\"afterRequestMiddleware\"];\n  public runner: AgentRunner;\n\n  constructor({\n    agents,\n    transcriptionService,\n    beforeRequestMiddleware,\n    afterRequestMiddleware,\n    runner,\n  }: CopilotRuntimeOptions) {\n    this.agents = agents;\n    this.transcriptionService = transcriptionService;\n    this.beforeRequestMiddleware = beforeRequestMiddleware;\n    this.afterRequestMiddleware = afterRequestMiddleware;\n    this.runner = runner ?? new InMemoryAgentRunner();\n  }\n}\n","import { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\nimport { CopilotRuntime } from \"../runtime\";\nimport { handleRunAgent } from \"../handlers/handle-run\";\nimport { handleGetRuntimeInfo } from \"../handlers/get-runtime-info\";\nimport { handleTranscribe } from \"../handlers/handle-transcribe\";\nimport { logger } from \"@copilotkitnext/shared\";\nimport { callBeforeRequestMiddleware, callAfterRequestMiddleware } from \"../middleware\";\nimport { handleConnectAgent } from \"../handlers/handle-connect\";\nimport { handleStopAgent } from \"../handlers/handle-stop\";\n\n/**\n * CORS configuration for CopilotKit endpoints.\n * When using credentials (e.g., HTTP-only cookies), you must specify an explicit origin.\n */\nexport interface CopilotEndpointCorsConfig {\n  /**\n   * Allowed origin(s) for CORS. Can be:\n   * - A string: exact origin (e.g., \"https://myapp.com\")\n   * - An array: list of allowed origins\n   * - A function: dynamic origin resolution\n   *\n   * Note: When credentials is true, origin cannot be \"*\"\n   */\n  origin: string | string[] | ((origin: string, c: any) => string | undefined | null);\n  /**\n   * Whether to allow credentials (cookies, HTTP authentication).\n   * When true, origin must be explicitly specified (not \"*\").\n   */\n  credentials?: boolean;\n}\n\ninterface CopilotEndpointParams {\n  runtime: CopilotRuntime;\n  basePath: string;\n  /**\n   * Optional CORS configuration. When not provided, defaults to allowing all origins without credentials.\n   * To support HTTP-only cookies, provide cors config with credentials: true and explicit origin.\n   */\n  cors?: CopilotEndpointCorsConfig;\n}\n\n// Define the context variables type\ntype CopilotEndpointContext = {\n  Variables: {\n    modifiedRequest?: Request;\n  };\n};\n\nexport function createCopilotEndpoint({ runtime, basePath, cors: corsConfig }: CopilotEndpointParams) {\n  const app = new Hono<CopilotEndpointContext>();\n\n  return app\n    .basePath(basePath)\n    .use(\n      \"*\",\n      cors({\n        origin: corsConfig?.origin ?? \"*\",\n        allowMethods: [\"GET\", \"HEAD\", \"PUT\", \"POST\", \"DELETE\", \"PATCH\", \"OPTIONS\"],\n        allowHeaders: [\"*\"],\n        credentials: corsConfig?.credentials ?? false,\n      }),\n    )\n    .use(\"*\", async (c, next) => {\n      const request = c.req.raw;\n      const path = c.req.path;\n\n      try {\n        const maybeModifiedRequest = await callBeforeRequestMiddleware({\n          runtime,\n          request,\n          path,\n        });\n        if (maybeModifiedRequest) {\n          c.set(\"modifiedRequest\", maybeModifiedRequest);\n        }\n      } catch (error) {\n        logger.error({ err: error, url: request.url, path }, \"Error running before request middleware\");\n        if (error instanceof Response) {\n          return error;\n        }\n        throw error;\n      }\n\n      await next();\n    })\n    .use(\"*\", async (c, next) => {\n      await next();\n\n      const response = c.res;\n      const path = c.req.path;\n\n      // Non-blocking after middleware\n      callAfterRequestMiddleware({\n        runtime,\n        response,\n        path,\n      }).catch((error) => {\n        logger.error({ err: error, url: c.req.url, path }, \"Error running after request middleware\");\n      });\n    })\n    .post(\"/agent/:agentId/run\", async (c) => {\n      const agentId = c.req.param(\"agentId\");\n      const request = c.get(\"modifiedRequest\") || c.req.raw;\n\n      try {\n        return await handleRunAgent({\n          runtime,\n          request,\n          agentId,\n        });\n      } catch (error) {\n        logger.error({ err: error, url: request.url, path: c.req.path }, \"Error running request handler\");\n        throw error;\n      }\n    })\n    .post(\"/agent/:agentId/connect\", async (c) => {\n      const agentId = c.req.param(\"agentId\");\n      const request = c.get(\"modifiedRequest\") || c.req.raw;\n\n      try {\n        return await handleConnectAgent({\n          runtime,\n          request,\n          agentId,\n        });\n      } catch (error) {\n        logger.error({ err: error, url: request.url, path: c.req.path }, \"Error running request handler\");\n        throw error;\n      }\n    })\n\n    .post(\"/agent/:agentId/stop/:threadId\", async (c) => {\n      const agentId = c.req.param(\"agentId\");\n      const threadId = c.req.param(\"threadId\");\n      const request = c.get(\"modifiedRequest\") || c.req.raw;\n\n      try {\n        return await handleStopAgent({\n          runtime,\n          request,\n          agentId,\n          threadId,\n        });\n      } catch (error) {\n        logger.error({ err: error, url: request.url, path: c.req.path }, \"Error running request handler\");\n        throw error;\n      }\n    })\n    .get(\"/info\", async (c) => {\n      const request = c.get(\"modifiedRequest\") || c.req.raw;\n\n      try {\n        return await handleGetRuntimeInfo({\n          runtime,\n          request,\n        });\n      } catch (error) {\n        logger.error({ err: error, url: request.url, path: c.req.path }, \"Error running request handler\");\n        throw error;\n      }\n    })\n    .post(\"/transcribe\", async (c) => {\n      const request = c.get(\"modifiedRequest\") || c.req.raw;\n\n      try {\n        return await handleTranscribe({\n          runtime,\n          request,\n        });\n      } catch (error) {\n        logger.error({ err: error, url: request.url, path: c.req.path }, \"Error running request handler\");\n        throw error;\n      }\n    })\n    .notFound((c) => {\n      return c.json({ error: \"Not found\" }, 404);\n    });\n\n  // return app;\n}\n","import {\n  AbstractAgent,\n  HttpAgent,\n  RunAgentInput,\n  RunAgentInputSchema,\n} from \"@ag-ui/client\";\nimport { EventEncoder } from \"@ag-ui/encoder\";\nimport { CopilotRuntime } from \"../runtime\";\nimport { extractForwardableHeaders } from \"./header-utils\";\n\ninterface RunAgentParameters {\n  request: Request;\n  runtime: CopilotRuntime;\n  agentId: string;\n}\n\nexport async function handleRunAgent({\n  runtime,\n  request,\n  agentId,\n}: RunAgentParameters) {\n  try {\n    const agents = await runtime.agents;\n\n    // Check if the requested agent exists\n    if (!agents[agentId]) {\n      return new Response(\n        JSON.stringify({\n          error: \"Agent not found\",\n          message: `Agent '${agentId}' does not exist`,\n        }),\n        {\n          status: 404,\n          headers: { \"Content-Type\": \"application/json\" },\n        }\n      );\n    }\n\n    const registeredAgent = agents[agentId] as AbstractAgent;\n    const agent = registeredAgent.clone() as AbstractAgent;\n\n    if (agent && \"headers\" in agent) {\n      const forwardableHeaders = extractForwardableHeaders(request);\n      agent.headers = {\n        ...agent.headers as Record<string, string>,\n        ...forwardableHeaders\n      };\n    }\n\n    const stream = new TransformStream();\n    const writer = stream.writable.getWriter();\n    const encoder = new EventEncoder();\n    let streamClosed = false;\n\n    // Process the request in the background\n    (async () => {\n      let input: RunAgentInput;\n      try {\n        const requestBody = await request.json();\n        input = RunAgentInputSchema.parse(requestBody);\n      } catch {\n        return new Response(\n          JSON.stringify({\n            error: \"Invalid request body\",\n          }),\n          { status: 400 }\n        );\n      }\n\n      agent.setMessages(input.messages);\n      agent.setState(input.state);\n      agent.threadId = input.threadId;\n\n      runtime.runner\n        .run({\n          threadId: input.threadId,\n          agent,\n          input,\n        })\n        .subscribe({\n          next: async (event) => {\n            if (!request.signal.aborted && !streamClosed) {\n              try {\n                await writer.write(encoder.encode(event));\n              } catch (error) {\n                if (error instanceof Error && error.name === 'AbortError') {\n                  streamClosed = true;\n                }\n              }\n            }\n          },\n          error: async (error) => {\n            console.error(\"Error running agent:\", error);\n            if (!streamClosed) {\n              try {\n                await writer.close();\n                streamClosed = true;\n              } catch {\n                // Stream already closed\n              }\n            }\n          },\n          complete: async () => {\n            if (!streamClosed) {\n              try {\n                await writer.close();\n                streamClosed = true;\n              } catch {\n                // Stream already closed\n              }\n            }\n          },\n        });\n    })().catch((error) => {\n      console.error(\"Error running agent:\", error);\n      console.error(\n        \"Error stack:\",\n        error instanceof Error ? error.stack : \"No stack trace\"\n      );\n      console.error(\"Error details:\", {\n        name: error instanceof Error ? error.name : \"Unknown\",\n        message: error instanceof Error ? error.message : String(error),\n        cause: error instanceof Error ? error.cause : undefined,\n      });\n      if (!streamClosed) {\n        try {\n          writer.close();\n          streamClosed = true;\n        } catch {\n          // Stream already closed\n        }\n      }\n    });\n\n    // Return the SSE response\n    return new Response(stream.readable, {\n      status: 200,\n      headers: {\n        \"Content-Type\": \"text/event-stream\",\n        \"Cache-Control\": \"no-cache\",\n        Connection: \"keep-alive\",\n      },\n    });\n  } catch (error) {\n    console.error(\"Error running agent:\", error);\n    console.error(\n      \"Error stack:\",\n      error instanceof Error ? error.stack : \"No stack trace\"\n    );\n    console.error(\"Error details:\", {\n      name: error instanceof Error ? error.name : \"Unknown\",\n      message: error instanceof Error ? error.message : String(error),\n      cause: error instanceof Error ? error.cause : undefined,\n    });\n\n    return new Response(\n      JSON.stringify({\n        error: \"Failed to run agent\",\n        message: error instanceof Error ? error.message : \"Unknown error\",\n      }),\n      {\n        status: 500,\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n}\n","/**\n * Determines if a header should be forwarded based on the allowlist.\n * Forwards: authorization header and all x-* custom headers.\n */\nexport function shouldForwardHeader(headerName: string): boolean {\n  const lower = headerName.toLowerCase();\n  return lower === \"authorization\" || lower.startsWith(\"x-\");\n}\n\n/**\n * Extracts headers that should be forwarded from a Request object.\n * Forwards only authorization and x-* headers.\n */\nexport function extractForwardableHeaders(request: Request): Record<string, string> {\n  const forwardableHeaders: Record<string, string> = {};\n  request.headers.forEach((value, key) => {\n    if (shouldForwardHeader(key)) {\n      forwardableHeaders[key] = value;\n    }\n  });\n  return forwardableHeaders;\n}\n","import { CopilotRuntime } from \"../runtime\";\nimport { AgentDescription, RuntimeInfo } from \"@copilotkitnext/shared\";\nimport { VERSION } from \"../runtime\";\n\ninterface HandleGetRuntimeInfoParameters {\n  runtime: CopilotRuntime;\n  request: Request;\n}\n\nexport async function handleGetRuntimeInfo({\n  runtime,\n}: HandleGetRuntimeInfoParameters) {\n  try {\n    const agents = await runtime.agents;\n\n    const agentsDict = Object.entries(agents).reduce(\n      (acc, [name, agent]) => {\n        acc[name] = {\n          name,\n          description: agent.description,\n          className: agent.constructor.name,\n        };\n        return acc;\n      },\n      {} as Record<string, AgentDescription>\n    );\n\n    const runtimeInfo: RuntimeInfo = {\n      version: VERSION,\n      agents: agentsDict,\n      audioFileTranscriptionEnabled: !!runtime.transcriptionService,\n    };\n\n    return new Response(JSON.stringify(runtimeInfo), {\n      status: 200,\n      headers: { \"Content-Type\": \"application/json\" },\n    });\n  } catch (error) {\n    return new Response(\n      JSON.stringify({\n        error: \"Failed to retrieve runtime information\",\n        message: error instanceof Error ? error.message : \"Unknown error\",\n      }),\n      {\n        status: 500,\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n}\n","import { CopilotRuntime } from \"../runtime\";\nimport {\n  TranscriptionErrorCode,\n  TranscriptionErrors,\n  type TranscriptionErrorResponse,\n} from \"@copilotkitnext/shared\";\n\n/**\n * HTTP status codes for transcription error codes\n */\nconst ERROR_STATUS_CODES: Record<TranscriptionErrorCode, number> = {\n  [TranscriptionErrorCode.SERVICE_NOT_CONFIGURED]: 503,\n  [TranscriptionErrorCode.INVALID_AUDIO_FORMAT]: 400,\n  [TranscriptionErrorCode.AUDIO_TOO_LONG]: 400,\n  [TranscriptionErrorCode.AUDIO_TOO_SHORT]: 400,\n  [TranscriptionErrorCode.RATE_LIMITED]: 429,\n  [TranscriptionErrorCode.AUTH_FAILED]: 401,\n  [TranscriptionErrorCode.PROVIDER_ERROR]: 500,\n  [TranscriptionErrorCode.NETWORK_ERROR]: 502,\n  [TranscriptionErrorCode.INVALID_REQUEST]: 400,\n};\n\ninterface HandleTranscribeParameters {\n  runtime: CopilotRuntime;\n  request: Request;\n}\n\ninterface Base64AudioInput {\n  audio: string; // base64-encoded audio data\n  mimeType: string;\n  filename?: string;\n}\n\nconst VALID_AUDIO_TYPES = [\n  \"audio/mpeg\",\n  \"audio/mp3\",\n  \"audio/mp4\",\n  \"audio/wav\",\n  \"audio/webm\",\n  \"audio/ogg\",\n  \"audio/flac\",\n  \"audio/aac\",\n];\n\nfunction isValidAudioType(type: string): boolean {\n  // Extract base MIME type (before semicolon) to handle types like \"audio/webm; codecs=opus\"\n  const baseType = type.split(\";\")[0]?.trim() ?? \"\";\n  return (\n    VALID_AUDIO_TYPES.includes(baseType) ||\n    baseType === \"\" ||\n    baseType === \"application/octet-stream\"\n  );\n}\n\nfunction createErrorResponse(errorResponse: TranscriptionErrorResponse): Response {\n  const status = ERROR_STATUS_CODES[errorResponse.error] ?? 500;\n  return new Response(JSON.stringify(errorResponse), {\n    status,\n    headers: { \"Content-Type\": \"application/json\" },\n  });\n}\n\nfunction base64ToFile(base64: string, mimeType: string, filename: string): File {\n  // Remove data URL prefix if present (e.g., \"data:audio/webm;base64,\")\n  const base64Data = base64.includes(\",\") ? base64.split(\",\")[1] ?? base64 : base64;\n\n  // Decode base64 to binary\n  const binaryString = atob(base64Data);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n\n  // Create File object\n  return new File([bytes], filename, { type: mimeType });\n}\n\nasync function extractAudioFromFormData(\n  request: Request\n): Promise<{ file: File } | { error: Response }> {\n  const formData = await request.formData();\n  const audioFile = formData.get(\"audio\") as File | null;\n\n  if (!audioFile || !(audioFile instanceof File)) {\n    const err = TranscriptionErrors.invalidRequest(\n      \"No audio file found in form data. Please include an 'audio' field.\"\n    );\n    return { error: createErrorResponse(err) };\n  }\n\n  if (!isValidAudioType(audioFile.type)) {\n    const err = TranscriptionErrors.invalidAudioFormat(audioFile.type, VALID_AUDIO_TYPES);\n    return { error: createErrorResponse(err) };\n  }\n\n  return { file: audioFile };\n}\n\nasync function extractAudioFromJson(\n  request: Request\n): Promise<{ file: File } | { error: Response }> {\n  let body: Base64AudioInput;\n\n  try {\n    body = await request.json();\n  } catch {\n    const err = TranscriptionErrors.invalidRequest(\"Request body must be valid JSON\");\n    return { error: createErrorResponse(err) };\n  }\n\n  if (!body.audio || typeof body.audio !== \"string\") {\n    const err = TranscriptionErrors.invalidRequest(\n      \"Request must include 'audio' field with base64-encoded audio data\"\n    );\n    return { error: createErrorResponse(err) };\n  }\n\n  if (!body.mimeType || typeof body.mimeType !== \"string\") {\n    const err = TranscriptionErrors.invalidRequest(\n      \"Request must include 'mimeType' field (e.g., 'audio/webm')\"\n    );\n    return { error: createErrorResponse(err) };\n  }\n\n  if (!isValidAudioType(body.mimeType)) {\n    const err = TranscriptionErrors.invalidAudioFormat(body.mimeType, VALID_AUDIO_TYPES);\n    return { error: createErrorResponse(err) };\n  }\n\n  try {\n    const filename = body.filename || \"recording.webm\";\n    const file = base64ToFile(body.audio, body.mimeType, filename);\n    return { file };\n  } catch {\n    const err = TranscriptionErrors.invalidRequest(\"Failed to decode base64 audio data\");\n    return { error: createErrorResponse(err) };\n  }\n}\n\n/**\n * Categorize provider errors into appropriate transcription error responses.\n */\nfunction categorizeProviderError(error: unknown): TranscriptionErrorResponse {\n  const message = error instanceof Error ? error.message : \"Unknown error occurred\";\n  const errorStr = String(error).toLowerCase();\n\n  // Check for rate limiting\n  if (errorStr.includes(\"rate\") || errorStr.includes(\"429\") || errorStr.includes(\"too many\")) {\n    return TranscriptionErrors.rateLimited();\n  }\n\n  // Check for auth errors\n  if (\n    errorStr.includes(\"auth\") ||\n    errorStr.includes(\"401\") ||\n    errorStr.includes(\"api key\") ||\n    errorStr.includes(\"unauthorized\")\n  ) {\n    return TranscriptionErrors.authFailed();\n  }\n\n  // Check for audio too long\n  if (errorStr.includes(\"too long\") || errorStr.includes(\"duration\") || errorStr.includes(\"length\")) {\n    return TranscriptionErrors.audioTooLong();\n  }\n\n  // Default to provider error\n  return TranscriptionErrors.providerError(message);\n}\n\nexport async function handleTranscribe({\n  runtime,\n  request,\n}: HandleTranscribeParameters) {\n  try {\n    // Check if transcription service is configured\n    if (!runtime.transcriptionService) {\n      const err = TranscriptionErrors.serviceNotConfigured();\n      return createErrorResponse(err);\n    }\n\n    // Determine input type based on content-type header\n    const contentType = request.headers.get(\"content-type\") || \"\";\n\n    let extractResult: { file: File } | { error: Response };\n\n    if (contentType.includes(\"multipart/form-data\")) {\n      // Handle multipart/form-data (REST mode)\n      extractResult = await extractAudioFromFormData(request);\n    } else if (contentType.includes(\"application/json\")) {\n      // Handle JSON with base64 audio (single-endpoint mode)\n      extractResult = await extractAudioFromJson(request);\n    } else {\n      const err = TranscriptionErrors.invalidRequest(\n        \"Request must be multipart/form-data or application/json with base64 audio\"\n      );\n      return createErrorResponse(err);\n    }\n\n    // Check for extraction errors\n    if (\"error\" in extractResult) {\n      return extractResult.error;\n    }\n\n    const audioFile = extractResult.file;\n\n    // Transcribe the audio file\n    const transcription = await runtime.transcriptionService.transcribeFile({\n      audioFile,\n      mimeType: audioFile.type,\n      size: audioFile.size,\n    });\n\n    return new Response(\n      JSON.stringify({\n        text: transcription,\n        size: audioFile.size,\n        type: audioFile.type,\n      }),\n      {\n        status: 200,\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n  } catch (error) {\n    // Categorize the error for better client-side handling\n    return createErrorResponse(categorizeProviderError(error));\n  }\n}\n","/**\n * Middleware support for CopilotKit Runtime.\n *\n * A middleware hook can be provided as either:\n *   1. A **callback function** executed in-process.\n *   2. A **webhook URL** (http/https).  The runtime will `POST` a JSON payload\n *      to the URL and, for *before* hooks, accept an optional modified\n *      `Request` object in the response body.\n *\n * Two lifecycle hooks are available:\n *   • `BEFORE_REQUEST` – runs *before* the request handler.\n *   • `AFTER_REQUEST`  – runs *after* the handler returns a `Response`.\n */\n\nimport type { CopilotRuntime } from \"./runtime\";\nimport type { MaybePromise } from \"@copilotkitnext/shared\";\nimport { logger } from \"@copilotkitnext/shared\";\n\n/* ------------------------------------------------------------------------------------------------\n * Public types\n * --------------------------------------------------------------------------------------------- */\n\nexport interface BeforeRequestMiddlewareParameters {\n  runtime: CopilotRuntime;\n  request: Request;\n  path: string;\n}\nexport interface AfterRequestMiddlewareParameters {\n  runtime: CopilotRuntime;\n  response: Response;\n  path: string;\n}\n\nexport type BeforeRequestMiddlewareFn = (\n  params: BeforeRequestMiddlewareParameters\n) => MaybePromise<Request | void>;\nexport type AfterRequestMiddlewareFn = (\n  params: AfterRequestMiddlewareParameters\n) => MaybePromise<void>;\n\n/**\n * A middleware value can be either a callback function or a webhook URL.\n */\nexport type BeforeRequestMiddleware = BeforeRequestMiddlewareFn;\nexport type AfterRequestMiddleware = AfterRequestMiddlewareFn;\n\n/** Lifecycle events emitted to webhook middleware. */\nexport enum CopilotKitMiddlewareEvent {\n  BeforeRequest = \"BEFORE_REQUEST\",\n  AfterRequest = \"AFTER_REQUEST\",\n}\n\n/** Stages used by the Middleware Webhook Protocol */\n/** Stages used by the CopilotKit webhook protocol */\nexport enum WebhookStage {\n  BeforeRequest = \"before_request\",\n  AfterRequest = \"after_request\",\n}\n\n/* ------------------------------------------------------------------------------------------------\n * Internal helpers – (de)serialisation\n * --------------------------------------------------------------------------------------------- */\n\nexport async function callBeforeRequestMiddleware({\n  runtime,\n  request,\n  path,\n}: BeforeRequestMiddlewareParameters): Promise<Request | void> {\n  const mw = runtime.beforeRequestMiddleware;\n  if (!mw) return;\n\n  // Function-based middleware (in-process)\n  if (typeof mw === \"function\") {\n    return (mw as BeforeRequestMiddlewareFn)({ runtime, request, path });\n  }\n\n  logger.warn({ mw }, \"Unsupported beforeRequestMiddleware value – skipped\");\n  return;\n}\n\nexport async function callAfterRequestMiddleware({\n  runtime,\n  response,\n  path,\n}: AfterRequestMiddlewareParameters): Promise<void> {\n  const mw = runtime.afterRequestMiddleware;\n  if (!mw) return;\n\n  if (typeof mw === \"function\") {\n    return (mw as AfterRequestMiddlewareFn)({ runtime, response, path });\n  }\n\n  logger.warn({ mw }, \"Unsupported afterRequestMiddleware value – skipped\");\n}\n","import { RunAgentInput, RunAgentInputSchema } from \"@ag-ui/client\";\nimport { EventEncoder } from \"@ag-ui/encoder\";\nimport { CopilotRuntime } from \"../runtime\";\nimport { extractForwardableHeaders } from \"./header-utils\";\n\ninterface ConnectAgentParameters {\n  request: Request;\n  runtime: CopilotRuntime;\n  agentId: string;\n}\n\nexport async function handleConnectAgent({\n  runtime,\n  request,\n  agentId,\n}: ConnectAgentParameters) {\n  try {\n    const agents = await runtime.agents;\n\n    // Check if the requested agent exists\n    if (!agents[agentId]) {\n      return new Response(\n        JSON.stringify({\n          error: \"Agent not found\",\n          message: `Agent '${agentId}' does not exist`,\n        }),\n        {\n          status: 404,\n          headers: { \"Content-Type\": \"application/json\" },\n        }\n      );\n    }\n\n    const stream = new TransformStream();\n    const writer = stream.writable.getWriter();\n    const encoder = new EventEncoder();\n    let streamClosed = false;\n\n    // Process the request in the background\n    (async () => {\n      let input: RunAgentInput;\n      try {\n        const requestBody = await request.json();\n        input = RunAgentInputSchema.parse(requestBody);\n      } catch {\n        return new Response(\n          JSON.stringify({\n            error: \"Invalid request body\",\n          }),\n          { status: 400 }\n        );\n      }\n\n      const forwardableHeaders = extractForwardableHeaders(request);\n\n      runtime.runner\n        .connect({\n          threadId: input.threadId,\n          headers: forwardableHeaders,\n        })\n        .subscribe({\n          next: async (event) => {\n            if (!request.signal.aborted && !streamClosed) {\n              try {\n                await writer.write(encoder.encode(event));\n              } catch (error) {\n                if (error instanceof Error && error.name === \"AbortError\") {\n                  streamClosed = true;\n                }\n              }\n            }\n          },\n          error: async (error) => {\n            console.error(\"Error running agent:\", error);\n            if (!streamClosed) {\n              try {\n                await writer.close();\n                streamClosed = true;\n              } catch {\n                // Stream already closed\n              }\n            }\n          },\n          complete: async () => {\n            if (!streamClosed) {\n              try {\n                await writer.close();\n                streamClosed = true;\n              } catch {\n                // Stream already closed\n              }\n            }\n          },\n        });\n    })().catch((error) => {\n      console.error(\"Error running agent:\", error);\n      console.error(\n        \"Error stack:\",\n        error instanceof Error ? error.stack : \"No stack trace\"\n      );\n      console.error(\"Error details:\", {\n        name: error instanceof Error ? error.name : \"Unknown\",\n        message: error instanceof Error ? error.message : String(error),\n        cause: error instanceof Error ? error.cause : undefined,\n      });\n      if (!streamClosed) {\n        try {\n          writer.close();\n          streamClosed = true;\n        } catch {\n          // Stream already closed\n        }\n      }\n    });\n\n    // Return the SSE response\n    return new Response(stream.readable, {\n      status: 200,\n      headers: {\n        \"Content-Type\": \"text/event-stream\",\n        \"Cache-Control\": \"no-cache\",\n        Connection: \"keep-alive\",\n      },\n    });\n  } catch (error) {\n    console.error(\"Error running agent:\", error);\n    console.error(\n      \"Error stack:\",\n      error instanceof Error ? error.stack : \"No stack trace\"\n    );\n    console.error(\"Error details:\", {\n      name: error instanceof Error ? error.name : \"Unknown\",\n      message: error instanceof Error ? error.message : String(error),\n      cause: error instanceof Error ? error.cause : undefined,\n    });\n\n    return new Response(\n      JSON.stringify({\n        error: \"Failed to run agent\",\n        message: error instanceof Error ? error.message : \"Unknown error\",\n      }),\n      {\n        status: 500,\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n}\n","import { CopilotRuntime } from \"../runtime\";\nimport { EventType } from \"@ag-ui/client\";\n\ninterface StopAgentParameters {\n  request: Request;\n  runtime: CopilotRuntime;\n  agentId: string;\n  threadId: string;\n}\n\nexport async function handleStopAgent({\n  runtime,\n  request,\n  agentId,\n  threadId,\n}: StopAgentParameters) {\n  try {\n    const agents = await runtime.agents;\n\n    if (!agents[agentId]) {\n      return new Response(\n        JSON.stringify({\n          error: \"Agent not found\",\n          message: `Agent '${agentId}' does not exist`,\n        }),\n        {\n          status: 404,\n          headers: { \"Content-Type\": \"application/json\" },\n        }\n      );\n    }\n\n    const stopped = await runtime.runner.stop({ threadId });\n\n    if (!stopped) {\n      return new Response(\n        JSON.stringify({\n          stopped: false,\n          message: `No active run for thread '${threadId}'.`,\n        }),\n        {\n          status: 200,\n          headers: { \"Content-Type\": \"application/json\" },\n        }\n      );\n    }\n\n    return new Response(\n      JSON.stringify({\n        stopped: true,\n        interrupt: {\n          type: EventType.RUN_ERROR,\n          message: \"Run stopped by user\",\n          code: \"STOPPED\",\n        },\n      }),\n      {\n        status: 200,\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n  } catch (error) {\n    console.error(\"Error stopping agent run:\", error);\n\n    return new Response(\n      JSON.stringify({\n        error: \"Failed to stop agent\",\n        message: error instanceof Error ? error.message : \"Unknown error\",\n      }),\n      {\n        status: 500,\n        headers: { \"Content-Type\": \"application/json\" },\n      }\n    );\n  }\n}\n","import { Hono } from \"hono\";\nimport { cors } from \"hono/cors\";\n\nimport { CopilotRuntime } from \"../runtime\";\nimport { handleRunAgent } from \"../handlers/handle-run\";\nimport { handleConnectAgent } from \"../handlers/handle-connect\";\nimport { handleStopAgent } from \"../handlers/handle-stop\";\nimport { handleGetRuntimeInfo } from \"../handlers/get-runtime-info\";\nimport { handleTranscribe } from \"../handlers/handle-transcribe\";\nimport { logger } from \"@copilotkitnext/shared\";\nimport { callBeforeRequestMiddleware, callAfterRequestMiddleware } from \"../middleware\";\nimport {\n  createJsonRequest,\n  expectString,\n  MethodCall,\n  parseMethodCall,\n} from \"./single-route-helpers\";\n\nimport { CopilotEndpointCorsConfig } from \"./hono\";\n\ninterface CopilotSingleEndpointParams {\n  runtime: CopilotRuntime;\n  /**\n   * Absolute path at which to mount the single-route endpoint (e.g. \"/api/copilotkit\").\n   */\n  basePath: string;\n  /**\n   * Optional CORS configuration. When not provided, defaults to allowing all origins without credentials.\n   * To support HTTP-only cookies, provide cors config with credentials: true and explicit origin.\n   */\n  cors?: CopilotEndpointCorsConfig;\n}\n\ntype CopilotEndpointContext = {\n  Variables: {\n    modifiedRequest?: Request;\n  };\n};\n\nexport function createCopilotEndpointSingleRoute({ runtime, basePath, cors: corsConfig }: CopilotSingleEndpointParams) {\n  const app = new Hono<CopilotEndpointContext>();\n  const routePath = normalizePath(basePath);\n\n  return app\n    .basePath(routePath)\n    .use(\n      \"*\",\n      cors({\n        origin: corsConfig?.origin ?? \"*\",\n        allowMethods: [\"GET\", \"HEAD\", \"PUT\", \"POST\", \"DELETE\", \"PATCH\", \"OPTIONS\"],\n        allowHeaders: [\"*\"],\n        credentials: corsConfig?.credentials ?? false,\n      }),\n    )\n    .use(\"*\", async (c, next) => {\n      const request = c.req.raw;\n      const path = c.req.path;\n\n      try {\n        const maybeModifiedRequest = await callBeforeRequestMiddleware({\n          runtime,\n          request,\n          path,\n        });\n        if (maybeModifiedRequest) {\n          c.set(\"modifiedRequest\", maybeModifiedRequest);\n        }\n      } catch (error) {\n        logger.error({ err: error, url: request.url, path }, \"Error running before request middleware\");\n        if (error instanceof Response) {\n          return error;\n        }\n        throw error;\n      }\n\n      await next();\n    })\n    .use(\"*\", async (c, next) => {\n      await next();\n\n      const response = c.res;\n      const path = c.req.path;\n\n      callAfterRequestMiddleware({\n        runtime,\n        response,\n        path,\n      }).catch((error) => {\n        logger.error({ err: error, url: c.req.url, path }, \"Error running after request middleware\");\n      });\n    })\n    .post(\"/\", async (c) => {\n      const request = c.get(\"modifiedRequest\") || c.req.raw;\n\n      let methodCall: MethodCall;\n      try {\n        methodCall = await parseMethodCall(request);\n      } catch (error) {\n        if (error instanceof Response) {\n          logger.warn({ url: request.url }, \"Invalid single-route payload\");\n          return error;\n        }\n        logger.warn({ err: error, url: request.url }, \"Invalid single-route payload\");\n        return c.json(\n          {\n            error: \"invalid_request\",\n            message: error instanceof Error ? error.message : \"Invalid request payload\",\n          },\n          400,\n        );\n      }\n\n      try {\n        switch (methodCall.method) {\n          case \"agent/run\": {\n            const agentId = expectString(methodCall.params, \"agentId\");\n            const handlerRequest = createJsonRequest(request, methodCall.body);\n            return await handleRunAgent({ runtime, request: handlerRequest, agentId });\n          }\n          case \"agent/connect\": {\n            const agentId = expectString(methodCall.params, \"agentId\");\n            const handlerRequest = createJsonRequest(request, methodCall.body);\n            return await handleConnectAgent({ runtime, request: handlerRequest, agentId });\n          }\n          case \"agent/stop\": {\n            const agentId = expectString(methodCall.params, \"agentId\");\n            const threadId = expectString(methodCall.params, \"threadId\");\n            return await handleStopAgent({ runtime, request, agentId, threadId });\n          }\n          case \"info\": {\n            return await handleGetRuntimeInfo({ runtime, request });\n          }\n          case \"transcribe\": {\n            const handlerRequest = createJsonRequest(request, methodCall.body);\n            return await handleTranscribe({ runtime, request: handlerRequest });\n          }\n          default: {\n            const exhaustiveCheck: never = methodCall.method;\n            return exhaustiveCheck;\n          }\n        }\n      } catch (error) {\n        if (error instanceof Response) {\n          return error;\n        }\n        logger.error({ err: error, url: request.url, method: methodCall.method }, \"Error running single-route handler\");\n        throw error;\n      }\n    })\n    .notFound((c) => {\n      return c.json({ error: \"Not found\" }, 404);\n    });\n}\n\nfunction normalizePath(path: string): string {\n  if (!path) {\n    throw new Error(\"basePath must be provided for single-route endpoint\");\n  }\n\n  if (!path.startsWith(\"/\")) {\n    return `/${path}`;\n  }\n\n  if (path.length > 1 && path.endsWith(\"/\")) {\n    return path.slice(0, -1);\n  }\n\n  return path;\n}\n","const METHOD_NAMES = [\n  \"agent/run\",\n  \"agent/connect\",\n  \"agent/stop\",\n  \"info\",\n  \"transcribe\",\n] as const;\n\nexport type EndpointMethod = (typeof METHOD_NAMES)[number];\n\ninterface JsonEnvelope {\n  method?: string;\n  params?: Record<string, unknown>;\n  body?: unknown;\n}\n\nexport interface MethodCall {\n  method: EndpointMethod;\n  params?: Record<string, unknown>;\n  body?: unknown;\n}\n\nexport async function parseMethodCall(request: Request): Promise<MethodCall> {\n  const contentType = request.headers.get(\"content-type\") || \"\";\n\n  if (!contentType.includes(\"application/json\")) {\n    throw createResponseError(\"Single-route endpoint expects JSON payloads\", 415);\n  }\n\n  let jsonEnvelope: JsonEnvelope;\n  try {\n    jsonEnvelope = (await request.clone().json()) as JsonEnvelope;\n  } catch (error) {\n    throw createResponseError(\"Invalid JSON payload\", 400);\n  }\n\n  const method = validateMethod(jsonEnvelope.method);\n\n  return {\n    method,\n    params: jsonEnvelope.params,\n    body: jsonEnvelope.body,\n  };\n}\n\nexport function expectString(params: Record<string, unknown> | undefined, key: string): string {\n  const value = params?.[key];\n  if (typeof value === \"string\" && value.trim().length > 0) {\n    return value;\n  }\n\n  throw createResponseError(`Missing or invalid parameter '${key}'`, 400);\n}\n\nexport function createJsonRequest(base: Request, body: unknown): Request {\n  if (body === undefined || body === null) {\n    throw createResponseError(\"Missing request body for JSON handler\", 400);\n  }\n\n  const headers = new Headers(base.headers);\n  headers.set(\"content-type\", \"application/json\");\n  headers.delete(\"content-length\");\n\n  const serializedBody = serializeJsonBody(body);\n\n  return new Request(base.url, {\n    method: \"POST\",\n    headers,\n    body: serializedBody,\n    signal: base.signal,\n  });\n}\n\nexport function createResponseError(message: string, status: number): Response {\n  return new Response(\n    JSON.stringify({\n      error: \"invalid_request\",\n      message,\n    }),\n    {\n      status,\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n    },\n  );\n}\n\nfunction validateMethod(method: string | undefined): EndpointMethod {\n  if (!method) {\n    throw createResponseError(\"Missing method field\", 400);\n  }\n\n  if ((METHOD_NAMES as readonly string[]).includes(method)) {\n    return method as EndpointMethod;\n  }\n\n  throw createResponseError(`Unsupported method '${method}'`, 400);\n}\n\nfunction serializeJsonBody(body: unknown): BodyInit {\n  if (typeof body === \"string\") {\n    return body;\n  }\n\n  if (body instanceof Blob || body instanceof ArrayBuffer || body instanceof Uint8Array) {\n    return body;\n  }\n\n  if (body instanceof FormData || body instanceof URLSearchParams) {\n    return body;\n  }\n\n  return JSON.stringify(body);\n}\n","export * from \"./agent-runner\";\nexport * from \"./in-memory\";\nexport { finalizeRunEvents } from \"@copilotkitnext/shared\";\n","export interface TranscribeFileOptions {\n  audioFile: File;\n  /** MIME type of the audio file */\n  mimeType?: string;\n  /** Size of the audio file in bytes */\n  size?: number;\n}\n\nexport abstract class TranscriptionService {\n  abstract transcribeFile(options: TranscribeFileOptions): Promise<string>;\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAA;AAAA,EACE,MAAQ;AAAA,EACR,SAAW;AAAA,EACX,aAAe;AAAA,EACf,MAAQ;AAAA,EACR,OAAS;AAAA,EACT,SAAW;AAAA,IACT,KAAK;AAAA,MACH,OAAS;AAAA,MACT,QAAU;AAAA,MACV,SAAW;AAAA,IACb;AAAA,IACA,aAAa;AAAA,MACX,OAAS;AAAA,MACT,QAAU;AAAA,MACV,SAAW;AAAA,IACb;AAAA,EACF;AAAA,EACA,eAAiB;AAAA,IACf,QAAU;AAAA,EACZ;AAAA,EACA,SAAW;AAAA,IACT,OAAS;AAAA,IACT,KAAO;AAAA,IACP,MAAQ;AAAA,IACR,eAAe;AAAA,IACf,OAAS;AAAA,IACT,MAAQ;AAAA,IACR,cAAc;AAAA,IACd,iBAAiB;AAAA,EACnB;AAAA,EACA,iBAAmB;AAAA,IACjB,iCAAiC;AAAA,IACjC,qCAAqC;AAAA,IACrC,eAAe;AAAA,IACf,kBAAkB;AAAA,IAClB,eAAe;AAAA,IACf,QAAU;AAAA,IACV,WAAa;AAAA,IACb,MAAQ;AAAA,IACR,YAAc;AAAA,IACd,QAAU;AAAA,EACZ;AAAA,EACA,cAAgB;AAAA,IACd,iBAAiB;AAAA,IACjB,eAAe;AAAA,IACf,kBAAkB;AAAA,IAClB,0BAA0B;AAAA,IAC1B,MAAQ;AAAA,IACR,SAAW;AAAA,IACX,MAAQ;AAAA,IACR,MAAQ;AAAA,EACV;AAAA,EACA,kBAAoB;AAAA,IAClB,iBAAiB;AAAA,IACjB,eAAe;AAAA,IACf,kBAAkB;AAAA,IAClB,0BAA0B;AAAA,EAC5B;AAAA,EACA,sBAAwB,CAAC;AAAA,EACzB,SAAW;AAAA,IACT,MAAQ;AAAA,EACV;AACF;;;ACzCO,IAAe,cAAf,MAA2B;AAKlC;;;ACpBA,kBAA0C;AAC1C,oBAOO;AACP,oBAAkC;AAUlC,IAAM,qBAAN,MAAyB;AAAA,EACvB,YAAmB,UAAkB;AAAlB;AAAA,EAAmB;AAAA;AAAA,EAGtC,UAA2C;AAAA;AAAA,EAG3C,YAAY;AAAA;AAAA,EAGZ,eAA8B;AAAA;AAAA,EAG9B,eAA8B,CAAC;AAAA;AAAA,EAG/B,QAA8B;AAAA;AAAA,EAG9B,aAA8C;AAAA;AAAA,EAG9C,gBAAgB;AAAA;AAAA,EAGhB,gBAAoC;AACtC;AAGA,IAAM,mBAAmB,uBAAO,IAAI,yCAAyC;AAO7E,SAAS,iBAAkD;AACzD,QAAM,YAAY;AAElB,MAAI,CAAC,UAAU,gBAAgB,GAAG;AAChC,cAAU,gBAAgB,IAAI;AAAA,MAC5B,QAAQ,oBAAI,IAAgC;AAAA,MAC5C,oBAAoB,oBAAI,IAA2B;AAAA,IACrD;AAAA,EACF;AAEA,QAAM,OAAO,UAAU,gBAAgB;AAIvC,MAAI,KAAK,OAAO,SAAS,KAAK,KAAK,mBAAmB,OAAO,GAAG;AAC9D,eAAW,CAAC,UAAU,YAAY,KAAK,KAAK,oBAAoB;AAC9D,YAAM,QAAQ,IAAI,mBAAmB,QAAQ;AAC7C,YAAM,eAAe;AACrB,WAAK,OAAO,IAAI,UAAU,KAAK;AAAA,IACjC;AAAA,EACF;AAEA,SAAO,KAAK;AACd;AAEA,SAAS,mBAAmB,UAAkB,cAAmC;AAC/E,QAAM,YAAY;AAClB,MAAI,UAAU,gBAAgB,GAAG;AAC/B,cAAU,gBAAgB,EAAE,mBAAmB,IAAI,UAAU,YAAY;AAAA,EAC3E;AACF;AAEA,IAAM,eAAe,eAAe;AAE7B,IAAM,sBAAN,cAAkC,YAAY;AAAA,EACnD,IAAI,SAAuD;AACzD,QAAI,gBAAgB,aAAa,IAAI,QAAQ,QAAQ;AACrD,QAAI,CAAC,eAAe;AAClB,sBAAgB,IAAI,mBAAmB,QAAQ,QAAQ;AACvD,mBAAa,IAAI,QAAQ,UAAU,aAAa;AAAA,IAClD;AACA,UAAM,QAAQ;AAEd,QAAI,MAAM,WAAW;AACnB,YAAM,IAAI,MAAM,wBAAwB;AAAA,IAC1C;AACA,UAAM,YAAY;AAClB,UAAM,eAAe,QAAQ,MAAM;AACnC,UAAM,QAAQ,QAAQ;AACtB,UAAM,gBAAgB;AAGtB,UAAM,iBAAiB,oBAAI,IAAY;AACvC,UAAM,mBAAgC,CAAC;AACvC,UAAM,gBAAgB;AAGtB,UAAM,qBAAqB,oBAAI,IAAY;AAC3C,eAAW,OAAO,MAAM,cAAc;AACpC,iBAAW,SAAS,IAAI,QAAQ;AAC9B,YAAI,eAAe,SAAS,OAAO,MAAM,cAAc,UAAU;AAC/D,6BAAmB,IAAI,MAAM,SAAS;AAAA,QACxC;AACA,YAAI,MAAM,SAAS,wBAAU,aAAa;AACxC,gBAAM,aAAa;AACnB,gBAAM,WAAW,WAAW,OAAO,YAAY,CAAC;AAChD,qBAAW,WAAW,UAAU;AAC9B,+BAAmB,IAAI,QAAQ,EAAE;AAAA,UACnC;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,UAAM,cAAc,IAAI,0BAAyB,QAAQ;AACzD,UAAM,cAAc,MAAM;AAG1B,UAAM,UAAU;AAGhB,UAAM,aAAa,IAAI,0BAAyB,QAAQ;AACxD,UAAM,aAAa;AAGnB,UAAM,WAAW,YAAY;AAE3B,YAAM,UAAU,MAAM,aAAa,MAAM,aAAa,SAAS,CAAC;AAChE,YAAM,cAAc,SAAS,SAAS;AAEtC,UAAI;AACF,cAAM,QAAQ,MAAM,SAAS,QAAQ,OAAO;AAAA,UAC1C,SAAS,CAAC,EAAE,MAAM,MAAM;AACtB,gBAAI,iBAA4B;AAChC,gBAAI,MAAM,SAAS,wBAAU,aAAa;AACxC,oBAAM,kBAAkB;AACxB,kBAAI,CAAC,gBAAgB,OAAO;AAC1B,sBAAM,oBAAoB,QAAQ,MAAM,WACpC,QAAQ,MAAM,SAAS;AAAA,kBACrB,CAAC,YAAY,CAAC,mBAAmB,IAAI,QAAQ,EAAE;AAAA,gBACjD,IACA;AACJ,sBAAM,eAAe;AAAA,kBACnB,GAAG,QAAQ;AAAA,kBACX,GAAI,sBAAsB,SACtB,EAAE,UAAU,kBAAkB,IAC9B,CAAC;AAAA,gBACP;AACA,iCAAiB;AAAA,kBACf,GAAG;AAAA,kBACH,OAAO;AAAA,gBACT;AAAA,cACF;AAAA,YACF;AAEA,uBAAW,KAAK,cAAc;AAC9B,wBAAY,KAAK,cAAc;AAC/B,6BAAiB,KAAK,cAAc;AAAA,UACtC;AAAA,UACA,cAAc,CAAC,EAAE,QAAQ,MAAM;AAE7B,gBAAI,CAAC,eAAe,IAAI,QAAQ,EAAE,GAAG;AACnC,6BAAe,IAAI,QAAQ,EAAE;AAAA,YAC/B;AAAA,UACF;AAAA,UACA,mBAAmB,MAAM;AAEvB,gBAAI,QAAQ,MAAM,UAAU;AAC1B,yBAAW,WAAW,QAAQ,MAAM,UAAU;AAC5C,oBAAI,CAAC,eAAe,IAAI,QAAQ,EAAE,GAAG;AACnC,iCAAe,IAAI,QAAQ,EAAE;AAAA,gBAC/B;AAAA,cACF;AAAA,YACF;AAAA,UACF;AAAA,QACF,CAAC;AAED,cAAM,qBAAiB,iCAAkB,kBAAkB;AAAA,UACzD,eAAe,MAAM;AAAA,QACvB,CAAC;AACD,mBAAW,SAAS,gBAAgB;AAClC,qBAAW,KAAK,KAAK;AACrB,sBAAY,KAAK,KAAK;AAAA,QACxB;AAGA,YAAI,MAAM,cAAc;AAEtB,gBAAM,sBAAkB,6BAAc,gBAAgB;AAEtD,gBAAM,aAAa,KAAK;AAAA,YACtB,UAAU,QAAQ;AAAA,YAClB,OAAO,MAAM;AAAA,YACb;AAAA,YACA,QAAQ;AAAA,YACR,WAAW,KAAK,IAAI;AAAA,UACtB,CAAC;AAGD,6BAAmB,QAAQ,UAAU,MAAM,YAAY;AAAA,QACzD;AAGA,cAAM,gBAAgB;AACtB,cAAM,eAAe;AACrB,cAAM,QAAQ;AACd,cAAM,aAAa;AACnB,cAAM,gBAAgB;AACtB,cAAM,YAAY;AAClB,mBAAW,SAAS;AACpB,oBAAY,SAAS;AAAA,MACvB,QAAQ;AACN,cAAM,qBAAiB,iCAAkB,kBAAkB;AAAA,UACzD,eAAe,MAAM;AAAA,QACvB,CAAC;AACD,mBAAW,SAAS,gBAAgB;AAClC,qBAAW,KAAK,KAAK;AACrB,sBAAY,KAAK,KAAK;AAAA,QACxB;AAGA,YAAI,MAAM,gBAAgB,iBAAiB,SAAS,GAAG;AAErD,gBAAM,sBAAkB,6BAAc,gBAAgB;AACtD,gBAAM,aAAa,KAAK;AAAA,YACtB,UAAU,QAAQ;AAAA,YAClB,OAAO,MAAM;AAAA,YACb;AAAA,YACA,QAAQ;AAAA,YACR,WAAW,KAAK,IAAI;AAAA,UACtB,CAAC;AAGD,6BAAmB,QAAQ,UAAU,MAAM,YAAY;AAAA,QACzD;AAGA,cAAM,gBAAgB;AACtB,cAAM,eAAe;AACrB,cAAM,QAAQ;AACd,cAAM,aAAa;AACnB,cAAM,gBAAgB;AACtB,cAAM,YAAY;AAClB,mBAAW,SAAS;AACpB,oBAAY,SAAS;AAAA,MACvB;AAAA,IACF;AAGA,QAAI,aAAa;AACf,kBAAY,UAAU;AAAA,QACpB,MAAM,CAAC,MAAM,YAAY,KAAK,CAAC;AAAA,QAC/B,OAAO,CAAC,QAAQ,YAAY,MAAM,GAAG;AAAA,QACrC,UAAU,MAAM;AAAA,QAEhB;AAAA,MACF,CAAC;AAAA,IACH;AAGA,aAAS;AAGT,WAAO,WAAW,aAAa;AAAA,EACjC;AAAA,EAEA,QAAQ,SAA2D;AACjE,UAAM,QAAQ,aAAa,IAAI,QAAQ,QAAQ;AAC/C,UAAM,oBAAoB,IAAI,0BAAyB,QAAQ;AAE/D,QAAI,CAAC,OAAO;AAEV,wBAAkB,SAAS;AAC3B,aAAO,kBAAkB,aAAa;AAAA,IACxC;AAGA,UAAM,oBAAiC,CAAC;AACxC,eAAW,OAAO,MAAM,cAAc;AACpC,wBAAkB,KAAK,GAAG,IAAI,MAAM;AAAA,IACtC;AAGA,UAAM,sBAAkB,6BAAc,iBAAiB;AAGvD,UAAM,oBAAoB,oBAAI,IAAY;AAC1C,eAAW,SAAS,iBAAiB;AACnC,wBAAkB,KAAK,KAAK;AAC5B,UAAI,eAAe,SAAS,OAAO,MAAM,cAAc,UAAU;AAC/D,0BAAkB,IAAI,MAAM,SAAS;AAAA,MACvC;AAAA,IACF;AAGA,QAAI,MAAM,YAAY,MAAM,aAAa,MAAM,gBAAgB;AAC7D,YAAM,QAAQ,UAAU;AAAA,QACtB,MAAM,CAAC,UAAU;AAEf,cACE,eAAe,SACf,OAAO,MAAM,cAAc,YAC3B,kBAAkB,IAAI,MAAM,SAAS,GACrC;AACA;AAAA,UACF;AACA,4BAAkB,KAAK,KAAK;AAAA,QAC9B;AAAA,QACA,UAAU,MAAM,kBAAkB,SAAS;AAAA,QAC3C,OAAO,CAAC,QAAQ,kBAAkB,MAAM,GAAG;AAAA,MAC7C,CAAC;AAAA,IACH,OAAO;AAEL,wBAAkB,SAAS;AAAA,IAC7B;AAEA,WAAO,kBAAkB,aAAa;AAAA,EACxC;AAAA,EAEA,UAAU,SAAwD;AAChE,UAAM,QAAQ,aAAa,IAAI,QAAQ,QAAQ;AAC/C,WAAO,QAAQ,QAAQ,OAAO,aAAa,KAAK;AAAA,EAClD;AAAA,EAEA,KAAK,SAA+D;AAClE,UAAM,QAAQ,aAAa,IAAI,QAAQ,QAAQ;AAC/C,QAAI,CAAC,SAAS,CAAC,MAAM,WAAW;AAC9B,aAAO,QAAQ,QAAQ,KAAK;AAAA,IAC9B;AACA,QAAI,MAAM,eAAe;AACvB,aAAO,QAAQ,QAAQ,KAAK;AAAA,IAC9B;AAEA,UAAM,gBAAgB;AACtB,UAAM,YAAY;AAElB,UAAM,QAAQ,MAAM;AACpB,QAAI,CAAC,OAAO;AACV,YAAM,gBAAgB;AACtB,YAAM,YAAY;AAClB,aAAO,QAAQ,QAAQ,KAAK;AAAA,IAC9B;AAEA,QAAI;AACF,YAAM,SAAS;AACf,aAAO,QAAQ,QAAQ,IAAI;AAAA,IAC7B,SAAS,OAAO;AACd,cAAQ,MAAM,6BAA6B,KAAK;AAChD,YAAM,gBAAgB;AACtB,YAAM,YAAY;AAClB,aAAO,QAAQ,QAAQ,KAAK;AAAA,IAC9B;AAAA,EACF;AACF;;;AC3WO,IAAM,UAAU,gBAAI;AAqBpB,IAAM,iBAAN,MAAqB;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEP,YAAY;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,GAA0B;AACxB,SAAK,SAAS;AACd,SAAK,uBAAuB;AAC5B,SAAK,0BAA0B;AAC/B,SAAK,yBAAyB;AAC9B,SAAK,SAAS,UAAU,IAAI,oBAAoB;AAAA,EAClD;AACF;;;ACpDA,kBAAqB;AACrB,kBAAqB;;;ACDrB,IAAAA,iBAKO;AACP,qBAA6B;;;ACFtB,SAAS,oBAAoB,YAA6B;AAC/D,QAAM,QAAQ,WAAW,YAAY;AACrC,SAAO,UAAU,mBAAmB,MAAM,WAAW,IAAI;AAC3D;AAMO,SAAS,0BAA0B,SAA0C;AAClF,QAAM,qBAA6C,CAAC;AACpD,UAAQ,QAAQ,QAAQ,CAAC,OAAO,QAAQ;AACtC,QAAI,oBAAoB,GAAG,GAAG;AAC5B,yBAAmB,GAAG,IAAI;AAAA,IAC5B;AAAA,EACF,CAAC;AACD,SAAO;AACT;;;ADLA,eAAsB,eAAe;AAAA,EACnC;AAAA,EACA;AAAA,EACA;AACF,GAAuB;AACrB,MAAI;AACF,UAAM,SAAS,MAAM,QAAQ;AAG7B,QAAI,CAAC,OAAO,OAAO,GAAG;AACpB,aAAO,IAAI;AAAA,QACT,KAAK,UAAU;AAAA,UACb,OAAO;AAAA,UACP,SAAS,UAAU,OAAO;AAAA,QAC5B,CAAC;AAAA,QACD;AAAA,UACE,QAAQ;AAAA,UACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAChD;AAAA,MACF;AAAA,IACF;AAEA,UAAM,kBAAkB,OAAO,OAAO;AACtC,UAAM,QAAQ,gBAAgB,MAAM;AAEpC,QAAI,SAAS,aAAa,OAAO;AAC/B,YAAM,qBAAqB,0BAA0B,OAAO;AAC5D,YAAM,UAAU;AAAA,QACd,GAAG,MAAM;AAAA,QACT,GAAG;AAAA,MACL;AAAA,IACF;AAEA,UAAM,SAAS,IAAI,gBAAgB;AACnC,UAAM,SAAS,OAAO,SAAS,UAAU;AACzC,UAAM,UAAU,IAAI,4BAAa;AACjC,QAAI,eAAe;AAGnB,KAAC,YAAY;AACX,UAAI;AACJ,UAAI;AACF,cAAM,cAAc,MAAM,QAAQ,KAAK;AACvC,gBAAQ,mCAAoB,MAAM,WAAW;AAAA,MAC/C,QAAQ;AACN,eAAO,IAAI;AAAA,UACT,KAAK,UAAU;AAAA,YACb,OAAO;AAAA,UACT,CAAC;AAAA,UACD,EAAE,QAAQ,IAAI;AAAA,QAChB;AAAA,MACF;AAEA,YAAM,YAAY,MAAM,QAAQ;AAChC,YAAM,SAAS,MAAM,KAAK;AAC1B,YAAM,WAAW,MAAM;AAEvB,cAAQ,OACL,IAAI;AAAA,QACH,UAAU,MAAM;AAAA,QAChB;AAAA,QACA;AAAA,MACF,CAAC,EACA,UAAU;AAAA,QACT,MAAM,OAAO,UAAU;AACrB,cAAI,CAAC,QAAQ,OAAO,WAAW,CAAC,cAAc;AAC5C,gBAAI;AACF,oBAAM,OAAO,MAAM,QAAQ,OAAO,KAAK,CAAC;AAAA,YAC1C,SAAS,OAAO;AACd,kBAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AACzD,+BAAe;AAAA,cACjB;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,QACA,OAAO,OAAO,UAAU;AACtB,kBAAQ,MAAM,wBAAwB,KAAK;AAC3C,cAAI,CAAC,cAAc;AACjB,gBAAI;AACF,oBAAM,OAAO,MAAM;AACnB,6BAAe;AAAA,YACjB,QAAQ;AAAA,YAER;AAAA,UACF;AAAA,QACF;AAAA,QACA,UAAU,YAAY;AACpB,cAAI,CAAC,cAAc;AACjB,gBAAI;AACF,oBAAM,OAAO,MAAM;AACnB,6BAAe;AAAA,YACjB,QAAQ;AAAA,YAER;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACL,GAAG,EAAE,MAAM,CAAC,UAAU;AACpB,cAAQ,MAAM,wBAAwB,KAAK;AAC3C,cAAQ;AAAA,QACN;AAAA,QACA,iBAAiB,QAAQ,MAAM,QAAQ;AAAA,MACzC;AACA,cAAQ,MAAM,kBAAkB;AAAA,QAC9B,MAAM,iBAAiB,QAAQ,MAAM,OAAO;AAAA,QAC5C,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,QAC9D,OAAO,iBAAiB,QAAQ,MAAM,QAAQ;AAAA,MAChD,CAAC;AACD,UAAI,CAAC,cAAc;AACjB,YAAI;AACF,iBAAO,MAAM;AACb,yBAAe;AAAA,QACjB,QAAQ;AAAA,QAER;AAAA,MACF;AAAA,IACF,CAAC;AAGD,WAAO,IAAI,SAAS,OAAO,UAAU;AAAA,MACnC,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,gBAAgB;AAAA,QAChB,iBAAiB;AAAA,QACjB,YAAY;AAAA,MACd;AAAA,IACF,CAAC;AAAA,EACH,SAAS,OAAO;AACd,YAAQ,MAAM,wBAAwB,KAAK;AAC3C,YAAQ;AAAA,MACN;AAAA,MACA,iBAAiB,QAAQ,MAAM,QAAQ;AAAA,IACzC;AACA,YAAQ,MAAM,kBAAkB;AAAA,MAC9B,MAAM,iBAAiB,QAAQ,MAAM,OAAO;AAAA,MAC5C,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAC9D,OAAO,iBAAiB,QAAQ,MAAM,QAAQ;AAAA,IAChD,CAAC;AAED,WAAO,IAAI;AAAA,MACT,KAAK,UAAU;AAAA,QACb,OAAO;AAAA,QACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MACpD,CAAC;AAAA,MACD;AAAA,QACE,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AACF;;;AE7JA,eAAsB,qBAAqB;AAAA,EACzC;AACF,GAAmC;AACjC,MAAI;AACF,UAAM,SAAS,MAAM,QAAQ;AAE7B,UAAM,aAAa,OAAO,QAAQ,MAAM,EAAE;AAAA,MACxC,CAAC,KAAK,CAAC,MAAM,KAAK,MAAM;AACtB,YAAI,IAAI,IAAI;AAAA,UACV;AAAA,UACA,aAAa,MAAM;AAAA,UACnB,WAAW,MAAM,YAAY;AAAA,QAC/B;AACA,eAAO;AAAA,MACT;AAAA,MACA,CAAC;AAAA,IACH;AAEA,UAAM,cAA2B;AAAA,MAC/B,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,+BAA+B,CAAC,CAAC,QAAQ;AAAA,IAC3C;AAEA,WAAO,IAAI,SAAS,KAAK,UAAU,WAAW,GAAG;AAAA,MAC/C,QAAQ;AAAA,MACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,IAChD,CAAC;AAAA,EACH,SAAS,OAAO;AACd,WAAO,IAAI;AAAA,MACT,KAAK,UAAU;AAAA,QACb,OAAO;AAAA,QACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MACpD,CAAC;AAAA,MACD;AAAA,QACE,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AACF;;;AChDA,IAAAC,iBAIO;AAKP,IAAM,qBAA6D;AAAA,EACjE,CAAC,sCAAuB,sBAAsB,GAAG;AAAA,EACjD,CAAC,sCAAuB,oBAAoB,GAAG;AAAA,EAC/C,CAAC,sCAAuB,cAAc,GAAG;AAAA,EACzC,CAAC,sCAAuB,eAAe,GAAG;AAAA,EAC1C,CAAC,sCAAuB,YAAY,GAAG;AAAA,EACvC,CAAC,sCAAuB,WAAW,GAAG;AAAA,EACtC,CAAC,sCAAuB,cAAc,GAAG;AAAA,EACzC,CAAC,sCAAuB,aAAa,GAAG;AAAA,EACxC,CAAC,sCAAuB,eAAe,GAAG;AAC5C;AAaA,IAAM,oBAAoB;AAAA,EACxB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAEA,SAAS,iBAAiB,MAAuB;AAE/C,QAAM,WAAW,KAAK,MAAM,GAAG,EAAE,CAAC,GAAG,KAAK,KAAK;AAC/C,SACE,kBAAkB,SAAS,QAAQ,KACnC,aAAa,MACb,aAAa;AAEjB;AAEA,SAAS,oBAAoB,eAAqD;AAChF,QAAM,SAAS,mBAAmB,cAAc,KAAK,KAAK;AAC1D,SAAO,IAAI,SAAS,KAAK,UAAU,aAAa,GAAG;AAAA,IACjD;AAAA,IACA,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,EAChD,CAAC;AACH;AAEA,SAAS,aAAa,QAAgB,UAAkB,UAAwB;AAE9E,QAAM,aAAa,OAAO,SAAS,GAAG,IAAI,OAAO,MAAM,GAAG,EAAE,CAAC,KAAK,SAAS;AAG3E,QAAM,eAAe,KAAK,UAAU;AACpC,QAAM,QAAQ,IAAI,WAAW,aAAa,MAAM;AAChD,WAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC5C,UAAM,CAAC,IAAI,aAAa,WAAW,CAAC;AAAA,EACtC;AAGA,SAAO,IAAI,KAAK,CAAC,KAAK,GAAG,UAAU,EAAE,MAAM,SAAS,CAAC;AACvD;AAEA,eAAe,yBACb,SAC+C;AAC/C,QAAM,WAAW,MAAM,QAAQ,SAAS;AACxC,QAAM,YAAY,SAAS,IAAI,OAAO;AAEtC,MAAI,CAAC,aAAa,EAAE,qBAAqB,OAAO;AAC9C,UAAM,MAAM,mCAAoB;AAAA,MAC9B;AAAA,IACF;AACA,WAAO,EAAE,OAAO,oBAAoB,GAAG,EAAE;AAAA,EAC3C;AAEA,MAAI,CAAC,iBAAiB,UAAU,IAAI,GAAG;AACrC,UAAM,MAAM,mCAAoB,mBAAmB,UAAU,MAAM,iBAAiB;AACpF,WAAO,EAAE,OAAO,oBAAoB,GAAG,EAAE;AAAA,EAC3C;AAEA,SAAO,EAAE,MAAM,UAAU;AAC3B;AAEA,eAAe,qBACb,SAC+C;AAC/C,MAAI;AAEJ,MAAI;AACF,WAAO,MAAM,QAAQ,KAAK;AAAA,EAC5B,QAAQ;AACN,UAAM,MAAM,mCAAoB,eAAe,iCAAiC;AAChF,WAAO,EAAE,OAAO,oBAAoB,GAAG,EAAE;AAAA,EAC3C;AAEA,MAAI,CAAC,KAAK,SAAS,OAAO,KAAK,UAAU,UAAU;AACjD,UAAM,MAAM,mCAAoB;AAAA,MAC9B;AAAA,IACF;AACA,WAAO,EAAE,OAAO,oBAAoB,GAAG,EAAE;AAAA,EAC3C;AAEA,MAAI,CAAC,KAAK,YAAY,OAAO,KAAK,aAAa,UAAU;AACvD,UAAM,MAAM,mCAAoB;AAAA,MAC9B;AAAA,IACF;AACA,WAAO,EAAE,OAAO,oBAAoB,GAAG,EAAE;AAAA,EAC3C;AAEA,MAAI,CAAC,iBAAiB,KAAK,QAAQ,GAAG;AACpC,UAAM,MAAM,mCAAoB,mBAAmB,KAAK,UAAU,iBAAiB;AACnF,WAAO,EAAE,OAAO,oBAAoB,GAAG,EAAE;AAAA,EAC3C;AAEA,MAAI;AACF,UAAM,WAAW,KAAK,YAAY;AAClC,UAAM,OAAO,aAAa,KAAK,OAAO,KAAK,UAAU,QAAQ;AAC7D,WAAO,EAAE,KAAK;AAAA,EAChB,QAAQ;AACN,UAAM,MAAM,mCAAoB,eAAe,oCAAoC;AACnF,WAAO,EAAE,OAAO,oBAAoB,GAAG,EAAE;AAAA,EAC3C;AACF;AAKA,SAAS,wBAAwB,OAA4C;AAC3E,QAAM,UAAU,iBAAiB,QAAQ,MAAM,UAAU;AACzD,QAAM,WAAW,OAAO,KAAK,EAAE,YAAY;AAG3C,MAAI,SAAS,SAAS,MAAM,KAAK,SAAS,SAAS,KAAK,KAAK,SAAS,SAAS,UAAU,GAAG;AAC1F,WAAO,mCAAoB,YAAY;AAAA,EACzC;AAGA,MACE,SAAS,SAAS,MAAM,KACxB,SAAS,SAAS,KAAK,KACvB,SAAS,SAAS,SAAS,KAC3B,SAAS,SAAS,cAAc,GAChC;AACA,WAAO,mCAAoB,WAAW;AAAA,EACxC;AAGA,MAAI,SAAS,SAAS,UAAU,KAAK,SAAS,SAAS,UAAU,KAAK,SAAS,SAAS,QAAQ,GAAG;AACjG,WAAO,mCAAoB,aAAa;AAAA,EAC1C;AAGA,SAAO,mCAAoB,cAAc,OAAO;AAClD;AAEA,eAAsB,iBAAiB;AAAA,EACrC;AAAA,EACA;AACF,GAA+B;AAC7B,MAAI;AAEF,QAAI,CAAC,QAAQ,sBAAsB;AACjC,YAAM,MAAM,mCAAoB,qBAAqB;AACrD,aAAO,oBAAoB,GAAG;AAAA,IAChC;AAGA,UAAM,cAAc,QAAQ,QAAQ,IAAI,cAAc,KAAK;AAE3D,QAAI;AAEJ,QAAI,YAAY,SAAS,qBAAqB,GAAG;AAE/C,sBAAgB,MAAM,yBAAyB,OAAO;AAAA,IACxD,WAAW,YAAY,SAAS,kBAAkB,GAAG;AAEnD,sBAAgB,MAAM,qBAAqB,OAAO;AAAA,IACpD,OAAO;AACL,YAAM,MAAM,mCAAoB;AAAA,QAC9B;AAAA,MACF;AACA,aAAO,oBAAoB,GAAG;AAAA,IAChC;AAGA,QAAI,WAAW,eAAe;AAC5B,aAAO,cAAc;AAAA,IACvB;AAEA,UAAM,YAAY,cAAc;AAGhC,UAAM,gBAAgB,MAAM,QAAQ,qBAAqB,eAAe;AAAA,MACtE;AAAA,MACA,UAAU,UAAU;AAAA,MACpB,MAAM,UAAU;AAAA,IAClB,CAAC;AAED,WAAO,IAAI;AAAA,MACT,KAAK,UAAU;AAAA,QACb,MAAM;AAAA,QACN,MAAM,UAAU;AAAA,QAChB,MAAM,UAAU;AAAA,MAClB,CAAC;AAAA,MACD;AAAA,QACE,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,MAChD;AAAA,IACF;AAAA,EACF,SAAS,OAAO;AAEd,WAAO,oBAAoB,wBAAwB,KAAK,CAAC;AAAA,EAC3D;AACF;;;AJ9NA,IAAAC,iBAAuB;;;AKUvB,IAAAC,iBAAuB;AA+CvB,eAAsB,4BAA4B;AAAA,EAChD;AAAA,EACA;AAAA,EACA;AACF,GAA+D;AAC7D,QAAM,KAAK,QAAQ;AACnB,MAAI,CAAC,GAAI;AAGT,MAAI,OAAO,OAAO,YAAY;AAC5B,WAAQ,GAAiC,EAAE,SAAS,SAAS,KAAK,CAAC;AAAA,EACrE;AAEA,wBAAO,KAAK,EAAE,GAAG,GAAG,0DAAqD;AACzE;AACF;AAEA,eAAsB,2BAA2B;AAAA,EAC/C;AAAA,EACA;AAAA,EACA;AACF,GAAoD;AAClD,QAAM,KAAK,QAAQ;AACnB,MAAI,CAAC,GAAI;AAET,MAAI,OAAO,OAAO,YAAY;AAC5B,WAAQ,GAAgC,EAAE,SAAS,UAAU,KAAK,CAAC;AAAA,EACrE;AAEA,wBAAO,KAAK,EAAE,GAAG,GAAG,yDAAoD;AAC1E;;;AC7FA,IAAAC,iBAAmD;AACnD,IAAAC,kBAA6B;AAU7B,eAAsB,mBAAmB;AAAA,EACvC;AAAA,EACA;AAAA,EACA;AACF,GAA2B;AACzB,MAAI;AACF,UAAM,SAAS,MAAM,QAAQ;AAG7B,QAAI,CAAC,OAAO,OAAO,GAAG;AACpB,aAAO,IAAI;AAAA,QACT,KAAK,UAAU;AAAA,UACb,OAAO;AAAA,UACP,SAAS,UAAU,OAAO;AAAA,QAC5B,CAAC;AAAA,QACD;AAAA,UACE,QAAQ;AAAA,UACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAChD;AAAA,MACF;AAAA,IACF;AAEA,UAAM,SAAS,IAAI,gBAAgB;AACnC,UAAM,SAAS,OAAO,SAAS,UAAU;AACzC,UAAM,UAAU,IAAI,6BAAa;AACjC,QAAI,eAAe;AAGnB,KAAC,YAAY;AACX,UAAI;AACJ,UAAI;AACF,cAAM,cAAc,MAAM,QAAQ,KAAK;AACvC,gBAAQ,mCAAoB,MAAM,WAAW;AAAA,MAC/C,QAAQ;AACN,eAAO,IAAI;AAAA,UACT,KAAK,UAAU;AAAA,YACb,OAAO;AAAA,UACT,CAAC;AAAA,UACD,EAAE,QAAQ,IAAI;AAAA,QAChB;AAAA,MACF;AAEA,YAAM,qBAAqB,0BAA0B,OAAO;AAE5D,cAAQ,OACL,QAAQ;AAAA,QACP,UAAU,MAAM;AAAA,QAChB,SAAS;AAAA,MACX,CAAC,EACA,UAAU;AAAA,QACT,MAAM,OAAO,UAAU;AACrB,cAAI,CAAC,QAAQ,OAAO,WAAW,CAAC,cAAc;AAC5C,gBAAI;AACF,oBAAM,OAAO,MAAM,QAAQ,OAAO,KAAK,CAAC;AAAA,YAC1C,SAAS,OAAO;AACd,kBAAI,iBAAiB,SAAS,MAAM,SAAS,cAAc;AACzD,+BAAe;AAAA,cACjB;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,QACA,OAAO,OAAO,UAAU;AACtB,kBAAQ,MAAM,wBAAwB,KAAK;AAC3C,cAAI,CAAC,cAAc;AACjB,gBAAI;AACF,oBAAM,OAAO,MAAM;AACnB,6BAAe;AAAA,YACjB,QAAQ;AAAA,YAER;AAAA,UACF;AAAA,QACF;AAAA,QACA,UAAU,YAAY;AACpB,cAAI,CAAC,cAAc;AACjB,gBAAI;AACF,oBAAM,OAAO,MAAM;AACnB,6BAAe;AAAA,YACjB,QAAQ;AAAA,YAER;AAAA,UACF;AAAA,QACF;AAAA,MACF,CAAC;AAAA,IACL,GAAG,EAAE,MAAM,CAAC,UAAU;AACpB,cAAQ,MAAM,wBAAwB,KAAK;AAC3C,cAAQ;AAAA,QACN;AAAA,QACA,iBAAiB,QAAQ,MAAM,QAAQ;AAAA,MACzC;AACA,cAAQ,MAAM,kBAAkB;AAAA,QAC9B,MAAM,iBAAiB,QAAQ,MAAM,OAAO;AAAA,QAC5C,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,QAC9D,OAAO,iBAAiB,QAAQ,MAAM,QAAQ;AAAA,MAChD,CAAC;AACD,UAAI,CAAC,cAAc;AACjB,YAAI;AACF,iBAAO,MAAM;AACb,yBAAe;AAAA,QACjB,QAAQ;AAAA,QAER;AAAA,MACF;AAAA,IACF,CAAC;AAGD,WAAO,IAAI,SAAS,OAAO,UAAU;AAAA,MACnC,QAAQ;AAAA,MACR,SAAS;AAAA,QACP,gBAAgB;AAAA,QAChB,iBAAiB;AAAA,QACjB,YAAY;AAAA,MACd;AAAA,IACF,CAAC;AAAA,EACH,SAAS,OAAO;AACd,YAAQ,MAAM,wBAAwB,KAAK;AAC3C,YAAQ;AAAA,MACN;AAAA,MACA,iBAAiB,QAAQ,MAAM,QAAQ;AAAA,IACzC;AACA,YAAQ,MAAM,kBAAkB;AAAA,MAC9B,MAAM,iBAAiB,QAAQ,MAAM,OAAO;AAAA,MAC5C,SAAS,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,MAC9D,OAAO,iBAAiB,QAAQ,MAAM,QAAQ;AAAA,IAChD,CAAC;AAED,WAAO,IAAI;AAAA,MACT,KAAK,UAAU;AAAA,QACb,OAAO;AAAA,QACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MACpD,CAAC;AAAA,MACD;AAAA,QACE,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AACF;;;AClJA,IAAAC,iBAA0B;AAS1B,eAAsB,gBAAgB;AAAA,EACpC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAwB;AACtB,MAAI;AACF,UAAM,SAAS,MAAM,QAAQ;AAE7B,QAAI,CAAC,OAAO,OAAO,GAAG;AACpB,aAAO,IAAI;AAAA,QACT,KAAK,UAAU;AAAA,UACb,OAAO;AAAA,UACP,SAAS,UAAU,OAAO;AAAA,QAC5B,CAAC;AAAA,QACD;AAAA,UACE,QAAQ;AAAA,UACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAChD;AAAA,MACF;AAAA,IACF;AAEA,UAAM,UAAU,MAAM,QAAQ,OAAO,KAAK,EAAE,SAAS,CAAC;AAEtD,QAAI,CAAC,SAAS;AACZ,aAAO,IAAI;AAAA,QACT,KAAK,UAAU;AAAA,UACb,SAAS;AAAA,UACT,SAAS,6BAA6B,QAAQ;AAAA,QAChD,CAAC;AAAA,QACD;AAAA,UACE,QAAQ;AAAA,UACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,QAChD;AAAA,MACF;AAAA,IACF;AAEA,WAAO,IAAI;AAAA,MACT,KAAK,UAAU;AAAA,QACb,SAAS;AAAA,QACT,WAAW;AAAA,UACT,MAAM,yBAAU;AAAA,UAChB,SAAS;AAAA,UACT,MAAM;AAAA,QACR;AAAA,MACF,CAAC;AAAA,MACD;AAAA,QACE,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,MAChD;AAAA,IACF;AAAA,EACF,SAAS,OAAO;AACd,YAAQ,MAAM,6BAA6B,KAAK;AAEhD,WAAO,IAAI;AAAA,MACT,KAAK,UAAU;AAAA,QACb,OAAO;AAAA,QACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU;AAAA,MACpD,CAAC;AAAA,MACD;AAAA,QACE,QAAQ;AAAA,QACR,SAAS,EAAE,gBAAgB,mBAAmB;AAAA,MAChD;AAAA,IACF;AAAA,EACF;AACF;;;AP1BO,SAAS,sBAAsB,EAAE,SAAS,UAAU,MAAM,WAAW,GAA0B;AACpG,QAAM,MAAM,IAAI,iBAA6B;AAE7C,SAAO,IACJ,SAAS,QAAQ,EACjB;AAAA,IACC;AAAA,QACA,kBAAK;AAAA,MACH,QAAQ,YAAY,UAAU;AAAA,MAC9B,cAAc,CAAC,OAAO,QAAQ,OAAO,QAAQ,UAAU,SAAS,SAAS;AAAA,MACzE,cAAc,CAAC,GAAG;AAAA,MAClB,aAAa,YAAY,eAAe;AAAA,IAC1C,CAAC;AAAA,EACH,EACC,IAAI,KAAK,OAAO,GAAG,SAAS;AAC3B,UAAM,UAAU,EAAE,IAAI;AACtB,UAAM,OAAO,EAAE,IAAI;AAEnB,QAAI;AACF,YAAM,uBAAuB,MAAM,4BAA4B;AAAA,QAC7D;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AACD,UAAI,sBAAsB;AACxB,UAAE,IAAI,mBAAmB,oBAAoB;AAAA,MAC/C;AAAA,IACF,SAAS,OAAO;AACd,4BAAO,MAAM,EAAE,KAAK,OAAO,KAAK,QAAQ,KAAK,KAAK,GAAG,yCAAyC;AAC9F,UAAI,iBAAiB,UAAU;AAC7B,eAAO;AAAA,MACT;AACA,YAAM;AAAA,IACR;AAEA,UAAM,KAAK;AAAA,EACb,CAAC,EACA,IAAI,KAAK,OAAO,GAAG,SAAS;AAC3B,UAAM,KAAK;AAEX,UAAM,WAAW,EAAE;AACnB,UAAM,OAAO,EAAE,IAAI;AAGnB,+BAA2B;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC,EAAE,MAAM,CAAC,UAAU;AAClB,4BAAO,MAAM,EAAE,KAAK,OAAO,KAAK,EAAE,IAAI,KAAK,KAAK,GAAG,wCAAwC;AAAA,IAC7F,CAAC;AAAA,EACH,CAAC,EACA,KAAK,uBAAuB,OAAO,MAAM;AACxC,UAAM,UAAU,EAAE,IAAI,MAAM,SAAS;AACrC,UAAM,UAAU,EAAE,IAAI,iBAAiB,KAAK,EAAE,IAAI;AAElD,QAAI;AACF,aAAO,MAAM,eAAe;AAAA,QAC1B;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,4BAAO,MAAM,EAAE,KAAK,OAAO,KAAK,QAAQ,KAAK,MAAM,EAAE,IAAI,KAAK,GAAG,+BAA+B;AAChG,YAAM;AAAA,IACR;AAAA,EACF,CAAC,EACA,KAAK,2BAA2B,OAAO,MAAM;AAC5C,UAAM,UAAU,EAAE,IAAI,MAAM,SAAS;AACrC,UAAM,UAAU,EAAE,IAAI,iBAAiB,KAAK,EAAE,IAAI;AAElD,QAAI;AACF,aAAO,MAAM,mBAAmB;AAAA,QAC9B;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,4BAAO,MAAM,EAAE,KAAK,OAAO,KAAK,QAAQ,KAAK,MAAM,EAAE,IAAI,KAAK,GAAG,+BAA+B;AAChG,YAAM;AAAA,IACR;AAAA,EACF,CAAC,EAEA,KAAK,kCAAkC,OAAO,MAAM;AACnD,UAAM,UAAU,EAAE,IAAI,MAAM,SAAS;AACrC,UAAM,WAAW,EAAE,IAAI,MAAM,UAAU;AACvC,UAAM,UAAU,EAAE,IAAI,iBAAiB,KAAK,EAAE,IAAI;AAElD,QAAI;AACF,aAAO,MAAM,gBAAgB;AAAA,QAC3B;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,4BAAO,MAAM,EAAE,KAAK,OAAO,KAAK,QAAQ,KAAK,MAAM,EAAE,IAAI,KAAK,GAAG,+BAA+B;AAChG,YAAM;AAAA,IACR;AAAA,EACF,CAAC,EACA,IAAI,SAAS,OAAO,MAAM;AACzB,UAAM,UAAU,EAAE,IAAI,iBAAiB,KAAK,EAAE,IAAI;AAElD,QAAI;AACF,aAAO,MAAM,qBAAqB;AAAA,QAChC;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,4BAAO,MAAM,EAAE,KAAK,OAAO,KAAK,QAAQ,KAAK,MAAM,EAAE,IAAI,KAAK,GAAG,+BAA+B;AAChG,YAAM;AAAA,IACR;AAAA,EACF,CAAC,EACA,KAAK,eAAe,OAAO,MAAM;AAChC,UAAM,UAAU,EAAE,IAAI,iBAAiB,KAAK,EAAE,IAAI;AAElD,QAAI;AACF,aAAO,MAAM,iBAAiB;AAAA,QAC5B;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH,SAAS,OAAO;AACd,4BAAO,MAAM,EAAE,KAAK,OAAO,KAAK,QAAQ,KAAK,MAAM,EAAE,IAAI,KAAK,GAAG,+BAA+B;AAChG,YAAM;AAAA,IACR;AAAA,EACF,CAAC,EACA,SAAS,CAAC,MAAM;AACf,WAAO,EAAE,KAAK,EAAE,OAAO,YAAY,GAAG,GAAG;AAAA,EAC3C,CAAC;AAGL;;;AQpLA,IAAAC,eAAqB;AACrB,IAAAC,eAAqB;AAQrB,IAAAC,iBAAuB;;;ACTvB,IAAM,eAAe;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF;AAgBA,eAAsB,gBAAgB,SAAuC;AAC3E,QAAM,cAAc,QAAQ,QAAQ,IAAI,cAAc,KAAK;AAE3D,MAAI,CAAC,YAAY,SAAS,kBAAkB,GAAG;AAC7C,UAAM,oBAAoB,+CAA+C,GAAG;AAAA,EAC9E;AAEA,MAAI;AACJ,MAAI;AACF,mBAAgB,MAAM,QAAQ,MAAM,EAAE,KAAK;AAAA,EAC7C,SAAS,OAAO;AACd,UAAM,oBAAoB,wBAAwB,GAAG;AAAA,EACvD;AAEA,QAAM,SAAS,eAAe,aAAa,MAAM;AAEjD,SAAO;AAAA,IACL;AAAA,IACA,QAAQ,aAAa;AAAA,IACrB,MAAM,aAAa;AAAA,EACrB;AACF;AAEO,SAAS,aAAa,QAA6C,KAAqB;AAC7F,QAAM,QAAQ,SAAS,GAAG;AAC1B,MAAI,OAAO,UAAU,YAAY,MAAM,KAAK,EAAE,SAAS,GAAG;AACxD,WAAO;AAAA,EACT;AAEA,QAAM,oBAAoB,iCAAiC,GAAG,KAAK,GAAG;AACxE;AAEO,SAAS,kBAAkB,MAAe,MAAwB;AACvE,MAAI,SAAS,UAAa,SAAS,MAAM;AACvC,UAAM,oBAAoB,yCAAyC,GAAG;AAAA,EACxE;AAEA,QAAM,UAAU,IAAI,QAAQ,KAAK,OAAO;AACxC,UAAQ,IAAI,gBAAgB,kBAAkB;AAC9C,UAAQ,OAAO,gBAAgB;AAE/B,QAAM,iBAAiB,kBAAkB,IAAI;AAE7C,SAAO,IAAI,QAAQ,KAAK,KAAK;AAAA,IAC3B,QAAQ;AAAA,IACR;AAAA,IACA,MAAM;AAAA,IACN,QAAQ,KAAK;AAAA,EACf,CAAC;AACH;AAEO,SAAS,oBAAoB,SAAiB,QAA0B;AAC7E,SAAO,IAAI;AAAA,IACT,KAAK,UAAU;AAAA,MACb,OAAO;AAAA,MACP;AAAA,IACF,CAAC;AAAA,IACD;AAAA,MACE;AAAA,MACA,SAAS;AAAA,QACP,gBAAgB;AAAA,MAClB;AAAA,IACF;AAAA,EACF;AACF;AAEA,SAAS,eAAe,QAA4C;AAClE,MAAI,CAAC,QAAQ;AACX,UAAM,oBAAoB,wBAAwB,GAAG;AAAA,EACvD;AAEA,MAAK,aAAmC,SAAS,MAAM,GAAG;AACxD,WAAO;AAAA,EACT;AAEA,QAAM,oBAAoB,uBAAuB,MAAM,KAAK,GAAG;AACjE;AAEA,SAAS,kBAAkB,MAAyB;AAClD,MAAI,OAAO,SAAS,UAAU;AAC5B,WAAO;AAAA,EACT;AAEA,MAAI,gBAAgB,QAAQ,gBAAgB,eAAe,gBAAgB,YAAY;AACrF,WAAO;AAAA,EACT;AAEA,MAAI,gBAAgB,YAAY,gBAAgB,iBAAiB;AAC/D,WAAO;AAAA,EACT;AAEA,SAAO,KAAK,UAAU,IAAI;AAC5B;;;AD3EO,SAAS,iCAAiC,EAAE,SAAS,UAAU,MAAM,WAAW,GAAgC;AACrH,QAAM,MAAM,IAAI,kBAA6B;AAC7C,QAAM,YAAY,cAAc,QAAQ;AAExC,SAAO,IACJ,SAAS,SAAS,EAClB;AAAA,IACC;AAAA,QACA,mBAAK;AAAA,MACH,QAAQ,YAAY,UAAU;AAAA,MAC9B,cAAc,CAAC,OAAO,QAAQ,OAAO,QAAQ,UAAU,SAAS,SAAS;AAAA,MACzE,cAAc,CAAC,GAAG;AAAA,MAClB,aAAa,YAAY,eAAe;AAAA,IAC1C,CAAC;AAAA,EACH,EACC,IAAI,KAAK,OAAO,GAAG,SAAS;AAC3B,UAAM,UAAU,EAAE,IAAI;AACtB,UAAM,OAAO,EAAE,IAAI;AAEnB,QAAI;AACF,YAAM,uBAAuB,MAAM,4BAA4B;AAAA,QAC7D;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AACD,UAAI,sBAAsB;AACxB,UAAE,IAAI,mBAAmB,oBAAoB;AAAA,MAC/C;AAAA,IACF,SAAS,OAAO;AACd,4BAAO,MAAM,EAAE,KAAK,OAAO,KAAK,QAAQ,KAAK,KAAK,GAAG,yCAAyC;AAC9F,UAAI,iBAAiB,UAAU;AAC7B,eAAO;AAAA,MACT;AACA,YAAM;AAAA,IACR;AAEA,UAAM,KAAK;AAAA,EACb,CAAC,EACA,IAAI,KAAK,OAAO,GAAG,SAAS;AAC3B,UAAM,KAAK;AAEX,UAAM,WAAW,EAAE;AACnB,UAAM,OAAO,EAAE,IAAI;AAEnB,+BAA2B;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC,EAAE,MAAM,CAAC,UAAU;AAClB,4BAAO,MAAM,EAAE,KAAK,OAAO,KAAK,EAAE,IAAI,KAAK,KAAK,GAAG,wCAAwC;AAAA,IAC7F,CAAC;AAAA,EACH,CAAC,EACA,KAAK,KAAK,OAAO,MAAM;AACtB,UAAM,UAAU,EAAE,IAAI,iBAAiB,KAAK,EAAE,IAAI;AAElD,QAAI;AACJ,QAAI;AACF,mBAAa,MAAM,gBAAgB,OAAO;AAAA,IAC5C,SAAS,OAAO;AACd,UAAI,iBAAiB,UAAU;AAC7B,8BAAO,KAAK,EAAE,KAAK,QAAQ,IAAI,GAAG,8BAA8B;AAChE,eAAO;AAAA,MACT;AACA,4BAAO,KAAK,EAAE,KAAK,OAAO,KAAK,QAAQ,IAAI,GAAG,8BAA8B;AAC5E,aAAO,EAAE;AAAA,QACP;AAAA,UACE,OAAO;AAAA,UACP,SAAS,iBAAiB,QAAQ,MAAM,UAAU;AAAA,QACpD;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAEA,QAAI;AACF,cAAQ,WAAW,QAAQ;AAAA,QACzB,KAAK,aAAa;AAChB,gBAAM,UAAU,aAAa,WAAW,QAAQ,SAAS;AACzD,gBAAM,iBAAiB,kBAAkB,SAAS,WAAW,IAAI;AACjE,iBAAO,MAAM,eAAe,EAAE,SAAS,SAAS,gBAAgB,QAAQ,CAAC;AAAA,QAC3E;AAAA,QACA,KAAK,iBAAiB;AACpB,gBAAM,UAAU,aAAa,WAAW,QAAQ,SAAS;AACzD,gBAAM,iBAAiB,kBAAkB,SAAS,WAAW,IAAI;AACjE,iBAAO,MAAM,mBAAmB,EAAE,SAAS,SAAS,gBAAgB,QAAQ,CAAC;AAAA,QAC/E;AAAA,QACA,KAAK,cAAc;AACjB,gBAAM,UAAU,aAAa,WAAW,QAAQ,SAAS;AACzD,gBAAM,WAAW,aAAa,WAAW,QAAQ,UAAU;AAC3D,iBAAO,MAAM,gBAAgB,EAAE,SAAS,SAAS,SAAS,SAAS,CAAC;AAAA,QACtE;AAAA,QACA,KAAK,QAAQ;AACX,iBAAO,MAAM,qBAAqB,EAAE,SAAS,QAAQ,CAAC;AAAA,QACxD;AAAA,QACA,KAAK,cAAc;AACjB,gBAAM,iBAAiB,kBAAkB,SAAS,WAAW,IAAI;AACjE,iBAAO,MAAM,iBAAiB,EAAE,SAAS,SAAS,eAAe,CAAC;AAAA,QACpE;AAAA,QACA,SAAS;AACP,gBAAM,kBAAyB,WAAW;AAC1C,iBAAO;AAAA,QACT;AAAA,MACF;AAAA,IACF,SAAS,OAAO;AACd,UAAI,iBAAiB,UAAU;AAC7B,eAAO;AAAA,MACT;AACA,4BAAO,MAAM,EAAE,KAAK,OAAO,KAAK,QAAQ,KAAK,QAAQ,WAAW,OAAO,GAAG,oCAAoC;AAC9G,YAAM;AAAA,IACR;AAAA,EACF,CAAC,EACA,SAAS,CAAC,MAAM;AACf,WAAO,EAAE,KAAK,EAAE,OAAO,YAAY,GAAG,GAAG;AAAA,EAC3C,CAAC;AACL;AAEA,SAAS,cAAc,MAAsB;AAC3C,MAAI,CAAC,MAAM;AACT,UAAM,IAAI,MAAM,qDAAqD;AAAA,EACvE;AAEA,MAAI,CAAC,KAAK,WAAW,GAAG,GAAG;AACzB,WAAO,IAAI,IAAI;AAAA,EACjB;AAEA,MAAI,KAAK,SAAS,KAAK,KAAK,SAAS,GAAG,GAAG;AACzC,WAAO,KAAK,MAAM,GAAG,EAAE;AAAA,EACzB;AAEA,SAAO;AACT;;;AEtKA,IAAAC,iBAAkC;;;ACM3B,IAAe,uBAAf,MAAoC;AAE3C;","names":["import_client","import_shared","import_shared","import_shared","import_client","import_encoder","import_client","import_hono","import_cors","import_shared","import_shared"]}