import {
  __publicField
} from "./chunk-NSSMTXJJ.mjs";

// ../../observability/dist/chunk-NFEGQTCC.mjs
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/dist/esm/trace/SemanticConventions.js
var SemanticAttributePrefixes = {
  input: "input",
  output: "output",
  llm: "llm",
  retrieval: "retrieval",
  reranker: "reranker",
  messages: "messages",
  message: "message",
  document: "document",
  embedding: "embedding",
  tool: "tool",
  tool_call: "tool_call",
  metadata: "metadata",
  tag: "tag",
  session: "session",
  user: "user",
  openinference: "openinference",
  message_content: "message_content",
  image: "image",
  audio: "audio",
  prompt: "prompt",
  agent: "agent",
  graph: "graph"
};
var LLMAttributePostfixes = {
  provider: "provider",
  system: "system",
  model_name: "model_name",
  token_count: "token_count",
  input_messages: "input_messages",
  output_messages: "output_messages",
  invocation_parameters: "invocation_parameters",
  prompts: "prompts",
  prompt_template: "prompt_template",
  function_call: "function_call",
  tools: "tools",
  cost: "cost"
};
var RetrievalAttributePostfixes = {
  documents: "documents"
};
var RerankerAttributePostfixes = {
  input_documents: "input_documents",
  output_documents: "output_documents",
  query: "query",
  model_name: "model_name",
  top_k: "top_k"
};
var EmbeddingAttributePostfixes = {
  embeddings: "embeddings",
  text: "text",
  model_name: "model_name",
  vector: "vector"
};
var ToolAttributePostfixes = {
  name: "name",
  description: "description",
  parameters: "parameters",
  json_schema: "json_schema"
};
var MessageAttributePostfixes = {
  role: "role",
  content: "content",
  contents: "contents",
  name: "name",
  function_call_name: "function_call_name",
  function_call_arguments_json: "function_call_arguments_json",
  tool_calls: "tool_calls",
  tool_call_id: "tool_call_id"
};
var MessageContentsAttributePostfixes = {
  type: "type",
  text: "text",
  image: "image"
};
var ImageAttributesPostfixes = {
  url: "url"
};
var ToolCallAttributePostfixes = {
  function_name: "function.name",
  function_arguments_json: "function.arguments",
  id: "id"
};
var DocumentAttributePostfixes = {
  id: "id",
  content: "content",
  score: "score",
  metadata: "metadata"
};
var TagAttributePostfixes = {
  tags: "tags"
};
var SessionAttributePostfixes = {
  id: "id"
};
var UserAttributePostfixes = {
  id: "id"
};
var AudioAttributesPostfixes = {
  url: "url",
  mime_type: "mime_type",
  transcript: "transcript"
};
var PromptAttributePostfixes = {
  vendor: "vendor",
  id: "id",
  url: "url"
};
var AgentPostfixes = {
  name: "name"
};
var GraphPostfixes = {
  node_id: "node.id",
  node_name: "node.name",
  node_parent_id: "node.parent_id"
};
var INPUT_VALUE = `${SemanticAttributePrefixes.input}.value`;
var INPUT_MIME_TYPE = `${SemanticAttributePrefixes.input}.mime_type`;
var OUTPUT_VALUE = `${SemanticAttributePrefixes.output}.value`;
var OUTPUT_MIME_TYPE = `${SemanticAttributePrefixes.output}.mime_type`;
var LLM_INPUT_MESSAGES = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.input_messages}`;
var LLM_PROMPTS = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.prompts}`;
var LLM_INVOCATION_PARAMETERS = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.invocation_parameters}`;
var LLM_OUTPUT_MESSAGES = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.output_messages}`;
var LLM_MODEL_NAME = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.model_name}`;
var LLM_PROVIDER = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.provider}`;
var LLM_SYSTEM = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.system}`;
var LLM_TOKEN_COUNT_COMPLETION = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion`;
var LLM_TOKEN_COUNT_COMPLETION_DETAILS_REASONING = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion_details.reasoning`;
var LLM_TOKEN_COUNT_COMPLETION_DETAILS_AUDIO = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion_details.audio`;
var LLM_TOKEN_COUNT_PROMPT = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt`;
var LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_WRITE = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.cache_write`;
var LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_READ = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.cache_read`;
var LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_INPUT = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.cache_input`;
var LLM_TOKEN_COUNT_PROMPT_DETAILS_AUDIO = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.audio`;
var LLM_TOKEN_COUNT_TOTAL = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.total`;
var LLM_TOKEN_COUNT_PROMPT_DETAILS = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details`;
var LLM_TOKEN_COUNT_COMPLETION_DETAILS = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion_details`;
var LLM_COST = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}`;
var LLM_COST_PROMPT = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt`;
var LLM_COST_COMPLETION = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion`;
var LLM_COST_TOTAL = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.total`;
var LLM_COST_INPUT = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.input`;
var LLM_COST_OUTPUT = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion_details.output`;
var LLM_COST_COMPLETION_DETAILS_REASONING = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion_details.reasoning`;
var LLM_COST_COMPLETION_DETAILS_AUDIO = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion_details.audio`;
var LLM_COST_PROMPT_DETAILS_CACHE_WRITE = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.cache_write`;
var LLM_COST_PROMPT_DETAILS_CACHE_READ = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.cache_read`;
var LLM_COST_PROMPT_DETAILS_CACHE_INPUT = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.cache_input`;
var LLM_COST_PROMPT_DETAILS_AUDIO = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.audio`;
var MESSAGE_ROLE = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.role}`;
var MESSAGE_NAME = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.name}`;
var MESSAGE_TOOL_CALLS = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.tool_calls}`;
var MESSAGE_TOOL_CALL_ID = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.tool_call_id}`;
var TOOL_CALL_FUNCTION_NAME = `${SemanticAttributePrefixes.tool_call}.${ToolCallAttributePostfixes.function_name}`;
var TOOL_CALL_FUNCTION_ARGUMENTS_JSON = `${SemanticAttributePrefixes.tool_call}.${ToolCallAttributePostfixes.function_arguments_json}`;
var TOOL_CALL_ID = `${SemanticAttributePrefixes.tool_call}.${ToolCallAttributePostfixes.id}`;
var MESSAGE_FUNCTION_CALL_NAME = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.function_call_name}`;
var MESSAGE_FUNCTION_CALL_ARGUMENTS_JSON = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.function_call_arguments_json}`;
var MESSAGE_CONTENT = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.content}`;
var MESSAGE_CONTENTS = `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.contents}`;
var MESSAGE_CONTENT_TYPE = `${SemanticAttributePrefixes.message_content}.${MessageContentsAttributePostfixes.type}`;
var MESSAGE_CONTENT_TEXT = `${SemanticAttributePrefixes.message_content}.${MessageContentsAttributePostfixes.text}`;
var MESSAGE_CONTENT_IMAGE = `${SemanticAttributePrefixes.message_content}.${MessageContentsAttributePostfixes.image}`;
var IMAGE_URL = `${SemanticAttributePrefixes.image}.${ImageAttributesPostfixes.url}`;
var DOCUMENT_ID = `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.id}`;
var DOCUMENT_CONTENT = `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.content}`;
var DOCUMENT_SCORE = `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.score}`;
var DOCUMENT_METADATA = `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.metadata}`;
var EMBEDDING_TEXT = `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.text}`;
var EMBEDDING_MODEL_NAME = `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.model_name}`;
var EMBEDDING_VECTOR = `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.vector}`;
var EMBEDDING_EMBEDDINGS = `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.embeddings}`;
var RETRIEVAL_DOCUMENTS = `${SemanticAttributePrefixes.retrieval}.${RetrievalAttributePostfixes.documents}`;
var PROMPT_TEMPLATE_PREFIX = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.prompt_template}`;
var PROMPT_TEMPLATE_VARIABLES = `${PROMPT_TEMPLATE_PREFIX}.variables`;
var PROMPT_TEMPLATE_TEMPLATE = `${PROMPT_TEMPLATE_PREFIX}.template`;
var LLM_FUNCTION_CALL = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.function_call}`;
var LLM_TOOLS = `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.tools}`;
var TOOL_NAME = `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.name}`;
var TOOL_DESCRIPTION = `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.description}`;
var TOOL_PARAMETERS = `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.parameters}`;
var TOOL_JSON_SCHEMA = `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.json_schema}`;
var SESSION_ID = `${SemanticAttributePrefixes.session}.${SessionAttributePostfixes.id}`;
var USER_ID = `${SemanticAttributePrefixes.user}.${UserAttributePostfixes.id}`;
var RERANKER_INPUT_DOCUMENTS = `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.input_documents}`;
var RERANKER_OUTPUT_DOCUMENTS = `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.output_documents}`;
var RERANKER_QUERY = `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.query}`;
var RERANKER_MODEL_NAME = `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.model_name}`;
var RERANKER_TOP_K = `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.top_k}`;
var METADATA = "metadata";
var PROMPT_TEMPLATE_VERSION = `${PROMPT_TEMPLATE_PREFIX}.version`;
var TAG_TAGS = `${SemanticAttributePrefixes.tag}.${TagAttributePostfixes.tags}`;
var AUDIO_URL = `${SemanticAttributePrefixes.audio}.${AudioAttributesPostfixes.url}`;
var AUDIO_MIME_TYPE = `${SemanticAttributePrefixes.audio}.${AudioAttributesPostfixes.mime_type}`;
var AUDIO_TRANSCRIPT = `${SemanticAttributePrefixes.audio}.${AudioAttributesPostfixes.transcript}`;
var PROMPT_VENDOR = `${SemanticAttributePrefixes.prompt}.${PromptAttributePostfixes.vendor}`;
var PROMPT_ID = `${SemanticAttributePrefixes.prompt}.${PromptAttributePostfixes.id}`;
var PROMPT_URL = `${SemanticAttributePrefixes.prompt}.${PromptAttributePostfixes.url}`;
var AGENT_NAME = `${SemanticAttributePrefixes.agent}.${AgentPostfixes.name}`;
var GRAPH_NODE_ID = `${SemanticAttributePrefixes.graph}.${GraphPostfixes.node_id}`;
var GRAPH_NODE_NAME = `${SemanticAttributePrefixes.graph}.${GraphPostfixes.node_name}`;
var GRAPH_NODE_PARENT_ID = `${SemanticAttributePrefixes.graph}.${GraphPostfixes.node_parent_id}`;
var SemanticConventions = {
  IMAGE_URL,
  INPUT_VALUE,
  INPUT_MIME_TYPE,
  OUTPUT_VALUE,
  OUTPUT_MIME_TYPE,
  LLM_INPUT_MESSAGES,
  LLM_OUTPUT_MESSAGES,
  LLM_MODEL_NAME,
  LLM_PROMPTS,
  LLM_INVOCATION_PARAMETERS,
  LLM_TOKEN_COUNT_COMPLETION,
  LLM_TOKEN_COUNT_COMPLETION_DETAILS,
  LLM_TOKEN_COUNT_COMPLETION_DETAILS_REASONING,
  LLM_TOKEN_COUNT_COMPLETION_DETAILS_AUDIO,
  LLM_TOKEN_COUNT_PROMPT,
  LLM_TOKEN_COUNT_PROMPT_DETAILS,
  LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_WRITE,
  LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_READ,
  LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_INPUT,
  LLM_TOKEN_COUNT_PROMPT_DETAILS_AUDIO,
  LLM_TOKEN_COUNT_TOTAL,
  LLM_SYSTEM,
  LLM_PROVIDER,
  LLM_TOOLS,
  LLM_COST,
  LLM_COST_PROMPT,
  LLM_COST_COMPLETION,
  LLM_COST_TOTAL,
  LLM_COST_INPUT,
  LLM_COST_OUTPUT,
  LLM_COST_COMPLETION_DETAILS_REASONING,
  LLM_COST_COMPLETION_DETAILS_AUDIO,
  LLM_COST_PROMPT_DETAILS_CACHE_WRITE,
  LLM_COST_PROMPT_DETAILS_CACHE_READ,
  LLM_COST_PROMPT_DETAILS_CACHE_INPUT,
  LLM_COST_PROMPT_DETAILS_AUDIO,
  MESSAGE_ROLE,
  MESSAGE_NAME,
  MESSAGE_TOOL_CALLS,
  MESSAGE_TOOL_CALL_ID,
  TOOL_CALL_ID,
  TOOL_CALL_FUNCTION_NAME,
  TOOL_CALL_FUNCTION_ARGUMENTS_JSON,
  MESSAGE_FUNCTION_CALL_NAME,
  MESSAGE_FUNCTION_CALL_ARGUMENTS_JSON,
  MESSAGE_CONTENT,
  MESSAGE_CONTENTS,
  MESSAGE_CONTENT_IMAGE,
  MESSAGE_CONTENT_TEXT,
  MESSAGE_CONTENT_TYPE,
  DOCUMENT_ID,
  DOCUMENT_CONTENT,
  DOCUMENT_SCORE,
  DOCUMENT_METADATA,
  EMBEDDING_EMBEDDINGS,
  EMBEDDING_TEXT,
  EMBEDDING_MODEL_NAME,
  EMBEDDING_VECTOR,
  TOOL_DESCRIPTION,
  TOOL_NAME,
  TOOL_PARAMETERS,
  TOOL_JSON_SCHEMA,
  PROMPT_TEMPLATE_VARIABLES,
  PROMPT_TEMPLATE_TEMPLATE,
  PROMPT_TEMPLATE_VERSION,
  RERANKER_INPUT_DOCUMENTS,
  RERANKER_OUTPUT_DOCUMENTS,
  RERANKER_QUERY,
  RERANKER_MODEL_NAME,
  RERANKER_TOP_K,
  LLM_FUNCTION_CALL,
  RETRIEVAL_DOCUMENTS,
  SESSION_ID,
  USER_ID,
  METADATA,
  TAG_TAGS,
  OPENINFERENCE_SPAN_KIND: `${SemanticAttributePrefixes.openinference}.span.kind`,
  PROMPT_VENDOR,
  PROMPT_ID,
  PROMPT_URL,
  AGENT_NAME,
  GRAPH_NODE_ID,
  GRAPH_NODE_NAME,
  GRAPH_NODE_PARENT_ID
};
var OpenInferenceSpanKind;
(function(OpenInferenceSpanKind2) {
  OpenInferenceSpanKind2["LLM"] = "LLM";
  OpenInferenceSpanKind2["CHAIN"] = "CHAIN";
  OpenInferenceSpanKind2["TOOL"] = "TOOL";
  OpenInferenceSpanKind2["RETRIEVER"] = "RETRIEVER";
  OpenInferenceSpanKind2["RERANKER"] = "RERANKER";
  OpenInferenceSpanKind2["EMBEDDING"] = "EMBEDDING";
  OpenInferenceSpanKind2["AGENT"] = "AGENT";
  OpenInferenceSpanKind2["GUARDRAIL"] = "GUARDRAIL";
  OpenInferenceSpanKind2["EVALUATOR"] = "EVALUATOR";
})(OpenInferenceSpanKind || (OpenInferenceSpanKind = {}));
var MimeType;
(function(MimeType2) {
  MimeType2["TEXT"] = "text/plain";
  MimeType2["JSON"] = "application/json";
  MimeType2["AUDIO_WAV"] = "audio/wav";
})(MimeType || (MimeType = {}));
var LLMSystem;
(function(LLMSystem2) {
  LLMSystem2["OPENAI"] = "openai";
  LLMSystem2["ANTHROPIC"] = "anthropic";
  LLMSystem2["MISTRALAI"] = "mistralai";
  LLMSystem2["COHERE"] = "cohere";
  LLMSystem2["VERTEXAI"] = "vertexai";
  LLMSystem2["AI21"] = "ai21";
  LLMSystem2["META"] = "meta";
  LLMSystem2["AMAZON"] = "amazon";
})(LLMSystem || (LLMSystem = {}));
var LLMProvider;
(function(LLMProvider2) {
  LLMProvider2["OPENAI"] = "openai";
  LLMProvider2["ANTHROPIC"] = "anthropic";
  LLMProvider2["MISTRALAI"] = "mistralai";
  LLMProvider2["COHERE"] = "cohere";
  LLMProvider2["GOOGLE"] = "google";
  LLMProvider2["AWS"] = "aws";
  LLMProvider2["AZURE"] = "azure";
  LLMProvider2["XAI"] = "xai";
  LLMProvider2["DEEPSEEK"] = "deepseek";
})(LLMProvider || (LLMProvider = {}));

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/platform/node/globalThis.js
var _globalThis = typeof globalThis === "object" ? globalThis : global;

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/version.js
var VERSION = "1.9.0";

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/internal/semver.js
var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
function _makeCompatibilityCheck(ownVersion) {
  var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
  var rejectedVersions = /* @__PURE__ */ new Set();
  var myVersionMatch = ownVersion.match(re);
  if (!myVersionMatch) {
    return function() {
      return false;
    };
  }
  var ownVersionParsed = {
    major: +myVersionMatch[1],
    minor: +myVersionMatch[2],
    patch: +myVersionMatch[3],
    prerelease: myVersionMatch[4]
  };
  if (ownVersionParsed.prerelease != null) {
    return function isExactmatch(globalVersion) {
      return globalVersion === ownVersion;
    };
  }
  function _reject(v) {
    rejectedVersions.add(v);
    return false;
  }
  function _accept(v) {
    acceptedVersions.add(v);
    return true;
  }
  return function isCompatible2(globalVersion) {
    if (acceptedVersions.has(globalVersion)) {
      return true;
    }
    if (rejectedVersions.has(globalVersion)) {
      return false;
    }
    var globalVersionMatch = globalVersion.match(re);
    if (!globalVersionMatch) {
      return _reject(globalVersion);
    }
    var globalVersionParsed = {
      major: +globalVersionMatch[1],
      minor: +globalVersionMatch[2],
      patch: +globalVersionMatch[3],
      prerelease: globalVersionMatch[4]
    };
    if (globalVersionParsed.prerelease != null) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major !== globalVersionParsed.major) {
      return _reject(globalVersion);
    }
    if (ownVersionParsed.major === 0) {
      if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    }
    if (ownVersionParsed.minor <= globalVersionParsed.minor) {
      return _accept(globalVersion);
    }
    return _reject(globalVersion);
  };
}
var isCompatible = _makeCompatibilityCheck(VERSION);

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/internal/global-utils.js
var major = VERSION.split(".")[0];
var GLOBAL_OPENTELEMETRY_API_KEY = /* @__PURE__ */ Symbol.for("opentelemetry.js.api." + major);
var _global = _globalThis;
function registerGlobal(type, instance, diag, allowOverride) {
  var _a;
  if (allowOverride === void 0) {
    allowOverride = false;
  }
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a !== void 0 ? _a : {
    version: VERSION
  };
  if (!allowOverride && api[type]) {
    var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
    diag.error(err.stack || err.message);
    return false;
  }
  if (api.version !== VERSION) {
    var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
    diag.error(err.stack || err.message);
    return false;
  }
  api[type] = instance;
  diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
  return true;
}
function getGlobal(type) {
  var _a, _b;
  var globalVersion = (_a = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a === void 0 ? void 0 : _a.version;
  if (!globalVersion || !isCompatible(globalVersion)) {
    return;
  }
  return (_b = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b === void 0 ? void 0 : _b[type];
}
function unregisterGlobal(type, diag) {
  diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
  var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
  if (api) {
    delete api[type];
  }
}

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/ComponentLogger.js
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var DiagComponentLogger = (
  /** @class */
  (function() {
    function DiagComponentLogger2(props) {
      this._namespace = props.namespace || "DiagComponentLogger";
    }
    DiagComponentLogger2.prototype.debug = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("debug", this._namespace, args);
    };
    DiagComponentLogger2.prototype.error = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("error", this._namespace, args);
    };
    DiagComponentLogger2.prototype.info = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("info", this._namespace, args);
    };
    DiagComponentLogger2.prototype.warn = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("warn", this._namespace, args);
    };
    DiagComponentLogger2.prototype.verbose = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      return logProxy("verbose", this._namespace, args);
    };
    return DiagComponentLogger2;
  })()
);
function logProxy(funcName, namespace, args) {
  var logger = getGlobal("diag");
  if (!logger) {
    return;
  }
  args.unshift(namespace);
  return logger[funcName].apply(logger, __spreadArray([], __read(args), false));
}

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/types.js
var DiagLogLevel;
(function(DiagLogLevel2) {
  DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
  DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
  DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
  DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
  DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
  DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
  DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
})(DiagLogLevel || (DiagLogLevel = {}));

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/diag/internal/logLevelLogger.js
function createLogLevelDiagLogger(maxLevel, logger) {
  if (maxLevel < DiagLogLevel.NONE) {
    maxLevel = DiagLogLevel.NONE;
  } else if (maxLevel > DiagLogLevel.ALL) {
    maxLevel = DiagLogLevel.ALL;
  }
  logger = logger || {};
  function _filterFunc(funcName, theLevel) {
    var theFunc = logger[funcName];
    if (typeof theFunc === "function" && maxLevel >= theLevel) {
      return theFunc.bind(logger);
    }
    return function() {
    };
  }
  return {
    error: _filterFunc("error", DiagLogLevel.ERROR),
    warn: _filterFunc("warn", DiagLogLevel.WARN),
    info: _filterFunc("info", DiagLogLevel.INFO),
    debug: _filterFunc("debug", DiagLogLevel.DEBUG),
    verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
  };
}

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/diag.js
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME = "diag";
var DiagAPI = (
  /** @class */
  (function() {
    function DiagAPI2() {
      function _logProxy(funcName) {
        return function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var logger = getGlobal("diag");
          if (!logger)
            return;
          return logger[funcName].apply(logger, __spreadArray2([], __read2(args), false));
        };
      }
      var self = this;
      var setLogger = function(logger, optionsOrLogLevel) {
        var _a, _b, _c;
        if (optionsOrLogLevel === void 0) {
          optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
        }
        if (logger === self) {
          var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
          self.error((_a = err.stack) !== null && _a !== void 0 ? _a : err.message);
          return false;
        }
        if (typeof optionsOrLogLevel === "number") {
          optionsOrLogLevel = {
            logLevel: optionsOrLogLevel
          };
        }
        var oldLogger = getGlobal("diag");
        var newLogger = createLogLevelDiagLogger((_b = optionsOrLogLevel.logLevel) !== null && _b !== void 0 ? _b : DiagLogLevel.INFO, logger);
        if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
          var stack = (_c = new Error().stack) !== null && _c !== void 0 ? _c : "<failed to generate stacktrace>";
          oldLogger.warn("Current logger will be overwritten from " + stack);
          newLogger.warn("Current logger will overwrite one already registered from " + stack);
        }
        return registerGlobal("diag", newLogger, self, true);
      };
      self.setLogger = setLogger;
      self.disable = function() {
        unregisterGlobal(API_NAME, self);
      };
      self.createComponentLogger = function(options) {
        return new DiagComponentLogger(options);
      };
      self.verbose = _logProxy("verbose");
      self.debug = _logProxy("debug");
      self.info = _logProxy("info");
      self.warn = _logProxy("warn");
      self.error = _logProxy("error");
    }
    DiagAPI2.instance = function() {
      if (!this._instance) {
        this._instance = new DiagAPI2();
      }
      return this._instance;
    };
    return DiagAPI2;
  })()
);

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context/context.js
function createContextKey(description) {
  return Symbol.for(description);
}
var BaseContext = (
  /** @class */
  /* @__PURE__ */ (function() {
    function BaseContext2(parentContext) {
      var self = this;
      self._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
      self.getValue = function(key) {
        return self._currentContext.get(key);
      };
      self.setValue = function(key, value) {
        var context2 = new BaseContext2(self._currentContext);
        context2._currentContext.set(key, value);
        return context2;
      };
      self.deleteValue = function(key) {
        var context2 = new BaseContext2(self._currentContext);
        context2._currentContext.delete(key);
        return context2;
      };
    }
    return BaseContext2;
  })()
);
var ROOT_CONTEXT = new BaseContext();

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context/NoopContextManager.js
var __read3 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray3 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var NoopContextManager = (
  /** @class */
  (function() {
    function NoopContextManager2() {
    }
    NoopContextManager2.prototype.active = function() {
      return ROOT_CONTEXT;
    };
    NoopContextManager2.prototype.with = function(_context, fn, thisArg) {
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return fn.call.apply(fn, __spreadArray3([thisArg], __read3(args), false));
    };
    NoopContextManager2.prototype.bind = function(_context, target) {
      return target;
    };
    NoopContextManager2.prototype.enable = function() {
      return this;
    };
    NoopContextManager2.prototype.disable = function() {
      return this;
    };
    return NoopContextManager2;
  })()
);

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/context.js
var __read4 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray4 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var API_NAME2 = "context";
var NOOP_CONTEXT_MANAGER = new NoopContextManager();
var ContextAPI = (
  /** @class */
  (function() {
    function ContextAPI2() {
    }
    ContextAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new ContextAPI2();
      }
      return this._instance;
    };
    ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
      return registerGlobal(API_NAME2, contextManager, DiagAPI.instance());
    };
    ContextAPI2.prototype.active = function() {
      return this._getContextManager().active();
    };
    ContextAPI2.prototype.with = function(context2, fn, thisArg) {
      var _a;
      var args = [];
      for (var _i = 3; _i < arguments.length; _i++) {
        args[_i - 3] = arguments[_i];
      }
      return (_a = this._getContextManager()).with.apply(_a, __spreadArray4([context2, fn, thisArg], __read4(args), false));
    };
    ContextAPI2.prototype.bind = function(context2, target) {
      return this._getContextManager().bind(context2, target);
    };
    ContextAPI2.prototype._getContextManager = function() {
      return getGlobal(API_NAME2) || NOOP_CONTEXT_MANAGER;
    };
    ContextAPI2.prototype.disable = function() {
      this._getContextManager().disable();
      unregisterGlobal(API_NAME2, DiagAPI.instance());
    };
    return ContextAPI2;
  })()
);

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/trace_flags.js
var TraceFlags;
(function(TraceFlags2) {
  TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
  TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
})(TraceFlags || (TraceFlags = {}));

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/invalid-span-constants.js
var INVALID_SPANID = "0000000000000000";
var INVALID_TRACEID = "00000000000000000000000000000000";
var INVALID_SPAN_CONTEXT = {
  traceId: INVALID_TRACEID,
  spanId: INVALID_SPANID,
  traceFlags: TraceFlags.NONE
};

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NonRecordingSpan.js
var NonRecordingSpan = (
  /** @class */
  (function() {
    function NonRecordingSpan2(_spanContext) {
      if (_spanContext === void 0) {
        _spanContext = INVALID_SPAN_CONTEXT;
      }
      this._spanContext = _spanContext;
    }
    NonRecordingSpan2.prototype.spanContext = function() {
      return this._spanContext;
    };
    NonRecordingSpan2.prototype.setAttribute = function(_key, _value) {
      return this;
    };
    NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
      return this;
    };
    NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
      return this;
    };
    NonRecordingSpan2.prototype.addLink = function(_link) {
      return this;
    };
    NonRecordingSpan2.prototype.addLinks = function(_links) {
      return this;
    };
    NonRecordingSpan2.prototype.setStatus = function(_status) {
      return this;
    };
    NonRecordingSpan2.prototype.updateName = function(_name) {
      return this;
    };
    NonRecordingSpan2.prototype.end = function(_endTime) {
    };
    NonRecordingSpan2.prototype.isRecording = function() {
      return false;
    };
    NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
    };
    return NonRecordingSpan2;
  })()
);

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/context-utils.js
var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
function getSpan(context2) {
  return context2.getValue(SPAN_KEY) || void 0;
}
function getActiveSpan() {
  return getSpan(ContextAPI.getInstance().active());
}
function setSpan(context2, span) {
  return context2.setValue(SPAN_KEY, span);
}
function deleteSpan(context2) {
  return context2.deleteValue(SPAN_KEY);
}
function setSpanContext(context2, spanContext) {
  return setSpan(context2, new NonRecordingSpan(spanContext));
}
function getSpanContext(context2) {
  var _a;
  return (_a = getSpan(context2)) === null || _a === void 0 ? void 0 : _a.spanContext();
}

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/spancontext-utils.js
var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
function isValidTraceId(traceId) {
  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
}
function isValidSpanId(spanId) {
  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
}
function isSpanContextValid(spanContext) {
  return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
}
function wrapSpanContext(spanContext) {
  return new NonRecordingSpan(spanContext);
}

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracer.js
var contextApi = ContextAPI.getInstance();
var NoopTracer = (
  /** @class */
  (function() {
    function NoopTracer2() {
    }
    NoopTracer2.prototype.startSpan = function(name, options, context2) {
      if (context2 === void 0) {
        context2 = contextApi.active();
      }
      var root = Boolean(options === null || options === void 0 ? void 0 : options.root);
      if (root) {
        return new NonRecordingSpan();
      }
      var parentFromContext = context2 && getSpanContext(context2);
      if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
        return new NonRecordingSpan(parentFromContext);
      } else {
        return new NonRecordingSpan();
      }
    };
    NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
      var opts;
      var ctx;
      var fn;
      if (arguments.length < 2) {
        return;
      } else if (arguments.length === 2) {
        fn = arg2;
      } else if (arguments.length === 3) {
        opts = arg2;
        fn = arg3;
      } else {
        opts = arg2;
        ctx = arg3;
        fn = arg4;
      }
      var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
      var span = this.startSpan(name, opts, parentContext);
      var contextWithSpanSet = setSpan(parentContext, span);
      return contextApi.with(contextWithSpanSet, fn, void 0, span);
    };
    return NoopTracer2;
  })()
);
function isSpanContext(spanContext) {
  return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
}

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracer.js
var NOOP_TRACER = new NoopTracer();
var ProxyTracer = (
  /** @class */
  (function() {
    function ProxyTracer2(_provider, name, version, options) {
      this._provider = _provider;
      this.name = name;
      this.version = version;
      this.options = options;
    }
    ProxyTracer2.prototype.startSpan = function(name, options, context2) {
      return this._getTracer().startSpan(name, options, context2);
    };
    ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
      var tracer = this._getTracer();
      return Reflect.apply(tracer.startActiveSpan, tracer, arguments);
    };
    ProxyTracer2.prototype._getTracer = function() {
      if (this._delegate) {
        return this._delegate;
      }
      var tracer = this._provider.getDelegateTracer(this.name, this.version, this.options);
      if (!tracer) {
        return NOOP_TRACER;
      }
      this._delegate = tracer;
      return this._delegate;
    };
    return ProxyTracer2;
  })()
);

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/NoopTracerProvider.js
var NoopTracerProvider = (
  /** @class */
  (function() {
    function NoopTracerProvider2() {
    }
    NoopTracerProvider2.prototype.getTracer = function(_name, _version, _options) {
      return new NoopTracer();
    };
    return NoopTracerProvider2;
  })()
);

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/ProxyTracerProvider.js
var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
var ProxyTracerProvider = (
  /** @class */
  (function() {
    function ProxyTracerProvider2() {
    }
    ProxyTracerProvider2.prototype.getTracer = function(name, version, options) {
      var _a;
      return (_a = this.getDelegateTracer(name, version, options)) !== null && _a !== void 0 ? _a : new ProxyTracer(this, name, version, options);
    };
    ProxyTracerProvider2.prototype.getDelegate = function() {
      var _a;
      return (_a = this._delegate) !== null && _a !== void 0 ? _a : NOOP_TRACER_PROVIDER;
    };
    ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
      this._delegate = delegate;
    };
    ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options) {
      var _a;
      return (_a = this._delegate) === null || _a === void 0 ? void 0 : _a.getTracer(name, version, options);
    };
    return ProxyTracerProvider2;
  })()
);

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace/status.js
var SpanStatusCode;
(function(SpanStatusCode2) {
  SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
  SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
  SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
})(SpanStatusCode || (SpanStatusCode = {}));

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/context-api.js
var context = ContextAPI.getInstance();

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/api/trace.js
var API_NAME3 = "trace";
var TraceAPI = (
  /** @class */
  (function() {
    function TraceAPI2() {
      this._proxyTracerProvider = new ProxyTracerProvider();
      this.wrapSpanContext = wrapSpanContext;
      this.isSpanContextValid = isSpanContextValid;
      this.deleteSpan = deleteSpan;
      this.getSpan = getSpan;
      this.getActiveSpan = getActiveSpan;
      this.getSpanContext = getSpanContext;
      this.setSpan = setSpan;
      this.setSpanContext = setSpanContext;
    }
    TraceAPI2.getInstance = function() {
      if (!this._instance) {
        this._instance = new TraceAPI2();
      }
      return this._instance;
    };
    TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
      var success = registerGlobal(API_NAME3, this._proxyTracerProvider, DiagAPI.instance());
      if (success) {
        this._proxyTracerProvider.setDelegate(provider);
      }
      return success;
    };
    TraceAPI2.prototype.getTracerProvider = function() {
      return getGlobal(API_NAME3) || this._proxyTracerProvider;
    };
    TraceAPI2.prototype.getTracer = function(name, version) {
      return this.getTracerProvider().getTracer(name, version);
    };
    TraceAPI2.prototype.disable = function() {
      unregisterGlobal(API_NAME3, DiagAPI.instance());
      this._proxyTracerProvider = new ProxyTracerProvider();
    };
    return TraceAPI2;
  })()
);

// ../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/build/esm/trace-api.js
var trace = TraceAPI.getInstance();

// ../../observability/dist/chunk-ZGEMAYS4.mjs
var OtelSpanAttributes;
var init_constants = __esm({
  "src/core/constants.ts"() {
    "use strict";
    OtelSpanAttributes = {
      // OpenInference - re-export all standard conventions
      ...SemanticConventions,
      // AG-Kit Trace attributes (non-standard)
      TRACE_NAME: "trace.name",
      TRACE_TAGS: "trace.tags",
      TRACE_PUBLIC: "trace.public",
      TRACE_METADATA: "trace.metadata",
      TRACE_INPUT: "trace.input",
      TRACE_OUTPUT: "trace.output",
      // AG-Kit Observation attributes (non-standard)
      OBSERVATION_TYPE: "observation.type",
      OBSERVATION_LEVEL: "observation.level",
      OBSERVATION_STATUS_MESSAGE: "observation.status_message",
      OBSERVATION_INPUT: "observation.input",
      OBSERVATION_OUTPUT: "observation.output",
      OBSERVATION_METADATA: "observation.metadata",
      // AG-Kit LLM-specific (non-standard)
      LLM_COMPLETION_START_TIME: "llm.completion_start_time",
      LLM_MODEL_PARAMETERS: "llm.model_parameters",
      LLM_USAGE_DETAILS: "llm.usage_details",
      LLM_COST_DETAILS: "llm.cost_details",
      // AG-Kit Retriever-specific (non-standard)
      RETRIEVER_NAME: "retriever.name",
      RETRIEVER_QUERY: "retriever.query",
      RETRIEVER_INDEX_ID: "retriever.index_id",
      RETRIEVER_TOP_K: "retriever.top_k",
      // AG-Kit General (non-standard)
      ENVIRONMENT: "environment",
      RELEASE: "release",
      VERSION: "version"
    };
  }
});
function createTraceAttributes({
  name,
  userId,
  sessionId,
  version,
  release,
  input,
  output,
  metadata,
  tags,
  environment,
  public: isPublic
} = {}) {
  const attributes = {
    [OtelSpanAttributes.TRACE_NAME]: name,
    // Use OpenInference standard attributes for user and session
    [OtelSpanAttributes.USER_ID]: userId,
    [OtelSpanAttributes.SESSION_ID]: sessionId,
    [OtelSpanAttributes.VERSION]: version,
    [OtelSpanAttributes.RELEASE]: release,
    [OtelSpanAttributes.TRACE_INPUT]: _serialize(input),
    [OtelSpanAttributes.TRACE_OUTPUT]: _serialize(output),
    [OtelSpanAttributes.TRACE_TAGS]: tags,
    [OtelSpanAttributes.ENVIRONMENT]: environment,
    [OtelSpanAttributes.TRACE_PUBLIC]: isPublic,
    ..._flattenAndSerializeMetadata(metadata, OtelSpanAttributes.TRACE_METADATA)
  };
  return Object.fromEntries(
    Object.entries(attributes).filter(([_, v]) => v != null)
  );
}
function createObservationAttributes(type, attributes) {
  const {
    metadata,
    input,
    output,
    level,
    statusMessage,
    version,
    completionStartTime,
    model,
    modelParameters,
    usageDetails
  } = attributes;
  const otelAttributes = {
    [SemanticConventions.OPENINFERENCE_SPAN_KIND]: type.toUpperCase(),
    [OtelSpanAttributes.OBSERVATION_TYPE]: type,
    [OtelSpanAttributes.OBSERVATION_LEVEL]: level,
    [OtelSpanAttributes.OBSERVATION_STATUS_MESSAGE]: statusMessage,
    [OtelSpanAttributes.VERSION]: version,
    // Use OpenInference input.value convention
    [SemanticConventions.INPUT_VALUE]: _serialize(input),
    // Also set legacy agkit.observation.input for compatibility
    [OtelSpanAttributes.OBSERVATION_INPUT]: _serialize(input),
    // Use OpenInference output.value convention
    [SemanticConventions.OUTPUT_VALUE]: _serialize(output),
    // Also set legacy agkit.observation.output for compatibility
    [OtelSpanAttributes.OBSERVATION_OUTPUT]: _serialize(output)
  };
  if (type === "llm") {
    if (model) {
      otelAttributes[SemanticConventions.LLM_MODEL_NAME] = model;
    }
    if (modelParameters) {
      otelAttributes[SemanticConventions.LLM_INVOCATION_PARAMETERS] = _serialize(modelParameters);
      otelAttributes[OtelSpanAttributes.LLM_MODEL_PARAMETERS] = _serialize(modelParameters);
    }
    if (usageDetails) {
      if (typeof usageDetails === "object") {
        const usage = usageDetails;
        if (usage.promptTokens !== void 0) {
          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_PROMPT] = usage.promptTokens;
        }
        if (usage.completionTokens !== void 0) {
          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_COMPLETION] = usage.completionTokens;
        }
        if (usage.totalTokens !== void 0) {
          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_TOTAL] = usage.totalTokens;
        }
      }
      otelAttributes[OtelSpanAttributes.LLM_USAGE_DETAILS] = _serialize(usageDetails);
    }
    if (completionStartTime) {
      otelAttributes[OtelSpanAttributes.LLM_COMPLETION_START_TIME] = _serialize(completionStartTime);
    }
  }
  if (type === "embedding") {
    if (model) {
      otelAttributes[SemanticConventions.EMBEDDING_MODEL_NAME] = model;
    }
    if (modelParameters) {
      otelAttributes[SemanticConventions.LLM_INVOCATION_PARAMETERS] = _serialize(modelParameters);
    }
  }
  const metadataAttrs = _flattenAndSerializeMetadata(
    metadata,
    SemanticConventions.METADATA
  );
  Object.assign(otelAttributes, metadataAttrs);
  const obsetvabilityMetadataAttrs = _flattenAndSerializeMetadata(
    metadata,
    OtelSpanAttributes.OBSERVATION_METADATA
  );
  Object.assign(otelAttributes, obsetvabilityMetadataAttrs);
  return Object.fromEntries(
    Object.entries(otelAttributes).filter(([_, v]) => v != null)
  );
}
function _serialize(obj) {
  try {
    if (typeof obj === "string") return obj;
    if (obj instanceof Date) return obj.toISOString();
    return obj != null ? JSON.stringify(obj) : void 0;
  } catch {
    return "<failed to serialize>";
  }
}
function _flattenAndSerializeMetadata(metadata, prefix) {
  const metadataAttributes = {};
  if (metadata === void 0 || metadata === null) {
    return metadataAttributes;
  }
  if (typeof metadata !== "object" || Array.isArray(metadata)) {
    const serialized = _serialize(metadata);
    if (serialized) {
      metadataAttributes[prefix] = serialized;
    }
  } else {
    for (const [key, value] of Object.entries(metadata)) {
      const serialized = typeof value === "string" ? value : _serialize(value);
      if (serialized) {
        metadataAttributes[`${prefix}.${key}`] = serialized;
      }
    }
  }
  return metadataAttributes;
}
var init_attributes = __esm({
  "src/core/attributes.ts"() {
    "use strict";
    init_constants();
  }
});
function createState() {
  return {
    isolatedTracerProvider: null
  };
}
function getObservabilityGlobalState() {
  const initialState = createState();
  try {
    const g = globalThis;
    if (typeof g !== "object" || g === null) {
      console.warn(
        "[Observability] globalThis is not available, using fallback state"
      );
      return initialState;
    }
    if (!g[OBSERVABILITY_GLOBAL_SYMBOL]) {
      Object.defineProperty(g, OBSERVABILITY_GLOBAL_SYMBOL, {
        value: initialState,
        writable: false,
        configurable: false,
        enumerable: false
      });
    }
    return g[OBSERVABILITY_GLOBAL_SYMBOL];
  } catch (err) {
    console.error(
      `[Observability] Failed to access global state: ${err instanceof Error ? err.message : String(err)}`
    );
    return initialState;
  }
}
function setTracerProvider(provider) {
  getObservabilityGlobalState().isolatedTracerProvider = provider;
}
function getTracerProvider() {
  const { isolatedTracerProvider } = getObservabilityGlobalState();
  if (isolatedTracerProvider) return isolatedTracerProvider;
  return trace.getTracerProvider();
}
function getTracer() {
  return getTracerProvider().getTracer(
    OBSERVABILITY_SDK_NAME,
    OBSERVABILITY_SDK_VERSION
  );
}
var OBSERVABILITY_GLOBAL_SYMBOL;
var OBSERVABILITY_SDK_NAME;
var OBSERVABILITY_SDK_VERSION;
var init_tracerProvider = __esm({
  "src/core/tracerProvider.ts"() {
    "use strict";
    OBSERVABILITY_GLOBAL_SYMBOL = /* @__PURE__ */ Symbol.for("observability");
    OBSERVABILITY_SDK_NAME = "ag-kit-observability";
    OBSERVABILITY_SDK_VERSION = "0.1.0";
  }
});
var BaseObservation;
var ObservationSpan;
var ObservationLLM;
var ObservationEmbedding;
var ObservationAgent;
var ObservationTool;
var ObservationChain;
var ObservationRetriever;
var ObservationReranker;
var ObservationEvaluator;
var ObservationGuardrail;
var init_spanWrapper = __esm({
  "src/core/spanWrapper.ts"() {
    "use strict";
    init_attributes();
    init_tracerProvider();
    BaseObservation = class {
      constructor(params) {
        /** The underlying OpenTelemetry span */
        __publicField(this, "otelSpan");
        /** The observation type */
        __publicField(this, "type");
        /** The span ID from the OpenTelemetry span context */
        __publicField(this, "id");
        /** The trace ID from the OpenTelemetry span context */
        __publicField(this, "traceId");
        this.otelSpan = params.otelSpan;
        this.id = params.otelSpan.spanContext().spanId;
        this.traceId = params.otelSpan.spanContext().traceId;
        this.type = params.type;
        if (params.attributes) {
          this.otelSpan.setAttributes(
            createObservationAttributes(params.type, params.attributes)
          );
        }
      }
      /** Gets the AG-Kit OpenTelemetry tracer instance */
      get tracer() {
        return getTracer();
      }
      /**
       * Ends the observation, marking it as complete.
       *
       * @param endTime - Optional end time, defaults to current time
       */
      end(endTime) {
        this.otelSpan.end(endTime);
      }
      /**
       * Updates the OTEL span attributes.
       *
       * @param attributes - Attributes to update
       * @internal
       */
      updateOtelSpanAttributes(attributes) {
        this.otelSpan.setAttributes(
          createObservationAttributes(this.type, attributes)
        );
      }
      /**
       * Updates the parent trace with new attributes.
       *
       * @param attributes - Trace attributes to set
       * @returns This observation for method chaining
       */
      updateTrace(attributes) {
        this.otelSpan.setAttributes(createTraceAttributes(attributes));
        return this;
      }
      startObservation(name, attributes, options) {
        const { startObservation: startObs } = (init_src(), __toCommonJS(src_exports));
        const { asType = "span" } = options || {};
        return startObs(name, attributes, {
          asType,
          parentSpanContext: this.otelSpan.spanContext()
        });
      }
    };
    ObservationSpan = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "span" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationLLM = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "llm" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationEmbedding = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "embedding" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationAgent = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "agent" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationTool = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "tool" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationChain = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "chain" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationRetriever = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "retriever" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationReranker = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "reranker" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationEvaluator = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "evaluator" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
    ObservationGuardrail = class extends BaseObservation {
      constructor(params) {
        super({ ...params, type: "guardrail" });
      }
      update(attributes) {
        super.updateOtelSpanAttributes(attributes);
        return this;
      }
    };
  }
});
var src_exports = {};
__export(src_exports, {
  ObservationAgent: () => ObservationAgent,
  ObservationChain: () => ObservationChain,
  ObservationEmbedding: () => ObservationEmbedding,
  ObservationEvaluator: () => ObservationEvaluator,
  ObservationGuardrail: () => ObservationGuardrail,
  ObservationLLM: () => ObservationLLM,
  ObservationReranker: () => ObservationReranker,
  ObservationRetriever: () => ObservationRetriever,
  ObservationSpan: () => ObservationSpan,
  ObservationTool: () => ObservationTool,
  createObservationAttributes: () => createObservationAttributes,
  createTraceAttributes: () => createTraceAttributes,
  getActiveSpanId: () => getActiveSpanId,
  getActiveTraceId: () => getActiveTraceId,
  getTracer: () => getTracer,
  getTracerProvider: () => getTracerProvider,
  observe: () => observe,
  setTracerProvider: () => setTracerProvider,
  startActiveObservation: () => startActiveObservation,
  startObservation: () => startObservation,
  updateActiveObservation: () => updateActiveObservation,
  updateActiveTrace: () => updateActiveTrace
});
function createOtelSpan(params) {
  return getTracer().startSpan(
    params.name,
    { startTime: params.startTime },
    createParentContext(params.parentSpanContext)
  );
}
function createParentContext(parentSpanContext) {
  if (!parentSpanContext) return;
  return trace.setSpanContext(context.active(), parentSpanContext);
}
function startObservation(name, attributes, options) {
  const { asType = "span", ...observationOptions } = options || {};
  const otelSpan = createOtelSpan({
    name,
    ...observationOptions
  });
  switch (asType) {
    case "llm":
      return new ObservationLLM({
        otelSpan,
        attributes
      });
    case "embedding":
      return new ObservationEmbedding({
        otelSpan,
        attributes
      });
    case "agent":
      return new ObservationAgent({
        otelSpan,
        attributes
      });
    case "tool":
      return new ObservationTool({
        otelSpan,
        attributes
      });
    case "chain":
      return new ObservationChain({
        otelSpan,
        attributes
      });
    case "retriever":
      return new ObservationRetriever({
        otelSpan,
        attributes
      });
    case "reranker":
      return new ObservationReranker({
        otelSpan,
        attributes
      });
    case "evaluator":
      return new ObservationEvaluator({
        otelSpan,
        attributes
      });
    case "guardrail":
      return new ObservationGuardrail({
        otelSpan,
        attributes
      });
    case "span":
    default:
      return new ObservationSpan({
        otelSpan,
        attributes
      });
  }
}
function updateActiveTrace(attributes) {
  const span = trace.getActiveSpan();
  if (!span) {
    console.warn(
      "[Observability] No active OTEL span in context. Skipping trace update."
    );
    return;
  }
  span.setAttributes(createTraceAttributes(attributes));
}
function getActiveTraceId() {
  return trace.getActiveSpan()?.spanContext().traceId;
}
function getActiveSpanId() {
  return trace.getActiveSpan()?.spanContext().spanId;
}
function wrapPromise(promise, span, endOnExit) {
  return promise.then(
    (value) => {
      if (endOnExit !== false) {
        span.end();
      }
      return value;
    },
    (err) => {
      span.setStatus({
        code: SpanStatusCode.ERROR,
        message: err instanceof Error ? err.message : "Unknown error"
      });
      if (endOnExit !== false) {
        span.end();
      }
      throw err;
    }
  );
}
function startActiveObservation(name, fn, options) {
  const { asType = "span", endOnExit, ...observationOptions } = options || {};
  return getTracer().startActiveSpan(
    name,
    { startTime: observationOptions?.startTime },
    createParentContext(observationOptions?.parentSpanContext) ?? context.active(),
    (span) => {
      try {
        let observation;
        switch (asType) {
          case "llm":
            observation = new ObservationLLM({ otelSpan: span });
            break;
          case "embedding":
            observation = new ObservationEmbedding({ otelSpan: span });
            break;
          case "agent":
            observation = new ObservationAgent({ otelSpan: span });
            break;
          case "tool":
            observation = new ObservationTool({ otelSpan: span });
            break;
          case "chain":
            observation = new ObservationChain({ otelSpan: span });
            break;
          case "retriever":
            observation = new ObservationRetriever({ otelSpan: span });
            break;
          case "reranker":
            observation = new ObservationReranker({ otelSpan: span });
            break;
          case "evaluator":
            observation = new ObservationEvaluator({ otelSpan: span });
            break;
          case "guardrail":
            observation = new ObservationGuardrail({ otelSpan: span });
            break;
          case "span":
          default:
            observation = new ObservationSpan({ otelSpan: span });
        }
        const result = fn(observation);
        if (result instanceof Promise) {
          return wrapPromise(
            result,
            span,
            endOnExit
          );
        } else {
          if (endOnExit !== false) {
            span.end();
          }
          return result;
        }
      } catch (err) {
        span.setStatus({
          code: SpanStatusCode.ERROR,
          message: err instanceof Error ? err.message : "Unknown error"
        });
        if (endOnExit !== false) {
          span.end();
        }
        throw err;
      }
    }
  );
}
function updateActiveObservation(attributes) {
  const span = trace.getActiveSpan();
  if (!span) {
    console.warn(
      "[Observability] No active OTEL span in context. Skipping observation update."
    );
    return;
  }
  span.setAttributes(createObservationAttributes("span", attributes));
}
function _captureArguments(args) {
  if (args.length === 0) return {};
  if (args.length === 1) return { arg: args[0] };
  return { args };
}
function observe(fn, options = {}) {
  const {
    asType = "span",
    captureInput = true,
    captureOutput = true,
    ...observationOptions
  } = options;
  const wrappedFunction = function(...args) {
    const name = fn.name || "anonymous-function";
    const inputData = captureInput ? _captureArguments(args) : void 0;
    const observation = startObservation(
      name,
      inputData ? { input: inputData } : {},
      {
        ...observationOptions,
        asType
      }
    );
    const activeContext = trace.setSpan(context.active(), observation.otelSpan);
    const result = context.with(activeContext, () => fn.apply(this, args));
    if (result instanceof Promise) {
      return result.then(
        (value) => {
          if (captureOutput) {
            observation.update({ output: value });
          }
          observation.end();
          return value;
        },
        (err) => {
          observation.update({
            level: "ERROR",
            statusMessage: err instanceof Error ? err.message : "Unknown error"
          });
          observation.end();
          throw err;
        }
      );
    }
    if (captureOutput) {
      observation.update({ output: result });
    }
    observation.end();
    return result;
  };
  Object.defineProperty(wrappedFunction, "name", { value: fn.name });
  Object.defineProperty(wrappedFunction, "length", { value: fn.length });
  return wrappedFunction;
}
var init_src = __esm({
  "src/index.ts"() {
    init_attributes();
    init_spanWrapper();
    init_tracerProvider();
    init_attributes();
    init_tracerProvider();
  }
});

// ../../observability/dist/langchain.mjs
import { BaseCallbackHandler } from "@langchain/core/callbacks/base";
import {
  AIMessage,
  AIMessageChunk,
  BaseMessage
} from "@langchain/core/messages";
import { noopLogger } from "@cloudbase/agent-shared";
init_src();
var CallbackHandler = class extends BaseCallbackHandler {
  constructor(params) {
    super();
    __publicField(this, "name", "ObservabilityCallbackHandler");
    __publicField(this, "userId");
    __publicField(this, "version");
    __publicField(this, "sessionId");
    __publicField(this, "tags");
    __publicField(this, "traceMetadata");
    __publicField(this, "completionStartTimes", {});
    __publicField(this, "promptToParentRunMap");
    __publicField(this, "runMap", /* @__PURE__ */ new Map());
    __publicField(this, "last_trace_id", null);
    // External parent context from AG-UI.Server span
    __publicField(this, "externalParentSpanContext");
    // Adapter name for ROOT span prefix
    __publicField(this, "adapterName");
    // Logger for debug output (defaults to noopLogger for silent operation)
    __publicField(this, "logger");
    this.sessionId = params?.sessionId;
    this.userId = params?.userId;
    this.tags = params?.tags ?? [];
    this.traceMetadata = params?.traceMetadata;
    this.version = params?.version;
    this.adapterName = params?.adapterName;
    this.logger = params?.logger ?? noopLogger;
    this.promptToParentRunMap = /* @__PURE__ */ new Map();
  }
  /**
   * Set external parent SpanContext from AG-UI.Server span.
   * This allows the CallbackHandler to link LangChain/LangGraph spans
   * to the server-level span, creating a unified trace hierarchy.
   *
   * @param spanContext - SpanContext from the AG-UI.Server span
   * @public
   */
  setExternalParentContext(spanContext) {
    this.externalParentSpanContext = spanContext;
  }
  async handleLLMNewToken(token, _idx, runId, _parentRunId, _tags, _fields) {
    if (runId && !(runId in this.completionStartTimes)) {
      this.logger.debug?.(`LLM first streaming token: ${runId}`);
      this.completionStartTimes[runId] = /* @__PURE__ */ new Date();
    }
  }
  async handleChainStart(chain, inputs, runId, parentRunId, tags, metadata, runType, name) {
    try {
      this.logger.debug?.(`Chain start with Id: ${runId}`);
      const runName = name ?? chain.id.at(-1)?.toString() ?? "Langchain Run";
      this.registerPromptInfo(parentRunId, metadata);
      let finalInput = inputs;
      if (typeof inputs === "object" && "input" in inputs && Array.isArray(inputs["input"]) && inputs["input"].every((m) => m instanceof BaseMessage)) {
        finalInput = inputs["input"].map(
          (m) => this.extractChatMessageContent(m)
        );
      } else if (typeof inputs === "object" && "messages" in inputs && Array.isArray(inputs["messages"]) && inputs["messages"].every((m) => m instanceof BaseMessage)) {
        finalInput = inputs["messages"].map(
          (m) => this.extractChatMessageContent(m)
        );
      } else if (typeof inputs === "object" && "content" in inputs && typeof inputs["content"] === "string") {
        finalInput = inputs["content"];
      }
      const observation = this.startAndRegisterObservation({
        runName,
        parentRunId,
        runId,
        tags,
        metadata,
        attributes: {
          input: finalInput
        },
        asType: "span"
      });
      const traceTags = [.../* @__PURE__ */ new Set([...tags ?? [], ...this.tags])];
      if (!parentRunId) {
        observation.updateTrace({
          tags: traceTags,
          userId: metadata && "userId" in metadata && typeof metadata["userId"] === "string" ? metadata["userId"] : this.userId,
          sessionId: metadata && "sessionId" in metadata && typeof metadata["sessionId"] === "string" ? metadata["sessionId"] : this.sessionId,
          metadata: this.traceMetadata,
          version: this.version
        });
      }
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleAgentAction(action, runId, parentRunId) {
    try {
      this.logger.debug?.(`Agent action ${action.tool} with ID: ${runId}`);
      this.startAndRegisterObservation({
        runId,
        parentRunId,
        runName: action.tool,
        attributes: {
          input: action
        },
        asType: "tool"
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleAgentEnd(action, runId, _parentRunId) {
    try {
      this.logger.debug?.(`Agent finish with ID: ${runId}`);
      this.handleObservationEnd({
        runId,
        attributes: { output: action }
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleChainError(err, runId, _parentRunId) {
    try {
      this.logger.debug?.(`Chain error: ${err} with ID: ${runId}`);
      this.handleObservationEnd({
        runId,
        attributes: {
          level: "ERROR",
          statusMessage: err.toString()
        }
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleGenerationStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
    this.logger.debug?.(
      `Generation start with ID: ${runId} and parentRunId ${parentRunId}`
    );
    const runName = name ?? llm.id.at(-1)?.toString() ?? "Langchain Generation";
    const modelParameters = {};
    const invocationParams = extraParams?.["invocation_params"];
    for (const [key, value] of Object.entries({
      temperature: invocationParams?.temperature,
      max_tokens: invocationParams?.max_tokens,
      top_p: invocationParams?.top_p,
      frequency_penalty: invocationParams?.frequency_penalty,
      presence_penalty: invocationParams?.presence_penalty,
      request_timeout: invocationParams?.request_timeout
    })) {
      if (value !== void 0 && value !== null) {
        modelParameters[key] = value;
      }
    }
    let extractedModelName;
    if (extraParams) {
      const invocationParamsModelName = extraParams.invocation_params.model;
      const metadataModelName = metadata && "ls_model_name" in metadata ? metadata["ls_model_name"] : void 0;
      extractedModelName = invocationParamsModelName ?? metadataModelName;
    }
    const registeredPrompt = this.promptToParentRunMap.get(
      parentRunId ?? "root"
    );
    if (registeredPrompt && parentRunId) {
      this.deregisterPromptInfo(parentRunId);
    }
    this.startAndRegisterObservation({
      runId,
      parentRunId,
      metadata,
      tags,
      runName,
      attributes: {
        input: messages,
        model: extractedModelName,
        modelParameters
      },
      asType: "llm"
    });
  }
  async handleChatModelStart(llm, messages, runId, parentRunId, extraParams, tags, metadata, name) {
    try {
      this.logger.debug?.(`Chat model start with ID: ${runId}`);
      const prompts = messages.flatMap(
        (message) => message.map((m) => this.extractChatMessageContent(m))
      );
      this.handleGenerationStart(
        llm,
        prompts,
        runId,
        parentRunId,
        extraParams,
        tags,
        metadata,
        name
      );
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleChainEnd(outputs, runId, _parentRunId) {
    try {
      this.logger.debug?.(`Chain end with ID: ${runId}`);
      let finalOutput = outputs;
      if (typeof outputs === "object" && "output" in outputs && typeof outputs["output"] === "string") {
        finalOutput = outputs["output"];
      } else if (typeof outputs === "object" && "messages" in outputs && Array.isArray(outputs["messages"]) && outputs["messages"].every((m) => m instanceof BaseMessage)) {
        finalOutput = {
          messages: outputs.messages.map(
            (message) => this.extractChatMessageContent(message)
          )
        };
      }
      this.handleObservationEnd({
        runId,
        attributes: {
          output: finalOutput
        }
      });
      this.deregisterPromptInfo(runId);
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleLLMStart(llm, prompts, runId, parentRunId, extraParams, tags, metadata, name) {
    try {
      this.logger.debug?.(`LLM start with ID: ${runId}`);
      this.handleGenerationStart(
        llm,
        prompts,
        runId,
        parentRunId,
        extraParams,
        tags,
        metadata,
        name
      );
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleToolStart(tool, input, runId, parentRunId, tags, metadata, name) {
    try {
      this.logger.debug?.(`Tool start with ID: ${runId}`);
      this.startAndRegisterObservation({
        runId,
        parentRunId,
        runName: name ?? tool.id.at(-1)?.toString() ?? "Tool execution",
        attributes: {
          input
        },
        metadata,
        tags,
        asType: "tool"
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleRetrieverStart(retriever, query, runId, parentRunId, tags, metadata, name) {
    try {
      this.logger.debug?.(`Retriever start with ID: ${runId}`);
      this.startAndRegisterObservation({
        runId,
        parentRunId,
        runName: name ?? retriever.id.at(-1)?.toString() ?? "Retriever",
        attributes: {
          input: query
        },
        tags,
        metadata,
        asType: "span"
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleRetrieverEnd(documents, runId, _parentRunId) {
    try {
      this.logger.debug?.(`Retriever end with ID: ${runId}`);
      this.handleObservationEnd({
        runId,
        attributes: {
          output: documents
        }
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleRetrieverError(err, runId, _parentRunId) {
    try {
      this.logger.debug?.(`Retriever error: ${err} with ID: ${runId}`);
      this.handleObservationEnd({
        runId,
        attributes: {
          level: "ERROR",
          statusMessage: err.toString()
        }
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleToolEnd(output, runId, _parentRunId) {
    try {
      this.logger.debug?.(`Tool end with ID: ${runId}`);
      this.handleObservationEnd({
        runId,
        attributes: { output }
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleToolError(err, runId, _parentRunId) {
    try {
      this.logger.debug?.(`Tool error ${err} with ID: ${runId}`);
      this.handleObservationEnd({
        runId,
        attributes: {
          level: "ERROR",
          statusMessage: err.toString()
        }
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleLLMEnd(output, runId, _parentRunId) {
    try {
      this.logger.debug?.(`LLM end with ID: ${runId}`);
      const lastResponse = output.generations[output.generations.length - 1][output.generations[output.generations.length - 1].length - 1];
      const llmUsage = this.extractUsageMetadata(lastResponse) ?? output.llmOutput?.["tokenUsage"];
      const modelName = this.extractModelNameFromMetadata(lastResponse);
      const usageDetails = {
        input: llmUsage?.input_tokens ?? ("promptTokens" in llmUsage ? llmUsage?.promptTokens : void 0),
        output: llmUsage?.output_tokens ?? ("completionTokens" in llmUsage ? llmUsage?.completionTokens : void 0),
        total: llmUsage?.total_tokens ?? ("totalTokens" in llmUsage ? llmUsage?.totalTokens : void 0)
      };
      if (llmUsage && "input_token_details" in llmUsage) {
        for (const [key, val] of Object.entries(
          llmUsage["input_token_details"] ?? {}
        )) {
          usageDetails[`input_${key}`] = val;
          if ("input" in usageDetails && typeof val === "number") {
            usageDetails["input"] = Math.max(0, usageDetails["input"] - val);
          }
        }
      }
      if (llmUsage && "output_token_details" in llmUsage) {
        for (const [key, val] of Object.entries(
          llmUsage["output_token_details"] ?? {}
        )) {
          usageDetails[`output_${key}`] = val;
          if ("output" in usageDetails && typeof val === "number") {
            usageDetails["output"] = Math.max(0, usageDetails["output"] - val);
          }
        }
      }
      const extractedOutput = "message" in lastResponse ? this.extractChatMessageContent(
        lastResponse["message"]
      ) : lastResponse.text;
      this.handleObservationEnd({
        runId,
        attributes: {
          model: modelName,
          output: extractedOutput,
          completionStartTime: runId in this.completionStartTimes ? this.completionStartTimes[runId] : void 0,
          usageDetails
        }
      });
      if (runId in this.completionStartTimes) {
        delete this.completionStartTimes[runId];
      }
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  async handleLLMError(err, runId, _parentRunId) {
    try {
      this.logger.debug?.(`LLM error ${err} with ID: ${runId}`);
      this.handleObservationEnd({
        runId,
        attributes: {
          level: "ERROR",
          statusMessage: err.toString()
        }
      });
    } catch (e) {
      this.logger.debug?.(e instanceof Error ? e.message : String(e));
    }
  }
  registerPromptInfo(parentRunId, metadata) {
    if (metadata && "promptInfo" in metadata && parentRunId) {
      this.promptToParentRunMap.set(
        parentRunId,
        metadata.promptInfo
      );
    }
  }
  deregisterPromptInfo(runId) {
    this.promptToParentRunMap.delete(runId);
  }
  startAndRegisterObservation(params) {
    const { runName, runId, parentRunId, attributes, metadata, tags, asType } = params;
    let parentSpanContext;
    if (parentRunId) {
      parentSpanContext = this.runMap.get(parentRunId)?.otelSpan.spanContext();
    } else if (this.externalParentSpanContext) {
      parentSpanContext = this.externalParentSpanContext;
    }
    let finalRunName = runName;
    if (!parentRunId && this.adapterName) {
      finalRunName = `Adapter.${this.adapterName}`;
    }
    const observation = startObservation(
      finalRunName,
      {
        version: this.version,
        metadata: this.joinTagsAndMetaData(tags, metadata),
        ...attributes
      },
      {
        asType: asType ?? "span",
        parentSpanContext
      }
    );
    this.runMap.set(runId, observation);
    return observation;
  }
  handleObservationEnd(params) {
    const { runId, attributes = {} } = params;
    const observation = this.runMap.get(runId);
    if (!observation) {
      this.logger.warn?.("Observation not found in runMap. Skipping operation.");
      return;
    }
    observation.update(attributes).end();
    this.last_trace_id = observation.traceId;
    this.runMap.delete(runId);
  }
  joinTagsAndMetaData(tags, metadata1, metadata2) {
    const finalDict = {};
    if (tags && tags.length > 0) {
      finalDict.tags = tags;
    }
    if (metadata1) {
      Object.assign(finalDict, metadata1);
    }
    if (metadata2) {
      Object.assign(finalDict, metadata2);
    }
    return this.stripObservabilityKeysFromMetadata(finalDict);
  }
  stripObservabilityKeysFromMetadata(metadata) {
    if (!metadata) {
      return;
    }
    const reservedKeys = ["promptInfo", "userId", "sessionId"];
    return Object.fromEntries(
      Object.entries(metadata).filter(([key, _]) => !reservedKeys.includes(key))
    );
  }
  extractUsageMetadata(generation) {
    try {
      const usageMetadata = "message" in generation && (AIMessage.isInstance(generation["message"]) || AIMessageChunk.isInstance(generation["message"])) ? generation["message"].usage_metadata : void 0;
      return usageMetadata;
    } catch (err) {
      this.logger.debug?.(`Error extracting usage metadata: ${err}`);
      return;
    }
  }
  extractModelNameFromMetadata(generation) {
    try {
      return "message" in generation && (AIMessage.isInstance(generation["message"]) || AIMessageChunk.isInstance(generation["message"])) ? generation["message"].response_metadata.model_name : void 0;
    } catch {
    }
  }
  extractChatMessageContent(message) {
    let response = void 0;
    if (message.getType() === "human") {
      response = { content: message.content, role: "user" };
    } else if (message.getType() === "generic") {
      response = {
        content: message.content,
        role: "human"
      };
    } else if (message.getType() === "ai") {
      response = { content: message.content, role: "assistant" };
      if ("tool_calls" in message && Array.isArray(message.tool_calls) && (message.tool_calls?.length ?? 0) > 0) {
        response["tool_calls"] = message["tool_calls"];
      }
      if ("additional_kwargs" in message && "tool_calls" in message["additional_kwargs"]) {
        response["tool_calls"] = message["additional_kwargs"]["tool_calls"];
      }
    } else if (message.getType() === "system") {
      response = { content: message.content, role: "system" };
    } else if (message.getType() === "function") {
      response = {
        content: message.content,
        additional_kwargs: message.additional_kwargs,
        role: message.name
      };
    } else if (message.getType() === "tool") {
      response = {
        content: message.content,
        additional_kwargs: message.additional_kwargs,
        role: message.name
      };
    } else if (!message.name) {
      response = { content: message.content };
    } else {
      response = {
        role: message.name,
        content: message.content
      };
    }
    if ((message.additional_kwargs.function_call || message.additional_kwargs.tool_calls) && response["tool_calls"] === void 0) {
      return { ...response, additional_kwargs: message.additional_kwargs };
    }
    return response;
  }
};
export {
  CallbackHandler
};
//# sourceMappingURL=langchain-6EY35CAB.mjs.map