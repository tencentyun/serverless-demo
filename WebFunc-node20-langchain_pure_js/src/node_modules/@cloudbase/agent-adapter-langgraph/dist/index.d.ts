import * as _langchain_core_messages from '@langchain/core/messages';
import * as _langchain_langgraph from '@langchain/langgraph';
import { AnnotationRoot, StateDefinition, StateGraph, BaseCheckpointSaver, CheckpointTuple, Checkpoint, CheckpointMetadata, BaseStore, Item, Operation, OperationResults } from '@langchain/langgraph';
import { AbstractAgent, AgentConfig, RunAgentInput, EventType, BaseEvent } from '@ag-ui/client';
import { Observable, Subscriber } from 'rxjs';
import { InteropZodObject } from '@langchain/core/utils/types';
import { Logger } from '@cloudbase/agent-shared';
export { Logger, createConsoleLogger, noopLogger } from '@cloudbase/agent-shared';
import { RunnableConfig } from '@langchain/core/runnables';
import { IMemoryClientOptions, MemoryClient } from '@cloudbase/agent-agents';

type SDZod = StateDefinition | InteropZodObject;
type CompiledStateGraph<SD extends SDZod> = ReturnType<StateGraph<SD>["compile"]>;
type AnnotationInside<T> = T extends AnnotationRoot<infer U> ? U : never;
type ClientStateDefinition = AnnotationInside<typeof ClientStateAnnotation>;
declare const ClientPropertiesAnnotation: AnnotationRoot<{
    tools: {
        (): _langchain_langgraph.LastValue<any[]>;
        (annotation: _langchain_langgraph.SingleReducer<any[], any[]>): _langchain_langgraph.BinaryOperatorAggregate<any[], any[]>;
        Root: <S extends StateDefinition>(sd: S) => AnnotationRoot<S>;
    };
}>;
declare const ClientStateAnnotation: AnnotationRoot<{
    messages: _langchain_langgraph.BinaryOperatorAggregate<_langchain_core_messages.BaseMessage<_langchain_core_messages.MessageStructure<_langchain_core_messages.MessageToolSet>, _langchain_core_messages.MessageType>[], _langchain_langgraph.Messages>;
    client: {
        (): _langchain_langgraph.LastValue<_langchain_langgraph.StateType<{
            tools: {
                (): _langchain_langgraph.LastValue<any[]>;
                (annotation: _langchain_langgraph.SingleReducer<any[], any[]>): _langchain_langgraph.BinaryOperatorAggregate<any[], any[]>;
                Root: <S extends StateDefinition>(sd: S) => AnnotationRoot<S>;
            };
        }>>;
        (annotation: _langchain_langgraph.SingleReducer<_langchain_langgraph.StateType<{
            tools: {
                (): _langchain_langgraph.LastValue<any[]>;
                (annotation: _langchain_langgraph.SingleReducer<any[], any[]>): _langchain_langgraph.BinaryOperatorAggregate<any[], any[]>;
                Root: <S extends StateDefinition>(sd: S) => AnnotationRoot<S>;
            };
        }>, _langchain_langgraph.StateType<{
            tools: {
                (): _langchain_langgraph.LastValue<any[]>;
                (annotation: _langchain_langgraph.SingleReducer<any[], any[]>): _langchain_langgraph.BinaryOperatorAggregate<any[], any[]>;
                Root: <S extends StateDefinition>(sd: S) => AnnotationRoot<S>;
            };
        }>>): _langchain_langgraph.BinaryOperatorAggregate<_langchain_langgraph.StateType<{
            tools: {
                (): _langchain_langgraph.LastValue<any[]>;
                (annotation: _langchain_langgraph.SingleReducer<any[], any[]>): _langchain_langgraph.BinaryOperatorAggregate<any[], any[]>;
                Root: <S extends StateDefinition>(sd: S) => AnnotationRoot<S>;
            };
        }>, _langchain_langgraph.StateType<{
            tools: {
                (): _langchain_langgraph.LastValue<any[]>;
                (annotation: _langchain_langgraph.SingleReducer<any[], any[]>): _langchain_langgraph.BinaryOperatorAggregate<any[], any[]>;
                Root: <S extends StateDefinition>(sd: S) => AnnotationRoot<S>;
            };
        }>>;
        Root: <S extends StateDefinition>(sd: S) => AnnotationRoot<S>;
    };
}>;
type ClientState = typeof ClientStateAnnotation.State;
declare class LanggraphAgent extends AbstractAgent {
    compiledWorkflow?: CompiledStateGraph<ClientStateDefinition>;
    private observabilityCallback?;
    private adapterName;
    private logger;
    constructor(agentConfig: AgentConfig & {
        compiledWorkflow: any;
        adapterName?: string;
        /**
         * Logger instance for structured logging.
         * @default noopLogger (silent)
         */
        logger?: Logger;
    });
    run(input: RunAgentInput): Observable<{
        type: EventType;
        timestamp?: number | undefined;
        rawEvent?: any;
    }>;
    _run(subscriber: Subscriber<BaseEvent>, input: RunAgentInput): Promise<void>;
    clone(): LanggraphAgent;
}

type PendingWrite = [string, any];
interface CheckpointListOptions {
    limit?: number;
    before?: RunnableConfig;
    filter?: Record<string, any>;
}
interface TDAISaverConfig extends IMemoryClientOptions {
    checkpointType?: string;
    checkpointWritesType?: string;
}
/**
 * TDAISaver - LangGraph checkpoint saver implementation using TDAI Memory
 *
 * Storage Strategy:
 * - Events (NoSQL): Store checkpoint data and pending writes in separate collections
 * - Supports namespaces and parent checkpoint relationships
 */
declare class TDAISaver extends BaseCheckpointSaver {
    private memoryClient;
    private checkpointType;
    private checkpointWritesType;
    constructor(config: TDAISaverConfig);
    /**
     * Retrieves a checkpoint from TDAI Memory based on the provided config.
     * If the config contains a "checkpoint_id" key, the checkpoint with the matching
     * thread ID and checkpoint ID is retrieved. Otherwise, the latest checkpoint
     * for the given thread ID is retrieved.
     */
    getTuple(config: RunnableConfig): Promise<CheckpointTuple | undefined>;
    /**
     * Retrieve a list of checkpoint tuples from TDAI Memory based on the provided config.
     * The checkpoints are ordered by checkpoint ID in descending order (newest first).
     */
    list(config: RunnableConfig, options?: CheckpointListOptions): AsyncGenerator<CheckpointTuple>;
    /**
     * Saves a checkpoint to TDAI Memory. The checkpoint is associated with the
     * provided config and its parent config (if any).
     */
    put(config: RunnableConfig, checkpoint: Checkpoint, metadata: CheckpointMetadata): Promise<RunnableConfig>;
    /**
     * Saves intermediate writes associated with a checkpoint to TDAI Memory.
     */
    putWrites(config: RunnableConfig, writes: PendingWrite[], taskId: string): Promise<void>;
    /**
     * Delete all checkpoints and writes for a thread from TDAI Memory.
     */
    deleteThread(threadId: string): Promise<void>;
    /**
     * Close the memory client connection
     */
    close(): void;
}

/**
 * TDAI Store configuration
 */
interface TDAIStoreConfig {
    /**
     * TDAI Memory Client instance for long-term storage
     */
    memoryClient: MemoryClient;
    /**
     * Session ID for storing records
     */
    sessionId: string;
    /**
     * Optional namespace prefix for all operations
     */
    namespacePrefix?: string[];
    /**
     * TTL configuration for records
     */
    ttl?: {
        defaultTtlSeconds?: number;
        sweepIntervalMinutes?: number;
    };
    /**
     * Whether to ensure tables/collections exist on startup
     */
    ensureTables?: boolean;
    /**
     * Default strategy for storing records
     */
    defaultStrategy?: string;
}
/**
 * Filter operators for advanced filtering
 */
interface FilterOperators {
    $eq?: unknown;
    $ne?: unknown;
    $gt?: number | Date;
    $gte?: number | Date;
    $lt?: number | Date;
    $lte?: number | Date;
    $in?: unknown[];
    $nin?: unknown[];
    $exists?: boolean;
    $regex?: string;
}
/**
 * TDAI implementation of the BaseStore interface.
 * Uses TDAI Memory Client for long-term record storage.
 */
declare class TDAIStore extends BaseStore {
    private client;
    private namespacePrefix;
    private ttlConfig?;
    private ensureTables;
    private isSetup;
    private isClosed;
    private sweepInterval?;
    private sessionId;
    private defaultStrategy;
    constructor(config: TDAIStoreConfig);
    /**
     * Create a storage key from namespace and key
     */
    private createStorageKey;
    /**
     * Parse a storage key back to namespace and key
     */
    private parseStorageKey;
    /**
     * Put an item with optional TTL.
     */
    put(namespace: string[], key: string, value: Record<string, unknown>, index?: false | string[], options?: {
        ttl?: number;
    }): Promise<void>;
    /**
     * Get an item by namespace and key.
     */
    get(namespace: string[], key: string): Promise<Item | null>;
    /**
     * Delete an item by namespace and key.
     */
    delete(namespace: string[], key: string): Promise<void>;
    /**
     * List namespaces with optional filtering.
     */
    listNamespaces(options?: {
        prefix?: string[];
        suffix?: string[];
        maxDepth?: number;
        limit?: number;
        offset?: number;
    }): Promise<string[][]>;
    /**
     * Execute multiple operations in a single batch.
     */
    batch<Op extends Operation[]>(operations: Op): Promise<OperationResults<Op>>;
    /**
     * Execute search operation
     */
    private executeSearch;
    /**
     * Execute list namespaces operation
     */
    private executeListNamespaces;
    /**
     * Initialize the store.
     */
    setup(): Promise<void>;
    /**
     * Start the store.
     */
    start(): Promise<void>;
    /**
     * Stop the store and close all connections.
     */
    stop(): Promise<void>;
    /**
     * Manually sweep expired items from the store.
     */
    sweepExpiredItems(): Promise<number>;
    /**
     * Get statistics about the store.
     */
    getStats(): Promise<{
        totalItems: number;
        expiredItems: number;
        namespaceCount: number;
        oldestItem: Date | null;
        newestItem: Date | null;
    }>;
    /**
     * Search for items in the store with support for text search and filtering.
     */
    search(namespacePrefix: string[], options?: {
        /**
         * Filter conditions with support for advanced operators.
         */
        filter?: Record<string, string | number | boolean | null | FilterOperators>;
        /**
         * Natural language search query.
         */
        query?: string;
        /**
         * Maximum number of results to return.
         * @default 10
         */
        limit?: number;
        /**
         * Number of results to skip for pagination.
         * @default 0
         */
        offset?: number;
        /**
         * Whether to refresh TTL for returned items.
         */
        refreshTtl?: boolean;
    }): Promise<Item[]>;
}

export { ClientPropertiesAnnotation, type ClientState, ClientStateAnnotation, LanggraphAgent, TDAISaver, type TDAISaverConfig, TDAIStore, type TDAIStoreConfig };
