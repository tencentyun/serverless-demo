{"version":3,"file":"encoder_backed.d.cts","names":["Document","BaseStore","EncoderBackedStore","K","V","SerializedType","Promise","AsyncGenerator","createDocumentStoreFromByteStore","Uint8Array","Record","ArrayBufferLike"],"sources":["../../src/storage/encoder_backed.d.ts"],"sourcesContent":["import { Document } from \"@langchain/core/documents\";\nimport { BaseStore } from \"@langchain/core/stores\";\n/**\n * Class that provides a layer of abstraction over the base storage,\n * allowing for the encoding and decoding of keys and values. It extends\n * the BaseStore class.\n */\nexport declare class EncoderBackedStore<K, V, SerializedType = any> extends BaseStore<K, V> {\n    lc_namespace: string[];\n    store: BaseStore<string, SerializedType>;\n    keyEncoder: (key: K) => string;\n    valueSerializer: (value: V) => SerializedType;\n    valueDeserializer: (value: SerializedType) => V;\n    constructor(fields: {\n        store: BaseStore<string, SerializedType>;\n        keyEncoder: (key: K) => string;\n        valueSerializer: (value: V) => SerializedType;\n        valueDeserializer: (value: SerializedType) => V;\n    });\n    /**\n     * Method to get multiple keys at once. It works with the encoded keys and\n     * serialized values.\n     * @param keys Array of keys to get\n     * @returns Promise that resolves with an array of values or undefined for each key\n     */\n    mget(keys: K[]): Promise<(V | undefined)[]>;\n    /**\n     * Method to set multiple keys at once. It works with the encoded keys and\n     * serialized values.\n     * @param keyValuePairs Array of key-value pairs to set\n     * @returns Promise that resolves when the operation is complete\n     */\n    mset(keyValuePairs: [K, V][]): Promise<void>;\n    /**\n     * Method to delete multiple keys at once. It works with the encoded keys.\n     * @param keys Array of keys to delete\n     * @returns Promise that resolves when the operation is complete\n     */\n    mdelete(keys: K[]): Promise<void>;\n    /**\n     * Method to yield keys. It works with the encoded keys.\n     * @param prefix Optional prefix to filter keys\n     * @returns AsyncGenerator that yields keys\n     */\n    yieldKeys(prefix?: string | undefined): AsyncGenerator<string | K>;\n}\nexport declare function createDocumentStoreFromByteStore(store: BaseStore<string, Uint8Array>): EncoderBackedStore<string, Document<Record<string, any>>, Uint8Array<ArrayBufferLike>>;\n//# sourceMappingURL=encoder_backed.d.ts.map"],"mappings":";;;;;;;AAOA;;;AAE6BK,cAFRH,kBAEQG,CAAAA,CAAAA,EAAAA,CAAAA,EAAAA,iBAAAA,GAAAA,CAAAA,SAF+CJ,SAE/CI,CAFyDF,CAEzDE,EAF4DD,CAE5DC,CAAAA,CAAAA;EAAlBJ,YAAAA,EAAAA,MAAAA,EAAAA;EACWE,KAAAA,EADXF,SACWE,CAAAA,MAAAA,EADOE,cACPF,CAAAA;EACOC,UAAAA,EAAAA,CAAAA,GAAAA,EADPD,CACOC,EAAAA,GAAAA,MAAAA;EAAMC,eAAAA,EAAAA,CAAAA,KAAAA,EAAND,CAAMC,EAAAA,GAAAA,cAAAA;EACJA,iBAAAA,EAAAA,CAAAA,KAAAA,EAAAA,cAAAA,EAAAA,GAAmBD,CAAnBC;EAAmBD,WAAAA,CAAAA,MAAAA,EAAAA;IAEjBC,KAAAA,EAAlBJ,SAAkBI,CAAAA,MAAAA,EAAAA,cAAAA,CAAAA;IAAlBJ,UAAAA,EAAAA,CAAAA,GAAAA,EACWE,CADXF,EAAAA,GAAAA,MAAAA;IACWE,eAAAA,EAAAA,CAAAA,KAAAA,EACOC,CADPD,EAAAA,GACaE,cADbF;IACOC,iBAAAA,EAAAA,CAAAA,KAAAA,EACEC,cADFD,EAAAA,GACqBA,CADrBA;EAAMC,CAAAA;EACJA;;;;;;EAePD,IAAAA,CAAAA,IAAAA,EAPbD,CAOaC,EAAAA,CAAAA,EAPPE,OAOOF,CAAAA,CAPEA,CAOFA,GAAAA,SAAAA,CAAAA,EAAAA,CAAAA;EAAOE;;;;;;EAzBkD,IAAA,CAAA,aAAA,EAAA,CAyB5DH,CAzB4D,EAyBzDC,CAzByD,CAAA,EAAA,CAAA,EAyBlDE,OAzBkD,CAAA,IAAA,CAAA;EAuC7DE;;;;;EAA6IG,OAAAA,CAAAA,IAAAA,EARnJR,CAQmJQ,EAAAA,CAAAA,EAR7IL,OAQ6IK,CAAAA,IAAAA,CAAAA;EAAXF;;AAAxC;;;0CAFtEF,wBAAwBJ;;iBAE5CK,gCAAAA,QAAwCP,kBAAkBQ,cAAcP,2BAA2BF,SAASU,sBAAsBD,WAAWE"}