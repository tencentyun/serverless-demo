"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.multiEdit = multiEdit;
exports.createMultiEditTool = createMultiEditTool;
const zod_1 = require("zod");
const utils_1 = require("../utils");
const edit_tool_1 = require("./edit-tool");
/**
 * Group edits by file path
 */
function groupEditsByFile(edits) {
    const grouped = new Map();
    for (const edit of edits) {
        const existing = grouped.get(edit.file_path) || [];
        existing.push(edit);
        grouped.set(edit.file_path, existing);
    }
    return grouped;
}
/**
 * Process edits for a single file sequentially
 */
async function processFileEdits(context, filePath, edits) {
    const results = [];
    let successfulEdits = 0;
    let failedEdits = 0;
    // Process edits sequentially for this file
    for (const edit of edits) {
        try {
            const result = await (0, edit_tool_1.editFile)(context, {
                file_path: edit.file_path,
                old_string: edit.old_string,
                new_string: edit.new_string,
                expected_replacements: edit.expected_replacements,
            });
            const editResult = {
                success: result.success,
                data: result.success ? result.data : undefined,
                error: result.success
                    ? undefined
                    : result.error || "Unknown error",
            };
            results.push(editResult);
            if (result.success) {
                successfulEdits++;
            }
            else {
                failedEdits++;
            }
        }
        catch (error) {
            results.push({
                success: false,
                error: error instanceof Error ? error.message : String(error),
                old_string: edit.old_string,
                new_string: edit.new_string,
            });
            failedEdits++;
        }
    }
    return {
        file_path: filePath,
        edits: results,
        totalEdits: edits.length,
        successfulEdits,
        failedEdits,
    };
}
/**
 * Edit multiple files with multiple edits each
 */
async function multiEdit(context, params) {
    const { edits } = params;
    const startTime = Date.now();
    try {
        // Group edits by file path
        const groupedEdits = groupEditsByFile(edits);
        const totalFiles = groupedEdits.size;
        context.messageHandler?.currentText.append(`\n[multi-edit] Processing ${edits.length} edits across ${totalFiles} files...`);
        // Process each file's edits concurrently (but edits within a file are sequential)
        const filePromises = Array.from(groupedEdits.entries()).map(([filePath, fileEdits]) => processFileEdits(context, filePath, fileEdits));
        const fileResults = await Promise.all(filePromises);
        // Calculate totals
        const totalEdits = edits.length;
        const successfulEdits = fileResults.reduce((sum, file) => sum + file.successfulEdits, 0);
        const failedEdits = fileResults.reduce((sum, file) => sum + file.failedEdits, 0);
        const duration = Date.now() - startTime;
        const summary = `Successfully applied ${successfulEdits} edit(s), failed ${failedEdits} edit(s) out of ${totalEdits} total across ${totalFiles} file(s) in ${duration}ms`;
        context.messageHandler?.currentText.append(`\n[multi-edit] Completed: ${summary}\n`);
        const multipleFilesResult = {
            files: fileResults,
            totalFiles,
            totalEdits,
            successfulEdits,
            failedEdits,
            summary,
        };
        return new utils_1.ToolResult({
            success: true,
            data: multipleFilesResult,
        });
    }
    catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        context.messageHandler?.currentText.append(`\n[multi-edit] Failed: ${errorMessage}\n`);
        return (0, utils_1.handleToolError)(error, "Multi-edit tool execution", "execution");
    }
}
/**
 * Create multi-edit tool with execution context
 */
function createMultiEditTool(context) {
    return (0, utils_1.tool)((params) => multiEdit(context, params), {
        name: "MultiEdit",
        description: `Edits multiple files with multiple edits each. Edits are grouped by file path - edits within the same file are processed sequentially to maintain consistency, while different files are processed concurrently for better performance.
**Usage:**
  - Provide an array of edit requests
  - Each request contains file_path, old_string, new_string, and optional expected_replacements
  - Returns detailed results for each edit including success/failure status
  - Advice: Only include edits in old_string that are necessary and avoid redundant changes`,
        schema: zod_1.z.object({
            edits: zod_1.z
                .array(edit_tool_1.editParametersSchema)
                .describe("Array of edit requests to process"),
        }),
        getDisplay: ({ name, input }) => {
            const totalFiles = new Set(input.edits.map((e) => e.file_path)).size;
            return `> Using ${name} for ${input.edits.length} edits across ${totalFiles} files`;
        },
    });
}
//# sourceMappingURL=multi-edit-tool.js.map