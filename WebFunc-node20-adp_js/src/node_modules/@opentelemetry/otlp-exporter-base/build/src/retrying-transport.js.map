{"version":3,"file":"retrying-transport.js","sourceRoot":"","sources":["../../src/retrying-transport.ts"],"names":[],"mappings":"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","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IExporterTransport } from './exporter-transport';\nimport { ExportResponse } from './export-response';\nimport { diag } from '@opentelemetry/api';\n\nconst MAX_ATTEMPTS = 5;\nconst INITIAL_BACKOFF = 1000;\nconst MAX_BACKOFF = 5000;\nconst BACKOFF_MULTIPLIER = 1.5;\nconst JITTER = 0.2;\n\n/**\n * Get a pseudo-random jitter that falls in the range of [-JITTER, +JITTER]\n */\nfunction getJitter() {\n  return Math.random() * (2 * JITTER) - JITTER;\n}\n\nclass RetryingTransport implements IExporterTransport {\n  private _transport: IExporterTransport;\n\n  constructor(transport: IExporterTransport) {\n    this._transport = transport;\n  }\n\n  private retry(\n    data: Uint8Array,\n    timeoutMillis: number,\n    inMillis: number\n  ): Promise<ExportResponse> {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        this._transport.send(data, timeoutMillis).then(resolve, reject);\n      }, inMillis);\n    });\n  }\n\n  async send(data: Uint8Array, timeoutMillis: number): Promise<ExportResponse> {\n    let attempts = MAX_ATTEMPTS;\n    let nextBackoff = INITIAL_BACKOFF;\n\n    const deadline = Date.now() + timeoutMillis;\n    let result = await this._transport.send(data, timeoutMillis);\n\n    while (result.status === 'retryable' && attempts > 0) {\n      attempts--;\n\n      // use maximum of computed backoff and 0 to avoid negative timeouts\n      const backoff = Math.max(\n        Math.min(nextBackoff * (1 + getJitter()), MAX_BACKOFF),\n        0\n      );\n      nextBackoff = nextBackoff * BACKOFF_MULTIPLIER;\n      const retryInMillis = result.retryInMillis ?? backoff;\n\n      // return when expected retry time is after the export deadline.\n      const remainingTimeoutMillis = deadline - Date.now();\n      if (retryInMillis > remainingTimeoutMillis) {\n        diag.info(\n          `Export retry time ${Math.round(retryInMillis)}ms exceeds remaining timeout ${Math.round(\n            remainingTimeoutMillis\n          )}ms, not retrying further.`\n        );\n        return result;\n      }\n\n      diag.verbose(`Scheduling export retry in ${Math.round(retryInMillis)}ms`);\n      result = await this.retry(data, remainingTimeoutMillis, retryInMillis);\n    }\n\n    if (result.status === 'success') {\n      diag.verbose(\n        `Export succeded after ${MAX_ATTEMPTS - attempts} retry attempts.`\n      );\n    } else if (result.status === 'retryable') {\n      diag.info(\n        `Export failed after maximum retry attempts (${MAX_ATTEMPTS}).`\n      );\n    } else {\n      diag.info(`Export failed with non-retryable error: ${result.error}`);\n    }\n\n    return result;\n  }\n\n  shutdown() {\n    return this._transport.shutdown();\n  }\n}\n\n/**\n * Creates an Exporter Transport that retries on 'retryable' response.\n */\nexport function createRetryingTransport(options: {\n  // Underlying transport to wrap.\n  transport: IExporterTransport;\n}): IExporterTransport {\n  return new RetryingTransport(options.transport);\n}\n"]}