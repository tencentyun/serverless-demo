{"version":3,"file":"index.cjs","names":["count: number | null","res","this","fetch","fetch","method: 'HEAD' | 'GET' | 'POST'","body: unknown | undefined"],"sources":["../src/PostgrestError.ts","../src/PostgrestBuilder.ts","../src/PostgrestTransformBuilder.ts","../src/PostgrestFilterBuilder.ts","../src/PostgrestQueryBuilder.ts","../src/PostgrestClient.ts","../src/index.ts"],"sourcesContent":["/**\n * Error format\n *\n * {@link https://postgrest.org/en/stable/api.html?highlight=options#errors-and-http-status-codes}\n */\nexport default class PostgrestError extends Error {\n  details: string\n  hint: string\n  code: string\n\n  /**\n   * @example\n   * ```ts\n   * import PostgrestError from '@supabase/postgrest-js'\n   *\n   * throw new PostgrestError({\n   *   message: 'Row level security prevented the request',\n   *   details: 'RLS denied the insert',\n   *   hint: 'Check your policies',\n   *   code: 'PGRST301',\n   * })\n   * ```\n   */\n  constructor(context: { message: string; details: string; hint: string; code: string }) {\n    super(context.message)\n    this.name = 'PostgrestError'\n    this.details = context.details\n    this.hint = context.hint\n    this.code = context.code\n  }\n}\n","import type {\n  PostgrestSingleResponse,\n  PostgrestResponseSuccess,\n  CheckMatchingArrayTypes,\n  MergePartialResult,\n  IsValidResultOverride,\n} from './types/types'\nimport { ClientServerOptions, Fetch } from './types/common/common'\nimport PostgrestError from './PostgrestError'\nimport { ContainsNull } from './select-query-parser/types'\n\nexport default abstract class PostgrestBuilder<\n  ClientOptions extends ClientServerOptions,\n  Result,\n  ThrowOnError extends boolean = false,\n> implements\n    PromiseLike<\n      ThrowOnError extends true ? PostgrestResponseSuccess<Result> : PostgrestSingleResponse<Result>\n    >\n{\n  protected method: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n  protected url: URL\n  protected headers: Headers\n  protected schema?: string\n  protected body?: unknown\n  protected shouldThrowOnError = false\n  protected signal?: AbortSignal\n  protected fetch: Fetch\n  protected isMaybeSingle: boolean\n  protected urlLengthLimit: number\n\n  /**\n   * Creates a builder configured for a specific PostgREST request.\n   *\n   * @example\n   * ```ts\n   * import PostgrestQueryBuilder from '@supabase/postgrest-js'\n   *\n   * const builder = new PostgrestQueryBuilder(\n   *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n   *   { headers: new Headers({ apikey: 'public-anon-key' }) }\n   * )\n   * ```\n   */\n  constructor(builder: {\n    method: 'GET' | 'HEAD' | 'POST' | 'PATCH' | 'DELETE'\n    url: URL\n    headers: HeadersInit\n    schema?: string\n    body?: unknown\n    shouldThrowOnError?: boolean\n    signal?: AbortSignal\n    fetch?: Fetch\n    isMaybeSingle?: boolean\n    urlLengthLimit?: number\n  }) {\n    this.method = builder.method\n    this.url = builder.url\n    this.headers = new Headers(builder.headers)\n    this.schema = builder.schema\n    this.body = builder.body\n    this.shouldThrowOnError = builder.shouldThrowOnError ?? false\n    this.signal = builder.signal\n    this.isMaybeSingle = builder.isMaybeSingle ?? false\n    this.urlLengthLimit = builder.urlLengthLimit ?? 8000\n\n    if (builder.fetch) {\n      this.fetch = builder.fetch\n    } else {\n      this.fetch = fetch\n    }\n  }\n\n  /**\n   * If there's an error with the query, throwOnError will reject the promise by\n   * throwing the error instead of returning it as part of a successful response.\n   *\n   * {@link https://github.com/supabase/supabase-js/issues/92}\n   */\n  throwOnError(): this & PostgrestBuilder<ClientOptions, Result, true> {\n    this.shouldThrowOnError = true\n    return this as this & PostgrestBuilder<ClientOptions, Result, true>\n  }\n\n  /**\n   * Set an HTTP header for the request.\n   */\n  setHeader(name: string, value: string): this {\n    this.headers = new Headers(this.headers)\n    this.headers.set(name, value)\n    return this\n  }\n\n  then<\n    TResult1 = ThrowOnError extends true\n      ? PostgrestResponseSuccess<Result>\n      : PostgrestSingleResponse<Result>,\n    TResult2 = never,\n  >(\n    onfulfilled?:\n      | ((\n          value: ThrowOnError extends true\n            ? PostgrestResponseSuccess<Result>\n            : PostgrestSingleResponse<Result>\n        ) => TResult1 | PromiseLike<TResult1>)\n      | undefined\n      | null,\n    onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null\n  ): PromiseLike<TResult1 | TResult2> {\n    // https://postgrest.org/en/stable/api.html#switching-schemas\n    if (this.schema === undefined) {\n      // skip\n    } else if (['GET', 'HEAD'].includes(this.method)) {\n      this.headers.set('Accept-Profile', this.schema)\n    } else {\n      this.headers.set('Content-Profile', this.schema)\n    }\n    if (this.method !== 'GET' && this.method !== 'HEAD') {\n      this.headers.set('Content-Type', 'application/json')\n    }\n\n    // NOTE: Invoke w/o `this` to avoid illegal invocation error.\n    // https://github.com/supabase/postgrest-js/pull/247\n    const _fetch = this.fetch\n    let res = _fetch(this.url.toString(), {\n      method: this.method,\n      headers: this.headers,\n      body: JSON.stringify(this.body),\n      signal: this.signal,\n    }).then(async (res) => {\n      let error = null\n      let data = null\n      let count: number | null = null\n      let status = res.status\n      let statusText = res.statusText\n\n      if (res.ok) {\n        if (this.method !== 'HEAD') {\n          const body = await res.text()\n          if (body === '') {\n            // Prefer: return=minimal\n          } else if (this.headers.get('Accept') === 'text/csv') {\n            data = body\n          } else if (\n            this.headers.get('Accept') &&\n            this.headers.get('Accept')?.includes('application/vnd.pgrst.plan+text')\n          ) {\n            data = body\n          } else {\n            data = JSON.parse(body)\n          }\n        }\n\n        const countHeader = this.headers.get('Prefer')?.match(/count=(exact|planned|estimated)/)\n        const contentRange = res.headers.get('content-range')?.split('/')\n        if (countHeader && contentRange && contentRange.length > 1) {\n          count = parseInt(contentRange[1])\n        }\n\n        // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n        // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n        if (this.isMaybeSingle && this.method === 'GET' && Array.isArray(data)) {\n          if (data.length > 1) {\n            error = {\n              // https://github.com/PostgREST/postgrest/blob/a867d79c42419af16c18c3fb019eba8df992626f/src/PostgREST/Error.hs#L553\n              code: 'PGRST116',\n              details: `Results contain ${data.length} rows, application/vnd.pgrst.object+json requires 1 row`,\n              hint: null,\n              message: 'JSON object requested, multiple (or no) rows returned',\n            }\n            data = null\n            count = null\n            status = 406\n            statusText = 'Not Acceptable'\n          } else if (data.length === 1) {\n            data = data[0]\n          } else {\n            data = null\n          }\n        }\n      } else {\n        const body = await res.text()\n\n        try {\n          error = JSON.parse(body)\n\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (Array.isArray(error) && res.status === 404) {\n            data = []\n            error = null\n            status = 200\n            statusText = 'OK'\n          }\n        } catch {\n          // Workaround for https://github.com/supabase/postgrest-js/issues/295\n          if (res.status === 404 && body === '') {\n            status = 204\n            statusText = 'No Content'\n          } else {\n            error = {\n              message: body,\n            }\n          }\n        }\n\n        if (error && this.isMaybeSingle && error?.details?.includes('0 rows')) {\n          error = null\n          status = 200\n          statusText = 'OK'\n        }\n\n        if (error && this.shouldThrowOnError) {\n          throw new PostgrestError(error)\n        }\n      }\n\n      const postgrestResponse = {\n        error,\n        data,\n        count,\n        status,\n        statusText,\n      }\n\n      return postgrestResponse\n    })\n    if (!this.shouldThrowOnError) {\n      res = res.catch((fetchError) => {\n        // Build detailed error information including cause if available\n        // Note: We don't populate code/hint for client-side network errors since those\n        // fields are meant for upstream service errors (PostgREST/PostgreSQL)\n        let errorDetails = ''\n        let hint = ''\n        let code = ''\n\n        // Add cause information if available (e.g., DNS errors, network failures)\n        const cause = fetchError?.cause\n        if (cause) {\n          const causeMessage = cause?.message ?? ''\n          const causeCode = cause?.code ?? ''\n\n          errorDetails = `${fetchError?.name ?? 'FetchError'}: ${fetchError?.message}`\n          errorDetails += `\\n\\nCaused by: ${cause?.name ?? 'Error'}: ${causeMessage}`\n          if (causeCode) {\n            errorDetails += ` (${causeCode})`\n          }\n          if (cause?.stack) {\n            errorDetails += `\\n${cause.stack}`\n          }\n        } else {\n          // No cause available, just include the error stack\n          errorDetails = fetchError?.stack ?? ''\n        }\n\n        // Get URL length for potential hints\n        const urlLength = this.url.toString().length\n\n        // Handle AbortError specially with helpful hints\n        if (fetchError?.name === 'AbortError' || fetchError?.code === 'ABORT_ERR') {\n          code = ''\n          hint = 'Request was aborted (timeout or manual cancellation)'\n\n          if (urlLength > this.urlLengthLimit) {\n            hint += `. Note: Your request URL is ${urlLength} characters, which may exceed server limits. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [many IDs])), consider using an RPC function to pass values server-side.`\n          }\n        }\n        // Handle HeadersOverflowError from undici (Node.js fetch implementation)\n        else if (\n          cause?.name === 'HeadersOverflowError' ||\n          cause?.code === 'UND_ERR_HEADERS_OVERFLOW'\n        ) {\n          code = ''\n          hint = 'HTTP headers exceeded server limits (typically 16KB)'\n\n          if (urlLength > this.urlLengthLimit) {\n            hint += `. Your request URL is ${urlLength} characters. If selecting many fields, consider using views. If filtering with large arrays (e.g., .in('id', [200+ IDs])), consider using an RPC function instead.`\n          }\n        }\n\n        return {\n          error: {\n            message: `${fetchError?.name ?? 'FetchError'}: ${fetchError?.message}`,\n            details: errorDetails,\n            hint: hint,\n            code: code,\n          },\n          data: null,\n          count: null,\n          status: 0,\n          statusText: '',\n        }\n      })\n    }\n\n    return res.then(onfulfilled, onrejected)\n  }\n\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n   */\n  returns<NewResult>(): PostgrestBuilder<\n    ClientOptions,\n    CheckMatchingArrayTypes<Result, NewResult>,\n    ThrowOnError\n  > {\n    /* istanbul ignore next */\n    return this as unknown as PostgrestBuilder<\n      ClientOptions,\n      CheckMatchingArrayTypes<Result, NewResult>,\n      ThrowOnError\n    >\n  }\n\n  /**\n   * Override the type of the returned `data` field in the response.\n   *\n   * @typeParam NewResult - The new type to cast the response data to\n   * @typeParam Options - Optional type configuration (defaults to { merge: true })\n   * @typeParam Options.merge - When true, merges the new type with existing return type. When false, replaces the existing types entirely (defaults to true)\n   * @example\n   * ```typescript\n   * // Merge with existing types (default behavior)\n   * const query = supabase\n   *   .from('users')\n   *   .select()\n   *   .overrideTypes<{ custom_field: string }>()\n   *\n   * // Replace existing types completely\n   * const replaceQuery = supabase\n   *   .from('users')\n   *   .select()\n   *   .overrideTypes<{ id: number; name: string }, { merge: false }>()\n   * ```\n   * @returns A PostgrestBuilder instance with the new type\n   */\n  overrideTypes<\n    NewResult,\n    Options extends { merge?: boolean } = { merge: true },\n  >(): PostgrestBuilder<\n    ClientOptions,\n    IsValidResultOverride<Result, NewResult, false, false> extends true\n      ? // Preserve the optionality of the result if the overriden type is an object (case of chaining with `maybeSingle`)\n        ContainsNull<Result> extends true\n        ? MergePartialResult<NewResult, NonNullable<Result>, Options> | null\n        : MergePartialResult<NewResult, Result, Options>\n      : CheckMatchingArrayTypes<Result, NewResult>,\n    ThrowOnError\n  > {\n    return this as unknown as PostgrestBuilder<\n      ClientOptions,\n      IsValidResultOverride<Result, NewResult, false, false> extends true\n        ? // Preserve the optionality of the result if the overriden type is an object (case of chaining with `maybeSingle`)\n          ContainsNull<Result> extends true\n          ? MergePartialResult<NewResult, NonNullable<Result>, Options> | null\n          : MergePartialResult<NewResult, Result, Options>\n        : CheckMatchingArrayTypes<Result, NewResult>,\n      ThrowOnError\n    >\n  }\n}\n","import PostgrestBuilder from './PostgrestBuilder'\nimport PostgrestFilterBuilder, { InvalidMethodError } from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser/result'\nimport { CheckMatchingArrayTypes } from './types/types'\nimport { ClientServerOptions, GenericSchema } from './types/common/common'\nimport type { MaxAffectedEnabled } from './types/feature-flags'\n\nexport default class PostgrestTransformBuilder<\n  ClientOptions extends ClientServerOptions,\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result,\n  RelationName = unknown,\n  Relationships = unknown,\n  Method = unknown,\n> extends PostgrestBuilder<ClientOptions, Result> {\n  /**\n   * Perform a SELECT on the query result.\n   *\n   * By default, `.insert()`, `.update()`, `.upsert()`, and `.delete()` do not\n   * return modified rows. By calling this method, modified rows are returned in\n   * `data`.\n   *\n   * @param columns - The columns to retrieve, separated by commas\n   */\n  select<\n    Query extends string = '*',\n    NewResultOne = GetResult<Schema, Row, RelationName, Relationships, Query, ClientOptions>,\n  >(\n    columns?: Query\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Row,\n    Method extends 'RPC'\n      ? Result extends unknown[]\n        ? NewResultOne[]\n        : NewResultOne\n      : NewResultOne[],\n    RelationName,\n    Relationships,\n    Method\n  > {\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n    this.url.searchParams.set('select', cleanedColumns)\n    this.headers.append('Prefer', 'return=representation')\n    return this as unknown as PostgrestFilterBuilder<\n      ClientOptions,\n      Schema,\n      Row,\n      Method extends 'RPC'\n        ? Result extends unknown[]\n          ? NewResultOne[]\n          : NewResultOne\n        : NewResultOne[],\n      RelationName,\n      Relationships,\n      Method\n    >\n  }\n\n  order<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: undefined }\n  ): this\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean; referencedTable?: string }\n  ): this\n  /**\n   * @deprecated Use `options.referencedTable` instead of `options.foreignTable`\n   */\n  order<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: undefined }\n  ): this\n  /**\n   * @deprecated Use `options.referencedTable` instead of `options.foreignTable`\n   */\n  order(\n    column: string,\n    options?: { ascending?: boolean; nullsFirst?: boolean; foreignTable?: string }\n  ): this\n  /**\n   * Order the query result by `column`.\n   *\n   * You can call this method multiple times to order by multiple columns.\n   *\n   * You can order referenced tables, but it only affects the ordering of the\n   * parent table if you use `!inner` in the query.\n   *\n   * @param column - The column to order by\n   * @param options - Named parameters\n   * @param options.ascending - If `true`, the result will be in ascending order\n   * @param options.nullsFirst - If `true`, `null`s appear first. If `false`,\n   * `null`s appear last.\n   * @param options.referencedTable - Set this to order a referenced table by\n   * its columns\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  order(\n    column: string,\n    {\n      ascending = true,\n      nullsFirst,\n      foreignTable,\n      referencedTable = foreignTable,\n    }: {\n      ascending?: boolean\n      nullsFirst?: boolean\n      foreignTable?: string\n      referencedTable?: string\n    } = {}\n  ): this {\n    const key = referencedTable ? `${referencedTable}.order` : 'order'\n    const existingOrder = this.url.searchParams.get(key)\n\n    this.url.searchParams.set(\n      key,\n      `${existingOrder ? `${existingOrder},` : ''}${column}.${ascending ? 'asc' : 'desc'}${\n        nullsFirst === undefined ? '' : nullsFirst ? '.nullsfirst' : '.nullslast'\n      }`\n    )\n    return this\n  }\n\n  /**\n   * Limit the query result by `count`.\n   *\n   * @param count - The maximum number of rows to return\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to limit rows of referenced\n   * tables instead of the parent table\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  limit(\n    count: number,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const key = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`\n    this.url.searchParams.set(key, `${count}`)\n    return this\n  }\n\n  /**\n   * Limit the query result by starting at an offset `from` and ending at the offset `to`.\n   * Only records within this range are returned.\n   * This respects the query order and if there is no order clause the range could behave unexpectedly.\n   * The `from` and `to` values are 0-based and inclusive: `range(1, 3)` will include the second, third\n   * and fourth rows of the query.\n   *\n   * @param from - The starting index from which to limit the result\n   * @param to - The last index to which to limit the result\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to limit rows of referenced\n   * tables instead of the parent table\n   * @param options.foreignTable - Deprecated, use `options.referencedTable`\n   * instead\n   */\n  range(\n    from: number,\n    to: number,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const keyOffset =\n      typeof referencedTable === 'undefined' ? 'offset' : `${referencedTable}.offset`\n    const keyLimit = typeof referencedTable === 'undefined' ? 'limit' : `${referencedTable}.limit`\n    this.url.searchParams.set(keyOffset, `${from}`)\n    // Range is inclusive, so add 1\n    this.url.searchParams.set(keyLimit, `${to - from + 1}`)\n    return this\n  }\n\n  /**\n   * Set the AbortSignal for the fetch request.\n   *\n   * @param signal - The AbortSignal to use for the fetch request\n   */\n  abortSignal(signal: AbortSignal): this {\n    this.signal = signal\n    return this\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be one row (e.g. using `.limit(1)`), otherwise this\n   * returns an error.\n   */\n  single<ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never>(): PostgrestBuilder<\n    ClientOptions,\n    ResultOne\n  > {\n    this.headers.set('Accept', 'application/vnd.pgrst.object+json')\n    return this as unknown as PostgrestBuilder<ClientOptions, ResultOne>\n  }\n\n  /**\n   * Return `data` as a single object instead of an array of objects.\n   *\n   * Query result must be zero or one row (e.g. using `.limit(1)`), otherwise\n   * this returns an error.\n   */\n  maybeSingle<\n    ResultOne = Result extends (infer ResultOne)[] ? ResultOne : never,\n  >(): PostgrestBuilder<ClientOptions, ResultOne | null> {\n    // Temporary partial fix for https://github.com/supabase/postgrest-js/issues/361\n    // Issue persists e.g. for `.insert([...]).select().maybeSingle()`\n    if (this.method === 'GET') {\n      this.headers.set('Accept', 'application/json')\n    } else {\n      this.headers.set('Accept', 'application/vnd.pgrst.object+json')\n    }\n    this.isMaybeSingle = true\n    return this as unknown as PostgrestBuilder<ClientOptions, ResultOne | null>\n  }\n\n  /**\n   * Return `data` as a string in CSV format.\n   */\n  csv(): PostgrestBuilder<ClientOptions, string> {\n    this.headers.set('Accept', 'text/csv')\n    return this as unknown as PostgrestBuilder<ClientOptions, string>\n  }\n\n  /**\n   * Return `data` as an object in [GeoJSON](https://geojson.org) format.\n   */\n  geojson(): PostgrestBuilder<ClientOptions, Record<string, unknown>> {\n    this.headers.set('Accept', 'application/geo+json')\n    return this as unknown as PostgrestBuilder<ClientOptions, Record<string, unknown>>\n  }\n\n  /**\n   * Return `data` as the EXPLAIN plan for the query.\n   *\n   * You need to enable the\n   * [db_plan_enabled](https://supabase.com/docs/guides/database/debugging-performance#enabling-explain)\n   * setting before using this method.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.analyze - If `true`, the query will be executed and the\n   * actual run time will be returned\n   *\n   * @param options.verbose - If `true`, the query identifier will be returned\n   * and `data` will include the output columns of the query\n   *\n   * @param options.settings - If `true`, include information on configuration\n   * parameters that affect query planning\n   *\n   * @param options.buffers - If `true`, include information on buffer usage\n   *\n   * @param options.wal - If `true`, include information on WAL record generation\n   *\n   * @param options.format - The format of the output, can be `\"text\"` (default)\n   * or `\"json\"`\n   */\n  explain({\n    analyze = false,\n    verbose = false,\n    settings = false,\n    buffers = false,\n    wal = false,\n    format = 'text',\n  }: {\n    analyze?: boolean\n    verbose?: boolean\n    settings?: boolean\n    buffers?: boolean\n    wal?: boolean\n    format?: 'json' | 'text'\n  } = {}) {\n    const options = [\n      analyze ? 'analyze' : null,\n      verbose ? 'verbose' : null,\n      settings ? 'settings' : null,\n      buffers ? 'buffers' : null,\n      wal ? 'wal' : null,\n    ]\n      .filter(Boolean)\n      .join('|')\n    // An Accept header can carry multiple media types but postgrest-js always sends one\n    const forMediatype = this.headers.get('Accept') ?? 'application/json'\n    this.headers.set(\n      'Accept',\n      `application/vnd.pgrst.plan+${format}; for=\"${forMediatype}\"; options=${options};`\n    )\n    if (format === 'json') {\n      return this as unknown as PostgrestBuilder<ClientOptions, Record<string, unknown>[]>\n    } else {\n      return this as unknown as PostgrestBuilder<ClientOptions, string>\n    }\n  }\n\n  /**\n   * Rollback the query.\n   *\n   * `data` will still be returned, but the query is not committed.\n   */\n  rollback(): this {\n    this.headers.append('Prefer', 'tx=rollback')\n    return this\n  }\n\n  /**\n   * Override the type of the returned `data`.\n   *\n   * @typeParam NewResult - The new result type to override with\n   * @deprecated Use overrideTypes<yourType, { merge: false }>() method at the end of your call chain instead\n   */\n  returns<NewResult>(): PostgrestTransformBuilder<\n    ClientOptions,\n    Schema,\n    Row,\n    CheckMatchingArrayTypes<Result, NewResult>,\n    RelationName,\n    Relationships,\n    Method\n  > {\n    return this as unknown as PostgrestTransformBuilder<\n      ClientOptions,\n      Schema,\n      Row,\n      CheckMatchingArrayTypes<Result, NewResult>,\n      RelationName,\n      Relationships,\n      Method\n    >\n  }\n\n  /**\n   * Set the maximum number of rows that can be affected by the query.\n   * Only available in PostgREST v13+ and only works with PATCH and DELETE methods.\n   *\n   * @param value - The maximum number of rows that can be affected\n   */\n  maxAffected(value: number): MaxAffectedEnabled<ClientOptions['PostgrestVersion']> extends true\n    ? // TODO: update the RPC case to only work on RPC that returns SETOF rows\n      Method extends 'PATCH' | 'DELETE' | 'RPC'\n      ? this\n      : InvalidMethodError<'maxAffected method only available on update or delete'>\n    : InvalidMethodError<'maxAffected method only available on postgrest 13+'> {\n    this.headers.append('Prefer', 'handling=strict')\n    this.headers.append('Prefer', `max-affected=${value}`)\n    return this as unknown as MaxAffectedEnabled<ClientOptions['PostgrestVersion']> extends true\n      ? Method extends 'PATCH' | 'DELETE' | 'RPC'\n        ? this\n        : InvalidMethodError<'maxAffected method only available on update or delete'>\n      : InvalidMethodError<'maxAffected method only available on postgrest 13+'>\n  }\n}\n","import PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport { JsonPathToAccessor, JsonPathToType } from './select-query-parser/utils'\nimport { ClientServerOptions, GenericSchema } from './types/common/common'\n\ntype FilterOperator =\n  | 'eq'\n  | 'neq'\n  | 'gt'\n  | 'gte'\n  | 'lt'\n  | 'lte'\n  | 'like'\n  | 'ilike'\n  | 'is'\n  | 'isdistinct'\n  | 'in'\n  | 'cs'\n  | 'cd'\n  | 'sl'\n  | 'sr'\n  | 'nxl'\n  | 'nxr'\n  | 'adj'\n  | 'ov'\n  | 'fts'\n  | 'plfts'\n  | 'phfts'\n  | 'wfts'\n  | 'match'\n  | 'imatch'\n\nexport type IsStringOperator<Path extends string> = Path extends `${string}->>${string}`\n  ? true\n  : false\n\nconst PostgrestReservedCharsRegexp = new RegExp('[,()]')\n\n// Match relationship filters with `table.column` syntax and resolve underlying\n// column value. If not matched, fallback to generic type.\n// TODO: Validate the relationship itself ala select-query-parser. Currently we\n// assume that all tables have valid relationships to each other, despite\n// nonexistent foreign keys.\ntype ResolveFilterValue<\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  ColumnName extends string,\n> = ColumnName extends `${infer RelationshipTable}.${infer Remainder}`\n  ? Remainder extends `${infer _}.${infer _}`\n    ? ResolveFilterValue<Schema, Row, Remainder>\n    : ResolveFilterRelationshipValue<Schema, RelationshipTable, Remainder>\n  : ColumnName extends keyof Row\n    ? Row[ColumnName]\n    : // If the column selection is a jsonpath like `data->value` or `data->>value` we attempt to match\n      // the expected type with the parsed custom json type\n      IsStringOperator<ColumnName> extends true\n      ? string\n      : JsonPathToType<Row, JsonPathToAccessor<ColumnName>> extends infer JsonPathValue\n        ? JsonPathValue extends never\n          ? never\n          : JsonPathValue\n        : never\n\ntype ResolveFilterRelationshipValue<\n  Schema extends GenericSchema,\n  RelationshipTable extends string,\n  RelationshipColumn extends string,\n> = Schema['Tables'] & Schema['Views'] extends infer TablesAndViews\n  ? RelationshipTable extends keyof TablesAndViews\n    ? 'Row' extends keyof TablesAndViews[RelationshipTable]\n      ? RelationshipColumn extends keyof TablesAndViews[RelationshipTable]['Row']\n        ? TablesAndViews[RelationshipTable]['Row'][RelationshipColumn]\n        : unknown\n      : unknown\n    : unknown\n  : never\n\nexport type InvalidMethodError<S extends string> = { Error: S }\n\nexport default class PostgrestFilterBuilder<\n  ClientOptions extends ClientServerOptions,\n  Schema extends GenericSchema,\n  Row extends Record<string, unknown>,\n  Result,\n  RelationName = unknown,\n  Relationships = unknown,\n  Method = unknown,\n> extends PostgrestTransformBuilder<\n  ClientOptions,\n  Schema,\n  Row,\n  Result,\n  RelationName,\n  Relationships,\n  Method\n> {\n  /**\n   * Match only rows where `column` is equal to `value`.\n   *\n   * To check if the value of `column` is NULL, you should use `.is()` instead.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  eq<ColumnName extends string>(\n    column: ColumnName,\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\n      ? NonNullable<unknown>\n      : // We want to infer the type before wrapping it into a `NonNullable` to avoid too deep\n        // type resolution error\n        ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n        ? NonNullable<ResolvedFilterValue>\n        : // We should never enter this case as all the branches are covered above\n          never\n  ): this {\n    this.url.searchParams.append(column, `eq.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is not equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  neq<ColumnName extends string>(\n    column: ColumnName,\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\n      ? unknown\n      : ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n        ? ResolvedFilterValue\n        : never\n  ): this {\n    this.url.searchParams.append(column, `neq.${value}`)\n    return this\n  }\n\n  gt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gt.${value}`)\n    return this\n  }\n\n  gte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  gte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is greater than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  gte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `gte.${value}`)\n    return this\n  }\n\n  lt<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lt(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lt(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lt.${value}`)\n    return this\n  }\n\n  lte<ColumnName extends string & keyof Row>(column: ColumnName, value: Row[ColumnName]): this\n  lte(column: string, value: unknown): this\n  /**\n   * Match only rows where `column` is less than or equal to `value`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  lte(column: string, value: unknown): this {\n    this.url.searchParams.append(column, `lte.${value}`)\n    return this\n  }\n\n  like<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  like(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  like(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `like.${pattern}`)\n    return this\n  }\n\n  likeAllOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  likeAllOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAllOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `like(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  likeAnyOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  likeAnyOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-sensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  likeAnyOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `like(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilike<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  ilike(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches `pattern` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param pattern - The pattern to match with\n   */\n  ilike(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `ilike.${pattern}`)\n    return this\n  }\n\n  ilikeAllOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  ilikeAllOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches all of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAllOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `ilike(all).{${patterns.join(',')}}`)\n    return this\n  }\n\n  ilikeAnyOf<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    patterns: readonly string[]\n  ): this\n  ilikeAnyOf(column: string, patterns: readonly string[]): this\n  /**\n   * Match only rows where `column` matches any of `patterns` case-insensitively.\n   *\n   * @param column - The column to filter on\n   * @param patterns - The patterns to match with\n   */\n  ilikeAnyOf(column: string, patterns: readonly string[]): this {\n    this.url.searchParams.append(column, `ilike(any).{${patterns.join(',')}}`)\n    return this\n  }\n\n  regexMatch<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  regexMatch(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches the PostgreSQL regex `pattern`\n   * case-sensitively (using the `~` operator).\n   *\n   * @param column - The column to filter on\n   * @param pattern - The PostgreSQL regular expression pattern to match with\n   */\n  regexMatch(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `match.${pattern}`)\n    return this\n  }\n\n  regexIMatch<ColumnName extends string & keyof Row>(column: ColumnName, pattern: string): this\n  regexIMatch(column: string, pattern: string): this\n  /**\n   * Match only rows where `column` matches the PostgreSQL regex `pattern`\n   * case-insensitively (using the `~*` operator).\n   *\n   * @param column - The column to filter on\n   * @param pattern - The PostgreSQL regular expression pattern to match with\n   */\n  regexIMatch(column: string, pattern: string): this {\n    this.url.searchParams.append(column, `imatch.${pattern}`)\n    return this\n  }\n\n  is<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: Row[ColumnName] & (boolean | null)\n  ): this\n  is(column: string, value: boolean | null): this\n  /**\n   * Match only rows where `column` IS `value`.\n   *\n   * For non-boolean columns, this is only relevant for checking if the value of\n   * `column` is NULL by setting `value` to `null`.\n   *\n   * For boolean columns, you can also set `value` to `true` or `false` and it\n   * will behave the same way as `.eq()`.\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  is(column: string, value: boolean | null): this {\n    this.url.searchParams.append(column, `is.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` IS DISTINCT FROM `value`.\n   *\n   * Unlike `.neq()`, this treats `NULL` as a comparable value. Two `NULL` values\n   * are considered equal (not distinct), and comparing `NULL` with any non-NULL\n   * value returns true (distinct).\n   *\n   * @param column - The column to filter on\n   * @param value - The value to filter with\n   */\n  isDistinct<ColumnName extends string>(\n    column: ColumnName,\n    value: ResolveFilterValue<Schema, Row, ColumnName> extends never\n      ? unknown\n      : ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n        ? ResolvedFilterValue\n        : never\n  ): this {\n    this.url.searchParams.append(column, `isdistinct.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is included in the `values` array.\n   *\n   * @param column - The column to filter on\n   * @param values - The values array to filter with\n   */\n  in<ColumnName extends string>(\n    column: ColumnName,\n    values: ReadonlyArray<\n      ResolveFilterValue<Schema, Row, ColumnName> extends never\n        ? unknown\n        : // We want to infer the type before wrapping it into a `NonNullable` to avoid too deep\n          // type resolution error\n          ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n          ? ResolvedFilterValue\n          : // We should never enter this case as all the branches are covered above\n            never\n    >\n  ): this {\n    const cleanedValues = Array.from(new Set(values))\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(column, `in.(${cleanedValues})`)\n    return this\n  }\n\n  /**\n   * Match only rows where `column` is NOT included in the `values` array.\n   *\n   * @param column - The column to filter on\n   * @param values - The values array to filter with\n   */\n  notIn<ColumnName extends string>(\n    column: ColumnName,\n    values: ReadonlyArray<\n      ResolveFilterValue<Schema, Row, ColumnName> extends never\n        ? unknown\n        : ResolveFilterValue<Schema, Row, ColumnName> extends infer ResolvedFilterValue\n          ? ResolvedFilterValue\n          : never\n    >\n  ): this {\n    const cleanedValues = Array.from(new Set(values))\n      .map((s) => {\n        // handle postgrest reserved characters\n        // https://postgrest.org/en/v7.0.0/api.html#reserved-characters\n        if (typeof s === 'string' && PostgrestReservedCharsRegexp.test(s)) return `\"${s}\"`\n        else return `${s}`\n      })\n      .join(',')\n    this.url.searchParams.append(column, `not.in.(${cleanedValues})`)\n    return this\n  }\n\n  contains<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\n  ): this\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * `column` contains every element appearing in `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  contains(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range types can be inclusive '[', ']' or exclusive '(', ')' so just\n      // keep it simple and accept a string\n      this.url.searchParams.append(column, `cs.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cs.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cs.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  containedBy<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]> | Record<string, unknown>\n  ): this\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this\n  /**\n   * Only relevant for jsonb, array, and range columns. Match only rows where\n   * every element appearing in `column` is contained by `value`.\n   *\n   * @param column - The jsonb, array, or range column to filter on\n   * @param value - The jsonb, array, or range value to filter with\n   */\n  containedBy(column: string, value: string | readonly unknown[] | Record<string, unknown>): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `cd.${value}`)\n    } else if (Array.isArray(value)) {\n      // array\n      this.url.searchParams.append(column, `cd.{${value.join(',')}}`)\n    } else {\n      // json\n      this.url.searchParams.append(column, `cd.${JSON.stringify(value)}`)\n    }\n    return this\n  }\n\n  rangeGt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is greater than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sr.${range}`)\n    return this\n  }\n\n  rangeGte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeGte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or greater than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeGte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxl.${range}`)\n    return this\n  }\n\n  rangeLt<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLt(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is less than any element in `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLt(column: string, range: string): this {\n    this.url.searchParams.append(column, `sl.${range}`)\n    return this\n  }\n\n  rangeLte<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeLte(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where every element in\n   * `column` is either contained in `range` or less than any element in\n   * `range`.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeLte(column: string, range: string): this {\n    this.url.searchParams.append(column, `nxr.${range}`)\n    return this\n  }\n\n  rangeAdjacent<ColumnName extends string & keyof Row>(column: ColumnName, range: string): this\n  rangeAdjacent(column: string, range: string): this\n  /**\n   * Only relevant for range columns. Match only rows where `column` is\n   * mutually exclusive to `range` and there can be no element between the two\n   * ranges.\n   *\n   * @param column - The range column to filter on\n   * @param range - The range to filter with\n   */\n  rangeAdjacent(column: string, range: string): this {\n    this.url.searchParams.append(column, `adj.${range}`)\n    return this\n  }\n\n  overlaps<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    value: string | ReadonlyArray<Row[ColumnName]>\n  ): this\n  overlaps(column: string, value: string | readonly unknown[]): this\n  /**\n   * Only relevant for array and range columns. Match only rows where\n   * `column` and `value` have an element in common.\n   *\n   * @param column - The array or range column to filter on\n   * @param value - The array or range value to filter with\n   */\n  overlaps(column: string, value: string | readonly unknown[]): this {\n    if (typeof value === 'string') {\n      // range\n      this.url.searchParams.append(column, `ov.${value}`)\n    } else {\n      // array\n      this.url.searchParams.append(column, `ov.{${value.join(',')}}`)\n    }\n    return this\n  }\n\n  textSearch<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  textSearch(\n    column: string,\n    query: string,\n    options?: { config?: string; type?: 'plain' | 'phrase' | 'websearch' }\n  ): this\n  /**\n   * Only relevant for text and tsvector columns. Match only rows where\n   * `column` matches the query string in `query`.\n   *\n   * @param column - The text or tsvector column to filter on\n   * @param query - The query text to match with\n   * @param options - Named parameters\n   * @param options.config - The text search configuration to use\n   * @param options.type - Change how the `query` text is interpreted\n   */\n  textSearch(\n    column: string,\n    query: string,\n    { config, type }: { config?: string; type?: 'plain' | 'phrase' | 'websearch' } = {}\n  ): this {\n    let typePart = ''\n    if (type === 'plain') {\n      typePart = 'pl'\n    } else if (type === 'phrase') {\n      typePart = 'ph'\n    } else if (type === 'websearch') {\n      typePart = 'w'\n    }\n    const configPart = config === undefined ? '' : `(${config})`\n    this.url.searchParams.append(column, `${typePart}fts${configPart}.${query}`)\n    return this\n  }\n\n  match<ColumnName extends string & keyof Row>(query: Record<ColumnName, Row[ColumnName]>): this\n  match(query: Record<string, unknown>): this\n  /**\n   * Match only rows where each column in `query` keys is equal to its\n   * associated value. Shorthand for multiple `.eq()`s.\n   *\n   * @param query - The object to filter with, with column names as keys mapped\n   * to their filter values\n   */\n  match(query: Record<string, unknown>): this {\n    Object.entries(query).forEach(([column, value]) => {\n      this.url.searchParams.append(column, `eq.${value}`)\n    })\n    return this\n  }\n\n  not<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: FilterOperator,\n    value: Row[ColumnName]\n  ): this\n  not(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which doesn't satisfy the filter.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to be negated to filter with, following\n   * PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  not(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `not.${operator}.${value}`)\n    return this\n  }\n\n  /**\n   * Match only rows which satisfy at least one of the filters.\n   *\n   * Unlike most filters, `filters` is used as-is and needs to follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure it's properly sanitized.\n   *\n   * It's currently not possible to do an `.or()` filter across multiple tables.\n   *\n   * @param filters - The filters to use, following PostgREST syntax\n   * @param options - Named parameters\n   * @param options.referencedTable - Set this to filter on referenced tables\n   * instead of the parent table\n   * @param options.foreignTable - Deprecated, use `referencedTable` instead\n   */\n  or(\n    filters: string,\n    {\n      foreignTable,\n      referencedTable = foreignTable,\n    }: { foreignTable?: string; referencedTable?: string } = {}\n  ): this {\n    const key = referencedTable ? `${referencedTable}.or` : 'or'\n    this.url.searchParams.append(key, `(${filters})`)\n    return this\n  }\n\n  filter<ColumnName extends string & keyof Row>(\n    column: ColumnName,\n    operator: `${'' | 'not.'}${FilterOperator}`,\n    value: unknown\n  ): this\n  filter(column: string, operator: string, value: unknown): this\n  /**\n   * Match only rows which satisfy the filter. This is an escape hatch - you\n   * should use the specific filter methods wherever possible.\n   *\n   * Unlike most filters, `opearator` and `value` are used as-is and need to\n   * follow [PostgREST\n   * syntax](https://postgrest.org/en/stable/api.html#operators). You also need\n   * to make sure they are properly sanitized.\n   *\n   * @param column - The column to filter on\n   * @param operator - The operator to filter with, following PostgREST syntax\n   * @param value - The value to filter with, following PostgREST syntax\n   */\n  filter(column: string, operator: string, value: unknown): this {\n    this.url.searchParams.append(column, `${operator}.${value}`)\n    return this\n  }\n}\n","import PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { GetResult } from './select-query-parser/result'\nimport {\n  ClientServerOptions,\n  Fetch,\n  GenericSchema,\n  GenericTable,\n  GenericView,\n} from './types/common/common'\n\nexport default class PostgrestQueryBuilder<\n  ClientOptions extends ClientServerOptions,\n  Schema extends GenericSchema,\n  Relation extends GenericTable | GenericView,\n  RelationName = unknown,\n  Relationships = Relation extends { Relationships: infer R } ? R : unknown,\n> {\n  url: URL\n  headers: Headers\n  schema?: string\n  signal?: AbortSignal\n  fetch?: Fetch\n  urlLengthLimit: number\n\n  /**\n   * Creates a query builder scoped to a Postgres table or view.\n   *\n   * @example\n   * ```ts\n   * import PostgrestQueryBuilder from '@supabase/postgrest-js'\n   *\n   * const query = new PostgrestQueryBuilder(\n   *   new URL('https://xyzcompany.supabase.co/rest/v1/users'),\n   *   { headers: { apikey: 'public-anon-key' } }\n   * )\n   * ```\n   */\n  constructor(\n    url: URL,\n    {\n      headers = {},\n      schema,\n      fetch,\n      urlLengthLimit = 8000,\n    }: {\n      headers?: HeadersInit\n      schema?: string\n      fetch?: Fetch\n      urlLengthLimit?: number\n    }\n  ) {\n    this.url = url\n    this.headers = new Headers(headers)\n    this.schema = schema\n    this.fetch = fetch\n    this.urlLengthLimit = urlLengthLimit\n  }\n\n  /**\n   * Clone URL and headers to prevent shared state between operations.\n   */\n  private cloneRequestState(): { url: URL; headers: Headers } {\n    return {\n      url: new URL(this.url.toString()),\n      headers: new Headers(this.headers),\n    }\n  }\n\n  /**\n   * Perform a SELECT query on the table or view.\n   *\n   * @param columns - The columns to retrieve, separated by commas. Columns can be renamed when returned with `customName:columnName`\n   *\n   * @param options - Named parameters\n   *\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   *\n   * @param options.count - Count algorithm to use to count rows in the table or view.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @remarks\n   * When using `count` with `.range()` or `.limit()`, the returned `count` is the total number of rows\n   * that match your filters, not the number of rows in the current page. Use this to build pagination UI.\n   */\n  select<\n    Query extends string = '*',\n    ResultOne = GetResult<\n      Schema,\n      Relation['Row'],\n      RelationName,\n      Relationships,\n      Query,\n      ClientOptions\n    >,\n  >(\n    columns?: Query,\n    options?: {\n      head?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    ResultOne[],\n    RelationName,\n    Relationships,\n    'GET'\n  > {\n    const { head = false, count } = options ?? {}\n\n    const method = head ? 'HEAD' : 'GET'\n    // Remove whitespaces except when quoted\n    let quoted = false\n    const cleanedColumns = (columns ?? '*')\n      .split('')\n      .map((c) => {\n        if (/\\s/.test(c) && !quoted) {\n          return ''\n        }\n        if (c === '\"') {\n          quoted = !quoted\n        }\n        return c\n      })\n      .join('')\n\n    const { url, headers } = this.cloneRequestState()\n    url.searchParams.set('select', cleanedColumns)\n\n    if (count) {\n      headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      fetch: this.fetch,\n      urlLengthLimit: this.urlLengthLimit,\n    })\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk inserts.\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  /**\n   * Perform an INSERT into the table or view.\n   *\n   * By default, inserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to insert. Pass an object to insert a single row\n   * or an array to insert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count inserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. Only applies for bulk\n   * inserts.\n   */\n  insert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      count,\n      defaultToNull = true,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  > {\n    const method = 'POST'\n    const { url, headers } = this.cloneRequestState()\n\n    if (count) {\n      headers.append('Prefer', `count=${count}`)\n    }\n    if (!defaultToNull) {\n      headers.append('Prefer', `missing=default`)\n    }\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n      urlLengthLimit: this.urlLengthLimit,\n    })\n  }\n\n  // TODO(v3): Make `defaultToNull` consistent for both single & bulk upserts.\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row,\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row[],\n    options?: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    }\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  >\n  /**\n   * Perform an UPSERT on the table or view. Depending on the column(s) passed\n   * to `onConflict`, `.upsert()` allows you to perform the equivalent of\n   * `.insert()` if a row with the corresponding `onConflict` columns doesn't\n   * exist, or if it does exist, perform an alternative action depending on\n   * `ignoreDuplicates`.\n   *\n   * By default, upserted rows are not returned. To return it, chain the call\n   * with `.select()`.\n   *\n   * @param values - The values to upsert with. Pass an object to upsert a\n   * single row or an array to upsert multiple rows.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.onConflict - Comma-separated UNIQUE column(s) to specify how\n   * duplicate rows are determined. Two rows are duplicates if all the\n   * `onConflict` columns are equal.\n   *\n   * @param options.ignoreDuplicates - If `true`, duplicate rows are ignored. If\n   * `false`, duplicate rows are merged with existing rows.\n   *\n   * @param options.count - Count algorithm to use to count upserted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @param options.defaultToNull - Make missing fields default to `null`.\n   * Otherwise, use the default value for the column. This only applies when\n   * inserting new rows, not when merging with existing rows under\n   * `ignoreDuplicates: false`. This also only applies when doing bulk upserts.\n   *\n   * @example Upsert a single row using a unique key\n   * ```ts\n   * // Upserting a single row, overwriting based on the 'username' unique column\n   * const { data, error } = await supabase\n   *   .from('users')\n   *   .upsert({ username: 'supabot' }, { onConflict: 'username' })\n   *\n   * // Example response:\n   * // {\n   * //   data: [\n   * //     { id: 4, message: 'bar', username: 'supabot' }\n   * //   ],\n   * //   error: null\n   * // }\n   * ```\n   *\n   * @example Upsert with conflict resolution and exact row counting\n   * ```ts\n   * // Upserting and returning exact count\n   * const { data, error, count } = await supabase\n   *   .from('users')\n   *   .upsert(\n   *     {\n   *       id: 3,\n   *       message: 'foo',\n   *       username: 'supabot'\n   *     },\n   *     {\n   *       onConflict: 'username',\n   *       count: 'exact'\n   *     }\n   *   )\n   *\n   * // Example response:\n   * // {\n   * //   data: [\n   * //     {\n   * //       id: 42,\n   * //       handle: \"saoirse\",\n   * //       display_name: \"Saoirse\"\n   * //     }\n   * //   ],\n   * //   count: 1,\n   * //   error: null\n   * // }\n   * ```\n   */\n\n  upsert<Row extends Relation extends { Insert: unknown } ? Relation['Insert'] : never>(\n    values: Row | Row[],\n    {\n      onConflict,\n      ignoreDuplicates = false,\n      count,\n      defaultToNull = true,\n    }: {\n      onConflict?: string\n      ignoreDuplicates?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n      defaultToNull?: boolean\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'POST'\n  > {\n    const method = 'POST'\n    const { url, headers } = this.cloneRequestState()\n\n    headers.append('Prefer', `resolution=${ignoreDuplicates ? 'ignore' : 'merge'}-duplicates`)\n\n    if (onConflict !== undefined) url.searchParams.set('on_conflict', onConflict)\n    if (count) {\n      headers.append('Prefer', `count=${count}`)\n    }\n    if (!defaultToNull) {\n      headers.append('Prefer', 'missing=default')\n    }\n\n    if (Array.isArray(values)) {\n      const columns = values.reduce((acc, x) => acc.concat(Object.keys(x)), [] as string[])\n      if (columns.length > 0) {\n        const uniqueColumns = [...new Set(columns)].map((column) => `\"${column}\"`)\n        url.searchParams.set('columns', uniqueColumns.join(','))\n      }\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n      urlLengthLimit: this.urlLengthLimit,\n    })\n  }\n\n  /**\n   * Perform an UPDATE on the table or view.\n   *\n   * By default, updated rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param values - The values to update with\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count updated rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  update<Row extends Relation extends { Update: unknown } ? Relation['Update'] : never>(\n    values: Row,\n    {\n      count,\n    }: {\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'PATCH'\n  > {\n    const method = 'PATCH'\n    const { url, headers } = this.cloneRequestState()\n\n    if (count) {\n      headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      body: values,\n      fetch: this.fetch ?? fetch,\n      urlLengthLimit: this.urlLengthLimit,\n    })\n  }\n\n  /**\n   * Perform a DELETE on the table or view.\n   *\n   * By default, deleted rows are not returned. To return it, chain the call\n   * with `.select()` after filters.\n   *\n   * @param options - Named parameters\n   *\n   * @param options.count - Count algorithm to use to count deleted rows.\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   */\n  delete({\n    count,\n  }: {\n    count?: 'exact' | 'planned' | 'estimated'\n  } = {}): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    Relation['Row'],\n    null,\n    RelationName,\n    Relationships,\n    'DELETE'\n  > {\n    const method = 'DELETE'\n    const { url, headers } = this.cloneRequestState()\n\n    if (count) {\n      headers.append('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schema,\n      fetch: this.fetch ?? fetch,\n      urlLengthLimit: this.urlLengthLimit,\n    })\n  }\n}\n","import PostgrestQueryBuilder from './PostgrestQueryBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport { Fetch, GenericSchema, ClientServerOptions } from './types/common/common'\nimport { GetRpcFunctionFilterBuilderByArgs } from './types/common/rpc'\n\n/**\n * PostgREST client.\n *\n * @typeParam Database - Types for the schema from the [type\n * generator](https://supabase.com/docs/reference/javascript/next/typescript-support)\n *\n * @typeParam SchemaName - Postgres schema to switch to. Must be a string\n * literal, the same one passed to the constructor. If the schema is not\n * `\"public\"`, this must be supplied manually.\n */\nexport default class PostgrestClient<\n  Database = any,\n  ClientOptions extends ClientServerOptions = Database extends {\n    __InternalSupabase: infer I extends ClientServerOptions\n  }\n    ? I\n    : {},\n  SchemaName extends string &\n    keyof Omit<Database, '__InternalSupabase'> = 'public' extends keyof Omit<\n    Database,\n    '__InternalSupabase'\n  >\n    ? 'public'\n    : string & keyof Omit<Database, '__InternalSupabase'>,\n  Schema extends GenericSchema = Omit<\n    Database,\n    '__InternalSupabase'\n  >[SchemaName] extends GenericSchema\n    ? Omit<Database, '__InternalSupabase'>[SchemaName]\n    : any,\n> {\n  url: string\n  headers: Headers\n  schemaName?: SchemaName\n  fetch?: Fetch\n  urlLengthLimit: number\n\n  // TODO: Add back shouldThrowOnError once we figure out the typings\n  /**\n   * Creates a PostgREST client.\n   *\n   * @param url - URL of the PostgREST endpoint\n   * @param options - Named parameters\n   * @param options.headers - Custom headers\n   * @param options.schema - Postgres schema to switch to\n   * @param options.fetch - Custom fetch\n   * @param options.timeout - Optional timeout in milliseconds for all requests. When set, requests will automatically abort after this duration to prevent indefinite hangs.\n   * @param options.urlLengthLimit - Maximum URL length in characters before warnings/errors are triggered. Defaults to 8000.\n   * @example\n   * ```ts\n   * import PostgrestClient from '@supabase/postgrest-js'\n   *\n   * const postgrest = new PostgrestClient('https://xyzcompany.supabase.co/rest/v1', {\n   *   headers: { apikey: 'public-anon-key' },\n   *   schema: 'public',\n   *   timeout: 30000, // 30 second timeout\n   * })\n   * ```\n   */\n  constructor(\n    url: string,\n    {\n      headers = {},\n      schema,\n      fetch,\n      timeout,\n      urlLengthLimit = 8000,\n    }: {\n      headers?: HeadersInit\n      schema?: SchemaName\n      fetch?: Fetch\n      timeout?: number\n      urlLengthLimit?: number\n    } = {}\n  ) {\n    this.url = url\n    this.headers = new Headers(headers)\n    this.schemaName = schema\n    this.urlLengthLimit = urlLengthLimit\n\n    const originalFetch = fetch ?? globalThis.fetch\n\n    // Wrap fetch with timeout if specified\n    if (timeout !== undefined && timeout > 0) {\n      this.fetch = (input, init) => {\n        const controller = new AbortController()\n        const timeoutId = setTimeout(() => controller.abort(), timeout)\n\n        // Merge abort signals if one already exists\n        const existingSignal = init?.signal\n        if (existingSignal) {\n          // If the existing signal is already aborted, use it directly\n          if (existingSignal.aborted) {\n            clearTimeout(timeoutId)\n            return originalFetch(input, init)\n          }\n\n          // Listen to existing signal and abort our controller too\n          const abortHandler = () => {\n            clearTimeout(timeoutId)\n            controller.abort()\n          }\n          existingSignal.addEventListener('abort', abortHandler, { once: true })\n\n          return originalFetch(input, {\n            ...init,\n            signal: controller.signal,\n          }).finally(() => {\n            clearTimeout(timeoutId)\n            existingSignal.removeEventListener('abort', abortHandler)\n          })\n        }\n\n        return originalFetch(input, {\n          ...init,\n          signal: controller.signal,\n        }).finally(() => clearTimeout(timeoutId))\n      }\n    } else {\n      this.fetch = originalFetch\n    }\n  }\n  from<\n    TableName extends string & keyof Schema['Tables'],\n    Table extends Schema['Tables'][TableName],\n  >(relation: TableName): PostgrestQueryBuilder<ClientOptions, Schema, Table, TableName>\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\n    relation: ViewName\n  ): PostgrestQueryBuilder<ClientOptions, Schema, View, ViewName>\n  /**\n   * Perform a query on a table or a view.\n   *\n   * @param relation - The table or view name to query\n   */\n  from(relation: string): PostgrestQueryBuilder<ClientOptions, Schema, any, any> {\n    if (!relation || typeof relation !== 'string' || relation.trim() === '') {\n      throw new Error('Invalid relation name: relation must be a non-empty string.')\n    }\n\n    const url = new URL(`${this.url}/${relation}`)\n    return new PostgrestQueryBuilder(url, {\n      headers: new Headers(this.headers),\n      schema: this.schemaName,\n      fetch: this.fetch,\n      urlLengthLimit: this.urlLengthLimit,\n    })\n  }\n\n  /**\n   * Select a schema to query or perform an function (rpc) call.\n   *\n   * The schema needs to be on the list of exposed schemas inside Supabase.\n   *\n   * @param schema - The schema to query\n   */\n  schema<DynamicSchema extends string & keyof Omit<Database, '__InternalSupabase'>>(\n    schema: DynamicSchema\n  ): PostgrestClient<\n    Database,\n    ClientOptions,\n    DynamicSchema,\n    Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\n  > {\n    return new PostgrestClient(this.url, {\n      headers: this.headers,\n      schema,\n      fetch: this.fetch,\n      urlLengthLimit: this.urlLengthLimit,\n    })\n  }\n\n  /**\n   * Perform a function call.\n   *\n   * @param fn - The function name to call\n   * @param args - The arguments to pass to the function call\n   * @param options - Named parameters\n   * @param options.head - When set to `true`, `data` will not be returned.\n   * Useful if you only need the count.\n   * @param options.get - When set to `true`, the function will be called with\n   * read-only access mode.\n   * @param options.count - Count algorithm to use to count rows returned by the\n   * function. Only applicable for [set-returning\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\n   *\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\n   * hood.\n   *\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\n   * statistics under the hood.\n   *\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\n   * numbers.\n   *\n   * @example\n   * ```ts\n   * // For cross-schema functions where type inference fails, use overrideTypes:\n   * const { data } = await supabase\n   *   .schema('schema_b')\n   *   .rpc('function_a', {})\n   *   .overrideTypes<{ id: string; user_id: string }[]>()\n   * ```\n   */\n  rpc<\n    FnName extends string & keyof Schema['Functions'],\n    Args extends Schema['Functions'][FnName]['Args'] = never,\n    FilterBuilder extends GetRpcFunctionFilterBuilderByArgs<\n      Schema,\n      FnName,\n      Args\n    > = GetRpcFunctionFilterBuilderByArgs<Schema, FnName, Args>,\n  >(\n    fn: FnName,\n    args: Args = {} as Args,\n    {\n      head = false,\n      get = false,\n      count,\n    }: {\n      head?: boolean\n      get?: boolean\n      count?: 'exact' | 'planned' | 'estimated'\n    } = {}\n  ): PostgrestFilterBuilder<\n    ClientOptions,\n    Schema,\n    FilterBuilder['Row'],\n    FilterBuilder['Result'],\n    FilterBuilder['RelationName'],\n    FilterBuilder['Relationships'],\n    'RPC'\n  > {\n    let method: 'HEAD' | 'GET' | 'POST'\n    const url = new URL(`${this.url}/rpc/${fn}`)\n    let body: unknown | undefined\n    // objects/arrays-of-objects can't be serialized to URL params, use POST + return=minimal instead\n    const _isObject = (v: unknown): boolean =>\n      v !== null && typeof v === 'object' && (!Array.isArray(v) || v.some(_isObject))\n    const _hasObjectArg = head && Object.values(args as object).some(_isObject)\n    if (_hasObjectArg) {\n      method = 'POST'\n      body = args\n    } else if (head || get) {\n      method = head ? 'HEAD' : 'GET'\n      Object.entries(args)\n        // params with undefined value needs to be filtered out, otherwise it'll\n        // show up as `?param=undefined`\n        .filter(([_, value]) => value !== undefined)\n        // array values need special syntax\n        .map(([name, value]) => [name, Array.isArray(value) ? `{${value.join(',')}}` : `${value}`])\n        .forEach(([name, value]) => {\n          url.searchParams.append(name, value)\n        })\n    } else {\n      method = 'POST'\n      body = args\n    }\n\n    const headers = new Headers(this.headers)\n    if (_hasObjectArg) {\n      headers.set('Prefer', count ? `count=${count},return=minimal` : 'return=minimal')\n    } else if (count) {\n      headers.set('Prefer', `count=${count}`)\n    }\n\n    return new PostgrestFilterBuilder({\n      method,\n      url,\n      headers,\n      schema: this.schemaName,\n      body,\n      fetch: this.fetch ?? fetch,\n      urlLengthLimit: this.urlLengthLimit,\n    })\n  }\n}\n","import PostgrestClient from './PostgrestClient'\nimport PostgrestQueryBuilder from './PostgrestQueryBuilder'\nimport PostgrestFilterBuilder from './PostgrestFilterBuilder'\nimport PostgrestTransformBuilder from './PostgrestTransformBuilder'\nimport PostgrestBuilder from './PostgrestBuilder'\nimport PostgrestError from './PostgrestError'\n\nexport {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n}\nexport default {\n  PostgrestClient,\n  PostgrestQueryBuilder,\n  PostgrestFilterBuilder,\n  PostgrestTransformBuilder,\n  PostgrestBuilder,\n  PostgrestError,\n}\nexport type {\n  PostgrestResponse,\n  PostgrestResponseFailure,\n  PostgrestResponseSuccess,\n  PostgrestSingleResponse,\n  PostgrestMaybeSingleResponse,\n} from './types/types'\nexport type { ClientServerOptions as PostgrestClientOptions } from './types/common/common'\n// https://github.com/supabase/postgrest-js/issues/551\n// To be replaced with a helper type that only uses public types\nexport type { GetResult as UnstableGetResult } from './select-query-parser/result'\n"],"mappings":"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"}