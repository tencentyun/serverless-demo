{"version":3,"file":"meta.js","names":["modifiedSchema: InteropZodObject","schema"],"sources":["../../../src/graph/zod/meta.ts"],"sourcesContent":["import {\n  InferInteropZodOutput,\n  InteropZodObject,\n  InteropZodType,\n  getInteropZodObjectShape,\n  extendInteropZodObject,\n  getInteropZodDefaultGetter,\n  interopZodObjectPartial,\n  InteropZodObjectShape,\n  isZodSchemaV3,\n  getSchemaDescription,\n} from \"@langchain/core/utils/types\";\nimport { BaseChannel } from \"../../channels/base.js\";\nimport { BinaryOperatorAggregate } from \"../../channels/binop.js\";\nimport { LastValue } from \"../../channels/last_value.js\";\n\nexport const META_EXTRAS_DESCRIPTION_PREFIX = \"lg:\";\n\n/** @internal */\nexport type ReducedZodChannel<\n  T extends InteropZodType,\n  TReducerSchema extends InteropZodType\n> = T & {\n  lg_reducer_schema: TReducerSchema;\n};\n\n/** @internal */\nexport type InteropZodToStateDefinition<\n  T extends InteropZodObject,\n  TShape = InteropZodObjectShape<T>\n> = {\n  [key in keyof TShape]: TShape[key] extends ReducedZodChannel<\n    infer Schema,\n    infer ReducerSchema\n  >\n    ? Schema extends InteropZodType<infer V>\n      ? ReducerSchema extends InteropZodType<infer U>\n        ? BaseChannel<V, U>\n        : never\n      : never\n    : TShape[key] extends InteropZodType<infer V, infer U>\n    ? BaseChannel<V, U>\n    : never;\n};\n\nexport type UpdateType<\n  T extends InteropZodObject,\n  TShape = InteropZodObjectShape<T>\n> = {\n  [key in keyof TShape]?: TShape[key] extends ReducedZodChannel<\n    infer Schema,\n    infer ReducerSchema\n  >\n    ? Schema extends InteropZodType<unknown>\n      ? ReducerSchema extends InteropZodType<infer U>\n        ? U\n        : never\n      : never\n    : TShape[key] extends InteropZodType<unknown, infer U>\n    ? U\n    : never;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport interface SchemaMeta<TValue = any, TUpdate = TValue> {\n  jsonSchemaExtra?: {\n    langgraph_nodes?: string[];\n    langgraph_type?: \"prompt\" | \"messages\";\n    [key: string]: unknown;\n  };\n  reducer?: {\n    schema?: InteropZodType<TUpdate>;\n    fn: (a: TValue, b: TUpdate) => TValue;\n  };\n  default?: () => TValue;\n}\n\n/**\n * A registry for storing and managing metadata associated with schemas.\n * This class provides methods to get, extend, remove, and check metadata for a given schema.\n */\nexport class SchemaMetaRegistry {\n  /**\n   * Internal map storing schema metadata.\n   * @internal\n   */\n  _map = new WeakMap<InteropZodType, SchemaMeta>();\n\n  /**\n   * Cache for extended schfemas.\n   * @internal\n   */\n  _extensionCache = new Map<string, WeakMap<InteropZodType, InteropZodType>>();\n\n  /**\n   * Retrieves the metadata associated with a given schema.\n   * @template TValue The value type of the schema.\n   * @template TUpdate The update type of the schema (defaults to TValue).\n   * @param schema The schema to retrieve metadata for.\n   * @returns The associated SchemaMeta, or undefined if not present.\n   */\n  get<TValue, TUpdate = TValue>(\n    schema: InteropZodType<TValue>\n  ): SchemaMeta<TValue, TUpdate> | undefined {\n    return this._map.get(schema);\n  }\n\n  /**\n   * Extends or sets the metadata for a given schema.\n   * @template TValue The value type of the schema.\n   * @template TUpdate The update type of the schema (defaults to TValue).\n   * @param schema The schema to extend metadata for.\n   * @param predicate A function that receives the existing metadata (or undefined) and returns the new metadata.\n   */\n  extend<TValue, TUpdate>(\n    schema: InteropZodType<TValue>,\n    predicate: (\n      meta: SchemaMeta<TValue, TUpdate> | undefined\n    ) => SchemaMeta<TValue, TUpdate>\n  ) {\n    const existingMeta = this.get<TValue, TUpdate>(schema);\n    this._map.set(schema, predicate(existingMeta));\n  }\n\n  /**\n   * Removes the metadata associated with a given schema.\n   * @param schema The schema to remove metadata for.\n   * @returns The SchemaMetaRegistry instance (for chaining).\n   */\n  remove(schema: InteropZodType): this {\n    this._map.delete(schema);\n    return this;\n  }\n\n  /**\n   * Checks if metadata exists for a given schema.\n   * @param schema The schema to check.\n   * @returns True if metadata exists, false otherwise.\n   */\n  has(schema: InteropZodType): boolean {\n    return this._map.has(schema);\n  }\n\n  /**\n   * Returns a mapping of channel instances for each property in the schema\n   * using the associated metadata in the registry.\n   *\n   * This is used to create the `channels` object that's passed to the `Graph` constructor.\n   *\n   * @template T The shape of the schema.\n   * @param schema The schema to extract channels from.\n   * @returns A mapping from property names to channel instances.\n   */\n  getChannelsForSchema<T extends InteropZodObject>(\n    schema: T\n  ): InteropZodToStateDefinition<T> {\n    const channels = {} as Record<string, BaseChannel>;\n    const shape = getInteropZodObjectShape(schema);\n    for (const [key, channelSchema] of Object.entries(shape)) {\n      const meta = this.get(channelSchema);\n      if (meta?.reducer) {\n        channels[key] = new BinaryOperatorAggregate<\n          InferInteropZodOutput<typeof channelSchema>\n        >(meta.reducer.fn, meta.default);\n      } else {\n        channels[key] = new LastValue(meta?.default);\n      }\n    }\n    return channels as InteropZodToStateDefinition<T>;\n  }\n\n  /**\n   * Returns a modified schema that introspectively looks at all keys of the provided\n   * object schema, and applies the augmentations based on meta provided with those keys\n   * in the registry and the selectors provided in the `effects` parameter.\n   *\n   * This assumes that the passed in schema is the \"root\" schema object for a graph where\n   * the keys of the schema are the channels of the graph. Because we need to represent\n   * the input of a graph in a couple of different ways, the `effects` parameter allows\n   * us to apply those augmentations based on pre determined conditions.\n   *\n   * @param schema The root schema object to extend.\n   * @param effects The effects that are being applied.\n   * @returns The extended schema.\n   */\n  getExtendedChannelSchemas<T extends InteropZodObject>(\n    schema: T,\n    effects: {\n      /**\n       * Augments the shape by using the reducer's schema if it exists\n       */\n      withReducerSchema?: boolean;\n      /**\n       * Applies the stringified jsonSchemaExtra as a description to the schema.\n       */\n      withJsonSchemaExtrasAsDescription?: boolean;\n      /**\n       * Applies the `.partial()` modifier to the schema.\n       */\n      asPartial?: boolean;\n    }\n  ): InteropZodObject {\n    // If no effects are being applied, return the schema unchanged\n    if (Object.keys(effects).length === 0) {\n      return schema;\n    }\n\n    // Cache key is determined by looking at the effects that are being applied\n    const cacheKey = Object.entries(effects)\n      .filter(([, v]) => v === true)\n      .sort(([a], [b]) => a.localeCompare(b))\n      .map(([k, v]) => `${k}:${v}`)\n      .join(\"|\");\n\n    const cache = this._extensionCache.get(cacheKey) ?? new WeakMap();\n    if (cache.has(schema)) return cache.get(schema)! as T;\n\n    let modifiedSchema: InteropZodObject = schema;\n\n    if (\n      effects.withReducerSchema ||\n      effects.withJsonSchemaExtrasAsDescription\n    ) {\n      const newShapeEntries = Object.entries(\n        getInteropZodObjectShape(schema)\n      ).map(([key, schema]) => {\n        const meta = this.get(schema);\n        let outputSchema = effects.withReducerSchema\n          ? meta?.reducer?.schema ?? schema\n          : schema;\n        if (\n          effects.withJsonSchemaExtrasAsDescription &&\n          meta?.jsonSchemaExtra\n        ) {\n          const description =\n            getSchemaDescription(outputSchema) ?? getSchemaDescription(schema);\n          const strExtras = JSON.stringify({\n            ...meta.jsonSchemaExtra,\n            description,\n          });\n          outputSchema = outputSchema.describe(\n            `${META_EXTRAS_DESCRIPTION_PREFIX}${strExtras}`\n          );\n        }\n        return [key, outputSchema];\n      });\n      modifiedSchema = extendInteropZodObject(\n        schema,\n        Object.fromEntries(newShapeEntries)\n      );\n      if (isZodSchemaV3(modifiedSchema)) {\n        modifiedSchema._def.unknownKeys = \"strip\";\n      }\n    }\n    if (effects.asPartial) {\n      modifiedSchema = interopZodObjectPartial(modifiedSchema);\n    }\n\n    cache.set(schema, modifiedSchema);\n    this._extensionCache.set(cacheKey, cache);\n    return modifiedSchema;\n  }\n}\n\nexport const schemaMetaRegistry = new SchemaMetaRegistry();\n\nexport function withLangGraph<\n  TValue,\n  TUpdate,\n  TSchema extends InteropZodType<TValue>\n>(\n  schema: TSchema,\n  meta: SchemaMeta<TValue, TUpdate> & { reducer?: undefined }\n): TSchema;\nexport function withLangGraph<\n  TValue,\n  TUpdate,\n  TSchema extends InteropZodType<TValue>\n>(\n  schema: TSchema,\n  meta: SchemaMeta<TValue, TUpdate>\n): ReducedZodChannel<TSchema, InteropZodType<TUpdate>>;\nexport function withLangGraph<\n  TValue,\n  TUpdate,\n  TSchema extends InteropZodType<TValue>\n>(\n  schema: TSchema,\n  meta: SchemaMeta<TValue, TUpdate>\n): ReducedZodChannel<TSchema, InteropZodType<TUpdate>> | TSchema {\n  if (meta.reducer && !meta.default) {\n    const defaultValueGetter = getInteropZodDefaultGetter(schema);\n    if (defaultValueGetter != null) {\n      // eslint-disable-next-line no-param-reassign\n      meta.default = defaultValueGetter;\n    }\n  }\n  if (meta.reducer) {\n    const schemaWithReducer = Object.assign(schema, {\n      lg_reducer_schema: meta.reducer?.schema ?? schema,\n    });\n    schemaMetaRegistry.extend(schemaWithReducer, () => meta);\n    return schemaWithReducer;\n  } else {\n    schemaMetaRegistry.extend(schema, () => meta);\n    return schema;\n  }\n}\n"],"mappings":";;;;;AAgBA,MAAa,iCAAiC;;;;;AAiE9C,IAAa,qBAAb,MAAgC;;;;;CAK9B,uBAAO,IAAI;;;;;CAMX,kCAAkB,IAAI;;;;;;;;CAStB,IACE,QACyC;AACzC,SAAO,KAAK,KAAK,IAAI;;;;;;;;;CAUvB,OACE,QACA,WAGA;EACA,MAAM,eAAe,KAAK,IAAqB;AAC/C,OAAK,KAAK,IAAI,QAAQ,UAAU;;;;;;;CAQlC,OAAO,QAA8B;AACnC,OAAK,KAAK,OAAO;AACjB,SAAO;;;;;;;CAQT,IAAI,QAAiC;AACnC,SAAO,KAAK,KAAK,IAAI;;;;;;;;;;;;CAavB,qBACE,QACgC;EAChC,MAAM,WAAW;EACjB,MAAM,QAAQ,yBAAyB;AACvC,OAAK,MAAM,CAAC,KAAK,kBAAkB,OAAO,QAAQ,QAAQ;GACxD,MAAM,OAAO,KAAK,IAAI;AACtB,OAAI,MAAM,QACR,UAAS,OAAO,IAAI,wBAElB,KAAK,QAAQ,IAAI,KAAK;OAExB,UAAS,OAAO,IAAI,UAAU,MAAM;;AAGxC,SAAO;;;;;;;;;;;;;;;;CAiBT,0BACE,QACA,SAckB;AAElB,MAAI,OAAO,KAAK,SAAS,WAAW,EAClC,QAAO;EAIT,MAAM,WAAW,OAAO,QAAQ,SAC7B,QAAQ,GAAG,OAAO,MAAM,MACxB,MAAM,CAAC,IAAI,CAAC,OAAO,EAAE,cAAc,IACnC,KAAK,CAAC,GAAG,OAAO,GAAG,EAAE,GAAG,KACxB,KAAK;EAER,MAAM,QAAQ,KAAK,gBAAgB,IAAI,6BAAa,IAAI;AACxD,MAAI,MAAM,IAAI,QAAS,QAAO,MAAM,IAAI;EAExC,IAAIA,iBAAmC;AAEvC,MACE,QAAQ,qBACR,QAAQ,mCACR;GACA,MAAM,kBAAkB,OAAO,QAC7B,yBAAyB,SACzB,KAAK,CAAC,KAAKC,cAAY;IACvB,MAAM,OAAO,KAAK,IAAIA;IACtB,IAAI,eAAe,QAAQ,oBACvB,MAAM,SAAS,UAAUA,WACzBA;AACJ,QACE,QAAQ,qCACR,MAAM,iBACN;KACA,MAAM,cACJ,qBAAqB,iBAAiB,qBAAqBA;KAC7D,MAAM,YAAY,KAAK,UAAU;MAC/B,GAAG,KAAK;MACR;;AAEF,oBAAe,aAAa,SAC1B,GAAG,iCAAiC;;AAGxC,WAAO,CAAC,KAAK;;AAEf,oBAAiB,uBACf,QACA,OAAO,YAAY;AAErB,OAAI,cAAc,gBAChB,gBAAe,KAAK,cAAc;;AAGtC,MAAI,QAAQ,UACV,kBAAiB,wBAAwB;AAG3C,QAAM,IAAI,QAAQ;AAClB,OAAK,gBAAgB,IAAI,UAAU;AACnC,SAAO;;;AAIX,MAAa,qBAAqB,IAAI;AAkBtC,SAAgB,cAKd,QACA,MAC+D;AAC/D,KAAI,KAAK,WAAW,CAAC,KAAK,SAAS;EACjC,MAAM,qBAAqB,2BAA2B;AACtD,MAAI,sBAAsB,KAExB,MAAK,UAAU;;AAGnB,KAAI,KAAK,SAAS;EAChB,MAAM,oBAAoB,OAAO,OAAO,QAAQ,EAC9C,mBAAmB,KAAK,SAAS,UAAU;AAE7C,qBAAmB,OAAO,yBAAyB;AACnD,SAAO;QACF;AACL,qBAAmB,OAAO,cAAc;AACxC,SAAO"}