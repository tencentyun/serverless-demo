"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FunctionService = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const lodash_1 = __importDefault(require("lodash"));
const cos_nodejs_sdk_v5_1 = __importDefault(require("cos-nodejs-sdk-v5"));
const packer_1 = require("./packer");
const error_1 = require("../error");
const utils_1 = require("../utils");
const constant_1 = require("../constant");
// 是否为 Node 函数
function isNodeFunction(runtime) {
    // 不严格限制
    return runtime === 'Nodejs10.15' || runtime === 'Nodejs8.9' || (runtime === null || runtime === void 0 ? void 0 : runtime.includes('Nodejs'));
}
// 解析函数配置，换成请求参数
function configToParams(options) {
    var _a, _b, _c, _d, _e, _f, _g;
    const { func, codeSecret, baseParams } = options;
    let installDependency;
    // Node 函数默认安装依赖
    installDependency = isNodeFunction(func.runtime) ? 'TRUE' : 'FALSE';
    // 是否安装依赖，选项可以覆盖
    if (typeof func.installDependency !== 'undefined') {
        installDependency = func.installDependency ? 'TRUE' : 'FALSE';
    }
    // 转换环境变量
    const envVariables = Object.keys(func.envVariables || {}).map(key => ({
        Key: key,
        Value: func.envVariables[key]
    }));
    // 当不存在 L5 配置时，不修改 L5 状态，否则根据 true/false 进行修改
    const l5Enable = typeof (func === null || func === void 0 ? void 0 : func.l5) === 'undefined' ? null : (func === null || func === void 0 ? void 0 : func.l5) ? 'TRUE' : 'FALSE';
    const params = Object.assign(Object.assign({}, baseParams), { FunctionName: func.name, 
        // 不可选择
        L5Enable: l5Enable });
    // 函数绑定的角色
    params.Role = func.role || params.Role;
    // 修复参数存在 undefined 字段时，会出现鉴权失败的情况
    // Environment 为覆盖式修改，不保留已有字段
    envVariables.length && (params.Environment = { Variables: envVariables });
    // 处理入口
    params.Handler = func.handler || 'index.main';
    // 默认超时时间为 10S
    params.Timeout = Number(func.timeout) || 10;
    // 默认运行环境 Nodejs8.9
    params.Runtime = func.runtime || 'Nodejs8.9';
    if (((_a = func === null || func === void 0 ? void 0 : func.vpc) === null || _a === void 0 ? void 0 : _a.subnetId) !== undefined && ((_b = func === null || func === void 0 ? void 0 : func.vpc) === null || _b === void 0 ? void 0 : _b.vpcId) !== undefined) {
        // VPC 网络
        params.VpcConfig = {
            SubnetId: (_c = func === null || func === void 0 ? void 0 : func.vpc) === null || _c === void 0 ? void 0 : _c.subnetId,
            VpcId: (_d = func === null || func === void 0 ? void 0 : func.vpc) === null || _d === void 0 ? void 0 : _d.vpcId
        };
    }
    // 运行内存
    params.MemorySize = func.memorySize || 256;
    // 自动安装依赖
    params.InstallDependency = installDependency;
    // 代码保护
    if (codeSecret || func.codeSecret) {
        params.CodeSecret = codeSecret || func.codeSecret;
    }
    // 函数层
    if ((_e = func === null || func === void 0 ? void 0 : func.layers) === null || _e === void 0 ? void 0 : _e.length) {
        const transformLayers = func.layers.map(item => ({
            LayerName: item.name,
            LayerVersion: item.version
        }));
        params.Layers = transformLayers;
    }
    // HTTP 云函数类型
    if ((func === null || func === void 0 ? void 0 : func.type) === 'HTTP') {
        params.Type = 'HTTP';
        // WebSocket 协议支持
        if ((func === null || func === void 0 ? void 0 : func.protocolType) === 'WS') {
            params.ProtocolType = 'WS';
            // 协议参数，直接透传或使用默认值
            // 参考文档：https://cloud.tencent.com/document/api/583/17244#ProtocolParams
            const idleTimeOut = (_g = (_f = func === null || func === void 0 ? void 0 : func.protocolParams) === null || _f === void 0 ? void 0 : _f.wsParams) === null || _g === void 0 ? void 0 : _g.idleTimeOut;
            params.ProtocolParams = {
                WSParams: {
                    IdleTimeOut: typeof idleTimeOut === 'number' ? idleTimeOut : 15
                }
            };
        }
        // 多并发配置
        // 参考文档：https://cloud.tencent.com/document/api/583/17244#InstanceConcurrencyConfig
        if (func === null || func === void 0 ? void 0 : func.instanceConcurrencyConfig) {
            params.InstanceConcurrencyConfig = {
                DynamicEnabled: func.instanceConcurrencyConfig.dynamicEnabled || 'FALSE',
                MaxConcurrency: func.instanceConcurrencyConfig.maxConcurrency || 10
            };
        }
    }
    // 云函数描述
    if (func === null || func === void 0 ? void 0 : func.description) {
        params.Description = func.description;
    }
    return params;
}
class FunctionService {
    constructor(environment) {
        this.environment = environment;
        this.scfService = new utils_1.CloudService(environment.cloudBaseContext, 'scf', '2018-04-16');
        this.vpcService = new utils_1.CloudService(environment.cloudBaseContext, 'vpc', '2017-03-12');
        this.tcbService = new utils_1.CloudService(environment.cloudBaseContext, 'tcb', '2018-06-08');
        this.userService = environment.getUserService();
    }
    /**
     * 增量更新函数代码
     * @param {IUpdateFunctionIncrementalCodeParam} funcParam
     * @returns {Promise<void>}
     * @memberof FunctionService
     */
    async updateFunctionIncrementalCode(funcParam) {
        const { env, namespace } = this.getFunctionConfig();
        const { functionRootPath, func, deleteFiles, addFiles } = funcParam;
        const { name, runtime } = func;
        const params = {
            FunctionName: name,
            EnvId: env,
            Namespace: namespace
        };
        let packer;
        let base64;
        if (deleteFiles) {
            params.DeleteFiles = deleteFiles;
        }
        if (addFiles) {
            // 将选中的增量文件或增量文件夹  转base64
            const codeType = runtime === 'Java8' ? packer_1.CodeType.JavaFile : packer_1.CodeType.File;
            packer = new packer_1.FunctionPacker({
                codeType,
                name,
                root: functionRootPath,
                ignore: [],
                incrementalPath: addFiles
            });
            await packer.build();
            base64 = await packer.getBase64Code();
            if (!base64) {
                throw new error_1.CloudBaseError('函数不存在！');
            }
            params.AddFiles = base64;
        }
        return this.tcbService.request('UpdateFunctionIncrementalCode', params);
    }
    /**
     * 创建云函数
     * @param {ICreateFunctionParam} funcParam
     * @returns {(Promise<IResponseInfo | ICreateFunctionRes>)}
     */
    async createFunction(funcParam) {
        const { env } = this.getFunctionConfig();
        const { func, functionRootPath, force = false, base64Code, codeSecret, functionPath, deployMode } = funcParam;
        const funcName = func.name;
        const params = configToParams({
            func,
            codeSecret,
            baseParams: {
                EnvId: env,
                Role: 'TCB_QcsRole',
                Stamp: 'MINI_QCBASE'
            }
        });
        params.Code = await this.getCodeParams({
            func,
            base64Code,
            functionPath,
            functionRootPath,
            deployMode
        }, params.InstallDependency);
        const { TopicId, LogsetId } = this.getClsServiceConfig();
        params.ClsTopicId = TopicId;
        params.ClsLogsetId = LogsetId;
        try {
            // 创建云函数
            const res = await this.tcbService.request('CreateFunction', params);
            // 等待函数状态正常
            await this.waitFunctionActive(funcName, codeSecret);
            // 创建函数触发器、失败自动重试
            await this.retryCreateTrigger(funcName, func.triggers);
            // 设置路径，创建云接入路径
            if (func.path) {
                await this.createAccessPath(funcName, func.path);
            }
            // 检查函数状态
            await this.waitFunctionActive(funcName, codeSecret);
            return res;
        }
        catch (e) {
            // 函数存在
            const functionExist = e.code === 'ResourceInUse.FunctionName' || e.code === 'ResourceInUse.Function';
            // 已存在同名函数，强制更新
            if (functionExist && force) {
                // 1. 更新函数配置和代码，同名函数可能存在 codeSecret，先修改代码，清除 codeSecret
                const codeRes = await this.updateFunctionCode({
                    func,
                    base64Code,
                    functionPath,
                    functionRootPath,
                    codeSecret: codeSecret
                });
                // 等待函数状态正常
                await this.waitFunctionActive(funcName, codeSecret);
                // 2. 更新函数配置
                const configRes = await this.updateFunctionConfig(func);
                // 等待函数状态正常
                await this.waitFunctionActive(funcName, codeSecret);
                // 3. 创建函数触发器
                const triggerRes = await this.retryCreateTrigger(funcName, func.triggers);
                // 设置路径，创建云接入路径
                if (func.path) {
                    await this.createAccessPath(funcName, func.path);
                }
                // 检查函数状态
                await this.waitFunctionActive(funcName, codeSecret);
                // 返回全部操作的响应值
                return {
                    triggerRes,
                    configRes,
                    codeRes
                };
            }
            // 不强制覆盖，抛出错误
            if (e.message && !force) {
                throw new error_1.CloudBaseError(`[${funcName}] 部署失败：\n${e.message}`, {
                    code: e.code,
                    requestId: e.requestId
                });
            }
            throw e;
        }
    }
    /**
     * @param {number} [limit=20]
     * @param {number} [offset=0]
     * @returns {Promise<{
     *         Functions: Record<string, string>[]
     *         RequestId: string
     *         TotalCount: number
     *     }>}
     * @memberof FunctionService
     */
    async getFunctionList(limit = 20, offset = 0) {
        // 获取Function 环境配置
        const { env } = this.getFunctionConfig();
        const res = await this.tcbService.request('ListFunctions', {
            EnvId: env,
            Limit: limit,
            Offset: offset
        });
        return res;
    }
    /**
     * 列出函数
     * @param {number} [limit=20]
     * @param {number} [offset=0]
     * @returns {Promise<Record<string, string>[]>}
     */
    async listFunctions(limit = 20, offset = 0) {
        // 获取Function 环境配置
        const { env } = this.getFunctionConfig();
        const res = await this.tcbService.request('ListFunctions', {
            EnvId: env,
            Limit: limit,
            Offset: offset
        });
        const { Functions = [] } = res;
        const data = [];
        Functions.forEach(func => {
            const { FunctionId, FunctionName, Runtime, AddTime, ModTime, Status } = func;
            data.push({
                FunctionId,
                FunctionName,
                Runtime,
                AddTime,
                ModTime,
                Status
            });
        });
        return data;
    }
    /**
     * 列出所有函数
     * @param {IListFunctionOptions} options
     * @returns {Promise<Record<string, string>[]>}
     */
    async listAllFunctions(options) {
        const allFunctions = [];
        let currentOffset = 0;
        const pageSize = 20;
        const { envId } = options;
        while (true) {
            try {
                const res = await this.tcbService.request('ListFunctions', {
                    EnvId: envId,
                    Limit: pageSize,
                    Offset: currentOffset
                });
                const { Functions = [], TotalCount } = res;
                if (Functions.length === 0) {
                    break;
                }
                allFunctions.push(...Functions);
                // 检查是否已获取所有函数
                if (allFunctions.length >= TotalCount || Functions.length < pageSize) {
                    break;
                }
                currentOffset += pageSize;
            }
            catch (error) {
                throw new error_1.CloudBaseError(`获取函数列表失败: ${error.message}`);
            }
        }
        // 格式化数据
        const data = [];
        allFunctions.forEach(func => {
            const { FunctionId, FunctionName, Runtime, AddTime, ModTime, Status } = func;
            data.push({
                FunctionId,
                FunctionName,
                Runtime,
                AddTime,
                ModTime,
                Status
            });
        });
        return data;
    }
    /**
     * 删除云函数
     * @param {string} name 云函数名称
     * @param {string} qualifier 需要删除的版本号，不填默认删除函数下全部版本。
     * @returns {Promise<IResponseInfo>}
     */
    async deleteFunction({ name }) {
        var _a;
        const { namespace } = this.getFunctionConfig();
        // 检测是否绑定了 API 网关
        const accessService = this.environment.getAccessService();
        const res = await accessService.getAccessList({
            name
        });
        // 删除绑定的 API 网关
        if (((_a = res === null || res === void 0 ? void 0 : res.APISet) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            await accessService.deleteAccess({
                name
            });
        }
        await this.scfService.request('DeleteFunction', {
            FunctionName: name,
            Namespace: namespace
        });
    }
    /**
     * 批量删除云函数
     * @param {Object} options
     * @param {string[]} options.names 云函数名称列表
     * @returns {Promise<void>}
     */
    async batchDeleteFunctions({ names }) {
        const promises = names.map(name => (async () => {
            try {
                await this.deleteFunction({ name });
                (0, utils_1.successLog)(`[${name}] 函数删除成功！`);
            }
            catch (e) {
                throw new error_1.CloudBaseError(e.message);
            }
        })());
        await Promise.all(promises);
    }
    /**
     * 获取云函数详细信息
     * @param {string} name 云函数名称
     * @returns {Promise<Record<string, string>>}
     */
    async getFunctionDetail(name, codeSecret) {
        const { env } = this.getFunctionConfig();
        const params = {
            FunctionName: name,
            EnvId: env,
            ShowCode: 'TRUE',
            Namespace: env
        };
        if (codeSecret) {
            params.CodeSecret = codeSecret;
        }
        const data = await this.tcbService.request('GetFunction', params);
        // 解析 VPC 配置
        const { VpcId = '', SubnetId = '' } = data.VpcConfig || {};
        if (VpcId && SubnetId) {
            try {
                const vpcs = await this.getVpcs();
                const subnets = await this.getSubnets(VpcId);
                const vpc = vpcs.find(item => item.VpcId === VpcId);
                const subnet = subnets.find(item => item.SubnetId === SubnetId);
                // FIXME: 这里的 vpc 和 subnet 不应该是 string 吧，它是 vpcs 和 subnets 的项啊
                data.VpcConfig = {
                    // @ts-ignore
                    vpc,
                    // @ts-ignore
                    subnet
                };
            }
            catch (e) {
                data.VpcConfig = {
                    vpc: 'VpcId',
                    subnet: 'SubnetId'
                };
            }
        }
        return data;
    }
    /**
     * 批量获取云函数详细信息
     * @param {Object} options
     * @param {string[]} options.names 云函数名称列表
     * @param {string} options.envId 环境 ID
     * @param {string} options.codeSecret
     * @returns {Promise<IFunctionInfo[]>}
     */
    async batchGetFunctionsDetail({ names, envId, codeSecret }) {
        const data = [];
        const promises = names.map(name => (async () => {
            try {
                const info = await this.getFunctionDetail(name, codeSecret);
                data.push(info);
            }
            catch (e) {
                throw new error_1.CloudBaseError(`${name} 获取信息失败：${e.message}`);
            }
        })());
        await Promise.all(promises);
        return data;
    }
    /**
     * 获取函数日志
     * @deprecated 请使用 getFunctionLogsV2 代替
     * @param {{
    *         name: string
    *         offset: number
    *         limit: number
    *         order: string
    *         orderBy: string
    *         startTime: string
    *         endTime: string
    *         requestId: string
    *     }} options
    * @returns {Promise<IFunctionLogRes>}
    */
    async getFunctionLogs(options) {
        let { name, offset = 0, limit = 10, order, orderBy, startTime, endTime, requestId } = options;
        const { namespace } = this.getFunctionConfig();
        if (startTime && !endTime) {
            // 自动补 endTime 为 startTime + 1d
            endTime = (0, utils_1.formatTimeByMs)(new Date(startTime).getTime() + 24 * 3600 * 1000);
        }
        if (endTime && !startTime) {
            // 自动补 startTime 为 endTime - 1d
            startTime = (0, utils_1.formatTimeByMs)(new Date(endTime).getTime() - 24 * 3600 * 1000);
        }
        const params = {
            Namespace: namespace,
            FunctionName: name,
            Offset: offset,
            Limit: limit,
            Order: order,
            OrderBy: orderBy,
            StartTime: startTime,
            EndTime: endTime,
            FunctionRequestId: requestId
        };
        const res = await this.scfService.request('GetFunctionLogs', params);
        return res;
    }
    /**
 * 获取函数日志 ID 列表
 * @param {{
    *         name: string
    *         offset: number
    *         limit: number
    *         startTime: string
    *         endTime: string
    *         requestId: string
    *         qualifier: string
    *     }} options
    * @returns {Promise<IFunctionLogResV2>}
    */
    async getFunctionLogsV2(options) {
        let { name, offset = 0, limit = 10, startTime, endTime, requestId, qualifier } = options;
        const { env } = this.getFunctionConfig();
        ({ startTime, endTime } = (0, utils_1.getCompleteTimeRange)({
            startTime,
            endTime
        }));
        const params = {
            EnvId: env,
            FunctionName: name,
            Offset: offset,
            Limit: limit,
            StartTime: startTime,
            EndTime: endTime,
            LogRequestId: requestId,
            Qualifier: qualifier || "$LATEST" // 云函数版本，不传则用 $LATEST
        };
        const res = await this.tcbService.request('GetFunctionLogs', params);
        return res;
    }
    /**
 * 根据函数日志 ID 查询日志详情
 * @param {{
    *         startTime: string
    *         endTime: string
    *         logRequestId: string
    *     }} options
    * @returns {Promise<IFunctionLogDetailRes>}
    */
    async getFunctionLogDetail(options) {
        let { logRequestId, startTime, endTime } = options;
        ({ startTime, endTime } = (0, utils_1.getCompleteTimeRange)({
            startTime,
            endTime
        }));
        const params = {
            StartTime: startTime,
            LogRequestId: logRequestId,
            EndTime: endTime
        };
        const res = await this.tcbService.request('GetFunctionLogDetail', params);
        return res;
    }
    /**
     * 获取函数的完整调用日志
     * 该方法会自动完成两步操作：1. 获取日志请求ID列表。 2. 根据ID列表获取每条日志的详细内容。
     * @param {IFunctionLogOptionsV2} options - 查询选项
     * @returns {Promise<IFunctionLogDetailRes[]>} 返回包含完整日志详情的数组
     */
    async getCompleteFunctionLogs(options) {
        // 调用 getFunctionLogsV2 获取日志请求ID列表
        const { name } = options;
        const logs = await this.getFunctionLogsV2(options);
        // 如果没有日志，直接返回空数组
        if (logs.LogList.length === 0) {
            return [];
        }
        const detailPromises = logs.LogList.map(async (log) => {
            // 对每一个日志ID，调用 getFunctionLogDetail
            const res = await this.getFunctionLogDetail({
                logRequestId: log.RequestId,
                startTime: options.startTime,
                endTime: options.endTime
            });
            return Object.assign(Object.assign({}, res), { RetCode: log.RetCode, FunctionName: name });
        });
        // 并发执行所有详情查询，等待它们全部完成
        const detailedLogs = await Promise.all(detailPromises);
        return detailedLogs;
    }
    /**
     * 更新云函数配置
     * @param {ICloudFunction} func 云函数配置
     * @returns {Promise<IResponseInfo>}
     */
    async updateFunctionConfig(func) {
        var _a, _b, _c, _d, _e, _f, _g;
        const { namespace } = this.getFunctionConfig();
        const envVariables = Object.keys(func.envVariables || {}).map(key => ({
            Key: key,
            Value: func.envVariables[key]
        }));
        // 当不存在 L5 配置时，不修改 L5 状态，否则根据 true/false 进行修改
        const l5Enable = typeof func.l5 === 'undefined' ? null : func.l5 ? 'TRUE' : 'FALSE';
        const params = {
            FunctionName: func.name,
            Namespace: namespace,
            L5Enable: l5Enable
        };
        if (func === null || func === void 0 ? void 0 : func.description) {
            params.Description = func.description;
        }
        // 修复参数存在 undefined 字段时，会出现鉴权失败的情况
        // Environment 为覆盖式修改，不保留已有字段
        envVariables.length && (params.Environment = { Variables: envVariables });
        // 不设默认超时时间，防止覆盖已有配置
        func.timeout && (params.Timeout = func.timeout);
        // 运行时
        func.runtime && (params.Runtime = func.runtime);
        if (((_a = func === null || func === void 0 ? void 0 : func.vpc) === null || _a === void 0 ? void 0 : _a.subnetId) !== undefined && ((_b = func === null || func === void 0 ? void 0 : func.vpc) === null || _b === void 0 ? void 0 : _b.vpcId) !== undefined) {
            // VPC 网络
            params.VpcConfig = {
                SubnetId: (_c = func === null || func === void 0 ? void 0 : func.vpc) === null || _c === void 0 ? void 0 : _c.subnetId,
                VpcId: (_d = func === null || func === void 0 ? void 0 : func.vpc) === null || _d === void 0 ? void 0 : _d.vpcId
            };
        }
        // 内存
        func.memorySize && (params.MemorySize = func.memorySize);
        // Node 函数默认安装依赖
        isNodeFunction(func.runtime) && (params.InstallDependency = 'TRUE');
        // 是否安装依赖，选项可以覆盖
        if (typeof func.installDependency !== 'undefined') {
            params.InstallDependency = func.installDependency ? 'TRUE' : 'FALSE';
        }
        // 函数层
        if ((_e = func === null || func === void 0 ? void 0 : func.layers) === null || _e === void 0 ? void 0 : _e.length) {
            const transformLayers = func.layers.map(item => ({
                LayerName: item.name,
                LayerVersion: item.version
            }));
            params.Layers = transformLayers;
        }
        // WebSocket 协议支持（仅 HTTP 函数）
        if (func === null || func === void 0 ? void 0 : func.protocolParams) {
            const idleTimeOut = (_g = (_f = func === null || func === void 0 ? void 0 : func.protocolParams) === null || _f === void 0 ? void 0 : _f.wsParams) === null || _g === void 0 ? void 0 : _g.idleTimeOut;
            params.ProtocolParams = {
                WSParams: {
                    IdleTimeOut: typeof idleTimeOut === 'number' ? idleTimeOut : 15
                }
            };
        }
        // 多并发配置（仅 HTTP 函数）
        if (func === null || func === void 0 ? void 0 : func.instanceConcurrencyConfig) {
            params.InstanceConcurrencyConfig = {
                DynamicEnabled: func.instanceConcurrencyConfig.dynamicEnabled || 'FALSE',
                MaxConcurrency: func.instanceConcurrencyConfig.maxConcurrency || 10
            };
        }
        try {
            // 如果函数配置中包含触发器，则更新触发器
            if (func.triggers && func.triggers.length > 0) {
                try {
                    await this.createFunctionTriggers(func.name, func.triggers);
                }
                catch (triggerError) {
                    // 如果触发器创建失败，记录警告
                    console.warn(`[${func.name}] 触发器更新失败：${triggerError.message}`);
                }
            }
            return this.scfService.request('UpdateFunctionConfiguration', params);
        }
        catch (e) {
            throw new error_1.CloudBaseError(`[${func.name}] 更新函数配置失败：${e.message}`, {
                code: e.code,
                requestId: e.requestId
            });
        }
    }
    /**
     *
     * @param {IUpdateFunctionCodeParam} funcParam
     * @returns {Promise<IResponseInfo>}
     * @memberof FunctionService
     */
    async updateFunctionCode(funcParam) {
        const { func, functionRootPath, base64Code, codeSecret, functionPath, deployMode } = funcParam;
        const funcName = func.name;
        const { env } = this.getFunctionConfig();
        let installDependency;
        // Node 函数默认安装依赖
        installDependency = isNodeFunction(func.runtime) ? 'TRUE' : 'FALSE';
        // 是否安装依赖，选项可以覆盖
        if (typeof func.installDependency !== 'undefined') {
            installDependency = func.installDependency ? 'TRUE' : 'FALSE';
        }
        const codeParams = await this.getCodeParams({
            func,
            functionPath,
            functionRootPath,
            base64Code,
            deployMode
        }, installDependency);
        const params = {
            FunctionName: funcName,
            EnvId: env,
            Handler: func.handler || 'index.main',
            InstallDependency: installDependency,
            Code: codeParams
        };
        if (codeSecret) {
            params.CodeSecret = codeSecret;
        }
        try {
            // 等待函数状态正常
            await this.waitFunctionActive(funcName, codeSecret);
            // 更新云函数代码
            const res = await this.tcbService.request('UpdateFunctionCode', params);
            if (installDependency && func.isWaitInstall === true) {
                await this.waitFunctionActive(funcName, codeSecret);
            }
            return res;
        }
        catch (e) {
            throw new error_1.CloudBaseError(`[${funcName}] 函数代码更新失败：${e.message}`, {
                code: e.code,
                requestId: e.requestId
            });
        }
    }
    /**
     * 调用云函数
     * @param {string} name 云函数名称
     * @param {Record<string, any>} params 调用函数传入参数
     * @returns {Promise<IFunctionInvokeRes>}
     */
    async invokeFunction(name, params) {
        const { namespace } = this.getFunctionConfig();
        const _params = {
            FunctionName: name,
            Namespace: namespace,
            LogType: 'Tail'
        };
        if (params) {
            _params.ClientContext = JSON.stringify(params);
        }
        try {
            const { RequestId, Result } = await this.scfService.request('Invoke', _params);
            return Object.assign({ RequestId }, Result);
        }
        catch (e) {
            throw new error_1.CloudBaseError(`[${name}] 调用失败：${e.message}`, {
                requestId: e.requestId
            });
        }
    }
    /**
     * 批量调用云函数
     * @param {IFunctionBatchOptions} options
     * @returns {Promise<IFunctionInvokeRes[]>}
     */
    async batchInvokeFunctions(options) {
        const { functions, envId, log = false } = options;
        const promises = functions.map(func => (async () => {
            try {
                const result = await this.invokeFunction(func.name, func.params);
                if (log) {
                    (0, utils_1.successLog)(`[${func.name}] 调用成功\n响应结果：\n`);
                    console.log(result);
                }
                return result;
            }
            catch (e) {
                throw new error_1.CloudBaseError(`${func.name} 函数调用失败：${e.message}`);
            }
        })());
        return Promise.all(promises);
    }
    /**
     * 复制云函数
     * @param {string} name 云函数名称
     * @param {string} newFunctionName 新的云函数名称
     * @param {string} targetEnvId 目标环境 Id
     * @param {boolean} [force=false] 是否覆盖同名云函数
     * @returns {Promise<IResponseInfo>}
     */
    /* eslint-disable-next-line */
    async copyFunction(name, newFunctionName, targetEnvId, force = false) {
        const { namespace } = this.getFunctionConfig();
        if (!namespace || !name || !newFunctionName) {
            throw new error_1.CloudBaseError('参数缺失');
        }
        return this.scfService.request('CopyFunction', {
            FunctionName: name,
            NewFunctionName: newFunctionName,
            Namespace: namespace,
            TargetNamespace: targetEnvId || namespace,
            Override: force ? true : false
        });
    }
    /**
     * 创建云函数触发器
     * @param {string} name 云函数名称
     * @param {ICloudFunctionTrigger[]} triggers 云函数触发器配置
     * @returns {Promise<IResponseInfo>}
     */
    async createFunctionTriggers(name, triggers = []) {
        if (!triggers || !triggers.length)
            return null;
        const { namespace } = this.getFunctionConfig();
        const parsedTriggers = triggers.map(item => {
            if (item.type !== 'timer') {
                throw new error_1.CloudBaseError(`不支持的触发器类型 [${item.type}]，目前仅支持定时触发器（timer）！`);
            }
            return {
                TriggerName: item.name,
                Type: item.type,
                TriggerDesc: item.config
            };
        });
        try {
            return await this.scfService.request('BatchCreateTrigger', {
                FunctionName: name,
                Namespace: namespace,
                Triggers: JSON.stringify(parsedTriggers),
                Count: parsedTriggers.length
            });
        }
        catch (e) {
            throw new error_1.CloudBaseError(`[${name}] 创建触发器失败：${e.message}`, {
                action: e.action,
                code: e.code,
                requestId: e.requestId
            });
        }
    }
    // 批量部署函数触发器
    async batchCreateTriggers(options) {
        const { functions, envId } = options;
        const promises = functions.map(func => (async () => {
            try {
                await this.createFunctionTriggers(func.name, func.triggers);
                (0, utils_1.successLog)(`[${func.name}] 创建云函数触发器成功！`);
            }
            catch (e) {
                throw new error_1.CloudBaseError(e.message);
            }
        })());
        await Promise.all(promises);
    }
    /**
     * 删除云函数触发器
     * @param {string} name 云函数名称
     * @param {string} triggerName 云函数触发器名称
     * @returns {Promise<IResponseInfo>}
     */
    async deleteFunctionTrigger(name, triggerName) {
        const { namespace } = this.getFunctionConfig();
        try {
            await this.scfService.request('DeleteTrigger', {
                FunctionName: name,
                Namespace: namespace,
                TriggerName: triggerName,
                Type: 'timer'
            });
            (0, utils_1.successLog)(`[${name}] 删除云函数触发器 ${triggerName} 成功！`);
        }
        catch (e) {
            throw new error_1.CloudBaseError(`[${name}] 删除触发器失败：${e.message}`);
        }
    }
    async batchDeleteTriggers(options) {
        const { functions, envId } = options;
        const promises = functions.map(func => (async () => {
            try {
                func.triggers.forEach(async (trigger) => {
                    await this.deleteFunctionTrigger(func.name, trigger.name);
                });
            }
            catch (e) {
                throw new error_1.CloudBaseError(e.message);
            }
        })());
        await Promise.all(promises);
    }
    /**
     * 下载云函数代码
     * @param {IFunctionCodeOptions} options
     * @returns {Promise<void>}
     */
    async downloadFunctionCode(options) {
        const { destPath, envId, functionName, codeSecret } = options;
        // 检验路径是否存在
        (0, utils_1.checkFullAccess)(destPath, true);
        // 获取下载链接
        const { Url } = await this.scfService.request('GetFunctionAddress', {
            FunctionName: functionName,
            Namespace: envId,
            CodeSecret: codeSecret
        });
        // 下载文件
        return (0, utils_1.downloadAndExtractRemoteZip)(Url, destPath);
    }
    /**
     * 获取云函数代码下载 链接
     * @param {string} functionName
     * @param {string} [codeSecret]
     * @returns {Promise<IFunctionDownloadUrlRes>}
     * @memberof FunctionService
     */
    async getFunctionDownloadUrl(functionName, codeSecret) {
        const { namespace } = this.getFunctionConfig();
        const params = {
            FunctionName: functionName,
            Namespace: namespace
        };
        if (codeSecret) {
            params.CodeSecret = codeSecret;
        }
        try {
            const { Url, CodeSha256, RequestId } = await this.scfService.request('GetFunctionAddress', params);
            return { Url, RequestId, CodeSha256 };
        }
        catch (e) {
            throw new error_1.CloudBaseError(`[${functionName}] 获取函数代码下载链接失败：${e.message}`, {
                requestId: e.requestId
            });
        }
    }
    // 函数绑定文件层
    async attachLayer(options) {
        const { envId, functionName, layerName, layerVersion, codeSecret } = options;
        let { Layers = [] } = await this.getFunctionDetail(functionName, codeSecret);
        Layers = Layers.map(item => lodash_1.default.pick(item, ['LayerName', 'LayerVersion']));
        // 新加的文件层添加到最后
        Layers.push({
            LayerName: layerName,
            LayerVersion: layerVersion
        });
        const res = await this.scfService.request('UpdateFunctionConfiguration', {
            Layers,
            Namespace: envId,
            FunctionName: functionName
        });
        return res;
    }
    // 函数解绑文件层
    async unAttachLayer(options) {
        const { envId, functionName, layerName, layerVersion, codeSecret } = options;
        let { Layers } = await this.getFunctionDetail(functionName, codeSecret);
        Layers = Layers.map(item => lodash_1.default.pick(item, ['LayerName', 'LayerVersion']));
        const index = Layers.findIndex(item => item.LayerName === layerName && item.LayerVersion === layerVersion);
        if (index === -1) {
            throw new error_1.CloudBaseError('层不存在');
        }
        // 删除指定的层
        Layers.splice(index, 1);
        const apiParams = {
            Namespace: envId,
            FunctionName: functionName,
            Layers: Layers.length > 0 ? Layers : [{
                    LayerName: '',
                    LayerVersion: 0
                }]
        };
        return this.scfService.request('UpdateFunctionConfiguration', apiParams);
    }
    // 更新云函数层
    async updateFunctionLayer(options) {
        const { envId, functionName, layers } = options;
        return this.scfService.request('UpdateFunctionConfiguration', {
            Layers: layers,
            Namespace: envId,
            FunctionName: functionName
        });
    }
    // 下载文件层 ZIP 文件
    async downloadLayer(options) {
        const { name, version, destPath } = options;
        const res = await this.scfService.request('GetLayerVersion', {
            LayerName: name,
            LayerVersion: version
        });
        const url = res === null || res === void 0 ? void 0 : res.Location;
        const zipPath = path_1.default.join(destPath, `${name}-${version}.zip`);
        if ((0, utils_1.checkFullAccess)(zipPath)) {
            throw new error_1.CloudBaseError(`文件已存在：${zipPath}`);
        }
        // 下载文件
        return (0, utils_1.downloadAndExtractRemoteZip)(url, destPath);
    }
    // 创建文件层版本
    async createLayer(options) {
        const { env } = this.getFunctionConfig();
        const { contentPath = '', name, base64Content = '', runtimes = [], description = '', licenseInfo = '' } = options;
        let base64;
        if (base64Content) {
            base64 = base64Content;
        }
        else if ((0, utils_1.isDirectory)(contentPath)) {
            // 压缩文件夹
            const dirName = path_1.default.parse(contentPath).name;
            const dest = path_1.default.join(process.cwd(), `temp-${dirName}.zip`);
            // ZIP 文件存在，删除 ZIP 文件
            if ((0, utils_1.checkFullAccess)(dest)) {
                (0, utils_1.delSync)(dest);
            }
            await (0, utils_1.compressToZip)({
                dirPath: contentPath,
                outputPath: dest
            });
            // 转换成 base64
            const fileBuffer = await fs_1.default.promises.readFile(dest);
            base64 = fileBuffer.toString('base64');
            (0, utils_1.delSync)(dest);
        }
        else {
            const fileType = path_1.default.extname(contentPath);
            if (fileType !== '.zip') {
                throw new error_1.CloudBaseError('文件类型不正确，目前只支持 ZIP 文件！');
            }
            const fileBuffer = await fs_1.default.promises.readFile(contentPath);
            base64 = fileBuffer.toString('base64');
        }
        return this.scfService.request('PublishLayerVersion', {
            LayerName: name,
            CompatibleRuntimes: runtimes,
            Content: {
                // 最大支持 20M
                ZipFile: base64
            },
            Description: description,
            LicenseInfo: licenseInfo,
            Src: `TCB_${env}`
        });
    }
    // 删除文件层版本
    async deleteLayerVersion(options) {
        const { name, version } = options;
        return this.scfService.request('DeleteLayerVersion', {
            LayerName: name,
            LayerVersion: version
        });
    }
    // 获取层版本列表
    async listLayerVersions(options) {
        const { name, runtimes } = options;
        let param = {
            LayerName: name
        };
        if (runtimes === null || runtimes === void 0 ? void 0 : runtimes.length) {
            param.CompatibleRuntime = runtimes;
        }
        return this.scfService.request('ListLayerVersions', param);
    }
    // 获取文件层列表
    async listLayers(options) {
        const { env } = this.getFunctionConfig();
        const { limit = 20, offset = 0, runtime, searchKey } = options;
        let param = {
            Limit: limit,
            Offset: offset,
            SearchKey: searchKey,
            // SearchSrc: `TCB_${env}`
        };
        if (runtime) {
            param.CompatibleRuntime = runtime;
        }
        return this.scfService.request('ListLayers', param);
    }
    // 获取层版本详细信息
    async getLayerVersion(options) {
        const { name, version } = options;
        return this.scfService.request('GetLayerVersion', {
            LayerName: name,
            LayerVersion: version
        });
    }
    // 检查函数状态，部分操作在函数更新中时不可进行
    async waitFunctionActive(funcName, codeSecret) {
        let ticker;
        let timer;
        let resolved;
        return new Promise((resolve, reject) => {
            // 超时时间 5 分钟
            timer = setTimeout(() => {
                clearInterval(ticker);
                if (!resolved) {
                    reject(new error_1.CloudBaseError('函数状态异常，检查超时'));
                }
            }, 300000);
            ticker = setInterval(async () => {
                try {
                    const { Status, StatusDesc, StatusReasons, RequestId } = await this.getFunctionDetail(funcName, codeSecret);
                    // 更新中
                    if (Status === constant_1.SCF_STATUS.CREATING || Status === constant_1.SCF_STATUS.UPDATING)
                        return;
                    // 创建失败
                    if (Status === constant_1.SCF_STATUS.CREATE_FAILED) {
                        const errorDetails = (StatusReasons === null || StatusReasons === void 0 ? void 0 : StatusReasons.map(item => `[${item.ErrorCode}] ${item.ErrorMessage}`).join('\n')) || '';
                        const errorMsg = `云函数创建失败${StatusDesc ? `\n状态描述: ${StatusDesc}` : ''}${errorDetails ? `\n失败信息: ${errorDetails}` : ''}`;
                        throw new error_1.CloudBaseError(errorMsg, { requestId: RequestId });
                    }
                    // 函数状态正常
                    clearInterval(ticker);
                    clearTimeout(timer);
                    resolve();
                }
                catch (e) {
                    clearInterval(ticker);
                    clearTimeout(timer);
                    reject(e);
                }
                resolved = true;
            }, 1000);
        });
    }
    /**
     * 设置预置并发
     * @private
     * @param {IProvisionedConcurrencyConfig} concurrencyConfig
     * @returns
     * @memberof FunctionService
     */
    async setProvisionedConcurrencyConfig(concurrencyConfig) {
        const { namespace } = this.getFunctionConfig();
        const { functionName: FunctionName, qualifier: Qualifier, versionProvisionedConcurrencyNum: VersionProvisionedConcurrencyNum } = concurrencyConfig;
        return this.scfService.request('PutProvisionedConcurrencyConfig', {
            FunctionName,
            Qualifier,
            VersionProvisionedConcurrencyNum,
            Namespace: namespace
        });
    }
    /**
     * 获取函数预置并发详情
     * @private
     * @param {IGetProvisionedConcurrencyConfig} concurrencyConfig
     * @returns {Promise<IGetProvisionedConcurrencyRes>}
     * @memberof FunctionService
     */
    async getProvisionedConcurrencyConfig(concurrencyConfig) {
        const { namespace } = this.getFunctionConfig();
        const { functionName: FunctionName, qualifier: Qualifier } = concurrencyConfig;
        return this.scfService.request('GetProvisionedConcurrencyConfig', {
            FunctionName,
            Qualifier,
            Namespace: namespace
        });
    }
    /**
     * 删除预置并发
     * @private
     * @param {IGetProvisionedConcurrencyConfig} concurrencyConfig
     * @returns {Promise<IResponseInfo>}
     * @memberof FunctionService
     */
    async deleteProvisionedConcurrencyConfig(concurrencyConfig) {
        const { namespace } = this.getFunctionConfig();
        const { functionName: FunctionName, qualifier: Qualifier } = concurrencyConfig;
        return this.scfService.request('DeleteProvisionedConcurrencyConfig', {
            FunctionName,
            Qualifier,
            Namespace: namespace
        });
    }
    /**
     * 发布新版本
     * @param {IPublishVersionParams} publishParams
     * @returns {Promise<IPublishVersionRes>}
     * @memberof FunctionService
     */
    async publishVersion(publishParams) {
        const { namespace } = this.getFunctionConfig();
        const { functionName: FunctionName, description: Description } = publishParams;
        return this.scfService.request('PublishVersion', {
            FunctionName,
            Description,
            Namespace: namespace
        });
    }
    /**
     * 查询函数版本详情
     * @param {IListFunctionVersionParams} listVersionParams
     * @returns {Promise<IFunctionVersionsRes>}
     * @memberof FunctionService
     */
    async listVersionByFunction(listVersionParams) {
        const { namespace } = this.getFunctionConfig();
        const { functionName: FunctionName, offset: Offset, limit: Limit, order: Order, orderBy: OrderBy } = listVersionParams;
        return this.scfService.request('ListVersionByFunction', {
            FunctionName,
            Namespace: namespace,
            Offset,
            Limit,
            Order,
            OrderBy
        });
    }
    /**
     *
     * @param {IUpdateFunctionAliasConfig} updateVersionConfigParams
     * @returns {Promise<IResponseInfo>}
     * @memberof FunctionService
     */
    async updateFunctionAliasConfig(updateVersionConfigParams) {
        const { namespace } = this.getFunctionConfig();
        const { functionName: FunctionName, name: Name, functionVersion: FunctionVersion, routingConfig: RoutingConfig, description: Description } = updateVersionConfigParams;
        return this.scfService.request('UpdateAlias', {
            FunctionName,
            Name,
            Namespace: namespace,
            FunctionVersion,
            RoutingConfig,
            Description
        });
    }
    /**
     * 查询函数别名详情
     * @param {IGetFunctionAlias} params
     * @returns {Promise<IGetFunctionAliasRes>}
     * @memberof FunctionService
     */
    async getFunctionAlias(params) {
        const { namespace } = this.getFunctionConfig();
        const { functionName: FunctionName, name: Name } = params;
        return this.scfService.request('GetAlias', {
            FunctionName,
            Name,
            Namespace: namespace
        });
    }
    /**
     * 通过scf COS 上传方式（通过 GetTempCosInfo + COS SDK 上传）
     * 返回 TempCosObjectName 用于创建/更新函数
     */
    async uploadFunctionZipToCosLegacy(options, installDependency) {
        const { func, functionPath, functionRootPath } = options;
        const { env } = this.getFunctionConfig();
        const { CloudAppId } = await this.userService.getTcbAccountInfo();
        const objectPath = `${CloudAppId}/${env}/${func.name}.zip`;
        // 1. 生成存放函数包的临时 Cos 目录
        const { Date: cosDate, Sign } = await this.scfService.request('GetTempCosInfo', {
            ObjectPath: `${objectPath}`
        });
        // 2. 本地压缩
        const codeType = packer_1.CodeType.File;
        // 云端安装依赖，自动忽略 node_modules 目录
        const ignore = installDependency === 'TRUE'
            ? ['node_modules/**/*', 'node_modules', ...(func.ignore || [])]
            : [...(func.ignore || [])];
        const packer = new packer_1.FunctionPacker({
            ignore,
            codeType,
            functionPath,
            name: func.name,
            root: functionRootPath
        });
        const zipFilePath = await packer.compressFiles();
        // 3. 初始化 cos 并上传
        const tempCosObjectName = `/${cosDate}/${objectPath}`;
        const uploadParams = {
            Bucket: `shtempcos-${constant_1.SCF_TEMP_COS.APPID}`,
            Key: tempCosObjectName,
            Region: constant_1.SCF_TEMP_COS.REGION,
            FilePath: zipFilePath,
        };
        const cos = new cos_nodejs_sdk_v5_1.default({
            getAuthorization: function (options, callback) {
                // 注入上一步获取的临时密钥
                callback(Sign);
            }
        });
        return new Promise((resolve, reject) => {
            cos.sliceUploadFile(uploadParams, async (err, data) => {
                // 清理临时文件
                await packer.clean();
                if (err) {
                    reject(new error_1.CloudBaseError(`COS 上传失败: ${err.message || err}`));
                }
                else {
                    resolve(data);
                }
            });
        });
    }
    /**
     * 新的 COS 上传方式（通过 DescribeBuildServiceCosInfo + PUT 上传）
     * 返回 CosTimestamp 用于创建/更新函数
     */
    async uploadFunctionZipToCos(options, installDependency) {
        const { func, functionPath, functionRootPath } = options;
        const { env } = this.getFunctionConfig();
        // 1. 生成存放函数包的临时 Cos 目录
        const { UploadUrl, UnixTimestamp, UploadHeaders } = await this.tcbService.request('DescribeBuildServiceCosInfo', {
            EnvId: env,
            ServiceName: func.name,
            Business: 'scf',
            Suffix: '.zip'
        });
        // 2. 本地压缩
        const codeType = packer_1.CodeType.File;
        // 云端安装依赖，自动忽略 node_modules 目录
        const ignore = installDependency === 'TRUE'
            ? ['node_modules/**/*', 'node_modules', ...(func.ignore || [])]
            : [...(func.ignore || [])];
        const packer = new packer_1.FunctionPacker({
            ignore,
            codeType,
            functionPath,
            name: func.name,
            root: functionRootPath
        });
        const zipFilePath = await packer.compressFiles();
        // 3. 通过 UploadUrl 直接上传
        const fileBuffer = fs_1.default.readFileSync(zipFilePath);
        // 构建请求头
        const headers = {
            'Content-Type': 'application/zip'
        };
        if (UploadHeaders && UploadHeaders.length > 0) {
            UploadHeaders.forEach(item => {
                headers[item.Key] = item.Value;
            });
        }
        const response = await fetch(UploadUrl, {
            method: 'PUT',
            body: fileBuffer,
            headers
        });
        if (!response.ok) {
            throw new error_1.CloudBaseError(`上传失败: ${response.status} ${response.statusText}`);
        }
        // 清理临时文件
        await packer.clean();
        return {
            UnixTimestamp
        };
    }
    async createAccessPath(name, path) {
        const access = this.environment.getAccessService();
        try {
            await access.createAccess({
                name,
                path
            });
        }
        catch (e) {
            // 当 Path 存在时，校验 Path 绑定的函数是不是当前函数
            if (e.code === 'InvalidParameter.APICreated') {
                const { APISet } = await access.getAccessList({
                    name
                });
                if ((APISet === null || APISet === void 0 ? void 0 : APISet[0].Name) !== name || (APISet === null || APISet === void 0 ? void 0 : APISet[0].Type) !== 1) {
                    throw e;
                }
            }
            else {
                throw e;
            }
        }
    }
    async getCodeParams(options, installDependency) {
        const { func, functionPath, functionRootPath, base64Code, deployMode } = options;
        // 直接传入 base64Code 的情况，校验大小
        // ZipFile 上传大小上限 1.5MB，base64 编码后长度约为原始大小的 4/3
        const MAX_ZIP_SIZE = 1.5 * 1024 * 1024; // 1.5MB
        const MAX_BASE64_LENGTH = Math.floor(MAX_ZIP_SIZE * 4 / 3); // ≈ 2097152
        if ((base64Code === null || base64Code === void 0 ? void 0 : base64Code.length) > MAX_BASE64_LENGTH) {
            throw new error_1.CloudBaseError('ZipFile 上传不能大于 1.5MB，请使用 COS 上传方式');
        }
        if (base64Code === null || base64Code === void 0 ? void 0 : base64Code.length) {
            return {
                ZipFile: base64Code
            };
        }
        const codeType = func.runtime === 'Java8' ? packer_1.CodeType.JavaFile : packer_1.CodeType.File;
        // 云端安装依赖，自动忽略 node_modules 目录
        const ignore = installDependency === 'TRUE'
            ? ['node_modules/**/*', 'node_modules', ...(func.ignore || [])]
            : [...(func.ignore || [])];
        const packer = new packer_1.FunctionPacker({
            ignore,
            codeType,
            functionPath,
            name: func.name,
            root: functionRootPath
        });
        await packer.build();
        // 指定 zip 上传方式：走 ZipFile base64 上传
        if (deployMode === 'zip') {
            // 判断是否超过 ZipFile 上传大小限制（1.5MB）
            const reachMax = await packer.isReachMaxSize();
            if (reachMax) {
                throw new error_1.CloudBaseError('ZipFile 上传不能大于 1.5MB，请使用 COS 上传方式（deployMode: "cos"）');
            }
            const base64 = await packer.getBase64Code();
            if (!(base64 === null || base64 === void 0 ? void 0 : base64.length)) {
                throw new error_1.CloudBaseError('文件不能为空');
            }
            console.log(`[${func.name}] 部署方式: ZIP base64 上传`);
            return {
                ZipFile: base64
            };
        }
        // 默认走 COS 上传
        console.log(`[${func.name}] 部署方式: COS 上传`);
        const legacyResult = await this.uploadFunctionZipToCosLegacy(options, installDependency);
        return {
            CosBucketRegion: constant_1.SCF_TEMP_COS.REGION,
            TempCosObjectName: `/${legacyResult.Key}`
        };
    }
    // 获取 COS 临时信息
    async getTempCosInfo(name) {
        const { env, appId } = await this.getFunctionConfig();
        /**
         * Response:
         * Date: "2020-03-18"
         * RequestId: "91876f56-7cd3-42bb-bc32-b74df5d0516e"
         * Sign: "Gc8QvXD50dx7yBfsl2yEYFwIL45hPTEyNTM2NjU4MTkm
         */
        return this.scfService.request('GetTempCosInfo', {
            ObjectPath: `${appId}/${env}/${name}.zip"`
        });
    }
    async retryCreateTrigger(name, triggers, count = 0) {
        try {
            const res = await this.createFunctionTriggers(name, triggers);
            return res;
        }
        catch (e) {
            if (count < 3) {
                await (0, utils_1.sleep)(500);
                const res = await this.retryCreateTrigger(name, triggers, count + 1);
                return res;
            }
            else {
                throw e;
            }
        }
    }
    /**
     * 获取函数配置信息
     * @private
     * @returns
     * @memberof FunctionService
     */
    getFunctionConfig() {
        var _a, _b, _c, _d;
        const envConfig = this.environment.lazyEnvironmentConfig;
        // Functions 可能为空
        const namespace = ((_b = (_a = envConfig.Functions) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.Namespace) || '';
        const appId = (_d = (_c = envConfig.Storages) === null || _c === void 0 ? void 0 : _c[0]) === null || _d === void 0 ? void 0 : _d.AppId;
        const { proxy } = this.environment.cloudBaseContext;
        return {
            proxy,
            appId,
            namespace,
            env: envConfig.EnvId
        };
    }
    /**
     * 获取日志cls配置信息
     */
    getClsServiceConfig() {
        var _a, _b;
        const currentEnv = this.environment.lazyEnvironmentConfig;
        const customLogServices = (_a = currentEnv === null || currentEnv === void 0 ? void 0 : currentEnv.CustomLogServices) === null || _a === void 0 ? void 0 : _a[0];
        const logServices = (_b = currentEnv === null || currentEnv === void 0 ? void 0 : currentEnv.LogServices) === null || _b === void 0 ? void 0 : _b[0];
        return {
            TopicId: (customLogServices === null || customLogServices === void 0 ? void 0 : customLogServices.ClsTopicId) || (logServices === null || logServices === void 0 ? void 0 : logServices.TopicId),
            LogsetId: (customLogServices === null || customLogServices === void 0 ? void 0 : customLogServices.ClsLogsetId) || (logServices === null || logServices === void 0 ? void 0 : logServices.LogsetId)
        };
    }
    /**
     * 获取 vpc 信息
     * @returns
     */
    async getVpcs() {
        const { VpcSet } = await this.vpcService.request('DescribeVpcs');
        return VpcSet;
    }
    /**
     * 获取子网
     * @param {string} vpcId
     * @returns
     */
    async getSubnets(vpcId) {
        const { SubnetSet } = await this.vpcService.request('DescribeSubnets', {
            Filters: [
                {
                    Name: 'vpc-id',
                    Values: [vpcId]
                }
            ]
        });
        return SubnetSet;
    }
}
exports.FunctionService = FunctionService;
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "updateFunctionIncrementalCode", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "createFunction", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "getFunctionList", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "listFunctions", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "listAllFunctions", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "deleteFunction", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "getFunctionDetail", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "batchGetFunctionsDetail", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "getFunctionLogs", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "getFunctionLogsV2", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "getFunctionLogDetail", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "getCompleteFunctionLogs", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "updateFunctionConfig", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "updateFunctionCode", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "invokeFunction", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "batchInvokeFunctions", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "copyFunction", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "createFunctionTriggers", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "deleteFunctionTrigger", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "getFunctionDownloadUrl", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "attachLayer", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "unAttachLayer", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "updateFunctionLayer", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "downloadLayer", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "createLayer", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "deleteLayerVersion", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "listLayerVersions", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "listLayers", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "getLayerVersion", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "setProvisionedConcurrencyConfig", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "getProvisionedConcurrencyConfig", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "deleteProvisionedConcurrencyConfig", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "publishVersion", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "listVersionByFunction", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "updateFunctionAliasConfig", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "getFunctionAlias", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "uploadFunctionZipToCosLegacy", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "uploadFunctionZipToCos", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "createAccessPath", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "getCodeParams", null);
__decorate([
    (0, utils_1.preLazy)()
], FunctionService.prototype, "getTempCosInfo", null);
