{"version":3,"sources":["../../../observability/dist/chunk-NFEGQTCC.mjs","../../../../node_modules/.pnpm/@arizeai+openinference-semantic-conventions@2.1.7/node_modules/@arizeai/openinference-semantic-conventions/src/trace/SemanticConventions.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/platform/node/globalThis.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/version.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/internal/semver.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/internal/global-utils.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag/ComponentLogger.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag/types.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/diag/internal/logLevelLogger.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/diag.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/context/context.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/context/NoopContextManager.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/context.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/trace_flags.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/invalid-span-constants.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/NonRecordingSpan.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/context-utils.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/spancontext-utils.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/NoopTracer.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/ProxyTracer.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/NoopTracerProvider.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/ProxyTracerProvider.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace/status.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/context-api.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/api/trace.ts","../../../../node_modules/.pnpm/@opentelemetry+api@1.9.0/node_modules/@opentelemetry/api/src/trace-api.ts","../../../observability/src/core/constants.ts","../../../observability/src/core/attributes.ts","../../../observability/src/core/tracerProvider.ts","../../../observability/src/core/spanWrapper.ts","../../../observability/src/index.ts","../../../observability/src/langchain/CallbackHandler.ts"],"sourcesContent":["var __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __esm = (fn, res) => function __init() {\n  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n};\nvar __export = (target, all) => {\n  for (var name in all)\n    __defProp(target, name, { get: all[name], enumerable: true });\n};\nvar __copyProps = (to, from, except, desc) => {\n  if (from && typeof from === \"object\" || typeof from === \"function\") {\n    for (let key of __getOwnPropNames(from))\n      if (!__hasOwnProp.call(to, key) && key !== except)\n        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n  }\n  return to;\n};\nvar __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\nexport {\n  __esm,\n  __export,\n  __toCommonJS\n};\n//# sourceMappingURL=chunk-NFEGQTCC.mjs.map","/**\n * Semantic conventions for OpenInference tracing\n */\n\nexport const SemanticAttributePrefixes = {\n  input: \"input\",\n  output: \"output\",\n  llm: \"llm\",\n  retrieval: \"retrieval\",\n  reranker: \"reranker\",\n  messages: \"messages\",\n  message: \"message\",\n  document: \"document\",\n  embedding: \"embedding\",\n  tool: \"tool\",\n  tool_call: \"tool_call\",\n  metadata: \"metadata\",\n  tag: \"tag\",\n  session: \"session\",\n  user: \"user\",\n  openinference: \"openinference\",\n  message_content: \"message_content\",\n  image: \"image\",\n  audio: \"audio\",\n  prompt: \"prompt\",\n  agent: \"agent\",\n  graph: \"graph\",\n} as const;\n\nexport const LLMAttributePostfixes = {\n  provider: \"provider\",\n  system: \"system\",\n  model_name: \"model_name\",\n  token_count: \"token_count\",\n  input_messages: \"input_messages\",\n  output_messages: \"output_messages\",\n  invocation_parameters: \"invocation_parameters\",\n  prompts: \"prompts\",\n  prompt_template: \"prompt_template\",\n  function_call: \"function_call\",\n  tools: \"tools\",\n  cost: \"cost\",\n} as const;\n\nexport const LLMPromptTemplateAttributePostfixes = {\n  variables: \"variables\",\n  template: \"template\",\n} as const;\n\nexport const RetrievalAttributePostfixes = {\n  documents: \"documents\",\n} as const;\n\nexport const RerankerAttributePostfixes = {\n  input_documents: \"input_documents\",\n  output_documents: \"output_documents\",\n  query: \"query\",\n  model_name: \"model_name\",\n  top_k: \"top_k\",\n} as const;\n\nexport const EmbeddingAttributePostfixes = {\n  embeddings: \"embeddings\",\n  text: \"text\",\n  model_name: \"model_name\",\n  vector: \"vector\",\n} as const;\n\nexport const ToolAttributePostfixes = {\n  name: \"name\",\n  description: \"description\",\n  parameters: \"parameters\",\n  json_schema: \"json_schema\",\n} as const;\n\nexport const MessageAttributePostfixes = {\n  role: \"role\",\n  content: \"content\",\n  contents: \"contents\",\n  name: \"name\",\n  function_call_name: \"function_call_name\",\n  function_call_arguments_json: \"function_call_arguments_json\",\n  tool_calls: \"tool_calls\",\n  tool_call_id: \"tool_call_id\",\n} as const;\n\nexport const MessageContentsAttributePostfixes = {\n  type: \"type\",\n  text: \"text\",\n  image: \"image\",\n} as const;\n\nexport const ImageAttributesPostfixes = {\n  url: \"url\",\n} as const;\n\nexport const ToolCallAttributePostfixes = {\n  function_name: \"function.name\",\n  function_arguments_json: \"function.arguments\",\n  id: \"id\",\n} as const;\n\nexport const DocumentAttributePostfixes = {\n  id: \"id\",\n  content: \"content\",\n  score: \"score\",\n  metadata: \"metadata\",\n} as const;\n\nexport const TagAttributePostfixes = {\n  tags: \"tags\",\n} as const;\n\nexport const SessionAttributePostfixes = {\n  id: \"id\",\n} as const;\n\nexport const UserAttributePostfixes = {\n  id: \"id\",\n} as const;\n\nexport const AudioAttributesPostfixes = {\n  url: \"url\",\n  mime_type: \"mime_type\",\n  transcript: \"transcript\",\n} as const;\n\nexport const PromptAttributePostfixes = {\n  vendor: \"vendor\",\n  id: \"id\",\n  url: \"url\",\n} as const;\n\nexport const AgentPostfixes = {\n  name: \"name\",\n} as const;\n\nexport const GraphPostfixes = {\n  node_id: \"node.id\",\n  node_name: \"node.name\",\n  node_parent_id: \"node.parent_id\",\n} as const;\n/**\n * The input to any span\n */\nexport const INPUT_VALUE = `${SemanticAttributePrefixes.input}.value` as const;\nexport const INPUT_MIME_TYPE =\n  `${SemanticAttributePrefixes.input}.mime_type` as const;\n/**\n * The output of any span\n */\nexport const OUTPUT_VALUE =\n  `${SemanticAttributePrefixes.output}.value` as const;\nexport const OUTPUT_MIME_TYPE =\n  `${SemanticAttributePrefixes.output}.mime_type` as const;\n/**\n * The messages sent to the LLM for completions\n * Typically seen in OpenAI chat completions\n * @see https://beta.openai.com/docs/api-reference/completions/create\n */\nexport const LLM_INPUT_MESSAGES =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.input_messages}` as const;\n\n/**\n * The prompts sent to the LLM for completions\n * Typically seen in OpenAI legacy completions\n * @see https://beta.openai.com/docs/api-reference/completions/create\n */\nexport const LLM_PROMPTS =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.prompts}` as const;\n\n/**\n * The JSON representation of the parameters passed to the LLM\n */\nexport const LLM_INVOCATION_PARAMETERS =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.invocation_parameters}` as const;\n\n/**\n * The messages received from the LLM for completions\n * Typically seen in OpenAI chat completions\n * @see https://platform.openai.com/docs/api-reference/chat/object#choices-message\n */\nexport const LLM_OUTPUT_MESSAGES =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.output_messages}` as const;\n\n/**\n * The name of the LLM model\n */\nexport const LLM_MODEL_NAME =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.model_name}` as const;\n\n/**\n * The provider of the inferences. E.g. the cloud provider\n */\nexport const LLM_PROVIDER =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.provider}` as const;\n\n/**\n * The AI product as identified by the client or server\n */\nexport const LLM_SYSTEM =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.system}` as const;\n\n/** Token count for the completion by the llm (in tokens) */\nexport const LLM_TOKEN_COUNT_COMPLETION =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion` as const;\n\n/** Token count for the reasoning steps in the completion (in tokens) */\nexport const LLM_TOKEN_COUNT_COMPLETION_DETAILS_REASONING =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion_details.reasoning` as const;\n\n/** Token count for audio input generated by the model (in tokens) */\nexport const LLM_TOKEN_COUNT_COMPLETION_DETAILS_AUDIO =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion_details.audio` as const;\n\n/** Token count for the prompt to the llm (in tokens) */\nexport const LLM_TOKEN_COUNT_PROMPT =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt` as const;\n\n/** Token count for the tokens written to cache (in tokens) */\nexport const LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_WRITE =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.cache_write` as const;\n\n/** Token count for the tokens retrieved from cache (in tokens) */\nexport const LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_READ =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.cache_read` as const;\n\n/** Token count for the input tokens in the prompt that were cached (in tokens) */\nexport const LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_INPUT =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.cache_input` as const;\n\n/** Token count for audio input presented in the prompt (in tokens) */\nexport const LLM_TOKEN_COUNT_PROMPT_DETAILS_AUDIO =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details.audio` as const;\n\n/** Token count for the entire transaction with the llm (in tokens) */\nexport const LLM_TOKEN_COUNT_TOTAL =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.total` as const;\n\n/**\n * Key prefix for additional prompt token count details. Each detail should be a separate attribute\n * with this prefix, e.g. llm.token_count.prompt_details.reasoning, llm.token_count.prompt_details.audio.\n * All values should be in tokens (integer count of tokens).\n */\nexport const LLM_TOKEN_COUNT_PROMPT_DETAILS =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.prompt_details` as const;\n\n/**\n * Key prefix for additional completion token count details. Each detail should be a separate attribute\n * with this prefix, e.g. llm.token_count.completion_details.reasoning, llm.token_count.completion_details.audio.\n * All values should be in tokens (integer count of tokens).\n */\nexport const LLM_TOKEN_COUNT_COMPLETION_DETAILS =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.token_count}.completion_details` as const;\n\n/**\n * Key prefix for cost information. When these keys are transformed into a JSON-like structure, it would look like:\n * {\n *     \"prompt\": 0.0021,  # Cost in USD\n *     \"completion\": 0.0045,  # Cost in USD\n *     \"total\": 0.0066,  # Cost in USD\n *     \"completion_details\": {\n *         \"output\": 0.0009,  # Cost in USD\n *         \"reasoning\": 0.0024,    # Cost in USD (e.g., 80 tokens * $0.03/1K tokens)\n *         \"audio\": 0.0012  # Cost in USD (e.g., 40 tokens * $0.03/1K tokens)\n *     },\n *     \"prompt_details\": {\n *         \"input\": 0.0003,  # Cost in USD\n *         \"cache_write\": 0.0006,  # Cost in USD (e.g., 20 tokens * $0.03/1K tokens)\n *         \"cache_read\": 0.0003,   # Cost in USD (e.g., 10 tokens * $0.03/1K tokens)\n *         \"cache_input\": 0.0006,  # Cost in USD (e.g., 20 tokens * $0.03/1K tokens)\n *         \"audio\": 0.0003   # Cost in USD (e.g., 10 tokens * $0.03/1K tokens)\n *     }\n * }\n * Note: This is a key prefix - individual attributes are stored as separate span attributes with this prefix,\n * e.g. llm.cost.prompt, llm.cost.completion_details.reasoning, etc. The JSON structure shown above represents\n * how these separate attributes can be conceptually organized.\n * All monetary values are in USD with floating point precision.\n */\nexport const LLM_COST =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}` as const;\n\n/** Cost of the prompt tokens in USD */\nexport const LLM_COST_PROMPT =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt` as const;\n\n/** Cost of the completion tokens in USD */\nexport const LLM_COST_COMPLETION =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion` as const;\n\n/** Total cost of the LLM call in USD (prompt + completion) */\nexport const LLM_COST_TOTAL =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.total` as const;\n\n/** Total cost of input tokens in USD. This represents the cost of tokens that were used as input\n * to the model, which may be different from the prompt cost if there are additional processing steps. */\nexport const LLM_COST_INPUT =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.input` as const;\n\n/** Total cost of output tokens in USD. This represents the cost of tokens that were generated as output\n * by the model, which may be different from the completion cost if there are additional processing steps. */\nexport const LLM_COST_OUTPUT =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion_details.output` as const;\n\n/** Cost of reasoning steps in the completion in USD */\nexport const LLM_COST_COMPLETION_DETAILS_REASONING =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion_details.reasoning` as const;\n\n/** Cost of audio tokens in the completion in USD */\nexport const LLM_COST_COMPLETION_DETAILS_AUDIO =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.completion_details.audio` as const;\n\n/** Cost of prompt tokens written to cache in USD */\nexport const LLM_COST_PROMPT_DETAILS_CACHE_WRITE =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.cache_write` as const;\n\n/** Cost of prompt tokens read from cache in USD */\nexport const LLM_COST_PROMPT_DETAILS_CACHE_READ =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.cache_read` as const;\n\n/** Cost of input tokens in the prompt that were cached in USD */\nexport const LLM_COST_PROMPT_DETAILS_CACHE_INPUT =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.cache_input` as const;\n\n/** Cost of audio tokens in the prompt in USD */\nexport const LLM_COST_PROMPT_DETAILS_AUDIO =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.cost}.prompt_details.audio` as const;\n\n/**\n * The role that the LLM assumes the message is from\n * during the LLM invocation\n */\nexport const MESSAGE_ROLE =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.role}` as const;\n\n/**\n * The name of the message. This is only used for role 'function' where the name\n * of the function is captured in the name field and the parameters are captured in the\n * content.\n */\nexport const MESSAGE_NAME =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.name}` as const;\n\n/**\n * The tool calls generated by the model, such as function calls.\n */\nexport const MESSAGE_TOOL_CALLS =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.tool_calls}` as const;\n\n/**\n * The id of the tool call on a \"tool\" role message\n */\nexport const MESSAGE_TOOL_CALL_ID =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.tool_call_id}` as const;\n\n/**\n * tool_call.function.name\n */\nexport const TOOL_CALL_FUNCTION_NAME =\n  `${SemanticAttributePrefixes.tool_call}.${ToolCallAttributePostfixes.function_name}` as const;\n\n/**\n * tool_call.function.argument (JSON string)\n */\nexport const TOOL_CALL_FUNCTION_ARGUMENTS_JSON =\n  `${SemanticAttributePrefixes.tool_call}.${ToolCallAttributePostfixes.function_arguments_json}` as const;\n\n/**\n * The id of the tool call\n */\nexport const TOOL_CALL_ID =\n  `${SemanticAttributePrefixes.tool_call}.${ToolCallAttributePostfixes.id}` as const;\n\n/**\n * The LLM function call function name\n */\nexport const MESSAGE_FUNCTION_CALL_NAME =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.function_call_name}` as const;\n\n/**\n * The LLM function call function arguments in a json string\n */\nexport const MESSAGE_FUNCTION_CALL_ARGUMENTS_JSON =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.function_call_arguments_json}` as const;\n/**\n * The content of the message sent to the LLM\n */\nexport const MESSAGE_CONTENT =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.content}` as const;\n/**\n * The array of contents for the message sent to the LLM. Each element of the array is\n * an `message_content` object.\n */\nexport const MESSAGE_CONTENTS =\n  `${SemanticAttributePrefixes.message}.${MessageAttributePostfixes.contents}` as const;\n/**\n * The type of content sent to the LLM\n */\nexport const MESSAGE_CONTENT_TYPE =\n  `${SemanticAttributePrefixes.message_content}.${MessageContentsAttributePostfixes.type}` as const;\n/**\n * The text content of the message sent to the LLM\n */\nexport const MESSAGE_CONTENT_TEXT =\n  `${SemanticAttributePrefixes.message_content}.${MessageContentsAttributePostfixes.text}` as const;\n/**\n * The image content of the message sent to the LLM\n */\nexport const MESSAGE_CONTENT_IMAGE =\n  `${SemanticAttributePrefixes.message_content}.${MessageContentsAttributePostfixes.image}` as const;\n/**\n * The http or base64 link to the image\n */\nexport const IMAGE_URL =\n  `${SemanticAttributePrefixes.image}.${ImageAttributesPostfixes.url}` as const;\n\nexport const DOCUMENT_ID =\n  `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.id}` as const;\n\nexport const DOCUMENT_CONTENT =\n  `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.content}` as const;\n\nexport const DOCUMENT_SCORE =\n  `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.score}` as const;\n\nexport const DOCUMENT_METADATA =\n  `${SemanticAttributePrefixes.document}.${DocumentAttributePostfixes.metadata}` as const;\n\n/**\n * The text that was embedded to create the vector\n */\nexport const EMBEDDING_TEXT =\n  `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.text}` as const;\n\n/**\n * The name of the model that was used to create the vector\n */\nexport const EMBEDDING_MODEL_NAME =\n  `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.model_name}` as const;\n\n/**\n * The embedding vector. Typically a high dimensional vector of floats or ints\n */\nexport const EMBEDDING_VECTOR =\n  `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.vector}` as const;\n\n/**\n * The embedding list root\n */\nexport const EMBEDDING_EMBEDDINGS =\n  `${SemanticAttributePrefixes.embedding}.${EmbeddingAttributePostfixes.embeddings}` as const;\n\n/**\n * The retrieval documents list root\n */\nexport const RETRIEVAL_DOCUMENTS =\n  `${SemanticAttributePrefixes.retrieval}.${RetrievalAttributePostfixes.documents}` as const;\n\nconst PROMPT_TEMPLATE_PREFIX =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.prompt_template}` as const;\n\n/**\n * The JSON representation of the variables used in the prompt template\n */\nexport const PROMPT_TEMPLATE_VARIABLES =\n  `${PROMPT_TEMPLATE_PREFIX}.variables` as const;\n\n/**\n * A prompt template\n */\nexport const PROMPT_TEMPLATE_TEMPLATE =\n  `${PROMPT_TEMPLATE_PREFIX}.template` as const;\n\n/**\n * The JSON representation of a function call of an LLM\n */\nexport const LLM_FUNCTION_CALL =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.function_call}` as const;\n\n/**\n * List of tools that are advertised to the LLM to be able to call\n */\nexport const LLM_TOOLS =\n  `${SemanticAttributePrefixes.llm}.${LLMAttributePostfixes.tools}` as const;\n\n/**\n * The name of a tool\n */\nexport const TOOL_NAME =\n  `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.name}` as const;\n\n/**\n * The description of a tool\n */\nexport const TOOL_DESCRIPTION =\n  `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.description}` as const;\n\n/**\n * The parameters of the tool represented as a JSON string\n */\nexport const TOOL_PARAMETERS =\n  `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.parameters}` as const;\n\n/**\n * The json schema of a tool input, It is RECOMMENDED that this be in the\n * OpenAI tool calling format: https://platform.openai.com/docs/assistants/tools\n */\nexport const TOOL_JSON_SCHEMA =\n  `${SemanticAttributePrefixes.tool}.${ToolAttributePostfixes.json_schema}` as const;\n\n/**\n * The session id of a trace. Used to correlate spans in a single session.\n */\nexport const SESSION_ID =\n  `${SemanticAttributePrefixes.session}.${SessionAttributePostfixes.id}` as const;\n\n/**\n * The user id of a trace. Used to correlate spans for a single user.\n */\nexport const USER_ID =\n  `${SemanticAttributePrefixes.user}.${UserAttributePostfixes.id}` as const;\n\n/**\n * The documents used as input to the reranker\n */\nexport const RERANKER_INPUT_DOCUMENTS =\n  `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.input_documents}` as const;\n\n/**\n * The documents output by the reranker\n */\nexport const RERANKER_OUTPUT_DOCUMENTS =\n  `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.output_documents}` as const;\n\n/**\n * The query string for the reranker\n */\nexport const RERANKER_QUERY =\n  `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.query}` as const;\n\n/**\n * The model name for the reranker\n */\nexport const RERANKER_MODEL_NAME =\n  `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.model_name}` as const;\n\n/**\n * The top k parameter for the reranker\n */\nexport const RERANKER_TOP_K =\n  `${SemanticAttributePrefixes.reranker}.${RerankerAttributePostfixes.top_k}` as const;\n\n/**\n * Metadata for a span, used to store user-defined key-value pairs\n */\nexport const METADATA = \"metadata\" as const;\n\n/**\n * A prompt template version\n */\nexport const PROMPT_TEMPLATE_VERSION =\n  `${PROMPT_TEMPLATE_PREFIX}.version` as const;\n\n/**\n * The tags associated with a span\n */\nexport const TAG_TAGS =\n  `${SemanticAttributePrefixes.tag}.${TagAttributePostfixes.tags}` as const;\n\n/**\n * The url of an audio file\n */\nexport const AUDIO_URL =\n  `${SemanticAttributePrefixes.audio}.${AudioAttributesPostfixes.url}` as const;\n\n/**\n * The audio mime type\n */\nexport const AUDIO_MIME_TYPE =\n  `${SemanticAttributePrefixes.audio}.${AudioAttributesPostfixes.mime_type}` as const;\n\n/**\n * The audio transcript as text\n */\nexport const AUDIO_TRANSCRIPT =\n  `${SemanticAttributePrefixes.audio}.${AudioAttributesPostfixes.transcript}` as const;\n/**\n * The vendor or origin of the prompt, e.g. a prompt library, a specialized service, etc.\n */\nexport const PROMPT_VENDOR =\n  `${SemanticAttributePrefixes.prompt}.${PromptAttributePostfixes.vendor}` as const;\n\n/**\n * A vendor-specific id used to locate the prompt\n */\nexport const PROMPT_ID =\n  `${SemanticAttributePrefixes.prompt}.${PromptAttributePostfixes.id}` as const;\n\n/**\n * A vendor-specific URL used to locate the prompt\n */\nexport const PROMPT_URL =\n  `${SemanticAttributePrefixes.prompt}.${PromptAttributePostfixes.url}` as const;\n\n/**\n * The name of the agent. Agents that perform the same functions should have the same name.\n */\nexport const AGENT_NAME =\n  `${SemanticAttributePrefixes.agent}.${AgentPostfixes.name}` as const;\n\n/**\n * The id of the node in the execution graph. This along with graph.node.parent_id are used to visualize the execution graph.\n */\nexport const GRAPH_NODE_ID =\n  `${SemanticAttributePrefixes.graph}.${GraphPostfixes.node_id}` as const;\n\n/**\n * The name of the node in the execution graph. Use this to present a human readable name for the node. Optional\n */\n\nexport const GRAPH_NODE_NAME =\n  `${SemanticAttributePrefixes.graph}.${GraphPostfixes.node_name}` as const;\n\n/**\n * This references the id of the parent node. Leaving this unset or set as empty string implies that the current span is the root node.\n */\nexport const GRAPH_NODE_PARENT_ID =\n  `${SemanticAttributePrefixes.graph}.${GraphPostfixes.node_parent_id}` as const;\n\nexport const SemanticConventions = {\n  IMAGE_URL,\n  INPUT_VALUE,\n  INPUT_MIME_TYPE,\n  OUTPUT_VALUE,\n  OUTPUT_MIME_TYPE,\n  LLM_INPUT_MESSAGES,\n  LLM_OUTPUT_MESSAGES,\n  LLM_MODEL_NAME,\n  LLM_PROMPTS,\n  LLM_INVOCATION_PARAMETERS,\n  LLM_TOKEN_COUNT_COMPLETION,\n  LLM_TOKEN_COUNT_COMPLETION_DETAILS,\n  LLM_TOKEN_COUNT_COMPLETION_DETAILS_REASONING,\n  LLM_TOKEN_COUNT_COMPLETION_DETAILS_AUDIO,\n  LLM_TOKEN_COUNT_PROMPT,\n  LLM_TOKEN_COUNT_PROMPT_DETAILS,\n  LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_WRITE,\n  LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_READ,\n  LLM_TOKEN_COUNT_PROMPT_DETAILS_CACHE_INPUT,\n  LLM_TOKEN_COUNT_PROMPT_DETAILS_AUDIO,\n  LLM_TOKEN_COUNT_TOTAL,\n  LLM_SYSTEM,\n  LLM_PROVIDER,\n  LLM_TOOLS,\n  LLM_COST,\n  LLM_COST_PROMPT,\n  LLM_COST_COMPLETION,\n  LLM_COST_TOTAL,\n  LLM_COST_INPUT,\n  LLM_COST_OUTPUT,\n  LLM_COST_COMPLETION_DETAILS_REASONING,\n  LLM_COST_COMPLETION_DETAILS_AUDIO,\n  LLM_COST_PROMPT_DETAILS_CACHE_WRITE,\n  LLM_COST_PROMPT_DETAILS_CACHE_READ,\n  LLM_COST_PROMPT_DETAILS_CACHE_INPUT,\n  LLM_COST_PROMPT_DETAILS_AUDIO,\n  MESSAGE_ROLE,\n  MESSAGE_NAME,\n  MESSAGE_TOOL_CALLS,\n  MESSAGE_TOOL_CALL_ID,\n  TOOL_CALL_ID,\n  TOOL_CALL_FUNCTION_NAME,\n  TOOL_CALL_FUNCTION_ARGUMENTS_JSON,\n  MESSAGE_FUNCTION_CALL_NAME,\n  MESSAGE_FUNCTION_CALL_ARGUMENTS_JSON,\n  MESSAGE_CONTENT,\n  MESSAGE_CONTENTS,\n  MESSAGE_CONTENT_IMAGE,\n  MESSAGE_CONTENT_TEXT,\n  MESSAGE_CONTENT_TYPE,\n  DOCUMENT_ID,\n  DOCUMENT_CONTENT,\n  DOCUMENT_SCORE,\n  DOCUMENT_METADATA,\n  EMBEDDING_EMBEDDINGS,\n  EMBEDDING_TEXT,\n  EMBEDDING_MODEL_NAME,\n  EMBEDDING_VECTOR,\n  TOOL_DESCRIPTION,\n  TOOL_NAME,\n  TOOL_PARAMETERS,\n  TOOL_JSON_SCHEMA,\n  PROMPT_TEMPLATE_VARIABLES,\n  PROMPT_TEMPLATE_TEMPLATE,\n  PROMPT_TEMPLATE_VERSION,\n  RERANKER_INPUT_DOCUMENTS,\n  RERANKER_OUTPUT_DOCUMENTS,\n  RERANKER_QUERY,\n  RERANKER_MODEL_NAME,\n  RERANKER_TOP_K,\n  LLM_FUNCTION_CALL,\n  RETRIEVAL_DOCUMENTS,\n  SESSION_ID,\n  USER_ID,\n  METADATA,\n  TAG_TAGS,\n  OPENINFERENCE_SPAN_KIND: `${SemanticAttributePrefixes.openinference}.span.kind`,\n  PROMPT_VENDOR,\n  PROMPT_ID,\n  PROMPT_URL,\n  AGENT_NAME,\n  GRAPH_NODE_ID,\n  GRAPH_NODE_NAME,\n  GRAPH_NODE_PARENT_ID,\n} as const;\n\nexport enum OpenInferenceSpanKind {\n  LLM = \"LLM\",\n  CHAIN = \"CHAIN\",\n  TOOL = \"TOOL\",\n  RETRIEVER = \"RETRIEVER\",\n  RERANKER = \"RERANKER\",\n  EMBEDDING = \"EMBEDDING\",\n  AGENT = \"AGENT\",\n  GUARDRAIL = \"GUARDRAIL\",\n  EVALUATOR = \"EVALUATOR\",\n}\n\n/**\n * An enum of common mime types. Not exhaustive.\n */\nexport enum MimeType {\n  TEXT = \"text/plain\",\n  JSON = \"application/json\",\n  AUDIO_WAV = \"audio/wav\",\n}\n\nexport enum LLMSystem {\n  OPENAI = \"openai\",\n  ANTHROPIC = \"anthropic\",\n  MISTRALAI = \"mistralai\",\n  COHERE = \"cohere\",\n  VERTEXAI = \"vertexai\",\n  AI21 = \"ai21\",\n  META = \"meta\",\n  AMAZON = \"amazon\",\n}\n\nexport enum LLMProvider {\n  OPENAI = \"openai\",\n  ANTHROPIC = \"anthropic\",\n  MISTRALAI = \"mistralai\",\n  COHERE = \"cohere\",\n  // Cloud Providers of LLM systems\n  GOOGLE = \"google\",\n  AWS = \"aws\",\n  AZURE = \"azure\",\n  XAI = \"xai\",\n  DEEPSEEK = \"deepseek\",\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/** only globals that common to node and browsers are allowed */\n// eslint-disable-next-line node/no-unsupported-features/es-builtins\nexport const _globalThis = typeof globalThis === 'object' ? globalThis : global;\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '1.9.0';\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { VERSION } from '../version';\n\nconst re = /^(\\d+)\\.(\\d+)\\.(\\d+)(-(.+))?$/;\n\n/**\n * Create a function to test an API version to see if it is compatible with the provided ownVersion.\n *\n * The returned function has the following semantics:\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param ownVersion version which should be checked against\n */\nexport function _makeCompatibilityCheck(\n  ownVersion: string\n): (globalVersion: string) => boolean {\n  const acceptedVersions = new Set<string>([ownVersion]);\n  const rejectedVersions = new Set<string>();\n\n  const myVersionMatch = ownVersion.match(re);\n  if (!myVersionMatch) {\n    // we cannot guarantee compatibility so we always return noop\n    return () => false;\n  }\n\n  const ownVersionParsed = {\n    major: +myVersionMatch[1],\n    minor: +myVersionMatch[2],\n    patch: +myVersionMatch[3],\n    prerelease: myVersionMatch[4],\n  };\n\n  // if ownVersion has a prerelease tag, versions must match exactly\n  if (ownVersionParsed.prerelease != null) {\n    return function isExactmatch(globalVersion: string): boolean {\n      return globalVersion === ownVersion;\n    };\n  }\n\n  function _reject(v: string) {\n    rejectedVersions.add(v);\n    return false;\n  }\n\n  function _accept(v: string) {\n    acceptedVersions.add(v);\n    return true;\n  }\n\n  return function isCompatible(globalVersion: string): boolean {\n    if (acceptedVersions.has(globalVersion)) {\n      return true;\n    }\n\n    if (rejectedVersions.has(globalVersion)) {\n      return false;\n    }\n\n    const globalVersionMatch = globalVersion.match(re);\n    if (!globalVersionMatch) {\n      // cannot parse other version\n      // we cannot guarantee compatibility so we always noop\n      return _reject(globalVersion);\n    }\n\n    const globalVersionParsed = {\n      major: +globalVersionMatch[1],\n      minor: +globalVersionMatch[2],\n      patch: +globalVersionMatch[3],\n      prerelease: globalVersionMatch[4],\n    };\n\n    // if globalVersion has a prerelease tag, versions must match exactly\n    if (globalVersionParsed.prerelease != null) {\n      return _reject(globalVersion);\n    }\n\n    // major versions must match\n    if (ownVersionParsed.major !== globalVersionParsed.major) {\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.major === 0) {\n      if (\n        ownVersionParsed.minor === globalVersionParsed.minor &&\n        ownVersionParsed.patch <= globalVersionParsed.patch\n      ) {\n        return _accept(globalVersion);\n      }\n\n      return _reject(globalVersion);\n    }\n\n    if (ownVersionParsed.minor <= globalVersionParsed.minor) {\n      return _accept(globalVersion);\n    }\n\n    return _reject(globalVersion);\n  };\n}\n\n/**\n * Test an API version to see if it is compatible with this API.\n *\n * - Exact match is always compatible\n * - Major versions must match exactly\n *    - 1.x package cannot use global 2.x package\n *    - 2.x package cannot use global 1.x package\n * - The minor version of the API module requesting access to the global API must be less than or equal to the minor version of this API\n *    - 1.3 package may use 1.4 global because the later global contains all functions 1.3 expects\n *    - 1.4 package may NOT use 1.3 global because it may try to call functions which don't exist on 1.3\n * - If the major version is 0, the minor version is treated as the major and the patch is treated as the minor\n * - Patch and build tag differences are not considered at this time\n *\n * @param version version of the API requesting an instance of the global API\n */\nexport const isCompatible = _makeCompatibilityCheck(VERSION);\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { MeterProvider } from '../metrics/MeterProvider';\nimport { ContextManager } from '../context/types';\nimport { DiagLogger } from '../diag/types';\nimport { _globalThis } from '../platform';\nimport { TextMapPropagator } from '../propagation/TextMapPropagator';\nimport type { TracerProvider } from '../trace/tracer_provider';\nimport { VERSION } from '../version';\nimport { isCompatible } from './semver';\n\nconst major = VERSION.split('.')[0];\nconst GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for(\n  `opentelemetry.js.api.${major}`\n);\n\nconst _global = _globalThis as OTelGlobal;\n\nexport function registerGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type,\n  instance: OTelGlobalAPI[Type],\n  diag: DiagLogger,\n  allowOverride = false\n): boolean {\n  const api = (_global[GLOBAL_OPENTELEMETRY_API_KEY] = _global[\n    GLOBAL_OPENTELEMETRY_API_KEY\n  ] ?? {\n    version: VERSION,\n  });\n\n  if (!allowOverride && api[type]) {\n    // already registered an API of this type\n    const err = new Error(\n      `@opentelemetry/api: Attempted duplicate registration of API: ${type}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  if (api.version !== VERSION) {\n    // All registered APIs must be of the same version exactly\n    const err = new Error(\n      `@opentelemetry/api: Registration of version v${api.version} for ${type} does not match previously registered API v${VERSION}`\n    );\n    diag.error(err.stack || err.message);\n    return false;\n  }\n\n  api[type] = instance;\n  diag.debug(\n    `@opentelemetry/api: Registered a global for ${type} v${VERSION}.`\n  );\n\n  return true;\n}\n\nexport function getGlobal<Type extends keyof OTelGlobalAPI>(\n  type: Type\n): OTelGlobalAPI[Type] | undefined {\n  const globalVersion = _global[GLOBAL_OPENTELEMETRY_API_KEY]?.version;\n  if (!globalVersion || !isCompatible(globalVersion)) {\n    return;\n  }\n  return _global[GLOBAL_OPENTELEMETRY_API_KEY]?.[type];\n}\n\nexport function unregisterGlobal(type: keyof OTelGlobalAPI, diag: DiagLogger) {\n  diag.debug(\n    `@opentelemetry/api: Unregistering a global for ${type} v${VERSION}.`\n  );\n  const api = _global[GLOBAL_OPENTELEMETRY_API_KEY];\n\n  if (api) {\n    delete api[type];\n  }\n}\n\ntype OTelGlobal = {\n  [GLOBAL_OPENTELEMETRY_API_KEY]?: OTelGlobalAPI;\n};\n\ntype OTelGlobalAPI = {\n  version: string;\n\n  diag?: DiagLogger;\n  trace?: TracerProvider;\n  context?: ContextManager;\n  metrics?: MeterProvider;\n  propagation?: TextMapPropagator;\n};\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { getGlobal } from '../internal/global-utils';\nimport { ComponentLoggerOptions, DiagLogger, DiagLogFunction } from './types';\n\n/**\n * Component Logger which is meant to be used as part of any component which\n * will add automatically additional namespace in front of the log message.\n * It will then forward all message to global diag logger\n * @example\n * const cLogger = diag.createComponentLogger({ namespace: '@opentelemetry/instrumentation-http' });\n * cLogger.debug('test');\n * // @opentelemetry/instrumentation-http test\n */\nexport class DiagComponentLogger implements DiagLogger {\n  private _namespace: string;\n\n  constructor(props: ComponentLoggerOptions) {\n    this._namespace = props.namespace || 'DiagComponentLogger';\n  }\n\n  public debug(...args: any[]): void {\n    return logProxy('debug', this._namespace, args);\n  }\n\n  public error(...args: any[]): void {\n    return logProxy('error', this._namespace, args);\n  }\n\n  public info(...args: any[]): void {\n    return logProxy('info', this._namespace, args);\n  }\n\n  public warn(...args: any[]): void {\n    return logProxy('warn', this._namespace, args);\n  }\n\n  public verbose(...args: any[]): void {\n    return logProxy('verbose', this._namespace, args);\n  }\n}\n\nfunction logProxy(\n  funcName: keyof DiagLogger,\n  namespace: string,\n  args: any\n): void {\n  const logger = getGlobal('diag');\n  // shortcut if logger not set\n  if (!logger) {\n    return;\n  }\n\n  args.unshift(namespace);\n  return logger[funcName](...(args as Parameters<DiagLogFunction>));\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport type DiagLogFunction = (message: string, ...args: unknown[]) => void;\n\n/**\n * Defines an internal diagnostic logger interface which is used to log internal diagnostic\n * messages, you can set the default diagnostic logger via the {@link DiagAPI} setLogger function.\n * API provided implementations include :-\n * - a No-Op {@link createNoopDiagLogger}\n * - a {@link DiagLogLevel} filtering wrapper {@link createLogLevelDiagLogger}\n * - a general Console {@link DiagConsoleLogger} version.\n */\nexport interface DiagLogger {\n  /** Log an error scenario that was not expected and caused the requested operation to fail. */\n  error: DiagLogFunction;\n\n  /**\n   * Log a warning scenario to inform the developer of an issues that should be investigated.\n   * The requested operation may or may not have succeeded or completed.\n   */\n  warn: DiagLogFunction;\n\n  /**\n   * Log a general informational message, this should not affect functionality.\n   * This is also the default logging level so this should NOT be used for logging\n   * debugging level information.\n   */\n  info: DiagLogFunction;\n\n  /**\n   * Log a general debug message that can be useful for identifying a failure.\n   * Information logged at this level may include diagnostic details that would\n   * help identify a failure scenario.\n   * For example: Logging the order of execution of async operations.\n   */\n  debug: DiagLogFunction;\n\n  /**\n   * Log a detailed (verbose) trace level logging that can be used to identify failures\n   * where debug level logging would be insufficient, this level of tracing can include\n   * input and output parameters and as such may include PII information passing through\n   * the API. As such it is recommended that this level of tracing should not be enabled\n   * in a production environment.\n   */\n  verbose: DiagLogFunction;\n}\n\n/**\n * Defines the available internal logging levels for the diagnostic logger, the numeric values\n * of the levels are defined to match the original values from the initial LogLevel to avoid\n * compatibility/migration issues for any implementation that assume the numeric ordering.\n */\nexport enum DiagLogLevel {\n  /** Diagnostic Logging level setting to disable all logging (except and forced logs) */\n  NONE = 0,\n\n  /** Identifies an error scenario */\n  ERROR = 30,\n\n  /** Identifies a warning scenario */\n  WARN = 50,\n\n  /** General informational log message */\n  INFO = 60,\n\n  /** General debug log message */\n  DEBUG = 70,\n\n  /**\n   * Detailed trace level logging should only be used for development, should only be set\n   * in a development environment.\n   */\n  VERBOSE = 80,\n\n  /** Used to set the logging level to include all logging */\n  ALL = 9999,\n}\n\n/**\n * Defines options for ComponentLogger\n */\nexport interface ComponentLoggerOptions {\n  namespace: string;\n}\n\nexport interface DiagLoggerOptions {\n  /**\n   * The {@link DiagLogLevel} used to filter logs sent to the logger.\n   *\n   * @defaultValue DiagLogLevel.INFO\n   */\n  logLevel?: DiagLogLevel;\n\n  /**\n   * Setting this value to `true` will suppress the warning message normally emitted when registering a logger when another logger is already registered.\n   */\n  suppressOverrideMessage?: boolean;\n}\n\nexport interface DiagLoggerApi {\n  /**\n   * Set the global DiagLogger and DiagLogLevel.\n   * If a global diag logger is already set, this will override it.\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param options - A {@link DiagLoggerOptions} object. If not provided, default values will be set.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, options?: DiagLoggerOptions): boolean;\n\n  /**\n   *\n   * @param logger - The {@link DiagLogger} instance to set as the default logger.\n   * @param logLevel - The {@link DiagLogLevel} used to filter logs sent to the logger. If not provided it will default to {@link DiagLogLevel.INFO}.\n   * @returns `true` if the logger was successfully registered, else `false`\n   */\n  setLogger(logger: DiagLogger, logLevel?: DiagLogLevel): boolean;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagLogFunction, DiagLogger, DiagLogLevel } from '../types';\n\nexport function createLogLevelDiagLogger(\n  maxLevel: DiagLogLevel,\n  logger: DiagLogger\n): DiagLogger {\n  if (maxLevel < DiagLogLevel.NONE) {\n    maxLevel = DiagLogLevel.NONE;\n  } else if (maxLevel > DiagLogLevel.ALL) {\n    maxLevel = DiagLogLevel.ALL;\n  }\n\n  // In case the logger is null or undefined\n  logger = logger || {};\n\n  function _filterFunc(\n    funcName: keyof DiagLogger,\n    theLevel: DiagLogLevel\n  ): DiagLogFunction {\n    const theFunc = logger[funcName];\n\n    if (typeof theFunc === 'function' && maxLevel >= theLevel) {\n      return theFunc.bind(logger);\n    }\n    return function () {};\n  }\n\n  return {\n    error: _filterFunc('error', DiagLogLevel.ERROR),\n    warn: _filterFunc('warn', DiagLogLevel.WARN),\n    info: _filterFunc('info', DiagLogLevel.INFO),\n    debug: _filterFunc('debug', DiagLogLevel.DEBUG),\n    verbose: _filterFunc('verbose', DiagLogLevel.VERBOSE),\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { DiagComponentLogger } from '../diag/ComponentLogger';\nimport { createLogLevelDiagLogger } from '../diag/internal/logLevelLogger';\nimport {\n  ComponentLoggerOptions,\n  DiagLogFunction,\n  DiagLogger,\n  DiagLoggerApi,\n  DiagLogLevel,\n} from '../diag/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\n\nconst API_NAME = 'diag';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry internal\n * diagnostic API\n */\nexport class DiagAPI implements DiagLogger, DiagLoggerApi {\n  private static _instance?: DiagAPI;\n\n  /** Get the singleton instance of the DiagAPI API */\n  public static instance(): DiagAPI {\n    if (!this._instance) {\n      this._instance = new DiagAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Private internal constructor\n   * @private\n   */\n  private constructor() {\n    function _logProxy(funcName: keyof DiagLogger): DiagLogFunction {\n      return function (...args) {\n        const logger = getGlobal('diag');\n        // shortcut if logger not set\n        if (!logger) return;\n        return logger[funcName](...args);\n      };\n    }\n\n    // Using self local variable for minification purposes as 'this' cannot be minified\n    const self = this;\n\n    // DiagAPI specific functions\n\n    const setLogger: DiagLoggerApi['setLogger'] = (\n      logger,\n      optionsOrLogLevel = { logLevel: DiagLogLevel.INFO }\n    ) => {\n      if (logger === self) {\n        // There isn't much we can do here.\n        // Logging to the console might break the user application.\n        // Try to log to self. If a logger was previously registered it will receive the log.\n        const err = new Error(\n          'Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation'\n        );\n        self.error(err.stack ?? err.message);\n        return false;\n      }\n\n      if (typeof optionsOrLogLevel === 'number') {\n        optionsOrLogLevel = {\n          logLevel: optionsOrLogLevel,\n        };\n      }\n\n      const oldLogger = getGlobal('diag');\n      const newLogger = createLogLevelDiagLogger(\n        optionsOrLogLevel.logLevel ?? DiagLogLevel.INFO,\n        logger\n      );\n      // There already is an logger registered. We'll let it know before overwriting it.\n      if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {\n        const stack = new Error().stack ?? '<failed to generate stacktrace>';\n        oldLogger.warn(`Current logger will be overwritten from ${stack}`);\n        newLogger.warn(\n          `Current logger will overwrite one already registered from ${stack}`\n        );\n      }\n\n      return registerGlobal('diag', newLogger, self, true);\n    };\n\n    self.setLogger = setLogger;\n\n    self.disable = () => {\n      unregisterGlobal(API_NAME, self);\n    };\n\n    self.createComponentLogger = (options: ComponentLoggerOptions) => {\n      return new DiagComponentLogger(options);\n    };\n\n    self.verbose = _logProxy('verbose');\n    self.debug = _logProxy('debug');\n    self.info = _logProxy('info');\n    self.warn = _logProxy('warn');\n    self.error = _logProxy('error');\n  }\n\n  public setLogger!: DiagLoggerApi['setLogger'];\n  /**\n   *\n   */\n  public createComponentLogger!: (\n    options: ComponentLoggerOptions\n  ) => DiagLogger;\n\n  // DiagLogger implementation\n  public verbose!: DiagLogFunction;\n  public debug!: DiagLogFunction;\n  public info!: DiagLogFunction;\n  public warn!: DiagLogFunction;\n  public error!: DiagLogFunction;\n\n  /**\n   * Unregister the global logger and return to Noop\n   */\n  public disable!: () => void;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from './types';\n\n/** Get a key to uniquely identify a context value */\nexport function createContextKey(description: string) {\n  // The specification states that for the same input, multiple calls should\n  // return different keys. Due to the nature of the JS dependency management\n  // system, this creates problems where multiple versions of some package\n  // could hold different keys for the same property.\n  //\n  // Therefore, we use Symbol.for which returns the same key for the same input.\n  return Symbol.for(description);\n}\n\nclass BaseContext implements Context {\n  private _currentContext!: Map<symbol, unknown>;\n\n  /**\n   * Construct a new context which inherits values from an optional parent context.\n   *\n   * @param parentContext a context from which to inherit values\n   */\n  constructor(parentContext?: Map<symbol, unknown>) {\n    // for minification\n    const self = this;\n\n    self._currentContext = parentContext ? new Map(parentContext) : new Map();\n\n    self.getValue = (key: symbol) => self._currentContext.get(key);\n\n    self.setValue = (key: symbol, value: unknown): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.set(key, value);\n      return context;\n    };\n\n    self.deleteValue = (key: symbol): Context => {\n      const context = new BaseContext(self._currentContext);\n      context._currentContext.delete(key);\n      return context;\n    };\n  }\n\n  /**\n   * Get a value from the context.\n   *\n   * @param key key which identifies a context value\n   */\n  public getValue!: (key: symbol) => unknown;\n\n  /**\n   * Create a new context which inherits from this context and has\n   * the given key set to the given value.\n   *\n   * @param key context key for which to set the value\n   * @param value value to set for the given key\n   */\n  public setValue!: (key: symbol, value: unknown) => Context;\n\n  /**\n   * Return a new context which inherits from this context but does\n   * not contain a value for the given key.\n   *\n   * @param key context key for which to clear a value\n   */\n  public deleteValue!: (key: symbol) => Context;\n}\n\n/** The root context is used as the default parent context when there is no active context */\nexport const ROOT_CONTEXT: Context = new BaseContext();\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ROOT_CONTEXT } from './context';\nimport * as types from './types';\n\nexport class NoopContextManager implements types.ContextManager {\n  active(): types.Context {\n    return ROOT_CONTEXT;\n  }\n\n  with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    _context: types.Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return fn.call(thisArg, ...args);\n  }\n\n  bind<T>(_context: types.Context, target: T): T {\n    return target;\n  }\n\n  enable(): this {\n    return this;\n  }\n\n  disable(): this {\n    return this;\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopContextManager } from '../context/NoopContextManager';\nimport { Context, ContextManager } from '../context/types';\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'context';\nconst NOOP_CONTEXT_MANAGER = new NoopContextManager();\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Context API\n */\nexport class ContextAPI {\n  private static _instance?: ContextAPI;\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Context API */\n  public static getInstance(): ContextAPI {\n    if (!this._instance) {\n      this._instance = new ContextAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current context manager.\n   *\n   * @returns true if the context manager was successfully registered, else false\n   */\n  public setGlobalContextManager(contextManager: ContextManager): boolean {\n    return registerGlobal(API_NAME, contextManager, DiagAPI.instance());\n  }\n\n  /**\n   * Get the currently active context\n   */\n  public active(): Context {\n    return this._getContextManager().active();\n  }\n\n  /**\n   * Execute a function with an active context\n   *\n   * @param context context to be active during function execution\n   * @param fn function to execute in a context\n   * @param thisArg optional receiver to be used for calling fn\n   * @param args optional arguments forwarded to fn\n   */\n  public with<A extends unknown[], F extends (...args: A) => ReturnType<F>>(\n    context: Context,\n    fn: F,\n    thisArg?: ThisParameterType<F>,\n    ...args: A\n  ): ReturnType<F> {\n    return this._getContextManager().with(context, fn, thisArg, ...args);\n  }\n\n  /**\n   * Bind a context to a target function or event emitter\n   *\n   * @param context context to bind to the event emitter or function. Defaults to the currently active context\n   * @param target function or event emitter to bind\n   */\n  public bind<T>(context: Context, target: T): T {\n    return this._getContextManager().bind(context, target);\n  }\n\n  private _getContextManager(): ContextManager {\n    return getGlobal(API_NAME) || NOOP_CONTEXT_MANAGER;\n  }\n\n  /** Disable and remove the global context manager */\n  public disable() {\n    this._getContextManager().disable();\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport enum TraceFlags {\n  /** Represents no flag set. */\n  NONE = 0x0,\n  /** Bit to represent whether trace is sampled in trace flags. */\n  SAMPLED = 0x1 << 0,\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { SpanContext } from './span_context';\nimport { TraceFlags } from './trace_flags';\n\nexport const INVALID_SPANID = '0000000000000000';\nexport const INVALID_TRACEID = '00000000000000000000000000000000';\nexport const INVALID_SPAN_CONTEXT: SpanContext = {\n  traceId: INVALID_TRACEID,\n  spanId: INVALID_SPANID,\n  traceFlags: TraceFlags.NONE,\n};\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Exception } from '../common/Exception';\nimport { TimeInput } from '../common/Time';\nimport { SpanAttributes } from './attributes';\nimport { INVALID_SPAN_CONTEXT } from './invalid-span-constants';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { SpanStatus } from './status';\nimport { Link } from './link';\n\n/**\n * The NonRecordingSpan is the default {@link Span} that is used when no Span\n * implementation is available. All operations are no-op including context\n * propagation.\n */\nexport class NonRecordingSpan implements Span {\n  constructor(\n    private readonly _spanContext: SpanContext = INVALID_SPAN_CONTEXT\n  ) {}\n\n  // Returns a SpanContext.\n  spanContext(): SpanContext {\n    return this._spanContext;\n  }\n\n  // By default does nothing\n  setAttribute(_key: string, _value: unknown): this {\n    return this;\n  }\n\n  // By default does nothing\n  setAttributes(_attributes: SpanAttributes): this {\n    return this;\n  }\n\n  // By default does nothing\n  addEvent(_name: string, _attributes?: SpanAttributes): this {\n    return this;\n  }\n\n  addLink(_link: Link): this {\n    return this;\n  }\n\n  addLinks(_links: Link[]): this {\n    return this;\n  }\n\n  // By default does nothing\n  setStatus(_status: SpanStatus): this {\n    return this;\n  }\n\n  // By default does nothing\n  updateName(_name: string): this {\n    return this;\n  }\n\n  // By default does nothing\n  end(_endTime?: TimeInput): void {}\n\n  // isRecording always returns false for NonRecordingSpan.\n  isRecording(): boolean {\n    return false;\n  }\n\n  // By default does nothing\n  recordException(_exception: Exception, _time?: TimeInput): void {}\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { createContextKey } from '../context/context';\nimport { Context } from '../context/types';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { ContextAPI } from '../api/context';\n\n/**\n * span key\n */\nconst SPAN_KEY = createContextKey('OpenTelemetry Context Key SPAN');\n\n/**\n * Return the span if one exists\n *\n * @param context context to get span from\n */\nexport function getSpan(context: Context): Span | undefined {\n  return (context.getValue(SPAN_KEY) as Span) || undefined;\n}\n\n/**\n * Gets the span from the current context, if one exists.\n */\nexport function getActiveSpan(): Span | undefined {\n  return getSpan(ContextAPI.getInstance().active());\n}\n\n/**\n * Set the span on a context\n *\n * @param context context to use as parent\n * @param span span to set active\n */\nexport function setSpan(context: Context, span: Span): Context {\n  return context.setValue(SPAN_KEY, span);\n}\n\n/**\n * Remove current span stored in the context\n *\n * @param context context to delete span from\n */\nexport function deleteSpan(context: Context): Context {\n  return context.deleteValue(SPAN_KEY);\n}\n\n/**\n * Wrap span context in a NoopSpan and set as span in a new\n * context\n *\n * @param context context to set active span on\n * @param spanContext span context to be wrapped\n */\nexport function setSpanContext(\n  context: Context,\n  spanContext: SpanContext\n): Context {\n  return setSpan(context, new NonRecordingSpan(spanContext));\n}\n\n/**\n * Get the span context of the span if it exists.\n *\n * @param context context to get values from\n */\nexport function getSpanContext(context: Context): SpanContext | undefined {\n  return getSpan(context)?.spanContext();\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { INVALID_SPANID, INVALID_TRACEID } from './invalid-span-constants';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { SpanContext } from './span_context';\n\nconst VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;\nconst VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;\n\nexport function isValidTraceId(traceId: string): boolean {\n  return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;\n}\n\nexport function isValidSpanId(spanId: string): boolean {\n  return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;\n}\n\n/**\n * Returns true if this {@link SpanContext} is valid.\n * @return true if this {@link SpanContext} is valid.\n */\nexport function isSpanContextValid(spanContext: SpanContext): boolean {\n  return (\n    isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId)\n  );\n}\n\n/**\n * Wrap the given {@link SpanContext} in a new non-recording {@link Span}\n *\n * @param spanContext span context to be wrapped\n * @returns a new non-recording {@link Span} with the provided context\n */\nexport function wrapSpanContext(spanContext: SpanContext): Span {\n  return new NonRecordingSpan(spanContext);\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ContextAPI } from '../api/context';\nimport { Context } from '../context/types';\nimport { getSpanContext, setSpan } from '../trace/context-utils';\nimport { NonRecordingSpan } from './NonRecordingSpan';\nimport { Span } from './span';\nimport { isSpanContextValid } from './spancontext-utils';\nimport { SpanOptions } from './SpanOptions';\nimport { SpanContext } from './span_context';\nimport { Tracer } from './tracer';\n\nconst contextApi = ContextAPI.getInstance();\n\n/**\n * No-op implementations of {@link Tracer}.\n */\nexport class NoopTracer implements Tracer {\n  // startSpan starts a noop span.\n  startSpan(\n    name: string,\n    options?: SpanOptions,\n    context = contextApi.active()\n  ): Span {\n    const root = Boolean(options?.root);\n    if (root) {\n      return new NonRecordingSpan();\n    }\n\n    const parentFromContext = context && getSpanContext(context);\n\n    if (\n      isSpanContext(parentFromContext) &&\n      isSpanContextValid(parentFromContext)\n    ) {\n      return new NonRecordingSpan(parentFromContext);\n    } else {\n      return new NonRecordingSpan();\n    }\n  }\n\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    opts: SpanOptions | undefined,\n    ctx: Context | undefined,\n    fn: F\n  ): ReturnType<F>;\n  startActiveSpan<F extends (span: Span) => ReturnType<F>>(\n    name: string,\n    arg2?: F | SpanOptions,\n    arg3?: F | Context,\n    arg4?: F\n  ): ReturnType<F> | undefined {\n    let opts: SpanOptions | undefined;\n    let ctx: Context | undefined;\n    let fn: F;\n\n    if (arguments.length < 2) {\n      return;\n    } else if (arguments.length === 2) {\n      fn = arg2 as F;\n    } else if (arguments.length === 3) {\n      opts = arg2 as SpanOptions | undefined;\n      fn = arg3 as F;\n    } else {\n      opts = arg2 as SpanOptions | undefined;\n      ctx = arg3 as Context | undefined;\n      fn = arg4 as F;\n    }\n\n    const parentContext = ctx ?? contextApi.active();\n    const span = this.startSpan(name, opts, parentContext);\n    const contextWithSpanSet = setSpan(parentContext, span);\n\n    return contextApi.with(contextWithSpanSet, fn, undefined, span);\n  }\n}\n\nfunction isSpanContext(spanContext: any): spanContext is SpanContext {\n  return (\n    typeof spanContext === 'object' &&\n    typeof spanContext['spanId'] === 'string' &&\n    typeof spanContext['traceId'] === 'string' &&\n    typeof spanContext['traceFlags'] === 'number'\n  );\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Context } from '../context/types';\nimport { NoopTracer } from './NoopTracer';\nimport { Span } from './span';\nimport { SpanOptions } from './SpanOptions';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER = new NoopTracer();\n\n/**\n * Proxy tracer provided by the proxy tracer provider\n */\nexport class ProxyTracer implements Tracer {\n  // When a real implementation is provided, this will be it\n  private _delegate?: Tracer;\n\n  constructor(\n    private _provider: TracerDelegator,\n    public readonly name: string,\n    public readonly version?: string,\n    public readonly options?: TracerOptions\n  ) {}\n\n  startSpan(name: string, options?: SpanOptions, context?: Context): Span {\n    return this._getTracer().startSpan(name, options, context);\n  }\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    _name: string,\n    _options: F | SpanOptions,\n    _context?: F | Context,\n    _fn?: F\n  ): ReturnType<F> {\n    const tracer = this._getTracer();\n    return Reflect.apply(tracer.startActiveSpan, tracer, arguments);\n  }\n\n  /**\n   * Try to get a tracer from the proxy tracer provider.\n   * If the proxy tracer provider has no delegate, return a noop tracer.\n   */\n  private _getTracer() {\n    if (this._delegate) {\n      return this._delegate;\n    }\n\n    const tracer = this._provider.getDelegateTracer(\n      this.name,\n      this.version,\n      this.options\n    );\n\n    if (!tracer) {\n      return NOOP_TRACER;\n    }\n\n    this._delegate = tracer;\n    return this._delegate;\n  }\n}\n\nexport interface TracerDelegator {\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { NoopTracer } from './NoopTracer';\nimport { Tracer } from './tracer';\nimport { TracerOptions } from './tracer_options';\nimport { TracerProvider } from './tracer_provider';\n\n/**\n * An implementation of the {@link TracerProvider} which returns an impotent\n * Tracer for all calls to `getTracer`.\n *\n * All operations are no-op.\n */\nexport class NoopTracerProvider implements TracerProvider {\n  getTracer(\n    _name?: string,\n    _version?: string,\n    _options?: TracerOptions\n  ): Tracer {\n    return new NoopTracer();\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { Tracer } from './tracer';\nimport { TracerProvider } from './tracer_provider';\nimport { ProxyTracer } from './ProxyTracer';\nimport { NoopTracerProvider } from './NoopTracerProvider';\nimport { TracerOptions } from './tracer_options';\n\nconst NOOP_TRACER_PROVIDER = new NoopTracerProvider();\n\n/**\n * Tracer provider which provides {@link ProxyTracer}s.\n *\n * Before a delegate is set, tracers provided are NoOp.\n *   When a delegate is set, traces are provided from the delegate.\n *   When a delegate is set after tracers have already been provided,\n *   all tracers already provided will use the provided delegate implementation.\n */\nexport class ProxyTracerProvider implements TracerProvider {\n  private _delegate?: TracerProvider;\n\n  /**\n   * Get a {@link ProxyTracer}\n   */\n  getTracer(name: string, version?: string, options?: TracerOptions): Tracer {\n    return (\n      this.getDelegateTracer(name, version, options) ??\n      new ProxyTracer(this, name, version, options)\n    );\n  }\n\n  getDelegate(): TracerProvider {\n    return this._delegate ?? NOOP_TRACER_PROVIDER;\n  }\n\n  /**\n   * Set the delegate tracer provider\n   */\n  setDelegate(delegate: TracerProvider) {\n    this._delegate = delegate;\n  }\n\n  getDelegateTracer(\n    name: string,\n    version?: string,\n    options?: TracerOptions\n  ): Tracer | undefined {\n    return this._delegate?.getTracer(name, version, options);\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nexport interface SpanStatus {\n  /** The status code of this message. */\n  code: SpanStatusCode;\n  /** A developer-facing error message. */\n  message?: string;\n}\n\n/**\n * An enumeration of status codes.\n */\nexport enum SpanStatusCode {\n  /**\n   * The default status.\n   */\n  UNSET = 0,\n  /**\n   * The operation has been validated by an Application developer or\n   * Operator to have completed successfully.\n   */\n  OK = 1,\n  /**\n   * The operation contains an error.\n   */\n  ERROR = 2,\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { ContextAPI } from './api/context';\n/** Entrypoint for context API */\nexport const context = ContextAPI.getInstance();\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getGlobal,\n  registerGlobal,\n  unregisterGlobal,\n} from '../internal/global-utils';\nimport { ProxyTracerProvider } from '../trace/ProxyTracerProvider';\nimport {\n  isSpanContextValid,\n  wrapSpanContext,\n} from '../trace/spancontext-utils';\nimport { Tracer } from '../trace/tracer';\nimport { TracerProvider } from '../trace/tracer_provider';\nimport {\n  deleteSpan,\n  getActiveSpan,\n  getSpan,\n  getSpanContext,\n  setSpan,\n  setSpanContext,\n} from '../trace/context-utils';\nimport { DiagAPI } from './diag';\n\nconst API_NAME = 'trace';\n\n/**\n * Singleton object which represents the entry point to the OpenTelemetry Tracing API\n */\nexport class TraceAPI {\n  private static _instance?: TraceAPI;\n\n  private _proxyTracerProvider = new ProxyTracerProvider();\n\n  /** Empty private constructor prevents end users from constructing a new instance of the API */\n  private constructor() {}\n\n  /** Get the singleton instance of the Trace API */\n  public static getInstance(): TraceAPI {\n    if (!this._instance) {\n      this._instance = new TraceAPI();\n    }\n\n    return this._instance;\n  }\n\n  /**\n   * Set the current global tracer.\n   *\n   * @returns true if the tracer provider was successfully registered, else false\n   */\n  public setGlobalTracerProvider(provider: TracerProvider): boolean {\n    const success = registerGlobal(\n      API_NAME,\n      this._proxyTracerProvider,\n      DiagAPI.instance()\n    );\n    if (success) {\n      this._proxyTracerProvider.setDelegate(provider);\n    }\n    return success;\n  }\n\n  /**\n   * Returns the global tracer provider.\n   */\n  public getTracerProvider(): TracerProvider {\n    return getGlobal(API_NAME) || this._proxyTracerProvider;\n  }\n\n  /**\n   * Returns a tracer from the global tracer provider.\n   */\n  public getTracer(name: string, version?: string): Tracer {\n    return this.getTracerProvider().getTracer(name, version);\n  }\n\n  /** Remove the global tracer provider */\n  public disable() {\n    unregisterGlobal(API_NAME, DiagAPI.instance());\n    this._proxyTracerProvider = new ProxyTracerProvider();\n  }\n\n  public wrapSpanContext = wrapSpanContext;\n\n  public isSpanContextValid = isSpanContextValid;\n\n  public deleteSpan = deleteSpan;\n\n  public getSpan = getSpan;\n\n  public getActiveSpan = getActiveSpan;\n\n  public getSpanContext = getSpanContext;\n\n  public setSpan = setSpan;\n\n  public setSpanContext = setSpanContext;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Split module-level variable definition into separate files to allow\n// tree-shaking on each api instance.\nimport { TraceAPI } from './api/trace';\n/** Entrypoint for trace API */\nexport const trace = TraceAPI.getInstance();\n","/**\n * OTEL attribute constants for AG-Kit observability.\n *\n * Uses OpenInference semantic conventions where applicable:\n * https://github.com/Arize-ai/openinference/tree/main/spec\n *\n * Falls back to AG-Kit specific attributes where OpenInference\n * doesn't define a standard.\n *\n * @module\n */\n\nimport {\n  SemanticConventions,\n  OpenInferenceSpanKind,\n} from \"@arizeai/openinference-semantic-conventions\";\n\n// Re-export OpenInference types for convenience\nexport { OpenInferenceSpanKind };\n\n/**\n * SDK information\n */\nexport const OBSERVABILITY_TRACER_NAME = \"agkit-tracer\";\nexport const OBSERVABILITY_SDK_NAME = \"@agkit/observability\";\n// Version will be injected from package.json\n\n/**\n * Combined attribute namespace for internal use\n * Provides a single namespace for all OTEL attributes used by AG-Kit\n *\n * Combines OpenInference SemanticConventions with AG-Kit specific attributes\n */\nexport const OtelSpanAttributes = {\n  // OpenInference - re-export all standard conventions\n  ...SemanticConventions,\n\n  // AG-Kit Trace attributes (non-standard)\n  TRACE_NAME: \"trace.name\",\n  TRACE_TAGS: \"trace.tags\",\n  TRACE_PUBLIC: \"trace.public\",\n  TRACE_METADATA: \"trace.metadata\",\n  TRACE_INPUT: \"trace.input\",\n  TRACE_OUTPUT: \"trace.output\",\n\n  // AG-Kit Observation attributes (non-standard)\n  OBSERVATION_TYPE: \"observation.type\",\n  OBSERVATION_LEVEL: \"observation.level\",\n  OBSERVATION_STATUS_MESSAGE: \"observation.status_message\",\n  OBSERVATION_INPUT: \"observation.input\",\n  OBSERVATION_OUTPUT: \"observation.output\",\n  OBSERVATION_METADATA: \"observation.metadata\",\n\n  // AG-Kit LLM-specific (non-standard)\n  LLM_COMPLETION_START_TIME: \"llm.completion_start_time\",\n  LLM_MODEL_PARAMETERS: \"llm.model_parameters\",\n  LLM_USAGE_DETAILS: \"llm.usage_details\",\n  LLM_COST_DETAILS: \"llm.cost_details\",\n\n  // AG-Kit Retriever-specific (non-standard)\n  RETRIEVER_NAME: \"retriever.name\",\n  RETRIEVER_QUERY: \"retriever.query\",\n  RETRIEVER_INDEX_ID: \"retriever.index_id\",\n  RETRIEVER_TOP_K: \"retriever.top_k\",\n\n  // AG-Kit General (non-standard)\n  ENVIRONMENT: \"environment\",\n  RELEASE: \"release\",\n  VERSION: \"version\",\n} as const;\n\n/**\n * Type for the OtelSpanAttributes object values\n */\nexport type OtelSpanAttributeValues = typeof OtelSpanAttributes[keyof typeof OtelSpanAttributes];\n","import { OBSERVABILITY_TRACER_NAME, OtelSpanAttributes } from \"./constants.js\";\nimport { SemanticConventions } from \"@arizeai/openinference-semantic-conventions\";\nimport { ObservationAttributes, TraceAttributes, ObservationType } from \"../types.js\";\nimport { type Attributes } from \"@opentelemetry/api\";\n\n/**\n * Creates OpenTelemetry attributes from trace attributes.\n *\n * Converts user-friendly trace attributes into OpenTelemetry attribute format\n * using OpenInference semantic conventions where applicable.\n *\n * @param attributes - Trace attributes to convert\n * @returns OpenTelemetry attributes object\n *\n * @example\n * ```typescript\n * const otelAttributes = createTraceAttributes({\n *   name: 'user-workflow',\n *   userId: 'user-123',\n *   sessionId: 'session-456',\n *   tags: ['checkout', 'payment']\n * });\n * ```\n *\n * @public\n */\nexport function createTraceAttributes({\n  name,\n  userId,\n  sessionId,\n  version,\n  release,\n  input,\n  output,\n  metadata,\n  tags,\n  environment,\n  public: isPublic,\n}: TraceAttributes = {}): Attributes {\n  const attributes = {\n    [OtelSpanAttributes.TRACE_NAME]: name,\n    // Use OpenInference standard attributes for user and session\n    [OtelSpanAttributes.USER_ID]: userId,\n    [OtelSpanAttributes.SESSION_ID]: sessionId,\n    [OtelSpanAttributes.VERSION]: version,\n    [OtelSpanAttributes.RELEASE]: release,\n    [OtelSpanAttributes.TRACE_INPUT]: _serialize(input),\n    [OtelSpanAttributes.TRACE_OUTPUT]: _serialize(output),\n    [OtelSpanAttributes.TRACE_TAGS]: tags,\n    [OtelSpanAttributes.ENVIRONMENT]: environment,\n    [OtelSpanAttributes.TRACE_PUBLIC]: isPublic,\n    ..._flattenAndSerializeMetadata(metadata, OtelSpanAttributes.TRACE_METADATA),\n  };\n\n  return Object.fromEntries(\n    Object.entries(attributes).filter(([_, v]) => v != null),\n  );\n}\n\n/**\n * Creates OpenTelemetry attributes from observation attributes.\n *\n * Maps observation attributes to OpenInference semantic conventions:\n * - Uses `openinference.span.kind` for span type\n * - Uses `llm.*` for LLM-specific attributes\n * - Uses `tool.*` for tool-specific attributes\n * - Falls back to `agkit.observation.*` for non-standard attributes\n *\n * @param type - Observation type (llm, tool, chain, etc.)\n * @param attributes - Observation attributes to convert\n * @returns OpenTelemetry attributes object\n *\n * @public\n */\nexport function createObservationAttributes(\n  type: ObservationType,\n  attributes: ObservationAttributes,\n): Attributes {\n  const {\n    metadata,\n    input,\n    output,\n    level,\n    statusMessage,\n    version,\n    completionStartTime,\n    model,\n    modelParameters,\n    usageDetails,\n  } = attributes;\n\n  // Base attributes for all observation types\n  const otelAttributes: Attributes = {\n    [SemanticConventions.OPENINFERENCE_SPAN_KIND]: type.toUpperCase(),\n    [OtelSpanAttributes.OBSERVATION_TYPE]: type,\n    [OtelSpanAttributes.OBSERVATION_LEVEL]: level,\n    [OtelSpanAttributes.OBSERVATION_STATUS_MESSAGE]: statusMessage,\n    [OtelSpanAttributes.VERSION]: version,\n    // Use OpenInference input.value convention\n    [SemanticConventions.INPUT_VALUE]: _serialize(input),\n    // Also set legacy agkit.observation.input for compatibility\n    [OtelSpanAttributes.OBSERVATION_INPUT]: _serialize(input),\n    // Use OpenInference output.value convention\n    [SemanticConventions.OUTPUT_VALUE]: _serialize(output),\n    // Also set legacy agkit.observation.output for compatibility\n    [OtelSpanAttributes.OBSERVATION_OUTPUT]: _serialize(output),\n  };\n\n  // LLM-specific attributes\n  if (type === \"llm\") {\n    if (model) {\n      otelAttributes[SemanticConventions.LLM_MODEL_NAME] = model;\n    }\n    if (modelParameters) {\n      otelAttributes[SemanticConventions.LLM_INVOCATION_PARAMETERS] =\n        _serialize(modelParameters);\n      // Also set agkit.llm.model_parameters for compatibility\n      otelAttributes[OtelSpanAttributes.LLM_MODEL_PARAMETERS] =\n        _serialize(modelParameters);\n    }\n    if (usageDetails) {\n      // Map to OpenInference llm.token_count.* attributes\n      if (typeof usageDetails === \"object\") {\n        const usage = usageDetails as Record<string, number>;\n        if (usage.promptTokens !== undefined) {\n          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_PROMPT] =\n            usage.promptTokens;\n        }\n        if (usage.completionTokens !== undefined) {\n          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_COMPLETION] =\n            usage.completionTokens;\n        }\n        if (usage.totalTokens !== undefined) {\n          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_TOTAL] =\n            usage.totalTokens;\n        }\n      }\n      // Also set legacy agkit.llm.usage_details for compatibility\n      otelAttributes[OtelSpanAttributes.LLM_USAGE_DETAILS] =\n        _serialize(usageDetails);\n    }\n    if (completionStartTime) {\n      otelAttributes[OtelSpanAttributes.LLM_COMPLETION_START_TIME] =\n        _serialize(completionStartTime);\n    }\n  }\n\n  // Embedding-specific attributes\n  if (type === \"embedding\") {\n    if (model) {\n      otelAttributes[SemanticConventions.EMBEDDING_MODEL_NAME] = model;\n    }\n    if (modelParameters) {\n      otelAttributes[SemanticConventions.LLM_INVOCATION_PARAMETERS] =\n        _serialize(modelParameters);\n    }\n  }\n\n  // Add metadata (use OpenInference metadata convention)\n  const metadataAttrs = _flattenAndSerializeMetadata(\n    metadata,\n    SemanticConventions.METADATA,\n  );\n  Object.assign(otelAttributes, metadataAttrs);\n\n  // Also add agkit.observation.metadata for compatibility\n  const obsetvabilityMetadataAttrs = _flattenAndSerializeMetadata(\n    metadata,\n    OtelSpanAttributes.OBSERVATION_METADATA\n  );\n  Object.assign(otelAttributes, obsetvabilityMetadataAttrs);\n\n  // Filter out null/undefined values\n  return Object.fromEntries(\n    Object.entries(otelAttributes).filter(([_, v]) => v != null),\n  );\n}\n\n/**\n * Safely serializes an object to JSON string.\n *\n * @param obj - Object to serialize\n * @returns JSON string or undefined if null/undefined\n * @internal\n */\nfunction _serialize(obj: unknown): string | undefined {\n  try {\n    if (typeof obj === \"string\") return obj;\n    if (obj instanceof Date) return obj.toISOString();\n    return obj != null ? JSON.stringify(obj) : undefined;\n  } catch {\n    return \"<failed to serialize>\";\n  }\n}\n\n/**\n * Flattens and serializes metadata into OpenTelemetry attribute format.\n *\n * Converts nested metadata objects into dot-notation attribute keys.\n * For example, `{ database: { host: 'localhost' } }` becomes\n * `{ 'metadata.database.host': 'localhost' }` (or 'agkit.observation.metadata.database.host').\n *\n * @param metadata - Metadata object to flatten\n * @param prefix - Attribute prefix (e.g., 'metadata' or 'agkit.observation.metadata')\n * @returns Flattened metadata attributes\n * @internal\n */\nfunction _flattenAndSerializeMetadata(\n  metadata: unknown,\n  prefix: string,\n): Record<string, string> {\n  const metadataAttributes: Record<string, string> = {};\n\n  if (metadata === undefined || metadata === null) {\n    return metadataAttributes;\n  }\n\n  if (typeof metadata !== \"object\" || Array.isArray(metadata)) {\n    const serialized = _serialize(metadata);\n    if (serialized) {\n      metadataAttributes[prefix] = serialized;\n    }\n  } else {\n    for (const [key, value] of Object.entries(metadata)) {\n      const serialized = typeof value === \"string\" ? value : _serialize(value);\n      if (serialized) {\n        metadataAttributes[`${prefix}.${key}`] = serialized;\n      }\n    }\n  }\n\n  return metadataAttributes;\n}\n","import { TracerProvider, trace, context } from \"@opentelemetry/api\";\n\nconst OBSERVABILITY_GLOBAL_SYMBOL = Symbol.for(\"observability\");\n\ntype ObservabilityGlobalState = {\n  isolatedTracerProvider: TracerProvider | null;\n};\n\nfunction createState(): ObservabilityGlobalState {\n  return {\n    isolatedTracerProvider: null,\n  };\n}\n\ninterface GlobalThis {\n  [OBSERVABILITY_GLOBAL_SYMBOL]?: ObservabilityGlobalState;\n}\n\n/**\n * Gets the global state for tracing observability.\n *\n * @returns The global state object\n * @internal\n */\nfunction getObservabilityGlobalState(): ObservabilityGlobalState {\n  const initialState = createState();\n\n  try {\n    const g = globalThis as typeof globalThis & GlobalThis;\n\n    if (typeof g !== \"object\" || g === null) {\n      console.warn(\n        \"[Observability] globalThis is not available, using fallback state\",\n      );\n      return initialState;\n    }\n\n    if (!g[OBSERVABILITY_GLOBAL_SYMBOL]) {\n      Object.defineProperty(g, OBSERVABILITY_GLOBAL_SYMBOL, {\n        value: initialState,\n        writable: false,\n        configurable: false,\n        enumerable: false,\n      });\n    }\n\n    return g[OBSERVABILITY_GLOBAL_SYMBOL]!;\n  } catch (err) {\n    console.error(\n      `[Observability] Failed to access global state: ${err instanceof Error ? err.message : String(err)}`,\n    );\n    return initialState;\n  }\n}\n\n/**\n * Sets an isolated TracerProvider for tracing tracing operations.\n *\n * This allows tracing to use its own TracerProvider instance, separate from\n * the global OpenTelemetry TracerProvider.\n *\n * Note: While this isolates span processing and export, it does NOT provide\n * complete trace isolation. OpenTelemetry context (trace IDs, parent spans)\n * is still shared between the global and isolated providers.\n *\n * @param provider - The TracerProvider instance to use, or null to clear\n *\n * @example\n * ```typescript\n * import { NodeTracerProvider } from '@opentelemetry/sdk-trace-node';\n * import { setTracerProvider } from './observability';\n *\n * const provider = new NodeTracerProvider();\n * setTracerProvider(provider);\n * ```\n *\n * @public\n */\nexport function setTracerProvider(provider: TracerProvider | null) {\n  getObservabilityGlobalState().isolatedTracerProvider = provider;\n}\n\n/**\n * Gets the TracerProvider for tracing tracing operations.\n *\n * Returns the isolated TracerProvider if one has been set via setTracerProvider(),\n * otherwise falls back to the global OpenTelemetry TracerProvider.\n *\n * @returns The TracerProvider instance to use for tracing tracing\n *\n * @example\n * ```typescript\n * import { getTracerProvider } from './observability';\n *\n * const provider = getTracerProvider();\n * const tracer = provider.getTracer('my-tracer', '1.0.0');\n * ```\n *\n * @public\n */\nexport function getTracerProvider(): TracerProvider {\n  const { isolatedTracerProvider } = getObservabilityGlobalState();\n\n  if (isolatedTracerProvider) return isolatedTracerProvider;\n\n  return trace.getTracerProvider();\n}\n\n/**\n * Gets the OpenTelemetry tracer instance for tracing.\n *\n * Returns a tracer specifically configured for tracing with the correct\n * tracer name and version.\n *\n * @returns The tracing OpenTelemetry tracer instance\n *\n * @example\n * ```typescript\n * import { getTracer } from './observability';\n *\n * const tracer = getTracer();\n * const span = tracer.startSpan('my-operation');\n * ```\n *\n * @public\n */\nexport function getTracer() {\n  return getTracerProvider().getTracer(\n    OBSERVABILITY_SDK_NAME,\n    OBSERVABILITY_SDK_VERSION\n  );\n}\n\n// SDK version - could be read from package.json in production\nconst OBSERVABILITY_SDK_NAME = \"ag-kit-observability\";\nconst OBSERVABILITY_SDK_VERSION = \"0.1.0\";\n","import { Span, TimeInput } from \"@opentelemetry/api\";\n\nimport { createObservationAttributes, createTraceAttributes } from \"./attributes.js\";\nimport { getTracer } from \"./tracerProvider.js\";\nimport {\n  BaseSpanAttributes,\n  LLMAttributes,\n  TraceAttributes,\n  ObservationType,\n} from \"../types.js\";\nimport type {\n  ToolAttributes,\n  AgentAttributes,\n  ChainAttributes,\n  RetrieverAttributes,\n  RerankerAttributes,\n  EvaluatorAttributes,\n  GuardrailAttributes,\n  EmbeddingAttributes,\n  ObservationAttributes,\n} from \"../types.js\";\n\n/**\n * Union type representing any observation wrapper.\n *\n * @public\n */\nexport type Observation =\n  | ObservationSpan\n  | ObservationLLM\n  | ObservationEmbedding\n  | ObservationAgent\n  | ObservationTool\n  | ObservationChain\n  | ObservationRetriever\n  | ObservationReranker\n  | ObservationEvaluator\n  | ObservationGuardrail;\n\n/**\n * Parameters for creating an observation wrapper.\n *\n * @internal\n */\ntype ObservationParams = {\n  otelSpan: Span;\n  type: ObservationType;\n  attributes?: BaseSpanAttributes | LLMAttributes;\n};\n\n/**\n * Base class for all observation wrappers.\n *\n * Provides common functionality for all observation types including:\n * - OpenTelemetry span integration\n * - Unique identification (span ID, trace ID)\n * - Lifecycle management (update, end)\n * - Trace context management\n * - Child observation creation\n *\n * @internal\n */\nabstract class BaseObservation {\n  /** The underlying OpenTelemetry span */\n  public readonly otelSpan: Span;\n  /** The observation type */\n  public readonly type: ObservationType;\n  /** The span ID from the OpenTelemetry span context */\n  public id: string;\n  /** The trace ID from the OpenTelemetry span context */\n  public traceId: string;\n\n  constructor(params: ObservationParams) {\n    this.otelSpan = params.otelSpan;\n    this.id = params.otelSpan.spanContext().spanId;\n    this.traceId = params.otelSpan.spanContext().traceId;\n    this.type = params.type;\n\n    if (params.attributes) {\n      this.otelSpan.setAttributes(\n        createObservationAttributes(params.type, params.attributes),\n      );\n    }\n  }\n\n  /** Gets the AG-Kit OpenTelemetry tracer instance */\n  protected get tracer() {\n    return getTracer();\n  }\n\n  /**\n   * Ends the observation, marking it as complete.\n   *\n   * @param endTime - Optional end time, defaults to current time\n   */\n  public end(endTime?: TimeInput) {\n    this.otelSpan.end(endTime);\n  }\n\n  /**\n   * Updates the OTEL span attributes.\n   *\n   * @param attributes - Attributes to update\n   * @internal\n   */\n  updateOtelSpanAttributes(attributes: ObservationAttributes) {\n    this.otelSpan.setAttributes(\n      createObservationAttributes(this.type, attributes),\n    );\n  }\n\n  /**\n   * Updates the parent trace with new attributes.\n   *\n   * @param attributes - Trace attributes to set\n   * @returns This observation for method chaining\n   */\n  public updateTrace(attributes: TraceAttributes) {\n    this.otelSpan.setAttributes(createTraceAttributes(attributes));\n    return this;\n  }\n\n  /**\n   * Creates a new child observation within this observation's context.\n   *\n   * @param name - Name for the child observation\n   * @param attributes - Type-specific attributes\n   * @param options - Configuration including observation type\n   * @returns Child observation instance\n   */\n  public startObservation(\n    name: string,\n    attributes: LLMAttributes,\n    options: { asType: \"llm\" },\n  ): ObservationLLM;\n  public startObservation(\n    name: string,\n    attributes: EmbeddingAttributes,\n    options: { asType: \"embedding\" },\n  ): ObservationEmbedding;\n  public startObservation(\n    name: string,\n    attributes: AgentAttributes,\n    options: { asType: \"agent\" },\n  ): ObservationAgent;\n  public startObservation(\n    name: string,\n    attributes: ToolAttributes,\n    options: { asType: \"tool\" },\n  ): ObservationTool;\n  public startObservation(\n    name: string,\n    attributes: ChainAttributes,\n    options: { asType: \"chain\" },\n  ): ObservationChain;\n  public startObservation(\n    name: string,\n    attributes: RetrieverAttributes,\n    options: { asType: \"retriever\" },\n  ): ObservationRetriever;\n  public startObservation(\n    name: string,\n    attributes: RerankerAttributes,\n    options: { asType: \"reranker\" },\n  ): ObservationReranker;\n  public startObservation(\n    name: string,\n    attributes: EvaluatorAttributes,\n    options: { asType: \"evaluator\" },\n  ): ObservationEvaluator;\n  public startObservation(\n    name: string,\n    attributes: GuardrailAttributes,\n    options: { asType: \"guardrail\" },\n  ): ObservationGuardrail;\n  public startObservation(\n    name: string,\n    attributes?: BaseSpanAttributes,\n    options?: { asType?: \"span\" },\n  ): ObservationSpan;\n  public startObservation(\n    name: string,\n    attributes?:\n      | BaseSpanAttributes\n      | LLMAttributes\n      | ToolAttributes\n      | AgentAttributes\n      | ChainAttributes\n      | RetrieverAttributes\n      | RerankerAttributes\n      | EvaluatorAttributes\n      | GuardrailAttributes\n      | EmbeddingAttributes,\n    options?: { asType?: ObservationType },\n  ): Observation {\n    // Import here to avoid circular dependency\n    const { startObservation: startObs } = require(\"../index.js\");\n    const { asType = \"span\" } = options || {};\n\n    return startObs(name, attributes, {\n      asType: asType as \"span\",\n      parentSpanContext: this.otelSpan.spanContext(),\n    });\n  }\n}\n\n// Type-specific observation classes\n\ntype ObservationSpanParams = {\n  otelSpan: Span;\n  attributes?: BaseSpanAttributes;\n};\n\n/**\n * General-purpose observation for tracking operations.\n *\n * @public\n */\nexport class ObservationSpan extends BaseObservation {\n  constructor(params: ObservationSpanParams) {\n    super({ ...params, type: \"span\" });\n  }\n\n  public update(attributes: BaseSpanAttributes): ObservationSpan {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationLLMParams = {\n  otelSpan: Span;\n  attributes?: LLMAttributes;\n};\n\n/**\n * LLM observation for tracking language model calls.\n *\n * @public\n */\nexport class ObservationLLM extends BaseObservation {\n  constructor(params: ObservationLLMParams) {\n    super({ ...params, type: \"llm\" });\n  }\n\n  public update(attributes: LLMAttributes): ObservationLLM {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationEmbeddingParams = {\n  otelSpan: Span;\n  attributes?: EmbeddingAttributes;\n};\n\n/**\n * Embedding observation for tracking embedding operations.\n *\n * @public\n */\nexport class ObservationEmbedding extends BaseObservation {\n  constructor(params: ObservationEmbeddingParams) {\n    super({ ...params, type: \"embedding\" });\n  }\n\n  public update(attributes: EmbeddingAttributes): ObservationEmbedding {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationAgentParams = {\n  otelSpan: Span;\n  attributes?: AgentAttributes;\n};\n\n/**\n * Agent observation for tracking AI agent workflows.\n *\n * @public\n */\nexport class ObservationAgent extends BaseObservation {\n  constructor(params: ObservationAgentParams) {\n    super({ ...params, type: \"agent\" });\n  }\n\n  public update(attributes: AgentAttributes): ObservationAgent {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationToolParams = {\n  otelSpan: Span;\n  attributes?: ToolAttributes;\n};\n\n/**\n * Tool observation for tracking tool calls.\n *\n * @public\n */\nexport class ObservationTool extends BaseObservation {\n  constructor(params: ObservationToolParams) {\n    super({ ...params, type: \"tool\" });\n  }\n\n  public update(attributes: ToolAttributes): ObservationTool {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationChainParams = {\n  otelSpan: Span;\n  attributes?: ChainAttributes;\n};\n\n/**\n * Chain observation for tracking multi-step workflows.\n *\n * @public\n */\nexport class ObservationChain extends BaseObservation {\n  constructor(params: ObservationChainParams) {\n    super({ ...params, type: \"chain\" });\n  }\n\n  public update(attributes: ChainAttributes): ObservationChain {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationRetrieverParams = {\n  otelSpan: Span;\n  attributes?: RetrieverAttributes;\n};\n\n/**\n * Retriever observation for tracking document retrieval.\n *\n * @public\n */\nexport class ObservationRetriever extends BaseObservation {\n  constructor(params: ObservationRetrieverParams) {\n    super({ ...params, type: \"retriever\" });\n  }\n\n  public update(attributes: RetrieverAttributes): ObservationRetriever {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationRerankerParams = {\n  otelSpan: Span;\n  attributes?: RerankerAttributes;\n};\n\n/**\n * Reranker observation for tracking reranking operations.\n *\n * @public\n */\nexport class ObservationReranker extends BaseObservation {\n  constructor(params: ObservationRerankerParams) {\n    super({ ...params, type: \"reranker\" });\n  }\n\n  public update(attributes: RerankerAttributes): ObservationReranker {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationEvaluatorParams = {\n  otelSpan: Span;\n  attributes?: EvaluatorAttributes;\n};\n\n/**\n * Evaluator observation for tracking evaluation operations.\n *\n * @public\n */\nexport class ObservationEvaluator extends BaseObservation {\n  constructor(params: ObservationEvaluatorParams) {\n    super({ ...params, type: \"evaluator\" });\n  }\n\n  public update(attributes: EvaluatorAttributes): ObservationEvaluator {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationGuardrailParams = {\n  otelSpan: Span;\n  attributes?: GuardrailAttributes;\n};\n\n/**\n * Guardrail observation for tracking safety checks.\n *\n * @public\n */\nexport class ObservationGuardrail extends BaseObservation {\n  constructor(params: ObservationGuardrailParams) {\n    super({ ...params, type: \"guardrail\" });\n  }\n\n  public update(attributes: GuardrailAttributes): ObservationGuardrail {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n","/**\n * Observability - OpenTelemetry-based tracing with OpenInference semantic conventions\n *\n * @packageDocumentation\n */\n\nimport { trace, context, TimeInput, SpanStatusCode, Span, SpanContext } from \"@opentelemetry/api\";\n\nimport {\n  createObservationAttributes,\n  createTraceAttributes,\n} from \"./core/attributes.js\";\nimport {\n  ObservationSpan,\n  ObservationLLM,\n  ObservationEmbedding,\n  ObservationAgent,\n  ObservationTool,\n  ObservationChain,\n  ObservationRetriever,\n  ObservationReranker,\n  ObservationEvaluator,\n  ObservationGuardrail,\n  type Observation,\n} from \"./core/spanWrapper.js\";\nimport { getTracer } from \"./core/tracerProvider.js\";\nimport {\n  ObservationType,\n  ObservationLevel,\n  BaseSpanAttributes,\n  LLMAttributes,\n  ToolAttributes,\n  AgentAttributes,\n  ChainAttributes,\n  RetrieverAttributes,\n  RerankerAttributes,\n  EvaluatorAttributes,\n  GuardrailAttributes,\n  EmbeddingAttributes,\n  ObservationAttributes,\n  TraceAttributes,\n} from \"./types.js\";\n\n// Export types\nexport type {\n  ObservationType,\n  ObservationLevel,\n  BaseSpanAttributes,\n  LLMAttributes,\n  ToolAttributes,\n  AgentAttributes,\n  ChainAttributes,\n  RetrieverAttributes,\n  RerankerAttributes,\n  EvaluatorAttributes,\n  GuardrailAttributes,\n  EmbeddingAttributes,\n  ObservationAttributes,\n  TraceAttributes,\n};\n\n// Export observation classes\nexport {\n  ObservationSpan,\n  ObservationLLM,\n  ObservationEmbedding,\n  ObservationAgent,\n  ObservationTool,\n  ObservationChain,\n  ObservationRetriever,\n  ObservationReranker,\n  ObservationEvaluator,\n  ObservationGuardrail,\n};\n\n// Export observation union type\nexport type { Observation };\n\n// Export core functions\nexport {\n  createTraceAttributes,\n  createObservationAttributes,\n} from \"./core/attributes.js\";\nexport {\n  setTracerProvider,\n  getTracerProvider,\n  getTracer,\n} from \"./core/tracerProvider.js\";\n\n/**\n * Options for starting observations (spans).\n *\n * @public\n */\nexport type StartObservationOptions = {\n  /** Custom start time for the observation */\n  startTime?: Date;\n  /** Parent span context to attach this observation to */\n  parentSpanContext?: SpanContext;\n};\n\n/**\n * Options for startObservation function.\n *\n * @public\n */\nexport type StartObservationOpts = StartObservationOptions & {\n  /** Type of observation to create. Defaults to 'span' */\n  asType?: ObservationType;\n};\n\n/**\n * Creates an OpenTelemetry span with the AG-Kit tracer.\n *\n * @param params - Parameters for span creation\n * @returns The created OpenTelemetry span\n * @internal\n */\nfunction createOtelSpan(params: {\n  name: string;\n  startTime?: TimeInput;\n  parentSpanContext?: SpanContext;\n}): Span {\n  return getTracer().startSpan(\n    params.name,\n    { startTime: params.startTime },\n    createParentContext(params.parentSpanContext),\n  );\n}\n\n/**\n * Creates a parent context from a span context.\n *\n * @param parentSpanContext - The span context to use as parent\n * @returns The created context or undefined if no parent provided\n * @internal\n */\nfunction createParentContext(\n  parentSpanContext?: SpanContext,\n): ReturnType<typeof trace.setSpanContext> | undefined {\n  if (!parentSpanContext) return;\n  return trace.setSpanContext(context.active(), parentSpanContext);\n}\n\n// Function overloads for proper type inference\n// Generic overload for dynamic asType (returns Observation union)\nexport function startObservation(\n  name: string,\n  attributes?: BaseSpanAttributes,\n  options?: StartObservationOpts & { asType?: ObservationType },\n): Observation;\n\n// Type-specific overloads for precise type inference\nexport function startObservation(\n  name: string,\n  attributes: LLMAttributes,\n  options: StartObservationOpts & { asType: \"llm\" },\n): ObservationLLM;\nexport function startObservation(\n  name: string,\n  attributes: EmbeddingAttributes,\n  options: StartObservationOpts & { asType: \"embedding\" },\n): ObservationEmbedding;\nexport function startObservation(\n  name: string,\n  attributes: AgentAttributes,\n  options: StartObservationOpts & { asType: \"agent\" },\n): ObservationAgent;\nexport function startObservation(\n  name: string,\n  attributes: ToolAttributes,\n  options: StartObservationOpts & { asType: \"tool\" },\n): ObservationTool;\nexport function startObservation(\n  name: string,\n  attributes: ChainAttributes,\n  options: StartObservationOpts & { asType: \"chain\" },\n): ObservationChain;\nexport function startObservation(\n  name: string,\n  attributes: RetrieverAttributes,\n  options: StartObservationOpts & { asType: \"retriever\" },\n): ObservationRetriever;\nexport function startObservation(\n  name: string,\n  attributes: RerankerAttributes,\n  options: StartObservationOpts & { asType: \"reranker\" },\n): ObservationReranker;\nexport function startObservation(\n  name: string,\n  attributes: EvaluatorAttributes,\n  options: StartObservationOpts & { asType: \"evaluator\" },\n): ObservationEvaluator;\nexport function startObservation(\n  name: string,\n  attributes: GuardrailAttributes,\n  options: StartObservationOpts & { asType: \"guardrail\" },\n): ObservationGuardrail;\nexport function startObservation(\n  name: string,\n  attributes?: BaseSpanAttributes,\n  options?: StartObservationOpts & { asType?: \"span\" },\n): ObservationSpan;\n\n/**\n * Creates and starts a new AG-Kit observation.\n *\n * Supports multiple observation types with full TypeScript type safety:\n * - **span**: General-purpose operations (default)\n * - **llm**: LLM calls and AI model interactions\n * - **embedding**: Text embedding and vector operations\n * - **agent**: AI agent workflows\n * - **tool**: Individual tool calls\n * - **chain**: Multi-step processes\n * - **retriever**: Document retrieval\n * - **reranker**: Result reranking\n * - **evaluator**: Quality assessment\n * - **guardrail**: Safety checks\n *\n * @param name - Descriptive name for the observation\n * @param attributes - Type-specific attributes\n * @param options - Configuration options\n * @returns Strongly-typed observation object\n *\n * @example\n * ```typescript\n * import { startObservation } from './observability';\n *\n * // LLM observation\n * const llm = startObservation('openai-gpt-4', {\n *   input: [{ role: 'user', content: 'Hello' }],\n *   model: 'gpt-4',\n *   modelParameters: { temperature: 0.7 }\n * }, { asType: 'llm' });\n *\n * // Tool observation\n * const tool = startObservation('weather-api', {\n *   input: { location: 'SF' }\n * }, { asType: 'tool' });\n *\n * // Chain observation\n * const chain = startObservation('rag-pipeline', {\n *   input: { question: 'What is AI?' }\n * }, { asType: 'chain' });\n * ```\n *\n * @public\n */\nexport function startObservation(\n  name: string,\n  attributes?:\n    | BaseSpanAttributes\n    | LLMAttributes\n    | EmbeddingAttributes\n    | AgentAttributes\n    | ToolAttributes\n    | ChainAttributes\n    | RetrieverAttributes\n    | RerankerAttributes\n    | EvaluatorAttributes\n    | GuardrailAttributes,\n  options?: StartObservationOpts,\n): Observation {\n  const { asType = \"span\", ...observationOptions } = options || {};\n\n  const otelSpan = createOtelSpan({\n    name,\n    ...observationOptions,\n  });\n\n  switch (asType) {\n    case \"llm\":\n      return new ObservationLLM({\n        otelSpan,\n        attributes: attributes as LLMAttributes,\n      });\n\n    case \"embedding\":\n      return new ObservationEmbedding({\n        otelSpan,\n        attributes: attributes as EmbeddingAttributes,\n      });\n\n    case \"agent\":\n      return new ObservationAgent({\n        otelSpan,\n        attributes: attributes as AgentAttributes,\n      });\n\n    case \"tool\":\n      return new ObservationTool({\n        otelSpan,\n        attributes: attributes as ToolAttributes,\n      });\n\n    case \"chain\":\n      return new ObservationChain({\n        otelSpan,\n        attributes: attributes as ChainAttributes,\n      });\n\n    case \"retriever\":\n      return new ObservationRetriever({\n        otelSpan,\n        attributes: attributes as RetrieverAttributes,\n      });\n\n    case \"reranker\":\n      return new ObservationReranker({\n        otelSpan,\n        attributes: attributes as RerankerAttributes,\n      });\n\n    case \"evaluator\":\n      return new ObservationEvaluator({\n        otelSpan,\n        attributes: attributes as EvaluatorAttributes,\n      });\n\n    case \"guardrail\":\n      return new ObservationGuardrail({\n        otelSpan,\n        attributes: attributes as GuardrailAttributes,\n      });\n\n    case \"span\":\n    default:\n      return new ObservationSpan({\n        otelSpan,\n        attributes: attributes as BaseSpanAttributes,\n      });\n  }\n}\n\n/**\n * Updates the currently active trace with new attributes.\n *\n * @param attributes - Trace attributes to set\n *\n * @example\n * ```typescript\n * import { updateActiveTrace } from './observability';\n *\n * updateActiveTrace({\n *   name: 'user-workflow',\n *   userId: 'user-123',\n *   tags: ['production']\n * });\n * ```\n *\n * @public\n */\nexport function updateActiveTrace(attributes: TraceAttributes) {\n  const span = trace.getActiveSpan();\n\n  if (!span) {\n    console.warn(\n      \"[Observability] No active OTEL span in context. Skipping trace update.\",\n    );\n    return;\n  }\n\n  span.setAttributes(createTraceAttributes(attributes));\n}\n\n/**\n * Gets the current active trace ID.\n *\n * @returns The trace ID of the currently active span, or undefined\n *\n * @public\n */\nexport function getActiveTraceId(): string | undefined {\n  return trace.getActiveSpan()?.spanContext().traceId;\n}\n\n/**\n * Gets the current active observation ID.\n *\n * @returns The span ID of the currently active span, or undefined\n *\n * @public\n */\nexport function getActiveSpanId(): string | undefined {\n  return trace.getActiveSpan()?.spanContext().spanId;\n}\n\n// ============================================================================\n// Active Observation Functions\n// ============================================================================\n\n/**\n * Options for startActiveObservation.\n *\n * @public\n */\nexport type StartActiveObservationOpts = StartObservationOpts & {\n  /** Whether to automatically end the observation when the function exits. Default: true */\n  endOnExit?: boolean;\n};\n\n/**\n * Wraps a Promise to automatically end the span when it resolves/rejects.\n *\n * @param promise - The promise to wrap\n * @param span - The OpenTelemetry span\n * @param endOnExit - Whether to end the span on exit\n * @returns The wrapped promise\n * @internal\n */\nfunction wrapPromise<T>(\n  promise: Promise<T>,\n  span: Span,\n  endOnExit: boolean | undefined,\n): Promise<T> {\n  return promise.then(\n    (value) => {\n      if (endOnExit !== false) {\n        span.end();\n      }\n      return value;\n    },\n    (err: unknown) => {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err instanceof Error ? err.message : \"Unknown error\",\n      });\n      if (endOnExit !== false) {\n        span.end();\n      }\n      throw err;\n    },\n  );\n}\n\n// Function overloads for startActiveObservation\nexport function startActiveObservation<\n  F extends (observation: ObservationSpan) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationLLM) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationEmbedding) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationAgent) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationTool) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationChain) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationRetriever) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationReranker) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationEvaluator) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationGuardrail) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\n\n/**\n * Creates an observation with automatic lifecycle management.\n *\n * This function creates an observation and executes a function with that observation\n * as a parameter. The observation is automatically ended when the function completes\n * (unless `endOnExit` is set to `false`).\n *\n * Supports both synchronous and asynchronous functions, with automatic error handling.\n *\n * @param name - Descriptive name for the observation\n * @param fn - Function to execute with the observation\n * @param options - Configuration options\n * @returns The result of the function\n *\n * @example\n * ```typescript\n * import { startActiveObservation } from './observability';\n *\n * // Synchronous function\n * const result = startActiveObservation('data-processing', (span) => {\n *   span.update({ input: { data: [1, 2, 3] } });\n *   const processed = data.map(x => x * 2);\n *   span.update({ output: { result: processed } });\n *   return processed;\n * }, { asType: 'span' });\n *\n * // Asynchronous function\n * const embeddings = await startActiveObservation(\n *   'text-embeddings',\n *   async (embedding) => {\n *     embedding.update({\n *       input: { texts: ['Hello', 'World'] },\n *       model: 'text-embedding-ada-002'\n *     });\n *\n *     const vectors = await generateEmbeddings(texts);\n *\n *     embedding.update({ output: { embeddings: vectors } });\n *     return vectors;\n *   },\n *   { asType: 'embedding' }\n * );\n *\n * // Disable automatic ending (for long-running operations)\n * startActiveObservation(\n *   'background-task',\n *   (span) => {\n *     span.update({ input: { taskId: '123' } });\n *     startBackgroundProcess(span);\n *     return 'started';\n *   },\n *   { asType: 'span', endOnExit: false }\n * );\n * ```\n *\n * @see {@link startObservation} for manual observation lifecycle management\n * @see {@link observe} for decorator-style function wrapping\n *\n * @public\n */\nexport function startActiveObservation<\n  F extends (observation: Observation) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F> {\n  const { asType = \"span\", endOnExit, ...observationOptions } = options || {};\n\n  return getTracer().startActiveSpan(\n    name,\n    { startTime: observationOptions?.startTime },\n    createParentContext(observationOptions?.parentSpanContext) ??\n      context.active(),\n    (span) => {\n      try {\n        let observation: Observation;\n\n        switch (asType) {\n          case \"llm\":\n            observation = new ObservationLLM({ otelSpan: span });\n            break;\n          case \"embedding\":\n            observation = new ObservationEmbedding({ otelSpan: span });\n            break;\n          case \"agent\":\n            observation = new ObservationAgent({ otelSpan: span });\n            break;\n          case \"tool\":\n            observation = new ObservationTool({ otelSpan: span });\n            break;\n          case \"chain\":\n            observation = new ObservationChain({ otelSpan: span });\n            break;\n          case \"retriever\":\n            observation = new ObservationRetriever({ otelSpan: span });\n            break;\n          case \"reranker\":\n            observation = new ObservationReranker({ otelSpan: span });\n            break;\n          case \"evaluator\":\n            observation = new ObservationEvaluator({ otelSpan: span });\n            break;\n          case \"guardrail\":\n            observation = new ObservationGuardrail({ otelSpan: span });\n            break;\n          case \"span\":\n          default:\n            observation = new ObservationSpan({ otelSpan: span });\n        }\n\n        const result = fn(observation as Parameters<F>[0]);\n\n        if (result instanceof Promise) {\n          return wrapPromise(\n            result,\n            span,\n            endOnExit,\n          ) as ReturnType<F>;\n        } else {\n          if (endOnExit !== false) {\n            span.end();\n          }\n          return result as ReturnType<F>;\n        }\n      } catch (err) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err instanceof Error ? err.message : \"Unknown error\",\n        });\n        if (endOnExit !== false) {\n          span.end();\n        }\n        throw err;\n      }\n    },\n  );\n}\n\n/**\n * Updates the currently active observation with new attributes.\n *\n * @param attributes - Observation attributes to set\n *\n * @example\n * ```typescript\n * import { updateActiveObservation } from './observability';\n *\n * // Within an active observation context\n * updateActiveObservation({\n *   metadata: { stage: 'processing' }\n * });\n * ```\n *\n * @public\n */\nexport function updateActiveObservation(\n  attributes: BaseSpanAttributes,\n): void {\n  const span = trace.getActiveSpan();\n\n  if (!span) {\n    console.warn(\n      \"[Observability] No active OTEL span in context. Skipping observation update.\",\n    );\n    return;\n  }\n\n  span.setAttributes(createObservationAttributes(\"span\", attributes));\n}\n\n// ============================================================================\n// Decorator Function\n// ============================================================================\n\n/**\n * Options for the observe decorator.\n *\n * @public\n */\nexport type ObserveOptions = Omit<StartObservationOpts, \"name\"> & {\n  /** Whether to capture function arguments as input. Default: true */\n  captureInput?: boolean;\n  /** Whether to capture return value as output. Default: true */\n  captureOutput?: boolean;\n};\n\n/**\n * Captures function arguments for observability input.\n *\n * @param args - Function arguments to capture\n * @returns Serialized arguments\n * @internal\n */\nfunction _captureArguments(args: unknown[]): Record<string, unknown> {\n  if (args.length === 0) return {};\n  if (args.length === 1) return { arg: args[0] };\n  return { args };\n}\n\n/**\n * Decorator function to add observability to any function.\n *\n * Wraps a function with automatic observation creation, input/output capture,\n * and lifecycle management. The observation is automatically ended when the\n * function completes.\n *\n * @param fn - Function to wrap\n * @param options - Configuration options\n * @returns Wrapped function with observability\n *\n * @example\n * ```typescript\n * import { observe } from './observability';\n *\n * // Wrap an existing function\n * const fetchData = observe(async (url: string) => {\n *   const response = await fetch(url);\n *   return response.json();\n * }, { asType: 'tool' });\n *\n * // Wrap with custom name\n * const processPayment = observe(\n *   async (amount: number, currency: string) => {\n *     return await paymentGateway.charge(amount, currency);\n *   },\n *   { name: 'payment-gateway-call', asType: 'tool' }\n * );\n *\n * // Class method decoration\n * class UserService {\n *   @observe({ asType: 'chain' })\n *   async getUser(id: string) {\n *     return await db.users.find(id);\n *   }\n * }\n * ```\n *\n * @public\n */\nexport function observe<T extends (...args: any[]) => any>(\n  fn: T,\n  options: ObserveOptions = {},\n): T {\n  const {\n    asType = \"span\",\n    captureInput = true,\n    captureOutput = true,\n    ...observationOptions\n  } = options;\n\n  const wrappedFunction = function (\n    this: any,\n    ...args: Parameters<T>\n  ): ReturnType<T> {\n    const name = fn.name || \"anonymous-function\";\n\n    // Prepare input data\n    const inputData = captureInput ? _captureArguments(args) : undefined;\n\n    // Create the observation\n    const observation = startObservation(\n      name,\n      inputData ? { input: inputData } : {},\n      {\n        ...observationOptions,\n        asType: asType as \"span\",\n      },\n    );\n\n    // Set the observation span as active in the context\n    const activeContext = trace.setSpan(context.active(), observation.otelSpan);\n\n    // Execute the function within the observation context\n    const result = context.with(activeContext, () => fn.apply(this, args));\n\n    // Handle promises\n    if (result instanceof Promise) {\n      return result.then(\n        (value) => {\n          if (captureOutput) {\n            observation.update({ output: value });\n          }\n          observation.end();\n          return value;\n        },\n        (err: unknown) => {\n          observation.update({\n            level: \"ERROR\",\n            statusMessage: err instanceof Error ? err.message : \"Unknown error\",\n          });\n          observation.end();\n          throw err;\n        },\n      ) as ReturnType<T>;\n    }\n\n    // Handle synchronous functions\n    if (captureOutput) {\n      observation.update({ output: result });\n    }\n    observation.end();\n\n    return result as ReturnType<T>;\n  };\n\n  // Preserve function properties\n  Object.defineProperty(wrappedFunction, \"name\", { value: fn.name });\n  Object.defineProperty(wrappedFunction, \"length\", { value: fn.length });\n\n  return wrappedFunction as T;\n}\n","/**\n * LangChain Callback Handler for AG-Kit Observability\n *\n * Converts LangChain callback events into AG-Kit observations with OpenInference semantics.\n */\n\nimport type { AgentAction, AgentFinish } from \"@langchain/core/agents\";\nimport { BaseCallbackHandler } from \"@langchain/core/callbacks/base\";\nimport type { Document } from \"@langchain/core/documents\";\nimport type { Serialized } from \"@langchain/core/load/serializable\";\nimport {\n  AIMessage,\n  AIMessageChunk,\n  BaseMessage,\n  type UsageMetadata,\n  type BaseMessageFields,\n  type MessageContent,\n} from \"@langchain/core/messages\";\nimport type { Generation, LLMResult } from \"@langchain/core/outputs\";\nimport type { ChainValues } from \"@langchain/core/utils/types\";\n\nimport {\n  startObservation,\n  type ObservationLLM,\n  type ObservationSpan,\n  type ObservationTool,\n  type Observation,\n  type ObservationAttributes,\n} from \"../index.js\";\nimport type { SpanContext } from \"@opentelemetry/api\";\nimport { type Logger, noopLogger } from \"@cloudbase/agent-shared\";\n\n/**\n * Constructor parameters for CallbackHandler.\n *\n * @public\n */\ntype ConstructorParams = {\n  userId?: string;\n  sessionId?: string;\n  tags?: string[];\n  version?: string;\n  traceMetadata?: Record<string, unknown>;\n  adapterName?: string;  // e.g., \"LangGraph\" or \"LangChain\"\n  /** Logger for debug output. Defaults to noopLogger (silent). */\n  logger?: Logger;\n};\n\n/**\n * Message format for LLM input/output.\n *\n * @public\n */\nexport type LlmMessage = {\n  role: string;\n  content: BaseMessageFields[\"content\"];\n  additional_kwargs?: BaseMessageFields[\"additional_kwargs\"];\n};\n\n/**\n * Anonymous message format (without role).\n *\n * @public\n */\nexport type AnonymousLlmMessage = {\n  content: BaseMessageFields[\"content\"];\n  additional_kwargs?: BaseMessageFields[\"additional_kwargs\"];\n};\n\n/**\n * Prompt information for linking to generations.\n *\n * @public\n */\ntype PromptInfo = {\n  name: string;\n  version: number;\n  isFallback: boolean;\n};\n\n/**\n * LangChain Callback Handler for AG-Kit Observability.\n *\n * This handler intercepts LangChain callbacks and converts them into\n * AG-Kit observations following OpenInference semantic conventions.\n *\n * @public\n */\nexport class CallbackHandler extends BaseCallbackHandler {\n  name = \"ObservabilityCallbackHandler\";\n\n  private userId?: string;\n  private version?: string;\n  private sessionId?: string;\n  private tags: string[];\n  private traceMetadata?: Record<string, unknown>;\n\n  private completionStartTimes: Record<string, Date> = {};\n  private promptToParentRunMap;\n  private runMap: Map<string, Observation> = new Map();\n\n  public last_trace_id: string | null = null;\n\n  // External parent context from AG-UI.Server span\n  private externalParentSpanContext?: SpanContext;\n\n  // Adapter name for ROOT span prefix\n  private adapterName?: string;\n\n  // Logger for debug output (defaults to noopLogger for silent operation)\n  private logger: Logger;\n\n  constructor(params?: ConstructorParams) {\n    super();\n\n    this.sessionId = params?.sessionId;\n    this.userId = params?.userId;\n    this.tags = params?.tags ?? [];\n    this.traceMetadata = params?.traceMetadata;\n    this.version = params?.version;\n    this.adapterName = params?.adapterName;\n    this.logger = params?.logger ?? noopLogger;\n\n    this.promptToParentRunMap = new Map<string, PromptInfo>();\n  }\n\n  /**\n   * Set external parent SpanContext from AG-UI.Server span.\n   * This allows the CallbackHandler to link LangChain/LangGraph spans\n   * to the server-level span, creating a unified trace hierarchy.\n   *\n   * @param spanContext - SpanContext from the AG-UI.Server span\n   * @public\n   */\n  setExternalParentContext(spanContext: SpanContext): void {\n    this.externalParentSpanContext = spanContext;\n  }\n\n  async handleLLMNewToken(\n    token: string,\n    _idx: any,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    _fields?: any\n  ): Promise<void> {\n    if (runId && !(runId in this.completionStartTimes)) {\n      this.logger.debug?.(`LLM first streaming token: ${runId}`);\n      this.completionStartTimes[runId] = new Date();\n    }\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    runType?: string,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Chain start with Id: ${runId}`);\n\n      const runName = name ?? chain.id.at(-1)?.toString() ?? \"Langchain Run\";\n\n      this.registerPromptInfo(parentRunId, metadata);\n\n      let finalInput: string | ChainValues = inputs;\n      if (\n        typeof inputs === \"object\" &&\n        \"input\" in inputs &&\n        Array.isArray(inputs[\"input\"]) &&\n        inputs[\"input\"].every((m: unknown) => m instanceof BaseMessage)\n      ) {\n        finalInput = inputs[\"input\"].map((m: BaseMessage) =>\n          this.extractChatMessageContent(m)\n        );\n      } else if (\n        typeof inputs === \"object\" &&\n        \"messages\" in inputs &&\n        Array.isArray(inputs[\"messages\"]) &&\n        inputs[\"messages\"].every((m: unknown) => m instanceof BaseMessage)\n      ) {\n        finalInput = inputs[\"messages\"].map((m: BaseMessage) =>\n          this.extractChatMessageContent(m)\n        );\n      } else if (\n        typeof inputs === \"object\" &&\n        \"content\" in inputs &&\n        typeof inputs[\"content\"] === \"string\"\n      ) {\n        finalInput = inputs[\"content\"];\n      }\n\n      const observation = this.startAndRegisterObservation({\n        runName,\n        parentRunId,\n        runId,\n        tags,\n        metadata,\n        attributes: {\n          input: finalInput,\n        },\n        asType: \"span\",\n      });\n\n      const traceTags = [...new Set([...(tags ?? []), ...this.tags])];\n\n      if (!parentRunId) {\n        observation.updateTrace({\n          tags: traceTags,\n          userId:\n            metadata &&\n            \"userId\" in metadata &&\n            typeof metadata[\"userId\"] === \"string\"\n              ? metadata[\"userId\"]\n              : this.userId,\n          sessionId:\n            metadata &&\n            \"sessionId\" in metadata &&\n            typeof metadata[\"sessionId\"] === \"string\"\n              ? metadata[\"sessionId\"]\n              : this.sessionId,\n          metadata: this.traceMetadata,\n          version: this.version,\n        });\n      }\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleAgentAction(\n    action: AgentAction,\n    runId: string,\n    parentRunId?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Agent action ${action.tool} with ID: ${runId}`);\n      this.startAndRegisterObservation({\n        runId,\n        parentRunId,\n        runName: action.tool,\n        attributes: {\n          input: action,\n        },\n        asType: \"tool\",\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleAgentEnd?(\n    action: AgentFinish,\n    runId: string,\n    _parentRunId?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Agent finish with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: { output: action },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleChainError(\n    err: any,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Chain error: ${err} with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          level: \"ERROR\",\n          statusMessage: err.toString(),\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleGenerationStart(\n    llm: Serialized,\n    messages: (LlmMessage | MessageContent | AnonymousLlmMessage)[],\n    runId: string,\n    parentRunId?: string | undefined,\n    extraParams?: Record<string, unknown> | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    this.logger.debug?.(\n      `Generation start with ID: ${runId} and parentRunId ${parentRunId}`\n    );\n\n    const runName = name ?? llm.id.at(-1)?.toString() ?? \"Langchain Generation\";\n\n    const modelParameters: Record<string, any> = {};\n    const invocationParams = extraParams?.[\"invocation_params\"];\n\n    for (const [key, value] of Object.entries({\n      temperature: (invocationParams as any)?.temperature,\n      max_tokens: (invocationParams as any)?.max_tokens,\n      top_p: (invocationParams as any)?.top_p,\n      frequency_penalty: (invocationParams as any)?.frequency_penalty,\n      presence_penalty: (invocationParams as any)?.presence_penalty,\n      request_timeout: (invocationParams as any)?.request_timeout,\n    })) {\n      if (value !== undefined && value !== null) {\n        modelParameters[key] = value;\n      }\n    }\n\n    interface InvocationParams {\n      _type?: string;\n      model?: string;\n      model_name?: string;\n      repo_id?: string;\n    }\n\n    let extractedModelName: string | undefined;\n    if (extraParams) {\n      const invocationParamsModelName = (\n        extraParams.invocation_params as InvocationParams\n      ).model;\n      const metadataModelName =\n        metadata && \"ls_model_name\" in metadata\n          ? (metadata[\"ls_model_name\"] as string)\n          : undefined;\n\n      extractedModelName = invocationParamsModelName ?? metadataModelName;\n    }\n\n    const registeredPrompt = this.promptToParentRunMap.get(\n      parentRunId ?? \"root\"\n    );\n    if (registeredPrompt && parentRunId) {\n      this.deregisterPromptInfo(parentRunId);\n    }\n\n    this.startAndRegisterObservation({\n      runId,\n      parentRunId,\n      metadata,\n      tags,\n      runName,\n      attributes: {\n        input: messages,\n        model: extractedModelName,\n        modelParameters: modelParameters,\n      },\n      asType: \"llm\",\n    });\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string | undefined,\n    extraParams?: Record<string, unknown> | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Chat model start with ID: ${runId}`);\n\n      const prompts = messages.flatMap((message) =>\n        message.map((m) => this.extractChatMessageContent(m))\n      );\n\n      this.handleGenerationStart(\n        llm,\n        prompts,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleChainEnd(\n    outputs: ChainValues,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Chain end with ID: ${runId}`);\n\n      let finalOutput: ChainValues | string = outputs;\n      if (\n        typeof outputs === \"object\" &&\n        \"output\" in outputs &&\n        typeof outputs[\"output\"] === \"string\"\n      ) {\n        finalOutput = outputs[\"output\"];\n      } else if (\n        typeof outputs === \"object\" &&\n        \"messages\" in outputs &&\n        Array.isArray(outputs[\"messages\"]) &&\n        outputs[\"messages\"].every((m: unknown) => m instanceof BaseMessage)\n      ) {\n        finalOutput = {\n          messages: outputs.messages.map((message: BaseMessage) =>\n            this.extractChatMessageContent(message)\n          ),\n        };\n      }\n\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          output: finalOutput,\n        },\n      });\n      this.deregisterPromptInfo(runId);\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string | undefined,\n    extraParams?: Record<string, unknown> | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`LLM start with ID: ${runId}`);\n      this.handleGenerationStart(\n        llm,\n        prompts,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Tool start with ID: ${runId}`);\n      this.startAndRegisterObservation({\n        runId,\n        parentRunId,\n        runName: name ?? tool.id.at(-1)?.toString() ?? \"Tool execution\",\n        attributes: {\n          input,\n        },\n        metadata,\n        tags,\n        asType: \"tool\",\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Retriever start with ID: ${runId}`);\n      this.startAndRegisterObservation({\n        runId,\n        parentRunId,\n        runName: name ?? retriever.id.at(-1)?.toString() ?? \"Retriever\",\n        attributes: {\n          input: query,\n        },\n        tags,\n        metadata,\n        asType: \"span\",\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleRetrieverEnd(\n    documents: Document<Record<string, any>>[],\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Retriever end with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          output: documents,\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleRetrieverError(\n    err: any,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Retriever error: ${err} with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          level: \"ERROR\",\n          statusMessage: err.toString(),\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleToolEnd(\n    output: string,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Tool end with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: { output },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleToolError(\n    err: any,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Tool error ${err} with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          level: \"ERROR\",\n          statusMessage: err.toString(),\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleLLMEnd(\n    output: LLMResult,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`LLM end with ID: ${runId}`);\n\n      const lastResponse =\n        output.generations[output.generations.length - 1][\n          output.generations[output.generations.length - 1].length - 1\n        ];\n      const llmUsage =\n        this.extractUsageMetadata(lastResponse) ??\n        output.llmOutput?.[\"tokenUsage\"];\n      const modelName = this.extractModelNameFromMetadata(lastResponse);\n\n      const usageDetails: Record<string, any> = {\n        input:\n          llmUsage?.input_tokens ??\n          (\"promptTokens\" in llmUsage ? llmUsage?.promptTokens : undefined),\n        output:\n          llmUsage?.output_tokens ??\n          (\"completionTokens\" in llmUsage\n            ? llmUsage?.completionTokens\n            : undefined),\n        total:\n          llmUsage?.total_tokens ??\n          (\"totalTokens\" in llmUsage ? llmUsage?.totalTokens : undefined),\n      };\n\n      if (llmUsage && \"input_token_details\" in llmUsage) {\n        for (const [key, val] of Object.entries(\n          llmUsage[\"input_token_details\"] ?? {}\n        )) {\n          usageDetails[`input_${key}`] = val;\n          if (\"input\" in usageDetails && typeof val === \"number\") {\n            usageDetails[\"input\"] = Math.max(0, usageDetails[\"input\"] - val);\n          }\n        }\n      }\n\n      if (llmUsage && \"output_token_details\" in llmUsage) {\n        for (const [key, val] of Object.entries(\n          llmUsage[\"output_token_details\"] ?? {}\n        )) {\n          usageDetails[`output_${key}`] = val;\n          if (\"output\" in usageDetails && typeof val === \"number\") {\n            usageDetails[\"output\"] = Math.max(0, usageDetails[\"output\"] - val);\n          }\n        }\n      }\n\n      const extractedOutput =\n        \"message\" in lastResponse\n          ? this.extractChatMessageContent(\n              lastResponse[\"message\"] as BaseMessage\n            )\n          : lastResponse.text;\n\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          model: modelName,\n          output: extractedOutput,\n          completionStartTime:\n            runId in this.completionStartTimes\n              ? this.completionStartTimes[runId]\n              : undefined,\n          usageDetails: usageDetails,\n        },\n      });\n\n      if (runId in this.completionStartTimes) {\n        delete this.completionStartTimes[runId];\n      }\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleLLMError(\n    err: any,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`LLM error ${err} with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          level: \"ERROR\",\n          statusMessage: err.toString(),\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  private registerPromptInfo(\n    parentRunId?: string,\n    metadata?: Record<string, unknown>\n  ): void {\n    if (metadata && \"promptInfo\" in metadata && parentRunId) {\n      this.promptToParentRunMap.set(\n        parentRunId,\n        metadata.promptInfo as PromptInfo\n      );\n    }\n  }\n\n  private deregisterPromptInfo(runId: string): void {\n    this.promptToParentRunMap.delete(runId);\n  }\n\n  private startAndRegisterObservation(params: {\n    runName: string;\n    runId: string;\n    parentRunId?: string;\n    attributes: Record<string, unknown>;\n    metadata?: Record<string, unknown>;\n    tags?: string[];\n    asType?: \"span\" | \"llm\" | \"tool\";\n  }): Observation {\n    const { runName, runId, parentRunId, attributes, metadata, tags, asType } =\n      params;\n\n    // Determine parent context:\n    // 1. If parentRunId exists, use the parent span from runMap (internal LangChain/LangGraph hierarchy)\n    // 2. If no parentRunId (ROOT span) but externalParentSpanContext exists, use it (link to AG-UI.Server)\n    // 3. Otherwise, create a new root span\n    let parentSpanContext: SpanContext | undefined;\n\n    if (parentRunId) {\n      // Internal parent from LangChain/LangGraph\n      parentSpanContext = this.runMap.get(parentRunId)?.otelSpan.spanContext();\n    } else if (this.externalParentSpanContext) {\n      // External parent from AG-UI.Server\n      parentSpanContext = this.externalParentSpanContext;\n    }\n\n    // Add adapter name prefix to ROOT span\n    let finalRunName = runName;\n    if (!parentRunId && this.adapterName) {\n      // ROOT span: add Adapter.LangGraph or Adapter.LangChain prefix\n      finalRunName = `Adapter.${this.adapterName}`;\n    }\n\n    const observation = startObservation(\n      finalRunName,\n      {\n        version: this.version,\n        metadata: this.joinTagsAndMetaData(tags, metadata),\n        ...attributes,\n      },\n      {\n        asType: asType ?? \"span\",\n        parentSpanContext,\n      }\n    );\n    this.runMap.set(runId, observation);\n\n    return observation;\n  }\n\n  private handleObservationEnd(params: {\n    runId: string;\n    attributes?: Record<string, unknown>;\n  }) {\n    const { runId, attributes = {} } = params;\n\n    const observation = this.runMap.get(runId);\n    if (!observation) {\n      this.logger.warn?.(\"Observation not found in runMap. Skipping operation.\");\n      return;\n    }\n\n    // Type-safe update: cast to ObservationAttributes which is the union of all observation attribute types\n    observation.update(attributes as ObservationAttributes).end();\n\n    this.last_trace_id = observation.traceId;\n    this.runMap.delete(runId);\n  }\n\n  private joinTagsAndMetaData(\n    tags?: string[] | undefined,\n    metadata1?: Record<string, unknown> | undefined,\n    metadata2?: Record<string, unknown> | undefined\n  ): Record<string, unknown> | undefined {\n    const finalDict: Record<string, unknown> = {};\n    if (tags && tags.length > 0) {\n      finalDict.tags = tags;\n    }\n    if (metadata1) {\n      Object.assign(finalDict, metadata1);\n    }\n    if (metadata2) {\n      Object.assign(finalDict, metadata2);\n    }\n    return this.stripObservabilityKeysFromMetadata(finalDict);\n  }\n\n  private stripObservabilityKeysFromMetadata(\n    metadata?: Record<string, unknown>\n  ): Record<string, unknown> | undefined {\n    if (!metadata) {\n      return;\n    }\n\n    const reservedKeys = [\"promptInfo\", \"userId\", \"sessionId\"];\n\n    return Object.fromEntries(\n      Object.entries(metadata).filter(([key, _]) => !reservedKeys.includes(key))\n    );\n  }\n\n  private extractUsageMetadata(\n    generation: Generation\n  ): UsageMetadata | undefined {\n    try {\n      const usageMetadata =\n        \"message\" in generation &&\n        (AIMessage.isInstance(generation[\"message\"]) ||\n          AIMessageChunk.isInstance(generation[\"message\"]))\n          ? generation[\"message\"].usage_metadata\n          : undefined;\n      return usageMetadata;\n    } catch (err) {\n      this.logger.debug?.(`Error extracting usage metadata: ${err}`);\n      return;\n    }\n  }\n\n  private extractModelNameFromMetadata(generation: any): string | undefined {\n    try {\n      return \"message\" in generation &&\n        (AIMessage.isInstance(generation[\"message\"]) ||\n          AIMessageChunk.isInstance(generation[\"message\"]))\n        ? generation[\"message\"].response_metadata.model_name\n        : undefined;\n    } catch {}\n  }\n\n  private extractChatMessageContent(\n    message: BaseMessage\n  ): LlmMessage | AnonymousLlmMessage | MessageContent {\n    let response = undefined;\n\n    if (message.getType() === \"human\") {\n      response = { content: message.content, role: \"user\" };\n    } else if (message.getType() === \"generic\") {\n      response = {\n        content: message.content,\n        role: \"human\",\n      };\n    } else if (message.getType() === \"ai\") {\n      response = { content: message.content, role: \"assistant\" };\n\n      if (\n        \"tool_calls\" in message &&\n        Array.isArray(message.tool_calls) &&\n        (message.tool_calls?.length ?? 0) > 0\n      ) {\n        (response as any)[\"tool_calls\"] = message[\"tool_calls\"];\n      }\n      if (\n        \"additional_kwargs\" in message &&\n        \"tool_calls\" in message[\"additional_kwargs\"]\n      ) {\n        (response as any)[\"tool_calls\"] =\n          message[\"additional_kwargs\"][\"tool_calls\"];\n      }\n    } else if (message.getType() === \"system\") {\n      response = { content: message.content, role: \"system\" };\n    } else if (message.getType() === \"function\") {\n      response = {\n        content: message.content,\n        additional_kwargs: message.additional_kwargs,\n        role: message.name,\n      };\n    } else if (message.getType() === \"tool\") {\n      response = {\n        content: message.content,\n        additional_kwargs: message.additional_kwargs,\n        role: message.name,\n      };\n    } else if (!message.name) {\n      response = { content: message.content };\n    } else {\n      response = {\n        role: message.name,\n        content: message.content,\n      };\n    }\n\n    if (\n      (message.additional_kwargs.function_call ||\n        message.additional_kwargs.tool_calls) &&\n      (response as any)[\"tool_calls\"] === undefined\n    ) {\n      return { ...response, additional_kwargs: message.additional_kwargs };\n    }\n\n    return response;\n  }\n}\n"],"mappings":"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","names":["OpenInferenceSpanKind","MimeType","LLMSystem","LLMProvider","isCompatible","DiagComponentLogger","DiagLogLevel","DiagAPI","__spreadArray","__read","BaseContext","context","NoopContextManager","__spreadArray","__read","API_NAME","ContextAPI","context","__spreadArray","__read","TraceFlags","NonRecordingSpan","context","NoopTracer","context","ProxyTracer","context","NoopTracerProvider","ProxyTracerProvider","SpanStatusCode","API_NAME","TraceAPI","SemanticConventions","trace","context"]}