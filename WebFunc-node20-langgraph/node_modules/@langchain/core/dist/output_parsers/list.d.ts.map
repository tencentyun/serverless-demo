{"version":3,"file":"list.d.ts","names":["BaseMessage","BaseTransformOutputParser","ListOutputParser","RegExp","AsyncGenerator","CommaSeparatedListOutputParser","Promise","CustomListOutputParser","length","separator","NumberedListOutputParser","MarkdownListOutputParser"],"sources":["../../src/output_parsers/list.d.ts"],"sourcesContent":["import { BaseMessage } from \"../messages/index.js\";\nimport { BaseTransformOutputParser } from \"./transform.js\";\n/**\n * Class to parse the output of an LLM call to a list.\n * @augments BaseOutputParser\n */\nexport declare abstract class ListOutputParser extends BaseTransformOutputParser<string[]> {\n    re?: RegExp;\n    _transform(inputGenerator: AsyncGenerator<string | BaseMessage>): AsyncGenerator<string[]>;\n}\n/**\n * Class to parse the output of an LLM call as a comma-separated list.\n * @augments ListOutputParser\n */\nexport declare class CommaSeparatedListOutputParser extends ListOutputParser {\n    static lc_name(): string;\n    lc_namespace: string[];\n    lc_serializable: boolean;\n    /**\n     * Parses the given text into an array of strings, using a comma as the\n     * separator. If the parsing fails, throws an OutputParserException.\n     * @param text The text to parse.\n     * @returns An array of strings obtained by splitting the input text at each comma.\n     */\n    parse(text: string): Promise<string[]>;\n    /**\n     * Provides instructions on the expected format of the response for the\n     * CommaSeparatedListOutputParser.\n     * @returns A string containing instructions on the expected format of the response.\n     */\n    getFormatInstructions(): string;\n}\n/**\n * Class to parse the output of an LLM call to a list with a specific length and separator.\n * @augments ListOutputParser\n */\nexport declare class CustomListOutputParser extends ListOutputParser {\n    lc_namespace: string[];\n    private length;\n    private separator;\n    constructor({ length, separator }: {\n        length?: number;\n        separator?: string;\n    });\n    /**\n     * Parses the given text into an array of strings, using the specified\n     * separator. If the parsing fails or the number of items in the list\n     * doesn't match the expected length, throws an OutputParserException.\n     * @param text The text to parse.\n     * @returns An array of strings obtained by splitting the input text at each occurrence of the specified separator.\n     */\n    parse(text: string): Promise<string[]>;\n    /**\n     * Provides instructions on the expected format of the response for the\n     * CustomListOutputParser, including the number of items and the\n     * separator.\n     * @returns A string containing instructions on the expected format of the response.\n     */\n    getFormatInstructions(): string;\n}\nexport declare class NumberedListOutputParser extends ListOutputParser {\n    static lc_name(): string;\n    lc_namespace: string[];\n    lc_serializable: boolean;\n    getFormatInstructions(): string;\n    re: RegExp;\n    parse(text: string): Promise<string[]>;\n}\nexport declare class MarkdownListOutputParser extends ListOutputParser {\n    static lc_name(): string;\n    lc_namespace: string[];\n    lc_serializable: boolean;\n    getFormatInstructions(): string;\n    re: RegExp;\n    parse(text: string): Promise<string[]>;\n}\n//# sourceMappingURL=list.d.ts.map"],"mappings":";;;;;;;;;AAMA;AACSG,uBADqBD,gBAAAA,SAAyBD,yBAC9CE,CAAAA,MAAAA,EAAAA,CAAAA,CAAAA;EAC8CH,EAAAA,CAAAA,EAD9CG,MAC8CH;EAAxBI,UAAAA,CAAAA,cAAAA,EAAAA,cAAAA,CAAAA,MAAAA,GAAwBJ,WAAxBI,CAAAA,CAAAA,EAAuCA,cAAvCA,CAAAA,MAAAA,EAAAA,CAAAA;;;AAFiD;AAQhF;AAsBA;AAIkBI,cA1BGH,8BAAAA,SAAuCH,gBAAgB,CA0B1DM;EAAQC,OAAAA,OAAAA,CAAAA,CAAAA,EAAAA,MAAAA;EAWDH,YAAAA,EAAAA,MAAAA,EAAAA;EAf2BJ,eAAAA,EAAAA,OAAAA;EAAgB;AAwBpE;;;;AAAsE;EAQjDS,KAAAA,CAAAA,IAAAA,EAAAA,MAAAA,CAAAA,EA5CIL,OA4CoB,CAAA,MAAA,EAAA,CAAA;EAKrCH;;;AAL8D;;;;;;;;cAhCjDI,sBAAAA,SAA+BL,gBAAAA;;;;;;;;;;;;;;;;;;uBAe3BI;;;;;;;;;cASJI,wBAAAA,SAAiCR,gBAAAA;;;;;MAK9CC;uBACiBG;;cAEJK,wBAAAA,SAAiCT,gBAAAA;;;;;MAK9CC;uBACiBG"}