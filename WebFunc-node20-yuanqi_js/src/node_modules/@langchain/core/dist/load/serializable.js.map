{"version":3,"file":"serializable.js","names":["obj: T","root: SerializedFields","secretsMap: { [key: string]: string }","current: any","serializableClass: typeof Serializable","kwargs?: SerializedFields","aliases: { [key: string]: string }","secrets: { [key: string]: string }","read: any","write: any","escapedKwargs: SerializedFields"],"sources":["../../src/load/serializable.ts"],"sourcesContent":["import { type SerializedFields, keyToJson, mapKeys } from \"./map_keys.js\";\nimport { escapeIfNeeded } from \"./validation.js\";\n\nexport interface BaseSerialized<T extends string> {\n  lc: number;\n  type: T;\n  id: string[];\n  name?: string;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  graph?: Record<string, any>;\n}\n\nexport interface SerializedConstructor extends BaseSerialized<\"constructor\"> {\n  kwargs: SerializedFields;\n}\n\nexport interface SerializedSecret extends BaseSerialized<\"secret\"> {}\n\nexport interface SerializedNotImplemented\n  extends BaseSerialized<\"not_implemented\"> {}\n\nexport type Serialized =\n  | SerializedConstructor\n  | SerializedSecret\n  | SerializedNotImplemented;\n\nfunction shallowCopy<T extends object>(obj: T): T {\n  return Array.isArray(obj) ? ([...obj] as T) : ({ ...obj } as T);\n}\n\nfunction replaceSecrets(\n  root: SerializedFields,\n  secretsMap: { [key: string]: string }\n): SerializedFields {\n  const result = shallowCopy(root);\n  for (const [path, secretId] of Object.entries(secretsMap)) {\n    const [last, ...partsReverse] = path.split(\".\").reverse();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let current: any = result;\n    for (const part of partsReverse.reverse()) {\n      if (current[part] === undefined) {\n        break;\n      }\n      current[part] = shallowCopy(current[part]);\n      current = current[part];\n    }\n    if (current[last] !== undefined) {\n      current[last] = {\n        lc: 1,\n        type: \"secret\",\n        id: [secretId],\n      };\n    }\n  }\n  return result;\n}\n\n/**\n * Get a unique name for the module, rather than parent class implementations.\n * Should not be subclassed, subclass lc_name above instead.\n */\nexport function get_lc_unique_name(\n  serializableClass: typeof Serializable\n): string {\n  // \"super\" here would refer to the parent class of Serializable,\n  // when we want the parent class of the module actually calling this method.\n  const parentClass = Object.getPrototypeOf(serializableClass);\n  const lcNameIsSubclassed =\n    typeof serializableClass.lc_name === \"function\" &&\n    (typeof parentClass.lc_name !== \"function\" ||\n      serializableClass.lc_name() !== parentClass.lc_name());\n  if (lcNameIsSubclassed) {\n    return serializableClass.lc_name();\n  } else {\n    return serializableClass.name;\n  }\n}\n\n/**\n * Interface for objects that can be serialized.\n * This is a duck-typed interface to avoid circular imports.\n */\nexport interface SerializableLike {\n  lc_serializable: boolean;\n  lc_secrets?: Record<string, string>;\n  toJSON(): {\n    lc: number;\n    type: string;\n    id: string[];\n    kwargs?: Record<string, unknown>;\n  };\n}\n\nexport interface SerializableInterface {\n  get lc_id(): string[];\n}\n\nexport abstract class Serializable implements SerializableInterface {\n  lc_serializable = false;\n\n  lc_kwargs: SerializedFields;\n\n  /**\n   * A path to the module that contains the class, eg. [\"langchain\", \"llms\"]\n   * Usually should be the same as the entrypoint the class is exported from.\n   */\n  abstract lc_namespace: string[];\n\n  /**\n   * The name of the serializable. Override to provide an alias or\n   * to preserve the serialized module name in minified environments.\n   *\n   * Implemented as a static method to support loading logic.\n   */\n  static lc_name(): string {\n    return this.name;\n  }\n\n  /**\n   * The final serialized identifier for the module.\n   */\n  get lc_id(): string[] {\n    return [\n      ...this.lc_namespace,\n      get_lc_unique_name(this.constructor as typeof Serializable),\n    ];\n  }\n\n  /**\n   * A map of secrets, which will be omitted from serialization.\n   * Keys are paths to the secret in constructor args, e.g. \"foo.bar.baz\".\n   * Values are the secret ids, which will be used when deserializing.\n   */\n  get lc_secrets(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  /**\n   * A map of additional attributes to merge with constructor args.\n   * Keys are the attribute names, e.g. \"foo\".\n   * Values are the attribute values, which will be serialized.\n   * These attributes need to be accepted by the constructor as arguments.\n   */\n  get lc_attributes(): SerializedFields | undefined {\n    return undefined;\n  }\n\n  /**\n   * A map of aliases for constructor args.\n   * Keys are the attribute names, e.g. \"foo\".\n   * Values are the alias that will replace the key in serialization.\n   * This is used to eg. make argument names match Python.\n   */\n  get lc_aliases(): { [key: string]: string } | undefined {\n    return undefined;\n  }\n\n  /**\n   * A manual list of keys that should be serialized.\n   * If not overridden, all fields passed into the constructor will be serialized.\n   */\n  get lc_serializable_keys(): string[] | undefined {\n    return undefined;\n  }\n\n  constructor(kwargs?: SerializedFields, ..._args: never[]) {\n    if (this.lc_serializable_keys !== undefined) {\n      this.lc_kwargs = Object.fromEntries(\n        Object.entries(kwargs || {}).filter(([key]) =>\n          this.lc_serializable_keys?.includes(key)\n        )\n      );\n    } else {\n      this.lc_kwargs = kwargs ?? {};\n    }\n  }\n\n  toJSON(): Serialized {\n    if (!this.lc_serializable) {\n      return this.toJSONNotImplemented();\n    }\n    if (\n      // eslint-disable-next-line no-instanceof/no-instanceof\n      this.lc_kwargs instanceof Serializable ||\n      typeof this.lc_kwargs !== \"object\" ||\n      Array.isArray(this.lc_kwargs)\n    ) {\n      // We do not support serialization of classes with arg not a POJO\n      // I'm aware the check above isn't as strict as it could be\n      return this.toJSONNotImplemented();\n    }\n\n    const aliases: { [key: string]: string } = {};\n    const secrets: { [key: string]: string } = {};\n    const kwargs = Object.keys(this.lc_kwargs).reduce((acc, key) => {\n      acc[key] = key in this ? this[key as keyof this] : this.lc_kwargs[key];\n      return acc;\n    }, {} as SerializedFields);\n    // get secrets, attributes and aliases from all superclasses\n    for (\n      let current = Object.getPrototypeOf(this);\n      current;\n      current = Object.getPrototypeOf(current)\n    ) {\n      Object.assign(aliases, Reflect.get(current, \"lc_aliases\", this));\n      Object.assign(secrets, Reflect.get(current, \"lc_secrets\", this));\n      Object.assign(kwargs, Reflect.get(current, \"lc_attributes\", this));\n    }\n\n    // include all secrets used, even if not in kwargs,\n    // will be replaced with sentinel value in replaceSecrets\n    Object.keys(secrets).forEach((keyPath) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let read: any = this;\n\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      let write: any = kwargs;\n\n      const [last, ...partsReverse] = keyPath.split(\".\").reverse();\n      for (const key of partsReverse.reverse()) {\n        if (!(key in read) || read[key] === undefined) return;\n        if (!(key in write) || write[key] === undefined) {\n          if (typeof read[key] === \"object\" && read[key] != null) {\n            write[key] = {};\n          } else if (Array.isArray(read[key])) {\n            write[key] = [];\n          }\n        }\n\n        read = read[key];\n        write = write[key];\n      }\n\n      if (last in read && read[last] !== undefined) {\n        write[last] = write[last] || read[last];\n      }\n    });\n\n    const escapedKwargs: SerializedFields = {};\n    // Track current path to detect circular references (but not shared references)\n    // The Serializable object itself stays in the path to detect self-references in kwargs\n    const pathSet = new WeakSet<object>();\n    pathSet.add(this);\n    for (const [key, value] of Object.entries(kwargs)) {\n      escapedKwargs[key] = escapeIfNeeded(value, pathSet);\n    }\n\n    // Now add secret markers - these are added AFTER escaping so they won't be escaped\n    const kwargsWithSecrets = Object.keys(secrets).length\n      ? replaceSecrets(escapedKwargs, secrets)\n      : escapedKwargs;\n\n    // Finally transform keys to JSON format\n    const processedKwargs = mapKeys(kwargsWithSecrets, keyToJson, aliases);\n\n    return {\n      lc: 1,\n      type: \"constructor\",\n      id: this.lc_id,\n      kwargs: processedKwargs,\n    };\n  }\n\n  toJSONNotImplemented(): SerializedNotImplemented {\n    return {\n      lc: 1,\n      type: \"not_implemented\",\n      id: this.lc_id,\n    };\n  }\n}\n"],"mappings":"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"}