{"version":3,"file":"client.d.cts","names":["Assistant","AssistantGraph","AssistantSortBy","AssistantSelectField","AssistantVersion","AssistantsSearchResponse","CancelAction","Checkpoint","Config","Cron","CronSelectField","CronCreateForThreadResponse","CronCreateResponse","CronSortBy","DefaultValues","GraphSchema","Item","ListNamespaceResponse","Metadata","Run","RunSelectField","RunStatus","SearchItemsResponse","SortOrder","Subgraphs","Thread","ThreadSelectField","ThreadSortBy","ThreadState","ThreadStatus","ThreadValuesFilter","Command","CronsCreatePayload","OnConflictBehavior","RunsCreatePayload","RunsStreamPayload","RunsWaitPayload","StreamEvent","StreamMode","ThreadStreamMode","TypedAsyncGenerator","AsyncCaller","AsyncCallerParams","HeaderValue","getApiKey","RequestHook","URL","RequestInit","Promise","ClientConfig","Record","BaseClient","AbortSignal","T","Response","AsyncGenerator","CronsClient","AssistantsClient","ThreadsClient","TStateType","ValuesType","Array","TUpdateType","Pick","Omit","Partial","RunsClient","TStreamMode","TSubgraphs","TCustomEventType","StoreClient","UiClient","Client","getClientConfigHash"],"sources":["../src/client.d.ts"],"sourcesContent":["import { Assistant, AssistantGraph, AssistantSortBy, AssistantSelectField, AssistantVersion, AssistantsSearchResponse, CancelAction, Checkpoint, Config, Cron, CronSelectField, CronCreateForThreadResponse, CronCreateResponse, CronSortBy, DefaultValues, GraphSchema, Item, ListNamespaceResponse, Metadata, Run, RunSelectField, RunStatus, SearchItemsResponse, SortOrder, Subgraphs, Thread, ThreadSelectField, ThreadSortBy, ThreadState, ThreadStatus, ThreadValuesFilter } from \"./schema.js\";\nimport type { Command, CronsCreatePayload, OnConflictBehavior, RunsCreatePayload, RunsStreamPayload, RunsWaitPayload, StreamEvent } from \"./types.js\";\nimport type { StreamMode, ThreadStreamMode, TypedAsyncGenerator } from \"./types.stream.js\";\nimport { AsyncCaller, AsyncCallerParams } from \"./utils/async_caller.js\";\ntype HeaderValue = string | undefined | null;\n/**\n * Get the API key from the environment.\n * Precedence:\n *   1. explicit argument (if string)\n *   2. LANGGRAPH_API_KEY\n *   3. LANGSMITH_API_KEY\n *   4. LANGCHAIN_API_KEY\n *\n * @param apiKey - API key provided as an argument. If null, skips environment lookup. If undefined, tries environment.\n * @returns The API key if found, otherwise undefined\n */\nexport declare function getApiKey(apiKey?: string | null): string | undefined;\nexport type RequestHook = (url: URL, init: RequestInit) => Promise<RequestInit> | RequestInit;\nexport interface ClientConfig {\n    apiUrl?: string;\n    /**\n     * API key for authentication.\n     * - If a string is provided, that key will be used\n     * - If undefined (default), the key will be auto-loaded from environment variables (LANGGRAPH_API_KEY, LANGSMITH_API_KEY, or LANGCHAIN_API_KEY)\n     * - If null, no API key will be set (skips auto-loading)\n     */\n    apiKey?: string | null;\n    callerOptions?: AsyncCallerParams;\n    timeoutMs?: number;\n    defaultHeaders?: Record<string, HeaderValue>;\n    onRequest?: RequestHook;\n}\ndeclare class BaseClient {\n    protected asyncCaller: AsyncCaller;\n    protected timeoutMs: number | undefined;\n    protected apiUrl: string;\n    protected defaultHeaders: Record<string, HeaderValue>;\n    protected onRequest?: RequestHook;\n    constructor(config?: ClientConfig);\n    protected prepareFetchOptions(path: string, options?: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        withResponse?: boolean;\n    }): [url: URL, init: RequestInit];\n    protected fetch<T>(path: string, options: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        signal: AbortSignal | undefined;\n        withResponse: true;\n    }): Promise<[T, Response]>;\n    protected fetch<T>(path: string, options?: RequestInit & {\n        json?: unknown;\n        params?: Record<string, unknown>;\n        timeoutMs?: number | null;\n        signal: AbortSignal | undefined;\n        withResponse?: false;\n    }): Promise<T>;\n    /**\n     * Protected helper for streaming with automatic retry logic.\n     * Handles both initial requests and reconnections with SSE.\n     */\n    protected streamWithRetry<T extends {\n        id?: string;\n        event: string;\n        data: unknown;\n    }>(config: {\n        endpoint: string;\n        method?: string;\n        signal?: AbortSignal;\n        headers?: Record<string, string>;\n        params?: Record<string, unknown>;\n        json?: unknown;\n        maxRetries?: number;\n        onReconnect?: (options: {\n            attempt: number;\n            lastEventId?: string;\n            cause: unknown;\n        }) => void;\n        onInitialResponse?: (response: Response) => void | Promise<void>;\n    }): AsyncGenerator<T>;\n}\nexport declare class CronsClient extends BaseClient {\n    /**\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns The created background run.\n     */\n    createForThread(threadId: string, assistantId: string, payload?: CronsCreatePayload): Promise<CronCreateForThreadResponse>;\n    /**\n     *\n     * @param assistantId Assistant ID to use for this cron job.\n     * @param payload Payload for creating a cron job.\n     * @returns\n     */\n    create(assistantId: string, payload?: CronsCreatePayload): Promise<CronCreateResponse>;\n    /**\n     *\n     * @param cronId Cron ID of Cron job to delete.\n     */\n    delete(cronId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     *\n     * @param query Query options.\n     * @returns List of crons.\n     */\n    search(query?: {\n        assistantId?: string;\n        threadId?: string;\n        limit?: number;\n        offset?: number;\n        sortBy?: CronSortBy;\n        sortOrder?: SortOrder;\n        select?: CronSelectField[];\n        signal?: AbortSignal;\n    }): Promise<Cron[]>;\n    /**\n     * Count cron jobs matching filters.\n     *\n     * @param query.assistantId Assistant ID to filter by.\n     * @param query.threadId Thread ID to filter by.\n     * @returns Number of cron jobs matching the criteria.\n     */\n    count(query?: {\n        assistantId?: string;\n        threadId?: string;\n        signal?: AbortSignal;\n    }): Promise<number>;\n}\nexport declare class AssistantsClient extends BaseClient {\n    /**\n     * Get an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant.\n     * @returns Assistant\n     */\n    get(assistantId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<Assistant>;\n    /**\n     * Get the JSON representation of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @param options.xray Whether to include subgraphs in the serialized graph representation. If an integer value is provided, only subgraphs with a depth less than or equal to the value will be included.\n     * @returns Serialized graph\n     */\n    getGraph(assistantId: string, options?: {\n        xray?: boolean | number;\n        signal?: AbortSignal;\n    }): Promise<AssistantGraph>;\n    /**\n     * Get the state and config schema of the graph assigned to a runnable\n     * @param assistantId The ID of the assistant.\n     * @returns Graph schema\n     */\n    getSchemas(assistantId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<GraphSchema>;\n    /**\n     * Get the schemas of an assistant by ID.\n     *\n     * @param assistantId The ID of the assistant to get the schema of.\n     * @param options Additional options for getting subgraphs, such as namespace or recursion extraction.\n     * @returns The subgraphs of the assistant.\n     */\n    getSubgraphs(assistantId: string, options?: {\n        namespace?: string;\n        recurse?: boolean;\n        signal?: AbortSignal;\n    }): Promise<Subgraphs>;\n    /**\n     * Create a new assistant.\n     * @param payload Payload for creating an assistant.\n     * @returns The created assistant.\n     */\n    create(payload: {\n        graphId: string;\n        config?: Config;\n        context?: unknown;\n        metadata?: Metadata;\n        assistantId?: string;\n        ifExists?: OnConflictBehavior;\n        name?: string;\n        description?: string;\n        signal?: AbortSignal;\n    }): Promise<Assistant>;\n    /**\n     * Update an assistant.\n     * @param assistantId ID of the assistant.\n     * @param payload Payload for updating the assistant.\n     * @returns The updated assistant.\n     */\n    update(assistantId: string, payload: {\n        graphId?: string;\n        config?: Config;\n        context?: unknown;\n        metadata?: Metadata;\n        name?: string;\n        description?: string;\n        signal?: AbortSignal;\n    }): Promise<Assistant>;\n    /**\n     * Delete an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @param deleteThreads If true, delete all threads with `metadata.assistant_id` equal to `assistantId`. Defaults to false.\n     */\n    delete(assistantId: string, options?: {\n        signal?: AbortSignal;\n        deleteThreads?: boolean;\n    }): Promise<void>;\n    /**\n     * List assistants.\n     * @param query Query options.\n     * @returns List of assistants or, when includePagination is true, a mapping with the assistants and next cursor.\n     */\n    search(query: {\n        graphId?: string;\n        name?: string;\n        metadata?: Metadata;\n        limit?: number;\n        offset?: number;\n        sortBy?: AssistantSortBy;\n        sortOrder?: SortOrder;\n        select?: AssistantSelectField[];\n        includePagination: true;\n        signal?: AbortSignal;\n    }): Promise<AssistantsSearchResponse>;\n    search(query?: {\n        graphId?: string;\n        name?: string;\n        metadata?: Metadata;\n        limit?: number;\n        offset?: number;\n        sortBy?: AssistantSortBy;\n        sortOrder?: SortOrder;\n        select?: AssistantSelectField[];\n        includePagination?: false;\n        signal?: AbortSignal;\n    }): Promise<Assistant[]>;\n    /**\n     * Count assistants matching filters.\n     *\n     * @param query.metadata Metadata to filter by. Exact match for each key/value.\n     * @param query.graphId Optional graph id to filter by.\n     * @param query.name Optional name to filter by.\n     * @returns Number of assistants matching the criteria.\n     */\n    count(query?: {\n        metadata?: Metadata;\n        graphId?: string;\n        name?: string;\n        signal?: AbortSignal;\n    }): Promise<number>;\n    /**\n     * List all versions of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @returns List of assistant versions.\n     */\n    getVersions(assistantId: string, payload?: {\n        metadata?: Metadata;\n        limit?: number;\n        offset?: number;\n        signal?: AbortSignal;\n    }): Promise<AssistantVersion[]>;\n    /**\n     * Change the version of an assistant.\n     *\n     * @param assistantId ID of the assistant.\n     * @param version The version to change to.\n     * @returns The updated assistant.\n     */\n    setLatest(assistantId: string, version: number, options?: {\n        signal?: AbortSignal;\n    }): Promise<Assistant>;\n}\nexport declare class ThreadsClient<TStateType = DefaultValues, TUpdateType = TStateType> extends BaseClient {\n    /**\n     * Get a thread by ID.\n     *\n     * @param threadId ID of the thread.\n     * @returns The thread.\n     */\n    get<ValuesType = TStateType>(threadId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<Thread<ValuesType>>;\n    /**\n     * Create a new thread.\n     *\n     * @param payload Payload for creating a thread.\n     * @returns The created thread.\n     */\n    create(payload?: {\n        /**\n         * Metadata for the thread.\n         */\n        metadata?: Metadata;\n        /**\n         * ID of the thread to create.\n         *\n         * If not provided, a random UUID will be generated.\n         */\n        threadId?: string;\n        /**\n         * How to handle duplicate creation.\n         *\n         * @default \"raise\"\n         */\n        ifExists?: OnConflictBehavior;\n        /**\n         * Graph ID to associate with the thread.\n         */\n        graphId?: string;\n        /**\n         * Apply a list of supersteps when creating a thread, each containing a sequence of updates.\n         *\n         * Used for copying a thread between deployments.\n         */\n        supersteps?: Array<{\n            updates: Array<{\n                values: unknown;\n                command?: Command;\n                asNode: string;\n            }>;\n        }>;\n        /**\n         * Optional time-to-live in minutes for the thread.\n         * If a number is provided, it is treated as minutes and defaults to strategy \"delete\".\n         * You may also provide an object { ttl: number, strategy?: \"delete\" }.\n         */\n        ttl?: number | {\n            ttl: number;\n            strategy?: \"delete\";\n        };\n        /**\n         * Signal to abort the request.\n         */\n        signal?: AbortSignal;\n    }): Promise<Thread<TStateType>>;\n    /**\n     * Copy an existing thread\n     * @param threadId ID of the thread to be copied\n     * @returns Newly copied thread\n     */\n    copy(threadId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<Thread<TStateType>>;\n    /**\n     * Update a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param payload Payload for updating the thread.\n     * @returns The updated thread.\n     */\n    update(threadId: string, payload?: {\n        /**\n         * Metadata for the thread.\n         */\n        metadata?: Metadata;\n        /**\n         * Optional time-to-live in minutes for the thread.\n         * If a number is provided, it is treated as minutes and defaults to strategy \"delete\".\n         * You may also provide an object { ttl: number, strategy?: \"delete\" }.\n         */\n        ttl?: number | {\n            ttl: number;\n            strategy?: \"delete\";\n        };\n        /**\n         * Signal to abort the request.\n         */\n        signal?: AbortSignal;\n    }): Promise<Thread>;\n    /**\n     * Delete a thread.\n     *\n     * @param threadId ID of the thread.\n     */\n    delete(threadId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * List threads\n     *\n     * @param query Query options\n     * @returns List of threads\n     */\n    search<ValuesType = TStateType>(query?: {\n        /**\n         * Metadata to filter threads by.\n         */\n        metadata?: Metadata;\n        /**\n         * Filter by specific thread IDs.\n         */\n        ids?: string[];\n        /**\n         * Maximum number of threads to return.\n         * Defaults to 10\n         */\n        limit?: number;\n        /**\n         * Offset to start from.\n         */\n        offset?: number;\n        /**\n         * Thread status to filter on.\n         */\n        status?: ThreadStatus;\n        /**\n         * Sort by.\n         */\n        sortBy?: ThreadSortBy;\n        /**\n         * Sort order.\n         * Must be one of 'asc' or 'desc'.\n         */\n        sortOrder?: SortOrder;\n        /**\n         * Array of fields to select.\n         * Elements or array must be one of 'thread_id, 'created_at', 'updated_at', 'metadata', 'config', 'context', 'status', 'values', or 'interrupts'.\n         */\n        select?: ThreadSelectField[];\n        /**\n         * Values to filter threads by.\n         */\n        values?: ThreadValuesFilter;\n        /**\n         * Signal to abort the request.\n         */\n        signal?: AbortSignal;\n    }): Promise<Thread<ValuesType>[]>;\n    /**\n     * Count threads matching filters.\n     *\n     * @param query.metadata Thread metadata to filter on.\n     * @param query.values State values to filter on.\n     * @param query.status Thread status to filter on.\n     * @returns Number of threads matching the criteria.\n     */\n    count<ValuesType = TStateType>(query?: {\n        metadata?: Metadata;\n        values?: ValuesType;\n        status?: ThreadStatus;\n        signal?: AbortSignal;\n    }): Promise<number>;\n    /**\n     * Get state for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @returns Thread state.\n     */\n    getState<ValuesType = TStateType>(threadId: string, checkpoint?: Checkpoint | string, options?: {\n        subgraphs?: boolean;\n        signal?: AbortSignal;\n    }): Promise<ThreadState<ValuesType>>;\n    /**\n     * Add state to a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @returns\n     */\n    updateState<ValuesType = TUpdateType>(threadId: string, options: {\n        values: ValuesType;\n        checkpoint?: Checkpoint;\n        checkpointId?: string;\n        asNode?: string;\n        signal?: AbortSignal;\n    }): Promise<Pick<Config, \"configurable\">>;\n    /**\n     * Patch the metadata of a thread.\n     *\n     * @param threadIdOrConfig Thread ID or config to patch the state of.\n     * @param metadata Metadata to patch the state with.\n     */\n    patchState(threadIdOrConfig: string | Config, metadata: Metadata, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * Get all past states for a thread.\n     *\n     * @param threadId ID of the thread.\n     * @param options Additional options.\n     * @returns List of thread states.\n     */\n    getHistory<ValuesType = TStateType>(threadId: string, options?: {\n        limit?: number;\n        before?: Config;\n        checkpoint?: Partial<Omit<Checkpoint, \"thread_id\">>;\n        metadata?: Metadata;\n        signal?: AbortSignal;\n    }): Promise<ThreadState<ValuesType>[]>;\n    joinStream(threadId: string, options?: {\n        lastEventId?: string;\n        streamMode?: ThreadStreamMode | ThreadStreamMode[];\n        signal?: AbortSignal;\n    }): AsyncGenerator<{\n        id?: string;\n        event: StreamEvent;\n        data: any;\n    }>;\n}\nexport declare class RunsClient<TStateType = DefaultValues, TUpdateType = TStateType, TCustomEventType = unknown> extends BaseClient {\n    stream<TStreamMode extends StreamMode | StreamMode[] = StreamMode, TSubgraphs extends boolean = false>(threadId: null, assistantId: string, payload?: Omit<RunsStreamPayload<TStreamMode, TSubgraphs>, \"multitaskStrategy\" | \"onCompletion\">): TypedAsyncGenerator<TStreamMode, TSubgraphs, TStateType, TUpdateType, TCustomEventType>;\n    stream<TStreamMode extends StreamMode | StreamMode[] = StreamMode, TSubgraphs extends boolean = false>(threadId: string, assistantId: string, payload?: RunsStreamPayload<TStreamMode, TSubgraphs>): TypedAsyncGenerator<TStreamMode, TSubgraphs, TStateType, TUpdateType, TCustomEventType>;\n    /**\n     * Create a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param assistantId Assistant ID to use for this run.\n     * @param payload Payload for creating a run.\n     * @returns The created run.\n     */\n    create(threadId: string | null, assistantId: string, payload?: RunsCreatePayload): Promise<Run>;\n    /**\n     * Create a batch of stateless background runs.\n     *\n     * @param payloads An array of payloads for creating runs.\n     * @returns An array of created runs.\n     */\n    createBatch(payloads: (Omit<RunsCreatePayload, \"signal\"> & {\n        assistantId: string;\n    })[], options?: {\n        signal?: AbortSignal;\n    }): Promise<Run[]>;\n    wait(threadId: null, assistantId: string, payload?: Omit<RunsWaitPayload, \"multitaskStrategy\" | \"onCompletion\">): Promise<ThreadState[\"values\"]>;\n    wait(threadId: string, assistantId: string, payload?: RunsWaitPayload): Promise<ThreadState[\"values\"]>;\n    /**\n     * List all runs for a thread.\n     *\n     * @param threadId The ID of the thread.\n     * @param options Filtering and pagination options.\n     * @returns List of runs.\n     */\n    list(threadId: string, options?: {\n        /**\n         * Maximum number of runs to return.\n         * Defaults to 10\n         */\n        limit?: number;\n        /**\n         * Offset to start from.\n         * Defaults to 0.\n         */\n        offset?: number;\n        /**\n         * Status of the run to filter by.\n         */\n        status?: RunStatus;\n        select?: RunSelectField[];\n        /**\n         * Signal to abort the request.\n         */\n        signal?: AbortSignal;\n    }): Promise<Run[]>;\n    /**\n     * Get a run by ID.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns The run.\n     */\n    get(threadId: string, runId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<Run>;\n    /**\n     * Cancel a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @param wait Whether to block when canceling\n     * @param action Action to take when cancelling the run. Possible values are `interrupt` or `rollback`. Default is `interrupt`.\n     * @returns\n     */\n    cancel(threadId: string, runId: string, wait?: boolean, action?: CancelAction, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * Block until a run is done.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    join(threadId: string, runId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<TStateType>;\n    /**\n     * Stream output from a run in real-time, until the run is done.\n     *\n     * @param threadId The ID of the thread. Can be set to `null` | `undefined` for stateless runs.\n     * @param runId The ID of the run.\n     * @param options Additional options for controlling the stream behavior:\n     *   - signal: An AbortSignal that can be used to cancel the stream request\n     *   - lastEventId: The ID of the last event received. Can be used to reconnect to a stream without losing events.\n     *   - cancelOnDisconnect: When true, automatically cancels the run if the client disconnects from the stream\n     *   - streamMode: Controls what types of events to receive from the stream (can be a single mode or array of modes)\n     *        Must be a subset of the stream modes passed when creating the run. Background runs default to having the union of all\n     *        stream modes enabled.\n     * @returns An async generator yielding stream parts.\n     */\n    joinStream(threadId: string | undefined | null, runId: string, options?: {\n        signal?: AbortSignal;\n        cancelOnDisconnect?: boolean;\n        lastEventId?: string;\n        streamMode?: StreamMode | StreamMode[];\n    } | AbortSignal): AsyncGenerator<{\n        id?: string;\n        event: StreamEvent;\n        data: any;\n    }>;\n    /**\n     * Delete a run.\n     *\n     * @param threadId The ID of the thread.\n     * @param runId The ID of the run.\n     * @returns\n     */\n    delete(threadId: string, runId: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n}\nexport declare class StoreClient extends BaseClient {\n    /**\n     * Store or update an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item within the namespace.\n     * @param value A dictionary containing the item's data.\n     * @param options.index Controls search indexing - null (use defaults), false (disable), or list of field paths to index.\n     * @param options.ttl Optional time-to-live in minutes for the item, or null for no expiration.\n     * @returns Promise<void>\n     *\n     * @example\n     * ```typescript\n     * await client.store.putItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { title: \"My Document\", content: \"Hello World\" },\n     *   { ttl: 60 } // expires in 60 minutes\n     * );\n     * ```\n     */\n    putItem(namespace: string[], key: string, value: Record<string, unknown>, options?: {\n        index?: false | string[] | null;\n        ttl?: number | null;\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * Retrieve a single item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @param options.refreshTtl Whether to refresh the TTL on this read operation. If null, uses the store's default behavior.\n     * @returns Promise<Item>\n     *\n     * @example\n     * ```typescript\n     * const item = await client.store.getItem(\n     *   [\"documents\", \"user123\"],\n     *   \"item456\",\n     *   { refreshTtl: true }\n     * );\n     * console.log(item);\n     * // {\n     * //   namespace: [\"documents\", \"user123\"],\n     * //   key: \"item456\",\n     * //   value: { title: \"My Document\", content: \"Hello World\" },\n     * //   createdAt: \"2024-07-30T12:00:00Z\",\n     * //   updatedAt: \"2024-07-30T12:00:00Z\"\n     * // }\n     * ```\n     */\n    getItem(namespace: string[], key: string, options?: {\n        refreshTtl?: boolean | null;\n        signal?: AbortSignal;\n    }): Promise<Item | null>;\n    /**\n     * Delete an item.\n     *\n     * @param namespace A list of strings representing the namespace path.\n     * @param key The unique identifier for the item.\n     * @returns Promise<void>\n     */\n    deleteItem(namespace: string[], key: string, options?: {\n        signal?: AbortSignal;\n    }): Promise<void>;\n    /**\n     * Search for items within a namespace prefix.\n     *\n     * @param namespacePrefix List of strings representing the namespace prefix.\n     * @param options.filter Optional dictionary of key-value pairs to filter results.\n     * @param options.limit Maximum number of items to return (default is 10).\n     * @param options.offset Number of items to skip before returning results (default is 0).\n     * @param options.query Optional search query.\n     * @param options.refreshTtl Whether to refresh the TTL on items returned by this search. If null, uses the store's default behavior.\n     * @returns Promise<SearchItemsResponse>\n     *\n     * @example\n     * ```typescript\n     * const results = await client.store.searchItems(\n     *   [\"documents\"],\n     *   {\n     *     filter: { author: \"John Doe\" },\n     *     limit: 5,\n     *     refreshTtl: true\n     *   }\n     * );\n     * console.log(results);\n     * // {\n     * //   items: [\n     * //     {\n     * //       namespace: [\"documents\", \"user123\"],\n     * //       key: \"item789\",\n     * //       value: { title: \"Another Document\", author: \"John Doe\" },\n     * //       createdAt: \"2024-07-30T12:00:00Z\",\n     * //       updatedAt: \"2024-07-30T12:00:00Z\"\n     * //     },\n     * //     // ... additional items ...\n     * //   ]\n     * // }\n     * ```\n     */\n    searchItems(namespacePrefix: string[], options?: {\n        filter?: Record<string, unknown>;\n        limit?: number;\n        offset?: number;\n        query?: string;\n        refreshTtl?: boolean | null;\n        signal?: AbortSignal;\n    }): Promise<SearchItemsResponse>;\n    /**\n     * List namespaces with optional match conditions.\n     *\n     * @param options.prefix Optional list of strings representing the prefix to filter namespaces.\n     * @param options.suffix Optional list of strings representing the suffix to filter namespaces.\n     * @param options.maxDepth Optional integer specifying the maximum depth of namespaces to return.\n     * @param options.limit Maximum number of namespaces to return (default is 100).\n     * @param options.offset Number of namespaces to skip before returning results (default is 0).\n     * @returns Promise<ListNamespaceResponse>\n     */\n    listNamespaces(options?: {\n        prefix?: string[];\n        suffix?: string[];\n        maxDepth?: number;\n        limit?: number;\n        offset?: number;\n        signal?: AbortSignal;\n    }): Promise<ListNamespaceResponse>;\n}\ndeclare class UiClient extends BaseClient {\n    private static promiseCache;\n    private static getOrCached;\n    getComponent(assistantId: string, agentName: string): Promise<string>;\n}\nexport declare class Client<TStateType = DefaultValues, TUpdateType = TStateType, TCustomEventType = unknown> {\n    /**\n     * The client for interacting with assistants.\n     */\n    assistants: AssistantsClient;\n    /**\n     * The client for interacting with threads.\n     */\n    threads: ThreadsClient<TStateType, TUpdateType>;\n    /**\n     * The client for interacting with runs.\n     */\n    runs: RunsClient<TStateType, TUpdateType, TCustomEventType>;\n    /**\n     * The client for interacting with cron runs.\n     */\n    crons: CronsClient;\n    /**\n     * The client for interacting with the KV store.\n     */\n    store: StoreClient;\n    /**\n     * The client for interacting with the UI.\n     * @internal Used by LoadExternalComponent and the API might change in the future.\n     */\n    \"~ui\": UiClient;\n    /**\n     * @internal Used to obtain a stable key representing the client.\n     */\n    private \"~configHash\";\n    constructor(config?: ClientConfig);\n}\n/**\n * @internal Used to obtain a stable key representing the client.\n */\nexport declare function getClientConfigHash(client: Client): string | undefined;\nexport {};\n"],"mappings":"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"}