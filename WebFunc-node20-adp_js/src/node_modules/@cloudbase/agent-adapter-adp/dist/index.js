"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AdpAgent: () => AdpAgent,
  AdpAgentError: () => AdpAgentError,
  CurrentNodeStatus: () => CurrentNodeStatus,
  ReplyMethod: () => ReplyMethod
});
module.exports = __toCommonJS(index_exports);

// src/agent.ts
var import_client = require("@ag-ui/client");
var import_rxjs = require("rxjs");
var import_axios = __toESM(require("axios"));

// src/utils.ts
function camelToSnake(str) {
  return str.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
}
function camelToSnakeKeys(obj) {
  if (obj === null || obj === void 0) {
    return obj;
  }
  if (Array.isArray(obj)) {
    return obj.map((item) => camelToSnakeKeys(item));
  }
  if (typeof obj === "object") {
    const result = {};
    for (const [key, value] of Object.entries(obj)) {
      const snakeKey = camelToSnake(key);
      result[snakeKey] = camelToSnakeKeys(value);
    }
    return result;
  }
  return obj;
}

// src/constant.ts
var DOCUMENT_MIME_TYPES = {
  "text/plain": "txt",
  "application/msword": "doc",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": "docx",
  "application/pdf": "pdf",
  "application/vnd.ms-powerpoint": "ppt",
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": "pptx"
};
var IMAGE_MIME_TYPES = {
  "image/png": "png",
  "image/jpeg": "jpg",
  "image/bmp": "bmp"
};
var MIME_TYPES = {
  ...DOCUMENT_MIME_TYPES,
  ...IMAGE_MIME_TYPES
};

// src/types.ts
var ReplyMethod = /* @__PURE__ */ ((ReplyMethod2) => {
  ReplyMethod2[ReplyMethod2["LLM_REPLY"] = 1] = "LLM_REPLY";
  ReplyMethod2[ReplyMethod2["UNKNOWN_QUESTION_REPLY"] = 2] = "UNKNOWN_QUESTION_REPLY";
  ReplyMethod2[ReplyMethod2["REJECT_QUESTION_REPLY"] = 3] = "REJECT_QUESTION_REPLY";
  ReplyMethod2[ReplyMethod2["SENSITIVE_REPLY"] = 4] = "SENSITIVE_REPLY";
  ReplyMethod2[ReplyMethod2["ADOPTED_QA_PRIORITY_REPLY"] = 5] = "ADOPTED_QA_PRIORITY_REPLY";
  ReplyMethod2[ReplyMethod2["WELCOME_REPLY"] = 6] = "WELCOME_REPLY";
  ReplyMethod2[ReplyMethod2["CONCURRENCY_LIMIT_REPLY"] = 7] = "CONCURRENCY_LIMIT_REPLY";
  ReplyMethod2[ReplyMethod2["GLOBAL_INTERVENTION_KNOWLEDGE"] = 8] = "GLOBAL_INTERVENTION_KNOWLEDGE";
  ReplyMethod2[ReplyMethod2["TASK_FLOW_REPLY"] = 9] = "TASK_FLOW_REPLY";
  ReplyMethod2[ReplyMethod2["TASK_FLOW_ANSWER"] = 10] = "TASK_FLOW_ANSWER";
  ReplyMethod2[ReplyMethod2["SEARCH_ENGINE_REPLY"] = 11] = "SEARCH_ENGINE_REPLY";
  ReplyMethod2[ReplyMethod2["KNOWLEDGE_POLISHED_REPLY"] = 12] = "KNOWLEDGE_POLISHED_REPLY";
  ReplyMethod2[ReplyMethod2["IMAGE_UNDERSTANDING_REPLY"] = 13] = "IMAGE_UNDERSTANDING_REPLY";
  ReplyMethod2[ReplyMethod2["REALTIME_DOCUMENT_REPLY"] = 14] = "REALTIME_DOCUMENT_REPLY";
  ReplyMethod2[ReplyMethod2["CLARIFICATION_CONFIRMATION_REPLY"] = 15] = "CLARIFICATION_CONFIRMATION_REPLY";
  ReplyMethod2[ReplyMethod2["WORKFLOW_REPLY"] = 16] = "WORKFLOW_REPLY";
  ReplyMethod2[ReplyMethod2["WORKFLOW_EXECUTION_END"] = 17] = "WORKFLOW_EXECUTION_END";
  ReplyMethod2[ReplyMethod2["AGENT_REPLY"] = 18] = "AGENT_REPLY";
  ReplyMethod2[ReplyMethod2["MULTI_INTENT_REPLY"] = 19] = "MULTI_INTENT_REPLY";
  return ReplyMethod2;
})(ReplyMethod || {});
var CurrentNodeStatus = /* @__PURE__ */ ((CurrentNodeStatus2) => {
  CurrentNodeStatus2[CurrentNodeStatus2["Pending"] = 0] = "Pending";
  CurrentNodeStatus2[CurrentNodeStatus2["Running"] = 1] = "Running";
  CurrentNodeStatus2[CurrentNodeStatus2["Succeeded"] = 2] = "Succeeded";
  CurrentNodeStatus2[CurrentNodeStatus2["Failed"] = 3] = "Failed";
  return CurrentNodeStatus2;
})(CurrentNodeStatus || {});

// src/agent.ts
var import_crypto = require("crypto");
var import_tencentcloud_sdk_nodejs_lke = require("tencentcloud-sdk-nodejs-lke");
var import_cos_nodejs_sdk_v5 = __toESM(require("cos-nodejs-sdk-v5"));
var AdpAgentError = class extends Error {
  constructor(message, code) {
    super(message);
    this.name = "AdpAgentError";
    if (code) this.code = code;
  }
};
var AdpAgent = class extends import_client.AbstractAgent {
  constructor(config) {
    super(config);
    this.finalAppKey = "";
    this.finalCloudCredential = {};
    this.adpConfig = config.adpConfig;
    this.finalAppKey = this.adpConfig.appKey || this.adpConfig.request?.body?.botAppKey || process.env.ADP_APP_KEY || "";
    this.reqAppClient = import_axios.default.create({
      baseURL: this.adpConfig.request?.baseUrl || "https://wss.lke.cloud.tencent.com"
    });
    const LkeClient = import_tencentcloud_sdk_nodejs_lke.lke.v20231130.Client;
    this.finalCloudCredential = {
      secretId: this.adpConfig.credential?.secretId || process.env.TENCENTCLOUD_SECRETID,
      secretKey: this.adpConfig.credential?.secretKey || process.env.TENCENTCLOUD_SECRETKEY,
      token: this.adpConfig.credential?.token || process.env.TENCENTCLOUD_SESSIONTOKEN
    };
    this.reqLkeClient = new LkeClient({
      credential: this.finalCloudCredential
    });
  }
  generateRequestBody({
    message,
    fileInfos,
    input
  }) {
    const { state, runId, threadId, forwardedProps } = input;
    const requestBody = {
      incremental: true,
      stream: "enable",
      ...this.adpConfig.request?.body || {},
      ...forwardedProps || {},
      botAppKey: this.finalAppKey,
      visitorBizId: state?.__request_context__?.id || forwardedProps?.visitorBizId || (0, import_crypto.randomUUID)(),
      requestId: runId,
      sessionId: threadId,
      content: message,
      fileInfos
    };
    return requestBody;
  }
  run(input) {
    return new import_rxjs.Observable((subscriber) => {
      this._run(subscriber, input);
    });
  }
  async _run(subscriber, input) {
    let thinkingMessageSet = /* @__PURE__ */ new Set();
    let thinkFinishedMessageSet = /* @__PURE__ */ new Set();
    try {
      const { runId } = input;
      const threadId = input.threadId || (0, import_crypto.randomUUID)();
      subscriber.next({
        type: import_client.EventType.RUN_STARTED,
        runId,
        threadId
      });
      if (!this.finalAppKey) {
        throw new AdpAgentError(
          "ADP_APP_KEY is required, check your env variables or config passed with the adapter",
          "MISSING_APP_KEY"
        );
      }
      const latestUserMessage = input.messages.filter((m) => m.role === "user").pop();
      if (!latestUserMessage) {
        throw new AdpAgentError(
          "Message content format error, or empty content",
          "INVALID_MESSAGE_FORMAT"
        );
      }
      const { message: docExtractedMessage, fileInfos } = await this.extractDocuments(latestUserMessage, threadId, subscriber);
      const message = await this.convertAGUIMessagesToAdpMessages(docExtractedMessage);
      if (!message) {
        throw new AdpAgentError(
          "Message content format error, or empty content",
          "INVALID_MESSAGE_FORMAT"
        );
      }
      if (input.messages.length > 1) {
        subscriber.next({
          type: import_client.EventType.RAW,
          rawEvent: {
            message: `ADP handles message history itself, so that a total of ${input.messages.length - 1} messages before and including last assistant message will be trimmed.`,
            type: "warn"
          }
        });
      }
      const requestBody = this.generateRequestBody({
        message,
        fileInfos,
        input
      });
      const response = await this.reqAppClient.post(
        this.adpConfig.request?.endpoint || "/v1/qbot/chat/sse",
        camelToSnakeKeys(requestBody),
        { responseType: "stream" }
      );
      const sseStream = response.data;
      let buffer = "";
      let interruptRequested = false;
      let thinkingStart = false;
      for await (const chunk of sseStream) {
        buffer += chunk.toString();
        const parts = buffer.split("\n\n");
        buffer = parts.pop() || "";
        for (const part of parts) {
          if (!part.trim()) continue;
          const event = { data: "", event: "" };
          for (const line of part.split("\n")) {
            if (line.startsWith("data:")) {
              event.data += line.slice(5);
            } else if (line.startsWith("event:")) {
              event.event = line.slice(6);
            }
          }
          if (event.data) {
            let data;
            try {
              data = JSON.parse(event.data);
            } catch (e) {
              throw new AdpAgentError(
                `ADP returned invalid data: ${event.data}`,
                "INVALID_DATA"
              );
            }
            switch (data.type) {
              case "reply": {
                const messageId = data.payload.record_id;
                const isFinal = data.payload.is_final;
                if (thinkingStart) {
                  thinkingStart = false;
                  for (const index of thinkingMessageSet) {
                    subscriber.next({
                      type: import_client.EventType.THINKING_TEXT_MESSAGE_END,
                      messageId: `${messageId}-think-${index}`
                    });
                  }
                  thinkingMessageSet.clear();
                  subscriber.next({
                    type: import_client.EventType.THINKING_END,
                    messageId
                  });
                }
                if (data.payload.is_from_self) {
                  if (data.payload.is_evil) {
                    throw new AdpAgentError(
                      "Message filtered by ADP",
                      "FILTERED_MESSAGE"
                    );
                  } else {
                    continue;
                  }
                }
                data.payload.content = data.payload.content.replace(
                  /\\n/g,
                  "\n\n"
                );
                switch (data.payload.reply_method) {
                  case 1 /* LLM_REPLY */: {
                    subscriber.next({
                      type: import_client.EventType.TEXT_MESSAGE_CHUNK,
                      messageId,
                      delta: data.payload.content
                    });
                    break;
                  }
                  case 16 /* WORKFLOW_REPLY */: {
                    subscriber.next({
                      type: import_client.EventType.TEXT_MESSAGE_CHUNK,
                      messageId,
                      delta: data.payload.content
                    });
                    if (isFinal && data.payload.work_flow && [
                      0 /* Pending */,
                      1 /* Running */
                    ].includes(data.payload.work_flow.current_node.Status)) {
                      subscriber.next({
                        type: import_client.EventType.TOOL_CALL_START,
                        toolCallId: data.payload.work_flow.current_node.NodeID,
                        toolCallName: `${data.payload.work_flow.workflow_name}-${data.payload.work_flow.current_node.NodeName}`,
                        parentMessageId: messageId
                      });
                      subscriber.next({
                        type: import_client.EventType.TOOL_CALL_ARGS,
                        toolCallId: data.payload.work_flow.current_node.NodeID,
                        delta: data.payload.work_flow.current_node.Input || "{}"
                      });
                      subscriber.next({
                        type: import_client.EventType.TOOL_CALL_END,
                        toolCallId: data.payload.work_flow.current_node.NodeID
                      });
                      interruptRequested = true;
                    }
                    break;
                  }
                  case 17 /* WORKFLOW_EXECUTION_END */: {
                    subscriber.next({
                      type: import_client.EventType.TOOL_CALL_RESULT,
                      messageId,
                      toolCallId: data.payload.work_flow.current_node.NodeID,
                      content: (data.payload.work_flow?.outputs || []).join(
                        "\n\n"
                      )
                    });
                    subscriber.next({
                      type: import_client.EventType.TEXT_MESSAGE_CHUNK,
                      messageId,
                      delta: data.payload.content
                    });
                    break;
                  }
                  default: {
                    subscriber.next({
                      type: import_client.EventType.TEXT_MESSAGE_CHUNK,
                      messageId,
                      delta: data.payload.content
                    });
                    break;
                  }
                }
                break;
              }
              case "thought": {
                const messageId = data.payload.record_id;
                if (!thinkingStart) {
                  thinkingStart = true;
                  subscriber.next({
                    type: import_client.EventType.THINKING_START,
                    messageId
                  });
                }
                data.payload.procedures.forEach((procedure) => {
                  const index = procedure.index.toString();
                  if (!thinkingMessageSet.has(index) && !thinkFinishedMessageSet.has(index)) {
                    thinkingMessageSet.add(index);
                    subscriber.next({
                      type: import_client.EventType.THINKING_TEXT_MESSAGE_START,
                      messageId: `${messageId}-think-${index}`,
                      delta: procedure.debugging.content
                    });
                  } else {
                    if (procedure.status === "processing") {
                      subscriber.next({
                        type: import_client.EventType.THINKING_TEXT_MESSAGE_CONTENT,
                        messageId: `${messageId}-think-${index}`,
                        delta: procedure.debugging.content
                      });
                    } else {
                      thinkingMessageSet.delete(index);
                      if (!thinkFinishedMessageSet.has(index)) {
                        thinkFinishedMessageSet.add(index);
                        subscriber.next({
                          type: import_client.EventType.THINKING_TEXT_MESSAGE_END,
                          messageId: `${messageId}-think-${index}`
                        });
                      }
                    }
                  }
                });
                break;
              }
              case "error": {
                console.error(
                  "[ERROR] ADP throws error: ",
                  JSON.stringify(data)
                );
                throw new AdpAgentError(
                  data.error.message,
                  data.error.code ? `ADP_ERROR_${data.error.code}` : "ADP_ERROR_-1"
                );
              }
              case "token_stat": {
                console.debug("[DEBUG] ADP token stat: ", JSON.stringify(data));
                break;
              }
              case "reference": {
                break;
              }
              default: {
                break;
              }
            }
          }
        }
      }
      if (interruptRequested) {
        subscriber.next({
          type: import_client.EventType.RUN_FINISHED,
          runId,
          threadId,
          outcome: "interrupt",
          interrupt: {}
        });
      } else {
        subscriber.next({
          type: import_client.EventType.RUN_FINISHED,
          threadId,
          runId
        });
      }
      subscriber.complete();
    } catch (e) {
      console.error("[ERROR] Uncaught error: ", JSON.stringify(e));
      let code = "UNKNOWN_ERROR";
      let message = JSON.stringify(e);
      if (e instanceof import_axios.AxiosError) {
        code = e.code || "REQUEST_ERROR";
        message = e.message;
      } else if (e instanceof AdpAgentError) {
        code = e.code || "AGENT_ERROR";
        message = e.message;
      }
      subscriber.next({
        type: import_client.EventType.RUN_ERROR,
        code,
        message: `Sorry, an error occurred while running the agent: Error code ${code}, ${message}`
      });
      subscriber.complete();
    } finally {
      thinkingMessageSet.clear();
      thinkFinishedMessageSet.clear();
    }
  }
  async convertAGUIMessagesToAdpMessages(message) {
    let result = "";
    if (message.role === "user") {
      let content = "";
      if (typeof message.content === "string") {
        content = message.content;
      } else {
        if (this.adpConfig.enableUpload) {
          if (!this.finalCloudCredential.token) {
            if (!this.finalCloudCredential.secretId) {
              throw new AdpAgentError(
                "TENCENTCLOUD_SECRETID is required, check your env variables or config passed with the adapter",
                "MISSING_SECRET_ID"
              );
            }
            if (!this.finalCloudCredential.secretKey) {
              throw new AdpAgentError(
                "TENCENTCLOUD_SECRETKEY is required, check your env variables or config passed with the adapter",
                "MISSING_SECRET_KEY"
              );
            }
          }
          const imageMap = /* @__PURE__ */ new Map();
          const imagesToUpload = [];
          message.content.forEach((item) => {
            if (item.type === "binary") {
              if (Object.keys(IMAGE_MIME_TYPES).includes(item.mimeType)) {
                imagesToUpload.push(item);
              }
            }
          });
          if (imagesToUpload.length) {
            await this.uploadToCos(
              imagesToUpload,
              (data, _, file) => {
                imageMap.set(
                  file.id || file.filename,
                  `https://${data.Location}`
                );
              },
              (fileName, error) => {
                throw new AdpAgentError(
                  `Upload image ${fileName} failed: ${error}`,
                  "UPLOAD_IMAGE_FAILED"
                );
              }
            );
          }
          content = message.content.reduce((acc, cur) => {
            if (cur.type === "text") {
              return acc + `${cur.text} `;
            } else if (cur.type === "binary") {
              if (Object.keys(IMAGE_MIME_TYPES).includes(cur.mimeType)) {
                if (imageMap.has(cur.id || cur.filename)) {
                  return acc + `![${cur.filename}](${imageMap.get(cur.id || cur.filename)}) `;
                } else {
                  return acc;
                }
              } else return acc;
            } else {
              return acc;
            }
          }, "").trim();
        }
      }
      result = `${message.role}: ${content}
${result}`;
    } else {
      result = `${message.role}: ${message.content}
${result}`;
    }
    return result.trim();
  }
  async extractDocuments(message, threadId, subscriber) {
    const documentFiles = [];
    let newMessage;
    if (message.role === "user" && Array.isArray(message.content)) {
      let newContent = [];
      message.content.forEach((item) => {
        if (item.type === "text") {
          newContent.push(item);
        } else if (item.type === "binary") {
          if (Object.keys(DOCUMENT_MIME_TYPES).includes(item.mimeType)) {
            documentFiles.push(item);
          } else {
            newContent.push(item);
          }
        }
      });
      newMessage = {
        ...message,
        content: newContent
      };
    } else newMessage = message;
    const fileInfos = [];
    const successedFiles = [];
    const failedFiles = [];
    if (this.adpConfig.enableUpload) {
      if (!this.finalCloudCredential.token) {
        if (!this.finalCloudCredential.secretId) {
          throw new AdpAgentError(
            "TENCENTCLOUD_SECRETID is required, check your env variables or config passed with the adapter",
            "MISSING_SECRET_ID"
          );
        }
        if (!this.finalCloudCredential.secretKey) {
          throw new AdpAgentError(
            "TENCENTCLOUD_SECRETKEY is required, check your env variables or config passed with the adapter",
            "MISSING_SECRET_KEY"
          );
        }
      }
      if (documentFiles.length) {
        try {
          await this.uploadToCos(
            documentFiles,
            (data, cosParams, file) => {
              successedFiles.push({ data, cosParams, file });
            },
            (fileName, error) => {
              failedFiles.push({ fileName, error });
            }
          );
        } catch (e) {
          console.error("Document upload failed: ", JSON.stringify(e));
        }
      }
      if (successedFiles.length) {
        for (const { data: cosData, cosParams, file } of successedFiles) {
          const extName = MIME_TYPES[file.mimeType];
          const requestBody = {
            sessionId: threadId,
            botAppKey: this.finalAppKey,
            requestId: (0, import_crypto.randomUUID)(),
            cosBucket: cosParams.Bucket,
            fileType: extName,
            fileName: file.filename,
            cosUrl: cosParams.UploadPath,
            cosHash: cosData.headers?.["x-cos-hash-crc64ecma"] || "",
            eTag: cosData.ETag,
            size: file.data?.length.toString() || "0"
          };
          const response = await this.reqAppClient.post(
            this.adpConfig.request?.docParseEndpoint || "/v1/qbot/chat/docParse",
            camelToSnakeKeys(requestBody),
            { responseType: "stream" }
          );
          const sseStream = response.data;
          let buffer = "";
          for await (const chunk of sseStream) {
            buffer += chunk.toString();
            const parts = buffer.split("\n\n");
            buffer = parts.pop() || "";
            for (const part of parts) {
              if (!part.trim()) continue;
              const event = { data: "", event: "" };
              for (const line of part.split("\n")) {
                if (line.startsWith("data:")) {
                  event.data += line.slice(5);
                } else if (line.startsWith("event:")) {
                  event.event = line.slice(6);
                }
              }
              if (event.data) {
                let data;
                try {
                  data = JSON.parse(event.data);
                } catch (e) {
                  throw new AdpAgentError(
                    `ADP returned invalid data: ${event.data}`,
                    "INVALID_DATA"
                  );
                }
                switch (data.type) {
                  case "parsing": {
                    subscriber.next({
                      type: import_client.EventType.RAW,
                      rawEvent: {
                        message: `Parsing document ${file.filename}: ${data.payload.process}%`,
                        type: "info"
                      }
                    });
                    if (data.payload.is_final) {
                      if (data.payload.error_message) {
                        subscriber.next({
                          type: import_client.EventType.RAW,
                          rawEvent: {
                            message: `Parsing document ${file.filename} failed: ${data.payload.error_message}`,
                            type: "error"
                          }
                        });
                      } else {
                        const fileNameNoExt = file.filename.split(".").splice(0, -1).join(".");
                        fileInfos.push({
                          docId: data.payload.doc_id,
                          fileName: fileNameNoExt,
                          fileType: extName,
                          fileSize: file.data?.length.toString() || "0",
                          fileUrl: `https://${cosData.Location}`
                        });
                      }
                    }
                    break;
                  }
                  default: {
                    break;
                  }
                }
              }
            }
          }
        }
      }
    }
    return {
      message: newMessage,
      fileInfos,
      failedFiles
    };
  }
  async getCosParams(mimeType) {
    const extName = MIME_TYPES?.[mimeType];
    if (!extName) {
      throw new Error(`Unsupported mime type: ${mimeType}`);
    }
    const isPicture = Object.keys(IMAGE_MIME_TYPES).includes(mimeType);
    const bizIdRes = await this.reqLkeClient.DescribeRobotBizIDByAppKey({
      AppKey: this.finalAppKey
    });
    const storageRes = await this.reqLkeClient.DescribeStorageCredential({
      BotBizId: bizIdRes.BotBizId,
      FileType: extName,
      IsPublic: isPicture,
      TypeKey: "realtime"
    });
    return storageRes;
  }
  async uploadToCos(files, onSuccess, onError) {
    const promises = [];
    for (const file of files) {
      const extName = MIME_TYPES?.[file.mimeType];
      if (!extName) {
        onError(file.filename || "unknown-file", "Unsupported file type");
        continue;
      }
      const cosParams = await this.getCosParams(file.mimeType);
      const cosClient = new import_cos_nodejs_sdk_v5.default({
        SecretId: cosParams.Credentials?.TmpSecretId,
        SecretKey: cosParams.Credentials?.TmpSecretKey,
        SecurityToken: cosParams.Credentials?.Token
      });
      if (!cosParams.Bucket || !cosParams.Region || !cosParams.UploadPath) {
        onError(file.filename || "unknown-file", "Failed to get COS params");
        continue;
      }
      const promise = new Promise((resolve, reject) => {
        cosClient.putObject(
          {
            Bucket: cosParams.Bucket,
            Region: cosParams.Region,
            Key: cosParams.UploadPath,
            Body: file.data
          },
          (err, data) => {
            if (err) {
              onError(file.filename || "unknown-file", err.message);
              reject();
            } else {
              onSuccess(data, cosParams, file);
              resolve();
            }
          }
        );
      });
      promises.push(promise);
    }
    await Promise.allSettled(promises);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AdpAgent,
  AdpAgentError,
  CurrentNodeStatus,
  ReplyMethod
});
//# sourceMappingURL=index.js.map