import {
  callAfterRequestMiddleware,
  callBeforeRequestMiddleware,
  createJsonRequest,
  expectString,
  handleConnectAgent,
  handleGetRuntimeInfo,
  handleRunAgent,
  handleStopAgent,
  handleTranscribe,
  parseMethodCall
} from "./chunk-2KPQGACC.mjs";

// src/endpoints/express.ts
import express from "express";
import cors from "cors";
import { logger as logger2 } from "@copilotkitnext/shared";

// src/endpoints/express-utils.ts
import { Readable } from "stream";
import { pipeline } from "stream";
import { promisify } from "util";
import { logger } from "@copilotkitnext/shared";
var streamPipeline = promisify(pipeline);
var METHODS_WITHOUT_BODY = /* @__PURE__ */ new Set(["GET", "HEAD"]);
function createFetchRequestFromExpress(req) {
  const method = req.method?.toUpperCase() ?? "GET";
  const origin = buildOrigin(req);
  const url = `${origin}${req.originalUrl ?? req.url ?? ""}`;
  const headers = new Headers();
  for (const [key, value] of Object.entries(req.headers)) {
    if (value === void 0) continue;
    if (Array.isArray(value)) {
      value.forEach((v) => headers.append(key, v));
    } else {
      headers.set(key, value);
    }
  }
  const init = {
    method,
    headers
  };
  const hasParsedBody = req.body !== void 0 && req.body !== null;
  const streamConsumed = isStreamConsumed(req, hasParsedBody);
  if (!METHODS_WITHOUT_BODY.has(method)) {
    const canStreamBody = req.readable !== false && !streamConsumed;
    if (canStreamBody) {
      init.body = Readable.toWeb(req);
      init.duplex = "half";
    } else if (hasParsedBody) {
      const { body, contentType } = synthesizeBody(req.body);
      if (contentType) {
        headers.set("content-type", contentType);
      }
      headers.delete("content-length");
      if (body !== void 0) {
        init.body = body;
      }
      logger.info(
        {
          url,
          method,
          readable: req.readable,
          readableEnded: req.readableEnded,
          complete: req.complete
        },
        "Express request stream already consumed; synthesized body from parsed content"
      );
    } else {
      headers.delete("content-length");
      logger.warn(
        { url, method },
        "Request stream already consumed but no body was available; sending empty body"
      );
    }
  }
  const controller = new AbortController();
  const abort = () => controller.abort();
  req.on("aborted", abort);
  req.on("error", abort);
  req.on("close", () => {
    if (req.aborted) {
      abort();
    }
  });
  init.signal = controller.signal;
  try {
    return new Request(url, init);
  } catch (error) {
    if (error instanceof TypeError && /disturbed|locked/i.test(error.message)) {
      headers.delete("content-length");
      delete init.duplex;
      if (hasParsedBody) {
        const { body, contentType } = synthesizeBody(req.body);
        if (contentType) {
          headers.set("content-type", contentType);
        }
        init.body = body;
        logger.info(
          { url, method },
          "Request stream disturbed while constructing Request; reused parsed body"
        );
      } else {
        init.body = void 0;
        logger.warn(
          { url, method },
          "Request stream was disturbed; falling back to empty body"
        );
      }
      return new Request(url, init);
    }
    throw error;
  }
}
async function sendFetchResponse(res, response) {
  res.status(response.status);
  response.headers.forEach((value, key) => {
    if (key.toLowerCase() === "content-length" && response.body !== null) {
      return;
    }
    res.setHeader(key, value);
  });
  if (!response.body) {
    res.end();
    return;
  }
  const nodeStream = Readable.fromWeb(response.body);
  try {
    await streamPipeline(nodeStream, res);
  } catch (error) {
    res.destroy(error);
    throw error;
  }
}
function buildOrigin(req) {
  const protocol = req.protocol || (req.secure ? "https" : "http");
  const host = req.get("host") ?? "localhost";
  return `${protocol}://${host}`;
}
function isStreamConsumed(req, hasParsedBody) {
  const state = req._readableState;
  return Boolean(
    hasParsedBody || req.readableEnded || req.complete || state?.ended || state?.endEmitted
  );
}
function synthesizeBody(body) {
  if (Buffer.isBuffer(body) || body instanceof Uint8Array) {
    return { body };
  }
  if (typeof body === "string") {
    return { body };
  }
  if (typeof body === "object" && body !== void 0) {
    return { body: JSON.stringify(body), contentType: "application/json" };
  }
  return {};
}

// src/endpoints/express.ts
function createCopilotEndpointExpress({ runtime, basePath }) {
  const router = express.Router();
  const normalizedBase = normalizeBasePath(basePath);
  router.use(cors({
    origin: "*",
    methods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH", "OPTIONS"],
    allowedHeaders: ["*"]
  }));
  router.post(joinPath(normalizedBase, "/agent/:agentId/run"), createRouteHandler(runtime, async ({ request, req }) => {
    const agentId = req.params.agentId;
    return handleRunAgent({ runtime, request, agentId });
  }));
  router.post(joinPath(normalizedBase, "/agent/:agentId/connect"), createRouteHandler(runtime, async ({ request, req }) => {
    const agentId = req.params.agentId;
    return handleConnectAgent({ runtime, request, agentId });
  }));
  router.post(joinPath(normalizedBase, "/agent/:agentId/stop/:threadId"), createRouteHandler(runtime, async ({ request, req }) => {
    const agentId = req.params.agentId;
    const threadId = req.params.threadId;
    return handleStopAgent({ runtime, request, agentId, threadId });
  }));
  router.get(joinPath(normalizedBase, "/info"), createRouteHandler(runtime, async ({ request }) => {
    return handleGetRuntimeInfo({ runtime, request });
  }));
  router.post(joinPath(normalizedBase, "/transcribe"), createRouteHandler(runtime, async ({ request }) => {
    return handleTranscribe({ runtime, request });
  }));
  router.use(joinPath(normalizedBase, "*"), (req, res) => {
    res.status(404).json({ error: "Not found" });
  });
  return router;
}
function createRouteHandler(runtime, factory) {
  return async (req, res, next) => {
    const path = req.originalUrl ?? req.path;
    let request = createFetchRequestFromExpress(req);
    try {
      const maybeModifiedRequest = await callBeforeRequestMiddleware({ runtime, request, path });
      if (maybeModifiedRequest) {
        request = maybeModifiedRequest;
      }
    } catch (error) {
      logger2.error({ err: error, url: request.url, path }, "Error running before request middleware");
      if (error instanceof Response) {
        try {
          await sendFetchResponse(res, error);
        } catch (streamError) {
          next(streamError);
        }
        return;
      }
      next(error);
      return;
    }
    try {
      const response = await factory({ request, req });
      await sendFetchResponse(res, response);
      callAfterRequestMiddleware({ runtime, response, path }).catch((error) => {
        logger2.error({ err: error, url: req.originalUrl ?? req.url, path }, "Error running after request middleware");
      });
    } catch (error) {
      if (error instanceof Response) {
        try {
          await sendFetchResponse(res, error);
        } catch (streamError) {
          next(streamError);
          return;
        }
        callAfterRequestMiddleware({ runtime, response: error, path }).catch((mwError) => {
          logger2.error({ err: mwError, url: req.originalUrl ?? req.url, path }, "Error running after request middleware");
        });
        return;
      }
      logger2.error({ err: error, url: request.url, path }, "Error running request handler");
      next(error);
    }
  };
}
function normalizeBasePath(path) {
  if (!path) {
    throw new Error("basePath must be provided for Express endpoint");
  }
  if (!path.startsWith("/")) {
    return `/${path}`;
  }
  if (path.length > 1 && path.endsWith("/")) {
    return path.slice(0, -1);
  }
  return path;
}
function joinPath(basePath, suffix) {
  if (basePath === "/") {
    return suffix.startsWith("/") ? suffix : `/${suffix}`;
  }
  if (!suffix) {
    return basePath;
  }
  if (suffix === "*") {
    return `${basePath}/*`;
  }
  return `${basePath}${suffix.startsWith("/") ? suffix : `/${suffix}`}`;
}

// src/endpoints/express-single.ts
import express2 from "express";
import cors2 from "cors";
import { logger as logger3 } from "@copilotkitnext/shared";
function createCopilotEndpointSingleRouteExpress({
  runtime,
  basePath
}) {
  const router = express2.Router();
  const routePath = normalizeSingleRoutePath(basePath);
  router.use(cors2({
    origin: "*",
    methods: ["GET", "HEAD", "PUT", "POST", "DELETE", "PATCH", "OPTIONS"],
    allowedHeaders: ["*"]
  }));
  router.post(routePath, createSingleRouteHandler(runtime));
  router.use((req, res) => {
    res.status(404).json({ error: "Not found" });
  });
  return router;
}
function createSingleRouteHandler(runtime) {
  return async (req, res, next) => {
    const path = req.originalUrl ?? req.path;
    let request = createFetchRequestFromExpress(req);
    try {
      const maybeModifiedRequest = await callBeforeRequestMiddleware({ runtime, request, path });
      if (maybeModifiedRequest) {
        request = maybeModifiedRequest;
      }
    } catch (error) {
      logger3.error({ err: error, url: request.url, path }, "Error running before request middleware");
      if (error instanceof Response) {
        try {
          await sendFetchResponse(res, error);
        } catch (streamError) {
          next(streamError);
        }
        return;
      }
      next(error);
      return;
    }
    let methodCall;
    try {
      methodCall = await parseMethodCall(request);
    } catch (error) {
      if (error instanceof Response) {
        logger3.warn({ url: request.url }, "Invalid single-route payload");
        try {
          await sendFetchResponse(res, error);
        } catch (streamError) {
          next(streamError);
        }
        return;
      }
      logger3.warn({ err: error, url: request.url }, "Invalid single-route payload");
      res.status(400).json({
        error: "invalid_request",
        message: error instanceof Error ? error.message : "Invalid request payload"
      });
      return;
    }
    try {
      let response;
      switch (methodCall.method) {
        case "agent/run": {
          const agentId = expectString(methodCall.params, "agentId");
          const handlerRequest = createJsonRequest(request, methodCall.body);
          response = await handleRunAgent({ runtime, request: handlerRequest, agentId });
          break;
        }
        case "agent/connect": {
          const agentId = expectString(methodCall.params, "agentId");
          const handlerRequest = createJsonRequest(request, methodCall.body);
          response = await handleConnectAgent({ runtime, request: handlerRequest, agentId });
          break;
        }
        case "agent/stop": {
          const agentId = expectString(methodCall.params, "agentId");
          const threadId = expectString(methodCall.params, "threadId");
          response = await handleStopAgent({ runtime, request, agentId, threadId });
          break;
        }
        case "info": {
          response = await handleGetRuntimeInfo({ runtime, request });
          break;
        }
        case "transcribe": {
          const handlerRequest = createJsonRequest(request, methodCall.body);
          response = await handleTranscribe({ runtime, request: handlerRequest });
          break;
        }
        default: {
          const exhaustive = methodCall.method;
          return exhaustive;
        }
      }
      await sendFetchResponse(res, response);
      callAfterRequestMiddleware({ runtime, response, path }).catch((error) => {
        logger3.error({ err: error, url: req.originalUrl ?? req.url, path }, "Error running after request middleware");
      });
    } catch (error) {
      if (error instanceof Response) {
        try {
          await sendFetchResponse(res, error);
        } catch (streamError) {
          next(streamError);
          return;
        }
        callAfterRequestMiddleware({ runtime, response: error, path }).catch((mwError) => {
          logger3.error({ err: mwError, url: req.originalUrl ?? req.url, path }, "Error running after request middleware");
        });
        return;
      }
      logger3.error({ err: error, url: request.url, path }, "Error running single-route handler");
      next(error);
    }
  };
}
function normalizeSingleRoutePath(path) {
  if (!path) {
    throw new Error("basePath must be provided for Express single-route endpoint");
  }
  if (!path.startsWith("/")) {
    return `/${path}`;
  }
  if (path.length > 1 && path.endsWith("/")) {
    return path.slice(0, -1);
  }
  return path;
}
export {
  createCopilotEndpointExpress,
  createCopilotEndpointSingleRouteExpress
};
//# sourceMappingURL=express.mjs.map