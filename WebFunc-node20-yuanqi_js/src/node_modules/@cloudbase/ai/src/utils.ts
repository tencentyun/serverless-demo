import { TransformStream as _TransformStream, ReadableStream as _ReadableStream } from 'web-streams-polyfill'
import { createReadableStreamWrapper } from '@mattiasbuelens/web-streams-adapter'
import { createParser, type EventSourceParser, type ParsedEvent } from './eventsource_parser'
import type {
  AsyncIterableReadableStream,
  ChatModelMessage,
  ToolCallAssistantMessage,
  ModelTool,
  FunctionTool,
} from './type'
import { TextDecoder } from 'text-encoding-shim'

export const ReadableStream = _ReadableStream as {
  prototype: ReadableStream

  new (
    underlyingSource: UnderlyingByteSource,
    strategy?: {
      highWaterMark?: number
    },
  ): ReadableStream<Uint8Array>
  new <R = any>(underlyingSource: UnderlyingDefaultSource<R>, strategy?: QueuingStrategy<R>): ReadableStream<R>
  new <R = any>(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>): ReadableStream<R>
}

export const TransformStream = _TransformStream as {
  prototype: TransformStream

  new <I = any, O = any>(
    transformer?: Transformer<I, O>,
    writableStrategy?: QueuingStrategy<I>,
    readableStrategy?: QueuingStrategy<O>,
  ): TransformStream<I, O>
}

export const createEventSourceParserTransformStream = () => {
  let parser!: EventSourceParser

  return new TransformStream<string, ParsedEvent>({
    start(controller) {
      parser = createParser((event) => {
        if (event.type === 'event') {
          controller.enqueue(event)
        }
      })
    },
    transform(chunk) {
      parser.feed(chunk)
    },
  })
}

export const toPolyfillReadable = createReadableStreamWrapper(ReadableStream)

export class TextDecoderStream {
  private handle: TextDecoder

  private transform = new TransformStream({
    transform: (chunk, controller) => {
      const value = this.handle.decode(new Uint8Array(chunk), { stream: true })

      if (value) {
        controller.enqueue(value)
      }
    },
    flush: (controller) => {
      const value = this.handle.decode()
      if (value) {
        controller.enqueue(value)
      }

      controller.terminate()
    },
  })

  constructor(encoding = 'utf-8', options: TextDecoderOptions = {}) {
    this.handle = new TextDecoder(encoding, options)
  }

  get encoding() {
    return this.handle.encoding
  }

  get fatal() {
    return this.handle.fatal
  }

  get ignoreBOM() {
    return this.handle.ignoreBOM
  }

  get readable() {
    return this.transform.readable
  }

  get writable() {
    return this.transform.writable
  }

  get [Symbol.toStringTag]() {
    return 'TextDecoderStream'
  }
}

export function createAsyncIterable<T>(stream: ReadableStream<T>) {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  const _stream = stream as AsyncIterableReadableStream<T>
  (_stream as any)[Symbol.asyncIterator] = () => {
    const reader = stream.getReader()
    return {
      async next(): Promise<IteratorResult<T>> {
        const { done, value } = await reader.read()
        return done ? { done: true, value: undefined } : { done: false, value }
      },
    }
  }
  return _stream
}

/**
 * 将 SSE 二进制流转换为 T 类型的流
 */
export function intoStandardStream<T>(stream: ReadableStream<Uint8Array>): ReadableStream<T> {
  return createAsyncIterable(stream
    .pipeThrough(new TextDecoderStream())
    .pipeThrough(createEventSourceParserTransformStream())
    .pipeThrough(new TransformStream<ParsedEvent, T>({
      transform(chunk, controller) {
        try {
          const data = JSON.parse(chunk.data) as T
          controller.enqueue(data)
        } catch (e) {
          if (chunk.data !== '[DONE]') {
            console.warn('Error when transforming event source data to json', e, chunk)
          } else {
            controller.terminate()
          }
        }
      },
    }),),)
}

/**
 * 将 SSE 二进制流转换为字符串流
 */
export function intoTextStream(stream: ReadableStream<Uint8Array>): AsyncIterableReadableStream<string> {
  return createAsyncIterable((toPolyfillReadable(stream) as typeof stream).pipeThrough(new TextDecoderStream()))
}

export async function readableStream2JsonObject(stream: ReadableStream) {
  const s = intoTextStream(stream)
  let total = ''
  for await (const chunk of s) {
    total += chunk
  }
  return JSON.parse(total)
}

export function createPromise<T = unknown>() {
  let res: (value: T | PromiseLike<T>) => void
  let rej: (reason?: any) => void
  const promise = new Promise<T>((resolve, reject) => {
    res = resolve
    rej = reject
  })
  return { promise, res, rej }
}

export function isToolCallAssistantMessage(message: ChatModelMessage): message is ToolCallAssistantMessage {
  // eslint-disable-next-line eqeqeq
  return message.role === 'assistant' && 'tool_calls' in message && message.tool_calls?.[0] != null
}

export function functionToolToModelTool(tool: FunctionTool): ModelTool {
  return {
    type: 'function',
    function: {
      description: tool.description,
      name: tool.name,
      parameters: tool.parameters,
    },
  }
}
