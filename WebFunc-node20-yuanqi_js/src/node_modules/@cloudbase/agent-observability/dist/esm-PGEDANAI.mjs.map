{"version":3,"sources":["../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/OTLPExporterBase.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/types.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/configuration/shared-configuration.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/bounded-queue-export-promise-handler.ts","../../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/src/baggage/constants.ts","../../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/src/baggage/utils.ts","../../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/src/platform/node/environment.ts","../../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/src/common/time.ts","../../../node_modules/.pnpm/@opentelemetry+core@2.4.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/core/src/ExportResult.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/logging-response-handler.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/otlp-export-delegate.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/src/common/hex-to-binary.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/src/common/utils.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/src/common/internal.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/src/trace/internal.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-transformer@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-transformer/src/trace/json/trace.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/util.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/configuration/otlp-http-configuration.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/configuration/otlp-node-http-configuration.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/transport/http-transport-utils.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/is-export-retryable.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/version.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/transport/http-exporter-transport.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/retrying-transport.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/otlp-http-export-delegate.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/configuration/shared-env-configuration.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/configuration/convert-legacy-node-http-options.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/configuration/otlp-node-http-env-configuration.ts","../../../node_modules/.pnpm/@opentelemetry+otlp-exporter-base@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/otlp-exporter-base/src/configuration/convert-legacy-http-options.ts","../../../node_modules/.pnpm/@opentelemetry+exporter-trace-otlp-http@0.210.0_@opentelemetry+api@1.9.0/node_modules/@opentelemetry/exporter-trace-otlp-http/src/platform/node/OTLPTraceExporter.ts"],"sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ExportResult } from '@opentelemetry/core';\nimport { IOtlpExportDelegate } from './otlp-export-delegate';\n\nexport class OTLPExporterBase<Internal> {\n  private _delegate: IOtlpExportDelegate<Internal>;\n  constructor(delegate: IOtlpExportDelegate<Internal>) {\n    this._delegate = delegate;\n  }\n\n  /**\n   * Export items.\n   * @param items\n   * @param resultCallback\n   */\n  export(\n    items: Internal,\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    this._delegate.export(items, resultCallback);\n  }\n\n  forceFlush(): Promise<void> {\n    return this._delegate.forceFlush();\n  }\n\n  shutdown(): Promise<void> {\n    return this._delegate.shutdown();\n  }\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * Interface for handling error\n */\nexport class OTLPExporterError extends Error {\n  readonly code?: number;\n  override readonly name: string = 'OTLPExporterError';\n  readonly data?: string;\n\n  constructor(message?: string, code?: number, data?: string) {\n    super(message);\n    this.data = data;\n    this.code = code;\n  }\n}\n\n/**\n * Interface for handling export service errors\n */\nexport interface ExportServiceError {\n  name: string;\n  code: number;\n  details: string;\n  metadata: { [key: string]: unknown };\n  message: string;\n  stack: string;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { HeadersFactory } from './otlp-http-configuration';\n\n/**\n * Configuration shared across all OTLP exporters\n *\n * Implementation note: anything added here MUST be\n * - platform-agnostic\n * - signal-agnostic\n * - transport-agnostic\n */\nexport interface OtlpSharedConfiguration {\n  timeoutMillis: number;\n  concurrencyLimit: number;\n  compression: 'gzip' | 'none';\n}\n\nexport function validateTimeoutMillis(timeoutMillis: number) {\n  if (Number.isFinite(timeoutMillis) && timeoutMillis > 0) {\n    return timeoutMillis;\n  }\n  throw new Error(\n    `Configuration: timeoutMillis is invalid, expected number greater than 0 (actual: '${timeoutMillis}')`\n  );\n}\n\nexport function wrapStaticHeadersInFunction(\n  headers: Record<string, string> | undefined\n): HeadersFactory | undefined {\n  if (headers == null) {\n    return undefined;\n  }\n\n  return async () => headers;\n}\n\n/**\n * @param userProvidedConfiguration  Configuration options provided by the user in code.\n * @param fallbackConfiguration Fallback to use when the {@link userProvidedConfiguration} does not specify an option.\n * @param defaultConfiguration The defaults as defined by the exporter specification\n */\nexport function mergeOtlpSharedConfigurationWithDefaults(\n  userProvidedConfiguration: Partial<OtlpSharedConfiguration>,\n  fallbackConfiguration: Partial<OtlpSharedConfiguration>,\n  defaultConfiguration: OtlpSharedConfiguration\n): OtlpSharedConfiguration {\n  return {\n    timeoutMillis: validateTimeoutMillis(\n      userProvidedConfiguration.timeoutMillis ??\n        fallbackConfiguration.timeoutMillis ??\n        defaultConfiguration.timeoutMillis\n    ),\n    concurrencyLimit:\n      userProvidedConfiguration.concurrencyLimit ??\n      fallbackConfiguration.concurrencyLimit ??\n      defaultConfiguration.concurrencyLimit,\n    compression:\n      userProvidedConfiguration.compression ??\n      fallbackConfiguration.compression ??\n      defaultConfiguration.compression,\n  };\n}\n\nexport function getSharedConfigurationDefaults(): OtlpSharedConfiguration {\n  return {\n    timeoutMillis: 10000,\n    concurrencyLimit: 30,\n    compression: 'none',\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface IExportPromiseHandler {\n  pushPromise(promise: Promise<void>): void;\n  hasReachedLimit(): boolean;\n  awaitAll(): Promise<void>;\n}\n\nclass BoundedQueueExportPromiseHandler implements IExportPromiseHandler {\n  private readonly _concurrencyLimit: number;\n  private _sendingPromises: Promise<unknown>[] = [];\n\n  /**\n   * @param concurrencyLimit maximum promises allowed in a queue at the same time.\n   */\n  constructor(concurrencyLimit: number) {\n    this._concurrencyLimit = concurrencyLimit;\n  }\n\n  public pushPromise(promise: Promise<void>): void {\n    if (this.hasReachedLimit()) {\n      throw new Error('Concurrency Limit reached');\n    }\n\n    this._sendingPromises.push(promise);\n    const popPromise = () => {\n      const index = this._sendingPromises.indexOf(promise);\n      void this._sendingPromises.splice(index, 1);\n    };\n    promise.then(popPromise, popPromise);\n  }\n\n  public hasReachedLimit(): boolean {\n    return this._sendingPromises.length >= this._concurrencyLimit;\n  }\n\n  public async awaitAll(): Promise<void> {\n    await Promise.all(this._sendingPromises);\n  }\n}\n\n/**\n * Promise queue for keeping track of export promises. Finished promises will be auto-dequeued.\n * Allows for awaiting all promises in the queue.\n */\nexport function createBoundedQueueExportPromiseHandler(options: {\n  concurrencyLimit: number;\n}): IExportPromiseHandler {\n  return new BoundedQueueExportPromiseHandler(options.concurrencyLimit);\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const BAGGAGE_KEY_PAIR_SEPARATOR = '=';\nexport const BAGGAGE_PROPERTIES_SEPARATOR = ';';\nexport const BAGGAGE_ITEMS_SEPARATOR = ',';\n\n// Name of the http header used to propagate the baggage\nexport const BAGGAGE_HEADER = 'baggage';\n// Maximum number of name-value pairs allowed by w3c spec\nexport const BAGGAGE_MAX_NAME_VALUE_PAIRS = 180;\n// Maximum number of bytes per a single name-value pair allowed by w3c spec\nexport const BAGGAGE_MAX_PER_NAME_VALUE_PAIRS = 4096;\n// Maximum total length of all name-value pairs allowed by w3c spec\nexport const BAGGAGE_MAX_TOTAL_LENGTH = 8192;\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  Baggage,\n  BaggageEntryMetadata,\n  baggageEntryMetadataFromString,\n} from '@opentelemetry/api';\nimport {\n  BAGGAGE_ITEMS_SEPARATOR,\n  BAGGAGE_PROPERTIES_SEPARATOR,\n  BAGGAGE_KEY_PAIR_SEPARATOR,\n  BAGGAGE_MAX_TOTAL_LENGTH,\n} from './constants';\n\ntype ParsedBaggageKeyValue = {\n  key: string;\n  value: string;\n  metadata: BaggageEntryMetadata | undefined;\n};\n\nexport function serializeKeyPairs(keyPairs: string[]): string {\n  return keyPairs.reduce((hValue: string, current: string) => {\n    const value = `${hValue}${\n      hValue !== '' ? BAGGAGE_ITEMS_SEPARATOR : ''\n    }${current}`;\n    return value.length > BAGGAGE_MAX_TOTAL_LENGTH ? hValue : value;\n  }, '');\n}\n\nexport function getKeyPairs(baggage: Baggage): string[] {\n  return baggage.getAllEntries().map(([key, value]) => {\n    let entry = `${encodeURIComponent(key)}=${encodeURIComponent(value.value)}`;\n\n    // include opaque metadata if provided\n    // NOTE: we intentionally don't URI-encode the metadata - that responsibility falls on the metadata implementation\n    if (value.metadata !== undefined) {\n      entry += BAGGAGE_PROPERTIES_SEPARATOR + value.metadata.toString();\n    }\n\n    return entry;\n  });\n}\n\nexport function parsePairKeyValue(\n  entry: string\n): ParsedBaggageKeyValue | undefined {\n  if (!entry) return;\n  const metadataSeparatorIndex = entry.indexOf(BAGGAGE_PROPERTIES_SEPARATOR);\n  const keyPairPart =\n    metadataSeparatorIndex === -1\n      ? entry\n      : entry.substring(0, metadataSeparatorIndex);\n\n  const separatorIndex = keyPairPart.indexOf(BAGGAGE_KEY_PAIR_SEPARATOR);\n  if (separatorIndex <= 0) return;\n\n  const rawKey = keyPairPart.substring(0, separatorIndex).trim();\n  const rawValue = keyPairPart.substring(separatorIndex + 1).trim();\n\n  if (!rawKey || !rawValue) return;\n  let key: string;\n  let value: string;\n  try {\n    key = decodeURIComponent(rawKey);\n    value = decodeURIComponent(rawValue);\n  } catch {\n    return;\n  }\n\n  let metadata;\n  if (\n    metadataSeparatorIndex !== -1 &&\n    metadataSeparatorIndex < entry.length - 1\n  ) {\n    const metadataString = entry.substring(metadataSeparatorIndex + 1);\n    metadata = baggageEntryMetadataFromString(metadataString);\n  }\n\n  return { key, value, metadata };\n}\n\n/**\n * Parse a string serialized in the baggage HTTP Format (without metadata):\n * https://github.com/w3c/baggage/blob/master/baggage/HTTP_HEADER_FORMAT.md\n */\nexport function parseKeyPairsIntoRecord(\n  value?: string\n): Record<string, string> {\n  const result: Record<string, string> = {};\n\n  if (typeof value === 'string' && value.length > 0) {\n    value.split(BAGGAGE_ITEMS_SEPARATOR).forEach(entry => {\n      const keyPair = parsePairKeyValue(entry);\n\n      if (keyPair !== undefined && keyPair.value.length > 0) {\n        result[keyPair.key] = keyPair.value;\n      }\n    });\n  }\n\n  return result;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag } from '@opentelemetry/api';\nimport { inspect } from 'util';\n\n/**\n * Retrieves a number from an environment variable.\n * - Returns `undefined` if the environment variable is empty, unset, contains only whitespace, or is not a number.\n * - Returns a number in all other cases.\n *\n * @param {string} key - The name of the environment variable to retrieve.\n * @returns {number | undefined} - The number value or `undefined`.\n */\nexport function getNumberFromEnv(key: string): number | undefined {\n  const raw = process.env[key];\n  if (raw == null || raw.trim() === '') {\n    return undefined;\n  }\n\n  const value = Number(raw);\n  if (isNaN(value)) {\n    diag.warn(\n      `Unknown value ${inspect(raw)} for ${key}, expected a number, using defaults`\n    );\n    return undefined;\n  }\n\n  return value;\n}\n\n/**\n * Retrieves a string from an environment variable.\n * - Returns `undefined` if the environment variable is empty, unset, or contains only whitespace.\n *\n * @param {string} key - The name of the environment variable to retrieve.\n * @returns {string | undefined} - The string value or `undefined`.\n */\nexport function getStringFromEnv(key: string): string | undefined {\n  const raw = process.env[key];\n  if (raw == null || raw.trim() === '') {\n    return undefined;\n  }\n  return raw;\n}\n\n/**\n * Retrieves a boolean value from an environment variable.\n * - Trims leading and trailing whitespace and ignores casing.\n * - Returns `false` if the environment variable is empty, unset, or contains only whitespace.\n * - Returns `false` for strings that cannot be mapped to a boolean.\n *\n * @param {string} key - The name of the environment variable to retrieve.\n * @returns {boolean} - The boolean value or `false` if the environment variable is unset empty, unset, or contains only whitespace.\n */\nexport function getBooleanFromEnv(key: string): boolean {\n  const raw = process.env[key]?.trim().toLowerCase();\n  if (raw == null || raw === '') {\n    // NOTE: falling back to `false` instead of `undefined` as required by the specification.\n    // If you have a use-case that requires `undefined`, consider using `getStringFromEnv()` and applying the necessary\n    // normalizations in the consuming code.\n    return false;\n  }\n  if (raw === 'true') {\n    return true;\n  } else if (raw === 'false') {\n    return false;\n  } else {\n    diag.warn(\n      `Unknown value ${inspect(raw)} for ${key}, expected 'true' or 'false', falling back to 'false' (default)`\n    );\n    return false;\n  }\n}\n\n/**\n * Retrieves a list of strings from an environment variable.\n * - Uses ',' as the delimiter.\n * - Trims leading and trailing whitespace from each entry.\n * - Excludes empty entries.\n * - Returns `undefined` if the environment variable is empty or contains only whitespace.\n * - Returns an empty array if all entries are empty or whitespace.\n *\n * @param {string} key - The name of the environment variable to retrieve.\n * @returns {string[] | undefined} - The list of strings or `undefined`.\n */\nexport function getStringListFromEnv(key: string): string[] | undefined {\n  return getStringFromEnv(key)\n    ?.split(',')\n    .map(v => v.trim())\n    .filter(s => s !== '');\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport * as api from '@opentelemetry/api';\nimport { otperformance as performance } from '../platform';\n\nconst NANOSECOND_DIGITS = 9;\nconst NANOSECOND_DIGITS_IN_MILLIS = 6;\nconst MILLISECONDS_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS_IN_MILLIS);\nconst SECOND_TO_NANOSECONDS = Math.pow(10, NANOSECOND_DIGITS);\n\n/**\n * Converts a number of milliseconds from epoch to HrTime([seconds, remainder in nanoseconds]).\n * @param epochMillis\n */\nexport function millisToHrTime(epochMillis: number): api.HrTime {\n  const epochSeconds = epochMillis / 1000;\n  // Decimals only.\n  const seconds = Math.trunc(epochSeconds);\n  // Round sub-nanosecond accuracy to nanosecond.\n  const nanos = Math.round((epochMillis % 1000) * MILLISECONDS_TO_NANOSECONDS);\n  return [seconds, nanos];\n}\n\n/**\n * @deprecated Use `performance.timeOrigin` directly.\n */\nexport function getTimeOrigin(): number {\n  return performance.timeOrigin;\n}\n\n/**\n * Returns an hrtime calculated via performance component.\n * @param performanceNow\n */\nexport function hrTime(performanceNow?: number): api.HrTime {\n  const timeOrigin = millisToHrTime(performance.timeOrigin);\n  const now = millisToHrTime(\n    typeof performanceNow === 'number' ? performanceNow : performance.now()\n  );\n\n  return addHrTimes(timeOrigin, now);\n}\n\n/**\n *\n * Converts a TimeInput to an HrTime, defaults to _hrtime().\n * @param time\n */\nexport function timeInputToHrTime(time: api.TimeInput): api.HrTime {\n  // process.hrtime\n  if (isTimeInputHrTime(time)) {\n    return time as api.HrTime;\n  } else if (typeof time === 'number') {\n    // Must be a performance.now() if it's smaller than process start time.\n    if (time < performance.timeOrigin) {\n      return hrTime(time);\n    } else {\n      // epoch milliseconds or performance.timeOrigin\n      return millisToHrTime(time);\n    }\n  } else if (time instanceof Date) {\n    return millisToHrTime(time.getTime());\n  } else {\n    throw TypeError('Invalid input type');\n  }\n}\n\n/**\n * Returns a duration of two hrTime.\n * @param startTime\n * @param endTime\n */\nexport function hrTimeDuration(\n  startTime: api.HrTime,\n  endTime: api.HrTime\n): api.HrTime {\n  let seconds = endTime[0] - startTime[0];\n  let nanos = endTime[1] - startTime[1];\n\n  // overflow\n  if (nanos < 0) {\n    seconds -= 1;\n    // negate\n    nanos += SECOND_TO_NANOSECONDS;\n  }\n\n  return [seconds, nanos];\n}\n\n/**\n * Convert hrTime to timestamp, for example \"2019-05-14T17:00:00.000123456Z\"\n * @param time\n */\nexport function hrTimeToTimeStamp(time: api.HrTime): string {\n  const precision = NANOSECOND_DIGITS;\n  const tmp = `${'0'.repeat(precision)}${time[1]}Z`;\n  const nanoString = tmp.substring(tmp.length - precision - 1);\n  const date = new Date(time[0] * 1000).toISOString();\n  return date.replace('000Z', nanoString);\n}\n\n/**\n * Convert hrTime to nanoseconds.\n * @param time\n */\nexport function hrTimeToNanoseconds(time: api.HrTime): number {\n  return time[0] * SECOND_TO_NANOSECONDS + time[1];\n}\n\n/**\n * Convert hrTime to milliseconds.\n * @param time\n */\nexport function hrTimeToMilliseconds(time: api.HrTime): number {\n  return time[0] * 1e3 + time[1] / 1e6;\n}\n\n/**\n * Convert hrTime to microseconds.\n * @param time\n */\nexport function hrTimeToMicroseconds(time: api.HrTime): number {\n  return time[0] * 1e6 + time[1] / 1e3;\n}\n\n/**\n * check if time is HrTime\n * @param value\n */\nexport function isTimeInputHrTime(value: unknown): value is api.HrTime {\n  return (\n    Array.isArray(value) &&\n    value.length === 2 &&\n    typeof value[0] === 'number' &&\n    typeof value[1] === 'number'\n  );\n}\n\n/**\n * check if input value is a correct types.TimeInput\n * @param value\n */\nexport function isTimeInput(\n  value: unknown\n): value is api.HrTime | number | Date {\n  return (\n    isTimeInputHrTime(value) ||\n    typeof value === 'number' ||\n    value instanceof Date\n  );\n}\n\n/**\n * Given 2 HrTime formatted times, return their sum as an HrTime.\n */\nexport function addHrTimes(time1: api.HrTime, time2: api.HrTime): api.HrTime {\n  const out = [time1[0] + time2[0], time1[1] + time2[1]] as api.HrTime;\n\n  // Nanoseconds\n  if (out[1] >= SECOND_TO_NANOSECONDS) {\n    out[1] -= SECOND_TO_NANOSECONDS;\n    out[0] += 1;\n  }\n\n  return out;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport interface ExportResult {\n  code: ExportResultCode;\n  error?: Error;\n}\n\nexport enum ExportResultCode {\n  SUCCESS,\n  FAILED,\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { diag } from '@opentelemetry/api';\nimport { IOtlpResponseHandler } from './response-handler';\n\nfunction isPartialSuccessResponse(\n  response: unknown\n): response is { partialSuccess: never } {\n  return Object.prototype.hasOwnProperty.call(response, 'partialSuccess');\n}\n\n/**\n * Default response handler that logs a partial success to the console.\n */\nexport function createLoggingPartialSuccessResponseHandler<\n  T,\n>(): IOtlpResponseHandler<T> {\n  return {\n    handleResponse(response: T) {\n      // Partial success MUST never be an empty object according the specification\n      // see https://opentelemetry.io/docs/specs/otlp/#partial-success\n      if (\n        response == null ||\n        !isPartialSuccessResponse(response) ||\n        response.partialSuccess == null ||\n        Object.keys(response.partialSuccess).length === 0\n      ) {\n        return;\n      }\n      diag.warn(\n        'Received Partial Success response:',\n        JSON.stringify(response.partialSuccess)\n      );\n    },\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ExportResult, ExportResultCode } from '@opentelemetry/core';\nimport { IExporterTransport } from './exporter-transport';\nimport { IExportPromiseHandler } from './bounded-queue-export-promise-handler';\nimport { ISerializer } from '@opentelemetry/otlp-transformer';\nimport { OTLPExporterError } from './types';\nimport { IOtlpResponseHandler } from './response-handler';\nimport { createLoggingPartialSuccessResponseHandler } from './logging-response-handler';\nimport { diag, DiagLogger } from '@opentelemetry/api';\n\n/**\n * Internally shared export logic for OTLP.\n */\nexport interface IOtlpExportDelegate<Internal> {\n  export(\n    internalRepresentation: Internal,\n    resultCallback: (result: ExportResult) => void\n  ): void;\n  forceFlush(): Promise<void>;\n  shutdown(): Promise<void>;\n}\n\nclass OTLPExportDelegate<Internal, Response>\n  implements IOtlpExportDelegate<Internal>\n{\n  private _diagLogger: DiagLogger;\n  private _transport: IExporterTransport;\n  private _serializer: ISerializer<Internal, Response>;\n  private _responseHandler: IOtlpResponseHandler<Response>;\n  private _promiseQueue: IExportPromiseHandler;\n  private _timeout: number;\n\n  constructor(\n    transport: IExporterTransport,\n    serializer: ISerializer<Internal, Response>,\n    responseHandler: IOtlpResponseHandler<Response>,\n    promiseQueue: IExportPromiseHandler,\n    timeout: number\n  ) {\n    this._transport = transport;\n    this._serializer = serializer;\n    this._responseHandler = responseHandler;\n    this._promiseQueue = promiseQueue;\n    this._timeout = timeout;\n    this._diagLogger = diag.createComponentLogger({\n      namespace: 'OTLPExportDelegate',\n    });\n  }\n\n  export(\n    internalRepresentation: Internal,\n    resultCallback: (result: ExportResult) => void\n  ): void {\n    this._diagLogger.debug('items to be sent', internalRepresentation);\n\n    // don't do any work if too many exports are in progress.\n    if (this._promiseQueue.hasReachedLimit()) {\n      resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Concurrent export limit reached'),\n      });\n      return;\n    }\n\n    const serializedRequest = this._serializer.serializeRequest(\n      internalRepresentation\n    );\n\n    if (serializedRequest == null) {\n      resultCallback({\n        code: ExportResultCode.FAILED,\n        error: new Error('Nothing to send'),\n      });\n      return;\n    }\n\n    this._promiseQueue.pushPromise(\n      this._transport.send(serializedRequest, this._timeout).then(\n        response => {\n          if (response.status === 'success') {\n            if (response.data != null) {\n              try {\n                this._responseHandler.handleResponse(\n                  this._serializer.deserializeResponse(response.data)\n                );\n              } catch (e) {\n                this._diagLogger.warn(\n                  'Export succeeded but could not deserialize response - is the response specification compliant?',\n                  e,\n                  response.data\n                );\n              }\n            }\n            // No matter the response, we can consider the export still successful.\n            resultCallback({\n              code: ExportResultCode.SUCCESS,\n            });\n            return;\n          } else if (response.status === 'failure' && response.error) {\n            resultCallback({\n              code: ExportResultCode.FAILED,\n              error: response.error,\n            });\n            return;\n          } else if (response.status === 'retryable') {\n            resultCallback({\n              code: ExportResultCode.FAILED,\n              error:\n                response.error ??\n                new OTLPExporterError('Export failed with retryable status'),\n            });\n          } else {\n            resultCallback({\n              code: ExportResultCode.FAILED,\n              error: new OTLPExporterError('Export failed with unknown error'),\n            });\n          }\n        },\n        reason =>\n          resultCallback({\n            code: ExportResultCode.FAILED,\n            error: reason,\n          })\n      )\n    );\n  }\n\n  forceFlush(): Promise<void> {\n    return this._promiseQueue.awaitAll();\n  }\n\n  async shutdown(): Promise<void> {\n    this._diagLogger.debug('shutdown started');\n    await this.forceFlush();\n    this._transport.shutdown();\n  }\n}\n\n/**\n * Creates a generic delegate for OTLP exports which only contains parts of the OTLP export that are shared across all\n * signals.\n */\nexport function createOtlpExportDelegate<Internal, Response>(\n  components: {\n    transport: IExporterTransport;\n    serializer: ISerializer<Internal, Response>;\n    promiseHandler: IExportPromiseHandler;\n  },\n  settings: { timeout: number }\n): IOtlpExportDelegate<Internal> {\n  return new OTLPExportDelegate(\n    components.transport,\n    components.serializer,\n    createLoggingPartialSuccessResponseHandler(),\n    components.promiseHandler,\n    settings.timeout\n  );\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction intValue(charCode: number): number {\n  // 0-9\n  if (charCode >= 48 && charCode <= 57) {\n    return charCode - 48;\n  }\n\n  // a-f\n  if (charCode >= 97 && charCode <= 102) {\n    return charCode - 87;\n  }\n\n  // A-F\n  return charCode - 55;\n}\n\nexport function hexToBinary(hexStr: string): Uint8Array {\n  const buf = new Uint8Array(hexStr.length / 2);\n  let offset = 0;\n\n  for (let i = 0; i < hexStr.length; i += 2) {\n    const hi = intValue(hexStr.charCodeAt(i));\n    const lo = intValue(hexStr.charCodeAt(i + 1));\n    buf[offset++] = (hi << 4) | lo;\n  }\n\n  return buf;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type { OtlpEncodingOptions, Fixed64, LongBits } from './internal-types';\nimport { HrTime } from '@opentelemetry/api';\nimport { hrTimeToNanoseconds } from '@opentelemetry/core';\nimport { hexToBinary } from './hex-to-binary';\n\nexport function hrTimeToNanos(hrTime: HrTime): bigint {\n  const NANOSECONDS = BigInt(1_000_000_000);\n  return (\n    BigInt(Math.trunc(hrTime[0])) * NANOSECONDS + BigInt(Math.trunc(hrTime[1]))\n  );\n}\n\nexport function toLongBits(value: bigint): LongBits {\n  const low = Number(BigInt.asUintN(32, value));\n  const high = Number(BigInt.asUintN(32, value >> BigInt(32)));\n  return { low, high };\n}\n\nexport function encodeAsLongBits(hrTime: HrTime): LongBits {\n  const nanos = hrTimeToNanos(hrTime);\n  return toLongBits(nanos);\n}\n\nexport function encodeAsString(hrTime: HrTime): string {\n  const nanos = hrTimeToNanos(hrTime);\n  return nanos.toString();\n}\n\nconst encodeTimestamp =\n  typeof BigInt !== 'undefined' ? encodeAsString : hrTimeToNanoseconds;\n\nexport type HrTimeEncodeFunction = (hrTime: HrTime) => Fixed64;\nexport type SpanContextEncodeFunction = (\n  spanContext: string\n) => string | Uint8Array;\nexport type OptionalSpanContextEncodeFunction = (\n  spanContext: string | undefined\n) => string | Uint8Array | undefined;\n\nexport interface Encoder {\n  encodeHrTime: HrTimeEncodeFunction;\n  encodeSpanContext: SpanContextEncodeFunction;\n  encodeOptionalSpanContext: OptionalSpanContextEncodeFunction;\n}\n\nfunction identity<T>(value: T): T {\n  return value;\n}\n\nfunction optionalHexToBinary(str: string | undefined): Uint8Array | undefined {\n  if (str === undefined) return undefined;\n  return hexToBinary(str);\n}\n\nconst DEFAULT_ENCODER: Encoder = {\n  encodeHrTime: encodeAsLongBits,\n  encodeSpanContext: hexToBinary,\n  encodeOptionalSpanContext: optionalHexToBinary,\n};\n\nexport function getOtlpEncoder(options?: OtlpEncodingOptions): Encoder {\n  if (options === undefined) {\n    return DEFAULT_ENCODER;\n  }\n\n  const useLongBits = options.useLongBits ?? true;\n  const useHex = options.useHex ?? false;\n  return {\n    encodeHrTime: useLongBits ? encodeAsLongBits : encodeTimestamp,\n    encodeSpanContext: useHex ? identity : hexToBinary,\n    encodeOptionalSpanContext: useHex ? identity : optionalHexToBinary,\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type {\n  IAnyValue,\n  IInstrumentationScope,\n  IKeyValue,\n  Resource,\n} from './internal-types';\nimport { Attributes } from '@opentelemetry/api';\nimport { InstrumentationScope } from '@opentelemetry/core';\nimport { Resource as ISdkResource } from '@opentelemetry/resources';\n\nexport function createResource(resource: ISdkResource): Resource {\n  const result: Resource = {\n    attributes: toAttributes(resource.attributes),\n    droppedAttributesCount: 0,\n  };\n\n  const schemaUrl = resource.schemaUrl;\n  if (schemaUrl && schemaUrl !== '') result.schemaUrl = schemaUrl;\n\n  return result;\n}\n\nexport function createInstrumentationScope(\n  scope: InstrumentationScope\n): IInstrumentationScope {\n  return {\n    name: scope.name,\n    version: scope.version,\n  };\n}\n\nexport function toAttributes(attributes: Attributes): IKeyValue[] {\n  return Object.keys(attributes).map(key => toKeyValue(key, attributes[key]));\n}\n\nexport function toKeyValue(key: string, value: unknown): IKeyValue {\n  return {\n    key: key,\n    value: toAnyValue(value),\n  };\n}\n\nexport function toAnyValue(value: unknown): IAnyValue {\n  const t = typeof value;\n  if (t === 'string') return { stringValue: value as string };\n  if (t === 'number') {\n    if (!Number.isInteger(value)) return { doubleValue: value as number };\n    return { intValue: value as number };\n  }\n  if (t === 'boolean') return { boolValue: value as boolean };\n  if (value instanceof Uint8Array) return { bytesValue: value };\n  if (Array.isArray(value))\n    return { arrayValue: { values: value.map(toAnyValue) } };\n  if (t === 'object' && value != null)\n    return {\n      kvlistValue: {\n        values: Object.entries(value as object).map(([k, v]) =>\n          toKeyValue(k, v)\n        ),\n      },\n    };\n\n  return {};\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type { Link } from '@opentelemetry/api';\nimport { Resource } from '@opentelemetry/resources';\nimport type { ReadableSpan, TimedEvent } from '@opentelemetry/sdk-trace-base';\nimport type { Encoder } from '../common/utils';\nimport {\n  createInstrumentationScope,\n  createResource,\n  toAttributes,\n} from '../common/internal';\nimport {\n  EStatusCode,\n  IEvent,\n  IExportTraceServiceRequest,\n  ILink,\n  IResourceSpans,\n  IScopeSpans,\n  ISpan,\n} from './internal-types';\nimport { OtlpEncodingOptions } from '../common/internal-types';\nimport { getOtlpEncoder } from '../common/utils';\n\n// Span flags constants matching the OTLP specification\nconst SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK = 0x100;\nconst SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK = 0x200;\n\n/**\n * Builds the 32-bit span flags value combining the low 8-bit W3C TraceFlags\n * with the HAS_IS_REMOTE and IS_REMOTE bits according to the OTLP spec.\n */\nfunction buildSpanFlagsFrom(traceFlags: number, isRemote?: boolean): number {\n  // low 8 bits are W3C TraceFlags (e.g., sampled)\n  let flags = (traceFlags & 0xff) | SPAN_FLAGS_CONTEXT_HAS_IS_REMOTE_MASK;\n  if (isRemote) {\n    flags |= SPAN_FLAGS_CONTEXT_IS_REMOTE_MASK;\n  }\n  return flags;\n}\n\nexport function sdkSpanToOtlpSpan(span: ReadableSpan, encoder: Encoder): ISpan {\n  const ctx = span.spanContext();\n  const status = span.status;\n  const parentSpanId = span.parentSpanContext?.spanId\n    ? encoder.encodeSpanContext(span.parentSpanContext?.spanId)\n    : undefined;\n  return {\n    traceId: encoder.encodeSpanContext(ctx.traceId),\n    spanId: encoder.encodeSpanContext(ctx.spanId),\n    parentSpanId: parentSpanId,\n    traceState: ctx.traceState?.serialize(),\n    name: span.name,\n    // Span kind is offset by 1 because the API does not define a value for unset\n    kind: span.kind == null ? 0 : span.kind + 1,\n    startTimeUnixNano: encoder.encodeHrTime(span.startTime),\n    endTimeUnixNano: encoder.encodeHrTime(span.endTime),\n    attributes: toAttributes(span.attributes),\n    droppedAttributesCount: span.droppedAttributesCount,\n    events: span.events.map(event => toOtlpSpanEvent(event, encoder)),\n    droppedEventsCount: span.droppedEventsCount,\n    status: {\n      // API and proto enums share the same values\n      code: status.code as unknown as EStatusCode,\n      message: status.message,\n    },\n    links: span.links.map(link => toOtlpLink(link, encoder)),\n    droppedLinksCount: span.droppedLinksCount,\n    flags: buildSpanFlagsFrom(ctx.traceFlags, span.parentSpanContext?.isRemote),\n  };\n}\n\nexport function toOtlpLink(link: Link, encoder: Encoder): ILink {\n  return {\n    attributes: link.attributes ? toAttributes(link.attributes) : [],\n    spanId: encoder.encodeSpanContext(link.context.spanId),\n    traceId: encoder.encodeSpanContext(link.context.traceId),\n    traceState: link.context.traceState?.serialize(),\n    droppedAttributesCount: link.droppedAttributesCount || 0,\n    flags: buildSpanFlagsFrom(link.context.traceFlags, link.context.isRemote),\n  };\n}\n\nexport function toOtlpSpanEvent(\n  timedEvent: TimedEvent,\n  encoder: Encoder\n): IEvent {\n  return {\n    attributes: timedEvent.attributes\n      ? toAttributes(timedEvent.attributes)\n      : [],\n    name: timedEvent.name,\n    timeUnixNano: encoder.encodeHrTime(timedEvent.time),\n    droppedAttributesCount: timedEvent.droppedAttributesCount || 0,\n  };\n}\n\nexport function createExportTraceServiceRequest(\n  spans: ReadableSpan[],\n  options?: OtlpEncodingOptions\n): IExportTraceServiceRequest {\n  const encoder = getOtlpEncoder(options);\n  return {\n    resourceSpans: spanRecordsToResourceSpans(spans, encoder),\n  };\n}\n\nfunction createResourceMap(readableSpans: ReadableSpan[]) {\n  const resourceMap: Map<Resource, Map<string, ReadableSpan[]>> = new Map();\n  for (const record of readableSpans) {\n    let ilsMap = resourceMap.get(record.resource);\n\n    if (!ilsMap) {\n      ilsMap = new Map();\n      resourceMap.set(record.resource, ilsMap);\n    }\n\n    // TODO this is duplicated in basic tracer. Consolidate on a common helper in core\n    const instrumentationScopeKey = `${record.instrumentationScope.name}@${\n      record.instrumentationScope.version || ''\n    }:${record.instrumentationScope.schemaUrl || ''}`;\n    let records = ilsMap.get(instrumentationScopeKey);\n\n    if (!records) {\n      records = [];\n      ilsMap.set(instrumentationScopeKey, records);\n    }\n\n    records.push(record);\n  }\n\n  return resourceMap;\n}\n\nfunction spanRecordsToResourceSpans(\n  readableSpans: ReadableSpan[],\n  encoder: Encoder\n): IResourceSpans[] {\n  const resourceMap = createResourceMap(readableSpans);\n  const out: IResourceSpans[] = [];\n\n  const entryIterator = resourceMap.entries();\n  let entry = entryIterator.next();\n  while (!entry.done) {\n    const [resource, ilmMap] = entry.value;\n    const scopeResourceSpans: IScopeSpans[] = [];\n    const ilmIterator = ilmMap.values();\n    let ilmEntry = ilmIterator.next();\n    while (!ilmEntry.done) {\n      const scopeSpans = ilmEntry.value;\n      if (scopeSpans.length > 0) {\n        const spans = scopeSpans.map(readableSpan =>\n          sdkSpanToOtlpSpan(readableSpan, encoder)\n        );\n\n        scopeResourceSpans.push({\n          scope: createInstrumentationScope(scopeSpans[0].instrumentationScope),\n          spans: spans,\n          schemaUrl: scopeSpans[0].instrumentationScope.schemaUrl,\n        });\n      }\n      ilmEntry = ilmIterator.next();\n    }\n    const processedResource = createResource(resource);\n    const transformedSpans: IResourceSpans = {\n      resource: processedResource,\n      scopeSpans: scopeResourceSpans,\n      schemaUrl: processedResource.schemaUrl,\n    };\n\n    out.push(transformedSpans);\n    entry = entryIterator.next();\n  }\n\n  return out;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ISerializer } from '../../i-serializer';\nimport { ReadableSpan } from '@opentelemetry/sdk-trace-base';\nimport { IExportTraceServiceResponse } from '../export-response';\nimport { createExportTraceServiceRequest } from '../internal';\n\nexport const JsonTraceSerializer: ISerializer<\n  ReadableSpan[],\n  IExportTraceServiceResponse\n> = {\n  serializeRequest: (arg: ReadableSpan[]) => {\n    const request = createExportTraceServiceRequest(arg, {\n      useHex: true,\n      useLongBits: false,\n    });\n    const encoder = new TextEncoder();\n    return encoder.encode(JSON.stringify(request));\n  },\n  deserializeResponse: (arg: Uint8Array) => {\n    if (arg.length === 0) {\n      return {};\n    }\n    const decoder = new TextDecoder();\n    return JSON.parse(decoder.decode(arg)) as IExportTraceServiceResponse;\n  },\n};\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { diag } from '@opentelemetry/api';\n\n/**\n * Parses headers from config leaving only those that have defined values\n * @param partialHeaders\n */\nexport function validateAndNormalizeHeaders(\n  partialHeaders: Record<string, string> | undefined\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n  Object.entries(partialHeaders ?? {}).forEach(([key, value]) => {\n    if (typeof value !== 'undefined') {\n      headers[key] = String(value);\n    } else {\n      diag.warn(\n        `Header \"${key}\" has invalid value (${value}) and will be ignored`\n      );\n    }\n  });\n  return headers;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport {\n  getSharedConfigurationDefaults,\n  mergeOtlpSharedConfigurationWithDefaults,\n  OtlpSharedConfiguration,\n} from './shared-configuration';\nimport { validateAndNormalizeHeaders } from '../util';\n\nexport type HeadersFactory = () => Promise<Record<string, string>>;\n\nexport interface OtlpHttpConfiguration extends OtlpSharedConfiguration {\n  url: string;\n  headers: HeadersFactory;\n}\n\nfunction mergeHeaders(\n  userProvidedHeaders: HeadersFactory | undefined | null,\n  fallbackHeaders: HeadersFactory | undefined | null,\n  defaultHeaders: HeadersFactory\n): HeadersFactory {\n  return async () => {\n    const requiredHeaders = {\n      ...(await defaultHeaders()),\n    };\n    const headers = {};\n\n    // add fallback ones first\n    if (fallbackHeaders != null) {\n      Object.assign(headers, await fallbackHeaders());\n    }\n\n    // override with user-provided ones\n    if (userProvidedHeaders != null) {\n      Object.assign(\n        headers,\n        validateAndNormalizeHeaders(await userProvidedHeaders())\n      );\n    }\n\n    // override required ones.\n    return Object.assign(headers, requiredHeaders);\n  };\n}\n\nfunction validateUserProvidedUrl(url: string | undefined): string | undefined {\n  if (url == null) {\n    return undefined;\n  }\n  try {\n    // NOTE: In non-browser environments, `globalThis.location` will be `undefined`.\n    const base = globalThis.location?.href;\n    return new URL(url, base).href;\n  } catch {\n    throw new Error(\n      `Configuration: Could not parse user-provided export URL: '${url}'`\n    );\n  }\n}\n\n/**\n * @param userProvidedConfiguration  Configuration options provided by the user in code.\n * @param fallbackConfiguration Fallback to use when the {@link userProvidedConfiguration} does not specify an option.\n * @param defaultConfiguration The defaults as defined by the exporter specification\n */\nexport function mergeOtlpHttpConfigurationWithDefaults(\n  userProvidedConfiguration: Partial<OtlpHttpConfiguration>,\n  fallbackConfiguration: Partial<OtlpHttpConfiguration>,\n  defaultConfiguration: OtlpHttpConfiguration\n): OtlpHttpConfiguration {\n  return {\n    ...mergeOtlpSharedConfigurationWithDefaults(\n      userProvidedConfiguration,\n      fallbackConfiguration,\n      defaultConfiguration\n    ),\n    headers: mergeHeaders(\n      userProvidedConfiguration.headers,\n      fallbackConfiguration.headers,\n      defaultConfiguration.headers\n    ),\n    url:\n      validateUserProvidedUrl(userProvidedConfiguration.url) ??\n      fallbackConfiguration.url ??\n      defaultConfiguration.url,\n  };\n}\n\nexport function getHttpConfigurationDefaults(\n  requiredHeaders: Record<string, string>,\n  signalResourcePath: string\n): OtlpHttpConfiguration {\n  return {\n    ...getSharedConfigurationDefaults(),\n    headers: async () => requiredHeaders,\n    url: 'http://localhost:4318/' + signalResourcePath,\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  getHttpConfigurationDefaults,\n  mergeOtlpHttpConfigurationWithDefaults,\n  OtlpHttpConfiguration,\n} from './otlp-http-configuration';\n\n// NOTE: do not change these imports to be actual imports, otherwise they WILL break `@opentelemetry/instrumentation-http`\nimport type * as http from 'http';\nimport type * as https from 'https';\n\nexport type HttpAgentFactory = (\n  protocol: string\n) => http.Agent | https.Agent | Promise<http.Agent> | Promise<https.Agent>;\n\nexport interface OtlpNodeHttpConfiguration extends OtlpHttpConfiguration {\n  /**\n   * Factory function for creating agents.\n   *\n   * @remarks\n   * Prefer using {@link httpAgentFactoryFromOptions} over manually writing a factory function wherever possible.\n   * If using a factory function (`HttpAgentFactory`), **do not import `http.Agent` or `https.Agent`\n   * statically at the top of the file**.\n   * Instead, use dynamic `import()` or `require()` to load the module. This ensures that the `http` or `https`\n   * module is not loaded before `@opentelemetry/instrumentation-http` can instrument it.\n   */\n  agentFactory: HttpAgentFactory;\n  /**\n   * User agent header string to be appended to the exporter's value as a prefix.\n   * Availablie since v1.49.0 of the spec.\n   * Ref: https://opentelemetry.io/docs/specs/otel/protocol/exporter/#user-agent\n   */\n  userAgent?: string;\n}\n\nexport function httpAgentFactoryFromOptions(\n  options: http.AgentOptions | https.AgentOptions\n): HttpAgentFactory {\n  return async protocol => {\n    const isInsecure = protocol === 'http:';\n    const module = isInsecure ? import('http') : import('https');\n    const { Agent } = await module;\n\n    if (isInsecure) {\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars -- these props should not be used in agent options\n      const { ca, cert, key, ...insecureOptions } =\n        options as https.AgentOptions;\n      return new Agent(insecureOptions);\n    }\n    return new Agent(options);\n  };\n}\n\n/**\n * @param userProvidedConfiguration  Configuration options provided by the user in code.\n * @param fallbackConfiguration Fallback to use when the {@link userProvidedConfiguration} does not specify an option.\n * @param defaultConfiguration The defaults as defined by the exporter specification\n */\nexport function mergeOtlpNodeHttpConfigurationWithDefaults(\n  userProvidedConfiguration: Partial<OtlpNodeHttpConfiguration>,\n  fallbackConfiguration: Partial<OtlpNodeHttpConfiguration>,\n  defaultConfiguration: OtlpNodeHttpConfiguration\n): OtlpNodeHttpConfiguration {\n  return {\n    ...mergeOtlpHttpConfigurationWithDefaults(\n      userProvidedConfiguration,\n      fallbackConfiguration,\n      defaultConfiguration\n    ),\n    agentFactory:\n      userProvidedConfiguration.agentFactory ??\n      fallbackConfiguration.agentFactory ??\n      defaultConfiguration.agentFactory,\n    userAgent: userProvidedConfiguration.userAgent,\n  };\n}\n\nexport function getNodeHttpConfigurationDefaults(\n  requiredHeaders: Record<string, string>,\n  signalResourcePath: string\n): OtlpNodeHttpConfiguration {\n  return {\n    ...getHttpConfigurationDefaults(requiredHeaders, signalResourcePath),\n    agentFactory: httpAgentFactoryFromOptions({ keepAlive: true }),\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport type * as http from 'http';\nimport type * as https from 'https';\nimport * as zlib from 'zlib';\nimport { Readable } from 'stream';\nimport { ExportResponse } from '../export-response';\nimport {\n  isExportHTTPErrorRetryable,\n  parseRetryAfterToMills,\n} from '../is-export-retryable';\nimport { OTLPExporterError } from '../types';\nimport { VERSION } from '../version';\n\nconst DEFAULT_USER_AGENT = `OTel-OTLP-Exporter-JavaScript/${VERSION}`;\n\n/**\n * Sends data using http\n * @param request\n * @param params\n * @param agent\n * @param data\n * @param onDone\n * @param timeoutMillis\n */\nexport function sendWithHttp(\n  request: typeof https.request | typeof http.request,\n  url: string,\n  headers: Record<string, string>,\n  compression: 'gzip' | 'none',\n  userAgent: string | undefined,\n  agent: http.Agent | https.Agent,\n  data: Uint8Array,\n  onDone: (response: ExportResponse) => void,\n  timeoutMillis: number\n): void {\n  const parsedUrl = new URL(url);\n\n  if (userAgent) {\n    headers['User-Agent'] = `${userAgent} ${DEFAULT_USER_AGENT}`;\n  } else {\n    headers['User-Agent'] = DEFAULT_USER_AGENT;\n  }\n\n  const options: http.RequestOptions | https.RequestOptions = {\n    hostname: parsedUrl.hostname,\n    port: parsedUrl.port,\n    path: parsedUrl.pathname,\n    method: 'POST',\n    headers,\n    agent,\n  };\n\n  const req = request(options, (res: http.IncomingMessage) => {\n    const responseData: Buffer[] = [];\n    res.on('data', chunk => responseData.push(chunk));\n\n    res.on('end', () => {\n      if (res.statusCode && res.statusCode < 299) {\n        onDone({\n          status: 'success',\n          data: Buffer.concat(responseData),\n        });\n      } else if (res.statusCode && isExportHTTPErrorRetryable(res.statusCode)) {\n        onDone({\n          status: 'retryable',\n          retryInMillis: parseRetryAfterToMills(res.headers['retry-after']),\n        });\n      } else {\n        const error = new OTLPExporterError(\n          res.statusMessage,\n          res.statusCode,\n          Buffer.concat(responseData).toString()\n        );\n        onDone({\n          status: 'failure',\n          error,\n        });\n      }\n    });\n  });\n\n  req.setTimeout(timeoutMillis, () => {\n    req.destroy();\n    onDone({\n      status: 'retryable',\n      error: new Error('Request timed out'),\n    });\n  });\n\n  req.on('error', (error: Error) => {\n    if (isHttpTransportNetworkErrorRetryable(error)) {\n      onDone({\n        status: 'retryable',\n        error,\n      });\n    } else {\n      onDone({\n        status: 'failure',\n        error,\n      });\n    }\n  });\n\n  compressAndSend(req, compression, data, (error: Error) => {\n    onDone({\n      status: 'failure',\n      error,\n    });\n  });\n}\n\nexport function compressAndSend(\n  req: http.ClientRequest,\n  compression: 'gzip' | 'none',\n  data: Uint8Array,\n  onError: (error: Error) => void\n) {\n  let dataStream = readableFromUint8Array(data);\n\n  if (compression === 'gzip') {\n    req.setHeader('Content-Encoding', 'gzip');\n    dataStream = dataStream\n      .on('error', onError)\n      .pipe(zlib.createGzip())\n      .on('error', onError);\n  }\n\n  dataStream.pipe(req).on('error', onError);\n}\n\nfunction readableFromUint8Array(buff: string | Uint8Array): Readable {\n  const readable = new Readable();\n  readable.push(buff);\n  readable.push(null);\n\n  return readable;\n}\n\nfunction isHttpTransportNetworkErrorRetryable(error: Error): boolean {\n  const RETRYABLE_NETWORK_ERROR_CODES = new Set([\n    'ECONNRESET',\n    'ECONNREFUSED',\n    'EPIPE',\n    'ETIMEDOUT',\n    'EAI_AGAIN',\n    'ENOTFOUND',\n    'ENETUNREACH',\n    'EHOSTUNREACH',\n  ]);\n\n  if ('code' in error && typeof error.code === 'string') {\n    return RETRYABLE_NETWORK_ERROR_CODES.has(error.code);\n  }\n\n  return false;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport function isExportHTTPErrorRetryable(statusCode: number): boolean {\n  return (\n    statusCode === 429 ||\n    statusCode === 502 ||\n    statusCode === 503 ||\n    statusCode === 504\n  );\n}\n\nexport function parseRetryAfterToMills(\n  retryAfter?: string | undefined | null\n): number | undefined {\n  if (retryAfter == null) {\n    return undefined;\n  }\n\n  const seconds = Number.parseInt(retryAfter, 10);\n  if (Number.isInteger(seconds)) {\n    return seconds > 0 ? seconds * 1000 : -1;\n  }\n  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After#directives\n  const delay = new Date(retryAfter).getTime() - Date.now();\n\n  if (delay >= 0) {\n    return delay;\n  }\n  return 0;\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// this is autogenerated file, see scripts/version-update.js\nexport const VERSION = '0.210.0';\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// NOTE: do not change these type imports to actual imports. Doing so WILL break `@opentelemetry/instrumentation-http`,\n// as they'd be imported before the http/https modules can be wrapped.\nimport type * as https from 'https';\nimport type * as http from 'http';\nimport { ExportResponse } from '../export-response';\nimport { IExporterTransport } from '../exporter-transport';\nimport { sendWithHttp } from './http-transport-utils';\nimport { NodeHttpRequestParameters } from './node-http-transport-types';\n\ninterface Utils {\n  agent: http.Agent | https.Agent;\n  request: typeof http.request | typeof https.request;\n}\n\nclass HttpExporterTransport implements IExporterTransport {\n  private _utils: Utils | null = null;\n  private _parameters: NodeHttpRequestParameters;\n\n  constructor(parameters: NodeHttpRequestParameters) {\n    this._parameters = parameters;\n  }\n\n  async send(data: Uint8Array, timeoutMillis: number): Promise<ExportResponse> {\n    const { agent, request } = await this._loadUtils();\n    const headers = await this._parameters.headers();\n\n    return new Promise<ExportResponse>(resolve => {\n      sendWithHttp(\n        request,\n        this._parameters.url,\n        headers,\n        this._parameters.compression,\n        this._parameters.userAgent,\n        agent,\n        data,\n        result => {\n          resolve(result);\n        },\n        timeoutMillis\n      );\n    });\n  }\n\n  shutdown() {\n    // intentionally left empty, nothing to do.\n  }\n\n  private async _loadUtils(): Promise<Utils> {\n    let utils = this._utils;\n\n    if (utils === null) {\n      const protocol = new URL(this._parameters.url).protocol;\n      const [agent, request] = await Promise.all([\n        this._parameters.agentFactory(protocol),\n        requestFunctionFactory(protocol),\n      ]);\n      utils = this._utils = { agent, request };\n    }\n\n    return utils;\n  }\n}\n\nasync function requestFunctionFactory(\n  protocol: string\n): Promise<typeof http.request | typeof https.request> {\n  const module = protocol === 'http:' ? import('http') : import('https');\n  const { request } = await module;\n  return request;\n}\n\nexport function createHttpExporterTransport(\n  parameters: NodeHttpRequestParameters\n): IExporterTransport {\n  return new HttpExporterTransport(parameters);\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { IExporterTransport } from './exporter-transport';\nimport { ExportResponse } from './export-response';\nimport { diag } from '@opentelemetry/api';\n\nconst MAX_ATTEMPTS = 5;\nconst INITIAL_BACKOFF = 1000;\nconst MAX_BACKOFF = 5000;\nconst BACKOFF_MULTIPLIER = 1.5;\nconst JITTER = 0.2;\n\n/**\n * Get a pseudo-random jitter that falls in the range of [-JITTER, +JITTER]\n */\nfunction getJitter() {\n  return Math.random() * (2 * JITTER) - JITTER;\n}\n\nclass RetryingTransport implements IExporterTransport {\n  private _transport: IExporterTransport;\n\n  constructor(transport: IExporterTransport) {\n    this._transport = transport;\n  }\n\n  private retry(\n    data: Uint8Array,\n    timeoutMillis: number,\n    inMillis: number\n  ): Promise<ExportResponse> {\n    return new Promise((resolve, reject) => {\n      setTimeout(() => {\n        this._transport.send(data, timeoutMillis).then(resolve, reject);\n      }, inMillis);\n    });\n  }\n\n  async send(data: Uint8Array, timeoutMillis: number): Promise<ExportResponse> {\n    let attempts = MAX_ATTEMPTS;\n    let nextBackoff = INITIAL_BACKOFF;\n\n    const deadline = Date.now() + timeoutMillis;\n    let result = await this._transport.send(data, timeoutMillis);\n\n    while (result.status === 'retryable' && attempts > 0) {\n      attempts--;\n\n      // use maximum of computed backoff and 0 to avoid negative timeouts\n      const backoff = Math.max(\n        Math.min(nextBackoff * (1 + getJitter()), MAX_BACKOFF),\n        0\n      );\n      nextBackoff = nextBackoff * BACKOFF_MULTIPLIER;\n      const retryInMillis = result.retryInMillis ?? backoff;\n\n      // return when expected retry time is after the export deadline.\n      const remainingTimeoutMillis = deadline - Date.now();\n      if (retryInMillis > remainingTimeoutMillis) {\n        diag.info(\n          `Export retry time ${Math.round(retryInMillis)}ms exceeds remaining timeout ${Math.round(\n            remainingTimeoutMillis\n          )}ms, not retrying further.`\n        );\n        return result;\n      }\n\n      diag.verbose(`Scheduling export retry in ${Math.round(retryInMillis)}ms`);\n      result = await this.retry(data, remainingTimeoutMillis, retryInMillis);\n    }\n\n    if (result.status === 'success') {\n      diag.verbose(\n        `Export succeded after ${MAX_ATTEMPTS - attempts} retry attempts.`\n      );\n    } else if (result.status === 'retryable') {\n      diag.info(\n        `Export failed after maximum retry attempts (${MAX_ATTEMPTS}).`\n      );\n    } else {\n      diag.info(`Export failed with non-retryable error: ${result.error}`);\n    }\n\n    return result;\n  }\n\n  shutdown() {\n    return this._transport.shutdown();\n  }\n}\n\n/**\n * Creates an Exporter Transport that retries on 'retryable' response.\n */\nexport function createRetryingTransport(options: {\n  // Underlying transport to wrap.\n  transport: IExporterTransport;\n}): IExporterTransport {\n  return new RetryingTransport(options.transport);\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport {\n  createOtlpExportDelegate,\n  IOtlpExportDelegate,\n} from './otlp-export-delegate';\nimport { ISerializer } from '@opentelemetry/otlp-transformer';\nimport { createHttpExporterTransport } from './transport/http-exporter-transport';\nimport { createBoundedQueueExportPromiseHandler } from './bounded-queue-export-promise-handler';\nimport { createRetryingTransport } from './retrying-transport';\nimport { OtlpNodeHttpConfiguration } from './configuration/otlp-node-http-configuration';\n\nexport function createOtlpHttpExportDelegate<Internal, Response>(\n  options: OtlpNodeHttpConfiguration,\n  serializer: ISerializer<Internal, Response>\n): IOtlpExportDelegate<Internal> {\n  return createOtlpExportDelegate(\n    {\n      transport: createRetryingTransport({\n        transport: createHttpExporterTransport(options),\n      }),\n      serializer: serializer,\n      promiseHandler: createBoundedQueueExportPromiseHandler(options),\n    },\n    { timeout: options.timeoutMillis }\n  );\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { getNumberFromEnv, getStringFromEnv } from '@opentelemetry/core';\nimport { OtlpSharedConfiguration } from './shared-configuration';\nimport { diag } from '@opentelemetry/api';\n\nfunction parseAndValidateTimeoutFromEnv(\n  timeoutEnvVar: string\n): number | undefined {\n  const envTimeout = getNumberFromEnv(timeoutEnvVar);\n  if (envTimeout != null) {\n    if (Number.isFinite(envTimeout) && envTimeout > 0) {\n      return envTimeout;\n    }\n    diag.warn(\n      `Configuration: ${timeoutEnvVar} is invalid, expected number greater than 0 (actual: ${envTimeout})`\n    );\n  }\n\n  return undefined;\n}\n\nfunction getTimeoutFromEnv(signalIdentifier: string) {\n  const specificTimeout = parseAndValidateTimeoutFromEnv(\n    `OTEL_EXPORTER_OTLP_${signalIdentifier}_TIMEOUT`\n  );\n  const nonSpecificTimeout = parseAndValidateTimeoutFromEnv(\n    'OTEL_EXPORTER_OTLP_TIMEOUT'\n  );\n\n  return specificTimeout ?? nonSpecificTimeout;\n}\n\nfunction parseAndValidateCompressionFromEnv(\n  compressionEnvVar: string\n): 'none' | 'gzip' | undefined {\n  const compression = getStringFromEnv(compressionEnvVar)?.trim();\n\n  if (compression == null || compression === 'none' || compression === 'gzip') {\n    return compression;\n  }\n\n  diag.warn(\n    `Configuration: ${compressionEnvVar} is invalid, expected 'none' or 'gzip' (actual: '${compression}')`\n  );\n  return undefined;\n}\n\nfunction getCompressionFromEnv(\n  signalIdentifier: string\n): 'none' | 'gzip' | undefined {\n  const specificCompression = parseAndValidateCompressionFromEnv(\n    `OTEL_EXPORTER_OTLP_${signalIdentifier}_COMPRESSION`\n  );\n  const nonSpecificCompression = parseAndValidateCompressionFromEnv(\n    'OTEL_EXPORTER_OTLP_COMPRESSION'\n  );\n\n  return specificCompression ?? nonSpecificCompression;\n}\n\nexport function getSharedConfigurationFromEnvironment(\n  signalIdentifier: string\n): Partial<OtlpSharedConfiguration> {\n  return {\n    timeoutMillis: getTimeoutFromEnv(signalIdentifier),\n    compression: getCompressionFromEnv(signalIdentifier),\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { OTLPExporterNodeConfigBase } from './legacy-node-configuration';\nimport { diag } from '@opentelemetry/api';\nimport {\n  getNodeHttpConfigurationDefaults,\n  HttpAgentFactory,\n  mergeOtlpNodeHttpConfigurationWithDefaults,\n  OtlpNodeHttpConfiguration,\n} from './otlp-node-http-configuration';\nimport { httpAgentFactoryFromOptions } from '../index-node-http';\nimport { getNodeHttpConfigurationFromEnvironment } from './otlp-node-http-env-configuration';\nimport { convertLegacyHeaders } from './convert-legacy-http-options';\n\nfunction convertLegacyAgentOptions(\n  config: OTLPExporterNodeConfigBase\n): HttpAgentFactory | undefined {\n  if (typeof config.httpAgentOptions === 'function') {\n    return config.httpAgentOptions;\n  }\n\n  let legacy = config.httpAgentOptions;\n  if (config.keepAlive != null) {\n    legacy = { keepAlive: config.keepAlive, ...legacy };\n  }\n\n  if (legacy != null) {\n    return httpAgentFactoryFromOptions(legacy);\n  } else {\n    return undefined;\n  }\n}\n\n/**\n * @deprecated this will be removed in 2.0\n * @param config\n * @param signalIdentifier\n * @param signalResourcePath\n * @param requiredHeaders\n */\nexport function convertLegacyHttpOptions(\n  config: OTLPExporterNodeConfigBase,\n  signalIdentifier: string,\n  signalResourcePath: string,\n  requiredHeaders: Record<string, string>\n): OtlpNodeHttpConfiguration {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  if ((config as any).metadata) {\n    diag.warn('Metadata cannot be set when using http');\n  }\n\n  return mergeOtlpNodeHttpConfigurationWithDefaults(\n    {\n      url: config.url,\n      headers: convertLegacyHeaders(config),\n      concurrencyLimit: config.concurrencyLimit,\n      timeoutMillis: config.timeoutMillis,\n      compression: config.compression,\n      agentFactory: convertLegacyAgentOptions(config),\n      userAgent: config.userAgent,\n    },\n    getNodeHttpConfigurationFromEnvironment(\n      signalIdentifier,\n      signalResourcePath\n    ),\n    getNodeHttpConfigurationDefaults(requiredHeaders, signalResourcePath)\n  );\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { getStringFromEnv, parseKeyPairsIntoRecord } from '@opentelemetry/core';\nimport { diag } from '@opentelemetry/api';\nimport { getSharedConfigurationFromEnvironment } from './shared-env-configuration';\nimport { wrapStaticHeadersInFunction } from './shared-configuration';\nimport {\n  OtlpNodeHttpConfiguration,\n  httpAgentFactoryFromOptions,\n} from './otlp-node-http-configuration';\n\nfunction getStaticHeadersFromEnv(\n  signalIdentifier: string\n): Record<string, string> | undefined {\n  const signalSpecificRawHeaders = getStringFromEnv(\n    `OTEL_EXPORTER_OTLP_${signalIdentifier}_HEADERS`\n  );\n  const nonSignalSpecificRawHeaders = getStringFromEnv(\n    'OTEL_EXPORTER_OTLP_HEADERS'\n  );\n\n  const signalSpecificHeaders = parseKeyPairsIntoRecord(\n    signalSpecificRawHeaders\n  );\n  const nonSignalSpecificHeaders = parseKeyPairsIntoRecord(\n    nonSignalSpecificRawHeaders\n  );\n\n  if (\n    Object.keys(signalSpecificHeaders).length === 0 &&\n    Object.keys(nonSignalSpecificHeaders).length === 0\n  ) {\n    return undefined;\n  }\n\n  // headers are combined instead of overwritten, with the specific headers taking precedence over\n  // the non-specific ones.\n  return Object.assign(\n    {},\n    parseKeyPairsIntoRecord(nonSignalSpecificRawHeaders),\n    parseKeyPairsIntoRecord(signalSpecificRawHeaders)\n  );\n}\n\nfunction appendRootPathToUrlIfNeeded(url: string): string | undefined {\n  try {\n    const parsedUrl = new URL(url);\n    // This will automatically append '/' if there's no root path.\n    return parsedUrl.toString();\n  } catch {\n    diag.warn(\n      `Configuration: Could not parse environment-provided export URL: '${url}', falling back to undefined`\n    );\n    return undefined;\n  }\n}\n\nfunction appendResourcePathToUrl(\n  url: string,\n  path: string\n): string | undefined {\n  try {\n    // just try to parse, if it fails we catch and warn.\n    new URL(url);\n  } catch {\n    diag.warn(\n      `Configuration: Could not parse environment-provided export URL: '${url}', falling back to undefined`\n    );\n    return undefined;\n  }\n\n  if (!url.endsWith('/')) {\n    url = url + '/';\n  }\n  url += path;\n\n  try {\n    // just try to parse, if it fails we catch and warn.\n    new URL(url);\n  } catch {\n    diag.warn(\n      `Configuration: Provided URL appended with '${path}' is not a valid URL, using 'undefined' instead of '${url}'`\n    );\n    return undefined;\n  }\n\n  return url;\n}\n\nfunction getNonSpecificUrlFromEnv(\n  signalResourcePath: string\n): string | undefined {\n  const envUrl = getStringFromEnv('OTEL_EXPORTER_OTLP_ENDPOINT');\n  if (envUrl === undefined) {\n    return undefined;\n  }\n  return appendResourcePathToUrl(envUrl, signalResourcePath);\n}\n\nfunction getSpecificUrlFromEnv(signalIdentifier: string): string | undefined {\n  const envUrl = getStringFromEnv(\n    `OTEL_EXPORTER_OTLP_${signalIdentifier}_ENDPOINT`\n  );\n  if (envUrl === undefined) {\n    return undefined;\n  }\n  return appendRootPathToUrlIfNeeded(envUrl);\n}\n\nfunction readFileFromEnv(\n  signalSpecificEnvVar: string,\n  nonSignalSpecificEnvVar: string,\n  warningMessage: string\n): Buffer | undefined {\n  const signalSpecificPath = getStringFromEnv(signalSpecificEnvVar);\n  const nonSignalSpecificPath = getStringFromEnv(nonSignalSpecificEnvVar);\n  const filePath = signalSpecificPath ?? nonSignalSpecificPath;\n\n  if (filePath != null) {\n    try {\n      return fs.readFileSync(path.resolve(process.cwd(), filePath));\n    } catch {\n      diag.warn(warningMessage);\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n}\n\nfunction getClientCertificateFromEnv(\n  signalIdentifier: string\n): Buffer | undefined {\n  return readFileFromEnv(\n    `OTEL_EXPORTER_OTLP_${signalIdentifier}_CLIENT_CERTIFICATE`,\n    'OTEL_EXPORTER_OTLP_CLIENT_CERTIFICATE',\n    'Failed to read client certificate chain file'\n  );\n}\n\nfunction getClientKeyFromEnv(signalIdentifier: string): Buffer | undefined {\n  return readFileFromEnv(\n    `OTEL_EXPORTER_OTLP_${signalIdentifier}_CLIENT_KEY`,\n    'OTEL_EXPORTER_OTLP_CLIENT_KEY',\n    'Failed to read client certificate private key file'\n  );\n}\n\nfunction getRootCertificateFromEnv(\n  signalIdentifier: string\n): Buffer | undefined {\n  return readFileFromEnv(\n    `OTEL_EXPORTER_OTLP_${signalIdentifier}_CERTIFICATE`,\n    'OTEL_EXPORTER_OTLP_CERTIFICATE',\n    'Failed to read root certificate file'\n  );\n}\n\n/**\n * Reads and returns configuration from the environment\n *\n * @param signalIdentifier all caps part in environment variables that identifies the signal (e.g.: METRICS, TRACES, LOGS)\n * @param signalResourcePath signal resource path to append if necessary (e.g.: v1/metrics, v1/traces, v1/logs)\n */\nexport function getNodeHttpConfigurationFromEnvironment(\n  signalIdentifier: string,\n  signalResourcePath: string\n): Partial<OtlpNodeHttpConfiguration> {\n  return {\n    ...getSharedConfigurationFromEnvironment(signalIdentifier),\n    url:\n      getSpecificUrlFromEnv(signalIdentifier) ??\n      getNonSpecificUrlFromEnv(signalResourcePath),\n    headers: wrapStaticHeadersInFunction(\n      getStaticHeadersFromEnv(signalIdentifier)\n    ),\n    agentFactory: httpAgentFactoryFromOptions({\n      keepAlive: true,\n      ca: getRootCertificateFromEnv(signalIdentifier),\n      cert: getClientCertificateFromEnv(signalIdentifier),\n      key: getClientKeyFromEnv(signalIdentifier),\n    }),\n  };\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { OTLPExporterConfigBase } from './legacy-base-configuration';\nimport { wrapStaticHeadersInFunction } from './shared-configuration';\nimport { HeadersFactory } from './otlp-http-configuration';\n\nexport function convertLegacyHeaders(\n  config: OTLPExporterConfigBase\n): HeadersFactory | undefined {\n  if (typeof config.headers === 'function') {\n    return config.headers;\n  }\n  return wrapStaticHeadersInFunction(config.headers);\n}\n","/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport { ReadableSpan, SpanExporter } from '@opentelemetry/sdk-trace-base';\nimport {\n  OTLPExporterNodeConfigBase,\n  OTLPExporterBase,\n} from '@opentelemetry/otlp-exporter-base';\nimport { JsonTraceSerializer } from '@opentelemetry/otlp-transformer';\nimport {\n  convertLegacyHttpOptions,\n  createOtlpHttpExportDelegate,\n} from '@opentelemetry/otlp-exporter-base/node-http';\n\n/**\n * Collector Trace Exporter for Node\n */\nexport class OTLPTraceExporter\n  extends OTLPExporterBase<ReadableSpan[]>\n  implements SpanExporter\n{\n  constructor(config: OTLPExporterNodeConfigBase = {}) {\n    super(\n      createOtlpHttpExportDelegate(\n        convertLegacyHttpOptions(config, 'TRACES', 'v1/traces', {\n          'Content-Type': 'application/json',\n        }),\n        JsonTraceSerializer\n      )\n    );\n  }\n}\n"],"mappings":"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","names":["ExportResultCode","diag","diag","hrTime","diag","resolve","diag","resolve","diag","diag","diag","diag","path","diag"]}