{"version":3,"file":"index.d.ts","names":["Runnable","RunnableConfig","RunnableFunc","StreamEvent","IterableReadableStream","All","BaseCache","BaseCheckpointSaver","BaseStore","CheckpointListOptions","CheckpointTuple","BaseChannel","Command","CommandInstance","StrRecord","PregelNode","LangGraphRunnableConfig","Durability","GetStateOptions","MultipleChannelSubscriptionOptions","PregelInputType","PregelInterface","PregelOptions","PregelOutputType","PregelParams","SingleChannelSubscriptionOptions","StateSnapshot","StreamMode","StreamOutputMap","RetryPolicy","ChannelWrite","WriteValue","StreamEventsOptions","Parameters","Channel","Record","PartialRunnable","RunInput","RunOutput","CallOptions","Partial","Promise","Pregel","InputType","OutputType","CommandType","Nodes","Channels","ContextType","Array","Omit","_langchain_core_runnables_graph0","Graph","Generator","AsyncGenerator","config","saved","subgraphCheckpointer","applyPendingWrites","AsyncIterableIterator","TStreamMode","TSubgraphs","TEncoding","StreamUpdatesType","StreamValuesType","NodeReturnType","StreamCustom","Uint8Array"],"sources":["../../src/pregel/index.d.ts"],"sourcesContent":["import { Runnable, RunnableConfig, RunnableFunc } from \"@langchain/core/runnables\";\nimport type { StreamEvent } from \"@langchain/core/tracers/log_stream\";\nimport { IterableReadableStream } from \"@langchain/core/utils/stream\";\nimport { All, BaseCache, BaseCheckpointSaver, BaseStore, CheckpointListOptions, CheckpointTuple } from \"@langchain/langgraph-checkpoint\";\nimport { BaseChannel } from \"../channels/base.js\";\nimport { Command, type CommandInstance } from \"../constants.js\";\nimport { StrRecord } from \"./algo.js\";\nimport { PregelNode } from \"./read.js\";\nimport { LangGraphRunnableConfig } from \"./runnable_types.js\";\nimport type { Durability, GetStateOptions, MultipleChannelSubscriptionOptions, PregelInputType, PregelInterface, PregelOptions, PregelOutputType, PregelParams, SingleChannelSubscriptionOptions, StateSnapshot, StreamMode, StreamOutputMap } from \"./types.js\";\nimport { RetryPolicy } from \"./utils/index.js\";\nimport { ChannelWrite } from \"./write.js\";\ntype WriteValue = Runnable | RunnableFunc<unknown, unknown> | unknown;\ntype StreamEventsOptions = Parameters<Runnable[\"streamEvents\"]>[2];\n/**\n * Utility class for working with channels in the Pregel system.\n * Provides static methods for subscribing to channels and writing to them.\n *\n * Channels are the communication pathways between nodes in a Pregel graph.\n * They enable message passing and state updates between different parts of the graph.\n */\nexport declare class Channel {\n    /**\n     * Creates a PregelNode that subscribes to a single channel.\n     * This is used to define how nodes receive input from channels.\n     *\n     * @example\n     * ```typescript\n     * // Subscribe to a single channel\n     * const node = Channel.subscribeTo(\"messages\");\n     *\n     * // Subscribe to multiple channels\n     * const node = Channel.subscribeTo([\"messages\", \"state\"]);\n     *\n     * // Subscribe with a custom key\n     * const node = Channel.subscribeTo(\"messages\", { key: \"chat\" });\n     * ```\n     *\n     * @param channel Single channel name to subscribe to\n     * @param options Subscription options\n     * @returns A PregelNode configured to receive from the specified channels\n     * @throws {Error} If a key is specified when subscribing to multiple channels\n     */\n    static subscribeTo(channel: string, options?: SingleChannelSubscriptionOptions): PregelNode;\n    /**\n     * Creates a PregelNode that subscribes to multiple channels.\n     * This is used to define how nodes receive input from channels.\n     *\n     * @example\n     * ```typescript\n     * // Subscribe to a single channel\n     * const node = Channel.subscribeTo(\"messages\");\n     *\n     * // Subscribe to multiple channels\n     * const node = Channel.subscribeTo([\"messages\", \"state\"]);\n     *\n     * // Subscribe with a custom key\n     * const node = Channel.subscribeTo(\"messages\", { key: \"chat\" });\n     * ```\n     *\n     * @param channels Single channel name to subscribe to\n     * @param options Subscription options\n     * @returns A PregelNode configured to receive from the specified channels\n     * @throws {Error} If a key is specified when subscribing to multiple channels\n     */\n    static subscribeTo(channels: string[], options?: MultipleChannelSubscriptionOptions): PregelNode;\n    /**\n     * Creates a ChannelWrite that specifies how to write values to channels.\n     * This is used to define how nodes send output to channels.\n     *\n     * @example\n     * ```typescript\n     * // Write to multiple channels\n     * const write = Channel.writeTo([\"output\", \"state\"]);\n     *\n     * // Write with specific values\n     * const write = Channel.writeTo([\"output\"], {\n     *   state: \"completed\",\n     *   result: calculateResult()\n     * });\n     *\n     * // Write with a transformation function\n     * const write = Channel.writeTo([\"output\"], {\n     *   result: (x) => processResult(x)\n     * });\n     * ```\n     *\n     * @param channels - Array of channel names to write to\n     * @param writes - Optional map of channel names to values or transformations\n     * @returns A ChannelWrite object that can be used to write to the specified channels\n     */\n    static writeTo(channels: string[], writes?: Record<string, WriteValue>): ChannelWrite;\n}\nexport type { PregelInputType, PregelOptions, PregelOutputType };\ndeclare class PartialRunnable<RunInput, RunOutput, CallOptions extends RunnableConfig> extends Runnable<RunInput, RunOutput, CallOptions> {\n    lc_namespace: string[];\n    invoke(_input: RunInput, _options?: Partial<CallOptions>): Promise<any>;\n    withConfig(_config: CallOptions): typeof this;\n    stream(input: RunInput, options?: Partial<CallOptions>): Promise<IterableReadableStream<any>>;\n}\n/**\n * The Pregel class is the core runtime engine of LangGraph, implementing a message-passing graph computation model\n * inspired by [Google's Pregel system](https://research.google/pubs/pregel-a-system-for-large-scale-graph-processing/).\n * It provides the foundation for building reliable, controllable agent workflows that can evolve state over time.\n *\n * Key features:\n * - Message passing between nodes in discrete \"supersteps\"\n * - Built-in persistence layer through checkpointers\n * - First-class streaming support for values, updates, and events\n * - Human-in-the-loop capabilities via interrupts\n * - Support for parallel node execution within supersteps\n *\n * The Pregel class is not intended to be instantiated directly by consumers. Instead, use the following higher-level APIs:\n * - {@link StateGraph}: The main graph class for building agent workflows\n *   - Compiling a {@link StateGraph} will return a {@link CompiledGraph} instance, which extends `Pregel`\n * - Functional API: A declarative approach using tasks and entrypoints\n *   - A `Pregel` instance is returned by the {@link entrypoint} function\n *\n * @example\n * ```typescript\n * // Using StateGraph API\n * const graph = new StateGraph(annotation)\n *   .addNode(\"nodeA\", myNodeFunction)\n *   .addEdge(\"nodeA\", \"nodeB\")\n *   .compile();\n *\n * // The compiled graph is a Pregel instance\n * const result = await graph.invoke(input);\n * ```\n *\n * @example\n * ```typescript\n * // Using Functional API\n * import { task, entrypoint } from \"@langchain/langgraph\";\n * import { MemorySaver } from \"@langchain/langgraph-checkpoint\";\n *\n * // Define tasks that can be composed\n * const addOne = task(\"add\", async (x: number) => x + 1);\n *\n * // Create a workflow using the entrypoint function\n * const workflow = entrypoint({\n *   name: \"workflow\",\n *   checkpointer: new MemorySaver()\n * }, async (numbers: number[]) => {\n *   // Tasks can be run in parallel\n *   const results = await Promise.all(numbers.map(n => addOne(n)));\n *   return results;\n * });\n *\n * // The workflow is a Pregel instance\n * const result = await workflow.invoke([1, 2, 3]); // Returns [2, 3, 4]\n * ```\n *\n * @typeParam Nodes - Mapping of node names to their {@link PregelNode} implementations\n * @typeParam Channels - Mapping of channel names to their {@link BaseChannel} or {@link ManagedValueSpec} implementations\n * @typeParam ContextType - Type of context that can be passed to the graph\n * @typeParam InputType - Type of input values accepted by the graph\n * @typeParam OutputType - Type of output values produced by the graph\n */\nexport declare class Pregel<Nodes extends StrRecord<string, PregelNode>, Channels extends StrRecord<string, BaseChannel>, ContextType extends Record<string, any> = StrRecord<string, any>, InputType = PregelInputType, OutputType = PregelOutputType, StreamUpdatesType = InputType, StreamValuesType = OutputType, NodeReturnType = unknown, CommandType = CommandInstance, StreamCustom = any> extends PartialRunnable<InputType | CommandType | null, OutputType, PregelOptions<Nodes, Channels, ContextType>> implements PregelInterface<Nodes, Channels, ContextType> {\n    /**\n     * Name of the class when serialized\n     * @internal\n     */\n    static lc_name(): string;\n    /** @internal Used for type inference */\n    \"~InputType\": InputType;\n    /** @internal Used for type inference */\n    \"~OutputType\": OutputType;\n    /** @internal LangChain namespace for serialization necessary because Pregel extends Runnable */\n    lc_namespace: string[];\n    /** @internal Flag indicating this is a Pregel instance - necessary for serialization */\n    lg_is_pregel: boolean;\n    /** The nodes in the graph, mapping node names to their PregelNode instances */\n    nodes: Nodes;\n    /** The channels in the graph, mapping channel names to their BaseChannel or ManagedValueSpec instances */\n    channels: Channels;\n    /**\n     * The input channels for the graph. These channels receive the initial input when the graph is invoked.\n     * Can be a single channel key or an array of channel keys.\n     */\n    inputChannels: keyof Channels | Array<keyof Channels>;\n    /**\n     * The output channels for the graph. These channels contain the final output when the graph completes.\n     * Can be a single channel key or an array of channel keys.\n     */\n    outputChannels: keyof Channels | Array<keyof Channels>;\n    /** Whether to automatically validate the graph structure when it is compiled. Defaults to true. */\n    autoValidate: boolean;\n    /**\n     * The streaming modes enabled for this graph. Defaults to [\"values\"].\n     * Supported modes:\n     * - \"values\": Streams the full state after each step\n     * - \"updates\": Streams state updates after each step\n     * - \"messages\": Streams messages from within nodes\n     * - \"custom\": Streams custom events from within nodes\n     * - \"debug\": Streams events related to the execution of the graph - useful for tracing & debugging graph execution\n     */\n    streamMode: StreamMode[];\n    /**\n     * Optional channels to stream. If not specified, all channels will be streamed.\n     * Can be a single channel key or an array of channel keys.\n     */\n    streamChannels?: keyof Channels | Array<keyof Channels>;\n    /**\n     * Optional array of node names or \"all\" to interrupt after executing these nodes.\n     * Used for implementing human-in-the-loop workflows.\n     */\n    interruptAfter?: Array<keyof Nodes> | All;\n    /**\n     * Optional array of node names or \"all\" to interrupt before executing these nodes.\n     * Used for implementing human-in-the-loop workflows.\n     */\n    interruptBefore?: Array<keyof Nodes> | All;\n    /** Optional timeout in milliseconds for the execution of each superstep */\n    stepTimeout?: number;\n    /** Whether to enable debug logging. Defaults to false. */\n    debug: boolean;\n    /**\n     * Optional checkpointer for persisting graph state.\n     * When provided, saves a checkpoint of the graph state at every superstep.\n     * When false or undefined, checkpointing is disabled, and the graph will not be able to save or restore state.\n     */\n    checkpointer?: BaseCheckpointSaver | boolean;\n    /** Optional retry policy for handling failures in node execution */\n    retryPolicy?: RetryPolicy;\n    /** The default configuration for graph execution, can be overridden on a per-invocation basis */\n    config?: LangGraphRunnableConfig;\n    /**\n     * Optional long-term memory store for the graph, allows for persistence & retrieval of data across threads\n     */\n    store?: BaseStore;\n    /**\n     * Optional cache for the graph, useful for caching tasks.\n     */\n    cache?: BaseCache;\n    /**\n     * Optional interrupt helper function.\n     * @internal\n     */\n    private userInterrupt?;\n    /**\n     * The trigger to node mapping for the graph run.\n     * @internal\n     */\n    private triggerToNodes;\n    /**\n     * Constructor for Pregel - meant for internal use only.\n     *\n     * @internal\n     */\n    constructor(fields: PregelParams<Nodes, Channels>);\n    /**\n     * Creates a new instance of the Pregel graph with updated configuration.\n     * This method follows the immutable pattern - instead of modifying the current instance,\n     * it returns a new instance with the merged configuration.\n     *\n     * @example\n     * ```typescript\n     * // Create a new instance with debug enabled\n     * const debugGraph = graph.withConfig({ debug: true });\n     *\n     * // Create a new instance with a specific thread ID\n     * const threadGraph = graph.withConfig({\n     *   configurable: { thread_id: \"123\" }\n     * });\n     * ```\n     *\n     * @param config - The configuration to merge with the current configuration\n     * @returns A new Pregel instance with the merged configuration\n     */\n    withConfig(config: Omit<LangGraphRunnableConfig, \"store\" | \"writer\" | \"interrupt\">): typeof this;\n    /**\n     * Validates the graph structure to ensure it is well-formed.\n     * Checks for:\n     * - No orphaned nodes\n     * - Valid input/output channel configurations\n     * - Valid interrupt configurations\n     *\n     * @returns this - The Pregel instance for method chaining\n     * @throws {GraphValidationError} If the graph structure is invalid\n     */\n    validate(): this;\n    /**\n     * Gets a list of all channels that should be streamed.\n     * If streamChannels is specified, returns those channels.\n     * Otherwise, returns all channels in the graph.\n     *\n     * @returns Array of channel keys to stream\n     */\n    get streamChannelsList(): Array<keyof Channels>;\n    /**\n     * Gets the channels to stream in their original format.\n     * If streamChannels is specified, returns it as-is (either single key or array).\n     * Otherwise, returns all channels in the graph as an array.\n     *\n     * @returns Channel keys to stream, either as a single key or array\n     */\n    get streamChannelsAsIs(): keyof Channels | Array<keyof Channels>;\n    /**\n     * Gets a drawable representation of the graph structure.\n     * This is an async version of getGraph() and is the preferred method to use.\n     *\n     * @param config - Configuration for generating the graph visualization\n     * @returns A representation of the graph that can be visualized\n     */\n    getGraphAsync(config: RunnableConfig): Promise<import(\"@langchain/core/runnables/graph\").Graph>;\n    /**\n     * Gets all subgraphs within this graph.\n     * A subgraph is a Pregel instance that is nested within a node of this graph.\n     *\n     * @deprecated Use getSubgraphsAsync instead. The async method will become the default in the next minor release.\n     * @param namespace - Optional namespace to filter subgraphs\n     * @param recurse - Whether to recursively get subgraphs of subgraphs\n     * @returns Generator yielding tuples of [name, subgraph]\n     */\n    getSubgraphs(namespace?: string, recurse?: boolean): Generator<[string, Pregel<any, any>]>;\n    /**\n     * Gets all subgraphs within this graph asynchronously.\n     * A subgraph is a Pregel instance that is nested within a node of this graph.\n     *\n     * @param namespace - Optional namespace to filter subgraphs\n     * @param recurse - Whether to recursively get subgraphs of subgraphs\n     * @returns AsyncGenerator yielding tuples of [name, subgraph]\n     */\n    getSubgraphsAsync(namespace?: string, recurse?: boolean): AsyncGenerator<[string, Pregel<any, any>]>;\n    /**\n     * Prepares a state snapshot from saved checkpoint data.\n     * This is an internal method used by getState and getStateHistory.\n     *\n     * @param config - Configuration for preparing the snapshot\n     * @param saved - Optional saved checkpoint data\n     * @param subgraphCheckpointer - Optional checkpointer for subgraphs\n     * @param applyPendingWrites - Whether to apply pending writes to tasks and then to channels\n     * @returns A snapshot of the graph state\n     * @internal\n     */\n    protected _prepareStateSnapshot({ config, saved, subgraphCheckpointer, applyPendingWrites }: {\n        config: RunnableConfig;\n        saved?: CheckpointTuple;\n        subgraphCheckpointer?: BaseCheckpointSaver;\n        applyPendingWrites?: boolean;\n    }): Promise<StateSnapshot>;\n    /**\n     * Gets the current state of the graph.\n     * Requires a checkpointer to be configured.\n     *\n     * @param config - Configuration for retrieving the state\n     * @param options - Additional options\n     * @returns A snapshot of the current graph state\n     * @throws {GraphValueError} If no checkpointer is configured\n     */\n    getState(config: RunnableConfig, options?: GetStateOptions): Promise<StateSnapshot>;\n    /**\n     * Gets the history of graph states.\n     * Requires a checkpointer to be configured.\n     * Useful for:\n     * - Debugging execution history\n     * - Implementing time travel\n     * - Analyzing graph behavior\n     *\n     * @param config - Configuration for retrieving the history\n     * @param options - Options for filtering the history\n     * @returns An async iterator of state snapshots\n     * @throws {Error} If no checkpointer is configured\n     */\n    getStateHistory(config: RunnableConfig, options?: CheckpointListOptions): AsyncIterableIterator<StateSnapshot>;\n    /**\n     * Apply updates to the graph state in bulk.\n     * Requires a checkpointer to be configured.\n     *\n     * This method is useful for recreating a thread\n     * from a list of updates, especially if a checkpoint\n     * is created as a result of multiple tasks.\n     *\n     * @internal The API might change in the future.\n     *\n     * @param startConfig - Configuration for the update\n     * @param updates - The list of updates to apply to graph state\n     * @returns Updated configuration\n     * @throws {GraphValueError} If no checkpointer is configured\n     * @throws {InvalidUpdateError} If the update cannot be attributed to a node or an update can be only applied in sequence.\n     */\n    bulkUpdateState(startConfig: LangGraphRunnableConfig, supersteps: Array<{\n        updates: Array<{\n            values?: Record<string, unknown> | unknown;\n            asNode?: keyof Nodes | string;\n        }>;\n    }>): Promise<RunnableConfig>;\n    /**\n     * Updates the state of the graph with new values.\n     * Requires a checkpointer to be configured.\n     *\n     * This method can be used for:\n     * - Implementing human-in-the-loop workflows\n     * - Modifying graph state during breakpoints\n     * - Integrating external inputs into the graph\n     *\n     * @param inputConfig - Configuration for the update\n     * @param values - The values to update the state with\n     * @param asNode - Optional node name to attribute the update to\n     * @returns Updated configuration\n     * @throws {GraphValueError} If no checkpointer is configured\n     * @throws {InvalidUpdateError} If the update cannot be attributed to a node\n     */\n    updateState(inputConfig: LangGraphRunnableConfig, values: Record<string, unknown> | unknown, asNode?: keyof Nodes | string): Promise<RunnableConfig>;\n    /**\n     * Gets the default values for various graph configuration options.\n     * This is an internal method used to process and normalize configuration options.\n     *\n     * @param config - The input configuration options\n     * @returns A tuple containing normalized values for:\n     * - debug mode\n     * - stream modes\n     * - input keys\n     * - output keys\n     * - remaining config\n     * - interrupt before nodes\n     * - interrupt after nodes\n     * - checkpointer\n     * - store\n     * - whether stream mode is single\n     * - node cache\n     * - whether checkpoint during is enabled\n     * @internal\n     */\n    _defaults(config: PregelOptions<Nodes, Channels>): [\n        boolean,\n        StreamMode[],\n        string | string[],\n        string | string[],\n        LangGraphRunnableConfig,\n        All | string[],\n        All | string[],\n        BaseCheckpointSaver | undefined,\n        BaseStore | undefined,\n        boolean,\n        BaseCache | undefined,\n        Durability\n    ];\n    /**\n     * Streams the execution of the graph, emitting state updates as they occur.\n     * This is the primary method for observing graph execution in real-time.\n     *\n     * Stream modes:\n     * - \"values\": Emits complete state after each step\n     * - \"updates\": Emits only state changes after each step\n     * - \"debug\": Emits detailed debug information\n     * - \"messages\": Emits messages from within nodes\n     * - \"custom\": Emits custom events from within nodes\n     * - \"checkpoints\": Emits checkpoints from within nodes\n     * - \"tasks\": Emits tasks from within nodes\n     *\n     * @param input - The input to start graph execution with\n     * @param options - Configuration options for streaming\n     * @returns An async iterable stream of graph state updates\n     */\n    stream<TStreamMode extends StreamMode | StreamMode[] | undefined, TSubgraphs extends boolean, TEncoding extends \"text/event-stream\" | undefined>(input: InputType | CommandType | null, options?: Partial<PregelOptions<Nodes, Channels, ContextType, TStreamMode, TSubgraphs, TEncoding>>): Promise<IterableReadableStream<StreamOutputMap<TStreamMode, TSubgraphs, StreamUpdatesType, StreamValuesType, keyof Nodes, NodeReturnType, StreamCustom, TEncoding>>>;\n    /**\n     * @inheritdoc\n     */\n    streamEvents(input: InputType | CommandType | null, options: Partial<PregelOptions<Nodes, Channels, ContextType>> & {\n        version: \"v1\" | \"v2\";\n    }, streamOptions?: StreamEventsOptions): IterableReadableStream<StreamEvent>;\n    streamEvents(input: InputType | CommandType | null, options: Partial<PregelOptions<Nodes, Channels, ContextType>> & {\n        version: \"v1\" | \"v2\";\n        encoding: \"text/event-stream\";\n    }, streamOptions?: StreamEventsOptions): IterableReadableStream<Uint8Array>;\n    /**\n     * Validates the input for the graph.\n     * @param input - The input to validate\n     * @returns The validated input\n     * @internal\n     */\n    protected _validateInput(input: PregelInputType): Promise<any>;\n    /**\n     * Validates the context options for the graph.\n     * @param context - The context options to validate\n     * @returns The validated context options\n     * @internal\n     */\n    protected _validateContext(context: Partial<LangGraphRunnableConfig[\"context\"]>): Promise<LangGraphRunnableConfig[\"context\"]>;\n    /**\n     * Internal iterator used by stream() to generate state updates.\n     * This method handles the core logic of graph execution and streaming.\n     *\n     * @param input - The input to start graph execution with\n     * @param options - Configuration options for streaming\n     * @returns AsyncGenerator yielding state updates\n     * @internal\n     */\n    _streamIterator(input: PregelInputType | Command, options?: Partial<PregelOptions<Nodes, Channels>>): AsyncGenerator<PregelOutputType>;\n    /**\n     * Run the graph with a single input and config.\n     * @param input The input to the graph.\n     * @param options The configuration to use for the run.\n     */\n    invoke(input: InputType | CommandType | null, options?: Partial<Omit<PregelOptions<Nodes, Channels, ContextType>, \"encoding\">>): Promise<OutputType>;\n    private _runLoop;\n    clearCache(): Promise<void>;\n}\n"],"mappings":"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"}