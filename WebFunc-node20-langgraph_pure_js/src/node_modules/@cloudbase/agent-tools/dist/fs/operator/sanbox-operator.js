"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.SandboxFileOperator = void 0;
const code_interpreter_1 = require("@e2b/code-interpreter");
const base_operator_1 = require("./base-operator");
const Stats_1 = require("memfs/lib/node/Stats");
const node_1 = require("memfs/lib/node");
const constants_1 = require("memfs/lib/constants");
const path = __importStar(require("path"));
class SandboxFileOperator extends base_operator_1.BaseFileOperator {
    constructor(fields) {
        super();
        if (!fields?.sandbox) {
            throw new Error("Sandbox instance is required");
        }
        this.sandbox = fields.sandbox;
        this.workspaceRoot = path.resolve("/home/user", fields?.workspaceRoot);
    }
    /**
     * Resolve path relative to workspace root if it's not absolute
     */
    resolvePath(pathLike) {
        const pathStr = pathLike.toString();
        if (path.posix.isAbsolute(pathStr)) {
            return pathStr;
        }
        // Use path.posix.join for sandbox environment (Unix-like paths)
        return path.posix.join(this.workspaceRoot, pathStr);
    }
    async access(path) {
        const resolvedPath = this.resolvePath(path);
        await this.sandbox.files.getInfo(resolvedPath);
    }
    async readFile(path, encoding) {
        const resolvedPath = this.resolvePath(path);
        const res = await this.sandbox.files.read(resolvedPath);
        const buffer = Buffer.from(res);
        if (encoding) {
            return buffer.toString(encoding);
        }
        else {
            return buffer;
        }
    }
    async mkdir(path, options) {
        const resolvedPath = this.resolvePath(path);
        if (options?.recursive) {
            const isSuccess = await this.sandbox.files.makeDir(resolvedPath);
            if (isSuccess) {
                return resolvedPath;
            }
            else {
                return undefined;
            }
        }
        else {
            await this.sandbox.files.makeDir(resolvedPath);
            return undefined;
        }
    }
    async writeFile(path, data) {
        const resolvedPath = this.resolvePath(path);
        // Handle conversion from NodeJS.ArrayBufferView to ArrayBuffer
        let finalData;
        if (typeof data === "string") {
            finalData = data;
        }
        else if (data instanceof ArrayBuffer) {
            finalData = data;
        }
        else if (data instanceof Blob) {
            finalData = data;
        }
        else if (data instanceof ReadableStream) {
            finalData = data;
        }
        else {
            // Handle NodeJS.ArrayBufferView (TypedArray or DataView)
            finalData = data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
        }
        await this.sandbox.files.write(resolvedPath, finalData);
    }
    async readdir(path, options) {
        const resolvedPath = this.resolvePath(path);
        const items = await this.sandbox.files.list(resolvedPath);
        if (options?.withFileTypes) {
            // Return Dirent array
            return items.map((item) => {
                const dirent = {
                    name: item.name,
                    path: item.path,
                    parentPath: "",
                    isFile: () => item.type === code_interpreter_1.FileType.FILE,
                    isDirectory: () => item.type === code_interpreter_1.FileType.DIR,
                    isBlockDevice: () => false,
                    isCharacterDevice: () => false,
                    isSymbolicLink: () => false,
                    isFIFO: () => false,
                    isSocket: () => false,
                };
                return dirent;
            });
        }
        else {
            // Return string array (file names)
            return items.map((item) => item.name);
        }
    }
    async stat(path) {
        const resolvedPath = this.resolvePath(path);
        const info = await this.sandbox.files.getInfo(resolvedPath);
        const node = new node_1.Node(0, (info.type === code_interpreter_1.FileType.FILE ? constants_1.constants.S_IFREG : constants_1.constants.S_IFDIR) |
            info.mode);
        node.mtime = info.modifiedTime ? new Date(info.modifiedTime) : new Date();
        node.ctime = new Date(node.mtime);
        node.getSize = () => info.size;
        const stats = Stats_1.Stats.build(node);
        return stats;
    }
    async exists(path) {
        const resolvedPath = this.resolvePath(path);
        return this.sandbox.files.exists(resolvedPath);
    }
    async unlink(path) {
        const resolvedPath = this.resolvePath(path);
        await this.sandbox.files.remove(resolvedPath);
    }
    async rmdir(path) {
        const resolvedPath = this.resolvePath(path);
        await this.sandbox.files.remove(resolvedPath);
    }
    async rename(oldPath, newPath) {
        const resolvedOldPath = this.resolvePath(oldPath);
        const resolvedNewPath = this.resolvePath(newPath);
        await this.sandbox.files.rename(resolvedOldPath, resolvedNewPath);
    }
}
exports.SandboxFileOperator = SandboxFileOperator;
//# sourceMappingURL=sanbox-operator.js.map