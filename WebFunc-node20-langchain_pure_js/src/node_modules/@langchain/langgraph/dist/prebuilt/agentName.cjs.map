{"version":3,"file":"agentName.cjs","names":["AIMessage","RunnableSequence","RunnableLambda"],"sources":["../../src/prebuilt/agentName.ts"],"sourcesContent":["import { LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport {\n  AIMessage,\n  AIMessageFields,\n  BaseMessage,\n  BaseMessageLike,\n  isAIMessage,\n  isAIMessageChunk,\n  isBaseMessage,\n  isBaseMessageChunk,\n  MessageContent,\n} from \"@langchain/core/messages\";\nimport { RunnableLambda, RunnableSequence } from \"@langchain/core/runnables\";\n\nconst NAME_PATTERN = /<name>(.*?)<\\/name>/s;\nconst CONTENT_PATTERN = /<content>(.*?)<\\/content>/s;\n\nexport type AgentNameMode = \"inline\";\n\n/**\n * Attach formatted agent names to the messages passed to and from a language model.\n *\n * This is useful for making a message history with multiple agents more coherent.\n *\n * NOTE: agent name is consumed from the message.name field.\n * If you're using an agent built with createReactAgent, name is automatically set.\n * If you're building a custom agent, make sure to set the name on the AI message returned by the LLM.\n *\n * @deprecated migrated to `langchain` package.\n *\n * @param message - Message to add agent name formatting to\n * @returns Message with agent name formatting\n *\n * @internal\n */\nexport function _addInlineAgentName<T extends BaseMessageLike>(\n  message: T\n): T | AIMessage {\n  const isAI =\n    isBaseMessage(message) &&\n    (isAIMessage(message) ||\n      (isBaseMessageChunk(message) && isAIMessageChunk(message)));\n\n  if (!isAI || !message.name) {\n    return message;\n  }\n\n  const { name } = message;\n\n  if (typeof message.content === \"string\") {\n    const fields = (\n      Object.keys(message.lc_kwargs ?? {}).length > 0\n        ? message.lc_kwargs\n        : message\n    ) as AIMessageFields;\n\n    return new AIMessage({\n      ...fields,\n      content: `<name>${name}</name><content>${message.content}</content>`,\n      name: undefined,\n    });\n  }\n\n  const updatedContent = [];\n  let textBlockCount = 0;\n\n  for (const contentBlock of message.content) {\n    if (typeof contentBlock === \"string\") {\n      textBlockCount += 1;\n      updatedContent.push(\n        `<name>${name}</name><content>${contentBlock}</content>`\n      );\n    } else if (\n      typeof contentBlock === \"object\" &&\n      \"type\" in contentBlock &&\n      contentBlock.type === \"text\"\n    ) {\n      textBlockCount += 1;\n      updatedContent.push({\n        ...contentBlock,\n        text: `<name>${name}</name><content>${contentBlock.text}</content>`,\n      });\n    } else {\n      updatedContent.push(contentBlock);\n    }\n  }\n\n  if (!textBlockCount) {\n    updatedContent.unshift({\n      type: \"text\",\n      text: `<name>${name}</name><content></content>`,\n    });\n  }\n  return new AIMessage({\n    ...message.lc_kwargs,\n    content: updatedContent as MessageContent,\n    name: undefined,\n  });\n}\n\n/**\n * Remove explicit name and content XML tags from the AI message content.\n *\n * @deprecated migrated to `langchain` package.\n *\n * Examples:\n *\n * @example\n * ```typescript\n * removeInlineAgentName(new AIMessage({ content: \"<name>assistant</name><content>Hello</content>\", name: \"assistant\" }))\n * // AIMessage with content: \"Hello\"\n *\n * removeInlineAgentName(new AIMessage({ content: [{type: \"text\", text: \"<name>assistant</name><content>Hello</content>\"}], name: \"assistant\" }))\n * // AIMessage with content: [{type: \"text\", text: \"Hello\"}]\n * ```\n *\n * @internal\n */\nexport function _removeInlineAgentName<T extends BaseMessage>(message: T): T {\n  if (!isAIMessage(message) || !message.content) {\n    return message;\n  }\n\n  let updatedContent: MessageContent = [];\n  let updatedName: string | undefined;\n\n  if (Array.isArray(message.content)) {\n    updatedContent = message.content\n      .filter((block) => {\n        if (block.type === \"text\" && typeof block.text === \"string\") {\n          const nameMatch = block.text.match(NAME_PATTERN);\n          const contentMatch = block.text.match(CONTENT_PATTERN);\n          // don't include empty content blocks that were added because there was no text block to modify\n          if (nameMatch && (!contentMatch || contentMatch[1] === \"\")) {\n            // capture name from text block\n            // eslint-disable-next-line prefer-destructuring\n            updatedName = nameMatch[1];\n            return false;\n          }\n          return true;\n        }\n        return true;\n      })\n      .map((block) => {\n        if (block.type === \"text\" && typeof block.text === \"string\") {\n          const nameMatch = block.text.match(NAME_PATTERN);\n          const contentMatch = block.text.match(CONTENT_PATTERN);\n\n          if (!nameMatch || !contentMatch) {\n            return block;\n          }\n\n          // capture name from text block\n          // eslint-disable-next-line prefer-destructuring\n          updatedName = nameMatch[1];\n\n          return {\n            ...block,\n            text: contentMatch[1],\n          };\n        }\n        return block;\n      });\n  } else {\n    const content = message.content as string;\n    const nameMatch = content.match(NAME_PATTERN);\n    const contentMatch = content.match(CONTENT_PATTERN);\n\n    if (!nameMatch || !contentMatch) {\n      return message;\n    }\n\n    // eslint-disable-next-line prefer-destructuring\n    updatedName = nameMatch[1];\n    // eslint-disable-next-line prefer-destructuring\n    updatedContent = contentMatch[1];\n  }\n\n  return new AIMessage({\n    ...(Object.keys(message.lc_kwargs ?? {}).length > 0\n      ? message.lc_kwargs\n      : message),\n    content: updatedContent,\n    name: updatedName,\n  }) as T;\n}\n\n/**\n * Attach formatted agent names to the messages passed to and from a language model.\n *\n * This is useful for making a message history with multiple agents more coherent.\n *\n * * @deprecated migrated to `langchain` package.\n *\n * NOTE: agent name is consumed from the message.name field.\n * If you're using an agent built with createReactAgent, name is automatically set.\n * If you're building a custom agent, make sure to set the name on the AI message returned by the LLM.\n *\n * @param model - Language model to add agent name formatting to\n * @param agentNameMode - How to expose the agent name to the LLM\n *   - \"inline\": Add the agent name directly into the content field of the AI message using XML-style tags.\n *     Example: \"How can I help you\" -> \"<name>agent_name</name><content>How can I help you?</content>\".\n */\nexport function withAgentName(\n  model: LanguageModelLike,\n  agentNameMode: AgentNameMode\n): LanguageModelLike {\n  let processInputMessage: (message: BaseMessageLike) => BaseMessageLike;\n  let processOutputMessage: (message: BaseMessage) => BaseMessage;\n\n  if (agentNameMode === \"inline\") {\n    processInputMessage = _addInlineAgentName;\n    processOutputMessage = _removeInlineAgentName;\n  } else {\n    throw new Error(\n      `Invalid agent name mode: ${agentNameMode}. Needs to be one of: \"inline\"`\n    );\n  }\n\n  function processInputMessages(\n    messages: BaseMessageLike[]\n  ): BaseMessageLike[] {\n    return messages.map(processInputMessage);\n  }\n\n  return RunnableSequence.from([\n    RunnableLambda.from(processInputMessages),\n    model,\n    RunnableLambda.from(processOutputMessage),\n  ]);\n}\n"],"mappings":"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"}