/* eslint-disable eqeqeq */
import type { IFetchOptions, SDKRequestInterface } from '@cloudbase/adapter-interface'
import type { ICloudbase, ICloudbaseConfig } from '@cloudbase/types'
import type { ICloudbaseComponent } from '@cloudbase/types/component'
import { AI } from './AI'
import { Bot } from './bot'
import * as models from './models'
import * as utils from './utils'

const COMPONENT_NAME = 'ai'

const { MODELS, ...restModels } = models

interface IHandleRequestInstance {
  req: SDKRequestInterface
}

type HandleRequestInstanceFunc = (options: IHandleRequestInstance) => SDKRequestInterface

const createRequestInstanceWithAccessTokenHeader = ({
  getAccessToken,
  req,
}: IHandleRequestInstance & { getAccessToken: () => Promise<{ accessToken: string }> }) => {
  const fetch: typeof req.fetch = async (options: IFetchOptions & { token?: string }) => {
    if (typeof req.fetch !== 'function') {
      throw new Error('req.fetch is not a function')
    }

    const { token, headers = {}, ...restOptions } = options
    let accessToken: string
    if (token != null) {
      accessToken = token
    } else {
      accessToken = (await getAccessToken()).accessToken
    }

    return req.fetch({
      headers: {
        Authorization: `Bearer ${accessToken}`,
        ...headers,
      },
      ...restOptions,
    })
  }

  return {
    download: req.download,
    post: req.post,
    upload: req.upload,
    fetch,
  }
}

interface AIInitOption {
  baseUrl?: string
}

interface ICreateAI {
  req: SDKRequestInterface
  baseUrl?: string
  env?: string
  getAccessToken?: () => Promise<{ accessToken: string }>
  handleReqInstance?: HandleRequestInstanceFunc
  i18n?: ICloudbaseConfig['i18n']
}

/**
 * 最简地创建一个接云开发网关服务的 `AI` 实例，请求时会自动带上鉴权请求头。
 * 只需要传入：
 *
 * - `getAccessToken`: 获取 accessToken 的函数
 * - `req`: 请求函数，一般从 adapter 上拿
 * - `env`: 云开发环境 ID
 *
 * 其他参数可按需传入覆盖函数逻辑。
 */
function createAI({ env, baseUrl, req, getAccessToken, handleReqInstance, i18n }: ICreateAI) {
  const getBaseUrl = () => {
    if (baseUrl != null) {
      return baseUrl
    }
    if (env == null) {
      throw new Error('`env` is required when `baseUrl` is not provided!')
    }
    return `https://${env}.api.tcloudbasegateway.com/v1`
  }

  const getReq = () => {
    if (handleReqInstance == null) {
      if (getAccessToken == null) {
        throw new Error('`getAccessToken` is required when `handleReqInstance` is not provided!')
      }
      return createRequestInstanceWithAccessTokenHeader({ req, getAccessToken })
    }
    return handleReqInstance({ req })
  }

  return new AI(getReq(), getBaseUrl(), i18n)
}

// 兼容
/**
 * @deprecated use `createAI`
 */
const createAi = createAI

/**
 * 创建 `AI` 实例。
 * 该函数挂载在 js sdk 的 Cloudbase 实例上。
 * 该函数调用了本模块暴露的 `createAI` 函数，但调用时通过传入参数做了逻辑覆盖：
 *
 * - 传入从 Cloudbase 实例上的中心的 `req`
 * - 传入从 Cloudbase 实例上拿到的 `baseUrl`
 * - 传入一个不处理 `req` 的 `handleReqInstance`，由于 `req` 是从 Cloudbase 实例上拿到的，这个中心的 `req` 已经可用了
 * - 不用传入 `env` 了，因为已经传了 `baseUrl`
 * - 不用传入 `getAccessToken` 了，因为传了 `handleReqInstance`
 */
function ai(
  this: ICloudbase & { getEndPointWithKey: (key: 'GATEWAY') => { BASE_URL: string; PROTOCOL: string } },
  options?: AIInitOption,
) {
  const req = this.request

  if (req.fetch == null) {
    throw new Error('cloudbase.request.fetch() unimplemented!')
  }

  const getUrlFromCloud = () => {
    const { BASE_URL, PROTOCOL } = this.getEndPointWithKey('GATEWAY')
    return `${PROTOCOL}${BASE_URL}`
  }

  const baseUrl = options?.baseUrl ?? getUrlFromCloud()

  return createAI({ req, baseUrl, handleReqInstance: ({ req }) => req, i18n: this.config.i18n })
}

const component: ICloudbaseComponent = {
  name: COMPONENT_NAME,
  entity: { ai },
}

function registerAi(app: ICloudbase) {
  try {
    app.registerComponent(component)
  } catch (e) {
    console.warn(e)
  }
}

export { AI, Bot, createAi, createAI, restModels as models, registerAi, utils }
export * from './type'

try {
  (window as any).registerAi = registerAi
} catch (e) {}
