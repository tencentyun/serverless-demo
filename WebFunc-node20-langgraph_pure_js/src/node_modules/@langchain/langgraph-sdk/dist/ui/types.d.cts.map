{"version":3,"file":"types.d.cts","names":["Client","ClientConfig","ThreadState","Config","Checkpoint","Metadata","Command","MultitaskStrategy","OnCompletionBehavior","DisconnectMode","Durability","UpdatesStreamEvent","CustomStreamEvent","MetadataStreamEvent","EventsStreamEvent","DebugStreamEvent","CheckpointsStreamEvent","TasksStreamEvent","StreamMode","DefaultToolCall","AIMessage","BagTemplate","AgentTypeConfigLike","IsAgentLike","T","ExtractAgentConfig","InferSchemaInput","S","Args","InferToolInput","ToolCallFromAgentTool","N","Record","InferAgentToolCalls","Tool","ExtractToolCallFromMessageUnion","M","TC","ExtractToolCallsFromState","StateType","Messages","MessageMetadata","GetUpdateType","Bag","Partial","GetConfigurableType","GetInterruptType","GetCustomEventType","GetToolCallsType","RunCallbackMeta","UseStreamThread","Promise","UseStreamOptions","RunMetadataStorage","ConfigWithConfigurable","ConfigurableType","SubmitOptions","ContextType","Omit","Array","UseStreamTransport","AbortSignal","AsyncGenerator","UseStreamCustomOptions","Pick","CustomSubmitOptions"],"sources":["../../src/ui/types.d.ts"],"sourcesContent":["import type { Client, ClientConfig } from \"../client.js\";\nimport type { ThreadState, Config, Checkpoint, Metadata } from \"../schema.js\";\nimport type { Command, MultitaskStrategy, OnCompletionBehavior, DisconnectMode, Durability } from \"../types.js\";\nimport type { UpdatesStreamEvent, CustomStreamEvent, MetadataStreamEvent, EventsStreamEvent, DebugStreamEvent, CheckpointsStreamEvent, TasksStreamEvent, StreamMode } from \"../types.stream.js\";\nimport type { DefaultToolCall, AIMessage } from \"../types.messages.js\";\nimport type { BagTemplate } from \"../types.template.js\";\n/**\n * Minimal interface matching the structure of AgentTypeConfig from @langchain/langgraph.\n * This allows type inference from ReactAgent without requiring the langchain dependency.\n */\nexport interface AgentTypeConfigLike {\n    Response: unknown;\n    State: unknown;\n    Context: unknown;\n    Middleware: unknown;\n    Tools: unknown;\n}\n/**\n * Check if a type is agent-like (has `~agentTypes` phantom property).\n * This property is present on `ReactAgent` instances created with `createAgent`.\n */\nexport type IsAgentLike<T> = T extends {\n    \"~agentTypes\": AgentTypeConfigLike;\n} ? true : false;\n/**\n * Extract the AgentTypeConfig from an agent-like type.\n *\n * @example\n * ```ts\n * const agent = createAgent({ ... });\n * type Config = ExtractAgentConfig<typeof agent>;\n * // Config is the AgentTypeConfig with Response, State, Context, Middleware, Tools\n * ```\n */\nexport type ExtractAgentConfig<T> = T extends {\n    \"~agentTypes\": infer Config;\n} ? Config extends AgentTypeConfigLike ? Config : never : never;\n/**\n * Helper type to infer schema input type, supporting both Zod v3 and v4.\n * - Zod v4 uses `_zod.input` property\n * - Zod v3 uses `_input` property\n */\ntype InferSchemaInput<S> = S extends {\n    _zod: {\n        input: infer Args;\n    };\n} ? Args : S extends {\n    _input: infer Args;\n} ? Args : never;\n/**\n * Helper type to extract the input type from a DynamicStructuredTool's _call method.\n * This is more reliable than trying to infer from the schema directly because\n * DynamicStructuredTool has the input type baked into its _call signature.\n */\ntype InferToolInput<T> = T extends {\n    _call: (arg: infer Args, ...rest: any[]) => any;\n} ? Args : T extends {\n    schema: infer S;\n} ? InferSchemaInput<S> : never;\n/**\n * Extract a tool call type from a single tool.\n * Works with tools created via `tool()` from `@langchain/core/tools`.\n *\n * This extracts the literal name type from DynamicStructuredTool's NameT parameter\n * and the args type from the _call method or schema's input property.\n */\ntype ToolCallFromAgentTool<T> = T extends {\n    name: infer N;\n} ? N extends string ? InferToolInput<T> extends infer Args ? Args extends never ? never : Args extends Record<string, any> ? {\n    name: N;\n    args: Args;\n    id?: string;\n    type?: \"tool_call\";\n} : never : never : never : never;\n/**\n * Extract tool calls type from an agent's tools.\n * Converts the tools array to a discriminated union of tool calls.\n *\n * This handles both tuple types (e.g., `readonly [Tool1, Tool2]`) and\n * array-of-union types (e.g., `readonly (Tool1 | Tool2)[]`) which is how\n * `createAgent` captures tool types.\n *\n * @example\n * ```ts\n * const agent = createAgent({ tools: [getWeather, search], ... });\n * type ToolCalls = InferAgentToolCalls<typeof agent>;\n * // ToolCalls is:\n * // | { name: \"get_weather\"; args: { location: string }; id?: string }\n * // | { name: \"search\"; args: { query: string }; id?: string }\n * ```\n */\nexport type InferAgentToolCalls<T> = ExtractAgentConfig<T>[\"Tools\"] extends readonly (infer Tool)[] ? ToolCallFromAgentTool<Tool> extends never ? DefaultToolCall : ToolCallFromAgentTool<Tool> : DefaultToolCall;\n/**\n * Extract the tool call type parameter from an AIMessage in a message union.\n * Returns `never` if the message is not an AIMessage or uses DefaultToolCall.\n *\n * The key distinction: custom tool calls have literal `name` types (e.g., \"get_weather\"),\n * while DefaultToolCall has `name: string`. We check if `string extends TC[\"name\"]` -\n * if true, it's DefaultToolCall; if false, it's a custom type with literal names.\n */\ntype ExtractToolCallFromMessageUnion<M> = M extends AIMessage<infer TC> ? TC extends {\n    name: infer N;\n} ? string extends N ? never : TC : never : never;\n/**\n * Extract the tool call type from a StateType's messages property.\n * This is the primary way to specify tool call types when using useStream.\n *\n * @example\n * ```ts\n * // Define state with typed messages\n * type MyToolCalls =\n *   | { name: \"get_weather\"; args: { location: string }; id?: string }\n *   | { name: \"search\"; args: { query: string }; id?: string };\n *\n * interface MyState {\n *   messages: Message<MyToolCalls>[];\n * }\n *\n * // ExtractToolCallsFromState<MyState> = MyToolCalls\n * ```\n */\nexport type ExtractToolCallsFromState<StateType extends Record<string, unknown>> = StateType extends {\n    messages: infer Messages;\n} ? Messages extends readonly (infer M)[] ? ExtractToolCallFromMessageUnion<M> : Messages extends (infer M)[] ? ExtractToolCallFromMessageUnion<M> : never : never;\nexport type MessageMetadata<StateType extends Record<string, unknown>> = {\n    /**\n     * The ID of the message used.\n     */\n    messageId: string;\n    /**\n     * The first thread state the message was seen in.\n     */\n    firstSeenState: ThreadState<StateType> | undefined;\n    /**\n     * The branch of the message.\n     */\n    branch: string | undefined;\n    /**\n     * The list of branches this message is part of.\n     * This is useful for displaying branching controls.\n     */\n    branchOptions: string[] | undefined;\n    /**\n     * Metadata sent alongside the message during run streaming.\n     * @remarks This metadata only exists temporarily in browser memory during streaming and is not persisted after completion.\n     */\n    streamMetadata: Record<string, unknown> | undefined;\n};\nexport type GetUpdateType<Bag extends BagTemplate, StateType extends Record<string, unknown>> = Bag extends {\n    UpdateType: unknown;\n} ? Bag[\"UpdateType\"] : Partial<StateType>;\nexport type GetConfigurableType<Bag extends BagTemplate> = Bag extends {\n    ConfigurableType: Record<string, unknown>;\n} ? Bag[\"ConfigurableType\"] : Record<string, unknown>;\nexport type GetInterruptType<Bag extends BagTemplate> = Bag extends {\n    InterruptType: unknown;\n} ? Bag[\"InterruptType\"] : unknown;\nexport type GetCustomEventType<Bag extends BagTemplate> = Bag extends {\n    CustomEventType: unknown;\n} ? Bag[\"CustomEventType\"] : unknown;\n/**\n * Extract the tool call type from a StateType's messages property.\n * This is the canonical way to get typed tool calls in useStream.\n *\n * Tool call types are now extracted from the messages property of StateType,\n * rather than being specified separately in the Bag.\n *\n * @example\n * ```ts\n * // Define state with typed messages\n * type MyToolCalls =\n *   | { name: \"get_weather\"; args: { location: string }; id?: string }\n *   | { name: \"search\"; args: { query: string }; id?: string };\n *\n * interface MyState {\n *   messages: Message<MyToolCalls>[];\n * }\n *\n * // GetToolCallsType<MyState> = MyToolCalls\n * ```\n */\nexport type GetToolCallsType<StateType extends Record<string, unknown>> = ExtractToolCallsFromState<StateType> extends never ? DefaultToolCall : ExtractToolCallsFromState<StateType>;\nexport interface RunCallbackMeta {\n    run_id: string;\n    thread_id: string;\n}\nexport interface UseStreamThread<StateType extends Record<string, unknown>> {\n    data: ThreadState<StateType>[] | null | undefined;\n    error: unknown;\n    isLoading: boolean;\n    mutate: (mutateId?: string) => Promise<ThreadState<StateType>[] | null | undefined>;\n}\nexport interface UseStreamOptions<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> {\n    /**\n     * The ID of the assistant to use.\n     */\n    assistantId: string;\n    /**\n     * Client used to send requests.\n     */\n    client?: Client;\n    /**\n     * The URL of the API to use.\n     */\n    apiUrl?: ClientConfig[\"apiUrl\"];\n    /**\n     * The API key to use.\n     */\n    apiKey?: ClientConfig[\"apiKey\"];\n    /**\n     * Custom call options, such as custom fetch implementation.\n     */\n    callerOptions?: ClientConfig[\"callerOptions\"];\n    /**\n     * Default headers to send with requests.\n     */\n    defaultHeaders?: ClientConfig[\"defaultHeaders\"];\n    /**\n     * Specify the key within the state that contains messages.\n     * Defaults to \"messages\".\n     *\n     * @default \"messages\"\n     */\n    messagesKey?: string;\n    /**\n     * Callback that is called when an error occurs.\n     */\n    onError?: (error: unknown, run: RunCallbackMeta | undefined) => void;\n    /**\n     * Callback that is called when the stream is finished.\n     */\n    onFinish?: (state: ThreadState<StateType>, run: RunCallbackMeta | undefined) => void;\n    /**\n     * Callback that is called when a new stream is created.\n     */\n    onCreated?: (run: RunCallbackMeta) => void;\n    /**\n     * Callback that is called when an update event is received.\n     */\n    onUpdateEvent?: (data: UpdatesStreamEvent<GetUpdateType<Bag, StateType>>[\"data\"], options: {\n        namespace: string[] | undefined;\n        mutate: (update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)) => void;\n    }) => void;\n    /**\n     * Callback that is called when a custom event is received.\n     */\n    onCustomEvent?: (data: CustomStreamEvent<GetCustomEventType<Bag>>[\"data\"], options: {\n        namespace: string[] | undefined;\n        mutate: (update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)) => void;\n    }) => void;\n    /**\n     * Callback that is called when a metadata event is received.\n     */\n    onMetadataEvent?: (data: MetadataStreamEvent[\"data\"]) => void;\n    /**\n     * Callback that is called when a LangChain event is received.\n     * @see https://langchain-ai.github.io/langgraph/cloud/how-tos/stream_events/#stream-graph-in-events-mode for more details.\n     */\n    onLangChainEvent?: (data: EventsStreamEvent[\"data\"]) => void;\n    /**\n     * Callback that is called when a debug event is received.\n     * @internal This API is experimental and subject to change.\n     */\n    onDebugEvent?: (data: DebugStreamEvent[\"data\"], options: {\n        namespace: string[] | undefined;\n    }) => void;\n    /**\n     * Callback that is called when a checkpoints event is received.\n     */\n    onCheckpointEvent?: (data: CheckpointsStreamEvent<StateType>[\"data\"], options: {\n        namespace: string[] | undefined;\n    }) => void;\n    /**\n     * Callback that is called when a tasks event is received.\n     */\n    onTaskEvent?: (data: TasksStreamEvent<StateType, GetUpdateType<Bag, StateType>>[\"data\"], options: {\n        namespace: string[] | undefined;\n    }) => void;\n    /**\n     * Callback that is called when the stream is stopped by the user.\n     * Provides a mutate function to update the stream state immediately\n     * without requiring a server roundtrip.\n     *\n     * @example\n     * ```typescript\n     * onStop: ({ mutate }) => {\n     *   mutate((prev) => ({\n     *     ...prev,\n     *     ui: prev.ui?.map(component =>\n     *       component.props.isLoading\n     *         ? { ...component, props: { ...component.props, stopped: true, isLoading: false }}\n     *         : component\n     *     )\n     *   }));\n     * }\n     * ```\n     */\n    onStop?: (options: {\n        mutate: (update: Partial<StateType> | ((prev: StateType) => Partial<StateType>)) => void;\n    }) => void;\n    /**\n     * The ID of the thread to fetch history and current values from.\n     */\n    threadId?: string | null;\n    /**\n     * Callback that is called when the thread ID is updated (ie when a new thread is created).\n     */\n    onThreadId?: (threadId: string) => void;\n    /** Will reconnect the stream on mount */\n    reconnectOnMount?: boolean | (() => RunMetadataStorage);\n    /**\n     * Initial values to display immediately when loading a thread.\n     * Useful for displaying cached thread data while official history loads.\n     * These values will be replaced when official thread data is fetched.\n     *\n     * Note: UI components from initialValues will render immediately if they're\n     * predefined in LoadExternalComponent's components prop, providing instant\n     * cached UI display without server fetches.\n     */\n    initialValues?: StateType | null;\n    /**\n     * Whether to fetch the history of the thread.\n     * If true, the history will be fetched from the server. Defaults to 10 entries.\n     * If false, only the last state will be fetched from the server.\n     * @default true\n     */\n    fetchStateHistory?: boolean | {\n        limit: number;\n    };\n    /**\n     * Manage the thread state externally.\n     */\n    thread?: UseStreamThread<StateType>;\n    /**\n     * Throttle the stream.\n     * If a number is provided, the stream will be throttled to the given number of milliseconds.\n     * If `true`, updates are batched in a single macrotask.\n     * If `false`, updates are not throttled or batched.\n     * @default true\n     */\n    throttle?: number | boolean;\n}\ninterface RunMetadataStorage {\n    getItem(key: `lg:stream:${string}`): string | null;\n    setItem(key: `lg:stream:${string}`, value: string): void;\n    removeItem(key: `lg:stream:${string}`): void;\n}\ntype ConfigWithConfigurable<ConfigurableType extends Record<string, unknown>> = Config & {\n    configurable?: ConfigurableType;\n};\nexport interface SubmitOptions<StateType extends Record<string, unknown> = Record<string, unknown>, ContextType extends Record<string, unknown> = Record<string, unknown>> {\n    config?: ConfigWithConfigurable<ContextType>;\n    context?: ContextType;\n    checkpoint?: Omit<Checkpoint, \"thread_id\"> | null;\n    command?: Command;\n    interruptBefore?: \"*\" | string[];\n    interruptAfter?: \"*\" | string[];\n    metadata?: Metadata;\n    multitaskStrategy?: MultitaskStrategy;\n    onCompletion?: OnCompletionBehavior;\n    onDisconnect?: DisconnectMode;\n    feedbackKeys?: string[];\n    streamMode?: Array<StreamMode>;\n    runId?: string;\n    optimisticValues?: Partial<StateType> | ((prev: StateType) => Partial<StateType>);\n    /**\n     * Whether or not to stream the nodes of any subgraphs called\n     * by the assistant.\n     * @default false\n     */\n    streamSubgraphs?: boolean;\n    /**\n     * Mark the stream as resumable. All events emitted during the run will be temporarily persisted\n     * in order to be re-emitted if the stream is re-joined.\n     * @default false\n     */\n    streamResumable?: boolean;\n    /**\n     * Whether to checkpoint during the run (or only at the end/interruption).\n     * - `\"async\"`: Save checkpoint asynchronously while the next step executes (default).\n     * - `\"sync\"`: Save checkpoint synchronously before the next step starts.\n     * - `\"exit\"`: Save checkpoint only when the graph exits.\n     * @default \"async\"\n     */\n    durability?: Durability;\n    /**\n     * The ID to use when creating a new thread. When provided, this ID will be used\n     * for thread creation when threadId is `null` or `undefined`.\n     * This enables optimistic UI updates where you know the thread ID\n     * before the thread is actually created.\n     */\n    threadId?: string;\n}\n/**\n * Transport used to stream the thread.\n * Only applicable for custom endpoints using `toLangGraphEventStream` or `toLangGraphEventStreamResponse`.\n */\nexport interface UseStreamTransport<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> {\n    stream: (payload: {\n        input: GetUpdateType<Bag, StateType> | null | undefined;\n        context: GetConfigurableType<Bag> | undefined;\n        command: Command | undefined;\n        config: ConfigWithConfigurable<GetConfigurableType<Bag>> | undefined;\n        signal: AbortSignal;\n    }) => Promise<AsyncGenerator<{\n        id?: string;\n        event: string;\n        data: unknown;\n    }>>;\n}\nexport type UseStreamCustomOptions<StateType extends Record<string, unknown> = Record<string, unknown>, Bag extends BagTemplate = BagTemplate> = Pick<UseStreamOptions<StateType, Bag>, \"messagesKey\" | \"threadId\" | \"onThreadId\" | \"onError\" | \"onCreated\" | \"onUpdateEvent\" | \"onCustomEvent\" | \"onMetadataEvent\" | \"onLangChainEvent\" | \"onDebugEvent\" | \"onCheckpointEvent\" | \"onTaskEvent\" | \"onStop\" | \"initialValues\" | \"throttle\"> & {\n    transport: UseStreamTransport<StateType, Bag>;\n};\nexport type CustomSubmitOptions<StateType extends Record<string, unknown> = Record<string, unknown>, ConfigurableType extends Record<string, unknown> = Record<string, unknown>> = Pick<SubmitOptions<StateType, ConfigurableType>, \"optimisticValues\" | \"context\" | \"command\" | \"config\">;\nexport {};\n"],"mappings":"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"}