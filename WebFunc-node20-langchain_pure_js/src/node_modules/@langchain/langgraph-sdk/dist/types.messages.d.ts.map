{"version":3,"file":"types.messages.d.ts","names":["ImageDetail","MessageContentImageUrl","MessageContentText","MessageContentComplex","MessageContent","MessageAdditionalKwargs","Record","BaseMessage","HumanMessage","DefaultToolCall","InvalidToolCall","UsageMetadata","AIMessage","ToolCall","ToolMessage","SystemMessage","FunctionMessage","RemoveMessage","Message","InferSchemaInput","S","Args","InferToolInput","T","ToolCallFromTool","N","ToolCallsFromTools","First","Rest","ToolCallState","ToolCallWithResult"],"sources":["../src/types.messages.d.ts"],"sourcesContent":["type ImageDetail = \"auto\" | \"low\" | \"high\";\ntype MessageContentImageUrl = {\n    type: \"image_url\";\n    image_url: string | {\n        url: string;\n        detail?: ImageDetail | undefined;\n    };\n};\ntype MessageContentText = {\n    type: \"text\";\n    text: string;\n};\ntype MessageContentComplex = MessageContentText | MessageContentImageUrl;\ntype MessageContent = string | MessageContentComplex[];\n/**\n * Model-specific additional kwargs, which is passed back to the underlying LLM.\n */\ntype MessageAdditionalKwargs = Record<string, unknown>;\ntype BaseMessage = {\n    additional_kwargs?: MessageAdditionalKwargs | undefined;\n    content: MessageContent;\n    id?: string | undefined;\n    name?: string | undefined;\n    response_metadata?: Record<string, unknown> | undefined;\n};\nexport type HumanMessage = BaseMessage & {\n    type: \"human\";\n    example?: boolean | undefined;\n};\n/**\n * Default tool call type when no specific tool definitions are provided.\n */\nexport type DefaultToolCall = {\n    name: string;\n    args: {\n        [x: string]: any;\n    };\n    id?: string | undefined;\n    type?: \"tool_call\" | undefined;\n};\n/**\n * Invalid tool call type.\n */\nexport type InvalidToolCall = {\n    name?: string | undefined;\n    args?: string | undefined;\n    id?: string | undefined;\n    error?: string | undefined;\n    type?: \"invalid_tool_call\" | undefined;\n};\n/**\n * Usage metadata for AI messages.\n */\nexport type UsageMetadata = {\n    input_tokens: number;\n    output_tokens: number;\n    total_tokens: number;\n    input_token_details?: {\n        audio?: number | undefined;\n        cache_read?: number | undefined;\n        cache_creation?: number | undefined;\n    } | undefined;\n    output_token_details?: {\n        audio?: number | undefined;\n        reasoning?: number | undefined;\n    } | undefined;\n};\n/**\n * AI message type that can be parameterized with custom tool call types.\n *\n * @template ToolCall The type of tool calls, defaults to DefaultToolCall.\n *                    Provide a discriminated union for type-safe tool call handling.\n *\n * @example\n * ```ts\n * // Define typed tool calls as a discriminated union\n * type MyToolCalls =\n *   | { name: \"get_weather\"; args: { location: string }; id?: string }\n *   | { name: \"search\"; args: { query: string; limit?: number }; id?: string };\n *\n * // Use with AIMessage\n * const message: AIMessage<MyToolCalls> = ...;\n *\n * // Now tool.name === \"get_weather\" narrows tool.args type\n * if (message.tool_calls) {\n *   for (const tool of message.tool_calls) {\n *     if (tool.name === \"get_weather\") {\n *       // tool.args is now { location: string }\n *       console.log(tool.args.location);\n *     }\n *   }\n * }\n * ```\n */\nexport type AIMessage<ToolCall = DefaultToolCall> = BaseMessage & {\n    type: \"ai\";\n    example?: boolean | undefined;\n    tool_calls?: ToolCall[] | undefined;\n    invalid_tool_calls?: InvalidToolCall[] | undefined;\n    usage_metadata?: UsageMetadata | undefined;\n};\nexport type ToolMessage = BaseMessage & {\n    type: \"tool\";\n    status?: \"error\" | \"success\" | undefined;\n    tool_call_id: string;\n    /**\n     * Artifact of the Tool execution which is not meant to be sent to the model.\n     *\n     * Should only be specified if it is different from the message content, e.g. if only\n     * a subset of the full tool output is being passed as message content but the full\n     * output is needed in other parts of the code.\n     */\n    artifact?: any;\n};\nexport type SystemMessage = BaseMessage & {\n    type: \"system\";\n};\nexport type FunctionMessage = BaseMessage & {\n    type: \"function\";\n};\nexport type RemoveMessage = BaseMessage & {\n    type: \"remove\";\n};\n/**\n * Union of all message types.\n *\n * @template ToolCall The type of tool calls for AIMessage, defaults to DefaultToolCall.\n */\nexport type Message<ToolCall = DefaultToolCall> = HumanMessage | AIMessage<ToolCall> | ToolMessage | SystemMessage | FunctionMessage | RemoveMessage;\n/**\n * Helper type to infer schema input type, supporting both Zod v3 and v4.\n * - Zod v4 uses `_zod.input` property\n * - Zod v3 uses `_input` property\n *\n * Note: Zod v4 is checked first as it's the more specific structure.\n */\ntype InferSchemaInput<S> = S extends {\n    _zod: {\n        input: infer Args;\n    };\n} ? Args : S extends {\n    _input: infer Args;\n} ? Args : never;\n/**\n * Helper type to extract the input type from a DynamicStructuredTool's _call method.\n * This is more reliable than trying to infer from the schema directly because\n * DynamicStructuredTool has the input type baked into its _call signature.\n */\ntype InferToolInput<T> = T extends {\n    _call: (arg: infer Args, ...rest: any[]) => any;\n} ? Args : T extends {\n    schema: infer S;\n} ? InferSchemaInput<S> : never;\n/**\n * Infer a tool call type from a single tool.\n * Works with tools created via `tool()` from `@langchain/core/tools`.\n *\n * For DynamicStructuredTool, this extracts the input type from the _call method,\n * which is the most reliable source as it's the pre-computed input type.\n *\n * @template T The tool type (e.g., DynamicStructuredTool)\n *\n * @example\n * ```ts\n * import { tool } from \"@langchain/core/tools\";\n * import { z } from \"zod\";\n *\n * const getWeather = tool(\n *   async ({ location }) => `Weather in ${location}`,\n *   { name: \"get_weather\", schema: z.object({ location: z.string() }) }\n * );\n *\n * // Infer: { name: \"get_weather\"; args: { location: string }; id?: string; type?: \"tool_call\" }\n * type WeatherToolCall = ToolCallFromTool<typeof getWeather>;\n * ```\n */\nexport type ToolCallFromTool<T> = T extends {\n    name: infer N;\n} ? InferToolInput<T> extends infer Args ? Args extends never ? never : Args extends Record<string, any> ? {\n    name: N;\n    args: Args;\n    id?: string;\n    type?: \"tool_call\";\n} : never : never : never;\n/**\n * Infer a union of tool call types from an array of tools.\n * Works with tools created via `tool()` from `@langchain/core/tools`.\n *\n * @template T A tuple/array of tools\n *\n * @example\n * ```ts\n * import { tool } from \"@langchain/core/tools\";\n * import { z } from \"zod\";\n *\n * const getWeather = tool(\n *   async ({ location }) => `Weather in ${location}`,\n *   { name: \"get_weather\", schema: z.object({ location: z.string() }) }\n * );\n *\n * const search = tool(\n *   async ({ query }) => `Results for ${query}`,\n *   { name: \"search\", schema: z.object({ query: z.string() }) }\n * );\n *\n * const tools = [getWeather, search] as const;\n *\n * // Infer union:\n * // | { name: \"get_weather\"; args: { location: string }; id?: string; type?: \"tool_call\" }\n * // | { name: \"search\"; args: { query: string }; id?: string; type?: \"tool_call\" }\n * type MyToolCalls = ToolCallsFromTools<typeof tools>;\n * ```\n */\nexport type ToolCallsFromTools<T extends readonly unknown[]> = T extends readonly [infer First, ...infer Rest] ? ToolCallFromTool<First> | ToolCallsFromTools<Rest> : never;\n/**\n * The lifecycle state of a tool call.\n *\n * - `pending`: Tool call received, awaiting result\n * - `completed`: Tool execution finished successfully\n * - `error`: Tool execution failed (result.status === \"error\")\n */\nexport type ToolCallState = \"pending\" | \"completed\" | \"error\";\n/**\n * Represents a tool call paired with its result.\n * Useful for rendering tool invocations and their outputs together.\n *\n * @template ToolCall The type of the tool call.\n */\nexport type ToolCallWithResult<ToolCall = DefaultToolCall> = {\n    /**\n     * Unique identifier for this tool call.\n     * Uses the tool call's id if available, otherwise generates one from aiMessage.id and index.\n     */\n    id: string;\n    /**\n     * The tool call from the AI message.\n     */\n    call: ToolCall;\n    /**\n     * The result message from tool execution.\n     * `undefined` if the tool is still being executed or no result was received.\n     */\n    result: ToolMessage | undefined;\n    /**\n     * The AI message that initiated this tool call.\n     */\n    aiMessage: AIMessage<ToolCall>;\n    /**\n     * Index of this tool call within the AI message's tool_calls array.\n     */\n    index: number;\n    /**\n     * The current lifecycle state of the tool call.\n     *\n     * - `pending`: No result yet\n     * - `completed`: Has result with success status\n     * - `error`: Has result with error status\n     */\n    state: ToolCallState;\n};\nexport {};\n"],"mappings":"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"}