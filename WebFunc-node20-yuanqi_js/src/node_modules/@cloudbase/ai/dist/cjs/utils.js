"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.functionToolToModelTool = exports.isToolCallAssistantMessage = exports.createPromise = exports.readableStream2JsonObject = exports.intoTextStream = exports.intoStandardStream = exports.createAsyncIterable = exports.TextDecoderStream = exports.toPolyfillReadable = exports.createEventSourceParserTransformStream = exports.TransformStream = exports.ReadableStream = void 0;
var web_streams_polyfill_1 = require("web-streams-polyfill");
var web_streams_adapter_1 = require("@mattiasbuelens/web-streams-adapter");
var eventsource_parser_1 = require("./eventsource_parser");
var text_encoding_shim_1 = require("text-encoding-shim");
exports.ReadableStream = web_streams_polyfill_1.ReadableStream;
exports.TransformStream = web_streams_polyfill_1.TransformStream;
var createEventSourceParserTransformStream = function () {
    var parser;
    return new exports.TransformStream({
        start: function (controller) {
            parser = (0, eventsource_parser_1.createParser)(function (event) {
                if (event.type === 'event') {
                    controller.enqueue(event);
                }
            });
        },
        transform: function (chunk) {
            parser.feed(chunk);
        },
    });
};
exports.createEventSourceParserTransformStream = createEventSourceParserTransformStream;
exports.toPolyfillReadable = (0, web_streams_adapter_1.createReadableStreamWrapper)(exports.ReadableStream);
var TextDecoderStream = (function () {
    function TextDecoderStream(encoding, options) {
        if (encoding === void 0) { encoding = 'utf-8'; }
        if (options === void 0) { options = {}; }
        var _this = this;
        this.transform = new exports.TransformStream({
            transform: function (chunk, controller) {
                var value = _this.handle.decode(new Uint8Array(chunk), { stream: true });
                if (value) {
                    controller.enqueue(value);
                }
            },
            flush: function (controller) {
                var value = _this.handle.decode();
                if (value) {
                    controller.enqueue(value);
                }
                controller.terminate();
            },
        });
        this.handle = new text_encoding_shim_1.TextDecoder(encoding, options);
    }
    Object.defineProperty(TextDecoderStream.prototype, "encoding", {
        get: function () {
            return this.handle.encoding;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextDecoderStream.prototype, "fatal", {
        get: function () {
            return this.handle.fatal;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextDecoderStream.prototype, "ignoreBOM", {
        get: function () {
            return this.handle.ignoreBOM;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextDecoderStream.prototype, "readable", {
        get: function () {
            return this.transform.readable;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextDecoderStream.prototype, "writable", {
        get: function () {
            return this.transform.writable;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TextDecoderStream.prototype, Symbol.toStringTag, {
        get: function () {
            return 'TextDecoderStream';
        },
        enumerable: false,
        configurable: true
    });
    return TextDecoderStream;
}());
exports.TextDecoderStream = TextDecoderStream;
function createAsyncIterable(stream) {
    var _stream = stream;
    _stream[Symbol.asyncIterator] = function () {
        var reader = stream.getReader();
        return {
            next: function () {
                return __awaiter(this, void 0, void 0, function () {
                    var _a, done, value;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0: return [4, reader.read()];
                            case 1:
                                _a = _b.sent(), done = _a.done, value = _a.value;
                                return [2, done ? { done: true, value: undefined } : { done: false, value: value }];
                        }
                    });
                });
            },
        };
    };
    return _stream;
}
exports.createAsyncIterable = createAsyncIterable;
function intoStandardStream(stream) {
    return createAsyncIterable(stream
        .pipeThrough(new TextDecoderStream())
        .pipeThrough((0, exports.createEventSourceParserTransformStream)())
        .pipeThrough(new exports.TransformStream({
        transform: function (chunk, controller) {
            try {
                var data = JSON.parse(chunk.data);
                controller.enqueue(data);
            }
            catch (e) {
                if (chunk.data !== '[DONE]') {
                    console.warn('Error when transforming event source data to json', e, chunk);
                }
                else {
                    controller.terminate();
                }
            }
        },
    })));
}
exports.intoStandardStream = intoStandardStream;
function intoTextStream(stream) {
    return createAsyncIterable((0, exports.toPolyfillReadable)(stream).pipeThrough(new TextDecoderStream()));
}
exports.intoTextStream = intoTextStream;
function readableStream2JsonObject(stream) {
    var _a, e_1, _b, _c;
    return __awaiter(this, void 0, void 0, function () {
        var s, total, _d, s_1, s_1_1, chunk, e_1_1;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    s = intoTextStream(stream);
                    total = '';
                    _e.label = 1;
                case 1:
                    _e.trys.push([1, 6, 7, 12]);
                    _d = true, s_1 = __asyncValues(s);
                    _e.label = 2;
                case 2: return [4, s_1.next()];
                case 3:
                    if (!(s_1_1 = _e.sent(), _a = s_1_1.done, !_a)) return [3, 5];
                    _c = s_1_1.value;
                    _d = false;
                    try {
                        chunk = _c;
                        total += chunk;
                    }
                    finally {
                        _d = true;
                    }
                    _e.label = 4;
                case 4: return [3, 2];
                case 5: return [3, 12];
                case 6:
                    e_1_1 = _e.sent();
                    e_1 = { error: e_1_1 };
                    return [3, 12];
                case 7:
                    _e.trys.push([7, , 10, 11]);
                    if (!(!_d && !_a && (_b = s_1.return))) return [3, 9];
                    return [4, _b.call(s_1)];
                case 8:
                    _e.sent();
                    _e.label = 9;
                case 9: return [3, 11];
                case 10:
                    if (e_1) throw e_1.error;
                    return [7];
                case 11: return [7];
                case 12: return [2, JSON.parse(total)];
            }
        });
    });
}
exports.readableStream2JsonObject = readableStream2JsonObject;
function createPromise() {
    var res;
    var rej;
    var promise = new Promise(function (resolve, reject) {
        res = resolve;
        rej = reject;
    });
    return { promise: promise, res: res, rej: rej };
}
exports.createPromise = createPromise;
function isToolCallAssistantMessage(message) {
    var _a;
    return message.role === 'assistant' && 'tool_calls' in message && ((_a = message.tool_calls) === null || _a === void 0 ? void 0 : _a[0]) != null;
}
exports.isToolCallAssistantMessage = isToolCallAssistantMessage;
function functionToolToModelTool(tool) {
    return {
        type: 'function',
        function: {
            description: tool.description,
            name: tool.name,
            parameters: tool.parameters,
        },
    };
}
exports.functionToolToModelTool = functionToolToModelTool;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZEQUE2RztBQUM3RywyRUFBaUY7QUFDakYsMkRBQTZGO0FBUTdGLHlEQUFnRDtBQUVuQyxRQUFBLGNBQWMsR0FBRyxxQ0FXN0IsQ0FBQTtBQUVZLFFBQUEsZUFBZSxHQUFHLHNDQVE5QixDQUFBO0FBRU0sSUFBTSxzQ0FBc0MsR0FBRztJQUNwRCxJQUFJLE1BQTBCLENBQUE7SUFFOUIsT0FBTyxJQUFJLHVCQUFlLENBQXNCO1FBQzlDLEtBQUssWUFBQyxVQUFVO1lBQ2QsTUFBTSxHQUFHLElBQUEsaUNBQVksRUFBQyxVQUFDLEtBQUs7Z0JBQzFCLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxPQUFPLEVBQUU7b0JBQzFCLFVBQVUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUE7aUJBQzFCO1lBQ0gsQ0FBQyxDQUFDLENBQUE7UUFDSixDQUFDO1FBQ0QsU0FBUyxZQUFDLEtBQUs7WUFDYixNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFBO1FBQ3BCLENBQUM7S0FDRixDQUFDLENBQUE7QUFDSixDQUFDLENBQUE7QUFmWSxRQUFBLHNDQUFzQywwQ0FlbEQ7QUFFWSxRQUFBLGtCQUFrQixHQUFHLElBQUEsaURBQTJCLEVBQUMsc0JBQWMsQ0FBQyxDQUFBO0FBRTdFO0lBcUJFLDJCQUFZLFFBQWtCLEVBQUUsT0FBZ0M7UUFBcEQseUJBQUEsRUFBQSxrQkFBa0I7UUFBRSx3QkFBQSxFQUFBLFlBQWdDO1FBQWhFLGlCQUVDO1FBcEJPLGNBQVMsR0FBRyxJQUFJLHVCQUFlLENBQUM7WUFDdEMsU0FBUyxFQUFFLFVBQUMsS0FBSyxFQUFFLFVBQVU7Z0JBQzNCLElBQU0sS0FBSyxHQUFHLEtBQUksQ0FBQyxNQUFNLENB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QUE7QUFDOUIsQ0FBQztBQVJELHNDQVFDO0FBRUQsU0FBZ0IsMEJBQTBCLENBQUMsT0FBeUI7O0lBRWxFLE9BQU8sT0FBTyxDQUFDLElBQUksS0FBSyxXQUFXLElBQUksWUFBWSxJQUFJLE9BQU8sSUFBSSxDQUFBLE1BQUEsT0FBTyxDQUFDLFVBQVUsMENBQUcsQ0FBQyxDQUFDLEtBQUksSUFBSSxDQUFBO0FBQ25HLENBQUM7QUFIRCxnRUFHQztBQUVELFNBQWdCLHVCQUF1QixDQUFDLElBQWtCO0lBQ3hELE9BQU87UUFDTCxJQUFJLEVBQUUsVUFBVTtRQUNoQixRQUFRLEVBQUU7WUFDUixXQUFXLEVBQUUsSUFBSSxDQUFDLFdBQVc7WUFDN0IsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsVUFBVSxFQUFFLElBQUksQ0FBQyxVQUFVO1NBQzVCO0tBQ0YsQ0FBQTtBQUNILENBQUM7QUFURCwwREFTQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRyYW5zZm9ybVN0cmVhbSBhcyBfVHJhbnNmb3JtU3RyZWFtLCBSZWFkYWJsZVN0cmVhbSBhcyBfUmVhZGFibGVTdHJlYW0gfSBmcm9tICd3ZWItc3RyZWFtcy1wb2x5ZmlsbCdcbmltcG9ydCB7IGNyZWF0ZVJlYWRhYmxlU3RyZWFtV3JhcHBlciB9IGZyb20gJ0BtYXR0aWFzYnVlbGVucy93ZWItc3RyZWFtcy1hZGFwdGVyJ1xuaW1wb3J0IHsgY3JlYXRlUGFyc2VyLCB0eXBlIEV2ZW50U291cmNlUGFyc2VyLCB0eXBlIFBhcnNlZEV2ZW50IH0gZnJvbSAnLi9ldmVudHNvdXJjZV9wYXJzZXInXG5pbXBvcnQgdHlwZSB7XG4gIEFzeW5jSXRlcmFibGVSZWFkYWJsZVN0cmVhbSxcbiAgQ2hhdE1vZGVsTWVzc2FnZSxcbiAgVG9vbENhbGxBc3Npc3RhbnRNZXNzYWdlLFxuICBNb2RlbFRvb2wsXG4gIEZ1bmN0aW9uVG9vbCxcbn0gZnJvbSAnLi90eXBlJ1xuaW1wb3J0IHsgVGV4dERlY29kZXIgfSBmcm9tICd0ZXh0LWVuY29kaW5nLXNoaW0nXG5cbmV4cG9ydCBjb25zdCBSZWFkYWJsZVN0cmVhbSA9IF9SZWFkYWJsZVN0cmVhbSBhcyB7XG4gIHByb3RvdHlwZTogUmVhZGFibGVTdHJlYW1cblxuICBuZXcgKFxuICAgIHVuZGVybHlpbmdTb3VyY2U6IFVuZGVybHlpbmdCeXRlU291cmNlLFxuICAgIHN0cmF0ZWd5Pzoge1xuICAgICAgaGlnaFdhdGVyTWFyaz86IG51bWJlclxuICAgIH0sXG4gICk6IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+XG4gIG5ldyA8UiA9IGFueT4odW5kZXJseWluZ1NvdXJjZTogVW5kZXJseWluZ0RlZmF1bHRTb3VyY2U8Uj4sIHN0cmF0ZWd5PzogUXVldWluZ1N0cmF0ZWd5PFI+KTogUmVhZGFibGVTdHJlYW08Uj5cbiAgbmV3IDxSID0gYW55Pih1bmRlcmx5aW5nU291cmNlPzogVW5kZXJseWluZ1NvdXJjZTxSPiwgc3RyYXRlZ3k/OiBRdWV1aW5nU3RyYXRlZ3k8Uj4pOiBSZWFkYWJsZVN0cmVhbTxSPlxufVxuXG5leHBvcnQgY29uc3QgVHJhbnNmb3JtU3RyZWFtID0gX1RyYW5zZm9ybVN0cmVhbSBhcyB7XG4gIHByb3RvdHlwZTogVHJhbnNmb3JtU3RyZWFtXG5cbiAgbmV3IDxJID0gYW55LCBPID0gYW55PihcbiAgICB0cmFuc2Zvcm1lcj86IFRyYW5zZm9ybWVyPEksIE8+LFxuICAgIHdyaXRhYmxlU3RyYXRlZ3k/OiBRdWV1aW5nU3RyYXRlZ3k8ST4sXG4gICAgcmVhZGFibGVTdHJhdGVneT86IFF1ZXVpbmdTdHJhdGVneTxPPixcbiAgKTogVHJhbnNmb3JtU3RyZWFtPEksIE8+XG59XG5cbmV4cG9ydCBjb25zdCBjcmVhdGVFdmVudFNvdXJjZVBhcnNlclRyYW5zZm9ybVN0cmVhbSA9ICgpID0+IHtcbiAgbGV0IHBhcnNlciE6IEV2ZW50U291cmNlUGFyc2VyXG5cbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW08c3RyaW5nLCBQYXJzZWRFdmVudD4oe1xuICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHBhcnNlciA9IGNyZWF0ZVBhcnNlcigoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnR5cGUgPT09ICdldmVudCcpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZXZlbnQpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfSxcbiAgICB0cmFuc2Zvcm0oY2h1bmspIHtcbiAgICAgIHBhcnNlci5mZWVkKGNodW5rKVxuICAgIH0sXG4gIH0pXG59XG5cbmV4cG9ydCBjb25zdCB0b1BvbHlmaWxsUmVhZGFibGUgPSBjcmVhdGVSZWFkYWJsZVN0cmVhbVdyYXBwZXIoUmVhZGFibGVTdHJlYW0pXG5cbmV4cG9ydCBjbGFzcyBUZXh0RGVjb2RlclN0cmVhbSB7XG4gIHByaXZhdGUgaGFuZGxlOiBUZXh0RGVjb2RlclxuXG4gIHByaXZhdGUgdHJhbnNmb3JtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgdHJhbnNmb3JtOiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5oYW5kbGUuZGVjb2RlKG5ldyBVaW50OEFycmF5KGNodW5rKSwgeyBzdHJlYW06IHRydWUgfSlcblxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSlcbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoOiAoY29udHJvbGxlcikgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmhhbmRsZS5kZWNvZGUoKVxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSlcbiAgICAgIH1cblxuICAgICAgY29udHJvbGxlci50ZXJtaW5hdGUoKVxuICAgIH0sXG4gIH0pXG5cbiAgY29uc3RydWN0b3IoZW5jb2RpbmcgPSAndXRmLTgnLCBvcHRpb25zOiBUZXh0RGVjb2Rlck9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuaGFuZGxlID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCBvcHRpb25zKVxuICB9XG5cbiAgZ2V0IGVuY29kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZS5lbmNvZGluZ1xuICB9XG5cbiAgZ2V0IGZhdGFsKCkge1xuICAgIHJldHVybiB0aGlzLmhhbmRsZS5mYXRhbFxuICB9XG5cbiAgZ2V0IGlnbm9yZUJPTSgpIHtcbiAgICByZXR1cm4gdGhpcy5oYW5kbGUuaWdub3JlQk9NXG4gIH1cblxuICBnZXQgcmVhZGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLnJlYWRhYmxlXG4gIH1cblxuICBnZXQgd3JpdGFibGUoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtLndyaXRhYmxlXG4gIH1cblxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuICdUZXh0RGVjb2RlclN0cmVhbSdcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQXN5bmNJdGVyYWJsZTxUPihzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFQ+KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgY29uc3QgX3N0cmVhbSA9IHN0cmVhbSBhcyBBc3luY0l0ZXJhYmxlUmVhZGFibGVTdHJlYW08VD5cbiAgKF9zdHJlYW0gYXMgYW55KVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSAoKSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpXG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIG5leHQoKTogUHJvbWlzZTxJdGVyYXRvclJlc3VsdDxUPj4ge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpXG4gICAgICAgIHJldHVybiBkb25lID8geyBkb25lOiB0cnVlLCB2YWx1ZTogdW5kZWZpbmVkIH0gOiB7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9XG4gICAgICB9LFxuICAgIH1cbiAgfVxuICByZXR1cm4gX3N0cmVhbVxufVxuXG4vKipcbiAqIOWwhiBTU0Ug5LqM6L+b5Yi25rWB6L2s5o2i5Li6IFQg57G75Z6L55qE5rWBXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRvU3RhbmRhcmRTdHJlYW08VD4oc3RyZWFtOiBSZWFkYWJsZVN0cmVhbTxVaW50OEFycmF5Pik6IFJlYWRhYmxlU3RyZWFtPFQ+IHtcbiAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGUoc3RyZWFtXG4gICAgLnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKVxuICAgIC5waXBlVGhyb3VnaChjcmVhdGVFdmVudFNvdXJjZVBhcnNlclRyYW5zZm9ybVN0cmVhbSgpKVxuICAgIC5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtPFBhcnNlZEV2ZW50LCBUPih7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShjaHVuay5kYXRhKSBhcyBUXG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGRhdGEpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoY2h1bmsuZGF0YSAhPT0gJ1tET05FXScpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignRXJyb3Igd2hlbiB0cmFuc2Zvcm1pbmcgZXZlbnQgc291cmNlIGRhdGEgdG8ganNvbicsIGUsIGNodW5rKVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnRlcm1pbmF0ZSgpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pLCksKVxufVxuXG4vKipcbiAqIOWwhiBTU0Ug5LqM6L+b5Yi25rWB6L2s5o2i5Li65a2X56ym5Liy5rWBXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpbnRvVGV4dFN0cmVhbShzdHJlYW06IFJlYWRhYmxlU3RyZWFtPFVpbnQ4QXJyYXk+KTogQXN5bmNJdGVyYWJsZVJlYWRhYmxlU3RyZWFtPHN0cmluZz4ge1xuICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZSgodG9Qb2x5ZmlsbFJlYWRhYmxlKHN0cmVhbSkgYXMgdHlwZW9mIHN0cmVhbSkucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpKVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gcmVhZGFibGVTdHJlYW0ySnNvbk9iamVjdChzdHJlYW06IFJlYWRhYmxlU3RyZWFtKSB7XG4gIGNvbnN0IHMgPSBpbnRvVGV4dFN0cmVhbShzdHJlYW0pXG4gIGxldCB0b3RhbCA9ICcnXG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2Ygcykge1xuICAgIHRvdGFsICs9IGNodW5rXG4gIH1cbiAgcmV0dXJuIEpTT04ucGFyc2UodG90YWwpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQcm9taXNlPFQgPSB1bmtub3duPigpIHtcbiAgbGV0IHJlczogKHZhbHVlOiBUIHwgUHJvbWlzZUxpa2U8VD4pID0+IHZvaWRcbiAgbGV0IHJlajogKHJlYXNvbj86IGFueSkgPT4gdm9pZFxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2U8VD4oKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHJlcyA9IHJlc29sdmVcbiAgICByZWogPSByZWplY3RcbiAgfSlcbiAgcmV0dXJuIHsgcHJvbWlzZSwgcmVzLCByZWogfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUb29sQ2FsbEFzc2lzdGFudE1lc3NhZ2UobWVzc2FnZTogQ2hhdE1vZGVsTWVzc2FnZSk6IG1lc3NhZ2UgaXMgVG9vbENhbGxBc3Npc3RhbnRNZXNzYWdlIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICByZXR1cm4gbWVzc2FnZS5yb2xlID09PSAnYXNzaXN0YW50JyAmJiAndG9vbF9jYWxscycgaW4gbWVzc2FnZSAmJiBtZXNzYWdlLnRvb2xfY2FsbHM/LlswXSAhPSBudWxsXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmdW5jdGlvblRvb2xUb01vZGVsVG9vbCh0b29sOiBGdW5jdGlvblRvb2wpOiBNb2RlbFRvb2wge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdmdW5jdGlvbicsXG4gICAgZnVuY3Rpb246IHtcbiAgICAgIGRlc2NyaXB0aW9uOiB0b29sLmRlc2NyaXB0aW9uLFxuICAgICAgbmFtZTogdG9vbC5uYW1lLFxuICAgICAgcGFyYW1ldGVyczogdG9vbC5wYXJhbWV0ZXJzLFxuICAgIH0sXG4gIH1cbn1cbiJdfQ==