{"version":3,"file":"responses.d.cts","names":["InteropZodObject","InteropZodType","AIMessage","LanguageModelLike","FunctionDefinition","StructuredOutputParsingError","MultipleStructuredOutputsError","ResponseFormatUndefined","ToolStrategy","S","_T","Record","ToolStrategyOptions","U","ProviderStrategy","T","ResponseFormat","transformResponseFormat","JsonSchemaFormat","TypedToolStrategy","Array","ToolStrategyError","Promise","toolStrategy","K","providerStrategy","hasSupportForJsonSchemaOutput"],"sources":["../../src/agents/responses.d.ts"],"sourcesContent":["import { InteropZodObject, InteropZodType } from \"@langchain/core/utils/types\";\nimport { type AIMessage } from \"@langchain/core/messages\";\nimport { type LanguageModelLike } from \"@langchain/core/language_models/base\";\nimport { type FunctionDefinition } from \"@langchain/core/language_models/base\";\nimport { StructuredOutputParsingError, MultipleStructuredOutputsError } from \"./errors.js\";\n/**\n * Special type to indicate that no response format is provided.\n * When this type is used, the structuredResponse property should not be present in the result.\n */\nexport type ResponseFormatUndefined = {\n    __responseFormatUndefined: true;\n};\n/**\n * Information for tracking structured output tool metadata.\n * This contains all necessary information to handle structured responses generated\n * via tool calls, including the original schema, its type classification, and the\n * corresponding tool implementation used by the tools strategy.\n */\nexport declare class ToolStrategy<_T = unknown> {\n    readonly schema: Record<string, unknown>;\n    readonly tool: {\n        type: \"function\";\n        function: FunctionDefinition;\n    };\n    readonly options?: ToolStrategyOptions | undefined;\n    private constructor();\n    get name(): string;\n    static fromSchema<S extends InteropZodObject>(schema: S, outputOptions?: ToolStrategyOptions): ToolStrategy<S extends InteropZodType<infer U> ? U : unknown>;\n    static fromSchema(schema: Record<string, unknown>, outputOptions?: ToolStrategyOptions): ToolStrategy<Record<string, unknown>>;\n    /**\n     * Parse tool arguments according to the schema.\n     *\n     * @throws {StructuredOutputParsingError} if the response is not valid\n     * @param toolArgs - The arguments from the tool call\n     * @returns The parsed response according to the schema type\n     */\n    parse(toolArgs: Record<string, unknown>): Record<string, unknown>;\n}\nexport declare class ProviderStrategy<T = unknown> {\n    private _schemaType?;\n    /**\n     * The schema to use for the provider strategy\n     */\n    readonly schema: Record<string, unknown>;\n    /**\n     * Whether to use strict mode for the provider strategy\n     */\n    readonly strict: boolean;\n    private constructor();\n    private constructor();\n    static fromSchema<T>(schema: InteropZodType<T>, strict?: boolean): ProviderStrategy<T>;\n    static fromSchema(schema: Record<string, unknown>, strict?: boolean): ProviderStrategy<Record<string, unknown>>;\n    /**\n     * Parse tool arguments according to the schema. If the response is not valid, return undefined.\n     *\n     * @param response - The AI message response to parse\n     * @returns The parsed response according to the schema type\n     */\n    parse(response: AIMessage): any;\n}\nexport type ResponseFormat = ToolStrategy<any> | ProviderStrategy<any>;\n/**\n * Handle user input for `responseFormat` parameter of `CreateAgentParams`.\n * This function defines the default behavior for the `responseFormat` parameter, which is:\n *\n * - if value is a Zod schema, default to structured output via tool calling\n * - if value is a JSON schema, default to structured output via tool calling\n * - if value is a custom response format, return it as is\n * - if value is an array, ensure all array elements are instance of `ToolStrategy`\n * @param responseFormat - The response format to transform, provided by the user\n * @param options - The response format options for tool strategy\n * @param model - The model to check if it supports JSON schema output\n * @returns\n */\nexport declare function transformResponseFormat(responseFormat?: InteropZodType<any> | InteropZodType<any>[] | JsonSchemaFormat | JsonSchemaFormat[] | ResponseFormat | ToolStrategy<any>[] | ResponseFormatUndefined, options?: ToolStrategyOptions, model?: LanguageModelLike | string): ResponseFormat[];\n/**\n * Branded type for ToolStrategy arrays that preserves type information\n */\nexport interface TypedToolStrategy<T = unknown> extends Array<ToolStrategy<any>> {\n    _schemaType?: T;\n}\nexport type ToolStrategyError = StructuredOutputParsingError | MultipleStructuredOutputsError;\nexport interface ToolStrategyOptions {\n    /**\n     * Allows you to customize the message that appears in the conversation history when structured\n     * output is generated.\n     */\n    toolMessageContent?: string;\n    /**\n     * Handle errors from the structured output tool call. Using tools to generate structured output\n     * can cause errors, e.g. if:\n     * - you provide multiple structured output schemas and the model calls multiple structured output tools\n     * - if the structured output generated by the tool call doesn't match provided schema\n     *\n     * This property allows to handle these errors in different ways:\n     * - `true` - retry the tool call\n     * - `false` - throw an error\n     * - `string` - retry the tool call with the provided message\n     * - `(error: ToolStrategyError) => Promise<string> | string` - retry with the provided message or throw the error\n     *\n     * @default true\n     */\n    handleError?: boolean | string | ((error: ToolStrategyError) => Promise<string> | string);\n}\nexport declare function toolStrategy<T extends InteropZodType<any>>(responseFormat: T, options?: ToolStrategyOptions): TypedToolStrategy<T extends InteropZodType<infer U> ? U : never>;\nexport declare function toolStrategy<T extends readonly InteropZodType<any>[]>(responseFormat: T, options?: ToolStrategyOptions): TypedToolStrategy<{\n    [K in keyof T]: T[K] extends InteropZodType<infer U> ? U : never;\n}[number]>;\nexport declare function toolStrategy(responseFormat: JsonSchemaFormat, options?: ToolStrategyOptions): TypedToolStrategy<Record<string, unknown>>;\nexport declare function toolStrategy(responseFormat: JsonSchemaFormat[], options?: ToolStrategyOptions): TypedToolStrategy<Record<string, unknown>>;\n/**\n * Creates a provider strategy for structured output using native JSON schema support.\n *\n * This function is used to configure structured output for agents when the underlying model\n * supports native JSON schema output (e.g., OpenAI's `gpt-4o`, `gpt-4o-mini`, and newer models).\n * Unlike `toolStrategy`, which uses function calling to extract structured output, `providerStrategy`\n * leverages the provider's native structured output capabilities, resulting in more efficient\n * and reliable schema enforcement.\n *\n * When used with a model that supports JSON schema output, the model will return responses\n * that directly conform to the provided schema without requiring tool calls. This is the\n * recommended approach for structured output when your model supports it.\n *\n * @param responseFormat - The schema to enforce, either a Zod schema, a JSON schema object, or an options object with `schema` and optional `strict` flag\n * @returns A `ProviderStrategy` instance that can be used as the `responseFormat` in `createAgent`\n *\n * @example\n * ```ts\n * import { providerStrategy, createAgent } from \"langchain\";\n * import { z } from \"zod\";\n *\n * const agent = createAgent({\n *   model: \"claude-haiku-4-5\",\n *   responseFormat: providerStrategy(\n *     z.object({\n *       answer: z.string().describe(\"The answer to the question\"),\n *       confidence: z.number().min(0).max(1),\n *     })\n *   ),\n * });\n * ```\n *\n * @example\n * ```ts\n * // Using strict mode for stricter schema enforcement\n * const agent = createAgent({\n *   model: \"claude-haiku-4-5\",\n *   responseFormat: providerStrategy({\n *     schema: z.object({\n *       name: z.string(),\n *       age: z.number(),\n *     }),\n *     strict: true\n *   }),\n * });\n * ```\n */\nexport declare function providerStrategy<T extends InteropZodType<unknown>>(responseFormat: T | {\n    schema: T;\n    strict?: boolean;\n}): ProviderStrategy<T extends InteropZodType<infer U> ? U : never>;\nexport declare function providerStrategy(responseFormat: JsonSchemaFormat | {\n    schema: JsonSchemaFormat;\n    strict?: boolean;\n}): ProviderStrategy<Record<string, unknown>>;\n/**\n * Type representing a JSON Schema object format.\n * This is a strict type that excludes ToolStrategy and ProviderStrategy instances.\n */\nexport type JsonSchemaFormat = {\n    type: \"null\" | \"boolean\" | \"object\" | \"array\" | \"number\" | \"string\" | \"integer\";\n    properties?: Record<string, unknown>;\n    required?: string[];\n    additionalProperties?: boolean;\n    [key: string]: unknown;\n} & {\n    __brand?: never;\n};\n/**\n * Identifies the models that support JSON schema output\n * @param model - The model to check\n * @returns True if the model supports JSON schema output, false otherwise\n */\nexport declare function hasSupportForJsonSchemaOutput(model?: LanguageModelLike | string): boolean;\n//# sourceMappingURL=responses.d.ts.map"],"mappings":"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"}