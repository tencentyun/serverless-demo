"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getCompleteTimeRange = exports.formatTimeByMs = exports.formatTimeValue = exports.guid6 = void 0;
exports.compressToZip = compressToZip;
exports.shouldSkipEntry = shouldSkipEntry;
exports.downloadAndExtractRemoteZip = downloadAndExtractRemoteZip;
exports.upload = upload;
exports.getRuntime = getRuntime;
exports.getEnvVar = getEnvVar;
exports.rsaEncrypt = rsaEncrypt;
exports.sleep = sleep;
exports.upperCaseStringFisrt = upperCaseStringFisrt;
exports.upperCaseObjKey = upperCaseObjKey;
exports.fetchTemplates = fetchTemplates;
exports.successLog = successLog;
const archiver_1 = __importDefault(require("archiver"));
const crypto_1 = __importDefault(require("crypto"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const lodash_1 = __importDefault(require("lodash"));
const path_1 = __importDefault(require("path"));
const unzipper_1 = __importDefault(require("unzipper"));
const constant_1 = require("../constant");
const http_request_1 = require("./http-request");
__exportStar(require("./auth"), exports);
__exportStar(require("./cloud-api-request"), exports);
__exportStar(require("./cloudbase-request"), exports);
__exportStar(require("./envLazy"), exports);
__exportStar(require("./fs"), exports);
__exportStar(require("./http-request"), exports);
var uuid_1 = require("./uuid");
Object.defineProperty(exports, "guid6", { enumerable: true, get: function () { return uuid_1.guid6; } });
async function compressToZip(option) {
    const { dirPath, outputPath, ignore, pattern = '**/*' } = option;
    return new Promise((resolve, reject) => {
        const output = fs_extra_1.default.createWriteStream(outputPath);
        const archive = (0, archiver_1.default)('zip');
        output.on('close', function () {
            resolve({
                zipPath: outputPath,
                size: Math.ceil(archive.pointer() / 1024)
            });
        });
        archive.on('error', function (err) {
            reject(err);
        });
        archive.pipe(output);
        // append files from a glob pattern
        archive.glob(pattern, {
            // 目标路径
            cwd: dirPath,
            ignore: ignore,
            dot: true
        });
        archive.finalize();
    });
}
/**
     * 检查是否应该跳过某个文件或文件夹
     * @param {string} entryPath 文件路径
     * @returns {boolean} 如果应该跳过则返回 true
     */
function shouldSkipEntry(entryPath) {
    const normalizedPath = entryPath.replace(/\\/g, '/'); // 统一路径分隔符
    // 过滤 macOS 系统文件和文件夹
    const macOSPatterns = [
        '__MACOSX', // macOS 资源文件夹
        '.DS_Store', // macOS 文件夹设置文件
    ];
    // 检查是否匹配任何需要跳过的模式
    return macOSPatterns.some(pattern => {
        // 检查路径是否以模式开头（用于文件夹）
        if (normalizedPath.startsWith(pattern + '/') || normalizedPath === pattern) {
            return true;
        }
        // 检查路径中是否包含这些模式（用于嵌套情况）
        if (normalizedPath.includes('/' + pattern + '/') || normalizedPath.includes('/' + pattern)) {
            return true;
        }
        // 检查文件名是否匹配模式
        const fileName = path_1.default.basename(normalizedPath);
        if (fileName === pattern) {
            return true;
        }
        // 检查以 ._ 开头的 macOS 资源文件
        if (fileName.startsWith('._')) {
            return true;
        }
        return false;
    });
}
/**
 * 下载并解压压缩包到指定目录
 * @param {string} downloadUrl 压缩包下载地址
 * @param {string} targetPath 目标路径
 * @returns {Promise<void>}
 * @throws 当下载失败或解压失败时抛出错误
 */
async function downloadAndExtractRemoteZip(downloadUrl, targetPath) {
    const downloadResponse = await (0, http_request_1.fetchStream)(downloadUrl);
    if (!downloadResponse.ok) {
        throw new Error(`下载失败，状态码: ${downloadResponse.status}`);
    }
    if (!downloadResponse.body) {
        throw new Error('下载响应中没有数据流');
    }
    // 创建目标目录
    const dirPath = path_1.default.resolve(targetPath);
    await fs_extra_1.default.ensureDir(dirPath);
    // 使用流式解压，避免大文件内存问题
    await new Promise((resolve, reject) => {
        let totalEntries = 0; // 总条目数（文件+目录）
        let processedEntries = 0; // 已处理条目数
        let streamEnded = false; // 流是否结束
        downloadResponse
            .body.pipe(unzipper_1.default.Parse())
            .on('error', reject)
            .on('entry', async (entry) => {
            totalEntries++;
            // 检查是否应该跳过这个条目
            if (shouldSkipEntry(entry.path)) {
                entry.autodrain(); // 丢弃数据流
                processedEntries++;
                checkCompletion();
                return;
            }
            const filePath = path_1.default.join(dirPath, entry.path);
            try {
                // 确保父目录存在（处理嵌套目录情况）
                await fs_extra_1.default.ensureDir(path_1.default.dirname(filePath));
                // 如果是目录则创建，否则写入文件
                if (entry.type === 'Directory') {
                    await fs_extra_1.default.ensureDir(filePath);
                    processedEntries++;
                    checkCompletion();
                }
                else {
                    entry
                        .pipe(fs_extra_1.default.createWriteStream(filePath))
                        .on('error', reject)
                        .on('finish', () => {
                        processedEntries++;
                        checkCompletion();
                    });
                }
            }
            catch (err) {
                reject(err);
            }
        })
            .on('close', () => {
            streamEnded = true;
            checkCompletion();
        });
        function checkCompletion() {
            if (streamEnded && totalEntries === processedEntries) {
                resolve('');
            }
        }
    });
}
/**
 * 将文件上传到指定 URL 地址
 * @param {Object} options - 上传配置项
 * @param {string} options.url - 目标上传地址
 * @param {File|Blob|Buffer} options.file - 要上传的文件对象
 * @param {string} [options.method='POST'] - HTTP 方法，默认为 POST
 * @param {Object} [options.headers={}] - 自定义请求头
 * @param {boolean} [options.withCredentials=false] - 是否携带跨域凭据
 */
function upload({ url, file, method = 'POST', headers = {}, withCredentials = false }) {
    return (0, http_request_1.fetchStream)(url, {
        method,
        headers,
        body: file,
        credentials: withCredentials ? 'include' : 'same-origin'
    })
        .then(async (response) => {
        const text = await response.text();
        const dataMeta = {
            data: null,
            context: {
                response,
                file
            }
        };
        try {
            dataMeta.data = JSON.parse(text);
        }
        catch (e) {
            // If parsing fails, keep data as null
        }
        if (!response.ok) {
            throw new Error(`${response.status} ${response.statusText} HTTP ERROR`);
        }
        return dataMeta;
    })
        .catch(error => {
        throw error; // 或者可以在这里进行错误转换
    });
}
function getRuntime() {
    return process.env[constant_1.ENV_NAME.ENV_RUNENV];
}
function getEnvVar(envName) {
    return process.env[envName];
}
function rsaEncrypt(data) {
    const buffer = Buffer.from(data);
    const encrypted = crypto_1.default.publicEncrypt({
        key: constant_1.PUBLIC_RSA_KEY,
        padding: crypto_1.default.constants.RSA_PKCS1_PADDING
    }, buffer);
    return encrypted.toString('base64');
}
function sleep(time) {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve();
        }, time);
    });
}
function upperCaseStringFisrt(str) {
    return str.slice(0, 1).toUpperCase().concat(str.slice(1));
}
function upperCaseObjKey(object) {
    const type = Object.prototype.toString.call(object).slice(8, -1);
    if (type === 'Object') {
        let newObj = {};
        // eslint-disable-next-line guard-for-in
        for (let key in object) {
            newObj[upperCaseStringFisrt(key)] = upperCaseObjKey(object[key]);
        }
        return newObj;
    }
    if (type === 'Array') {
        let newArr = [];
        for (let item of object) {
            newArr.push(upperCaseObjKey(item));
        }
        return newArr;
    }
    return object;
}
/**
 * 获取函数模板列表
 * @param type 函数模板类型，支持 'scfFunc' 和 'tcbrFunc'
 * @returns
 */
async function fetchTemplates(types) {
    const apiUrl = 'https://qcloud-tcb-console-1258344699.ap-shanghai.service.tcloudbase.com/func_tpl/v1.0/function_list/find?skip=0&limit=500';
    const responseData = await (0, http_request_1.fetch)(apiUrl, {
        method: 'POST'
    });
    return responseData.data.filter((item) => lodash_1.default.intersection(types, item.funcTypes).length > 0);
}
const formatTimeValue = (num) => {
    return num < 10 ? `0${num}` : `${num}`;
};
exports.formatTimeValue = formatTimeValue;
const formatTimeByMs = (ms) => {
    // 毫秒时间戳转换为 2025-07-19 09:00:00这种格式
    const time = new Date(ms);
    const year = time.getFullYear();
    const month = time.getMonth() + 1;
    const date = time.getDate();
    const hour = time.getHours();
    const minute = time.getMinutes();
    const second = time.getSeconds();
    return `${year}-${(0, exports.formatTimeValue)(month)}-${(0, exports.formatTimeValue)(date)} ${(0, exports.formatTimeValue)(hour)}:${(0, exports.formatTimeValue)(minute)}:${(0, exports.formatTimeValue)(second)}`;
};
exports.formatTimeByMs = formatTimeByMs;
const getCompleteTimeRange = (timeRange) => {
    let { startTime, endTime } = timeRange;
    if (!startTime && !endTime) {
        // 都不传则 endTime 为当前时间，startTime 为 startTime - 1d
        const curTime = new Date().getTime();
        endTime = (0, exports.formatTimeByMs)(curTime);
        startTime = (0, exports.formatTimeByMs)(curTime - 24 * 3600 * 1000);
    }
    if (startTime && !endTime) {
        // 自动补 endTime 为 startTime + 1d
        endTime = (0, exports.formatTimeByMs)(new Date(startTime).getTime() + 24 * 3600 * 1000);
    }
    if (endTime && !startTime) {
        // 自动补 startTime 为 endTime - 1d
        startTime = (0, exports.formatTimeByMs)(new Date(endTime).getTime() - 24 * 3600 * 1000);
    }
    return {
        startTime,
        endTime
    };
};
exports.getCompleteTimeRange = getCompleteTimeRange;
function successLog(msg) {
    // 空格，兼容中文字符编码长度问题
    console.log(`${msg}`);
}
