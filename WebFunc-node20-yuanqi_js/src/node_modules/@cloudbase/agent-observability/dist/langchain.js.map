{"version":3,"sources":["../src/core/constants.ts","../src/core/attributes.ts","../src/core/tracerProvider.ts","../src/core/spanWrapper.ts","../src/index.ts","../src/langchain/CallbackHandler.ts"],"sourcesContent":["/**\n * OTEL attribute constants for AG-Kit observability.\n *\n * Uses OpenInference semantic conventions where applicable:\n * https://github.com/Arize-ai/openinference/tree/main/spec\n *\n * Falls back to AG-Kit specific attributes where OpenInference\n * doesn't define a standard.\n *\n * @module\n */\n\nimport {\n  SemanticConventions,\n  OpenInferenceSpanKind,\n} from \"@arizeai/openinference-semantic-conventions\";\n\n// Re-export OpenInference types for convenience\nexport { OpenInferenceSpanKind };\n\n/**\n * SDK information\n */\nexport const OBSERVABILITY_TRACER_NAME = \"agkit-tracer\";\nexport const OBSERVABILITY_SDK_NAME = \"@agkit/observability\";\n// Version will be injected from package.json\n\n/**\n * Combined attribute namespace for internal use\n * Provides a single namespace for all OTEL attributes used by AG-Kit\n *\n * Combines OpenInference SemanticConventions with AG-Kit specific attributes\n */\nexport const OtelSpanAttributes = {\n  // OpenInference - re-export all standard conventions\n  ...SemanticConventions,\n\n  // AG-Kit Trace attributes (non-standard)\n  TRACE_NAME: \"trace.name\",\n  TRACE_TAGS: \"trace.tags\",\n  TRACE_PUBLIC: \"trace.public\",\n  TRACE_METADATA: \"trace.metadata\",\n  TRACE_INPUT: \"trace.input\",\n  TRACE_OUTPUT: \"trace.output\",\n\n  // AG-Kit Observation attributes (non-standard)\n  OBSERVATION_TYPE: \"observation.type\",\n  OBSERVATION_LEVEL: \"observation.level\",\n  OBSERVATION_STATUS_MESSAGE: \"observation.status_message\",\n  OBSERVATION_INPUT: \"observation.input\",\n  OBSERVATION_OUTPUT: \"observation.output\",\n  OBSERVATION_METADATA: \"observation.metadata\",\n\n  // AG-Kit LLM-specific (non-standard)\n  LLM_COMPLETION_START_TIME: \"llm.completion_start_time\",\n  LLM_MODEL_PARAMETERS: \"llm.model_parameters\",\n  LLM_USAGE_DETAILS: \"llm.usage_details\",\n  LLM_COST_DETAILS: \"llm.cost_details\",\n\n  // AG-Kit Retriever-specific (non-standard)\n  RETRIEVER_NAME: \"retriever.name\",\n  RETRIEVER_QUERY: \"retriever.query\",\n  RETRIEVER_INDEX_ID: \"retriever.index_id\",\n  RETRIEVER_TOP_K: \"retriever.top_k\",\n\n  // AG-Kit General (non-standard)\n  ENVIRONMENT: \"environment\",\n  RELEASE: \"release\",\n  VERSION: \"version\",\n} as const;\n\n/**\n * Type for the OtelSpanAttributes object values\n */\nexport type OtelSpanAttributeValues = typeof OtelSpanAttributes[keyof typeof OtelSpanAttributes];\n","import { OBSERVABILITY_TRACER_NAME, OtelSpanAttributes } from \"./constants.js\";\nimport { SemanticConventions } from \"@arizeai/openinference-semantic-conventions\";\nimport { ObservationAttributes, TraceAttributes, ObservationType } from \"../types.js\";\nimport { type Attributes } from \"@opentelemetry/api\";\n\n/**\n * Creates OpenTelemetry attributes from trace attributes.\n *\n * Converts user-friendly trace attributes into OpenTelemetry attribute format\n * using OpenInference semantic conventions where applicable.\n *\n * @param attributes - Trace attributes to convert\n * @returns OpenTelemetry attributes object\n *\n * @example\n * ```typescript\n * const otelAttributes = createTraceAttributes({\n *   name: 'user-workflow',\n *   userId: 'user-123',\n *   sessionId: 'session-456',\n *   tags: ['checkout', 'payment']\n * });\n * ```\n *\n * @public\n */\nexport function createTraceAttributes({\n  name,\n  userId,\n  sessionId,\n  version,\n  release,\n  input,\n  output,\n  metadata,\n  tags,\n  environment,\n  public: isPublic,\n}: TraceAttributes = {}): Attributes {\n  const attributes = {\n    [OtelSpanAttributes.TRACE_NAME]: name,\n    // Use OpenInference standard attributes for user and session\n    [OtelSpanAttributes.USER_ID]: userId,\n    [OtelSpanAttributes.SESSION_ID]: sessionId,\n    [OtelSpanAttributes.VERSION]: version,\n    [OtelSpanAttributes.RELEASE]: release,\n    [OtelSpanAttributes.TRACE_INPUT]: _serialize(input),\n    [OtelSpanAttributes.TRACE_OUTPUT]: _serialize(output),\n    [OtelSpanAttributes.TRACE_TAGS]: tags,\n    [OtelSpanAttributes.ENVIRONMENT]: environment,\n    [OtelSpanAttributes.TRACE_PUBLIC]: isPublic,\n    ..._flattenAndSerializeMetadata(metadata, OtelSpanAttributes.TRACE_METADATA),\n  };\n\n  return Object.fromEntries(\n    Object.entries(attributes).filter(([_, v]) => v != null),\n  );\n}\n\n/**\n * Creates OpenTelemetry attributes from observation attributes.\n *\n * Maps observation attributes to OpenInference semantic conventions:\n * - Uses `openinference.span.kind` for span type\n * - Uses `llm.*` for LLM-specific attributes\n * - Uses `tool.*` for tool-specific attributes\n * - Falls back to `agkit.observation.*` for non-standard attributes\n *\n * @param type - Observation type (llm, tool, chain, etc.)\n * @param attributes - Observation attributes to convert\n * @returns OpenTelemetry attributes object\n *\n * @public\n */\nexport function createObservationAttributes(\n  type: ObservationType,\n  attributes: ObservationAttributes,\n): Attributes {\n  const {\n    metadata,\n    input,\n    output,\n    level,\n    statusMessage,\n    version,\n    completionStartTime,\n    model,\n    modelParameters,\n    usageDetails,\n  } = attributes;\n\n  // Base attributes for all observation types\n  const otelAttributes: Attributes = {\n    [SemanticConventions.OPENINFERENCE_SPAN_KIND]: type.toUpperCase(),\n    [OtelSpanAttributes.OBSERVATION_TYPE]: type,\n    [OtelSpanAttributes.OBSERVATION_LEVEL]: level,\n    [OtelSpanAttributes.OBSERVATION_STATUS_MESSAGE]: statusMessage,\n    [OtelSpanAttributes.VERSION]: version,\n    // Use OpenInference input.value convention\n    [SemanticConventions.INPUT_VALUE]: _serialize(input),\n    // Also set legacy agkit.observation.input for compatibility\n    [OtelSpanAttributes.OBSERVATION_INPUT]: _serialize(input),\n    // Use OpenInference output.value convention\n    [SemanticConventions.OUTPUT_VALUE]: _serialize(output),\n    // Also set legacy agkit.observation.output for compatibility\n    [OtelSpanAttributes.OBSERVATION_OUTPUT]: _serialize(output),\n  };\n\n  // LLM-specific attributes\n  if (type === \"llm\") {\n    if (model) {\n      otelAttributes[SemanticConventions.LLM_MODEL_NAME] = model;\n    }\n    if (modelParameters) {\n      otelAttributes[SemanticConventions.LLM_INVOCATION_PARAMETERS] =\n        _serialize(modelParameters);\n      // Also set agkit.llm.model_parameters for compatibility\n      otelAttributes[OtelSpanAttributes.LLM_MODEL_PARAMETERS] =\n        _serialize(modelParameters);\n    }\n    if (usageDetails) {\n      // Map to OpenInference llm.token_count.* attributes\n      if (typeof usageDetails === \"object\") {\n        const usage = usageDetails as Record<string, number>;\n        if (usage.promptTokens !== undefined) {\n          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_PROMPT] =\n            usage.promptTokens;\n        }\n        if (usage.completionTokens !== undefined) {\n          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_COMPLETION] =\n            usage.completionTokens;\n        }\n        if (usage.totalTokens !== undefined) {\n          otelAttributes[SemanticConventions.LLM_TOKEN_COUNT_TOTAL] =\n            usage.totalTokens;\n        }\n      }\n      // Also set legacy agkit.llm.usage_details for compatibility\n      otelAttributes[OtelSpanAttributes.LLM_USAGE_DETAILS] =\n        _serialize(usageDetails);\n    }\n    if (completionStartTime) {\n      otelAttributes[OtelSpanAttributes.LLM_COMPLETION_START_TIME] =\n        _serialize(completionStartTime);\n    }\n  }\n\n  // Embedding-specific attributes\n  if (type === \"embedding\") {\n    if (model) {\n      otelAttributes[SemanticConventions.EMBEDDING_MODEL_NAME] = model;\n    }\n    if (modelParameters) {\n      otelAttributes[SemanticConventions.LLM_INVOCATION_PARAMETERS] =\n        _serialize(modelParameters);\n    }\n  }\n\n  // Add metadata (use OpenInference metadata convention)\n  const metadataAttrs = _flattenAndSerializeMetadata(\n    metadata,\n    SemanticConventions.METADATA,\n  );\n  Object.assign(otelAttributes, metadataAttrs);\n\n  // Also add agkit.observation.metadata for compatibility\n  const obsetvabilityMetadataAttrs = _flattenAndSerializeMetadata(\n    metadata,\n    OtelSpanAttributes.OBSERVATION_METADATA\n  );\n  Object.assign(otelAttributes, obsetvabilityMetadataAttrs);\n\n  // Filter out null/undefined values\n  return Object.fromEntries(\n    Object.entries(otelAttributes).filter(([_, v]) => v != null),\n  );\n}\n\n/**\n * Safely serializes an object to JSON string.\n *\n * @param obj - Object to serialize\n * @returns JSON string or undefined if null/undefined\n * @internal\n */\nfunction _serialize(obj: unknown): string | undefined {\n  try {\n    if (typeof obj === \"string\") return obj;\n    if (obj instanceof Date) return obj.toISOString();\n    return obj != null ? JSON.stringify(obj) : undefined;\n  } catch {\n    return \"<failed to serialize>\";\n  }\n}\n\n/**\n * Flattens and serializes metadata into OpenTelemetry attribute format.\n *\n * Converts nested metadata objects into dot-notation attribute keys.\n * For example, `{ database: { host: 'localhost' } }` becomes\n * `{ 'metadata.database.host': 'localhost' }` (or 'agkit.observation.metadata.database.host').\n *\n * @param metadata - Metadata object to flatten\n * @param prefix - Attribute prefix (e.g., 'metadata' or 'agkit.observation.metadata')\n * @returns Flattened metadata attributes\n * @internal\n */\nfunction _flattenAndSerializeMetadata(\n  metadata: unknown,\n  prefix: string,\n): Record<string, string> {\n  const metadataAttributes: Record<string, string> = {};\n\n  if (metadata === undefined || metadata === null) {\n    return metadataAttributes;\n  }\n\n  if (typeof metadata !== \"object\" || Array.isArray(metadata)) {\n    const serialized = _serialize(metadata);\n    if (serialized) {\n      metadataAttributes[prefix] = serialized;\n    }\n  } else {\n    for (const [key, value] of Object.entries(metadata)) {\n      const serialized = typeof value === \"string\" ? value : _serialize(value);\n      if (serialized) {\n        metadataAttributes[`${prefix}.${key}`] = serialized;\n      }\n    }\n  }\n\n  return metadataAttributes;\n}\n","import { TracerProvider, trace, context } from \"@opentelemetry/api\";\n\nconst OBSERVABILITY_GLOBAL_SYMBOL = Symbol.for(\"observability\");\n\ntype ObservabilityGlobalState = {\n  isolatedTracerProvider: TracerProvider | null;\n};\n\nfunction createState(): ObservabilityGlobalState {\n  return {\n    isolatedTracerProvider: null,\n  };\n}\n\ninterface GlobalThis {\n  [OBSERVABILITY_GLOBAL_SYMBOL]?: ObservabilityGlobalState;\n}\n\n/**\n * Gets the global state for tracing observability.\n *\n * @returns The global state object\n * @internal\n */\nfunction getObservabilityGlobalState(): ObservabilityGlobalState {\n  const initialState = createState();\n\n  try {\n    const g = globalThis as typeof globalThis & GlobalThis;\n\n    if (typeof g !== \"object\" || g === null) {\n      console.warn(\n        \"[Observability] globalThis is not available, using fallback state\",\n      );\n      return initialState;\n    }\n\n    if (!g[OBSERVABILITY_GLOBAL_SYMBOL]) {\n      Object.defineProperty(g, OBSERVABILITY_GLOBAL_SYMBOL, {\n        value: initialState,\n        writable: false,\n        configurable: false,\n        enumerable: false,\n      });\n    }\n\n    return g[OBSERVABILITY_GLOBAL_SYMBOL]!;\n  } catch (err) {\n    console.error(\n      `[Observability] Failed to access global state: ${err instanceof Error ? err.message : String(err)}`,\n    );\n    return initialState;\n  }\n}\n\n/**\n * Sets an isolated TracerProvider for tracing tracing operations.\n *\n * This allows tracing to use its own TracerProvider instance, separate from\n * the global OpenTelemetry TracerProvider.\n *\n * Note: While this isolates span processing and export, it does NOT provide\n * complete trace isolation. OpenTelemetry context (trace IDs, parent spans)\n * is still shared between the global and isolated providers.\n *\n * @param provider - The TracerProvider instance to use, or null to clear\n *\n * @example\n * ```typescript\n * import { NodeTracerProvider } from '@opentelemetry/sdk-trace-node';\n * import { setTracerProvider } from './observability';\n *\n * const provider = new NodeTracerProvider();\n * setTracerProvider(provider);\n * ```\n *\n * @public\n */\nexport function setTracerProvider(provider: TracerProvider | null) {\n  getObservabilityGlobalState().isolatedTracerProvider = provider;\n}\n\n/**\n * Gets the TracerProvider for tracing tracing operations.\n *\n * Returns the isolated TracerProvider if one has been set via setTracerProvider(),\n * otherwise falls back to the global OpenTelemetry TracerProvider.\n *\n * @returns The TracerProvider instance to use for tracing tracing\n *\n * @example\n * ```typescript\n * import { getTracerProvider } from './observability';\n *\n * const provider = getTracerProvider();\n * const tracer = provider.getTracer('my-tracer', '1.0.0');\n * ```\n *\n * @public\n */\nexport function getTracerProvider(): TracerProvider {\n  const { isolatedTracerProvider } = getObservabilityGlobalState();\n\n  if (isolatedTracerProvider) return isolatedTracerProvider;\n\n  return trace.getTracerProvider();\n}\n\n/**\n * Gets the OpenTelemetry tracer instance for tracing.\n *\n * Returns a tracer specifically configured for tracing with the correct\n * tracer name and version.\n *\n * @returns The tracing OpenTelemetry tracer instance\n *\n * @example\n * ```typescript\n * import { getTracer } from './observability';\n *\n * const tracer = getTracer();\n * const span = tracer.startSpan('my-operation');\n * ```\n *\n * @public\n */\nexport function getTracer() {\n  return getTracerProvider().getTracer(\n    OBSERVABILITY_SDK_NAME,\n    OBSERVABILITY_SDK_VERSION\n  );\n}\n\n// SDK version - could be read from package.json in production\nconst OBSERVABILITY_SDK_NAME = \"ag-kit-observability\";\nconst OBSERVABILITY_SDK_VERSION = \"0.1.0\";\n","import { Span, TimeInput } from \"@opentelemetry/api\";\n\nimport { createObservationAttributes, createTraceAttributes } from \"./attributes.js\";\nimport { getTracer } from \"./tracerProvider.js\";\nimport {\n  BaseSpanAttributes,\n  LLMAttributes,\n  TraceAttributes,\n  ObservationType,\n} from \"../types.js\";\nimport type {\n  ToolAttributes,\n  AgentAttributes,\n  ChainAttributes,\n  RetrieverAttributes,\n  RerankerAttributes,\n  EvaluatorAttributes,\n  GuardrailAttributes,\n  EmbeddingAttributes,\n  ObservationAttributes,\n} from \"../types.js\";\n\n/**\n * Union type representing any observation wrapper.\n *\n * @public\n */\nexport type Observation =\n  | ObservationSpan\n  | ObservationLLM\n  | ObservationEmbedding\n  | ObservationAgent\n  | ObservationTool\n  | ObservationChain\n  | ObservationRetriever\n  | ObservationReranker\n  | ObservationEvaluator\n  | ObservationGuardrail;\n\n/**\n * Parameters for creating an observation wrapper.\n *\n * @internal\n */\ntype ObservationParams = {\n  otelSpan: Span;\n  type: ObservationType;\n  attributes?: BaseSpanAttributes | LLMAttributes;\n};\n\n/**\n * Base class for all observation wrappers.\n *\n * Provides common functionality for all observation types including:\n * - OpenTelemetry span integration\n * - Unique identification (span ID, trace ID)\n * - Lifecycle management (update, end)\n * - Trace context management\n * - Child observation creation\n *\n * @internal\n */\nabstract class BaseObservation {\n  /** The underlying OpenTelemetry span */\n  public readonly otelSpan: Span;\n  /** The observation type */\n  public readonly type: ObservationType;\n  /** The span ID from the OpenTelemetry span context */\n  public id: string;\n  /** The trace ID from the OpenTelemetry span context */\n  public traceId: string;\n\n  constructor(params: ObservationParams) {\n    this.otelSpan = params.otelSpan;\n    this.id = params.otelSpan.spanContext().spanId;\n    this.traceId = params.otelSpan.spanContext().traceId;\n    this.type = params.type;\n\n    if (params.attributes) {\n      this.otelSpan.setAttributes(\n        createObservationAttributes(params.type, params.attributes),\n      );\n    }\n  }\n\n  /** Gets the AG-Kit OpenTelemetry tracer instance */\n  protected get tracer() {\n    return getTracer();\n  }\n\n  /**\n   * Ends the observation, marking it as complete.\n   *\n   * @param endTime - Optional end time, defaults to current time\n   */\n  public end(endTime?: TimeInput) {\n    this.otelSpan.end(endTime);\n  }\n\n  /**\n   * Updates the OTEL span attributes.\n   *\n   * @param attributes - Attributes to update\n   * @internal\n   */\n  updateOtelSpanAttributes(attributes: ObservationAttributes) {\n    this.otelSpan.setAttributes(\n      createObservationAttributes(this.type, attributes),\n    );\n  }\n\n  /**\n   * Updates the parent trace with new attributes.\n   *\n   * @param attributes - Trace attributes to set\n   * @returns This observation for method chaining\n   */\n  public updateTrace(attributes: TraceAttributes) {\n    this.otelSpan.setAttributes(createTraceAttributes(attributes));\n    return this;\n  }\n\n  /**\n   * Creates a new child observation within this observation's context.\n   *\n   * @param name - Name for the child observation\n   * @param attributes - Type-specific attributes\n   * @param options - Configuration including observation type\n   * @returns Child observation instance\n   */\n  public startObservation(\n    name: string,\n    attributes: LLMAttributes,\n    options: { asType: \"llm\" },\n  ): ObservationLLM;\n  public startObservation(\n    name: string,\n    attributes: EmbeddingAttributes,\n    options: { asType: \"embedding\" },\n  ): ObservationEmbedding;\n  public startObservation(\n    name: string,\n    attributes: AgentAttributes,\n    options: { asType: \"agent\" },\n  ): ObservationAgent;\n  public startObservation(\n    name: string,\n    attributes: ToolAttributes,\n    options: { asType: \"tool\" },\n  ): ObservationTool;\n  public startObservation(\n    name: string,\n    attributes: ChainAttributes,\n    options: { asType: \"chain\" },\n  ): ObservationChain;\n  public startObservation(\n    name: string,\n    attributes: RetrieverAttributes,\n    options: { asType: \"retriever\" },\n  ): ObservationRetriever;\n  public startObservation(\n    name: string,\n    attributes: RerankerAttributes,\n    options: { asType: \"reranker\" },\n  ): ObservationReranker;\n  public startObservation(\n    name: string,\n    attributes: EvaluatorAttributes,\n    options: { asType: \"evaluator\" },\n  ): ObservationEvaluator;\n  public startObservation(\n    name: string,\n    attributes: GuardrailAttributes,\n    options: { asType: \"guardrail\" },\n  ): ObservationGuardrail;\n  public startObservation(\n    name: string,\n    attributes?: BaseSpanAttributes,\n    options?: { asType?: \"span\" },\n  ): ObservationSpan;\n  public startObservation(\n    name: string,\n    attributes?:\n      | BaseSpanAttributes\n      | LLMAttributes\n      | ToolAttributes\n      | AgentAttributes\n      | ChainAttributes\n      | RetrieverAttributes\n      | RerankerAttributes\n      | EvaluatorAttributes\n      | GuardrailAttributes\n      | EmbeddingAttributes,\n    options?: { asType?: ObservationType },\n  ): Observation {\n    // Import here to avoid circular dependency\n    const { startObservation: startObs } = require(\"../index.js\");\n    const { asType = \"span\" } = options || {};\n\n    return startObs(name, attributes, {\n      asType: asType as \"span\",\n      parentSpanContext: this.otelSpan.spanContext(),\n    });\n  }\n}\n\n// Type-specific observation classes\n\ntype ObservationSpanParams = {\n  otelSpan: Span;\n  attributes?: BaseSpanAttributes;\n};\n\n/**\n * General-purpose observation for tracking operations.\n *\n * @public\n */\nexport class ObservationSpan extends BaseObservation {\n  constructor(params: ObservationSpanParams) {\n    super({ ...params, type: \"span\" });\n  }\n\n  public update(attributes: BaseSpanAttributes): ObservationSpan {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationLLMParams = {\n  otelSpan: Span;\n  attributes?: LLMAttributes;\n};\n\n/**\n * LLM observation for tracking language model calls.\n *\n * @public\n */\nexport class ObservationLLM extends BaseObservation {\n  constructor(params: ObservationLLMParams) {\n    super({ ...params, type: \"llm\" });\n  }\n\n  public update(attributes: LLMAttributes): ObservationLLM {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationEmbeddingParams = {\n  otelSpan: Span;\n  attributes?: EmbeddingAttributes;\n};\n\n/**\n * Embedding observation for tracking embedding operations.\n *\n * @public\n */\nexport class ObservationEmbedding extends BaseObservation {\n  constructor(params: ObservationEmbeddingParams) {\n    super({ ...params, type: \"embedding\" });\n  }\n\n  public update(attributes: EmbeddingAttributes): ObservationEmbedding {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationAgentParams = {\n  otelSpan: Span;\n  attributes?: AgentAttributes;\n};\n\n/**\n * Agent observation for tracking AI agent workflows.\n *\n * @public\n */\nexport class ObservationAgent extends BaseObservation {\n  constructor(params: ObservationAgentParams) {\n    super({ ...params, type: \"agent\" });\n  }\n\n  public update(attributes: AgentAttributes): ObservationAgent {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationToolParams = {\n  otelSpan: Span;\n  attributes?: ToolAttributes;\n};\n\n/**\n * Tool observation for tracking tool calls.\n *\n * @public\n */\nexport class ObservationTool extends BaseObservation {\n  constructor(params: ObservationToolParams) {\n    super({ ...params, type: \"tool\" });\n  }\n\n  public update(attributes: ToolAttributes): ObservationTool {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationChainParams = {\n  otelSpan: Span;\n  attributes?: ChainAttributes;\n};\n\n/**\n * Chain observation for tracking multi-step workflows.\n *\n * @public\n */\nexport class ObservationChain extends BaseObservation {\n  constructor(params: ObservationChainParams) {\n    super({ ...params, type: \"chain\" });\n  }\n\n  public update(attributes: ChainAttributes): ObservationChain {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationRetrieverParams = {\n  otelSpan: Span;\n  attributes?: RetrieverAttributes;\n};\n\n/**\n * Retriever observation for tracking document retrieval.\n *\n * @public\n */\nexport class ObservationRetriever extends BaseObservation {\n  constructor(params: ObservationRetrieverParams) {\n    super({ ...params, type: \"retriever\" });\n  }\n\n  public update(attributes: RetrieverAttributes): ObservationRetriever {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationRerankerParams = {\n  otelSpan: Span;\n  attributes?: RerankerAttributes;\n};\n\n/**\n * Reranker observation for tracking reranking operations.\n *\n * @public\n */\nexport class ObservationReranker extends BaseObservation {\n  constructor(params: ObservationRerankerParams) {\n    super({ ...params, type: \"reranker\" });\n  }\n\n  public update(attributes: RerankerAttributes): ObservationReranker {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationEvaluatorParams = {\n  otelSpan: Span;\n  attributes?: EvaluatorAttributes;\n};\n\n/**\n * Evaluator observation for tracking evaluation operations.\n *\n * @public\n */\nexport class ObservationEvaluator extends BaseObservation {\n  constructor(params: ObservationEvaluatorParams) {\n    super({ ...params, type: \"evaluator\" });\n  }\n\n  public update(attributes: EvaluatorAttributes): ObservationEvaluator {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n\ntype ObservationGuardrailParams = {\n  otelSpan: Span;\n  attributes?: GuardrailAttributes;\n};\n\n/**\n * Guardrail observation for tracking safety checks.\n *\n * @public\n */\nexport class ObservationGuardrail extends BaseObservation {\n  constructor(params: ObservationGuardrailParams) {\n    super({ ...params, type: \"guardrail\" });\n  }\n\n  public update(attributes: GuardrailAttributes): ObservationGuardrail {\n    super.updateOtelSpanAttributes(attributes);\n    return this;\n  }\n}\n","/**\n * Observability - OpenTelemetry-based tracing with OpenInference semantic conventions\n *\n * @packageDocumentation\n */\n\nimport { trace, context, TimeInput, SpanStatusCode, Span, SpanContext } from \"@opentelemetry/api\";\n\nimport {\n  createObservationAttributes,\n  createTraceAttributes,\n} from \"./core/attributes.js\";\nimport {\n  ObservationSpan,\n  ObservationLLM,\n  ObservationEmbedding,\n  ObservationAgent,\n  ObservationTool,\n  ObservationChain,\n  ObservationRetriever,\n  ObservationReranker,\n  ObservationEvaluator,\n  ObservationGuardrail,\n  type Observation,\n} from \"./core/spanWrapper.js\";\nimport { getTracer } from \"./core/tracerProvider.js\";\nimport {\n  ObservationType,\n  ObservationLevel,\n  BaseSpanAttributes,\n  LLMAttributes,\n  ToolAttributes,\n  AgentAttributes,\n  ChainAttributes,\n  RetrieverAttributes,\n  RerankerAttributes,\n  EvaluatorAttributes,\n  GuardrailAttributes,\n  EmbeddingAttributes,\n  ObservationAttributes,\n  TraceAttributes,\n} from \"./types.js\";\n\n// Export types\nexport type {\n  ObservationType,\n  ObservationLevel,\n  BaseSpanAttributes,\n  LLMAttributes,\n  ToolAttributes,\n  AgentAttributes,\n  ChainAttributes,\n  RetrieverAttributes,\n  RerankerAttributes,\n  EvaluatorAttributes,\n  GuardrailAttributes,\n  EmbeddingAttributes,\n  ObservationAttributes,\n  TraceAttributes,\n};\n\n// Export observation classes\nexport {\n  ObservationSpan,\n  ObservationLLM,\n  ObservationEmbedding,\n  ObservationAgent,\n  ObservationTool,\n  ObservationChain,\n  ObservationRetriever,\n  ObservationReranker,\n  ObservationEvaluator,\n  ObservationGuardrail,\n};\n\n// Export observation union type\nexport type { Observation };\n\n// Export core functions\nexport {\n  createTraceAttributes,\n  createObservationAttributes,\n} from \"./core/attributes.js\";\nexport {\n  setTracerProvider,\n  getTracerProvider,\n  getTracer,\n} from \"./core/tracerProvider.js\";\n\n/**\n * Options for starting observations (spans).\n *\n * @public\n */\nexport type StartObservationOptions = {\n  /** Custom start time for the observation */\n  startTime?: Date;\n  /** Parent span context to attach this observation to */\n  parentSpanContext?: SpanContext;\n};\n\n/**\n * Options for startObservation function.\n *\n * @public\n */\nexport type StartObservationOpts = StartObservationOptions & {\n  /** Type of observation to create. Defaults to 'span' */\n  asType?: ObservationType;\n};\n\n/**\n * Creates an OpenTelemetry span with the AG-Kit tracer.\n *\n * @param params - Parameters for span creation\n * @returns The created OpenTelemetry span\n * @internal\n */\nfunction createOtelSpan(params: {\n  name: string;\n  startTime?: TimeInput;\n  parentSpanContext?: SpanContext;\n}): Span {\n  return getTracer().startSpan(\n    params.name,\n    { startTime: params.startTime },\n    createParentContext(params.parentSpanContext),\n  );\n}\n\n/**\n * Creates a parent context from a span context.\n *\n * @param parentSpanContext - The span context to use as parent\n * @returns The created context or undefined if no parent provided\n * @internal\n */\nfunction createParentContext(\n  parentSpanContext?: SpanContext,\n): ReturnType<typeof trace.setSpanContext> | undefined {\n  if (!parentSpanContext) return;\n  return trace.setSpanContext(context.active(), parentSpanContext);\n}\n\n// Function overloads for proper type inference\n// Generic overload for dynamic asType (returns Observation union)\nexport function startObservation(\n  name: string,\n  attributes?: BaseSpanAttributes,\n  options?: StartObservationOpts & { asType?: ObservationType },\n): Observation;\n\n// Type-specific overloads for precise type inference\nexport function startObservation(\n  name: string,\n  attributes: LLMAttributes,\n  options: StartObservationOpts & { asType: \"llm\" },\n): ObservationLLM;\nexport function startObservation(\n  name: string,\n  attributes: EmbeddingAttributes,\n  options: StartObservationOpts & { asType: \"embedding\" },\n): ObservationEmbedding;\nexport function startObservation(\n  name: string,\n  attributes: AgentAttributes,\n  options: StartObservationOpts & { asType: \"agent\" },\n): ObservationAgent;\nexport function startObservation(\n  name: string,\n  attributes: ToolAttributes,\n  options: StartObservationOpts & { asType: \"tool\" },\n): ObservationTool;\nexport function startObservation(\n  name: string,\n  attributes: ChainAttributes,\n  options: StartObservationOpts & { asType: \"chain\" },\n): ObservationChain;\nexport function startObservation(\n  name: string,\n  attributes: RetrieverAttributes,\n  options: StartObservationOpts & { asType: \"retriever\" },\n): ObservationRetriever;\nexport function startObservation(\n  name: string,\n  attributes: RerankerAttributes,\n  options: StartObservationOpts & { asType: \"reranker\" },\n): ObservationReranker;\nexport function startObservation(\n  name: string,\n  attributes: EvaluatorAttributes,\n  options: StartObservationOpts & { asType: \"evaluator\" },\n): ObservationEvaluator;\nexport function startObservation(\n  name: string,\n  attributes: GuardrailAttributes,\n  options: StartObservationOpts & { asType: \"guardrail\" },\n): ObservationGuardrail;\nexport function startObservation(\n  name: string,\n  attributes?: BaseSpanAttributes,\n  options?: StartObservationOpts & { asType?: \"span\" },\n): ObservationSpan;\n\n/**\n * Creates and starts a new AG-Kit observation.\n *\n * Supports multiple observation types with full TypeScript type safety:\n * - **span**: General-purpose operations (default)\n * - **llm**: LLM calls and AI model interactions\n * - **embedding**: Text embedding and vector operations\n * - **agent**: AI agent workflows\n * - **tool**: Individual tool calls\n * - **chain**: Multi-step processes\n * - **retriever**: Document retrieval\n * - **reranker**: Result reranking\n * - **evaluator**: Quality assessment\n * - **guardrail**: Safety checks\n *\n * @param name - Descriptive name for the observation\n * @param attributes - Type-specific attributes\n * @param options - Configuration options\n * @returns Strongly-typed observation object\n *\n * @example\n * ```typescript\n * import { startObservation } from './observability';\n *\n * // LLM observation\n * const llm = startObservation('openai-gpt-4', {\n *   input: [{ role: 'user', content: 'Hello' }],\n *   model: 'gpt-4',\n *   modelParameters: { temperature: 0.7 }\n * }, { asType: 'llm' });\n *\n * // Tool observation\n * const tool = startObservation('weather-api', {\n *   input: { location: 'SF' }\n * }, { asType: 'tool' });\n *\n * // Chain observation\n * const chain = startObservation('rag-pipeline', {\n *   input: { question: 'What is AI?' }\n * }, { asType: 'chain' });\n * ```\n *\n * @public\n */\nexport function startObservation(\n  name: string,\n  attributes?:\n    | BaseSpanAttributes\n    | LLMAttributes\n    | EmbeddingAttributes\n    | AgentAttributes\n    | ToolAttributes\n    | ChainAttributes\n    | RetrieverAttributes\n    | RerankerAttributes\n    | EvaluatorAttributes\n    | GuardrailAttributes,\n  options?: StartObservationOpts,\n): Observation {\n  const { asType = \"span\", ...observationOptions } = options || {};\n\n  const otelSpan = createOtelSpan({\n    name,\n    ...observationOptions,\n  });\n\n  switch (asType) {\n    case \"llm\":\n      return new ObservationLLM({\n        otelSpan,\n        attributes: attributes as LLMAttributes,\n      });\n\n    case \"embedding\":\n      return new ObservationEmbedding({\n        otelSpan,\n        attributes: attributes as EmbeddingAttributes,\n      });\n\n    case \"agent\":\n      return new ObservationAgent({\n        otelSpan,\n        attributes: attributes as AgentAttributes,\n      });\n\n    case \"tool\":\n      return new ObservationTool({\n        otelSpan,\n        attributes: attributes as ToolAttributes,\n      });\n\n    case \"chain\":\n      return new ObservationChain({\n        otelSpan,\n        attributes: attributes as ChainAttributes,\n      });\n\n    case \"retriever\":\n      return new ObservationRetriever({\n        otelSpan,\n        attributes: attributes as RetrieverAttributes,\n      });\n\n    case \"reranker\":\n      return new ObservationReranker({\n        otelSpan,\n        attributes: attributes as RerankerAttributes,\n      });\n\n    case \"evaluator\":\n      return new ObservationEvaluator({\n        otelSpan,\n        attributes: attributes as EvaluatorAttributes,\n      });\n\n    case \"guardrail\":\n      return new ObservationGuardrail({\n        otelSpan,\n        attributes: attributes as GuardrailAttributes,\n      });\n\n    case \"span\":\n    default:\n      return new ObservationSpan({\n        otelSpan,\n        attributes: attributes as BaseSpanAttributes,\n      });\n  }\n}\n\n/**\n * Updates the currently active trace with new attributes.\n *\n * @param attributes - Trace attributes to set\n *\n * @example\n * ```typescript\n * import { updateActiveTrace } from './observability';\n *\n * updateActiveTrace({\n *   name: 'user-workflow',\n *   userId: 'user-123',\n *   tags: ['production']\n * });\n * ```\n *\n * @public\n */\nexport function updateActiveTrace(attributes: TraceAttributes) {\n  const span = trace.getActiveSpan();\n\n  if (!span) {\n    console.warn(\n      \"[Observability] No active OTEL span in context. Skipping trace update.\",\n    );\n    return;\n  }\n\n  span.setAttributes(createTraceAttributes(attributes));\n}\n\n/**\n * Gets the current active trace ID.\n *\n * @returns The trace ID of the currently active span, or undefined\n *\n * @public\n */\nexport function getActiveTraceId(): string | undefined {\n  return trace.getActiveSpan()?.spanContext().traceId;\n}\n\n/**\n * Gets the current active observation ID.\n *\n * @returns The span ID of the currently active span, or undefined\n *\n * @public\n */\nexport function getActiveSpanId(): string | undefined {\n  return trace.getActiveSpan()?.spanContext().spanId;\n}\n\n// ============================================================================\n// Active Observation Functions\n// ============================================================================\n\n/**\n * Options for startActiveObservation.\n *\n * @public\n */\nexport type StartActiveObservationOpts = StartObservationOpts & {\n  /** Whether to automatically end the observation when the function exits. Default: true */\n  endOnExit?: boolean;\n};\n\n/**\n * Wraps a Promise to automatically end the span when it resolves/rejects.\n *\n * @param promise - The promise to wrap\n * @param span - The OpenTelemetry span\n * @param endOnExit - Whether to end the span on exit\n * @returns The wrapped promise\n * @internal\n */\nfunction wrapPromise<T>(\n  promise: Promise<T>,\n  span: Span,\n  endOnExit: boolean | undefined,\n): Promise<T> {\n  return promise.then(\n    (value) => {\n      if (endOnExit !== false) {\n        span.end();\n      }\n      return value;\n    },\n    (err: unknown) => {\n      span.setStatus({\n        code: SpanStatusCode.ERROR,\n        message: err instanceof Error ? err.message : \"Unknown error\",\n      });\n      if (endOnExit !== false) {\n        span.end();\n      }\n      throw err;\n    },\n  );\n}\n\n// Function overloads for startActiveObservation\nexport function startActiveObservation<\n  F extends (observation: ObservationSpan) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationLLM) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationEmbedding) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationAgent) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationTool) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationChain) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationRetriever) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationReranker) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationEvaluator) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\nexport function startActiveObservation<\n  F extends (observation: ObservationGuardrail) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F>;\n\n/**\n * Creates an observation with automatic lifecycle management.\n *\n * This function creates an observation and executes a function with that observation\n * as a parameter. The observation is automatically ended when the function completes\n * (unless `endOnExit` is set to `false`).\n *\n * Supports both synchronous and asynchronous functions, with automatic error handling.\n *\n * @param name - Descriptive name for the observation\n * @param fn - Function to execute with the observation\n * @param options - Configuration options\n * @returns The result of the function\n *\n * @example\n * ```typescript\n * import { startActiveObservation } from './observability';\n *\n * // Synchronous function\n * const result = startActiveObservation('data-processing', (span) => {\n *   span.update({ input: { data: [1, 2, 3] } });\n *   const processed = data.map(x => x * 2);\n *   span.update({ output: { result: processed } });\n *   return processed;\n * }, { asType: 'span' });\n *\n * // Asynchronous function\n * const embeddings = await startActiveObservation(\n *   'text-embeddings',\n *   async (embedding) => {\n *     embedding.update({\n *       input: { texts: ['Hello', 'World'] },\n *       model: 'text-embedding-ada-002'\n *     });\n *\n *     const vectors = await generateEmbeddings(texts);\n *\n *     embedding.update({ output: { embeddings: vectors } });\n *     return vectors;\n *   },\n *   { asType: 'embedding' }\n * );\n *\n * // Disable automatic ending (for long-running operations)\n * startActiveObservation(\n *   'background-task',\n *   (span) => {\n *     span.update({ input: { taskId: '123' } });\n *     startBackgroundProcess(span);\n *     return 'started';\n *   },\n *   { asType: 'span', endOnExit: false }\n * );\n * ```\n *\n * @see {@link startObservation} for manual observation lifecycle management\n * @see {@link observe} for decorator-style function wrapping\n *\n * @public\n */\nexport function startActiveObservation<\n  F extends (observation: Observation) => unknown,\n>(name: string, fn: F, options?: StartActiveObservationOpts): ReturnType<F> {\n  const { asType = \"span\", endOnExit, ...observationOptions } = options || {};\n\n  return getTracer().startActiveSpan(\n    name,\n    { startTime: observationOptions?.startTime },\n    createParentContext(observationOptions?.parentSpanContext) ??\n      context.active(),\n    (span) => {\n      try {\n        let observation: Observation;\n\n        switch (asType) {\n          case \"llm\":\n            observation = new ObservationLLM({ otelSpan: span });\n            break;\n          case \"embedding\":\n            observation = new ObservationEmbedding({ otelSpan: span });\n            break;\n          case \"agent\":\n            observation = new ObservationAgent({ otelSpan: span });\n            break;\n          case \"tool\":\n            observation = new ObservationTool({ otelSpan: span });\n            break;\n          case \"chain\":\n            observation = new ObservationChain({ otelSpan: span });\n            break;\n          case \"retriever\":\n            observation = new ObservationRetriever({ otelSpan: span });\n            break;\n          case \"reranker\":\n            observation = new ObservationReranker({ otelSpan: span });\n            break;\n          case \"evaluator\":\n            observation = new ObservationEvaluator({ otelSpan: span });\n            break;\n          case \"guardrail\":\n            observation = new ObservationGuardrail({ otelSpan: span });\n            break;\n          case \"span\":\n          default:\n            observation = new ObservationSpan({ otelSpan: span });\n        }\n\n        const result = fn(observation as Parameters<F>[0]);\n\n        if (result instanceof Promise) {\n          return wrapPromise(\n            result,\n            span,\n            endOnExit,\n          ) as ReturnType<F>;\n        } else {\n          if (endOnExit !== false) {\n            span.end();\n          }\n          return result as ReturnType<F>;\n        }\n      } catch (err) {\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err instanceof Error ? err.message : \"Unknown error\",\n        });\n        if (endOnExit !== false) {\n          span.end();\n        }\n        throw err;\n      }\n    },\n  );\n}\n\n/**\n * Updates the currently active observation with new attributes.\n *\n * @param attributes - Observation attributes to set\n *\n * @example\n * ```typescript\n * import { updateActiveObservation } from './observability';\n *\n * // Within an active observation context\n * updateActiveObservation({\n *   metadata: { stage: 'processing' }\n * });\n * ```\n *\n * @public\n */\nexport function updateActiveObservation(\n  attributes: BaseSpanAttributes,\n): void {\n  const span = trace.getActiveSpan();\n\n  if (!span) {\n    console.warn(\n      \"[Observability] No active OTEL span in context. Skipping observation update.\",\n    );\n    return;\n  }\n\n  span.setAttributes(createObservationAttributes(\"span\", attributes));\n}\n\n// ============================================================================\n// Decorator Function\n// ============================================================================\n\n/**\n * Options for the observe decorator.\n *\n * @public\n */\nexport type ObserveOptions = Omit<StartObservationOpts, \"name\"> & {\n  /** Whether to capture function arguments as input. Default: true */\n  captureInput?: boolean;\n  /** Whether to capture return value as output. Default: true */\n  captureOutput?: boolean;\n};\n\n/**\n * Captures function arguments for observability input.\n *\n * @param args - Function arguments to capture\n * @returns Serialized arguments\n * @internal\n */\nfunction _captureArguments(args: unknown[]): Record<string, unknown> {\n  if (args.length === 0) return {};\n  if (args.length === 1) return { arg: args[0] };\n  return { args };\n}\n\n/**\n * Decorator function to add observability to any function.\n *\n * Wraps a function with automatic observation creation, input/output capture,\n * and lifecycle management. The observation is automatically ended when the\n * function completes.\n *\n * @param fn - Function to wrap\n * @param options - Configuration options\n * @returns Wrapped function with observability\n *\n * @example\n * ```typescript\n * import { observe } from './observability';\n *\n * // Wrap an existing function\n * const fetchData = observe(async (url: string) => {\n *   const response = await fetch(url);\n *   return response.json();\n * }, { asType: 'tool' });\n *\n * // Wrap with custom name\n * const processPayment = observe(\n *   async (amount: number, currency: string) => {\n *     return await paymentGateway.charge(amount, currency);\n *   },\n *   { name: 'payment-gateway-call', asType: 'tool' }\n * );\n *\n * // Class method decoration\n * class UserService {\n *   @observe({ asType: 'chain' })\n *   async getUser(id: string) {\n *     return await db.users.find(id);\n *   }\n * }\n * ```\n *\n * @public\n */\nexport function observe<T extends (...args: any[]) => any>(\n  fn: T,\n  options: ObserveOptions = {},\n): T {\n  const {\n    asType = \"span\",\n    captureInput = true,\n    captureOutput = true,\n    ...observationOptions\n  } = options;\n\n  const wrappedFunction = function (\n    this: any,\n    ...args: Parameters<T>\n  ): ReturnType<T> {\n    const name = fn.name || \"anonymous-function\";\n\n    // Prepare input data\n    const inputData = captureInput ? _captureArguments(args) : undefined;\n\n    // Create the observation\n    const observation = startObservation(\n      name,\n      inputData ? { input: inputData } : {},\n      {\n        ...observationOptions,\n        asType: asType as \"span\",\n      },\n    );\n\n    // Set the observation span as active in the context\n    const activeContext = trace.setSpan(context.active(), observation.otelSpan);\n\n    // Execute the function within the observation context\n    const result = context.with(activeContext, () => fn.apply(this, args));\n\n    // Handle promises\n    if (result instanceof Promise) {\n      return result.then(\n        (value) => {\n          if (captureOutput) {\n            observation.update({ output: value });\n          }\n          observation.end();\n          return value;\n        },\n        (err: unknown) => {\n          observation.update({\n            level: \"ERROR\",\n            statusMessage: err instanceof Error ? err.message : \"Unknown error\",\n          });\n          observation.end();\n          throw err;\n        },\n      ) as ReturnType<T>;\n    }\n\n    // Handle synchronous functions\n    if (captureOutput) {\n      observation.update({ output: result });\n    }\n    observation.end();\n\n    return result as ReturnType<T>;\n  };\n\n  // Preserve function properties\n  Object.defineProperty(wrappedFunction, \"name\", { value: fn.name });\n  Object.defineProperty(wrappedFunction, \"length\", { value: fn.length });\n\n  return wrappedFunction as T;\n}\n","/**\n * LangChain Callback Handler for AG-Kit Observability\n *\n * Converts LangChain callback events into AG-Kit observations with OpenInference semantics.\n */\n\nimport type { AgentAction, AgentFinish } from \"@langchain/core/agents\";\nimport { BaseCallbackHandler } from \"@langchain/core/callbacks/base\";\nimport type { Document } from \"@langchain/core/documents\";\nimport type { Serialized } from \"@langchain/core/load/serializable\";\nimport {\n  AIMessage,\n  AIMessageChunk,\n  BaseMessage,\n  type UsageMetadata,\n  type BaseMessageFields,\n  type MessageContent,\n} from \"@langchain/core/messages\";\nimport type { Generation, LLMResult } from \"@langchain/core/outputs\";\nimport type { ChainValues } from \"@langchain/core/utils/types\";\n\nimport {\n  startObservation,\n  type ObservationLLM,\n  type ObservationSpan,\n  type ObservationTool,\n  type Observation,\n  type ObservationAttributes,\n} from \"../index.js\";\nimport type { SpanContext } from \"@opentelemetry/api\";\nimport { type Logger, noopLogger } from \"@cloudbase/agent-shared\";\n\n/**\n * Constructor parameters for CallbackHandler.\n *\n * @public\n */\ntype ConstructorParams = {\n  userId?: string;\n  sessionId?: string;\n  tags?: string[];\n  version?: string;\n  traceMetadata?: Record<string, unknown>;\n  adapterName?: string;  // e.g., \"LangGraph\" or \"LangChain\"\n  /** Logger for debug output. Defaults to noopLogger (silent). */\n  logger?: Logger;\n};\n\n/**\n * Message format for LLM input/output.\n *\n * @public\n */\nexport type LlmMessage = {\n  role: string;\n  content: BaseMessageFields[\"content\"];\n  additional_kwargs?: BaseMessageFields[\"additional_kwargs\"];\n};\n\n/**\n * Anonymous message format (without role).\n *\n * @public\n */\nexport type AnonymousLlmMessage = {\n  content: BaseMessageFields[\"content\"];\n  additional_kwargs?: BaseMessageFields[\"additional_kwargs\"];\n};\n\n/**\n * Prompt information for linking to generations.\n *\n * @public\n */\ntype PromptInfo = {\n  name: string;\n  version: number;\n  isFallback: boolean;\n};\n\n/**\n * LangChain Callback Handler for AG-Kit Observability.\n *\n * This handler intercepts LangChain callbacks and converts them into\n * AG-Kit observations following OpenInference semantic conventions.\n *\n * @public\n */\nexport class CallbackHandler extends BaseCallbackHandler {\n  name = \"ObservabilityCallbackHandler\";\n\n  private userId?: string;\n  private version?: string;\n  private sessionId?: string;\n  private tags: string[];\n  private traceMetadata?: Record<string, unknown>;\n\n  private completionStartTimes: Record<string, Date> = {};\n  private promptToParentRunMap;\n  private runMap: Map<string, Observation> = new Map();\n\n  public last_trace_id: string | null = null;\n\n  // External parent context from AG-UI.Server span\n  private externalParentSpanContext?: SpanContext;\n\n  // Adapter name for ROOT span prefix\n  private adapterName?: string;\n\n  // Logger for debug output (defaults to noopLogger for silent operation)\n  private logger: Logger;\n\n  constructor(params?: ConstructorParams) {\n    super();\n\n    this.sessionId = params?.sessionId;\n    this.userId = params?.userId;\n    this.tags = params?.tags ?? [];\n    this.traceMetadata = params?.traceMetadata;\n    this.version = params?.version;\n    this.adapterName = params?.adapterName;\n    this.logger = params?.logger ?? noopLogger;\n\n    this.promptToParentRunMap = new Map<string, PromptInfo>();\n  }\n\n  /**\n   * Set external parent SpanContext from AG-UI.Server span.\n   * This allows the CallbackHandler to link LangChain/LangGraph spans\n   * to the server-level span, creating a unified trace hierarchy.\n   *\n   * @param spanContext - SpanContext from the AG-UI.Server span\n   * @public\n   */\n  setExternalParentContext(spanContext: SpanContext): void {\n    this.externalParentSpanContext = spanContext;\n  }\n\n  async handleLLMNewToken(\n    token: string,\n    _idx: any,\n    runId: string,\n    _parentRunId?: string,\n    _tags?: string[],\n    _fields?: any\n  ): Promise<void> {\n    if (runId && !(runId in this.completionStartTimes)) {\n      this.logger.debug?.(`LLM first streaming token: ${runId}`);\n      this.completionStartTimes[runId] = new Date();\n    }\n  }\n\n  async handleChainStart(\n    chain: Serialized,\n    inputs: ChainValues,\n    runId: string,\n    parentRunId?: string | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    runType?: string,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Chain start with Id: ${runId}`);\n\n      const runName = name ?? chain.id.at(-1)?.toString() ?? \"Langchain Run\";\n\n      this.registerPromptInfo(parentRunId, metadata);\n\n      let finalInput: string | ChainValues = inputs;\n      if (\n        typeof inputs === \"object\" &&\n        \"input\" in inputs &&\n        Array.isArray(inputs[\"input\"]) &&\n        inputs[\"input\"].every((m: unknown) => m instanceof BaseMessage)\n      ) {\n        finalInput = inputs[\"input\"].map((m: BaseMessage) =>\n          this.extractChatMessageContent(m)\n        );\n      } else if (\n        typeof inputs === \"object\" &&\n        \"messages\" in inputs &&\n        Array.isArray(inputs[\"messages\"]) &&\n        inputs[\"messages\"].every((m: unknown) => m instanceof BaseMessage)\n      ) {\n        finalInput = inputs[\"messages\"].map((m: BaseMessage) =>\n          this.extractChatMessageContent(m)\n        );\n      } else if (\n        typeof inputs === \"object\" &&\n        \"content\" in inputs &&\n        typeof inputs[\"content\"] === \"string\"\n      ) {\n        finalInput = inputs[\"content\"];\n      }\n\n      const observation = this.startAndRegisterObservation({\n        runName,\n        parentRunId,\n        runId,\n        tags,\n        metadata,\n        attributes: {\n          input: finalInput,\n        },\n        asType: \"span\",\n      });\n\n      const traceTags = [...new Set([...(tags ?? []), ...this.tags])];\n\n      if (!parentRunId) {\n        observation.updateTrace({\n          tags: traceTags,\n          userId:\n            metadata &&\n            \"userId\" in metadata &&\n            typeof metadata[\"userId\"] === \"string\"\n              ? metadata[\"userId\"]\n              : this.userId,\n          sessionId:\n            metadata &&\n            \"sessionId\" in metadata &&\n            typeof metadata[\"sessionId\"] === \"string\"\n              ? metadata[\"sessionId\"]\n              : this.sessionId,\n          metadata: this.traceMetadata,\n          version: this.version,\n        });\n      }\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleAgentAction(\n    action: AgentAction,\n    runId: string,\n    parentRunId?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Agent action ${action.tool} with ID: ${runId}`);\n      this.startAndRegisterObservation({\n        runId,\n        parentRunId,\n        runName: action.tool,\n        attributes: {\n          input: action,\n        },\n        asType: \"tool\",\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleAgentEnd?(\n    action: AgentFinish,\n    runId: string,\n    _parentRunId?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Agent finish with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: { output: action },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleChainError(\n    err: any,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Chain error: ${err} with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          level: \"ERROR\",\n          statusMessage: err.toString(),\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleGenerationStart(\n    llm: Serialized,\n    messages: (LlmMessage | MessageContent | AnonymousLlmMessage)[],\n    runId: string,\n    parentRunId?: string | undefined,\n    extraParams?: Record<string, unknown> | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    this.logger.debug?.(\n      `Generation start with ID: ${runId} and parentRunId ${parentRunId}`\n    );\n\n    const runName = name ?? llm.id.at(-1)?.toString() ?? \"Langchain Generation\";\n\n    const modelParameters: Record<string, any> = {};\n    const invocationParams = extraParams?.[\"invocation_params\"];\n\n    for (const [key, value] of Object.entries({\n      temperature: (invocationParams as any)?.temperature,\n      max_tokens: (invocationParams as any)?.max_tokens,\n      top_p: (invocationParams as any)?.top_p,\n      frequency_penalty: (invocationParams as any)?.frequency_penalty,\n      presence_penalty: (invocationParams as any)?.presence_penalty,\n      request_timeout: (invocationParams as any)?.request_timeout,\n    })) {\n      if (value !== undefined && value !== null) {\n        modelParameters[key] = value;\n      }\n    }\n\n    interface InvocationParams {\n      _type?: string;\n      model?: string;\n      model_name?: string;\n      repo_id?: string;\n    }\n\n    let extractedModelName: string | undefined;\n    if (extraParams) {\n      const invocationParamsModelName = (\n        extraParams.invocation_params as InvocationParams\n      ).model;\n      const metadataModelName =\n        metadata && \"ls_model_name\" in metadata\n          ? (metadata[\"ls_model_name\"] as string)\n          : undefined;\n\n      extractedModelName = invocationParamsModelName ?? metadataModelName;\n    }\n\n    const registeredPrompt = this.promptToParentRunMap.get(\n      parentRunId ?? \"root\"\n    );\n    if (registeredPrompt && parentRunId) {\n      this.deregisterPromptInfo(parentRunId);\n    }\n\n    this.startAndRegisterObservation({\n      runId,\n      parentRunId,\n      metadata,\n      tags,\n      runName,\n      attributes: {\n        input: messages,\n        model: extractedModelName,\n        modelParameters: modelParameters,\n      },\n      asType: \"llm\",\n    });\n  }\n\n  async handleChatModelStart(\n    llm: Serialized,\n    messages: BaseMessage[][],\n    runId: string,\n    parentRunId?: string | undefined,\n    extraParams?: Record<string, unknown> | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Chat model start with ID: ${runId}`);\n\n      const prompts = messages.flatMap((message) =>\n        message.map((m) => this.extractChatMessageContent(m))\n      );\n\n      this.handleGenerationStart(\n        llm,\n        prompts,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleChainEnd(\n    outputs: ChainValues,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Chain end with ID: ${runId}`);\n\n      let finalOutput: ChainValues | string = outputs;\n      if (\n        typeof outputs === \"object\" &&\n        \"output\" in outputs &&\n        typeof outputs[\"output\"] === \"string\"\n      ) {\n        finalOutput = outputs[\"output\"];\n      } else if (\n        typeof outputs === \"object\" &&\n        \"messages\" in outputs &&\n        Array.isArray(outputs[\"messages\"]) &&\n        outputs[\"messages\"].every((m: unknown) => m instanceof BaseMessage)\n      ) {\n        finalOutput = {\n          messages: outputs.messages.map((message: BaseMessage) =>\n            this.extractChatMessageContent(message)\n          ),\n        };\n      }\n\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          output: finalOutput,\n        },\n      });\n      this.deregisterPromptInfo(runId);\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleLLMStart(\n    llm: Serialized,\n    prompts: string[],\n    runId: string,\n    parentRunId?: string | undefined,\n    extraParams?: Record<string, unknown> | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`LLM start with ID: ${runId}`);\n      this.handleGenerationStart(\n        llm,\n        prompts,\n        runId,\n        parentRunId,\n        extraParams,\n        tags,\n        metadata,\n        name\n      );\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleToolStart(\n    tool: Serialized,\n    input: string,\n    runId: string,\n    parentRunId?: string | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Tool start with ID: ${runId}`);\n      this.startAndRegisterObservation({\n        runId,\n        parentRunId,\n        runName: name ?? tool.id.at(-1)?.toString() ?? \"Tool execution\",\n        attributes: {\n          input,\n        },\n        metadata,\n        tags,\n        asType: \"tool\",\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleRetrieverStart(\n    retriever: Serialized,\n    query: string,\n    runId: string,\n    parentRunId?: string | undefined,\n    tags?: string[] | undefined,\n    metadata?: Record<string, unknown> | undefined,\n    name?: string\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Retriever start with ID: ${runId}`);\n      this.startAndRegisterObservation({\n        runId,\n        parentRunId,\n        runName: name ?? retriever.id.at(-1)?.toString() ?? \"Retriever\",\n        attributes: {\n          input: query,\n        },\n        tags,\n        metadata,\n        asType: \"span\",\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleRetrieverEnd(\n    documents: Document<Record<string, any>>[],\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Retriever end with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          output: documents,\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleRetrieverError(\n    err: any,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Retriever error: ${err} with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          level: \"ERROR\",\n          statusMessage: err.toString(),\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleToolEnd(\n    output: string,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Tool end with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: { output },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleToolError(\n    err: any,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`Tool error ${err} with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          level: \"ERROR\",\n          statusMessage: err.toString(),\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleLLMEnd(\n    output: LLMResult,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`LLM end with ID: ${runId}`);\n\n      const lastResponse =\n        output.generations[output.generations.length - 1][\n          output.generations[output.generations.length - 1].length - 1\n        ];\n      const llmUsage =\n        this.extractUsageMetadata(lastResponse) ??\n        output.llmOutput?.[\"tokenUsage\"];\n      const modelName = this.extractModelNameFromMetadata(lastResponse);\n\n      const usageDetails: Record<string, any> = {\n        input:\n          llmUsage?.input_tokens ??\n          (\"promptTokens\" in llmUsage ? llmUsage?.promptTokens : undefined),\n        output:\n          llmUsage?.output_tokens ??\n          (\"completionTokens\" in llmUsage\n            ? llmUsage?.completionTokens\n            : undefined),\n        total:\n          llmUsage?.total_tokens ??\n          (\"totalTokens\" in llmUsage ? llmUsage?.totalTokens : undefined),\n      };\n\n      if (llmUsage && \"input_token_details\" in llmUsage) {\n        for (const [key, val] of Object.entries(\n          llmUsage[\"input_token_details\"] ?? {}\n        )) {\n          usageDetails[`input_${key}`] = val;\n          if (\"input\" in usageDetails && typeof val === \"number\") {\n            usageDetails[\"input\"] = Math.max(0, usageDetails[\"input\"] - val);\n          }\n        }\n      }\n\n      if (llmUsage && \"output_token_details\" in llmUsage) {\n        for (const [key, val] of Object.entries(\n          llmUsage[\"output_token_details\"] ?? {}\n        )) {\n          usageDetails[`output_${key}`] = val;\n          if (\"output\" in usageDetails && typeof val === \"number\") {\n            usageDetails[\"output\"] = Math.max(0, usageDetails[\"output\"] - val);\n          }\n        }\n      }\n\n      const extractedOutput =\n        \"message\" in lastResponse\n          ? this.extractChatMessageContent(\n              lastResponse[\"message\"] as BaseMessage\n            )\n          : lastResponse.text;\n\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          model: modelName,\n          output: extractedOutput,\n          completionStartTime:\n            runId in this.completionStartTimes\n              ? this.completionStartTimes[runId]\n              : undefined,\n          usageDetails: usageDetails,\n        },\n      });\n\n      if (runId in this.completionStartTimes) {\n        delete this.completionStartTimes[runId];\n      }\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  async handleLLMError(\n    err: any,\n    runId: string,\n    _parentRunId?: string | undefined\n  ): Promise<void> {\n    try {\n      this.logger.debug?.(`LLM error ${err} with ID: ${runId}`);\n      this.handleObservationEnd({\n        runId,\n        attributes: {\n          level: \"ERROR\",\n          statusMessage: err.toString(),\n        },\n      });\n    } catch (e) {\n      this.logger.debug?.(e instanceof Error ? e.message : String(e));\n    }\n  }\n\n  private registerPromptInfo(\n    parentRunId?: string,\n    metadata?: Record<string, unknown>\n  ): void {\n    if (metadata && \"promptInfo\" in metadata && parentRunId) {\n      this.promptToParentRunMap.set(\n        parentRunId,\n        metadata.promptInfo as PromptInfo\n      );\n    }\n  }\n\n  private deregisterPromptInfo(runId: string): void {\n    this.promptToParentRunMap.delete(runId);\n  }\n\n  private startAndRegisterObservation(params: {\n    runName: string;\n    runId: string;\n    parentRunId?: string;\n    attributes: Record<string, unknown>;\n    metadata?: Record<string, unknown>;\n    tags?: string[];\n    asType?: \"span\" | \"llm\" | \"tool\";\n  }): Observation {\n    const { runName, runId, parentRunId, attributes, metadata, tags, asType } =\n      params;\n\n    // Determine parent context:\n    // 1. If parentRunId exists, use the parent span from runMap (internal LangChain/LangGraph hierarchy)\n    // 2. If no parentRunId (ROOT span) but externalParentSpanContext exists, use it (link to AG-UI.Server)\n    // 3. Otherwise, create a new root span\n    let parentSpanContext: SpanContext | undefined;\n\n    if (parentRunId) {\n      // Internal parent from LangChain/LangGraph\n      parentSpanContext = this.runMap.get(parentRunId)?.otelSpan.spanContext();\n    } else if (this.externalParentSpanContext) {\n      // External parent from AG-UI.Server\n      parentSpanContext = this.externalParentSpanContext;\n    }\n\n    // Add adapter name prefix to ROOT span\n    let finalRunName = runName;\n    if (!parentRunId && this.adapterName) {\n      // ROOT span: add Adapter.LangGraph or Adapter.LangChain prefix\n      finalRunName = `Adapter.${this.adapterName}`;\n    }\n\n    const observation = startObservation(\n      finalRunName,\n      {\n        version: this.version,\n        metadata: this.joinTagsAndMetaData(tags, metadata),\n        ...attributes,\n      },\n      {\n        asType: asType ?? \"span\",\n        parentSpanContext,\n      }\n    );\n    this.runMap.set(runId, observation);\n\n    return observation;\n  }\n\n  private handleObservationEnd(params: {\n    runId: string;\n    attributes?: Record<string, unknown>;\n  }) {\n    const { runId, attributes = {} } = params;\n\n    const observation = this.runMap.get(runId);\n    if (!observation) {\n      this.logger.warn?.(\"Observation not found in runMap. Skipping operation.\");\n      return;\n    }\n\n    // Type-safe update: cast to ObservationAttributes which is the union of all observation attribute types\n    observation.update(attributes as ObservationAttributes).end();\n\n    this.last_trace_id = observation.traceId;\n    this.runMap.delete(runId);\n  }\n\n  private joinTagsAndMetaData(\n    tags?: string[] | undefined,\n    metadata1?: Record<string, unknown> | undefined,\n    metadata2?: Record<string, unknown> | undefined\n  ): Record<string, unknown> | undefined {\n    const finalDict: Record<string, unknown> = {};\n    if (tags && tags.length > 0) {\n      finalDict.tags = tags;\n    }\n    if (metadata1) {\n      Object.assign(finalDict, metadata1);\n    }\n    if (metadata2) {\n      Object.assign(finalDict, metadata2);\n    }\n    return this.stripObservabilityKeysFromMetadata(finalDict);\n  }\n\n  private stripObservabilityKeysFromMetadata(\n    metadata?: Record<string, unknown>\n  ): Record<string, unknown> | undefined {\n    if (!metadata) {\n      return;\n    }\n\n    const reservedKeys = [\"promptInfo\", \"userId\", \"sessionId\"];\n\n    return Object.fromEntries(\n      Object.entries(metadata).filter(([key, _]) => !reservedKeys.includes(key))\n    );\n  }\n\n  private extractUsageMetadata(\n    generation: Generation\n  ): UsageMetadata | undefined {\n    try {\n      const usageMetadata =\n        \"message\" in generation &&\n        (AIMessage.isInstance(generation[\"message\"]) ||\n          AIMessageChunk.isInstance(generation[\"message\"]))\n          ? generation[\"message\"].usage_metadata\n          : undefined;\n      return usageMetadata;\n    } catch (err) {\n      this.logger.debug?.(`Error extracting usage metadata: ${err}`);\n      return;\n    }\n  }\n\n  private extractModelNameFromMetadata(generation: any): string | undefined {\n    try {\n      return \"message\" in generation &&\n        (AIMessage.isInstance(generation[\"message\"]) ||\n          AIMessageChunk.isInstance(generation[\"message\"]))\n        ? generation[\"message\"].response_metadata.model_name\n        : undefined;\n    } catch {}\n  }\n\n  private extractChatMessageContent(\n    message: BaseMessage\n  ): LlmMessage | AnonymousLlmMessage | MessageContent {\n    let response = undefined;\n\n    if (message.getType() === \"human\") {\n      response = { content: message.content, role: \"user\" };\n    } else if (message.getType() === \"generic\") {\n      response = {\n        content: message.content,\n        role: \"human\",\n      };\n    } else if (message.getType() === \"ai\") {\n      response = { content: message.content, role: \"assistant\" };\n\n      if (\n        \"tool_calls\" in message &&\n        Array.isArray(message.tool_calls) &&\n        (message.tool_calls?.length ?? 0) > 0\n      ) {\n        (response as any)[\"tool_calls\"] = message[\"tool_calls\"];\n      }\n      if (\n        \"additional_kwargs\" in message &&\n        \"tool_calls\" in message[\"additional_kwargs\"]\n      ) {\n        (response as any)[\"tool_calls\"] =\n          message[\"additional_kwargs\"][\"tool_calls\"];\n      }\n    } else if (message.getType() === \"system\") {\n      response = { content: message.content, role: \"system\" };\n    } else if (message.getType() === \"function\") {\n      response = {\n        content: message.content,\n        additional_kwargs: message.additional_kwargs,\n        role: message.name,\n      };\n    } else if (message.getType() === \"tool\") {\n      response = {\n        content: message.content,\n        additional_kwargs: message.additional_kwargs,\n        role: message.name,\n      };\n    } else if (!message.name) {\n      response = { content: message.content };\n    } else {\n      response = {\n        role: message.name,\n        content: message.content,\n      };\n    }\n\n    if (\n      (message.additional_kwargs.function_call ||\n        message.additional_kwargs.tool_calls) &&\n      (response as any)[\"tool_calls\"] === undefined\n    ) {\n      return { ...response, additional_kwargs: message.additional_kwargs };\n    }\n\n    return response;\n  }\n}\n"],"mappings":"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","names":["import_openinference_semantic_conventions","import_api"]}